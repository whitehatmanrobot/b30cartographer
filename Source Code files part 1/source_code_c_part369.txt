          sizeof(LDAP_PAGED_RESULT_OID_STRING) ) == 2)) ) {

                lber = new CLdapBer( connection->publicLdapStruct.ld_version );

                if (lber == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint1( "LdapParsePageControl: unable to alloc msg for 0x%x.\n",
                                    connection );
                    }

                    err = LDAP_NO_MEMORY;
                    break;
                }

                err = lber->HrLoadBer(   (const BYTE *) currentControl->ldctl_value.bv_val,
                                         currentControl->ldctl_value.bv_len,
                                         &bytesTaken,
                                         TRUE );    // we have the whole message guarenteed

                if (err != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParsePageControl: loadBer error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    break;
                }

                err = lber->HrStartReadSequence();
                if (err != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParsePageControl: loadBer error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    break;
                }

                err = lber->HrGetValue( &totalCount );
                if (err != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParsePageControl: loadBer error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    break;
                }

                if (TotalCount != NULL) {

                    *TotalCount = totalCount;
                }

                if (Cookie != NULL) {

                    struct berval *cookie;
                    PBYTE *ppbBuf = NULL;

                    cookie = (struct berval *) ldapMalloc(
                                sizeof( struct berval ),
                                LDAP_BERVAL_SIGNATURE );

                    if (cookie == NULL) {

                        err = LDAP_NO_MEMORY;
                        IF_DEBUG(PARSE) {
                            LdapPrint1( "LdapParsePageControl: couldn't alloc berval for 0x%x.\n",
                                        connection );
                        }
                        break;
                    }

                    err = lber->HrGetBinaryValuePointer( (PBYTE *) &ppbBuf,
                                                         &cookie->bv_len );

                    if (ppbBuf != NULL) {

                        cookie->bv_val = (PCHAR)
                                ldapMalloc( cookie->bv_len,
                                            LDAP_CONTROL_SIGNATURE );

                        if (cookie->bv_val == NULL) {

                            err = LDAP_NO_MEMORY;
                            ber_bvfree( cookie );
                            break;
                        }

                        CopyMemory( cookie->bv_val,
                                    ppbBuf,
                                    cookie->bv_len );
                    } else {

                        cookie->bv_len = 0;
                        cookie->bv_val = NULL;
                    }

                    *Cookie = cookie;
                }

                err = LDAP_SUCCESS;
                break;                  // done with loop... look no more
            }
            controls++;
        }
    }

    if (lber != NULL) {

        delete lber;
    }

    SetConnectionError( connection, err, NULL );
    return err;
}



ULONG
LdapEncodeVlvControl (
    PLDAP_CONN      connection,
    PLDAPControlW   OutputControl,
    PLDAPVLVInfo    VlvInfo,
    BOOLEAN         Criticality,
    ULONG           CodePage
    )
{
    ULONG err = LDAP_PARAM_ERROR;
    CLdapBer *lber = NULL;
    ULONG hr = NOERROR;

    if ((connection == NULL) ||
        (OutputControl == NULL) ||
        (VlvInfo->ldvlv_version != LDAP_VLVINFO_VERSION) ||
        (!IsLdapInteger( (int) VlvInfo->ldvlv_before_count)) ||
        (!IsLdapInteger( (int) VlvInfo->ldvlv_after_count))  ||
        ((VlvInfo->ldvlv_attrvalue == NULL) &&
         (!IsLdapInteger( (int) VlvInfo->ldvlv_offset) ||
          !IsLdapInteger( (int) VlvInfo->ldvlv_count)))) {

        return LDAP_PARAM_ERROR;
    }

    OutputControl->ldctl_oid = NULL;
    OutputControl->ldctl_iscritical = Criticality;

    if (CodePage == LANG_UNICODE) {

        OutputControl->ldctl_oid = ldap_dup_stringW( LDAP_CONTROL_VLVREQUEST_W,
                                                     0,
                                                     LDAP_VALUE_SIGNATURE );
    } else {

        OutputControl->ldctl_oid = (PWCHAR) ldap_dup_string(  LDAP_CONTROL_VLVREQUEST,
                                                              0,
                                                              LDAP_VALUE_SIGNATURE );
    }

    if (OutputControl->ldctl_oid == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodeVlvControl;
    }

    lber = new CLdapBer( connection->publicLdapStruct.ld_version );

    if (lber == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodeVlvControl;
    }

    //
    // VirtualListViewRequest ::= SEQUENCE {
    //    beforeCount    INTEGER (0 .. maxInt),
    //    afterCount     INTEGER (0 .. maxInt),
    //    CHOICE {
    //            byoffset [0] SEQUENCE, {
    //                           offset           INTEGER (0 .. maxInt),
    //                           contentCount    INTEGER (0 .. maxInt)  
    //                          }
    //                     [1] greaterThanOrEqual assertionValue
    //            }
    //
    //    contextID     OCTET STRING OPTIONAL
    //
    //    }
    //

    hr = lber->HrStartWriteSequence();

    if (hr != NOERROR) {
        goto exitEncodeVlvControl;
    }

    hr = lber->HrAddValue( (LONG) VlvInfo->ldvlv_before_count );

    if (hr != NOERROR) {
        goto exitEncodeVlvControl;
    }
    
    hr = lber->HrAddValue( (LONG) VlvInfo->ldvlv_after_count );
    
    if (hr != NOERROR) {
        goto exitEncodeVlvControl;
    }


    if ( VlvInfo->ldvlv_attrvalue != NULL ) {

        //
        // We have an assertion value to encode. For some strange reason
        // Netscape seems to expect 0x81 instead of 0xA1. Is this a bug
        // in Netscape?
        //

        hr = lber->HrAddBinaryValue((BYTE *) VlvInfo->ldvlv_attrvalue->bv_val,
                                     VlvInfo->ldvlv_attrvalue->bv_len,
                                     0x80 | 0x1  );

    } else {

        //
        // We will use the offset & content count.
        // Constructed/context specific/tag is 0
        //

        hr = lber->HrStartWriteSequence( 0xA0 | 0x0 );

        if (hr != NOERROR) {
            goto exitEncodeVlvControl;
        }

        hr = lber->HrAddValue( (LONG) VlvInfo->ldvlv_offset );
        
        if (hr != NOERROR) {
            goto exitEncodeVlvControl;
        }

        hr = lber->HrAddValue( (LONG) VlvInfo->ldvlv_count );

        if (hr != NOERROR) {
            goto exitEncodeVlvControl;
        }
    
        hr = lber->HrEndWriteSequence();
    }

    if (hr != NOERROR) {
        goto exitEncodeVlvControl;
    }
    
    //
    // Finally, encode the context cookie if it exists.
    //

    if ( VlvInfo->ldvlv_context && VlvInfo->ldvlv_context->bv_len ) {

        hr = lber->HrAddBinaryValue((PBYTE) VlvInfo->ldvlv_context->bv_val,
                                    VlvInfo->ldvlv_context->bv_len
                                    );
    }
    
    if (hr != NOERROR) {
        goto exitEncodeVlvControl;
    }
    
    hr = lber->HrEndWriteSequence();
    ASSERT( hr == NOERROR );

    OutputControl->ldctl_value.bv_len = lber->CbData();

    if (OutputControl->ldctl_value.bv_len == 0) {

        err = LDAP_LOCAL_ERROR;
        goto exitEncodeVlvControl;
    }

    OutputControl->ldctl_value.bv_val = (PCHAR) ldapMalloc(
                            OutputControl->ldctl_value.bv_len,
                            LDAP_CONTROL_SIGNATURE );

    if (OutputControl->ldctl_value.bv_val == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodeVlvControl;
    }

    CopyMemory( OutputControl->ldctl_value.bv_val,
                lber->PbData(),
                OutputControl->ldctl_value.bv_len );

    err = LDAP_SUCCESS;

exitEncodeVlvControl:

    if (hr != NOERROR) {
        err = LDAP_DECODING_ERROR;
    }

    if (err != LDAP_SUCCESS) {

        if (OutputControl->ldctl_oid != NULL) {

            ldapFree( OutputControl->ldctl_oid, LDAP_VALUE_SIGNATURE );
            OutputControl->ldctl_oid = NULL;
        }

        OutputControl->ldctl_value.bv_len = 0;
    }

    if (lber != NULL) {
        delete lber;
    }
    
    return err;

}


ULONG
LdapCreateVlvControlWithAlloc (
        PLDAP            ExternalHandle,
        PLDAPVLVInfo     VlvInfo,
        PLDAPControlW   *Control,
        UCHAR            IsCritical,
        ULONG            CodePage
    )
{

    ULONG err;
    PLDAPControlW  control = NULL;
    PLDAP_CONN connection = NULL;
    BOOLEAN criticality = ( (IsCritical > 0) ? TRUE : FALSE );

    connection = GetConnectionPointer( ExternalHandle );

    if ((connection == NULL) || (Control == NULL) || (VlvInfo == NULL)) {
        err = LDAP_PARAM_ERROR;
        goto error;
    }

    control = (PLDAPControlW) ldapMalloc( sizeof( LDAPControlW ), LDAP_CONTROL_SIGNATURE );

    if (control == NULL) {

        *Control = NULL;
        err = LDAP_NO_MEMORY;
        goto error;
    }

    err = LdapEncodeVlvControl( connection,
                                control,
                                VlvInfo,
                                criticality,
                                CodePage
                                );

    if (err != LDAP_SUCCESS) {

        ldap_control_freeW( control );
        control = NULL;
    }

    *Control = control;

error:

    if (connection) {
        DereferenceLdapConnection( connection );
    }

    return err;

}


WINLDAPAPI
INT LDAPAPI
ldap_create_vlv_controlW (
    PLDAP            ExternalHandle,
    PLDAPVLVInfo     VlvInfo,
    UCHAR            IsCritical,
    PLDAPControlW    *Control
    )
{

    return LdapCreateVlvControlWithAlloc( ExternalHandle,
                                          VlvInfo,
                                          Control,
                                          IsCritical,
                                          LANG_UNICODE
                                          );

}

WINLDAPAPI
INT LDAPAPI
ldap_create_vlv_controlA (
    PLDAP            ExternalHandle,
    PLDAPVLVInfo     VlvInfo,
    UCHAR            IsCritical,
    PLDAPControlA    *Control
    )
{

    return LdapCreateVlvControlWithAlloc( ExternalHandle,
                                          VlvInfo,
                                          (PLDAPControlW  *)Control,
                                          IsCritical,
                                          LANG_ACP
                                          );

}


ULONG
LdapParseVlvControl (
        PLDAP_CONN      connection,
        PLDAPControlW  *ServerControls,
        ULONG          *TargetPos,
        ULONG          *ListCount,
        PBERVAL        *Context,
        INT            *Error,
        ULONG           CodePage
        )
{
    ULONG err = LDAP_CONTROL_NOT_FOUND;
    CLdapBer *lber = NULL;
    ULONG hr = NOERROR;

    //
    //  First thing is to zero out the parms passed in.
    //

    if (TargetPos != NULL) {

        *TargetPos = 0;
    }

    if (ListCount != NULL) {

        *ListCount = 0;
    }

    if (Error != NULL) {

        *Error = LDAP_SUCCESS;
    }

    if (Context != NULL) {

        *Context = NULL;
    }
    
    if (ServerControls != NULL) {

        PLDAPControlW *controls = ServerControls;
        PLDAPControlW currentControl;
        ULONG bytesTaken;
        LONG  vlvError = 0;
        ULONG targetPosition = 0;
        ULONG ContentCount = 0;

        while (*controls != NULL) {

            currentControl = *controls;

            //
            //  check to see if the current control is the VLV control
            //

            if ( ((CodePage == LANG_UNICODE) &&
                  ( ldapWStringsIdentical( currentControl->ldctl_oid,
                                           -1,
                                           LDAP_CONTROL_VLVRESPONSE_W,
                                           -1 ) == TRUE )) ||
                 ((CodePage == LANG_ACP) &&
                  ( CompareStringA( LDAP_DEFAULT_LOCALE,
                                    NORM_IGNORECASE,
                                    (PCHAR) currentControl->ldctl_oid,
                                    -1,
                                    LDAP_CONTROL_VLVRESPONSE,
                                    sizeof(LDAP_CONTROL_VLVRESPONSE) ) == 2)) ) {

                lber = new CLdapBer( connection->publicLdapStruct.ld_version );

                if (lber == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint1( "LdapParseVlvControl: unable to alloc msg for 0x%x.\n",
                                    connection );
                    }

                    err = LDAP_NO_MEMORY;
                    break;
                }

                hr = lber->HrLoadBer(   (const BYTE *) currentControl->ldctl_value.bv_val,
                                         currentControl->ldctl_value.bv_len,
                                         &bytesTaken,
                                         TRUE );    // we have the whole message guarenteed

                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseVlvControl: loadBer error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    err = LDAP_DECODING_ERROR;
                    break;
                }

                hr = lber->HrStartReadSequence();
                
                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseVlvControl: loadBer error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    err = LDAP_DECODING_ERROR;
                    break;
                }

                hr = lber->HrGetValue( (PLONG) &targetPosition );

                if ((hr != NOERROR) || !IsLdapInteger( (int) targetPosition )) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseVlvControl: TargetPos read error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    err = LDAP_DECODING_ERROR;
                    break;
                }
                
                hr = lber->HrGetValue( (PLONG) &ContentCount );

                if ((hr != NOERROR) || !IsLdapInteger( (int) ContentCount )) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseVlvControl: ListCount read error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    err = LDAP_DECODING_ERROR;
                    break;
                }
                
                hr = lber->HrGetEnumValue( &vlvError );
                
                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseVlvControl: getEnumValue error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    err = LDAP_DECODING_ERROR;
                    break;
                }

                if (TargetPos != NULL) {

                    *TargetPos = targetPosition;
                }

                if (ListCount != NULL) {

                    *ListCount = ContentCount;
                }

                if (Error != NULL) {

                    *Error = vlvError;
                }

                if (Context != NULL) {

                    struct berval *cookie;
                    PBYTE *ppbBuf = NULL;

                    cookie = (struct berval *) ldapMalloc(
                                sizeof( struct berval ),
                                LDAP_BERVAL_SIGNATURE );

                    if (cookie == NULL) {

                        err = LDAP_NO_MEMORY;
                        IF_DEBUG(PARSE) {
                            LdapPrint1( "LdapParseVlvControl: couldn't alloc berval for 0x%x.\n",
                                        connection );
                        }
                        break;
                    }

                    err = lber->HrGetBinaryValuePointer( (PBYTE *) &ppbBuf,
                                                         &cookie->bv_len );

                    if (ppbBuf != NULL) {

                        cookie->bv_val = (PCHAR)
                                ldapMalloc( cookie->bv_len,
                                            LDAP_CONTROL_SIGNATURE );

                        if (cookie->bv_val == NULL) {

                            err = LDAP_NO_MEMORY;
                            ber_bvfree( cookie );
                            break;
                        }

                        CopyMemory( cookie->bv_val,
                                    ppbBuf,
                                    cookie->bv_len );
                    } else {

                        ber_bvfree( cookie );
                        cookie = NULL;
                    }

                    *Context = cookie;
                }

                err = LDAP_SUCCESS;
                break;                  // done with loop... look no more
            }
            controls++;
        }
    }

    if (lber != NULL) {

        delete lber;
    }

    SetConnectionError( connection, err, NULL );
    return err;
}

WINLDAPAPI
INT LDAPAPI
ldap_parse_vlv_controlW (
        PLDAP             ExternalHandle,
        PLDAPControlW    *Control,
        ULONG            *TargetPos,
        ULONG            *ListCount,
        PBERVAL          *Context,
        PINT              ErrCode
    )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err  = LdapParseVlvControl(    connection,
                                   Control,
                                   TargetPos,
                                   ListCount,
                                   Context,
                                   ErrCode,
                                   LANG_UNICODE );

    DereferenceLdapConnection( connection );

    return err;

}


WINLDAPAPI
INT LDAPAPI
ldap_parse_vlv_controlA (
        PLDAP             ExternalHandle,
        PLDAPControlA    *Control,
        ULONG            *TargetPos,
        ULONG            *ListCount,
        PBERVAL          *Context,
        PINT              ErrCode
    )
{

    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err  = LdapParseVlvControl(    connection,
                                   (PLDAPControlW *)Control,
                                   TargetPos,
                                   ListCount,
                                   Context,
                                   ErrCode,
                                   LANG_ACP );

    DereferenceLdapConnection( connection );

    return err;

}



// paged.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\parse.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    parse.cxx extended parse of results from LDAP servers

Abstract:

   This module implements the APIs to break up LDAP responses into components

Author:

    Andy Herron (andyhe)        16-Apr-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG LdapParseResult (
        PLDAP_CONN connection,
        LDAPMessage *ResultMessage,
        ULONG *ReturnCode OPTIONAL,          // returned by server
        PWCHAR *MatchedDNs OPTIONAL,         // free with ldap_value_freeW
        PWCHAR *ErrorMessage OPTIONAL,       // free with ldap_value_freeW
        PWCHAR **Referrals OPTIONAL,         // free with ldap_value_freeW
        PLDAPControlW **ServerControls OPTIONAL,
        BOOLEAN Freeit,
        ULONG codePage
        )
//
//  This is one of the main entry points of the LDAP API... it returns the
//  error code that the server returned to a requesting client.  We've already
//  parsed out the return code so there's not much work.
//
{
    ULONG err;
    CLdapBer *lber;
    ULONG hr;
    ULONG tag;

    //
    //  since we return -1 on calls such as ldap_search as a message id, we'll
    //  explicitely check for it here.
    //

    if (ReturnCode != NULL) {

        *ReturnCode = 0;
    }
    if (MatchedDNs != NULL) {

        *MatchedDNs = NULL;
    }
    if (ErrorMessage != NULL) {

        *ErrorMessage = NULL;
    }
    if (Referrals != NULL) {

        *Referrals = NULL;
    }
    if (ServerControls != NULL) {

        *ServerControls = NULL;
    }

    if ( ResultMessage == (LDAPMessage *) -1 ) {

        ResultMessage = NULL;
    }

    LDAPMessage *checkResult = ResultMessage;

    while ((checkResult != NULL) &&
           ((checkResult->lm_msgtype == LDAP_RES_REFERRAL) ||
            (checkResult->lm_msgtype == LDAP_RES_SEARCH_ENTRY))) {

        checkResult = checkResult->lm_chain;
    }

    //
    //  return the result from the first non-search entry record.
    //

    if (checkResult == NULL) {

        IF_DEBUG(PARSE) {
            LdapPrint1( "LdapParseResult couldn't find result message for conn 0x%x\n",
                            connection);
        }
        return LDAP_NO_RESULTS_RETURNED;
    }

    lber = (CLdapBer *)checkResult->lm_ber;

    if (lber == NULL) {

        return LDAP_LOCAL_ERROR;
    }

    lber->Reset(FALSE);

    err = LdapInitialDecodeMessage( connection, checkResult );

    if (err != LDAP_SUCCESS) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "LdapParseResult couldn't decode message for conn 0x%x, result 0x%x.\n",
                            connection, err);
        }
        return err;
    }

    //
    //  LdapInitialDecodeMessage leaves the message parsed up to the error
    //  code.  we'll pick up the rest from there.
    //
    //      LDAPMessage ::= SEQUENCE {
    //              messageID       MessageID,
    //              protocolOp      CHOICE {  }
    //              controls       [0] Controls OPTIONAL }
    //
    //      LDAPResult ::= SEQUENCE {
    //              resultCode      ENUMERATED { };
    //              matchedDN       LDAPDN,
    //              errorMessage    LDAPString,
    //              referral        [3] Referral OPTIONAL }
    //
    //      Controls ::= SEQUENCE OF Control
    //
    //      Control ::= SEQUENCE {
    //              controlType             LDAPOID,
    //              criticality             BOOLEAN DEFAULT FALSE,
    //              controlValue            OCTET STRING OPTIONAL }
    //
    //      Referral ::= SEQUENCE OF LDAPURL
    //
    //      LDAPURL ::= LDAPString  -- limited to characters permitted in URLs
    //
    //      BindResponse ::= [APPLICATION 1] SEQUENCE {
    //           COMPONENTS OF LDAPResult,
    //           serverCreds        [7] SaslCredentials OPTIONAL }
    //
    //      For search, modify, add, rename, delete and compare... the
    //          response is just an LDAPResult
    //
    //      ExtendedResponse ::= [APPLICATION 24] SEQUENCE {
    //              COMPONENTS OF LDAPResult,
    //              responseName     [10] LDAPOID OPTIONAL,
    //              response         [11] OCTET STRING OPTIONAL }
    //

    if (ReturnCode != NULL) {
        *ReturnCode = checkResult->lm_returncode;
    }

    if (MatchedDNs != NULL) {

        if (codePage == LANG_UNICODE) {

            hr = lber->HrGetValueWithAlloc(MatchedDNs);

        } else {

            hr = lber->HrGetValueWithAlloc((PCHAR *) MatchedDNs);
        }

        if (*MatchedDNs != NULL) {

            ldapSwapTags( *MatchedDNs, LDAP_VALUE_SIGNATURE, LDAP_BUFFER_SIGNATURE );
        }

    } else {

        hr = lber->HrSkipElement();
    }

    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "LdapParseResult couldn't decode matchedDN for conn 0x%x, result 0x%x.\n",
                            connection, hr);
        }
        goto error;
    }

    if (ErrorMessage != NULL) {

        if (codePage == LANG_UNICODE) {

            hr = lber->HrGetValueWithAlloc(ErrorMessage);

        } else {

            hr = lber->HrGetValueWithAlloc((PCHAR *) ErrorMessage);
        }

        if (*ErrorMessage != NULL) {

            ldapSwapTags( *ErrorMessage, LDAP_VALUE_SIGNATURE, LDAP_BUFFER_SIGNATURE );
        }
    } else {

        hr = lber->HrSkipElement();
    }

    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "LdapParseResult couldn't decode errorMsg for conn 0x%x, result 0x%x.\n",
                            connection, hr);
        }
        goto error;
    }

    hr = lber->HrPeekTag( &tag );

    if (tag == (BER_CLASS_CONTEXT_SPECIFIC | BER_FORM_CONSTRUCTED | 0x03)) {

        if (Referrals != NULL) {

            ULONG resultCount = 0;      // current offset in table
            ULONG sizeResultTable = 2;  // current size of result table

            hr = lber->HrStartReadSequence( tag );

            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "LdapParseResult couldn't decode referrals for conn 0x%x, result 0x%x.\n",
                                    connection, hr);
                }
                goto error;
            }

            if (codePage == LANG_UNICODE) {

                PWCHAR *resultWStr = NULL;

                while (hr == NOERROR) {

                    PWCHAR attrWValue = NULL;

                    if ((resultWStr == NULL) ||
                        (resultCount >= (sizeResultTable-1))) {      // leave room for null

                        if (sizeResultTable < 256) {    // only increase table size slowly
                            sizeResultTable *= 2;
                        } else {
                            sizeResultTable += 256;
                        }

                        PWCHAR *newResultTable = (PWCHAR *) ldapMalloc( sizeof(PWCHAR) * sizeResultTable,
                                                            LDAP_VALUE_LIST_SIGNATURE );

                        if (newResultTable == NULL) {

                            IF_DEBUG(OUTMEMORY) {
                                LdapPrint2( "LdapParseResult conn 0x%x could not allocate mem of 0x%x .\n",
                                                connection, sizeof(PWCHAR) * sizeResultTable);
                            }
                            hr = LDAP_NO_MEMORY;
                            continue;
                        }

                        if (resultWStr != NULL) {

                            CopyMemory( newResultTable, resultWStr, sizeof(PWCHAR) * resultCount );
                            ldapFree( resultWStr, LDAP_VALUE_LIST_SIGNATURE );
                        }
                        resultWStr = newResultTable;
                    }

                    hr = lber->HrGetValueWithAlloc( &attrWValue );
                    if (hr != NOERROR) {

                        //
                        //  This will fail when we hit the end of the attribute list
                        //

                        IF_DEBUG(TRACE1) {
                            LdapPrint2( "LdapParseResult conn 0x%x received error 0x%x .\n",
                                            connection, hr);
                        }
                        continue;       // rest of results may be valid
                    }

                    *(resultWStr+resultCount) = attrWValue;
                    resultCount++;
                }
                *(resultWStr+resultCount) = NULL;

                *Referrals = resultWStr;

            } else {

                PCHAR *resultStr = NULL;

                //
                //  get the list of attribute values in form of single byte strings
                //

                while (hr == NOERROR) {

                    PCHAR attrValue = NULL;

                    if ((resultStr == NULL) ||
                        (resultCount >= (sizeResultTable-1))) {      // leave room for null

                        if (sizeResultTable < 256) {    // only increase table size slowly
                            sizeResultTable *= 2;
                        } else {
                            sizeResultTable += 256;
                        }

                        PCHAR *newResultTable = (PCHAR *) ldapMalloc( sizeof(PCHAR) * sizeResultTable,
                                                            LDAP_VALUE_LIST_SIGNATURE );

                        if (newResultTable == NULL) {

                            IF_DEBUG(OUTMEMORY) {
                                LdapPrint2( "LdapParseResult conn 0x%x could not allocate mem of 0x%x .\n",
                                                connection, sizeof(PCHAR) * sizeResultTable);
                            }
                            hr = LDAP_NO_MEMORY;
                            continue;
                        }

                        if (resultStr != NULL) {

                            CopyMemory( newResultTable, resultStr, sizeof(PCHAR) * resultCount );
                            ldapFree( resultStr, LDAP_VALUE_LIST_SIGNATURE );
                        }
                        resultStr = newResultTable;
                    }

                    hr = lber->HrGetValueWithAlloc( &attrValue );
                    if (hr != NOERROR) {

                        //
                        //  This will fail when we hit the end of the attribute list
                        //

                        IF_DEBUG(TRACE1) {
                            LdapPrint2( "LdapParseResult conn 0x%x received error 0x%x .\n",
                                            connection, hr);
                        }
                        continue;       // rest of results may be valid
                    }

                    *(resultStr+resultCount) = attrValue;
                    resultCount++;
                }
                *(resultStr+resultCount) = NULL;

                *Referrals = (PWCHAR *)resultStr;
            }

            hr = lber->HrEndReadSequence();
            ASSERT( hr == NOERROR );

        } else {

            hr = lber->HrSkipElement();
        }

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "LdapParseResult couldn't decode referrals for conn 0x%x, result 0x%x.\n",
                                connection, hr);
            }
            goto error;
        }

    }

    if (ServerControls != NULL) {

        hr = lber->HrEndReadSequence();
        ASSERT( hr == NOERROR );

        hr = lber->HrPeekTag( &tag );

        if (tag == (BER_CLASS_CONTEXT_SPECIFIC | BER_FORM_CONSTRUCTED | 0x00)) {

            hr = lber->HrStartReadSequence(tag);
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "LdapParseResult couldn't decode controls for conn 0x%x, result 0x%x.\n",
                                    connection, hr);
                }
                goto error;
            }

            hr = LdapRetrieveControlsFromMessage( ServerControls, codePage, lber );

            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "LdapParseResult couldn't parse controls for conn 0x%x, result 0x%x.\n",
                                    connection, hr);
                }
                goto error;
            }
        }
    }

    if ( Freeit ) {

        //
        //  if there are more searchResultDone messages, don't free the
        //  list of messages.
        //

        checkResult = checkResult->lm_chain;

        while ((checkResult != NULL) &&
               ((checkResult->lm_msgtype == LDAP_RES_REFERRAL) ||
                (checkResult->lm_msgtype == LDAP_RES_SEARCH_ENTRY))) {

            checkResult = checkResult->lm_chain;
        }

        if (checkResult != NULL) {

            return LDAP_MORE_RESULTS_TO_RETURN;
        }

        ldap_msgfree( ResultMessage );
    }

    return LDAP_SUCCESS;

error:

    ASSERT (hr != LDAP_SUCCESS);

    if (MatchedDNs && *MatchedDNs) {

        ldapFree(*MatchedDNs, LDAP_BUFFER_SIGNATURE);
        *MatchedDNs = NULL;
    }
    
    if (ErrorMessage && *ErrorMessage) {

        ldapFree(*ErrorMessage, LDAP_BUFFER_SIGNATURE);
        *ErrorMessage = NULL;
    }
    
    if (Referrals && *Referrals) {
        ldap_value_freeW(*Referrals);
        *Referrals = NULL;
    }
    
    if (ServerControls && *ServerControls) {
        ldap_controls_freeW(*ServerControls);
        *ServerControls = NULL;
    }


    return hr;
}

ULONG LdapParseExtendedResult (
        PLDAP_CONN      connection,
        LDAPMessage    *ResultMessage,
        PWCHAR         *ResultOID,
        struct berval **ResultData,
        BOOLEAN         Freeit,
        ULONG           codePage
        )
{
    ULONG      err;
    CLdapBer  *lber;
    ULONG    hr;
    ULONG      tag;

    if ( ResultOID != NULL ) {
      *ResultOID = NULL;
    }

    if ( ResultData != NULL ) {
      *ResultData = NULL;
    }

    if ( ResultMessage == (LDAPMessage *) -1 ) {
      ResultMessage = NULL;
    }

    LDAPMessage *checkResult = ResultMessage;

    if (checkResult == NULL) {

        IF_DEBUG(PARSE) {
            LdapPrint1( "LdapParseExtendedResult couldn't find result message for conn 0x%x\n",
                            connection);
        }
        return LDAP_NO_RESULTS_RETURNED;
    }

    lber = (CLdapBer *)checkResult->lm_ber;

    if (lber == NULL) {

        return LDAP_LOCAL_ERROR;
    }

    lber->Reset( FALSE );

    err = LdapInitialDecodeMessage( connection, checkResult );

    if (err != LDAP_SUCCESS) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "LdapParseResult couldn't decode message for conn 0x%x, result 0x%x.\n",
                            connection, err);
        }
        return err;
    }

    //
    //  LdapInitialDecodeMessage leaves the message parsed up to the error
    //  code.  we'll pick up the rest from there.
    //
    //      LDAPMessage ::= SEQUENCE {
    //              messageID       MessageID,
    //              protocolOp      CHOICE {...,ExtendedResponse,..  }
    //              controls       [0] Controls OPTIONAL }
    //
    //      ExtendedResponse ::= [APPLICATION 24] SEQUENCE {
    //              COMPONENTS OF LDAPResult,
    //              responseName     [10] LDAPOID OPTIONAL,
    //              response         [11] OCTET STRING OPTIONAL }
    //
    //      LDAPResult ::= SEQUENCE {
    //              resultCode      ENUMERATED { };
    //              matchedDN       LDAPDN,
    //              errorMessage    LDAPString,
    //              referral        [3] Referral OPTIONAL }

    // errorCode is consumed by LdapDecodeInitialMessage


    // skip MatchedDN
    hr = lber->HrSkipElement();
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "LdapParseExtendedResult couldn't decode matchedDN for conn 0x%x, result 0x%x.\n",
                            connection, hr);
        }
        return hr;
    }

    // skip ErrorMessage
    hr = lber->HrSkipElement();
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "LdapParseExtendedResult couldn't decode errorMsg for conn 0x%x, result 0x%x.\n",
                            connection, hr);
        }
        return hr;
    }

    // referrals are OPTIONAL
    hr = lber->HrPeekTag( &tag );

    if (tag == (BER_CLASS_CONTEXT_SPECIFIC | BER_FORM_CONSTRUCTED | 0x03)) {
       
        //
        // Referrals are present
        //

       hr = lber->HrSkipElement();
       if (hr != NOERROR) {

           IF_DEBUG(PARSE) {
               LdapPrint2( "LdapParseExtendedResult couldn't decode referrals for conn 0x%x, result 0x%x.\n",
                               connection, hr);
           }
           return hr;
       }
    } else if (tag == (BER_CLASS_CONTEXT_SPECIFIC | 0xA) ) {
        
        //
        // tag = 0x8A, this is the response name..
        // responseName [10] LDAPOID OPTIONAL found
        //

        if ( ResultOID ) {

           if (codePage == LANG_UNICODE) {

               hr = lber->HrGetValueWithAlloc( ResultOID, TRUE );

           } else {

               hr = lber->HrGetValueWithAlloc( ( PCHAR * )ResultOID, TRUE );
           }

        } else {
            
            hr = lber->HrSkipElement();
        }

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "LdapParseExtendedResult couldn't decode ResultOID for conn 0x%x, result 0x%x.\n",
                               connection, hr);
            }
            return hr;
        }


        //
        // look for response [11] OCTETSTRING OPTIONAL
        //

        hr = lber->HrPeekTag( &tag );

        if (tag == (BER_CLASS_CONTEXT_SPECIFIC | 0x0B)) {
            //
            // tag = 0x8B, we found the optional response [11[
            //
    
            if ( ResultData ) {
                hr = lber->HrGetValueWithAlloc( ResultData, TRUE );
            } else {
                hr = lber->HrSkipElement();
            }
               
            if (hr != NOERROR) {
                IF_DEBUG(PARSE) {
                    LdapPrint2( "LdapParseExtendedResult couldn't decode response data  for conn 0x%x, result 0x%x.\n",
                                connection, hr);
                }

                if (ResultOID && *ResultOID) {
                    // if we already allocated the OID, free it so we don't leak
                    // on error
                    ldapFree(*ResultOID, LDAP_VALUE_SIGNATURE);
                    *ResultOID = NULL;
                }
                
                return hr;
            }
        }

    }

    if ( Freeit ) {
       ldap_msgfree( ResultMessage );
    }

    return LDAP_SUCCESS;
}

WINLDAPAPI ULONG LDAPAPI ldap_parse_resultW (
        LDAP *ExternalHandle,
        LDAPMessage *ResultMessage,
        ULONG *ReturnCode OPTIONAL,          // returned by server
        PWCHAR *MatchedDNs OPTIONAL,         // free with ldap_value_freeW
        PWCHAR *ErrorMessage OPTIONAL,       // free with ldap_memfreeW
        PWCHAR **Referrals OPTIONAL,         // free with ldap_memfreeW
        PLDAPControlW **ServerControls OPTIONAL,
        BOOLEAN Freeit
        )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapParseResult(      connection,
                                ResultMessage,
                                ReturnCode,
                                MatchedDNs,
                                ErrorMessage,
                                Referrals,
                                ServerControls,
                                Freeit,
                                LANG_UNICODE
                            );

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_parse_resultA (
        LDAP *ExternalHandle,
        LDAPMessage *ResultMessage,
        ULONG *ReturnCode OPTIONAL,         // returned by server
        PCHAR *MatchedDNs OPTIONAL,         // free with ldap_value_freeA
        PCHAR *ErrorMessage OPTIONAL,       // free with ldap_value_freeA
        PCHAR **Referrals OPTIONAL,         // free with ldap_value_freeA
        PLDAPControlA **ServerControls OPTIONAL,
        BOOLEAN Freeit
        )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapParseResult(      connection,
                                ResultMessage,
                                ReturnCode,
                                (PWCHAR *) MatchedDNs,
                                (PWCHAR *) ErrorMessage,
                                (PWCHAR **) Referrals,
                                (PLDAPControlW **) ServerControls,
                                Freeit,
                                LANG_ACP
                            );

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_parse_extended_resultW (
        LDAP           *ExternalHandle,
        LDAPMessage    *ResultMessage,
        PWCHAR         *ResultOID,
        struct berval **ResultData,
        BOOLEAN         Freeit
        )

{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapParseExtendedResult( connection,
                                   ResultMessage,
                                   ResultOID,
                                   ResultData,
                                   Freeit,
                                   LANG_UNICODE
                                 );

    DereferenceLdapConnection( connection );

    return err;
}


WINLDAPAPI ULONG LDAPAPI ldap_parse_extended_resultA (
        LDAP           *ExternalHandle,
        LDAPMessage    *ResultMessage,
        PCHAR          *ResultOID,
        struct berval **ResultData,
        BOOLEAN         Freeit
        )

{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapParseExtendedResult( connection,
                                   ResultMessage,
                                   (PWCHAR *)ResultOID,
                                   ResultData,
                                   Freeit,
                                   LANG_ACP
                                 );

    DereferenceLdapConnection( connection );

    return err;
}

// parse.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\precomp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ldap32.h   LDAP client 32 API header file

Abstract:

   This module is the header file for the 32 bit LDAP client API.

Author:

    Andy Herron (andyhe)        08-May-1996

Revision History:

--*/

#ifndef LDAP_CLIENT_PRECOMP_DEFINED
#define LDAP_CLIENT_PRECOMP_DEFINED

#ifdef __cplusplus
extern "C" {
#endif

#define INCL_WINSOCK_API_TYPEDEFS 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windef.h>
#include <windows.h>
#include <winsock2.h>
#include <svcguid.h>
#include <wtypes.h>
#include <stdlib.h>     // for malloc and free
#include <mmsystem.h>

#define SECURITY_WIN32 1

#include <security.h>
#include <kerberos.h>
#include <dsgetdc.h>
#include <ntdsapi.h>
#include <dsrole.h>

#include <crypt.h>
#include <des.h>

#define LDAP_UNICODE 0
#define _WINLDAP_ 1
#include <winldap.h>
#define _WINBER_ 1
#include <winber.h>

#include <ntldap.h>

#include "lmacros.h"
#include "globals.h"
#include "ldapp.h"
#include "debug.h"
#include "ldapstr.h"
//
//  This is in schnlsp.h, but since this isn't in the 4.0 QFE tree, we'll plop
//  it here.
//

#ifndef SEC_I_INCOMPLETE_CREDENTIALS

#define SEC_I_INCOMPLETE_CREDENTIALS      ((HRESULT)0x00090320L)

#endif

#ifdef __cplusplus
}
#endif

#endif  // LDAP_CLIENT_PRECOMP_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\newber.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation
   
Module Name:
      
   newber.cxx  
     
Abstract:

   This file contains utility functions required for BER 
   manipulation.
   
   
Author: 
   
   Anoop Anantha (AnoopA)    1-Dec-1997

Revision History:
   
--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"



BerElement * __cdecl ber_init (
     BERVAL  *pBerVal
     )
//
// This constructs a new BerElement structure containing a copy of the
// data in the supplied berval structure.
//
// Returns a pointer to a BerElement structure on success and NULL on failure.
//
{
   LBER *lber;
   ULONG err;
   ULONG bytestaken;

   if ((pBerVal != NULL) &&
        (pBerVal->bv_val != NULL) &&
        (pBerVal->bv_len != 0)) {

      lber = new CLdapBer( LDAP_VERSION2 );

      if (lber == NULL) {
         
         IF_DEBUG (OUTMEMORY) {
            LdapPrint0( "ber_alloc_t could not allocate BerElement structure ");
         }
         return NULL;
      }
      
      err = lber->HrLoadBer( (const BYTE *) pBerVal->bv_val,
                             pBerVal->bv_len,
                             &bytestaken,
                             TRUE,        // This is the whole message
                             TRUE         // Ignore the tag
                             );
      
      if (err == NOERROR) {

          return (BerElement*)lber;
      }

      delete lber;
   }

   return NULL;
}

VOID __cdecl ber_free (
     BerElement *pBerElement,
     INT fbuf
     )
//
// This frees a BerElement which is returned from ber_alloc_t() 
// or ber_init(). The second argument - fbuf should always be set
// to 1. I don't know why - the spec says so.
//
//
{
   CLdapBer *lber;

   if ( (pBerElement == NULL )||(fbuf != 1) ) {
      
      return;
   }

   lber = (CLdapBer *) pBerElement;

   delete lber;

}


VOID  __cdecl
ber_bvfree (
    struct berval *bv
    )
{
   PLDAP_MEMORY_DESCRIPTOR allocBlock;

   //
   // In some places, we allocate the entire berval structure in one piece
   // using the LDAP_VALUE_SIGNATURE. One example of this is in HrGetValueWithAlloc
   //

    if (bv != NULL) {

       allocBlock = (PLDAP_MEMORY_DESCRIPTOR) bv;
       allocBlock--;  // point to header


       if (allocBlock->Tag == LDAP_VALUE_SIGNATURE) {
           
          ldapFree( bv, LDAP_VALUE_SIGNATURE );
       
       } else { 

          ASSERT(allocBlock->Tag == LDAP_BERVAL_SIGNATURE);

        if (bv->bv_val != NULL) {
            ldapFree( bv->bv_val , LDAP_CONTROL_SIGNATURE );
        }
        ldapFree( bv, LDAP_BERVAL_SIGNATURE );
       }
    }
    return;
}


VOID __cdecl ber_bvecfree (
     PBERVAL *pBerVal
     )
//
// Frees an array of BERVAL structures.
//
//
{
   int i;

   if (pBerVal != NULL) {

      for ( i=0; pBerVal[i] != NULL; i++) {
         
         ber_bvfree( pBerVal[i] );
      }

      ldapFree( pBerVal, LDAP_BERVAL_SIGNATURE );
   }
   
   return;

}


PBERVAL __cdecl ber_bvdup (
     PBERVAL pBerVal
     )
//
// Returns a copy of a the supplied berval structure
//
{
   PBERVAL dup = NULL;

   if (pBerVal != NULL) {

      dup = (PBERVAL) ldapMalloc( sizeof( BERVAL ),
                                    LDAP_BERVAL_SIGNATURE );

      if (dup == NULL) {

         IF_DEBUG (OUTMEMORY) {
            LdapPrint0( "ber_bvdup could not allocate memory for berval structure ");
         }
         
         return NULL;
      }
      
      dup->bv_len = pBerVal->bv_len;

      if ((pBerVal->bv_len !=0 ) &&
          (pBerVal->bv_val != NULL ) ) {
      
         dup->bv_val = (PCHAR) ldapMalloc( dup->bv_len ,
                                           LDAP_CONTROL_SIGNATURE );

         if (dup->bv_val == NULL) {
              IF_DEBUG (OUTMEMORY) {
                 LdapPrint0( "ber_bvdup could not allocate berval structure ");
              }
              ldapFree( dup, LDAP_BERVAL_SIGNATURE );
              return NULL;
         }

         CopyMemory( dup->bv_val, pBerVal->bv_val, dup->bv_len);
      }
   }
   return dup;
}



BerElement* __cdecl ber_alloc_t (
     INT options
     )
//
// Constructs and returns a BerElement structure. The options field
// contains a bitwise-or of options which are to be used when generating
// the encoding of the BerElement
//
// The LBER_USE_DER options should always be specified.
//
{
   LBER  *lber;

   if (options & LBER_USE_DER) {
      
         lber = new CLdapBer( LDAP_VERSION2 );
         
         if (lber == NULL) {
            IF_DEBUG (OUTMEMORY) {
               LdapPrint0( "ber_alloc_t could not allocate BerElement structure ");
            }
            return NULL;
      }
         
         return (BerElement *) lber;
   }

   return NULL;
}



ULONG __cdecl ber_skip_tag (
     BerElement *pBerElement,
     PULONG pLen
     )
//
// This skips over the current tag and returns the tag of the next
// element in the supplied BerElement. The lenght of this element is
// stored in the pLen argument.
//
// LBER_DEFAULT is returned if there is no further data to be read
// else the tag of the next element is returned.
//
// The difference between ber_skip_tag() and ber_peek_tag() is that the
// state pointer is advanced past the first tag+lenght and is pointed to
// the value part of the next element
//
//
{
   LBER *lber;
   ULONG hr;
   ULONG tag;
 
    if ((pBerElement != NULL)&&(pLen != NULL )) {
 
       lber = (LBER *) pBerElement;
       hr = lber->HrSkipTag2( &tag, pLen );
 
       return ((hr == NO_ERROR) ? tag : LBER_DEFAULT );
    }
 
    return LDAP_PARAM_ERROR;
  
}

ULONG __cdecl ber_peek_tag (
     BerElement *pBerElement,
     PULONG pLen
     )
//
// This returns the tag of the next element to be parsed in the 
// supplied BerElement. The length of this element is stored in the
// pLen argument.
//
// LBER_DEFAULT is returned if there is no further data to be read
// else the tag of the next element is returned.
//
{
   LBER *lber;
   ULONG tag, oldpos;

   if ((pBerElement != NULL)&&(pLen != NULL )) {

      lber = (LBER *) pBerElement;
      //
      // Save the current position
      //
      oldpos = lber->GetCurrPos();
      tag = ber_skip_tag( pBerElement, pLen );
      //
      // Restore the previous position
      //
      lber->SetCurrPos( oldpos );
      return tag;
   }

   return LDAP_PARAM_ERROR;

}


ULONG __cdecl ber_first_element (
     BerElement *pBerElement,
     PULONG pLen,
     PCHAR *pOpaque
     )
//
// This returns the tag and length of the first element in a SET, SET OF
// or SEQUENCE OF data value. 
//
// LBER_DEFAULT is returned if the constructed value is empty else, the tag
// is returned. It also returns an opaque cookie which has to be passed to
// subsequent invocations of ber_next_element().
//
{
   ULONG hr;
   LBER *lber;


   if ((pBerElement != NULL) && (pLen !=NULL) && (pOpaque != NULL) ) {
      
      lber = (LBER *) pBerElement;
   //
   // First, skip the SET, SET OF or SEQUENCE tag
   //
   
      hr = ber_skip_tag( pBerElement, pLen );
      if (hr == LBER_DEFAULT) {
         return LBER_DEFAULT;
      }

      *pOpaque = (PCHAR) (lber->PbData() + lber->GetCurrPos() + *pLen);
      if ( *pLen == 0 ) {
          return LBER_DEFAULT;
      } else {
          return ( ber_peek_tag( pBerElement, pLen ) );
      }

   }
   return LDAP_PARAM_ERROR;
}



ULONG __cdecl ber_next_element (
     BerElement *pBerElement,
     PULONG pLen,
     PCHAR opaque
     )
//
// This positions the state at the start of the next element in the
// constructed type.
//
// LBER_DEFAULT is returned if the constructed value is empty else, the tag
// is returned.
//
{
   LBER *lber = (LBER *) pBerElement;

   if ((pBerElement != NULL) && (pLen !=NULL) && (opaque != NULL)) {

      if ( (PCHAR) (lber->PbData() + lber-> GetCurrPos()) == opaque) {

         return LBER_DEFAULT;
      }

      return ( ber_peek_tag( pBerElement, pLen ) );
   }
   return LDAP_PARAM_ERROR;
}


INT __cdecl ber_flatten (
     BerElement *pBerElement,
     PBERVAL *pBerVal
     )
//
// This allocates a BerVal structure whose contents are taken from the
// supplied BerElement structure.
//
// The return values are 0 on success and -1 on error.
//
{
   if ((pBerElement == NULL)||
      (pBerVal == NULL)) {
         
      return -1;
   }

      *pBerVal = (PBERVAL) ldapMalloc( sizeof( BERVAL ),
                                    LDAP_BERVAL_SIGNATURE );

      if (*pBerVal == NULL) {

         IF_DEBUG (OUTMEMORY) {
            LdapPrint0( "ber_flatten could'nt allocate berval structure ");
         }
         return -1;
         
      }

      LBER* plber = (LBER *) pBerElement;

      (*pBerVal)->bv_len = plber->CbData();

      (*pBerVal)->bv_val = (PCHAR) ldapMalloc( plber->CbData(),
                                           LDAP_CONTROL_SIGNATURE );

         if ((*pBerVal)->bv_val == NULL) {
              IF_DEBUG (OUTMEMORY) {
                 LdapPrint0( "ber_flatten could'nt allocate val structure ");
              }
              ldapFree( *pBerVal, LDAP_BERVAL_SIGNATURE );
              return -1;
         }

         //
         // Copy the value field over
         //
         CopyMemory( (*pBerVal)->bv_val, plber->PbData(), plber->CbData() );
         
         return 0;

}


INT __cdecl ber_printf (
     BerElement *pBerElement,
     PCHAR fmt,
     ...
     )
//
// This is similar to sprintf(). One important difference
// is that state information is maintained in the BerElement so that multiple
// calls can be made to ber_printf() to append to the end of the BerElement.
//
// The function returns -1 if there is an error during encoding.
//
//
{
   va_list argPtr;
   CHAR *pchar, *strval, **vstrval;
   int retval = NO_ERROR, intval;
   BERVAL **ppberval;
   LBER *lber = (LBER*) pBerElement;
   
   if ((pBerElement==NULL) || (fmt == NULL)) {

      return LBER_ERROR;
   }

   //
   // Make the argument pointer point to the first unnamed argument
   //

   va_start( argPtr, fmt );

   for (pchar = fmt; (*pchar != '\0')&&(retval==NO_ERROR) ; pchar++) {

      switch (*pchar) {
      case 't': //  overriding tag (int) follows
         {
               intval = va_arg( argPtr, INT );
               lber->HrOverrideTag( intval );
               break;
         }
      case 'b': // Boolean (int) follows
         {
            intval = va_arg( argPtr, INT );
            retval = lber->HrAddValue((BOOLEAN) intval, BER_BOOLEAN );
            break;
         }
      case 'i': // integer (int) follows
         {
            intval = va_arg( argPtr, INT );
            retval = lber->HrAddValue( (LONG) intval, BER_INTEGER );
            break;
         }
      case 'e': // enumerated type (int) follows
         {
            intval = va_arg( argPtr, INT );
            retval = lber->HrAddValue( (LONG) intval, BER_ENUMERATED );
            break;
         }
      case 'X': // Bitstring, args are char* ptr followed by
                // an int containing the number of bits in the bitstring
         {
            strval = va_arg( argPtr, PCHAR );
            intval = va_arg( argPtr, INT );
            retval = lber->HrAddBinaryValue( (PBYTE) strval, intval, BER_BITSTRING );
            break;
         }
      case 'n': // Null. No argument is required
         {
//          retval = lber->HrAddTag( BER_NULL ); 
            retval = lber->HrAddValue( (const CHAR *) NULL, BER_NULL );
            break;
         }
      case 'o': // octet string (not null terminated). Args are char* ptr,
                // followed by an int containing the length of the string
         {
            strval = va_arg( argPtr, PCHAR );
            intval = va_arg( argPtr, INT );
            retval = lber->HrAddBinaryValue( (PBYTE) strval, intval, BER_OCTETSTRING );
            break;
         }
      case 's': // octet string (null terminated). Next arg is a char* pointing
                // to a null terminated string.
         {
            strval = va_arg( argPtr, PCHAR );
            retval = lber->HrAddValue( strval, BER_OCTETSTRING );
            break;
         }
      case 'v': // several octet strings.
         {
            vstrval = va_arg( argPtr, PCHAR *);
            if (vstrval == NULL) {
               break;
            }
            for (intval = 0; vstrval[intval] != NULL; intval++) {
               retval = lber->HrAddValue( vstrval[intval], BER_OCTETSTRING );
               if (retval != NO_ERROR) {
                  break;
               }
            }
            break;
         }
      case 'V': // several octet strings
         {
            ppberval = va_arg( argPtr, BERVAL ** );
            if (ppberval == NULL) {
               break;
            }
            for (intval = 0; ppberval[intval] != NULL; intval++) {
               retval = lber->HrAddBinaryValue( (PBYTE) ppberval[intval]->bv_val,
                                                ppberval[intval]->bv_len,
                                                BER_OCTETSTRING );
               if (retval != NO_ERROR) {
                  break;
               }
            }
            break;
         }
      case '{': // Begin sequence, no argument is required
         {
            retval = lber->HrStartWriteSequence( BER_SEQUENCE );
            break;
         }
      case '}': // End sequence, no argument is required
         {
            retval = lber->HrEndWriteSequence();
            break;
         }
      case '[': // Begin set
         {
            retval = lber->HrStartWriteSequence( BER_SET );
            break;
         }
      case ']': // End set
         {
            retval = lber->HrEndWriteSequence();
            break;
         }
      default:
         {
            IF_DEBUG (BER) {  
               LdapPrint1( "ber_printf Unidentified format character %c ", *pchar);
            }
            
            retval = LBER_ERROR;

         }
      }
   }
   va_end( argPtr );
   return (retval == NO_ERROR) ? NO_ERROR : LBER_ERROR;
}


ULONG __cdecl ber_scanf (
     BerElement *pBerElement,
     PCHAR fmt,
     ...
     )
{
   va_list argPtr;
   CHAR *pchar, **pstrval, **pstrvalNew, ***ppstrval;
   int *pintval, retval = NO_ERROR;
   BERVAL **ppberval, **ppbervalNew, ***pppberval;
   ULONG *pUlong, uLong, tag;
   LBER *lber = (LBER*) pBerElement;
   ULONG  nextTag, tagLength;
   ULONG oldPos;
   #define CHUNK_SIZE  10    // minimum is 2.
   
   if ((pBerElement==NULL) || (fmt == NULL)) {

      return (ULONG) -1;
   }

   //
   // Make the argument pointer point to the first unnamed argument
   //

   va_start( argPtr, fmt );

   for (pchar = fmt; (*pchar != '\0')&&(retval==NO_ERROR) ; pchar++) {

      switch (*pchar) {
      case 'a':  // Octet string (null terminated)
         {
            pstrval = va_arg(argPtr, PCHAR*);
            nextTag = ber_peek_tag(pBerElement, &tagLength);
            if (nextTag == LBER_DEFAULT) {
                retval = LDAP_DECODING_ERROR;
                break;
            }
            if (GetBerForm(nextTag) == BER_FORM_CONSTRUCTED) {
                retval = LDAP_DECODING_ERROR;
            } else {
                retval = lber->HrGetValueWithAlloc(pstrval, TRUE);
            }
            break;
         }
      case 'O':  // Octet string (non-null terminated)
         {
            ppberval = va_arg( argPtr, PBERVAL* );
            nextTag = ber_peek_tag(pBerElement, &tagLength);
            if (nextTag == LBER_DEFAULT) {
                retval = LDAP_DECODING_ERROR;
                break;
            }
            if (GetBerForm(nextTag) == BER_FORM_CONSTRUCTED) {
                retval = LDAP_DECODING_ERROR;
            } else {
                retval = lber->HrGetValueWithAlloc(ppberval, TRUE);
            }
            break;
         }
      case 'b':  // Boolean
         {
            pintval = va_arg( argPtr, int* );
            nextTag = ber_peek_tag(pBerElement, &tagLength);
            if (nextTag == LBER_DEFAULT) {
                retval = LDAP_DECODING_ERROR;
                break;
            }
            if (GetBerForm(nextTag) == BER_FORM_CONSTRUCTED) {
                retval = LDAP_DECODING_ERROR;
            } else {
                retval = lber->HrGetValue((long*)pintval, BER_BOOLEAN, TRUE);
            }
            break;
         }
      case 'i':  // Integer
         {
            pintval = va_arg( argPtr, int* );
            nextTag = ber_peek_tag(pBerElement, &tagLength);
            if (nextTag == LBER_DEFAULT) {
                retval = LDAP_DECODING_ERROR;
                break;
            }
            if (GetBerForm(nextTag) == BER_FORM_CONSTRUCTED) {
                retval = LDAP_DECODING_ERROR;
            } else {
                retval = lber->HrGetValue((long*)pintval, BER_INTEGER, TRUE);
            }
            break;
         }
      case 'e':  // Enumerated
         {
            pintval = va_arg( argPtr, int* );
            nextTag = ber_peek_tag(pBerElement, &tagLength);
            if (nextTag == LBER_DEFAULT) {
                retval = LDAP_DECODING_ERROR;
                break;
            }
            if (GetBerForm(nextTag) == BER_FORM_CONSTRUCTED) {
                retval = LDAP_DECODING_ERROR;
            } else {
                retval = lber->HrGetValue((long*)pintval, BER_ENUMERATED, TRUE);
            }
            break;
         }
      case 'B':   // Bitstring
         {
            pstrval = va_arg( argPtr, PCHAR* );
            pUlong = va_arg( argPtr, PULONG );
            nextTag = ber_peek_tag(pBerElement, &tagLength);
            if (nextTag == LBER_DEFAULT) {
                retval = LDAP_DECODING_ERROR;
                break;
            }
            if (GetBerForm(nextTag) == BER_FORM_CONSTRUCTED) {
                retval = LDAP_DECODING_ERROR;
            } else {
                retval = lber->HrGetBinaryValuePointer( (PBYTE*) pstrval, pUlong, BER_BITSTRING, TRUE );
            }
            if (retval != NO_ERROR) {
               //
               // Duplicate the data and pass it back
               //
            }
            break;
         }
      case 'n':  // null
         {
            oldPos = lber->GetCurrPos();
            retval = lber->HrSkipTag();
            if (retval != NO_ERROR) {
                lber->SetCurrPos(oldPos);
                break;
            }
            retval = lber->HrGetLength( &uLong );
            if (retval != NO_ERROR) {
                lber->SetCurrPos(oldPos);
                break;
            }
            if (uLong != 0) {
                retval = LBER_ERROR;
                lber->SetCurrPos(oldPos);
                break;
            }
            break;
         }
      case 'v':   // several null terminated octet strings
         {
            ppstrval = va_arg( argPtr, PCHAR**);
            *ppstrval = NULL;
            PCHAR cookie;
            ULONG numofstrings=0, len, currentArraySize = 0 ;
            
            //
            // We have to allocate a null-terminated array of PCHARs and make
            // ppstrval point to it. To do this, we need to know how many 
            // octet strings are present. Note that we can't simply count
            // the number of strings first, build the array, and then fill it 
            // because ber_next_element will alter the internal state of the
            // BerElement.
            //

            for (tag=ber_first_element(pBerElement, &len, &cookie); 
                 (( tag != LBER_DEFAULT ) && ( retval != LBER_DEFAULT ));
                 tag = ber_next_element(pBerElement,&len, cookie)) {

                 if ( *ppstrval == NULL ) {
                     
                     //
                     // first time around, alloc a sufficiently large array 
                     //
                     
                     *ppstrval = (PCHAR *) ldapMalloc( CHUNK_SIZE * sizeof(PCHAR),
                                                       LDAP_BUFFER_SIGNATURE );
                     if ( *ppstrval == NULL ) {
                         return LBER_ERROR;
                     }

                     currentArraySize = CHUNK_SIZE;

                    } else if ( numofstrings > (currentArraySize-2) ) {
                            
                        //
                        // sort of realloc and free the old memory
                        //
                        
                        pstrvalNew = NULL;
                        pstrvalNew = (PCHAR *) ldapMalloc( (currentArraySize + CHUNK_SIZE) * sizeof(PCHAR),
                                                            LDAP_BUFFER_SIGNATURE );
                        if ( pstrvalNew == NULL ){
                            return LBER_ERROR;
                        }
                        ldap_MoveMemory( (PCHAR) pstrvalNew,
                                         (PCHAR) *ppstrval,
                                         (currentArraySize * sizeof(PCHAR)));
                        ldapFree( *ppstrval, LDAP_BUFFER_SIGNATURE );
                        *ppstrval = pstrvalNew;
                        currentArraySize += CHUNK_SIZE;
                    }


                    retval = lber->HrGetValueWithAlloc( (&(*ppstrval)[numofstrings]), TRUE);
                    numofstrings++;
            }
            
            break;
         }
      case 'V':   // several non-null terminated octet strings
         {
            pppberval = va_arg( argPtr, PBERVAL**);
            *pppberval = NULL;
            PCHAR cookie;
            ULONG numofbervals=0, len, currentArraySize = 0 ;

            //
            // We have to allocate a null-terminated array of PBERVALs and make
            // pppberval point to it. To do this, we need to know how many 
            // bervals are present. Note that we can't simply count
            // the number of bervals first, build the array, and then fill it 
            // because ber_next_element will alter the internal state of the
            // BerElement.
            //

            for (tag=ber_first_element(pBerElement, &len, &cookie); 
                 (( tag != LBER_DEFAULT ) && ( retval != LBER_DEFAULT ));
                 tag = ber_next_element(pBerElement,&len, cookie)) {

                 if ( *pppberval == NULL ) {
                     
                     //
                     // first time around, alloc a sufficiently large array 
                     //
                     
                     *pppberval = (PBERVAL *) ldapMalloc( CHUNK_SIZE * sizeof(PBERVAL),
                                                       LDAP_BUFFER_SIGNATURE );
                     if ( *pppberval == NULL ) {
                         return LBER_ERROR;
                     }

                    } else if ( numofbervals > (currentArraySize-2) ) {
                        
                        //
                        // sort of realloc and free the old memory
                        //
                        
                        ppbervalNew = NULL;
                        ppbervalNew = (PBERVAL *) ldapMalloc( (currentArraySize + CHUNK_SIZE) * sizeof(PBERVAL),
                                                              LDAP_BUFFER_SIGNATURE );
                        if ( ppbervalNew == NULL ){
                                return LBER_ERROR;
                        }
                        ldap_MoveMemory( (PCHAR) ppbervalNew,
                                         (PCHAR) *pppberval,
                                         (currentArraySize * sizeof(PBERVAL)));
                        ldapFree( *pppberval, LDAP_BUFFER_SIGNATURE );
                        *pppberval = ppbervalNew;
                        currentArraySize += CHUNK_SIZE;
                    }

                    retval = lber->HrGetValueWithAlloc( (&(*pppberval)[numofbervals]), TRUE);
                    numofbervals++;
            }
            
            break;
         }
      case 'x':   // Skip element.
         {
            retval = lber->HrSkipElement();
            break;
         }
      case '{':   // Begin sequence
         {
             retval = lber->HrStartReadSequence(BER_SEQUENCE, TRUE);
             break;
         }
      case '}':   // End sequence
         {
             retval = lber->HrEndReadSequence();
             break;
         }
      case '[':   // Begin Set
         {
             retval = lber->HrStartReadSequence(BER_SET, TRUE);
             break;
         }
      case ']':   // End set
         {
             retval = lber->HrEndReadSequence();
             break;
         }

         }
      }
   va_end( argPtr );

   return (retval == NO_ERROR) ? NO_ERROR : LBER_ERROR;

}

// newber.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\ping.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ping.cxx  check to see if an LDAP server is still around

Abstract:

   This module handles incoming data from an LDAP server

Author:

    Andy Herron (andyhe)        17-Jun-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ipexport.h>
#include <icmpapi.h>

typedef HANDLE (WINAPI *FICMPCREATEFILE) (
    VOID
    );

typedef BOOL (WINAPI *FICMPCLOSEHANDLE) (
    HANDLE IcmpHandle
    );

typedef DWORD (WINAPI *FICMPSENDECHO) (
    HANDLE                   IcmpHandle,
    IPAddr                   DestinationAddress,
    LPVOID                   RequestData,
    WORD                     RequestSize,
    PIP_OPTION_INFORMATION   RequestOptions,
    LPVOID                   ReplyBuffer,
    DWORD                    ReplySize,
    DWORD                    Timeout
    );

FICMPCREATEFILE pIcmpCreateFile = 0;
FICMPCLOSEHANDLE pIcmpCloseHandle = 0;
FICMPSENDECHO  pIcmpSendEcho = 0;

#define ICMP_REPLY_BUFFER_SIZE (sizeof(ICMP_ECHO_REPLY) + 128)

HINSTANCE IcmpLibraryHandle = NULL;

BOOLEAN
LoadPingLibrary(
    VOID
    );

ULONG
LdapPingServer(
    PLDAP_CONN      Connection
    )
{
    ULONG err = LDAP_SUCCESS;
    HANDLE icmpHandle = NULL;
    UCHAR request;
    ULONG waitTime = Connection->PingWaitTimeInMilliseconds;
    UCHAR replyBuffer[ICMP_REPLY_BUFFER_SIZE];

    if ((waitTime > 0) &&
        (LoadPingLibrary() == TRUE)) {

        icmpHandle = (*pIcmpCreateFile)();

        if (icmpHandle != NULL) {

            request = '?';

            err = (*pIcmpSendEcho)( icmpHandle,
                                    Connection->SocketAddress.sin_addr.s_addr,
                                    &request,
                                    1,              // request size
                                    NULL,
                                    &replyBuffer[0],
                                    ICMP_REPLY_BUFFER_SIZE,
                                    waitTime
                                  );

            if (err > 0) {

                err = LDAP_SUCCESS;

            } else {

                err = LDAP_TIMEOUT;
            }

            (*pIcmpCloseHandle)( icmpHandle );
        }
    }

    return err;
}

BOOLEAN
LoadPingLibrary(
    VOID
    )
{
    if (IcmpLibraryHandle != NULL) {

        return TRUE;
    }

    IcmpLibraryHandle = LoadSystem32LibraryA( "ICMP.DLL" );

    if (IcmpLibraryHandle != NULL) {

        pIcmpCreateFile = (FICMPCREATEFILE) GetProcAddress( IcmpLibraryHandle,
                                                            "IcmpCreateFile" );
        pIcmpCloseHandle = (FICMPCLOSEHANDLE) GetProcAddress(   IcmpLibraryHandle,
                                                            "IcmpCloseHandle" );
        pIcmpSendEcho = (FICMPSENDECHO) GetProcAddress(     IcmpLibraryHandle,
                                                            "IcmpSendEcho" );
        if ((pIcmpCreateFile == NULL) ||
            (pIcmpCloseHandle == NULL) ||
            (pIcmpSendEcho == NULL)) {

            UnloadPingLibrary();
        }
    }
    return ((IcmpLibraryHandle != NULL) ? TRUE : FALSE);
}

VOID
UnloadPingLibrary(
    VOID
    )
{
    if (IcmpLibraryHandle != NULL) {

        FreeLibrary( IcmpLibraryHandle );
        IcmpLibraryHandle = NULL;
    }
    return;
}

// ping.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\open.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    open.cxx  open a connection to an LDAP server

Abstract:

   This module implements the LDAP ldap_open API.

Author:

    Andy Herron    (andyhe)        08-May-1996
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"
#include <dststlog.h>

#define LDAP_CONNECT_TIMEOUT     45    // seconds
#define MAX_PARALLEL_CONNECTS    20    // Limited to 64 because select can't handle more
#define CONNECT_INTERVAL         100   // milliseconds
#define MAX_SOCK_ADDRS           100   // max number of records we will retrieve
#define SAMESITE_CONNECT_TIMEOUT 10    // seconds for intra site connections
#define LDAP_QUICK_TIMEOUT       2     // in seconds to accomodate high latency links.

DEFINE_DSLOG;

LDAP *LdapConnectionOpen (
    PWCHAR HostName,
    ULONG PortNumber,
    BOOLEAN Udp
    );

INT
OpenLdapServer (
    PLDAP_CONN Connection,
    struct l_timeval  *timeout
    );

ULONG
LdapWinsockConnect (
    PLDAP_CONN Connection,
    USHORT PortNumber,
    PWCHAR HostName,
    struct l_timeval  *timeout,
    BOOLEAN samesite
    );

BOOLEAN
LdapIsAddressNumeric (
    PWCHAR HostName
    );

struct hostent *
GetHostByNameW(
    PWCHAR  hostName
 );

ULONG
Inet_addrW(
   PWCHAR  IpAddressW
 );

ULONG
GetCurrentMachineParams(
    PWCHAR* Address,
    PWCHAR* DnsHostName
    );

ULONG
GetPrimaryDomainName(
    PWCHAR* pDomainName
    );    

//
//  This routine is one of the main entry points for clients calling into the
//  ldap API.  The Hostname is a list of 0 to n hosts, separated by spaces.
//  The host name can be either a name or a TCP address of the form
//  nnn.nnn.nnn.nnn.
//

LDAP * __cdecl ldap_openW (
    PWCHAR HostName,
    ULONG PortNumber
    )
{
    return LdapConnectionOpen( HostName, PortNumber, FALSE );
}

//
//  This routine is one of the main entry points for clients calling into the
//  ldap API.  The Hostname is a list of 0 to n hosts, separated by spaces.
//  The host name can be either a name or a TCP address of the form
//  nnn.nnn.nnn.nnn.
//

LDAP * __cdecl ldap_open (
    PCHAR HostName,
    ULONG PortNumber
    )
{

    LDAP* ExternalHandle = NULL;
    ULONG err;
    PWCHAR wHostName = NULL;

    err = ToUnicodeWithAlloc( HostName,
                              -1,
                              &wHostName,
                              LDAP_UNICODE_SIGNATURE,
                              LANG_ACP );

    if (err == LDAP_SUCCESS) {

        ExternalHandle = LdapConnectionOpen( wHostName, PortNumber, FALSE );
    }

    ldapFree(wHostName, LDAP_UNICODE_SIGNATURE);

    return ExternalHandle;
}

LDAP * __cdecl cldap_open (
    PCHAR HostName,
    ULONG PortNumber
    )
{
    LDAP* ExternalHandle = NULL;
    ULONG err;
    PWCHAR wHostName = NULL;

    err = ToUnicodeWithAlloc( HostName,
                              -1,
                              &wHostName,
                              LDAP_UNICODE_SIGNATURE,
                              LANG_ACP );

    if (err == LDAP_SUCCESS) {

        ExternalHandle = LdapConnectionOpen( wHostName, PortNumber, TRUE );
    }

    ldapFree(wHostName, LDAP_UNICODE_SIGNATURE);

    return ExternalHandle;
}

LDAP * __cdecl cldap_openW (
    PWCHAR HostName,
    ULONG PortNumber
    )
{
    return LdapConnectionOpen( HostName, PortNumber, TRUE );
}

LDAP * __cdecl ldap_sslinit (
    PCHAR HostName,
    ULONG PortNumber,
    int Secure
    )
{
    LDAP* connection = NULL;
    ULONG err;
    PWCHAR wHostName = NULL;

    err = ToUnicodeWithAlloc( HostName,
                              -1,
                              &wHostName,
                              LDAP_UNICODE_SIGNATURE,
                              LANG_ACP );

    if (err == LDAP_SUCCESS) {

        connection = ldap_sslinitW( wHostName, PortNumber,(ULONG) Secure );
    }

    ldapFree(wHostName, LDAP_UNICODE_SIGNATURE);

    return connection;

}


LDAP * __cdecl ldap_init (
    PCHAR HostName,
    ULONG PortNumber
    )
{
    return ldap_sslinit( HostName, PortNumber, 0 );
}


LDAP * __cdecl ldap_initW (
    PWCHAR HostName,
    ULONG PortNumber
    )
{
    return ldap_sslinitW( HostName, PortNumber, 0 );
}


LDAP * __cdecl ldap_sslinitW (
    PWCHAR HostName,
    ULONG PortNumber,
    int Secure
    )
{
    PLDAP_CONN connection;

    connection = LdapAllocateConnection( HostName, PortNumber, (ULONG) Secure, FALSE );

    if (connection == NULL) {

        return NULL;
    }

    //
    // No locks needed - not yet added to connection list
    //

    connection->HandlesGivenToCaller++;

    //
    // Add it to global list of connections
    //

    ACQUIRE_LOCK( &ConnectionListLock );

    InsertTailList( &GlobalListActiveConnections, &connection->ConnectionListEntry );

    RELEASE_LOCK( &ConnectionListLock );

    DereferenceLdapConnection( connection );

    return connection->ExternalInfo;

}


LDAP_CONN * LdapAllocateConnection (
    PWCHAR HostName,
    ULONG PortNumber,
    ULONG Secure,
    BOOLEAN Udp
    )
//
//  This routine creates a data block containing instance data for a connection.
//
//  Must return a Win32 error code.
//
{
    PLDAP_CONN connection = NULL;
    ULONG err;
    HANDLE hConnectEvent = NULL;

    DWORD dwCritSectInitStage = 0;

    if (LdapInitializeWinsock() == FALSE) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LdapAllocateConnection could not initialize winsock, 0x%x.\n", GetLastError());
        }
        SetLastError( ERROR_NETWORK_UNREACHABLE );
        SetConnectionError(NULL, LDAP_CONNECT_ERROR, NULL);
        return NULL;
    }

    (VOID) LdapInitSecurity();

    hConnectEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

    if (hConnectEvent == NULL) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LdapAllocateConnection could not alloc event, 0x%x.\n", GetLastError());
        }
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        SetConnectionError(NULL, LDAP_NO_MEMORY, NULL);
        return NULL;
    }

    //
    //  allocate the connection block and setup all the initial values
    //

    connection = (PLDAP_CONN) ldapMalloc( sizeof( LDAP_CONN ), LDAP_CONN_SIGNATURE );

    if (connection == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap_open could not allocate 0x%x bytes.\n", sizeof( LDAP_CONN ) );
        }

        CloseHandle( hConnectEvent );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        SetConnectionError(NULL, LDAP_NO_MEMORY, NULL);        
        return NULL;
    }

    if (HostName != NULL) {

        connection->ListOfHosts = ldap_dup_stringW( HostName, 0, LDAP_HOST_NAME_SIGNATURE );

        if (connection->ListOfHosts == NULL) {

            IF_DEBUG(OUTMEMORY) {
                LdapPrint1( "ldap_open could not allocate mem for %s\n", HostName );
            }

            ldapFree( connection, LDAP_CONN_SIGNATURE );

            CloseHandle( hConnectEvent );
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            SetConnectionError(NULL, LDAP_NO_MEMORY, NULL);        
            return NULL;
        }
    }

    InterlockedIncrement( &GlobalConnectionCount );

    //
    //  keep in mind the memory is already zero initialized
    //

    connection->ReferenceCount = 2;
    connection->ConnectEvent = hConnectEvent;

    connection->ConnObjectState = ConnObjectActive;

    connection->publicLdapStruct.ld_options = LDAP_OPT_DNS |
                                    LDAP_OPT_CHASE_REFERRALS |
                                    LDAP_CHASE_SUBORDINATE_REFERRALS |
                                    LDAP_CHASE_EXTERNAL_REFERRALS;

    connection->PortNumber = LOWORD( PortNumber );
    connection->AREC_Exclusive = FALSE;
    connection->ExternalInfo = &connection->publicLdapStruct;
    connection->publicLdapStruct.ld_version = ( Udp ? LDAP_VERSION3 : LDAP_VERSION2 );
    connection->HighestSupportedLdapVersion = LDAP_VERSION2;
    connection->TcpHandle = INVALID_SOCKET;
    connection->UdpHandle = INVALID_SOCKET;
    connection->MaxReceivePacket = INITIAL_MAX_RECEIVE_BUFFER;
    connection->NegotiateFlags = DEFAULT_NEGOTIATE_FLAGS;
    connection->SendDrainTimeSeconds = (ULONG) -1;

    //  setup fields for keep alive processing

    connection->TimeOfLastReceive = LdapGetTickCount();
    connection->PingLimit = LOWORD( GlobalLdapPingLimit );
    connection->KeepAliveSecondCount = GlobalWaitSecondsForSelect;
    connection->PingWaitTimeInMilliseconds = GlobalPingWaitTime;
    connection->HostConnectState = HostConnectStateUnconnected;

    InitializeListHead( &connection->CompletedReceiveList );
    InitializeListHead( &connection->PendingCryptoList );
    SetNullCredentials( connection );

    connection->ConnectionListEntry.Flink = NULL;

    __try {

        INITIALIZE_LOCK( &(connection->ReconnectLock) );
        dwCritSectInitStage = 1;
        
        INITIALIZE_LOCK( &(connection->StateLock) );
        dwCritSectInitStage = 2;
        
        INITIALIZE_LOCK( &(connection->SocketLock) );
        dwCritSectInitStage = 3;
        
        INITIALIZE_LOCK( &(connection->ScramblingLock) );
        dwCritSectInitStage = 4;

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // Something went wrong
        //
        IF_DEBUG(ERRORS) {
            LdapPrint0( "LdapAllocateConnection could not initialize critical sections.\n");
        }

        switch (dwCritSectInitStage) {
            // fall-through is deliberate

        case 4:
            DELETE_LOCK(&(connection->ScramblingLock));
        case 3:
            DELETE_LOCK(&(connection->SocketLock));
        case 2:
            DELETE_LOCK(&(connection->StateLock));
        case 1:
            DELETE_LOCK(&(connection->ReconnectLock));
        case 0:
        default:
            break;
        }
        
        InterlockedDecrement( &GlobalConnectionCount );    
        ldapFree( connection->ListOfHosts, LDAP_HOST_NAME_SIGNATURE );
        ldapFree( connection, LDAP_CONN_SIGNATURE );
        CloseHandle( hConnectEvent );
        
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        SetConnectionError(NULL, LDAP_NO_MEMORY, NULL);        

        return NULL;
    }


    connection->publicLdapStruct.ld_deref = LDAP_DEREF_NEVER;
    connection->publicLdapStruct.ld_timelimit = LDAP_TIME_LIMIT_DEFAULT;
    connection->publicLdapStruct.ld_errno = LDAP_SUCCESS;
    connection->publicLdapStruct.ld_cldaptries = CLDAP_DEFAULT_RETRY_COUNT;
    connection->publicLdapStruct.ld_cldaptimeout = CLDAP_DEFAULT_TIMEOUT_COUNT;
    connection->publicLdapStruct.ld_refhoplimit = LDAP_REF_DEFAULT_HOP_LIMIT;
    connection->publicLdapStruct.ld_lberoptions = LBER_USE_DER;
    connection->PromptForCredentials = TRUE;
    connection->AutoReconnect = TRUE;
    connection->UserAutoRecChoice = TRUE;
    connection->ClientCertRoutine = NULL;
    connection->ServerCertRoutine = NULL;
    connection->SentPacket = FALSE;
    connection->ProcessedListOfHosts = FALSE;
    connection->ForceHostBasedSPN = FALSE;
    connection->DefaultServer = FALSE;

    if (Udp) {

        connection->UdpHandle = (*psocket)(PF_INET, SOCK_DGRAM, 0);

        err = ( connection->UdpHandle == INVALID_SOCKET ) ? ERROR_BAD_NET_NAME : 0;

    } else {

        connection->TcpHandle = (*psocket)(PF_INET, SOCK_STREAM, 0);

        err = ( connection->TcpHandle == INVALID_SOCKET ) ? ERROR_BAD_NET_NAME : 0;
    }

    if ((err == 0) && psetsockopt) {
        // prevent socket hijacking
    
        BOOL t = TRUE;

        (*psetsockopt)( Udp ? connection->UdpHandle : connection->TcpHandle,
                        SOL_SOCKET,
                        SO_EXCLUSIVEADDRUSE,
                        reinterpret_cast<char*>(&t),
                        sizeof(t) );
    }

    if (err != 0) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint1( "ldap_create failed to open socket, err = 0x%x.\n", (*pWSAGetLastError)());
        }

exitWithError:
        CloseLdapConnection( connection );
        DereferenceLdapConnection( connection );
        SetLastError(err);
        SetConnectionError(NULL, (err == ERROR_SUCCESS ? LDAP_SUCCESS : LDAP_OPERATIONS_ERROR), NULL);
        return NULL;
    }

    ULONG secure = PtrToUlong(((Secure == 0) ? LDAP_OPT_OFF : LDAP_OPT_ON ));

    err = LdapSetConnectionOption( connection, LDAP_OPT_SSL, &secure, FALSE );

    if (err != LDAP_SUCCESS) {

        err = ERROR_OPEN_FAILED;
        goto exitWithError;
    }

    return connection;
}

//
//  After all of the above plethora of ways to get to this routine, we
//  have some code that actually allocates a connection block and sets it up.
//

LDAP *LdapConnectionOpen (
    PWCHAR HostName,
    ULONG PortNumber,
    BOOLEAN Udp
    )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = LdapAllocateConnection( HostName, PortNumber, 0, Udp );

    if (connection == NULL) {

        IF_DEBUG(CONNECTION) {
            LdapPrint1( "ldap_open failed to create connection, err = 0x%x.\n", GetLastError());
        }

        return NULL;
    }

    //
    //  open a connection to any of the servers specified
    //

    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {

        CloseLdapConnection( connection );
        DereferenceLdapConnection( connection );
        connection = NULL;
        SetConnectionError(NULL, err, NULL);
        SetLastError( LdapMapErrorToWin32( err ));

        IF_DEBUG(CONNECTION) {
            LdapPrint1( "ldap_open failed to open connection, err = 0x%x.\n", err);
        }
        return NULL;
    }

    //
    // We haven't given the connection to anyone - so object must be active
    //

    ASSERT(connection->ConnObjectState == ConnObjectActive);

    connection->HandlesGivenToCaller++;

    //
    // Add it to global list of connections
    //

    ACQUIRE_LOCK( &ConnectionListLock );

    InsertTailList( &GlobalListActiveConnections, &connection->ConnectionListEntry );

    RELEASE_LOCK( &ConnectionListLock );

    //
    // Wake up select so that it picks up the new connection handle.
    //
    
    LdapWakeupSelect();

    DereferenceLdapConnection( connection );

    return connection->ExternalInfo;
}

INT
OpenLdapServer (
    PLDAP_CONN Connection,
    struct l_timeval  *timeout
    )
//
//  The Connection->ListOfHosts parameter is a list of hosts of the form :
//      hostname
//      hostaddr
//      hostname:port
//      hostaddr:port
//
//  We should, for each one, do the following :
//
//      If name, call DsGetDcOpen to get DCs
//      If name and DsGetDcOpen fails, call gethostbyname, get list of addrs
//         for every addr we have, try connect()
//
//  Each of them is null terminated, the number is specified by
//  Connection->NumberOfHosts
//
//  This returns a Win32 error code.
{
    USHORT  PortNumber;
    USHORT  hostsTried;
    PWCHAR  hostName;
    INT     rc = ERROR_HOST_UNREACHABLE;
    INT     wsErr;
    USHORT  port;
    PWCHAR  endOfHost;
    PWCHAR  hostPtr;
    BOOLEAN haveTriedExplicitHost = FALSE;
    BOOLEAN tryingExplicitHost = FALSE;
    BOOLEAN samesite = FALSE;
    ULONGLONG   startTime;
    BOOLEAN fIsValidDnsSuppliedName = FALSE;
    DWORD DCFlags = 0;

#if DBG
    startTime = LdapGetTickCount();
#endif

    if ((Connection->ProcessedListOfHosts) && (Connection->DefaultServer == TRUE)) {

        //
        // If we're reconnecting, and the user originally asked us to find the default
        // server (by passing in NULL), we reset the internal state and go through the
        // DsGetDcName process again to retrieve a fresh DC.  This way, we have all the
        // data we need in order to generate a valid DNS-based SPN for Kerberos.
        //

        //
        // We need to free ListOfHosts.  ExplicitHostName and HostNameW may be aliased
        // to ListOfHosts.  So if they are, we need to take appropriate action.  We'll
        // just reset HostNameW later, so we free it if it didn't point to the same
        // memory as ListOfHosts, and reset it to NULL.  This prevents a leak.
        // For ExplicitHostName, we want to preserve it, so we copy it off if it is
        // currently an alias for ListOfHosts (in practice, I don't think this will
        // ever happen)
        //
        if (Connection->ExplicitHostName == Connection->ListOfHosts) {
            // Copy this off before freeing ListOfHosts if it's an alias to
            // ListOfHosts (see unbind.cxx)
            Connection->ExplicitHostName = ldap_dup_stringW(Connection->ExplicitHostName,
                                                            0,
                                                            LDAP_HOST_NAME_SIGNATURE);

            if ((Connection->ExplicitHostName) == NULL) {
                return LDAP_NO_MEMORY;
            }
        }

        if (( Connection->HostNameW != Connection->ExplicitHostName ) &&
           ( Connection->HostNameW != Connection->ListOfHosts )) {
            // Reset HostNameW --- this may point to a allocated block of memory,
            // or it may be a alias for ListOfHosts, hence the check above
            // (see unbind.cxx)
            ldapFree( Connection->HostNameW, LDAP_HOST_NAME_SIGNATURE );
        }
        Connection->HostNameW = NULL;

        // Free everything we'll set in the code to find a DC below
        ldapFree( Connection->ListOfHosts, LDAP_HOST_NAME_SIGNATURE );
        Connection->ListOfHosts = NULL;

        ldapFree( Connection->DnsSuppliedName, LDAP_HOST_NAME_SIGNATURE );
        Connection->DnsSuppliedName = NULL;

        ldapFree( Connection->DomainName, LDAP_HOST_NAME_SIGNATURE);
        Connection->DomainName = NULL;

        DCFlags = DS_FORCE_REDISCOVERY; // since our old DC may have gone down
        Connection->ProcessedListOfHosts = FALSE;  // we're resetting ListOfHosts
    }


    if (Connection->ListOfHosts == NULL) {

        PWCHAR Address, DnsName, DomainName;
        DWORD numAddrs = 1;
        ULONG strLen0, strLen1;
        BOOLEAN fGC = FALSE;

        Address = DnsName = DomainName = NULL;

        if ((!GlobalWin9x) &&
            ((Connection->PortNumber == LDAP_PORT) ||
             (Connection->PortNumber == LDAP_SSL_PORT))) {

            rc = GetCurrentMachineParams( &Address, &DnsName );
        }

        if (( Connection->PortNumber == LDAP_GC_PORT ) ||
            ( Connection->PortNumber == LDAP_SSL_GC_PORT )) {

            fGC = TRUE;
        }
            
         if (rc != LDAP_SUCCESS) {

            //
            //  Either the current machine is not a DC or we failed trying to
            //  find out.Get the domain name for the currently logged in user.
            //  alas, for now we just get the server name of a NTDS DC in the domain.
            //


            rc = GetDefaultLdapServer(    NULL,
                                          &Address,
                                          &DnsName,
                                          (fGC ? &DomainName : NULL),
                                          &numAddrs,
                                          Connection->GetDCFlags | DCFlags,
                                          &samesite,
                                          Connection->PortNumber,
                                          &Connection->ResolvedGetDCFlags
                                          );

            if ((rc == NO_ERROR) && !fGC) {

                rc = GetPrimaryDomainName(&DomainName);
            }
         }

        if (rc != NO_ERROR) {

            return rc;
        }

        strLen0 = (Address == NULL) ? 0 : (strlenW( Address ) + 1);
        strLen1 = (DomainName == NULL) ? 0 : (strlenW( DomainName ) + 1);

        if (strLen0 > 1) {

            Connection->ListOfHosts = ldap_dup_stringW(  Address,
                                                         strLen1, // Allocate extra for the domain name
                                                         LDAP_HOST_NAME_SIGNATURE );

            if (Connection->ListOfHosts && (strLen1 > 1)) {

                PWCHAR nextHost = Connection->ListOfHosts + strLen0;

                // make this a space separated list of names

                    if (strLen0 > 0) {
                        *(nextHost-1) = L' ';
                    }
                ldap_MoveMemory( (PCHAR) nextHost, (PCHAR) DomainName, sizeof(WCHAR)*strLen1 );
            }

            ldapFree( Address, LDAP_HOST_NAME_SIGNATURE );
            Address = NULL;
            Connection->DnsSuppliedName = DnsName;
            fIsValidDnsSuppliedName = TRUE;
            Connection->DomainName = DomainName;
        }

        if (Connection->ListOfHosts == NULL) {

            ldapFree( Address, LDAP_HOST_NAME_SIGNATURE );
            SetLastError( ERROR_INCORRECT_ADDRESS );
            return ERROR_INCORRECT_ADDRESS;
        }

        Connection->DefaultServer = TRUE;
    } 

    //
    //  if we haven't already processed the list of hosts (i.e., this isn't
    //  a autoreconnect), go through the list of hosts and replace all spaces
    //  with nulls and count up number of hosts
    //
    //  If this is a autoreconnect, the NULLs were already inserted during the
    //  initial connect, and trying to do it a second time will cause us to
    //  lost all but the first host on the list (since we'll stop at the first
    //  NULL)
    //

    if (!Connection->ProcessedListOfHosts)
    {
        Connection->NumberOfHosts = 1;

        hostPtr = Connection->ListOfHosts;

        while (*hostPtr != L'\0') {

            if (*hostPtr == L' ') {

                Connection->NumberOfHosts++;
                *hostPtr = L'\0';
                hostPtr++;

                while (*hostPtr == L' ') {
                    hostPtr++;
                }
            } else {

                hostPtr++;
            }
        }

        Connection->ProcessedListOfHosts = TRUE;
    }
    
    //
    //  Try to connect to the server(s) specified by hostName
    //

RetryWithoutExplicitHost:

    PortNumber = Connection->PortNumber;
    hostsTried = 0;

    hostName = Connection->ListOfHosts;

    //
    //  if the app suggested a server to try by calling ldap_set_option with
    //  LDAP_OPT_HOSTNAME before we got in here, then we try that name first
    //

    if ((haveTriedExplicitHost == FALSE) &&
        (Connection->ExplicitHostName != NULL)) {

        hostName = Connection->ExplicitHostName;
        haveTriedExplicitHost = TRUE;
        tryingExplicitHost = TRUE;
    }

    Connection->SocketAddress.sin_family = AF_INET;

    if (PortNumber == 0) {
        PortNumber = LDAP_SERVER_PORT;
    }
    Connection->SocketAddress.sin_port = (*phtons)( LOWORD( PortNumber ));

    rc = ERROR_HOST_UNREACHABLE;

    while (( hostsTried < Connection->NumberOfHosts ) &&
           ( rc != 0 )) {

        port = LOWORD( PortNumber );

        IF_DEBUG(CONNECTION) {
            LdapPrint2( "LDAP conn 0x%x trying host %S\n", Connection, hostName );
        }

        //
        //  pick up :nnn for port number
        //

        endOfHost = hostName;

        while ((*endOfHost != L':') &&
               (*endOfHost != L'\0')) {

            endOfHost++;
        }

        if (*endOfHost != L'\0') {

            PWCHAR portPtr = endOfHost + 1;

            //
            //  pick up port number
            //

            port = 0;

            while (*portPtr != L'\0') {

                if (*portPtr < L'0' ||
                    *portPtr > L'9') {

                    IF_DEBUG(CONNECTION) {
                        LdapPrint2( "LDAP conn 0x%x invalid port number for %S\n", Connection, hostName );
                    }
                    rc = ERROR_INVALID_NETNAME;
                    goto tryNextServer;
                }

                port = (port * 10) + (*portPtr++ - L'0');
            }
            if (port == 0) {
                port = LOWORD( PortNumber );
            }
            *endOfHost = L'\0';
        } else {
            endOfHost = NULL;
        }

        Connection->SocketAddress.sin_port = (*phtons)( port );

        if ( LdapIsAddressNumeric(hostName) ) {

            Connection->SocketAddress.sin_addr.s_addr = Inet_addrW( hostName );

            if (Connection->SocketAddress.sin_addr.s_addr != INADDR_NONE) {

                rc = LdapWinsockConnect( Connection, port, hostName, timeout, samesite );

                if (!fIsValidDnsSuppliedName) {
                    if (Connection->DnsSuppliedName) {
                        ldapFree( Connection->DnsSuppliedName, LDAP_HOST_NAME_SIGNATURE );
                        Connection->DnsSuppliedName = NULL;
                    }
                }

                //
                // If the user explicitly connects via a numeric IP address, we want to
                // make sure that the resulting SPN contains that IP address, not a
                // retrieved DNS name corresponding to that IP address, for security
                // reasons (DNS can be spoofed).
                //
                // If we're here, the user must have explicitly passed in a IP address,
                // unless we just retrieved the IP address from the locator because the
                // user passed in NULL (fIsValidDnsSuppliedName).
                //
                if (!fIsValidDnsSuppliedName)
                {
                    Connection->ForceHostBasedSPN = TRUE;
                }

            } else {

                IF_DEBUG(CONNECTION) {
                    LdapPrint1( "LDAP inet_addr failed to get address from %S\n", hostName );
                }
            }

        } else {

           struct hostent *hostEntry = NULL;
           BOOLEAN connected = FALSE;
           ULONG dnsSrvRecordCount = 0;
           BOOLEAN LoopBack = FALSE;

           if (ldapWStringsIdentical( 
                        Connection->ListOfHosts,
                        -1,
                        L"localhost",
                        -1)) {
               
               LoopBack = TRUE;
           }

           if ( (Connection->AREC_Exclusive == FALSE) && 
                (tryingExplicitHost == FALSE) &&
                (LoopBack == FALSE)) {
               
               rc = ConnectToSRVrecs( Connection,
                                      hostName,
                                      tryingExplicitHost,
                                      port,
                                      timeout );
               if (rc == LDAP_SUCCESS) {
                   connected = TRUE;
               }
           
           }

            if (connected == FALSE) {

                PWCHAR HostAddress = NULL;
                PWCHAR DnsName = NULL;
                PWCHAR DomainName = NULL;
                PWCHAR hostNameUsedByGetHostByName = hostName;

                //
                //  The hostname is of the form HOSTNAME.  Do a gethostbyname
                //  and try to connect to it.
                //


                hostEntry = GetHostByNameW( hostName );

                if ((hostEntry == NULL) &&
                    (Connection->AREC_Exclusive == FALSE) &&
                    (tryingExplicitHost == FALSE) &&
                    (LoopBack == FALSE)) {

                    wsErr = (*pWSAGetLastError)();

                    IF_DEBUG(CONNECTION) {
                       LdapPrint2( "LDAP gethostbyname failed for %S, 0x%x\n", hostName, wsErr );
                    }

                    rc = ERROR_INCORRECT_ADDRESS;

                    // now we try to connect to the name as if it were a
                    // domain name.  We've already checked SRV records, so
                    // try to make it work simply for a flat name like "ntdev".

                    if ((dnsSrvRecordCount == 0) &&
                        (tryingExplicitHost == FALSE)) {

                            DWORD numAddrs = 1;
                            samesite= FALSE;

                            rc = GetDefaultLdapServer(    hostName,
                                                          &HostAddress,
                                                          &DnsName,
                                                          &DomainName,
                                                          &numAddrs,
                                                          Connection->GetDCFlags | DS_IS_FLAT_NAME,
                                                          &samesite,
                                                          port,
                                                          &Connection->ResolvedGetDCFlags
                                                          );

                            if ((rc == 0) && (HostAddress != NULL)) {

                                if ( LdapIsAddressNumeric(HostAddress) ) {

                                    Connection->SocketAddress.sin_addr.s_addr = Inet_addrW( HostAddress );

                                    if (Connection->SocketAddress.sin_addr.s_addr != INADDR_NONE) {

                                        rc = LdapWinsockConnect( Connection, port, HostAddress, timeout, samesite );

                                        //
                                        //  if we succeeded here, we have to
                                        //  move the HostName pointer in the
                                        //  connection record to point to the
                                        //  domain name since the server name
                                        //  may go away
                                        //
                                        // Also, store the real machine name in
                                        // the DnsSuppliedName field to be
                                        // used later for making up the SPN
                                        // during bind.
                                        //

                                        if (rc == 0) {

                                            Connection->HostNameW = hostName;
                                            Connection->DnsSuppliedName = DnsName;
                                            Connection->DomainName = DomainName;
                                        }

                                    } else {

                                        IF_DEBUG(CONNECTION) {
                                            LdapPrint1( "LDAP inet_addr failed to get address from %S\n", hostName );
                                        }
                                        rc = ERROR_INCORRECT_ADDRESS;
                                    }
                                } else {

                                    hostEntry = GetHostByNameW( HostAddress );
                                    hostNameUsedByGetHostByName = HostAddress;
                                    rc = ERROR_INCORRECT_ADDRESS;
                                }

                            } else {

                                rc = ERROR_INCORRECT_ADDRESS;
                            }
                    }

                }

                if (hostEntry != NULL) {

                   //
                   // gethostbyname has returned us a list of addresses which we
                   // can use to do a parallel connect.
                   //
                   rc = ConnectToArecs( Connection,
                                        hostEntry,
                                        tryingExplicitHost,
                                        port,
                                        timeout );

                   if (rc == LDAP_SUCCESS) {
                      
                       connected = TRUE;

#if LDAPDBG
                      if ( (Connection->AREC_Exclusive == FALSE) && (tryingExplicitHost == FALSE) ) {

                          char tempBuff[1000]; 
                          DWORD tempErr = GetModuleFileName( NULL, tempBuff, 1000);

                          if (tempErr == 0) {
                              LdapPrint1("Process 0x%x is calling LDAP without setting the LDAP_OPT_AREC_EXCLUSIVE flag\n", GetCurrentProcessId());
                              LdapPrint0("Using this flag when passing in a fully-qualified server DNS name can\n");
                              LdapPrint0("improve the performance of this application when connecting.\n");
                              LdapPrint0("You can use tlist.exe to get the process name of the application.\n");
                          } else {
                              LdapPrint2("%s [PID 0x%x] is calling LDAP without setting the LDAP_OPT_AREC_EXCLUSIVE flag\n", tempBuff, GetCurrentProcessId());
                              LdapPrint0("Using this flag when passing in a fully-qualified server DNS name can\n");
                              LdapPrint0("improve the performance of this application when connecting.\n");                              
                          }
                      }
#endif
                   }
                }

                if (HostAddress != NULL) {

                    if (rc == 0) {

                        ldapFree( Connection->ExplicitHostName, LDAP_HOST_NAME_SIGNATURE );
                        Connection->ExplicitHostName = HostAddress;

                    } else {

                        ldapFree( HostAddress, LDAP_HOST_NAME_SIGNATURE );
                    }
                }
            }

            //
            // Free the hostent structure if we have allocated it
            //

            if (hostEntry &&
                pWSALookupServiceBeginW &&
                pWSALookupServiceNextW &&
                pWSALookupServiceEnd) {

                PCHAR* temp = hostEntry->h_addr_list;
                int i=0;

                while (temp[i]) {
                    ldapFree(temp[i], LDAP_ANSI_SIGNATURE);
                    i++;
                }

                ldapFree(temp, LDAP_ANSI_SIGNATURE);
                ldapFree(hostEntry->h_name, LDAP_HOST_NAME_SIGNATURE);
                ldapFree(hostEntry->h_aliases, LDAP_HOST_NAME_SIGNATURE);
                ldapFree(hostEntry, LDAP_ANSI_SIGNATURE);
            }

        }

        if (endOfHost != NULL) {
            *endOfHost = L':';
        }

tryNextServer:
        if (rc != 0) {

            hostsTried++;

            //
            // go to next host
            //

            while (*hostName != L'\0') {
                hostName++;
            }
            hostName++;
        }
    }

    if ((rc != 0) && (tryingExplicitHost == TRUE)) {

        tryingExplicitHost = FALSE;
        goto RetryWithoutExplicitHost;
    }

    if ((rc == 0) && (tryingExplicitHost == TRUE)) {

        //
        //  if we succeeded here, we have to move the HostName pointer in the
        //  connection record to point to the domain name since the server name
        //  may go away.
        //

       if ((Connection->HostNameW != NULL) &&
            (Connection->HostNameW != Connection->ListOfHosts) &&
           (Connection->HostNameW != Connection->ExplicitHostName)) {

          ldapFree( Connection->HostNameW, LDAP_HOST_NAME_SIGNATURE );
       }
        Connection->HostNameW = Connection->ListOfHosts;
    }

    if ((rc==0) && (hostsTried)) {
        //
        // The Hostname ptr will be pointing somewhere inbetween the ListOfHost
        // we have to reset it.
        //

        Connection->HostNameW = Connection->ListOfHosts;
    }

    //
    // We finally need an ANSI version of the hostname on the connection
    // block to be compliant with the UMICH implementation.
    //

    ldapFree( Connection->publicLdapStruct.ld_host, LDAP_HOST_NAME_SIGNATURE );

    FromUnicodeWithAlloc( Connection->HostNameW,
                          &Connection->publicLdapStruct.ld_host,
                          LDAP_HOST_NAME_SIGNATURE,
                          LANG_ACP
                          );


    if ( ( rc == 0 ) && ( Connection->SslPort ) ) {

        rc = LdapSetupSslSession( Connection );
    }

    START_LOGGING;
    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0]"));
    DSLOG((0,"[OP=ldap_open][SV=%s][ST=%I64d][ET=%I64d][ER=%d][-]\n",
           Connection->publicLdapStruct.ld_host, startTime, LdapGetTickCount(), rc));
    END_LOGGING;

    return rc;
}

ULONG
LdapWinsockConnect (
    PLDAP_CONN Connection,
    USHORT PortNumber,
    PWCHAR  HostName,
    struct l_timeval  *timeout,
    BOOLEAN samesite
    )
{
    ULONG wsErr;
    BOOLEAN isAsync = FALSE;
    ULONG nonblockingMode;
    BOOLEAN tcpSocket = (Connection->TcpHandle != INVALID_SOCKET) ? TRUE : FALSE;

    //
    //  we call connect both for UDP and TCP.  With UDP, it just
    //  associates the address with the socket.
    //  With TCP, we leave the socket in nonblocking mode.
    //

    if (tcpSocket && pioctlsocket) {

        nonblockingMode = 1;
        isAsync = TRUE;

        //
        //  We set the socket to nonblocking, do the connect, call select
        //  with the timeout value, and fail the whole thing if it doesn't
        //  work.
        //

        wsErr = (*pioctlsocket)( Connection->TcpHandle,
                                 FIONBIO,
                                 &nonblockingMode
                                );

        if (wsErr != 0) {

            //
            //  if it fails, we just do a synchronous connect... we tried.
            //

            wsErr = (*pWSAGetLastError)();

            IF_DEBUG(NETWORK_ERRORS) {
                LdapPrint2( "LDAP conn %u ioclsocket returned 0x%x\n", Connection, wsErr );
            }

            isAsync = FALSE;
        }
    }

    if (tcpSocket && psetsockopt && Connection->UseTCPKeepAlives) {

        // turn on TCP keep-alives if requested
        
        int t = TRUE;

        wsErr = (*psetsockopt)( Connection->TcpHandle,
                                SOL_SOCKET,
                                SO_KEEPALIVE,
                                reinterpret_cast<char*>(&t),
                                sizeof(t)
                              );

        if (wsErr != 0) {
        
            // we'll treat failure to turn on keep-alives as non-fatal
            wsErr = (*pWSAGetLastError)();

            IF_DEBUG(NETWORK_ERRORS) {
                LdapPrint2( "LDAP conn %u setsockopt for keepalive returned 0x%x\n", Connection, wsErr );
            }
        }

    }

TryConnectAgain:

    wsErr = (*pconnect)(get_socket( Connection ),
                        (struct sockaddr *)&Connection->SocketAddress,
                        sizeof(Connection->SocketAddress) );

    if (wsErr != 0) {

        wsErr = (*pWSAGetLastError)();

        //
        //  if someone in our process set OVERLAPPED to TRUE for all sockets,
        //  then the connect will fail here if we've set it to nonblocking
        //  mode, so we'll pick up this error code and revert to blocking.
        //

        if (wsErr == WSAEINVAL && isAsync == TRUE) {

            IF_DEBUG(CONNECT) {
                LdapPrint2( "LDAP connect switching back to sync for host %S, port %u\n",
                        HostName, PortNumber );
            }

            SOCKET newSocket = (*psocket)(PF_INET,
                                          tcpSocket ? SOCK_STREAM : SOCK_DGRAM,
                                          0);

            if (newSocket != INVALID_SOCKET) {

                if (psetsockopt) {
                    // prevent socket hijacking
                
                    BOOL t = TRUE;

                    (*psetsockopt)( newSocket,
                                    SOL_SOCKET,
                                    SO_EXCLUSIVEADDRUSE,
                                    reinterpret_cast<char*>(&t),
                                    sizeof(t) );
                }

                BeginSocketProtection( Connection );

                int sockerr = (*pclosesocket)( tcpSocket ? Connection->TcpHandle : Connection->UdpHandle);
                ASSERT(sockerr == 0); 

                if (tcpSocket) {
                    Connection->TcpHandle = newSocket;
                } else {
                    Connection->UdpHandle = newSocket;
                }

                EndSocketProtection( Connection );

                isAsync = FALSE;
                goto TryConnectAgain;
            }
        }

        if (wsErr == 0) {

            wsErr = WSA_WAIT_TIMEOUT;
        }
        IF_DEBUG(CONNECTION) {
            LdapPrint3( "LDAP connect returned err %u for addr %S, port %u\n",
                    wsErr, HostName, PortNumber );
        }
    }

    if (isAsync) {

        BOOLEAN failedSelect = FALSE;

        if (wsErr == WSAEWOULDBLOCK) {

            fd_set writeSelectSet;
            fd_set excSelectSet;
            timeval selectTimeout;

            FD_ZERO( &writeSelectSet );
            FD_SET( Connection->TcpHandle, &writeSelectSet );
            FD_ZERO( &excSelectSet );
            FD_SET( Connection->TcpHandle, &excSelectSet );

                  if (timeout == NULL) {

                     if (samesite == TRUE) {

                        //
                        // We are connecting to servers in the same site. We can afford
                        // to have a small timeout.
                        //

                        selectTimeout.tv_sec = SAMESITE_CONNECT_TIMEOUT;
                        selectTimeout.tv_usec = 0;

                     } else {

                        selectTimeout.tv_sec = LDAP_CONNECT_TIMEOUT;
                        selectTimeout.tv_usec = 0;

                     }
                  } else {

                     //
                     // honor the user specified timeout
                     //

                     selectTimeout.tv_sec = timeout->tv_sec;
                     selectTimeout.tv_usec = timeout->tv_usec;
                  }

            wsErr = (*pselect)(   0,
                                  NULL,
                                  &writeSelectSet,
                                  &excSelectSet,
                                  &selectTimeout );

            if ((wsErr == SOCKET_ERROR) || (wsErr == 0)) {

failedSelect:
                if (wsErr == SOCKET_ERROR) {

                    wsErr = (*pWSAGetLastError)();
                }

                if (wsErr == 0) {

                    wsErr = WSA_WAIT_TIMEOUT;
                }

                IF_DEBUG(NETWORK_ERRORS) {
                    LdapPrint2( "LDAP conn 0x%x connect/select returned %u\n", Connection, wsErr );
                }

                failedSelect = TRUE;

                ASSERT( wsErr != 0 );

            } else {

                if ((*pwsafdisset)(Connection->TcpHandle, &writeSelectSet )) {

                    wsErr = 0;

                } else {

                    IF_DEBUG(CONNECTION) {
                        LdapPrint3( "LDAP connect returned err 0x%x for addr %S, port %u\n",
                                wsErr, HostName, PortNumber );
                    }
                    wsErr = (ULONG) SOCKET_ERROR;
                    goto failedSelect;
                }
            }
        }
    }

    if (wsErr == 0) {

        Connection->PortNumber = PortNumber;

        IF_DEBUG(CONNECTION) {
            LdapPrint2( "LDAP conn 0x%x connected to addr %S\n", Connection, HostName );
        }

        if (( PortNumber == LDAP_SERVER_PORT_SSL ) ||
            ( PortNumber == LDAP_SSL_GC_PORT)) {

            Connection->SslPort = TRUE;
        }

        Connection->HostNameW = HostName;

    } else {

        IF_DEBUG(CONNECTION) {
            LdapPrint4( "LDAP conn 0x%x connecting to addr %S, port %u err = 0x%x\n",
                    Connection, HostName, PortNumber, wsErr );
        }

        SOCKET newSocket = (*psocket)(PF_INET,
                                      tcpSocket ? SOCK_STREAM : SOCK_DGRAM,
                                      0);

        if (newSocket != INVALID_SOCKET) {

            if (psetsockopt) {
                // prevent socket hijacking
            
                BOOL t = TRUE;

                (*psetsockopt)( newSocket,
                                SOL_SOCKET,
                                SO_EXCLUSIVEADDRUSE,
                                reinterpret_cast<char*>(&t),
                                sizeof(t) );
            }

            BeginSocketProtection( Connection );

            int sockerr = (*pclosesocket)( tcpSocket ? Connection->TcpHandle : Connection->UdpHandle);
            ASSERT(sockerr == 0); 

            if (tcpSocket) {
                Connection->TcpHandle = newSocket;
            } else {
                Connection->UdpHandle = newSocket;
            }

            EndSocketProtection( Connection );

        }
    }

    return wsErr;
}


//
//   This is the function which takes in an LDAP handle returned
//   from ldap_init( ) and connects to the server for you
//

ULONG __cdecl ldap_connect (
    LDAP *ExternalHandle,
    struct l_timeval  *timeout
    )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapConnect( connection, timeout, FALSE );

    DereferenceLdapConnection( connection );

    return err;
}

ULONG
LdapConnect (
    PLDAP_CONN connection,
    struct l_timeval  *timeout,
    BOOLEAN DontWait
    )
{
    ULONG err;
    BOOLEAN haveLock = FALSE;

    //
    // Check if the connection has already been established
    // if yes, simply return. If not, establish it
    //

    if ( connection->HostConnectState == HostConnectStateConnected ) {

        return LDAP_SUCCESS;
    }

waitAgain:

    if (haveLock == FALSE) {
        ACQUIRE_LOCK( &connection->StateLock );
        haveLock = TRUE;
    }

    //
    //  single thread the call to OpenLdapServer
    //

    if ( connection->HostConnectState == HostConnectStateConnected ) {

        IF_DEBUG(CONNECT) {
            LdapPrint1( "ldap_connect reports connection 0x%x already connected\n",
                            connection );
        }
        err = LDAP_SUCCESS;
        goto connectDone;
    }

    if (( connection->ServerDown == TRUE) && (connection->AutoReconnect == FALSE) ) {

       err = LDAP_SERVER_DOWN;
       goto connectDone;
    }

    if (connection->ConnObjectState != ConnObjectActive) {

        IF_DEBUG(CONNECT) {
            LdapPrint3( "ldap_connect connection 0x%x is in state 0x%x for thread 0x%x\n",
                            connection,
                            connection->ConnObjectState,
                            GetCurrentThreadId() );
        }
        err = LDAP_USER_CANCELLED;
        goto connectDone;
    }

    //
    //  if no thread is currently handling the reconnect, volunteer... but then
    //  don't go into a wait state waiting for someone else to do it.
    //

    if (DontWait == FALSE) {

        if ((connection->HostConnectState == HostConnectStateError) &&
            (connection->AutoReconnect == TRUE)) {

            //
            // Let go of the StateLock while waiting for the ReconnectLock
            //

            RELEASE_LOCK( &connection->StateLock );
            haveLock = FALSE;
            ACQUIRE_LOCK( &connection->ReconnectLock );

            //
            // Grab the StateLock again before checking the state which
            // could have changed while we were waiting for the ReconnectLock
            //

            ACQUIRE_LOCK( &connection->StateLock );
            haveLock = TRUE;

            if ((connection->HostConnectState == HostConnectStateError) &&
                (connection->AutoReconnect == TRUE)) {

                    IF_DEBUG(CONNECT) {
                        LdapPrint2( "ldap_connect connection 0x%x is in error state for thread 0x%x, reconnecting...\n",
                                        connection,
                                        GetCurrentThreadId() );
                    }

                    //
                    //  we'll call off to autoreconnect and then recursively come back in
                    //  here.  kind of ugly, but auto-reconnect involves a lot of
                    //  processing, so we keep it in one place.
                    //

                    connection->HostConnectState = HostConnectStateReconnecting;
                    RELEASE_LOCK( &connection->StateLock );
                    haveLock = FALSE;

                    err = LdapAutoReconnect( connection );

                    RELEASE_LOCK( &connection->ReconnectLock );

                    goto connectDone;

            }

            RELEASE_LOCK( &connection->ReconnectLock );
            goto waitAgain;

        }

        if (haveLock == FALSE) {
            ACQUIRE_LOCK( &connection->StateLock );
            haveLock = TRUE;
        }

        //
        //  if some other thread is doing the reconnect, wait for it to finish
        //

        if ((( connection->HostConnectState == HostConnectStateConnecting ) ||
             ( connection->HostConnectState == HostConnectStateReconnecting ))) {

            IF_DEBUG(CONNECT) {
                LdapPrint2( "ldap_connect thread 0x%x is waiting on connection 0x%x\n",
                                GetCurrentThreadId(),
                                connection );
            }
            RELEASE_LOCK( &connection->StateLock );
            haveLock = FALSE;

            WaitForSingleObjectEx( connection->ConnectEvent,
                                   INFINITE,
                                   TRUE );         // alertable
            goto waitAgain;
        }
    }

    ResetEvent( connection->ConnectEvent );
    connection->HostConnectState = HostConnectStateConnecting;

    IF_DEBUG(CONNECT) {
        LdapPrint2( "ldap_connect thread 0x%x is opening connection 0x%x\n",
                        GetCurrentThreadId(),
                        connection );
    }

    RELEASE_LOCK( &connection->StateLock );
    haveLock = FALSE;

    //
    //  open a connection to any of the servers specified
    //

    err = OpenLdapServer( connection, timeout );

    //
    //  If we couldn't open the LDAP server, then the address that
    //  DsGetDCName passed us isn't valid (or the value in the
    //  registry isn't valid).  Either way, we mark to force rediscovery
    //  and then try this whole thing again.
    //

    ACQUIRE_LOCK( &connection->StateLock );
    haveLock = TRUE;

    if (err != 0) {

        connection->HostConnectState = HostConnectStateError;
        if (DontWait == FALSE) {
            SetEvent( connection->ConnectEvent );
        }

        IF_DEBUG(CONNECT) {
            LdapPrint2( "LdapConnect failed to open connection 0x%x, err = 0x%x.\n",
                connection, err);
        }

        IF_DEBUG(SERVERDOWN) {
            LdapPrint2( "LdapConnect thread 0x%x has connection 0x%x as down.\n",
                            GetCurrentThreadId(),
                            connection );
        }
        err = LDAP_SERVER_DOWN;
        goto connectDone;
    }

    IF_DEBUG(CONNECT) {
        LdapPrint2( "ldap_connect thread 0x%x has opened connection 0x%x\n",
                        GetCurrentThreadId(),
                        connection );
    }

    connection->HostConnectState = HostConnectStateConnected;
    if (DontWait == FALSE) {
        SetEvent( connection->ConnectEvent );
    }

    if (connection->ConnObjectState != ConnObjectActive) {

        IF_DEBUG(CONNECT) {
            LdapPrint1( "LdapConnect connection 0x%x is closing.\n", connection);
        }

        err = LDAP_USER_CANCELLED;
        goto connectDone;
    }

    IF_DEBUG(CONNECTION) {
        LdapPrint2( "ldap_connect marking 0x%x as open, host is %S.\n",
                       connection, connection->HostNameW );
    }

    LdapWakeupSelect();

connectDone:

    IF_DEBUG(CONNECT) {
        LdapPrint3( "ldap_connect thread 0x%x is leaving for conn 0x%x with 0x%x\n",
                        GetCurrentThreadId(),
                        connection,
                        err );
    }

    if (haveLock) {
        RELEASE_LOCK( &connection->StateLock );
    }

    SetConnectionError(connection, err, NULL);
    return(err);
}

BOOLEAN
LdapIsAddressNumeric (
    PWCHAR HostName
    )
{
    BOOLEAN rc = FALSE;

    //
    //  to check to see if it's a TCP address, we check for it to only
    //  contain only numerals and periods.
    //

    while (((*HostName >= L'0') && (*HostName <= L'9')) ||
            (*HostName == L'.')) {
        HostName++;
    }

    //
    //  if we hit the end of the hostname, then it's an address.
    //

    if (*HostName == L'\0' || *HostName == L':') {

        rc = TRUE;
    }
    return rc;
}



ULONG
ConnectToSRVrecs(
    PLDAP_CONN Connection,
    PWCHAR HostName,
    BOOLEAN SuggestedHost,
    USHORT port,
    struct l_timeval  *timeout
    )
//
// HostName can be of the form "ntdsdc1.ntdev.microsoft.com" or simply
// "ntdev.microsoft.com". If this is a SuggestedHost, we try to connect to
// that host first (1 second preference) before the rest of the address records.
//
//
{
    HANDLE enumHandle = NULL;
    PWCHAR hostname = NULL;
    ULONG hostCount;
    LPWSTR site = NULL;
    ULONG rc = LDAP_SUCCESS;
    BOOLEAN GetDcSucceeded = FALSE;
    BOOLEAN StartedEnumeration = FALSE;
    ULONG totalCount = 0;
    struct l_timeval localtimeout = {0};
    PWCHAR Address = NULL;
    PWCHAR DnsHostName = NULL;
    PWCHAR DomainName = NULL;
    PSOCKHOLDER2  sockAddressArr[MAX_SOCK_ADDRS];

    //
    // Initialize all elements of our SOCKHOLDER2 array.
    //

    for (int j=0; j<MAX_SOCK_ADDRS; j++ ) {

        sockAddressArr[j] = NULL;
    }

    hostname = ( HostName==NULL ) ? Connection->ListOfHosts : HostName;

    //
    // If a hostname wasn't suggested, we try DsGetDcName
    // because it will return to us a "sticky" address to connect to. This will
    // ensure that we always hit the same DC everytime someone comes in with a
    // domain name like "ntdev.microsoft.com". This will also ensure that if we
    // are on a DC, we connect to the same machine without going on the wire. Note
    // that if the "sticky" DC goes down, the user has to repeat the process
    // with the ForceVerify flag set.
    //
    // Note that we assume the hostname is of a DNS style name. This is to prevent
    // DsGetDcName from performing a lengthy NetBT broadcast.
    //
    //


    if ( SuggestedHost == FALSE ) {

        sockaddr_in *ptemp;
        BOOLEAN samesite = FALSE;
        DWORD numAddrs = 1;
        ULONG tempAddr = 0;
        ULONG Flags = 0;
        BOOLEAN ForcedRetry = FALSE;

TryAgain:

        if (ForcedRetry) {
            Flags = DS_FORCE_REDISCOVERY;
        }

        rc = GetDefaultLdapServer( hostname,
                                   &Address,
                                   &DnsHostName,
                                   &DomainName,
                                   &numAddrs,
                                   Connection->GetDCFlags | Flags | DS_IS_DNS_NAME,
                                   &samesite,
                                   Connection->PortNumber,
                                   &Connection->ResolvedGetDCFlags
                                   );


        if ((rc == NO_ERROR) && (Address != NULL)) {

            sockAddressArr[totalCount] = (PSOCKHOLDER2)ldapMalloc(sizeof(SOCKHOLDER2), LDAP_SOCKADDRL_SIGNATURE);

            if (sockAddressArr[totalCount] == NULL) {
                rc = LDAP_NO_MEMORY;
                goto ExitWithCleanup;
            }

            sockAddressArr[totalCount]->psocketaddr = (LPSOCKET_ADDRESS)ldapMalloc(sizeof(SOCKET_ADDRESS), LDAP_SOCKADDRL_SIGNATURE);

            if (sockAddressArr[totalCount]->psocketaddr == NULL) {

                ldapFree(sockAddressArr[totalCount],LDAP_SOCKADDRL_SIGNATURE );
                sockAddressArr[totalCount] = NULL;
                rc = LDAP_NO_MEMORY;
                goto ExitWithCleanup;
            }

            sockAddressArr[totalCount]->psocketaddr->lpSockaddr = (LPSOCKADDR)ldapMalloc(sizeof(SOCKADDR), LDAP_SOCKADDRL_SIGNATURE);

            if (sockAddressArr[totalCount]->psocketaddr->lpSockaddr == NULL) {

                ldapFree(sockAddressArr[totalCount]->psocketaddr,LDAP_SOCKADDRL_SIGNATURE );
                ldapFree(sockAddressArr[totalCount],LDAP_SOCKADDRL_SIGNATURE );
                sockAddressArr[totalCount] = NULL;
                rc = LDAP_NO_MEMORY;
                goto ExitWithCleanup;
            }

            ptemp = (sockaddr_in *) sockAddressArr[totalCount]->psocketaddr->lpSockaddr;
            sockAddressArr[totalCount]->psocketaddr->iSockaddrLength = sizeof(sockaddr_in);

            tempAddr = Inet_addrW( Address );

            if (tempAddr != INADDR_NONE) {

               CopyMemory( &(ptemp->sin_addr.s_addr), &tempAddr, sizeof(tempAddr) );
               ptemp->sin_family = AF_INET;
               ptemp->sin_port = (*phtons)( port );
               GetDcSucceeded = TRUE;

            } else {

               ldapFree(sockAddressArr[totalCount]->psocketaddr->lpSockaddr,LDAP_SOCKADDRL_SIGNATURE );
               ldapFree(sockAddressArr[totalCount]->psocketaddr,LDAP_SOCKADDRL_SIGNATURE );
               ldapFree(sockAddressArr[totalCount],LDAP_SOCKADDRL_SIGNATURE );
               sockAddressArr[totalCount] = NULL;
               rc = LDAP_LOCAL_ERROR;
            }

        }

        if ((rc == LDAP_SUCCESS) && (GetDcSucceeded)) {

            //
            // We give the address returned by DsGetDcName preference. Keep in mind
            // that this server may not respond in 1 second in which case we move
            // on to enumerate DNS records.
            //

            sockAddressArr[totalCount]->DnsSuppliedName = DnsHostName;
            DnsHostName = NULL;

            IF_DEBUG(CONNECTION) {
                LdapPrint1("Dns supplied hostname from DsGetDcName is %s\n", sockAddressArr[totalCount]->DnsSuppliedName);
            }
            totalCount++;
            sockAddressArr[totalCount] = NULL;   // Null terminate the array.
            localtimeout.tv_sec = LDAP_QUICK_TIMEOUT;

            if (ForcedRetry) {
             
                //
                // This must be a reachable DC we are connecting to. Wait twice
                // as long if necessary.
                //

                localtimeout.tv_sec = localtimeout.tv_sec * 2;
            }

            localtimeout.tv_usec = 0;

            rc = LdapParallelConnect( Connection,
                                   &sockAddressArr[0],
                                   port,
                                   totalCount,
                                   &localtimeout
                                   );

            if (rc == LDAP_SUCCESS) {

                Connection->HostNameW = ldap_dup_stringW( hostname,
                                                         0,
                                                         LDAP_HOST_NAME_SIGNATURE );
                Connection->DomainName = DomainName;
                DomainName = NULL;

                goto ExitWithCleanup;

            }

            //
            // We failed to connect to the DC returned from DsGetDcName. Maybe
            // it was a cached DC and has gone down since. Let's force the
            // locator to find a fresh DC.
            //

            ldapFree( DomainName, LDAP_HOST_NAME_SIGNATURE );
            DomainName = NULL;
            ldapFree( Address, LDAP_HOST_NAME_SIGNATURE);
            Address = NULL;

            if (!ForcedRetry) {
             
                ForcedRetry = TRUE;
                goto TryAgain;
            }

        }
    }

    //
    // This could be a third party SRV record registration. DsGetDcName will
    // not find such a name by default.
    //
    // Note that if this is not a third party SRV record domain but an A record
    // instead, it will result in unnecessary delay and traffic. For this reason,
    // applications MUST specify the LDAP_OPT_AREC_EXCLUSIVE flag when specifying
    // SRV records.
    //

    rc = InitLdapServerFromDomain( hostname,
                                   Connection->GetDCFlags | DS_ONLY_LDAP_NEEDED,
                                   &enumHandle,
                                   &site
                                   );

    if (rc != LDAP_SUCCESS) {

        goto ExitWithCleanup;
    }

    StartedEnumeration = TRUE;

    while (totalCount < MAX_SOCK_ADDRS-1) {

        LPSOCKET_ADDRESS  sockAddresses;

        //
        // Try to collect all the addresses into the array of addresses
        //

        hostCount = 0;

        rc = NextLdapServerFromDomain( enumHandle,
                                       &sockAddresses,
                                       &DnsHostName,
                                       &hostCount
                                       );

        if (rc != NO_ERROR) {

            break;
        }

        ULONG count = 0;


        while ((count < hostCount) && (totalCount < MAX_SOCK_ADDRS-1)) {

            sockAddressArr[totalCount] = (PSOCKHOLDER2)ldapMalloc(sizeof(SOCKHOLDER2), LDAP_SOCKADDRL_SIGNATURE);

            if (sockAddressArr[totalCount] == NULL) {
                rc = LDAP_NO_MEMORY;
                goto ExitWithCleanup;
            }

            sockAddressArr[totalCount]->psocketaddr = (LPSOCKET_ADDRESS)ldapMalloc(sizeof(SOCKET_ADDRESS), LDAP_SOCKADDRL_SIGNATURE);

            if (sockAddressArr[totalCount]->psocketaddr == NULL) {
                ldapFree(sockAddressArr[totalCount],LDAP_SOCKADDRL_SIGNATURE );
                sockAddressArr[totalCount] = NULL;
                rc = LDAP_NO_MEMORY;
                goto ExitWithCleanup;
            }

            sockAddressArr[totalCount]->psocketaddr->lpSockaddr = (LPSOCKADDR)ldapMalloc(max(sizeof(SOCKADDR), (&sockAddresses[count])->iSockaddrLength),
                                                                                         LDAP_SOCKADDRL_SIGNATURE);

            if (sockAddressArr[totalCount]->psocketaddr->lpSockaddr == NULL) {
                ldapFree(sockAddressArr[totalCount]->psocketaddr,LDAP_SOCKADDRL_SIGNATURE );
                ldapFree(sockAddressArr[totalCount],LDAP_SOCKADDRL_SIGNATURE );
                sockAddressArr[totalCount] = NULL;
                rc = LDAP_NO_MEMORY;
                goto ExitWithCleanup;
            }

            sockAddressArr[totalCount]->psocketaddr->iSockaddrLength = (&sockAddresses[count])->iSockaddrLength;

            CopyMemory(sockAddressArr[totalCount]->psocketaddr->lpSockaddr,
                       (&sockAddresses[count])->lpSockaddr,
                       (&sockAddresses[count])->iSockaddrLength);

            sockAddressArr[totalCount]->DnsSuppliedName = ldap_dup_stringW( DnsHostName,
                                                                            0,
                                                                            LDAP_HOST_NAME_SIGNATURE
                                                                            );

            IF_DEBUG(CONNECTION) {
                LdapPrint3("Dns supplied hostname from DsGetDcNext is %s totalcount %d intermediatecount %d\n", sockAddressArr[totalCount]->DnsSuppliedName, totalCount, count );
            }

            totalCount++;
            count++;

        }

        ldapFree( DnsHostName, LDAP_HOST_NAME_SIGNATURE );
        DnsHostName = NULL;

        LocalFree( sockAddresses );
    }

    sockAddressArr[totalCount] = NULL;

    IF_DEBUG(CONNECTION) {
        LdapPrint2("Collected a total of %d address records for host %S\n",totalCount, hostname);
    }

    if (totalCount == 0) {

        CloseLdapServerFromDomain( enumHandle, site );
        return rc;
    }

    //
    // We can now connect to any address in this null terminated array.
    //

    if (timeout == NULL) {

        if (site != NULL) {

            //
            // We are connecting to servers in the same site. We can afford
            // to have a small timeout.
            //


            localtimeout.tv_sec = (SuggestedHost) ? LDAP_QUICK_TIMEOUT : SAMESITE_CONNECT_TIMEOUT;
            localtimeout.tv_usec = 0;

        } else {

            localtimeout.tv_sec = (SuggestedHost) ? LDAP_QUICK_TIMEOUT : LDAP_CONNECT_TIMEOUT;
            localtimeout.tv_usec = 0;

        }
    } else {

        //
        // honor the user specified timeout
        //

        localtimeout.tv_sec = (SuggestedHost) ? 1:timeout->tv_sec;
        localtimeout.tv_usec = timeout->tv_usec;
    }

    rc = LdapParallelConnect( Connection,
                              &sockAddressArr[0],
                              port,
                              totalCount,
                              &localtimeout
                              );

    if (rc == LDAP_SUCCESS) {
        Connection->HostNameW = ldap_dup_stringW( hostname,
                                                  0,
                                                  LDAP_HOST_NAME_SIGNATURE );

    }


ExitWithCleanup:

    //
    // Cleanup allocated socket addresses.
    //

    ULONG i =0;

    while (sockAddressArr[i] != NULL) {
        ldapFree(sockAddressArr[i]->psocketaddr->lpSockaddr, LDAP_SOCKADDRL_SIGNATURE);
        ldapFree(sockAddressArr[i]->psocketaddr, LDAP_SOCKADDRL_SIGNATURE);
        ldapFree(sockAddressArr[i]->DnsSuppliedName, LDAP_HOST_NAME_SIGNATURE);
        ldapFree(sockAddressArr[i], LDAP_SOCKADDRL_SIGNATURE);
        sockAddressArr[i] = NULL;
        i++;
    }

    if ( Address != NULL) {
        ldapFree( Address, LDAP_HOST_NAME_SIGNATURE );
    }

    if ( DnsHostName != NULL ) {
        ldapFree( DnsHostName, LDAP_HOST_NAME_SIGNATURE );
    }

    if ( DomainName != NULL) {
        ldapFree( DomainName, LDAP_HOST_NAME_SIGNATURE );
    }


    if ( StartedEnumeration ) {
        CloseLdapServerFromDomain( enumHandle, site );
    }

    return rc;

}


ULONG
ConnectToArecs(
    PLDAP_CONN  Connection,
    struct hostent  *hostEntry,
    BOOLEAN SuggestedHost,
    USHORT port,
    struct l_timeval  *timeout
    )
{

   PSOCKHOLDER2  sockAddressArr[MAX_SOCK_ADDRS];
   sockaddr_in *ptemp;
   ULONG rc, hostCount = 0;
   PCHAR hostAddr = hostEntry->h_addr_list[0];

   while ((hostAddr != NULL) && (hostCount < MAX_SOCK_ADDRS-1)) {

      //
      // Allocate both the SOCKET_ADDRESS & sockaddr structures
      //
      sockAddressArr[hostCount] = (PSOCKHOLDER2)ldapMalloc(sizeof(SOCKHOLDER2), LDAP_SOCKADDRL_SIGNATURE);

      if (sockAddressArr[hostCount] == NULL) {

         rc = LDAP_NO_MEMORY;
         goto ExitWithCleanup;

      }

      sockAddressArr[hostCount]->psocketaddr = (LPSOCKET_ADDRESS)ldapMalloc(sizeof(SOCKET_ADDRESS), LDAP_SOCKADDRL_SIGNATURE);

      if (sockAddressArr[hostCount]->psocketaddr == NULL) {

         rc = LDAP_NO_MEMORY;
         goto ExitWithCleanup;
      }

      sockAddressArr[hostCount]->psocketaddr->lpSockaddr = (LPSOCKADDR)ldapMalloc(sizeof(SOCKADDR), LDAP_SOCKADDRL_SIGNATURE);

      if (sockAddressArr[hostCount]->psocketaddr->lpSockaddr == NULL) {

         rc = LDAP_LOCAL_ERROR;
         goto ExitWithCleanup;
      }

      ptemp = (sockaddr_in *) sockAddressArr[hostCount]->psocketaddr->lpSockaddr;
      sockAddressArr[hostCount]->psocketaddr->iSockaddrLength = sizeof(sockaddr_in);

      ASSERT( sizeof(ptemp->sin_addr.s_addr) == hostEntry->h_length );
      
      if (hostEntry->h_length <= sizeof(ptemp->sin_addr.s_addr)) {
          CopyMemory( &(ptemp->sin_addr.s_addr), hostAddr, hostEntry->h_length );
      }
      else {
         LdapPrint1("h_length is too big (%d)\n", hostEntry->h_length );      
         rc = LDAP_LOCAL_ERROR;
         goto ExitWithCleanup;
      }

      ptemp->sin_family = AF_INET;
      ptemp->sin_port = (*phtons)( port );

      //
      // All address records will have the same name. So, we will not bother
      // to hook up the DNS supplied hostname. We will do it later if the
      // connect is successful.
      //
      sockAddressArr[hostCount]->DnsSuppliedName = NULL;

      hostAddr = hostEntry->h_addr_list[++hostCount];
   }

   sockAddressArr[hostCount] = NULL;

   if (Connection->PortNumber == 0) {
      Connection->PortNumber = LDAP_SERVER_PORT;
   }

   IF_DEBUG(CONNECTION) {
      LdapPrint2("gethostbyname collected %d records for %S\n", hostCount, hostEntry->h_name );
   }


   struct l_timeval localtimeout;


   if (timeout == NULL) {
      //
      // gethostbyname does not give us any site information, so we use a long
      // timeout.
      //

      localtimeout.tv_sec = (SuggestedHost) ? 1:LDAP_CONNECT_TIMEOUT;
      localtimeout.tv_usec = 0;
   } else {

      //
      // honor the user specified timeout
      //

      localtimeout.tv_sec = (SuggestedHost) ? 1:timeout->tv_sec;
      localtimeout.tv_usec = timeout->tv_usec;
   }


   rc = LdapParallelConnect( Connection,
                             &sockAddressArr[0],
                             port,
                             hostCount,
                             &localtimeout
                             );

   if (rc == LDAP_SUCCESS) {

       //
       // Convert from ANSI to Unicode before storing off the hostnames internally
       // We do this only if we called gethostbyname() in winsock 1.1.
       //

       if (pWSALookupServiceBeginW &&
           pWSALookupServiceNextW &&
           pWSALookupServiceEnd) {

           Connection->DnsSuppliedName = ldap_dup_stringW( hostEntry->h_aliases ?
                                                           (PWCHAR)hostEntry->h_aliases : (PWCHAR) hostEntry->h_name,
                                                           0,
                                                           LDAP_HOST_NAME_SIGNATURE
                                                          );
           FromUnicodeWithAlloc( hostEntry->h_aliases ?
                                 (PWCHAR)hostEntry->h_aliases : (PWCHAR) hostEntry->h_name,
                                 &Connection->publicLdapStruct.ld_host,
                                 LDAP_HOST_NAME_SIGNATURE,
                                 LANG_ACP
                                 );

       } else {

           //
           // Probably Win95 without Unicode RNR APIs. We are dealing with a TRUE hostEnt
           // structure.
           //

           ToUnicodeWithAlloc( hostEntry->h_aliases ?
                               hostEntry->h_aliases[0] : hostEntry->h_name,
                               -1,
                               &Connection->DnsSuppliedName,
                               LDAP_HOST_NAME_SIGNATURE,
                               LANG_ACP
                               );

          Connection->publicLdapStruct.ld_host = ldap_dup_string( hostEntry->h_aliases ?
                                                                  hostEntry->h_aliases[0] : hostEntry->h_name,
                                                                  0,
                                                                  LDAP_HOST_NAME_SIGNATURE );

       }

       Connection->HostNameW = ldap_dup_stringW( Connection->DnsSuppliedName,
                                                 0,
                                                 LDAP_HOST_NAME_SIGNATURE
                                                 );


      IF_DEBUG(CONNECTION) {
         LdapPrint1("Successfully connected to host %S\n", Connection->DnsSuppliedName);
      }
   }


ExitWithCleanup:

   for (ULONG i = 0; i < hostCount; i++) {

      if ( sockAddressArr[i]->psocketaddr->lpSockaddr ) {

         ldapFree(sockAddressArr[i]->psocketaddr->lpSockaddr, LDAP_SOCKADDRL_SIGNATURE);

         if ( sockAddressArr[i]->psocketaddr ) {

            ldapFree(sockAddressArr[i]->psocketaddr, LDAP_SOCKADDRL_SIGNATURE);

            if ( sockAddressArr[i] ) {

               ldapFree(sockAddressArr[i], LDAP_SOCKADDRL_SIGNATURE);

            }
         }
      }
   }

   return rc;

}

ULONG
LdapParallelConnect(
       PLDAP_CONN   Connection,
       PSOCKHOLDER2 *sockAddressArr,
       USHORT port,
       UINT totalCount,
       struct l_timeval  *timeout
       )
{
   //
   // we take in an array of pointers to SOCKET_ADDRESS structures. The goal is to try to issue connect
   // to any one of those addresses. To do this, we issues async connects to each address in intervals of
   // 1/10 sec (default).
   //

   SOCKHOLDER sockarray [MAX_PARALLEL_CONNECTS];
   ULONG remainingcount = totalCount;
   ULONG currentset = 0;
   ULONG startingpos = 0;
   ULONG index, k;
   ULONG sockpos = 0;
   ULONG wsErr = 0;
   ULONG nonblockingMode = 1;
   ULONG hoststried = 0;
   ULONG currentsock = 0;
   fd_set writeSelectSet;
   fd_set excSelectSet;
   fd_set retrywriteSelectSet;
   fd_set retryexcSelectSet;   
   timeval selectTimeout;
   ULONGLONG starttime;
   BOOLEAN connected = FALSE;
   BOOLEAN LastTimeout = FALSE;
   BOOLEAN StreamSocket = TRUE;
   ULONG sockErr = 0;

   if ((Connection == NULL)||
       (sockAddressArr == NULL)||
       (totalCount == 0)||
       (timeout == NULL))  {

      return LDAP_PARAM_ERROR;
   }


   port = (port == 0) ? LDAP_SERVER_PORT : port;

   if (( port == LDAP_SERVER_PORT_SSL ) ||
        ( port == LDAP_SSL_GC_PORT ) ) {

      Connection->SslPort = TRUE;
   }

   FD_ZERO( &retrywriteSelectSet );
   FD_ZERO( &retryexcSelectSet );
   selectTimeout.tv_sec = 0;
   selectTimeout.tv_usec = CONNECT_INTERVAL*1000;
   starttime = LdapGetTickCount();


   while ((connected == FALSE) &&
          (remainingcount > 0) &&
          ((LdapGetTickCount() - starttime)/1000 < (DWORD) timeout->tv_sec)) {

      if (remainingcount <= MAX_PARALLEL_CONNECTS) {
   
         currentset = remainingcount;
         remainingcount = 0;
      
      } else {

         currentset = MAX_PARALLEL_CONNECTS;
         remainingcount -= currentset;
      }

      for (index=startingpos, sockpos=0;
            index < (currentset+hoststried);
            index++, startingpos++, sockpos++) {

         ASSERT (sockAddressArr[index] != NULL);
         
         LastTimeout = FALSE;

         //
         // Create an appropriate socket and issue a connect
         //

         if (Connection->TcpHandle != INVALID_SOCKET) {

             sockarray[sockpos].sock = (*psocket)(PF_INET, SOCK_STREAM, 0);

             StreamSocket = TRUE;

         } else {

             sockarray[sockpos].sock = (*psocket)(PF_INET, SOCK_DGRAM, 0);
             StreamSocket = FALSE;
         }

         if (sockarray[sockpos].sock == INVALID_SOCKET) {
             goto ExitWithCleanup;
         }
   
         sockarray[sockpos].psocketaddr = sockAddressArr[index]->psocketaddr;
         sockarray[sockpos].DnsSuppliedName = sockAddressArr[index]->DnsSuppliedName;

         if (psetsockopt) {
            // prevent socket hijacking
        
            BOOL t = TRUE;

            (*psetsockopt)( sockarray[sockpos].sock,
                            SOL_SOCKET,
                            SO_EXCLUSIVEADDRUSE,
                            reinterpret_cast<char*>(&t),
                            sizeof(t) );
         }
   
         wsErr = (*pioctlsocket)( sockarray[sockpos].sock,
                                  FIONBIO,
                                  &nonblockingMode
                                  );
         if (wsErr != 0) {
             LdapPrint1("ioctlsocket failed with 0x%x . .\n", GetLastError());
             LdapCleanupSockets( sockpos+1 );
             goto ExitWithCleanup;
         }


         if (StreamSocket && psetsockopt && Connection->UseTCPKeepAlives) {

            // turn on TCP keep-alives if requested
            
            int t = TRUE;

            wsErr = (*psetsockopt)( sockarray[sockpos].sock,
                                    SOL_SOCKET,
                                    SO_KEEPALIVE,
                                    reinterpret_cast<char*>(&t),
                                    sizeof(t)
                                  );

            if (wsErr != 0) {
            
                // we'll treat failure to turn on keep-alives as non-fatal
                wsErr = (*pWSAGetLastError)();

                IF_DEBUG(NETWORK_ERRORS) {
                    LdapPrint2( "LDAP conn %u setsockopt for keepalive returned 0x%x\n", Connection, wsErr );
                }
            }

         }

        
         sockaddr_in *inetSocket = (sockaddr_in *) sockAddressArr[index]->psocketaddr->lpSockaddr;

         inetSocket->sin_port = (*phtons)( port );

         wsErr = (*pconnect)(sockarray[sockpos].sock,
                             (struct sockaddr *) inetSocket,
                             sizeof(struct sockaddr_in) );

        
         if ((wsErr != SOCKET_ERROR) ||
             (wsErr == SOCKET_ERROR)&&
             ((*pWSAGetLastError)() == WSAEWOULDBLOCK)) {

             FD_SET( sockarray[sockpos].sock, &retrywriteSelectSet );
             FD_SET( sockarray[sockpos].sock, &retryexcSelectSet );
             writeSelectSet = retrywriteSelectSet;
             excSelectSet = retryexcSelectSet;
                   
             if (index >= (currentset + hoststried - 1)) {
                 
                 //
                 // We will not be issuing any more connects for this set
                 // So, we should wait for the entire timeout period.
                 //
                 // We should actually wait for the remainder of the
                 // timeout period but this method is accurate to within 1%
                 //
                        
                 LastTimeout = TRUE;
                 selectTimeout.tv_sec = timeout->tv_sec;
                 selectTimeout.tv_usec = timeout->tv_usec;
             }
                  
             wsErr = (*pselect)(   0,
                                   NULL,
                                   &writeSelectSet,
                                   &excSelectSet,
                                   &selectTimeout );
             
             if (wsErr == SOCKET_ERROR) {
      
                 LdapPrint1("select failed with 0x%x . .\n", GetLastError());
                 LdapCleanupSockets( sockpos+1 );
                 goto ExitWithCleanup;
      
             } else  if (wsErr == 0) {

                 //
                 // We timed out without receiving a response.
                 // Go ahead and issue another connect.
                 //
                     
                 wsErr = WSA_WAIT_TIMEOUT;
                 connected = FALSE;
                 IF_DEBUG(CONNECTION) {
                     LdapPrint0("No response yet. . .\n");
                 }
                 
             } else {
      
                 for (k=0; k<=sockpos; k++) {
                     
                     if ((*pwsafdisset)(sockarray[k].sock, &writeSelectSet )) {
                         
                         //
                         // Yes! This connect was successful 
                         //
                         
                         connected = TRUE;
                       
                         BeginSocketProtection( Connection );

                         if (StreamSocket) {
                       
                             if (Connection->TcpHandle != INVALID_SOCKET) {
                                 sockErr = (*pclosesocket)( Connection->TcpHandle );
                                 ASSERT(sockErr == 0);

                             }
                             Connection->TcpHandle = sockarray[k].sock;

                         } else {

                             if (Connection->UdpHandle != INVALID_SOCKET) {
                                 sockErr = (*pclosesocket)( Connection->UdpHandle );
                                 ASSERT(sockErr == 0);
                             }
                             Connection->UdpHandle = sockarray[k].sock;
                         }
                       
                         EndSocketProtection( Connection );
                                   
                         sockarray[k].sock = INVALID_SOCKET;
  
                         inetSocket = (sockaddr_in *) sockarray[k].psocketaddr->lpSockaddr;
                       
                         ASSERT( sizeof(Connection->SocketAddress.sin_addr.s_addr) ==
                                 sizeof( inetSocket->sin_addr.s_addr ) );
          
                         CopyMemory( &Connection->SocketAddress.sin_addr.s_addr,
                                     &inetSocket->sin_addr.s_addr,
                                     sizeof(Connection->SocketAddress.sin_addr.s_addr) );

                         Connection->DnsSuppliedName = ldap_dup_stringW(sockarray[k].DnsSuppliedName,
                                                                        0,
                                                                        LDAP_HOST_NAME_SIGNATURE);

                         Connection->PortNumber = port;

                         IF_DEBUG(CONNECTION) {
                             LdapPrint1("Successfully connected to host %S\n", Connection->DnsSuppliedName);
                         }
                         
                         LdapCleanupSockets( sockpos+1 );
                         goto ExitWithCleanup;
                        
                     } else if ((*pwsafdisset)(sockarray[k].sock, &excSelectSet )) {
      
                         //
                         // If there was an exception, we have no other choice
                         // Remove the socket from the select sets and close it.
                         
                         FD_CLR( sockarray[k].sock, &retryexcSelectSet);
                         FD_CLR( sockarray[k].sock, &retrywriteSelectSet);

                         sockErr = (*pclosesocket)(sockarray[k].sock);
                         ASSERT(sockErr == 0);
                         
                         sockarray[k].sock = INVALID_SOCKET;

                     }
                 }

             }

              //
              // If this is the last timeout for the current set, close 
              // all the sockets we created and clear the fd_sets because
              // they can't hold more than 64 sockets.
              //

              if (LastTimeout == TRUE) {
                 
                LdapCleanupSockets( sockpos+1 );
                FD_ZERO( &retrywriteSelectSet );
                FD_ZERO( &retryexcSelectSet );
              }

            } else {
               
                wsErr = (*pWSAGetLastError)();

                IF_DEBUG(CONNECTION) {
                    LdapPrint1("Connect failed with 0x%x\n",wsErr );
                }
                
                sockErr = (*pclosesocket)( sockarray[sockpos].sock );
                ASSERT(sockErr == 0);

                goto ExitWithCleanup;
            }
      }
      
      hoststried += currentset;
   }

ExitWithCleanup:

      //
      // We need to close all the sockets we created
      //

      LdapCleanupSockets( sockpos );
      
      if ((connected == FALSE) && (wsErr != WSA_WAIT_TIMEOUT)) {
      
         wsErr = (*pWSAGetLastError)();
         SetConnectionError( Connection, wsErr, NULL );

         IF_DEBUG(NETWORK_ERRORS) {
             LdapPrint2( "LDAP conn %u returned 0x%x\n", Connection, wsErr );
         }
         return LDAP_CONNECT_ERROR;
      }
      
      if (connected == TRUE) {

         return LDAP_SUCCESS;
      
      } else if (wsErr == 0) {

         return LDAP_SERVER_DOWN;
      }

      return wsErr;

}

struct hostent *
GetHostByNameW(
    PWCHAR  hostName
 )
{
    //
    // We try to make use of Winsock2 functionality if available. This is
    // because gethostbyname in Winsock 1.1 supports only ANSI.
    //

    if (pWSALookupServiceBeginW &&
        pWSALookupServiceNextW &&
        pWSALookupServiceEnd) {

        //
        //  We will fabricate a hostent structure of our own. It will look
        //  like the following. The only fields of interest are h_name, h_aliases[0],
        //  h_length and h_addr_list. Note that we will fill in a UNICODE
        //  h_name and h_aliases[0] field instead of the standard ANSI name.
        //
        //
        //      struct  hostent {
        //      WCHAR   * h_name;               /* official name of host */
        //      WCHAR   * h_aliases;            /* first alias */
        //      short   h_addrtype;             /* host address type */
        //      short   h_length;               /* length of address */
        //      char    FAR * FAR * h_addr_list; /* list of addresses */
        //      };
        //
        //

        #define INITIAL_COUNT   20
         
        WSAQUERYSETW  qsQuery;
        PWSAQUERYSETW pBuffer = NULL;
        HANDLE hRnr = NULL;
        ULONG totalCount = 0;
        DWORD dwQuerySize = 0;
        GUID  ServiceGuid = SVCID_INET_HOSTADDRBYNAME;
        struct hostent  *phostent = NULL;
        int retval = 0;
        PCHAR *IPArray = NULL;
        ULONG arraySize = INITIAL_COUNT;
        BOOLEAN bCapturedOfficialName = FALSE;
        ULONG dnsFlags = LUP_RETURN_ADDR | LUP_RETURN_NAME | LUP_RETURN_BLOB | LUP_RETURN_ALIASES;

        //
        // Allocate a hostent structure which the callee will free later
        //

        phostent = (struct hostent*) ldapMalloc(sizeof(struct hostent), LDAP_ANSI_SIGNATURE );

        if (!phostent) {
            goto Cleanup;
        }

        //
        // Fill in the size of an IP address.
        // This will change when we move to IPv6.
        //

        phostent->h_length = 4;
         
        //
        // Initialize the query structure
        //

        memset(&qsQuery, 0, sizeof(WSAQUERYSETW));
        qsQuery.dwSize = sizeof(WSAQUERYSETW);   // the dwSize field has to be initialised like this
        qsQuery.dwNameSpace = NS_ALL;
        qsQuery.lpServiceClassId = &ServiceGuid;  // this is the GUID to perform forward name resolution (name to IP)
        qsQuery.lpszServiceInstanceName = hostName;

        if( pWSALookupServiceBeginW( &qsQuery,
                                     dnsFlags,
                                     &hRnr ) == SOCKET_ERROR ) {

            IF_DEBUG(CONNECTION) {
                LdapPrint1( "WSALookupServiceBegin failed  %d\n", GetLastError() );
            }
            goto Cleanup;
        }


         //
         // Determine the size of the buffer required to store the results.
         //

         retval = pWSALookupServiceNextW( hRnr,
                                          dnsFlags,
                                          &dwQuerySize,
                                          NULL          // No buffer supplied
                                          );
         
         if (GetLastError() != WSAEFAULT) {
             IF_DEBUG(CONNECTION) {
                 LdapPrint1( "WSALookupServiceNext failed with %d\n", GetLastError() );
             }
             goto Cleanup;
         }
             
         IF_DEBUG(CONNECTION) {
             LdapPrint1( "WSALookupServiceNext requires a buffer of %d\n", dwQuerySize );
         }

         pBuffer = (PWSAQUERYSETW) ldapMalloc(dwQuerySize, LDAP_BUFFER_SIGNATURE);

         if (!pBuffer) {
             goto Cleanup;
         }

         //
         // Allocate an initial array capable of holding upto INITIAL_COUNT addresses.
         //

         IPArray = (PCHAR*) ldapMalloc( (INITIAL_COUNT+1)*sizeof(PCHAR),
                                        LDAP_ANSI_SIGNATURE
                                        );

         if (!IPArray) {
             goto Cleanup;
         }


         //
         // Marshall the returned data into a hostent structure. Note that
         // we use a Unicode hostname instead of the ANSI name.
         //

         while (( pWSALookupServiceNextW( hRnr,
                                          dnsFlags,
                                          &dwQuerySize,
                                          pBuffer ) == NO_ERROR )) {


             if ((bCapturedOfficialName) && (pBuffer->lpszServiceInstanceName)) {

                 //
                 // We pick up the first alias -- verified with JamesG.
                 // Note that we shoe horn a Unicode string instead of a ptr to
                 // null-terminated array of ANSI strings.
                 //

                 phostent->h_aliases = (PCHAR*) ldap_dup_stringW(pBuffer->lpszServiceInstanceName,
                                                                 0,
                                                                 LDAP_HOST_NAME_SIGNATURE
                                                                 );
                 if (!phostent->h_aliases) {
                     goto Cleanup;
                 }
                 IF_DEBUG(CONNECTION) {
                     LdapPrint1("First host alias is %S\n", phostent->h_aliases);
                 }
             }

             //
             // We pick off the official name first; Clarified with JamesG.
             //
             
             if ((!phostent->h_name) &&
                 (pBuffer->dwNumberOfCsAddrs > 0)) {

                 phostent->h_name = (PCHAR) ldap_dup_stringW(pBuffer->lpszServiceInstanceName,
                                                             0,
                                                             LDAP_HOST_NAME_SIGNATURE
                                                             );
                 if (!phostent->h_name) {
                     goto Cleanup;
                 }
                 IF_DEBUG(CONNECTION) {
                     LdapPrint1("Official host %S\n", phostent->h_name);
                 }

                 bCapturedOfficialName = TRUE;
             }

             struct sockaddr_in *ptemp;

             ptemp = (sockaddr_in *) pBuffer->lpcsaBuffer->RemoteAddr.lpSockaddr;

             ASSERT(sizeof(ptemp->sin_addr) == phostent->h_length);

             IF_DEBUG(CONNECTION) {
                 LdapPrint1("Number of addresses collected 0x%x\n", pBuffer->dwNumberOfCsAddrs );
             }

             UINT i;

             for (i=0 ;( i < pBuffer->dwNumberOfCsAddrs ); i++,totalCount++) {

                    ptemp = (struct sockaddr_in *) pBuffer->lpcsaBuffer[i].RemoteAddr.lpSockaddr;

                    if ( totalCount == arraySize ) {

                        PCHAR *newArray;
                        int j=0;

                        //
                        // It is time to realloc our IPArray since it is too small.
                        //

                        arraySize *=2;

                        newArray = (PCHAR*) ldapMalloc( (arraySize+1)*sizeof(PCHAR),
                                                        LDAP_ANSI_SIGNATURE
                                                        );
                        if (!newArray) {
                            goto Cleanup;
                        }

                        //
                        // Copy all the old entries to the new one.
                        //

                        while (IPArray[j]) {
                            newArray[j] = IPArray[j];
                            j++;
                        }
                        //
                        // Free the old array.
                        //
                        ldapFree( IPArray, LDAP_ANSI_SIGNATURE );
                        
                        IPArray = newArray;
                    }

                    IPArray[totalCount] = (PCHAR) ldapMalloc(phostent->h_length,
                                                                 LDAP_ANSI_SIGNATURE);

                    if (IPArray[totalCount] == NULL) {
                        goto Cleanup;
                    }

                    CopyMemory( IPArray[totalCount], &ptemp->sin_addr, phostent->h_length );

                    IF_DEBUG(CONNECTION) {
                        if (pinet_ntoa) {
                            LdapPrint1("Copied address %s\n", pinet_ntoa(ptemp->sin_addr));
                        }
                    }
             }

             //
             // We need to determine the required buffer size before each call to 
             // WSALookupServiceBegin. Keep in mind that the buffer length can change
             // for each call.
             //

             DWORD dwNewQuerySize = 0;

             retval = pWSALookupServiceNextW( hRnr,
                                              dnsFlags,
                                              &dwNewQuerySize,
                                              NULL          // No buffer supplied on purpose
                                              );

             if (GetLastError() != WSAEFAULT) {
                 IF_DEBUG(CONNECTION) {
                     LdapPrint1( "WSALookupServiceNext failed with %d\n", GetLastError() );
                 }
                 break;
             
             } else {

                 if (dwNewQuerySize > dwQuerySize) {

                     IF_DEBUG(CONNECTION) {
                         LdapPrint1( "WSALookupServiceNext requires a bigger buffer of %d\n", dwNewQuerySize );
                     }
                     ldapFree( pBuffer, LDAP_BUFFER_SIGNATURE);
                     pBuffer = (PWSAQUERYSETW) ldapMalloc(dwNewQuerySize, LDAP_BUFFER_SIGNATURE);

                     if (!pBuffer) {
                         break; 
                     }

                     dwQuerySize = dwNewQuerySize;
                 }
             }

         }

         phostent->h_addr_list = IPArray;

Cleanup:
         ldapFree( pBuffer, LDAP_BUFFER_SIGNATURE );

         if ( hRnr ) {
             pWSALookupServiceEnd( hRnr );
         }

         if ( ( totalCount == 0 ) || 
              ( phostent && (phostent->h_addr_list == NULL) ) ) {

             if (phostent) {

                 ldapFree(phostent->h_name, LDAP_HOST_NAME_SIGNATURE);
                 ldapFree(phostent->h_aliases, LDAP_HOST_NAME_SIGNATURE);
                 ldapFree(phostent, LDAP_ANSI_SIGNATURE);
                 phostent = NULL;
             }

             int j=0;

             if (IPArray) {

                 while (IPArray[j]) {
                     ldapFree(IPArray[j], LDAP_ANSI_SIGNATURE);
                     j++;
                 }

                 ldapFree(IPArray, LDAP_ANSI_SIGNATURE);
             }
         }

         return phostent;

    } else {

        //
        // We don't have winsock2 functionality, do our best by calling gethostbyname
        //

        PCHAR ansiHostname = NULL;
        struct hostent * retval = NULL;
        ULONG err = 0;

        LdapPrint0("No Winsock2 functionality found.\n");

        err = FromUnicodeWithAlloc( hostName,
                                    &ansiHostname,
                                    LDAP_HOST_NAME_SIGNATURE,
                                    LANG_ACP);

        if (err != LDAP_SUCCESS) {
            return NULL;
        }

        retval = ((*pgethostbyname)( ansiHostname ));

        ldapFree( ansiHostname, LDAP_HOST_NAME_SIGNATURE );

        return retval;
    }

}

ULONG
Inet_addrW(
   PWCHAR  IpAddressW
 )
{
    //
    // Convert from Unicode to ANSI because inet_addr does not handle
    // Unicode.
    //

    PCHAR IpAddressA = NULL;
    ULONG err, retval;

    err = FromUnicodeWithAlloc( IpAddressW,
                                &IpAddressA,
                                LDAP_BUFFER_SIGNATURE,
                                LANG_ACP);

    if (err != LDAP_SUCCESS) {

        return INADDR_NONE;
    }

    retval = (*pinet_addr)( IpAddressA );

    ldapFree( IpAddressA, LDAP_BUFFER_SIGNATURE );

    return retval;

}

// open.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\receive.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    receive.c    receive data from an LDAP server

Abstract:

   This module handles incoming data from an LDAP server

Author:

    Andy Herron (andyhe)        01-Jun-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

//
//  Not exactly thrilled with this, but users want an arbitrary number of
//  connections, and not limited by FD_SETSIZE.  We'll play with it here so
//  that all the macros still 'just work'.
//

fd_set *WinsockSelectReadSet = NULL;
ULONG Real_FD_SETSIZE = FD_SETSIZE;

#define CONSECUTIVE_PING_LIMIT   8

#if DBG
    #define INTJECTSERVERDOWNS  120
//  ULONG InjectServerDowns = INTJECTSERVERDOWNS;
    ULONG InjectServerDowns = 0;

VOID
LdapSpewSearchResults (
    PLDAP_REQUEST request,
    PLDAP_CONN resultConn,
    ULONG msgid,
    LDAPMessage * result
    );

#endif

#undef FD_SETSIZE

ULONG FD_SETSIZE = 0;

PLDAP_CONN
LdapAllBuffersToMessages (
    PLDAP_CONN Connection,
    ULONG AllOfMessage
    );

ULONG
LdapBuffersToMessages (
    PLDAP_CONN Connection,
    ULONG AllOfMessage
    );

ULONG
DrainWinsock (
    ULONG milliseconds
    );

ULONG __cdecl
ldap_result (
    LDAP            *ExternalHandle,
    ULONG           msgid,
    ULONG           AllOfMessage,
    struct l_timeval  *TimeOut,
    LDAPMessage     **res
    )
{
    PLDAP_CONN connection = NULL;
    ULONG err;
    PLDAPMessage lastMessage = NULL;

    if (res == NULL) {

        return (ULONG) -1;
    }

    *res = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL && ExternalHandle != NULL) {

        return (ULONG) -1;
    }

    err = ldap_result_with_error( connection,
                                  msgid,
                                  AllOfMessage,
                                  TimeOut,
                                  res,
                                  &lastMessage );

    if (err == LDAP_SUCCESS) {

        if (lastMessage == NULL) {

            lastMessage = *res;
        }

        //
        //  return the result from a non-search entry record, rather than just
        //  the first entry in the list.  This is because the server's
        //  return code is stored in the last entry.
        //

        if (lastMessage != NULL) {

            err = lastMessage->lm_msgtype;

        } else {

            err = (ULONG) -1;
            SetConnectionError( connection, LDAP_TIMEOUT, NULL );
        }
    } else {

        SetConnectionError( connection, err, NULL );

        if (err == LDAP_TIMEOUT) {

            err = 0;

        } else {

            err = (ULONG) -1;
        }
    }

    if (connection != NULL) {

       DereferenceLdapConnection( connection );
    }

    return err;
}

ULONG
ldap_result_with_error (
    PLDAP_CONN      Connection,
    ULONG           msgid,
    ULONG           AllOfMessage,
    struct l_timeval  *TimeOut,
    LDAPMessage     **res,
    LDAPMessage     **LastMessage
    )
//
//  This is the same as ldap_result except that we don't return the message
//  type... we return the result code of the wait.  This will be very useful.
//
{
    ULONG err;
    PLDAP_CONN dereferenceConnection = NULL;
    ULONG timeout;
    LDAPMessage *result = NULL;
    PLDAP_REQUEST request = NULL;
    ULONG all = LDAP_MSG_ALL;

    if (res == NULL) {

        return LDAP_PARAM_ERROR;
    }

    *res = NULL;

    if (LastMessage != NULL) {

        *LastMessage = NULL;
    }

    if ((AllOfMessage == LDAP_MSG_ONE) ||
        (AllOfMessage == LDAP_MSG_ALL) ||
        (AllOfMessage == LDAP_MSG_RECEIVED)) {

        all = AllOfMessage;
    }

    if ((Connection != NULL) && (msgid != (ULONG)LDAP_RES_ANY)) {

        PLDAP_REQUEST MatchingRequest = FindLdapRequest( msgid );

        if (MatchingRequest &&
            MatchingRequest->PageRequest &&
            MatchingRequest->SecondaryConnection) {

            IF_DEBUG(CONTROLS) {
                LdapPrint2("Getting data for conn 0x%x instead of 0x%x\n",MatchingRequest->SecondaryConnection, Connection );
            }
            Connection = MatchingRequest->SecondaryConnection;
        }

        if (MatchingRequest) {

            //
            // We don't really need this request. So, deref it
            //

            DereferenceLdapRequest( MatchingRequest );
        }
    }

    if (TimeOut == NULL) {

        timeout = WSA_INFINITE;

    } else {

        if ((TimeOut->tv_sec == 0) &&
            (TimeOut->tv_usec == 0)) {

            timeout = 0;

        } else {

            //
            //  convert to milliseconds.
            //

            timeout = (TimeOut->tv_sec * 1000) + (TimeOut->tv_usec / 1000);
        }
    }

    if (msgid == (ULONG) -1) {

        msgid = 0;
    }

    request = FindLdapRequest( (LONG) msgid );

    if ((msgid != 0) &&
        (request == NULL)) {

        SetConnectionError( Connection, LDAP_PARAM_ERROR, NULL );

        IF_DEBUG(RECEIVEDATA) {
            LdapPrint1( "ldap_result couldn't find request for msgid 0x%x\n", msgid );
        }
        return LDAP_PARAM_ERROR;
    }

GotReferral:

    err = LdapWaitForResponseFromServer(    Connection,
                                            request,
                                            timeout,
                                            all,
                                            &result,
                                            FALSE    // reconnect if necessary.
                                            );

    if (result != NULL) {

        LDAPMessage *lastResult = NULL;
        LDAPMessage *checkResult = NULL;
        PLDAP_CONN resultConn = Connection;

        if (resultConn == NULL) {

            resultConn = GetConnectionPointer(result->Connection);
            dereferenceConnection = resultConn;
        }

        //
        // Note that resultConn could be NULL at this point if we couldn't
        // reference it
        //
        if (resultConn == NULL) {

            LdapPrint1( "resultConn NULL because connection handle 0x%x was unbound\n",
                        result->Connection);
        }

        if (request == NULL) {

            request = FindLdapRequest( result->lm_msgid );
        }

        IF_DEBUG(RECEIVEDATA) {
            LdapPrint3( "ldap_result found results at 0x%x for request 0x%x msgid 0x%x\n",
                        result, request, msgid );
        }

        //
        //  check if we need to chase any referrals
        //

        if ((request != NULL) && (request->ChaseReferrals != 0) && (resultConn != NULL)) {

            ULONG referralError;

            referralError = HandleReferrals( resultConn,
                                             &result,
                                             request );

            if ((referralError == LDAP_SUCCESS) ||
                ( result == NULL )) {

                IF_DEBUG(REFERRALS) {
                    LdapPrint1( "ldap_result chasing referral for msg 0x%x\n", request );
                }

                if (msgid == 0) {

                    DereferenceLdapRequest( request );
                    request = NULL;
                }
                ASSERT( result == NULL );
                goto GotReferral;
            }
        }

        //
        //  find the last message in the list if required.  There's two reasons
        //  why it might be required : if the caller needs to handle it (so we
        //  only traverse the list once) and to check to see if we need to
        //  close the request.
        //

        if ((LastMessage != NULL) || (request != NULL)) {

            checkResult = result;
            LDAPMessage *lastMessage = NULL;

            while (checkResult != NULL) {

                if ((checkResult->lm_msgtype != LDAP_RES_SEARCH_ENTRY) &&
                    (checkResult->lm_msgtype != LDAP_RES_REFERRAL)){

                    lastResult = checkResult;

                    if (lastResult->lm_eom) {

                        IF_DEBUG(EOM) {
                            LdapPrint2( "ldap_result found EOM marker for req 0x%x, msg 0x%x\n",
                                        request, lastResult );
                        }
                        break;
                    }
                }
                lastMessage = checkResult;
                checkResult = checkResult->lm_chain;
            }

            if (lastResult == NULL) {

                lastResult = lastMessage;
            }

            if (LastMessage != NULL) {

                *LastMessage = lastResult;
            }
        }

        ASSERT( lastResult != NULL );

#if DBG
        IF_DEBUG(SPEWSEARCH) {
            LdapSpewSearchResults( request, resultConn, msgid, result );
        }
#endif

        //
        //  since we're returning results, free the ber structure from the
        //  request so that we don't duplicate results during reconnect.
        //
        //  If this is a notifications result, don't free the BER buffer
        //  because we will need it during autoresends.
        //

        if ((request != NULL) &&
            (request->NotificationSearch == FALSE) ) {

            CLdapBer *lber;

            lber = (CLdapBer *) InterlockedExchangePointer(  &request->BerMessageSent,
                                                             NULL );
            if (lber != NULL) {
                delete lber;
            }
        }

        //
        //  if the request needs to be closed, do so now.
        //

        if ((lastResult != NULL) &&
             (lastResult->lm_eom == TRUE) &&
             (request != NULL)) {

            IF_DEBUG(EOM) {
                LdapPrint2( "ldap_result checking to close req 0x%x, msg 0x%x\n",
                            request, lastResult );
            }

            ACQUIRE_LOCK( &request->Lock );

            if ((request->ResponsesOutstanding == 0) &&
                (request->MessageLinkedList == NULL)) {

                IF_DEBUG(REQUEST) {
                     LdapPrint2( "ldap_result closing request 0x%x for msg 0x%x\n",
                                 request, request->MessageId );
                } else {

                    IF_DEBUG(EOM) {
                         LdapPrint2( "ldap_result closing request 0x%x for msg 0x%x\n",
                                     request, request->MessageId );
                    }
                }

                RELEASE_LOCK( &request->Lock );

                CloseLdapRequest( request );

            } else {

                IF_DEBUG(EOM) {
                    LdapPrint1( "ldap_result responses outstanding for req 0x%x\n",
                                request );
                }

                RELEASE_LOCK( &request->Lock );
            }

            START_LOGGING;
            DSLOG((DSLOG_FLAG_TAG_CNPN,"[+]"));
            DSLOG((0,"[ID=%d][ET=%I64d][RC=%d][ER=%d][-]\n",
                   request->MessageId,LdapGetTickCount(),request->ReferralCount,
                   ldap_result2error(Connection->ExternalInfo,result,FALSE)));
            END_LOGGING;
        }

        SetConnectionError( resultConn, LDAP_SUCCESS, NULL );

        err = LDAP_SUCCESS;

        *res = result;

    } else {

        ASSERT(err != NOERROR);

        *res = NULL;

        IF_DEBUG(CONNECTION) {
            LdapPrint2( "ldap_result conn 0x%x failed with 0x%x.\n", Connection, err);
        }

        if (err == LDAP_SERVER_DOWN) {

            //
            //  if we chased a referral and the server went down, return
            //  an error of 'unavailable'... why not?
            //

            if ((Connection != NULL) &&
                (Connection->ServerDown == FALSE)) {

                err = LDAP_UNAVAILABLE;
            }

            SetConnectionError( Connection, err, NULL );
        }
    }

    if (request != NULL) {

        DereferenceLdapRequest( request );
    }

    if ((*res != NULL) && (Connection != NULL)) {

      //
      // We need to get the error string returned by the server and
      // store it.
      //

      PWCHAR ErrorMessage = NULL;

      LdapParseResult(Connection,
                      *res,
                      0,                   // return code
                      NULL,                // Matched DNs
                      &ErrorMessage,       // Server returned err msg
                      NULL,                // No need for referrals
                      NULL,                // or controls
                      FALSE,               // and don't free the message
                      LANG_UNICODE
                      );


      InsertErrorMessage( Connection, ErrorMessage );
    }

    if (dereferenceConnection != NULL) {

        DereferenceLdapConnection( dereferenceConnection );
    }

   return err;
}

#if DBG
VOID
LdapSpewSearchResults (
    PLDAP_REQUEST request,
    PLDAP_CONN resultConn,
    ULONG msgid,
    LDAPMessage *result
    )
{
    ACQUIRE_LOCK( &ConnectionListLock );
    if (request == NULL) {

        LdapPrint1( "\nLDAPSPEW no request for message %u\n", msgid );

    } else {

        LdapPrint3( "\nLDAPSPEW request %u is an %x operation for %S\n",
                request->MessageId,
                request->Operation,
                request->OriginalDN );

        LdapPrint3( "\nLDAPSPEW from server %s, explicit %s, port %u\n",
                resultConn->ListOfHosts,
                resultConn->ExplicitHostName,
                resultConn->PortNumber );

        if (request->Operation == LDAP_SEARCH_CMD) {

            LdapPrint2( "\tLDAPSPEW scope is %u, filter is %S\n",
                request->search.ScopeOfSearch, request->search.SearchFilter );
#if 1
            PWCHAR *attrList = request->search.AttributeList;
            if (attrList == NULL) {

                LdapPrint0( "\tLDAPSPEW requesting all attributes.\n" );

            } else {

                LdapPrint0( "\tLDAPSPEW requesting attributes :\n" );

                while (*attrList != NULL) {

                    LdapPrint1( "\t\t%S\n", *attrList );
                    attrList++;
                }
            }
#endif
        }
    }

    PLDAPMessage    temp = result;

    LdapPrint1( "\nLDAPSPEW results for %u are : \n", msgid );

    while (temp != NULL) {

        if (temp->lm_msgtype != LDAP_RES_SEARCH_ENTRY) {

            LdapPrint1( "\tMessage type received is 0x%x\n", temp->lm_msgtype );

        } else {

            PWCHAR dn = NULL;
            PWCHAR attribute;
            BerElement *opaque;

            dn = ldap_get_dnW( resultConn->ExternalInfo, temp );

            LdapPrint1( "\tDN is : %S\n", dn );

            ldap_memfree( (PCHAR) dn );
#if 1
            attribute = ldap_first_attributeW( resultConn->ExternalInfo,
                                              temp,
                                              &opaque
                                              );
            while (attribute != NULL) {

                PWCHAR *value = NULL;
                ULONG total;

                value = ldap_get_valuesW(   resultConn->ExternalInfo,
                                            temp,
                                            attribute
                                            );

                total = ldap_count_valuesW(value);
                if (total > 1) {

                    ULONG count;

                    LdapPrint1( "\tAttribute %S is :\n", attribute );

                    for (count = 0; count < total; count++ ) {
                        LdapPrint1( "\t\t%S\n", value[count] );
                    }

                } else if (total == 1) {

                    LdapPrint2( "\tAttribute %S is %S\n", attribute, *value );

                } else {

                    LdapPrint1( "\tAttribute %S has no value\n", attribute );
                }

                ldap_value_freeW( value );

                attribute = ldap_next_attributeW( resultConn->ExternalInfo,
                                                  temp,
                                                  opaque
                                                  );
            }
#endif
        }
        temp = temp->lm_chain;
    }

    RELEASE_LOCK( &ConnectionListLock );
    return;
}
#endif

LONG GlobalWaitersCount = 0;

ULONG
LdapWaitForResponseFromServer (
    IN PLDAP_CONN Connection,
    IN PLDAP_REQUEST Request,
    IN ULONG Timeout,
    IN ULONG AllOfMessage,
    OUT PLDAPMessage *Result,
    IN BOOLEAN DisableReconnect
    )
//
//  Wait for a response from the server for a given messageid and return the
//  message.
//
//  Timeout value is in milliseconds.
//
{
    PLDAP_MESSAGEWAIT msgWait = NULL;
    ULONG err = LDAP_SUCCESS;
    ULONG messageNumber;
    BOOLEAN haveLock = FALSE;
    ULONG waitErr;
    ULONGLONG startingTime = LdapGetTickCount();
    ULONGLONG currentTime;
    ULONG waitTime;
    BOOLEAN cldap = FALSE;
    ULONG cldapRetries = 0;
    PLDAP_CONN reconnectConnection = NULL;

    if (Result != NULL) {
        *Result = NULL;
    }

    ULONG checkMessage =  (AllOfMessage == LDAP_MSG_RECEIVED) ?
                            LDAP_MSG_ALL : AllOfMessage;

    messageNumber = (Request != NULL) ? Request->MessageId : 0;

    //
    //  Check to see if we already have a message waiting
    //

TryAgain:

    if (Result != NULL) {

        if ((Request != NULL) && (Request->ResultsAreCached)) {

            ACQUIRE_LOCK( &ConnectionListLock );

            err = LdapBuffersToMessages( Connection, AllOfMessage );

            RELEASE_LOCK( &ConnectionListLock );

            if (err != LDAP_SUCCESS) {

                IF_DEBUG(CACHE) {
                    LdapPrint1("LdapBuffersToMessages returned err 0x%x\n", err);
                }
                return err;
            }
        }

        err = LdapGetResponseFromServer( Connection,
                                         Request,
                                         checkMessage,
                                         Result );

        if (*Result != NULL) {

            //
            //  we have a message from the server waiting for us.
            //

            ASSERT( err == LDAP_SUCCESS );
            goto exitWaitForMessage;
        }

        if ((Request != NULL) &&
            (Connection != NULL) &&
            (Connection->UdpHandle != INVALID_SOCKET)) {

            cldap = TRUE;

            if (( Timeout == WSA_INFINITE ) ||
                ( Timeout == 0 )) {

                //
                //  convert seconds to milliseconds.
                //

                Timeout = Connection->publicLdapStruct.ld_cldaptimeout * 1000;
            }
        }
    }

    //
    //  allocate a wait structure to wait for the reply
    //

    msgWait = LdapGetMessageWaitStructure(  Connection,
                                            AllOfMessage,
                                            messageNumber,
                                            ((Result == NULL) ? TRUE : FALSE) );

    //
    //  We may have gotten a message after we last checked but before we
    //  allocated the structure.  We'll check one more time.
    //

    if (Result != NULL) {
        err = LdapGetResponseFromServer( Connection,
                                         Request,
                                         checkMessage,
                                         Result );

        if (*Result != NULL) {

            //
            //  we have a message from the server waiting for us.
            //

            ASSERT( err == LDAP_SUCCESS );
            goto exitWaitForMessage;
        }
    }

    //
    // Make sure we indeed have outstanding requests before we try to pull data
    // or go off to sleep waiting for someone else to do the job for us.
    //

    if (GlobalCountOfOpenRequests == 0) {
        if (Result != NULL) {

            // check one more time --- another thread may have come by and processed
            // our request (dropping GlobalCountOfOpenRequests to 0), so we need
            // to check for the data now being available

            
            err = LdapGetResponseFromServer( Connection,
                                             Request,
                                             checkMessage,
                                             Result );

            if (*Result != NULL) {

                //
                //  we have a message from the server waiting for us.
                //
                ASSERT( err == LDAP_SUCCESS );
                goto exitWaitForMessage;
            }
        }

        err = LDAP_PARAM_ERROR;
        SetConnectionError( Connection, err, NULL );
        goto exitWaitForMessage;
    }

    //
    //  otherwise, check to make sure we have a structure to wait on.
    //

    if (msgWait == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldapGetMsg connection 0x%x failed wait allocation.\n", Connection);
        }

        err = LDAP_NO_MEMORY;
        SetConnectionError( Connection, err, NULL );
        goto exitWaitForMessage;
    }

TryReceiveAgain:

    //
    //  The messageWaitStructure starts out reset, we only reset it and set
    //  it to not satisfied right before we go check to see if there's a message.
    //  We then check it again before we exit to see if we should wake up
    //  another waiter since we're happily exiting.
    //

    if (haveLock == FALSE) {
        ACQUIRE_LOCK( &ConnectionListLock );
        haveLock = TRUE;
    }

    if ((Connection != NULL) &&
        (Connection->ConnObjectState != ConnObjectActive)) {

        err = LDAP_PARAM_ERROR;
        SetConnectionError( Connection, err, NULL );
        goto exitWaitForMessage;
    }

    if ((Request != NULL) &&
        ((Request->Closed == TRUE) ||
         (Request->Abandoned == TRUE ))) {

        err = (Request->Closed ? LDAP_PARAM_ERROR : LDAP_USER_CANCELLED);
        SetConnectionError( Connection, err, NULL );
        goto exitWaitForMessage;
    }

    if (GlobalReceiveHandlerThread != NULL) {

        //
        //  Some other thread is handling receives... we just sit and wait.
        //

        // NOTE: This code also appears below. Please maintain them
        // in unison.

        InterlockedIncrement( &GlobalWaitersCount );

        //
        // We want to be visible only if this thread is allowed to reconnect
        //

        if ( Connection  && !DisableReconnect ) {

            InterlockedIncrement( &Connection->WaiterCount );
        }

        RELEASE_LOCK( &ConnectionListLock );
        haveLock = FALSE;

        if ((Timeout != 0) && (Timeout != (ULONG) -1)) {

            waitTime = Timeout - (DWORD)(LdapGetTickCount() - startingTime);

        } else {

            waitTime = Timeout;
        }

        IF_DEBUG(RECEIVEDATA) {
            LdapPrint1( "LdapWaitForResponseFromServer waiting for request 0x%x.\n",
                        Request );
        }

        waitErr = WaitForSingleObjectEx( msgWait->Event,
                                         waitTime,
                                         FALSE );


        InterlockedDecrement( &GlobalWaitersCount );

        if ( Connection  && !DisableReconnect ) {

            InterlockedDecrement( &Connection->WaiterCount );
        }

        if (waitErr == (ULONG) -1) {

            waitErr = GetLastError();
        }

    } else {

        //
        // There is a small timing window where another thread might have
        // collected results for us. So, we should check for messages before
        // we go any further. Otherwise, there is a possibility that we might
        // block for 2 mins inside DrainWinsock().
        //


        if (Result != NULL) {

            haveLock = FALSE;
            RELEASE_LOCK( &ConnectionListLock );
            err = LdapGetResponseFromServer( Connection,
                                             Request,
                                             checkMessage,
                                             Result );
            haveLock = TRUE;
            ACQUIRE_LOCK( &ConnectionListLock );
            if (*Result != NULL) {

                //
                //  we have a message from the server waiting for us.
                //

                ASSERT( err == LDAP_SUCCESS );
                goto exitWaitForMessage;
            }
        }

        //
        //  We're now probably the thread that will process data.  Be careful here,
        //  as we can't leave this routine without ensuring that either
        //  another thread has taken over OR no threads are waiting.
        //
        //  Note that since we released and reacquired ConnectionListLock around the
        //  previous LdapGetResponseFromServer call, there is a small window during which
        //  another thread could have become the GlobalReceiveHandlerThread.  So now
        //  that we're back inside ConnectionListLock, we need to recheck
        //  GlobalReceiveHandlerThread and if some other thread is the receive handler,
        //  just wait on it to receive the data.

        if ( !Connection ||
             (Connection  &&
              Connection->HostConnectState == HostConnectStateConnected) ) {

                if (GlobalReceiveHandlerThread == NULL) {
                    GlobalReceiveHandlerThread = GetCurrentThreadId();
                }
                else {
                    //
                    //  Some other thread is handling receives... we just sit and wait.
                    //

                    // NOTE: This code also appears above. Please maintain them
                    // in unison.

                    InterlockedIncrement( &GlobalWaitersCount );

                    //
                    // We want to be visible only if this thread is allowed to reconnect
                    //

                    if ( Connection  && !DisableReconnect ) {

                        InterlockedIncrement( &Connection->WaiterCount );
                    }

                    RELEASE_LOCK( &ConnectionListLock );
                    haveLock = FALSE;

                    if ((Timeout != 0) && (Timeout != (ULONG) -1)) {

                        waitTime = Timeout - (DWORD)(LdapGetTickCount() - startingTime);

                    } else {

                        waitTime = Timeout;
                    }

                    IF_DEBUG(RECEIVEDATA) {
                        LdapPrint1( "LdapWaitForResponseFromServer waiting for request 0x%x.\n",
                                    Request );
                    }

                    waitErr = WaitForSingleObjectEx( msgWait->Event,
                                                     waitTime,
                                                     FALSE );


                    InterlockedDecrement( &GlobalWaitersCount );

                    if ( Connection  && !DisableReconnect ) {

                        InterlockedDecrement( &Connection->WaiterCount );
                    }

                    if (waitErr == (ULONG) -1) {

                        waitErr = GetLastError();
                    }

                    goto doneReceive;
                }
        
                haveLock = FALSE;
                RELEASE_LOCK( &ConnectionListLock );
        
                //
                //  wait for the response to come back from the server
                //
        
                if ((Timeout != 0) && (Timeout != (ULONG) -1)) {
        
                    waitTime = Timeout - (DWORD)(LdapGetTickCount() - startingTime);
        
                } else {
        
                    waitTime = Timeout;
                }
        
                //
                //  when we drain winsock, if it returns with no error, we keep draining
                //  so that we get all data before returning entries.
                //
        
                waitErr = 0;
        
                if (waitTime == (ULONG) -1) {
        
                    //
                    //  They specified an infinite amount of time, let's not
                    //  wait that long.
                    //
        
                    waitErr = DrainWinsock( waitTime );
        
                    while (waitErr == 0) {
        
                        waitErr = DrainWinsock( 0 );
                    }
        
                    if (waitErr == WSAENOBUFS) {
        
                        //
                        // Catastrophic error in DrainWinsock()
                        //
        
                        LdapPrint1("Drainwinsock failed with error 0x%x\n", waitErr);
                        SetConnectionError( Connection, waitErr, NULL );
                        err = LDAP_NO_MEMORY;
                        
                        //
                        // Reset GlobalReceiveHandlerThread before exiting.
                        //

                        ACQUIRE_LOCK(&ConnectionListLock);
                        GlobalReceiveHandlerThread = NULL;
                        RELEASE_LOCK(&ConnectionListLock);
                        
                        goto exitWaitForMessage;
                    }
        
                } else {
        
                    ULONG successfulReceives = 0;
        
                    //
                    //  We drain winsock at least once (for small timeout values) but
                    //  if we're getting completely hosed with data from the server,
                    //  we don't ignore the timeout value passed in from the app.
                    //
        
                    while (waitErr == 0) {
        
                        waitErr = DrainWinsock( 0 );
        
                        if (waitErr == 0) {
                            successfulReceives++;
                        }
        
                        if ((Timeout != 0) &&
                            (Timeout <= (LdapGetTickCount() - startingTime))) {
        
                            break;
                        }
                    }
        
                    if ((waitErr == WSA_WAIT_TIMEOUT) &&
                        (waitTime != 0) &&
                        (successfulReceives == 0)) {
        
                        waitErr = DrainWinsock( waitTime );
        
                        while (waitErr == 0) {
        
                            waitErr = DrainWinsock( 0 );
                        }
                    }
        
                    if (waitErr == WSAENOBUFS) {
        
                        //
                        // Catastrophic error in DrainWinsock()
                        //
        
                        LdapPrint1("Drainwinsock failed with error 0x%x\n", waitErr);
                        SetConnectionError( Connection, waitErr, NULL );
                        err = LDAP_NO_MEMORY;
                        
                        //
                        // Reset GlobalReceiveHandlerThread before exiting.
                        //

                        ACQUIRE_LOCK(&ConnectionListLock);
                        GlobalReceiveHandlerThread = NULL;
                        RELEASE_LOCK(&ConnectionListLock);
                        goto exitWaitForMessage;
                    }
                }
        
                IF_DEBUG(TRACE1) {
                    LdapPrint1( "LdapWaitForResponseFromServer DrainWinsock returned 0x%x.\n",
                                waitErr );
                }
        
                //
                //  We just tried to receive data... convert the buffers to messages.
                //
                //  This function references the connection
                //
                reconnectConnection = LdapAllBuffersToMessages( Connection, AllOfMessage );

            
        } else if (!DisableReconnect) {
            
            haveLock = FALSE;
            RELEASE_LOCK( &ConnectionListLock );
    
            //
            // the connection is not properly connected. Try to reconnect.
            //
    
            err = LdapConnect( Connection, NULL, FALSE );
            
            if (err == LDAP_SUCCESS) {
    
                goto TryReceiveAgain;
    
            } else {
    
                goto exitWaitForMessage;
            }
        
        } else {

            //
            // We must not attempt to reconnect as we might actually be blocked
            // on a send or waiting for a bind response.
            //

            err = LDAP_SERVER_DOWN;
            ASSERT( GlobalReceiveHandlerThread == NULL );
            goto exitWaitForMessage;
        }

        //
        //  now we allow other threads to handle the message pump... then we
        //  try to auto-reconnect only if our connection needs it or if there
        //  are threads currently waiting on this connection.
        //

        ACQUIRE_LOCK(&ConnectionListLock);
        GlobalReceiveHandlerThread = NULL;
        RELEASE_LOCK(&ConnectionListLock);        

        if (( !DisableReconnect ) &&
            ( reconnectConnection != NULL ) &&
            (( reconnectConnection == Connection ) ||
             ( reconnectConnection->WaiterCount > 0 ))) {

            ACQUIRE_LOCK( &reconnectConnection->ReconnectLock );

            if ((reconnectConnection->HostConnectState == HostConnectStateError) &&
                (reconnectConnection->AutoReconnect == TRUE)) {

                ACQUIRE_LOCK( &reconnectConnection->StateLock );

                reconnectConnection->HostConnectState = HostConnectStateReconnecting;

                RELEASE_LOCK( &reconnectConnection->StateLock );

                err = LdapAutoReconnect( reconnectConnection );

                IF_DEBUG(NETWORK_ERRORS) {
                    LdapPrint2( "LdapWaitForResponseFromServer: reconnect returned 0x%x for 0x%x\n",
                                err, reconnectConnection );
                }
            }

            RELEASE_LOCK( &reconnectConnection->ReconnectLock );
        }

        if ( reconnectConnection != NULL ) {
            DereferenceLdapConnection( reconnectConnection );
        }
    }

doneReceive:

    //
    //  Now that we've either processed all the packets or we've been woken
    //  up, check to see if we have any messages.
    //

    if ((Result != NULL) && (msgWait->Satisfied == TRUE)) {

        //
        //  We reset the event BEFORE we call off to get the response,
        //  otherwise we could not wakeup if the response comes in between
        //  the time we check and the time we reset the event.
        //

        ResetEvent( msgWait->Event );
        msgWait->Satisfied = FALSE;     // mark that we're not active

        err = LdapGetResponseFromServer(    Connection,
                                            Request,
                                            AllOfMessage,
                                            Result );
    }

    if ((Result != NULL) && (*Result == NULL)) {

        //
        //  hmmm... what did we wake up for if there was no message for us.
        //  let's go try again.
        //

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint1( "LdapWaitForResponseFromServer: no message found for 0x%x. retrying!\n",
                                Connection );
        }

        if ((Connection != NULL) &&
            (Connection->ServerDown == TRUE)) {

            if (Connection->AutoReconnect == FALSE) {

                IF_DEBUG(SERVERDOWN) {
                    LdapPrint2( "ldapWaitForResponse thread 0x%x has connection 0x%x as down.\n",
                                    GetCurrentThreadId(),
                                    Connection );
                }
                err = LDAP_SERVER_DOWN;

            } else {

                err = LDAP_UNAVAILABLE;
            }

        } else if ((GlobalLdapShuttingDown == TRUE) ||
                   ((Connection != NULL) &&
                    (Connection->ConnObjectState != ConnObjectActive))) {

            err = LDAP_USER_CANCELLED;

        } else if ( GlobalCountOfOpenRequests == 0 ) {

            //
            //  now this is interesting... we've run out of things to wait
            //  for.  Either the request was abandoned or all the servers
            //  have gone down.
            //

            //
            //  since we were off chasing referrals or something, return
            //  what we have so far maybe.
            //

            if (AllOfMessage != LDAP_MSG_RECEIVED) {
                err = LdapGetResponseFromServer( Connection,
                                                 Request,
                                                 checkMessage,
                                                 Result );

                if (*Result != NULL) {

                    //
                    //  we have a message from the server waiting for us.
                    //
                    ASSERT( err == LDAP_SUCCESS );
                    goto exitWaitForMessage;
                }
            }

            if (AllOfMessage == LDAP_MSG_RECEIVED) {

                (VOID)LdapGetResponseFromServer(    Connection,
                                                    Request,
                                                    AllOfMessage,
                                                    Result );
            }

            if (Request != NULL && Request->Abandoned) {

                err = LDAP_USER_CANCELLED;

            } else {

                //
                //  we should return timeout, nothing else.
                //

                err = LDAP_TIMEOUT;
            }

        } else {

            //
            //  check to see if we've exceeded the time limit
            //

            currentTime = LdapGetTickCount();

            if ((Timeout != 0) &&
                ((Timeout == (ULONG) -1) ||
                 (currentTime - startingTime < Timeout))) {

                goto TryReceiveAgain;
            }

            //
            //  If this is a CLDAP request, send the request again, as the
            //  server may have not received it or we may have missed it.
            //

            if ((cldap == TRUE) &&
                (cldapRetries++ <= Connection->publicLdapStruct.ld_cldaptries)) {

                if (haveLock) {
                    RELEASE_LOCK( &ConnectionListLock );
                    haveLock = FALSE;
                }

                ACQUIRE_LOCK( &Request->Lock );

                if (Request->Abandoned == FALSE ) {

                   RELEASE_LOCK( &Request->Lock );

                   ULONG hr = LdapSendCommand(  Connection,
                                                   Request,
                                                   0 );

                    //
                    //  If we successfully sent the packet off, let's go back
                    //  up to the top to wait for the packet again.
                    //

                    if (hr == LDAP_SUCCESS) {

                        IF_DEBUG(CLDAP) {
                            LdapPrint1( "LdapWaitForResponseFromServer rewaiting for connection 0x%x\n",
                                        Connection );
                        }

                        //
                        //  Reset timer
                        //

                        startingTime = LdapGetTickCount();
                        goto TryReceiveAgain;
                    }

                    IF_DEBUG(NETWORK_ERRORS) {
                        LdapPrint2( "LdapWaitForResponseFromServer connection 0x%x send with error of 0x%x.\n",
                                    Connection, hr );
                    }
                } else {

                    RELEASE_LOCK( &Request->Lock );
                }

            }

            //
            //  go check one more time for responses.  It could be that we
            //  haven't received the end of message yet, in which case we
            //  wouldn't have had our wait satisfied.
            //

            if (AllOfMessage != LDAP_MSG_ALL) {

                err = LdapGetResponseFromServer(    Connection,
                                                    Request,
                                                    AllOfMessage,
                                                    Result );

                if (*Result == NULL) {

                    err = LDAP_TIMEOUT;
                }
            } else {

                err = LDAP_TIMEOUT;
            }
        }

        SetConnectionError( Connection, err, NULL );

    } else {

        //
        // We can't assume that (err==LDAP_SUCCESS) here because
        // LdapAutoReconnect can fail with LDAP_SERVER_DOWN when the caller
        // doesn't want a LdapMessage (Result == NULL). Since this is mainly
        // called internally (in LdapSendRaw, etc.), we  should reset the
        // error to success so that the error is picked up in the receive
        // path.
        //

        err = LDAP_SUCCESS;
    }

exitWaitForMessage:

    if (msgWait != NULL) {

        if (haveLock == FALSE) {

            ACQUIRE_LOCK( &ConnectionListLock );    // need it within next call
            haveLock = TRUE;
        }

        //
        //  if our wait should be satified, then we need to wake somebody else
        //  up because we're exiting and maybe haven't pulled off the message.
        //

        if (msgWait->Satisfied) {

            CheckForWaiters( msgWait->MessageNumber, FALSE, NULL );
        }

        LdapFreeMessageWaitStructure( msgWait );
        msgWait = NULL;
    }

    //
    //  If we're running in Win9x with Winsock1.1, and there's no thread
    //  currently calling select and there are threads waiting on wait events,
    //  then we satisfy one of the waits so that they will pick up waiting
    //  with select rather than a wait structure.  This is so packets will
    //  actually get received rather than every thread just waiting for hell
    //  to freeze over.
    //

    if ((GlobalReceiveHandlerThread == NULL) &&
        (GlobalWaitersCount > 0)) {

        if (haveLock == FALSE) {

            ACQUIRE_LOCK( &ConnectionListLock );
            haveLock = TRUE;
        }

        //
        //  recheck since GlobalReceiveHandlerThread is protected by the lock.
        //

        if ((GlobalReceiveHandlerThread == NULL) &&
            (GlobalWaitersCount > 0)) {

            //
            //  there are other threads waiting and there's no one handling
            //  the receive thread.  Succeed a wait.
            //

            CheckForWaiters( 0, TRUE, NULL );
        }
    }

    if (haveLock) {
        haveLock = FALSE;
        RELEASE_LOCK( &ConnectionListLock );
    }

    if ((err == LDAP_SUCCESS) &&
        (Result != NULL) &&
        (Request != NULL) &&
        (Request->CopyResultToCache == TRUE)) {

        if (CopyResultToCache( Connection, *Result ) == TRUE) {

            Request->CopyResultToCache = FALSE;
            Request->ResultsAreCached = TRUE;

            err = FabricateLdapResult(Request,
                                      Connection,
                                      Request->OriginalDN,
                                      Request->search.AttributeList,
                                      Request->search.Unicode
                                      );


        } else {

            //
            // We were not able to cache the data, resend the original request
            // to the server.
            //

            Request->CopyResultToCache = FALSE;
            Request->ResultsAreCached = FALSE;

            err = SendLdapSearch(Request,
                                 Connection,
                                 Request->OriginalDN,
                                 Request->search.ScopeOfSearch,
                                 Request->search.SearchFilter,
                                 Request->search.AttributeList,
                                 Request->search.AttributesOnly,
                                 Request->search.Unicode,
                                 (CLdapBer **)&Request->BerMessageSent,
                                 0 );

        }


        if (err == LDAP_SUCCESS) {

            //
            // Free the old result message and get a new result message
            // from the cache. This message will consist of only the attributes
            // requested in the original search.
            //

            ldap_msgfree( *Result );
            *Result = NULL;
            goto TryAgain;
        }
    }

    return err;
}

PLDAP_CONN
LdapAllBuffersToMessages (
    PLDAP_CONN PreferredConnection,
    ULONG AllOfMessage
    )
//
//  This routine processes all received buffers into LDAP messages.  It
//  bounces out if we hit a connection that needs to be reconnected.
//
//  We give first preference to the specified connection.
//
//  No locks must be held coming in here!!
//
{
    PLIST_ENTRY listEntry;
    PLDAP_CONN connection = NULL;
    ULONG err;
    PLDAP_CONN reconnectConnection = NULL;

    ACQUIRE_LOCK( &ConnectionListLock );
    
    if ( PreferredConnection != NULL ) {
        
        PreferredConnection = ReferenceLdapConnection( PreferredConnection );
        
        if ( PreferredConnection &&
             (PreferredConnection->HostConnectState == HostConnectStateConnected ) ) {

            err = LdapBuffersToMessages( PreferredConnection, AllOfMessage );
            
            if (PreferredConnection->HostConnectState == HostConnectStateError) {

                //
                // Possible candidate for auto-reconnect
                //

                if (PreferredConnection->AutoReconnect == TRUE) {

                    reconnectConnection = PreferredConnection;
                
                } else {

                    RELEASE_LOCK( &ConnectionListLock );

                    ClearPendingListForConnection( PreferredConnection );

                    ACQUIRE_LOCK( &ConnectionListLock );
                }

            }
        }

        //
        // Keep the connection referenced if it is a candidate for reconnect.
        //

        if ( PreferredConnection && !reconnectConnection ) {
            DereferenceLdapConnection( PreferredConnection );
        }
    }

    if (reconnectConnection) {

        RELEASE_LOCK( &ConnectionListLock );
        return reconnectConnection;
    }

    //
    // Walk the rest of the connectionList, converting buffers to messages
    // and looking for potential autoreconnect candidates.
    //

    listEntry = GlobalListActiveConnections.Flink;

    while (listEntry != &GlobalListActiveConnections) {

        connection = CONTAINING_RECORD( listEntry, LDAP_CONN, ConnectionListEntry );

        if (connection == PreferredConnection) {
            
            //
            // We have already processed this one, skip to the next one.
            //

            listEntry = listEntry->Flink;
            continue;
        }

        connection = ReferenceLdapConnection( connection );

        if (connection &&
            (connection->HostConnectState == HostConnectStateConnected )) {

            err = LdapBuffersToMessages( connection, AllOfMessage );

            if (connection->HostConnectState == HostConnectStateError) {

                //
                //   here we go trying auto-reconnect
                //

                if (connection->AutoReconnect == TRUE) {

                    reconnectConnection = connection;
                    break;
                }

                RELEASE_LOCK( &ConnectionListLock );

                ClearPendingListForConnection( connection );

                ACQUIRE_LOCK( &ConnectionListLock );
            }

            listEntry = listEntry->Flink;
            DereferenceLdapConnection( connection );

        } else {

            listEntry = listEntry->Flink;
            
            if (connection) {
                DereferenceLdapConnection( connection );
            }
        }
    }

    RELEASE_LOCK( &ConnectionListLock );
    return reconnectConnection;
}

ULONG
LdapBuffersToMessages (
    PLDAP_CONN Connection,
    ULONG AllOfMessage
    )
//
//  This routine processes all received buffers into LDAP messages.
//
//  !! The ConnectionListLock must be held coming in here.
//
{
    PLDAP_RECVBUFFER buffer = NULL;
    ULONG err;
    PLIST_ENTRY listEntry;
    ULONG hr;
    ULONG messagesGenerated = 0;

    //
    //  drain the crypto stream into the Received list.  If this fails, there
    //  was a problem and the user must close the connection.
    //

    err = DrainPendingCryptoStream( Connection );

    if (err != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "LdapBuffersToMessages : drain crypto returned 0x%x on conn 0x%x\n",
                            err, Connection );
        }

        //
        // We can't call CloseLdapConnection() because the user can't unbind the connection
        // due to the connection state being set to closed, thus leaking the connection.
        // Our only option is to set the state to HostConnectState to Error and set
        // autoreconnect to OFF. This will prevent autoreconnects yet convey an 
        // error (LDAP_SERVER_DOWN) to the user upon decryption failure.
        // This is the best we can do.
        //

        Connection->ServerDown = TRUE;
        Connection->HostConnectState = HostConnectStateError;
        Connection->AutoReconnect = FALSE;
        
        return err;
    }
    
    listEntry = Connection->CompletedReceiveList.Flink;

    if (listEntry == &Connection->CompletedReceiveList) {

        //
        // No plaintext buffers for us to convert into messages. We have nothing
        // to do.
        //
        
        return err;
    }

    IF_DEBUG(TRACE1) {
        LdapPrint1( "LdapBuffersToMessages : searching for messages on conn 0x%x\n", Connection );
    }

    err = LDAP_SUCCESS;

    while (( listEntry != &Connection->CompletedReceiveList ) &&
           ( err == LDAP_SUCCESS )) {

        //
        //  loop through the receive buffers converting them to LDAP messages
        //

        buffer = CONTAINING_RECORD(   listEntry,
                                      LDAP_RECVBUFFER,
                                      ReceiveListEntry );

        ASSERT( buffer->Connection == Connection );

        if (buffer->NumberOfBytesReceived == 0) {

            IF_DEBUG(TRACE1) {
                LdapPrint1( "BufferToMessages : connection 0x%x is marked down.\n",
                             Connection );
            }

            IF_DEBUG(SERVERDOWN) {
                LdapPrint2( "ldapBuffersToMsgs thread 0x%x has connection 0x%x as down.\n",
                                GetCurrentThreadId(),
                                Connection );
            }
            err = LDAP_SERVER_DOWN;
            Connection->ServerDown = TRUE;
            Connection->HostConnectState = HostConnectStateError;
            LdapFreeReceiveStructure( buffer, TRUE );
            continue;
        }

        IF_DEBUG(TRACE1) {
            LdapPrint2( "  checking out buffer 0x%x for Connection 0x%x\n",
                                buffer, Connection );
        }

        while ((err == NOERROR) &&
               (buffer->NumberOfBytesReceived > buffer->NumberOfBytesTaken)) {

            ULONG bytesTaken;
            ULONG bytesAvailable;
            PLDAPMessage result;
            CLdapBer *lber;

            bytesAvailable = buffer->NumberOfBytesReceived - buffer->NumberOfBytesTaken;
            bytesTaken = 0;

            if (Connection->PendingMessage == NULL) {

                //
                //  There is no portion of a message waiting so this must be
                //  the start of a new message.
                //

                result = (PLDAPMessage) ldapMalloc( sizeof(LDAPMessage),
                                                    LDAP_MESG_SIGNATURE );

                if (result == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint1( "BufferToMessages: unable to alloc msg for 0x%x.\n",
                                    Connection );
                    }

                    err = LDAP_NO_MEMORY;
                    break;
                }

                lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

                if (lber == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint1( "BufferToMessages: unable to alloc msg for 0x%x.\n",
                                    Connection );
                    }

                    ldapFree( result, LDAP_MESG_SIGNATURE );
                    err = LDAP_NO_MEMORY;
                    break;
                }

                result->Connection = Connection->ExternalInfo;
                result->lm_ber = (PVOID) lber;

                hr = lber->HrLoadBer(
                         (const BYTE *) &buffer->DataBuffer[buffer->NumberOfBytesTaken],
                          bytesAvailable,
                          &bytesTaken);

                if (hr != NOERROR) {

                    err = hr;

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "BufferToMessages: loadBer1 error of 0x%x for 0x%x.\n",
                                    err, Connection );
                    }

                    ldapFree( result, LDAP_MESG_SIGNATURE );
                    delete lber;
                    break;
                }

            } else {

                //
                //  We've already received a portion of a message, this must
                //  be the continuation of it.
                //

                result = Connection->PendingMessage;

                lber = (CLdapBer *) (result->lm_ber);

                ASSERT( lber != NULL );

                hr = lber->HrLoadMoreBer(
                         (const BYTE *) &buffer->DataBuffer[buffer->NumberOfBytesTaken],
                         bytesAvailable,
                         &bytesTaken);

                if (hr != NOERROR) {

                    err = hr;

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "BufferToMessages: loadBer2 error of 0x%x for 0x%x.\n",
                                    err, Connection );
                    }

                    if (hr != LDAP_NO_MEMORY) {

                        ASSERT( hr == LDAP_DECODING_ERROR );

                        ldapFree( result, LDAP_MESG_SIGNATURE );
                        delete lber;
                        Connection->PendingMessage = NULL;
                    }

                    break;
                }
            }

            //
            //  check to see if we've received the whole message
            //

            if ((lber->CbData() > lber->BytesReceived()) ||
                (lber->CbData() == 0)) {

                // if CbData is 0, means that we don't have enough of the
                // message to determine the length.

                Connection->PendingMessage = result;

            } else {

                Connection->PendingMessage = NULL;

                //
                //  this message is now complete.  Find the request block for
                //  it and put it on the list.
                //

                err = LdapInitialDecodeMessage( Connection, result );

                if (err != NOERROR) {

                    IF_DEBUG(NETWORK_ERRORS) {
                        LdapPrint2( "LdapBuffersToMessages Connection 0x%x, decoding error of 0x%x\n",
                                    Connection, err );
                    }

                    ldapFree( result, LDAP_MESG_SIGNATURE );
                    delete lber;

                } else {

                    //
                    //  find the request block for this message id
                    //

                    PLDAP_REQUEST request = FindLdapRequest( result->lm_msgid );

                    if (request == NULL) {

                        IF_DEBUG(NETWORK_ERRORS) {
                            LdapPrint2( "LdapBuffersToMessages Connection 0x%x, request for msgid 0x%x not found.\n",
                                        Connection, result->lm_msgid );
                        }

                        if ( result->lm_msgid == 0 ) {

                           Connection->HostConnectState = HostConnectStateError;
                           Connection->ServerDown = TRUE;

                           IF_DEBUG(NETWORK_ERRORS) {
                               LdapPrint2( "LdapBuffersToMessages Connection 0x%x, msgid 0x%x found.\n",
                                           Connection, result->lm_msgid );
                           }
                        }
                        
                        IF_DEBUG(NETWORK_ERRORS) {
                           LdapPrint2("LdapBuffersToMessages discarding result msgid 0X%X at 0x%X for lack of request\n", result->lm_msgid,result );
                        }

                        ldapFree( result, LDAP_MESG_SIGNATURE );
                        delete lber;

                    } else {

                        ACQUIRE_LOCK( &request->Lock );

                        if (request->Abandoned) {

                            RELEASE_LOCK( &request->Lock );

                            IF_DEBUG(NETWORK_ERRORS) {
                                LdapPrint2( "LdapBuffersToMessages Connection 0x%x, request 0x%x abandoned.\n",
                                            Connection, result->lm_msgid );
                            }

                            DereferenceLdapRequest( request );
                            ldapFree( result, LDAP_MESG_SIGNATURE );
                            delete lber;

                        } else {

                            PLDAPMessage msgList = request->MessageLinkedList;

                            //
                            //  if the caller wanted us to ref/deref connections
                            //  for each message, we ref the connection here.
                            //

                            if (request->ReferenceConnectionsPerMessage) {

                                result->ConnectionReferenced = TRUE;
                                Connection = ReferenceLdapConnection( Connection );
                                ASSERT(Connection);
                            }

                            if ((result->lm_msgtype != LDAP_RES_SEARCH_ENTRY) &&
                                (result->lm_msgtype != LDAP_RES_REFERRAL)) {

                                DecrementPendingList( request, Connection );

                                IF_DEBUG(REQUEST) {
                                    LdapPrint2( "LdapBuffersToMessages received message type 0x%x for msgid 0x%X\n", result->lm_msgtype, result->lm_msgid );
                                    LdapPrint1( "LdapBuffersToMessages handling completion for 0x%x.\n", request );
                                }

                            } else if (result->lm_msgtype == LDAP_RES_SEARCH_ENTRY) {

                                request->ReceivedData = TRUE;

                                IF_DEBUG(REQUEST) {
                                    LdapPrint1( "LdapBuffersToMessages handling searchEntry for 0x%x.\n", request );
                                }

                            } else {
                                IF_DEBUG(REQUEST) {
                                    LdapPrint1( "LdapBuffersToMessages handling referral for 0x%x.\n", request );
                                }
                            }

                            //
                            //  put the message on the end of the message's
                            //  chain list
                            //

                            while ((msgList != NULL) &&
                                   (msgList->lm_chain != NULL)) {

                                msgList = msgList->lm_chain;
                            }

                            result->lm_chain = NULL;
                            result->lm_next = NULL;

                            if (msgList != NULL) {

                                msgList->lm_chain = result;

                            } else {

                                request->MessageLinkedList = result;
                            }

                            result->lm_time = GetTickCount();
                            result->Request = request;

                            //
                            //  figure out if we need to wake somebody up.
                            //
                            //  if it wasn't a searchEntry or subordinateRef
                            //  (or we're chasing referrals), then
                            //  wake somebody.
                            //

                            if (((result->lm_msgtype == LDAP_RES_SEARCH_ENTRY)&&(AllOfMessage == LDAP_MSG_ALL)) ||
                                ((result->lm_msgtype == LDAP_RES_REFERRAL) &&
                                 (request->ChaseReferrals == 0))) {

                                RELEASE_LOCK( &request->Lock );

                            } else {

                                //
                                //  if we're about to wake someone up, only
                                //  do it if we don't have outstanding responses.
                                //

                               if ((result->lm_msgtype == LDAP_RES_SEARCH_ENTRY)&&
                                   (AllOfMessage != LDAP_MSG_ALL)) {
                                  goto wakeSomeoneUp;
                               }
                                if (result->lm_msgtype != LDAP_RES_REFERRAL) {

                                    if (request->ResponsesOutstanding > 0) {

                                        IF_DEBUG(SCRATCH) {
                                             LdapPrint2( "LdapBuffersToMessages request 0x%x has 0x%x outstanding\n",
                                                         request, request->ResponsesOutstanding );
                                        }
                                        RELEASE_LOCK( &request->Lock );

                                    } else {

                                          //
                                          // This is the last message
                                          //

                                        IF_DEBUG(EOM) {
                                             LdapPrint3( "LdapBuffersToMessages marking eom for request 0x%x, msg 0x%x, msgid 0x%x\n",request, result, result->lm_msgid );
                                        }
                                        result->lm_eom = TRUE;
                                        goto wakeSomeoneUp;
                                    }
                                } else {
wakeSomeoneUp:
                                    LONG msgId = result->lm_msgid;

                                    RELEASE_LOCK( &request->Lock );

                                    //
                                    //  check for waiters for this message
                                    //

                                    CheckForWaiters( msgId, FALSE, Connection );
                                }
                            }
                            DereferenceLdapRequest( request );

                            messagesGenerated++;
                        }
                    }
                }
            }

            buffer->NumberOfBytesTaken += bytesTaken;
        }

        //
        //  we've converted the single buffer to some messages... let's
        //  continue on.
        //

        listEntry = listEntry->Flink;

        //
        //  the only time we leave the buffer on the received list is when
        //  we're in an out of memory condition and we haven't processed the
        //  entire packet.
        //

        if ((buffer->NumberOfBytesReceived == buffer->NumberOfBytesTaken) ||
            (err != LDAP_NO_MEMORY) ) {

            LdapFreeReceiveStructure( buffer, TRUE );
        }
    }

    if (messagesGenerated > 0) {

        SetConnectionError( Connection, err, NULL );
    }
    return err;
}

VOID
CheckForWaiters (
    ULONG MessageNumber,
    BOOLEAN AnyWaiter,
    PLDAP_CONN Connection
    )
//
//  This searches down through the list of waiting threads and signals one
//  that is waiting for the specific message number.  If none are found for
//  the specific message number, a thread waiting for any (messageNumber = 0)
//  is signalled.
//
//  The AnyWaiter parameter specifies that we should just succeed any old
//  waiter, doesn't matter what it's waiting for.
//
//  !! The lock protecting the list of waiters must be held coming in here.
//
{
    PLIST_ENTRY waitList = &GlobalListWaiters;
    PLIST_ENTRY listEntry;
    PLDAP_MESSAGEWAIT generalWait = NULL;
    PLDAP_MESSAGEWAIT specificWait = NULL;

    listEntry = waitList->Flink;

    //
    //  ensure there aren't any wait structures for this particular
    //  message
    //

    while (listEntry != waitList) {

        specificWait = CONTAINING_RECORD( listEntry,
                                         LDAP_MESSAGEWAIT,
                                         WaitListEntry );

        if (specificWait->Satisfied == FALSE) {

            if (specificWait->PendingSendOnly) {

                if ((Connection == NULL) ||
                    (Connection == specificWait->Connection)) {

                    IF_DEBUG(RECEIVEDATA) {
                        LdapPrint2( "CheckForWaiter setting connection 0x%x, wait 0x%x\n",
                                    specificWait->Connection, specificWait );
                    }

                    specificWait->Satisfied = TRUE;
                    SetEvent( specificWait->Event );
                }

            } else {

                if (AnyWaiter == TRUE) {
                    break;
                }

                if (specificWait->MessageNumber == MessageNumber) {
                    break;
                }

                if ((specificWait->MessageNumber == 0) &&
                   (Connection == specificWait->Connection) ) {
                   break;
                }
                //
                //  Consider also looking at the connection that this response
                //  came from as criteria to who should be woken up.
                //

                if (generalWait == NULL) {
                    generalWait = specificWait;
                }
            }
        }

        specificWait = NULL;
        listEntry = listEntry->Flink;
    }

    if (specificWait != NULL) {

        generalWait = specificWait;
    }

    if (generalWait != NULL) {

        IF_DEBUG(RECEIVEDATA) {
            LdapPrint2( "CheckForWaiter setting MsgNo 0x%x, wait 0x%x\n",
                        generalWait->MessageNumber, generalWait );
        }

        generalWait->Satisfied = TRUE;
        SetEvent( generalWait->Event );

    } else {

        IF_DEBUG(SCRATCH) {
            LdapPrint1( "CheckForWaiter didn't find any waiters for MsgNo 0x%x\n",
                        MessageNumber );
        }
    }
    return;
}

ULONG
LdapGetResponseFromServer (
    IN PLDAP_CONN Connection,
    IN PLDAP_REQUEST Request,
    IN ULONG AllOfMessage,
    OUT PLDAPMessage *Result
    )
//
//  Get a response from the server for a given messageid
//  and return the message.
//
{
    PLIST_ENTRY requestListEntry;
    PLDAP_REQUEST request = Request;
    PLDAPMessage message;

    ASSERT( *Result == NULL );
    ASSERT( ( AllOfMessage == LDAP_MSG_ALL ) ||
            ( AllOfMessage == LDAP_MSG_ONE ) ||
            ( AllOfMessage == LDAP_MSG_RECEIVED ));

    if (request != NULL) {

        //
        //  we know exactly which request to look at...
        //

        ACQUIRE_LOCK( &request->Lock );

        IF_DEBUG(RECEIVEDATA) {
            LdapPrint1( "LdapGetResponseFromServer : searching for msgs for message 0x%x\n",
                        Request->MessageId );
        }

        //
        //  if the client wanted only a complete message, ensure that this is it.
        //

        message = request->MessageLinkedList;

        if ((message != NULL) &&
            (AllOfMessage == LDAP_MSG_ALL)) {

            if (request->ResponsesOutstanding > 0) {

                message = NULL;

                IF_DEBUG(REQUEST) {
                    LdapPrint2( "LdapGetRespFromSrv still 0x%x pending responses for 0x%x.\n",
                                request->ResponsesOutstanding, request );
                }

            } else if (message->lm_msgtype == LDAP_RES_SEARCH_ENTRY) {

                PLDAPMessage chainedMsg;

                //
                //  search down chain for LDAP_RES_SEARCH_RESULT message
                //

                for (chainedMsg = message;
                    ((chainedMsg != NULL) &&
                     (chainedMsg->lm_msgtype != LDAP_RES_SEARCH_RESULT));
                    chainedMsg = chainedMsg->lm_chain );

                if (chainedMsg == NULL) {

                    //
                    //  Haven't received the whole message.  we're done
                    //  and haven't found it.
                    //

                    IF_DEBUG(RECEIVEDATA) {
                        LdapPrint1( "LdapGetResponseFromServer : haven't found whole msg 0x%x\n",
                                    Request->MessageId );
                    }
                    message = NULL;
                }
            }
        }

        if (message != NULL) {

            //
            //  remove message from list of incoming messages for request
            //

            IF_DEBUG(RECEIVEDATA) {
                LdapPrint2( "LdapGetResponseFromServer Msg 0x%x marked received for conn 0x%x\n",
                                    message->lm_msgid, message->Connection );
            }

            if ((AllOfMessage == LDAP_MSG_ONE) &&
                (message->lm_chain != NULL)) {

                message->lm_chain->lm_next = message->lm_next;
                message->lm_next = message->lm_chain;
                message->lm_chain = NULL;
            }

            request->MessageLinkedList = message->lm_next;
            message->lm_next = NULL;

            *Result = message;

        } else {

            IF_DEBUG(RECEIVEDATA) {
                LdapPrint1( "LdapGetResponseFromServer: no message found for 0x%x.\n",
                                    request->MessageId );
            }
        }

        RELEASE_LOCK( &request->Lock );

        return LDAP_SUCCESS;
    }

    //
    //  search through the list of pending requests for the messages we're
    //  looking for
    //

    ACQUIRE_LOCK( &RequestListLock );

    requestListEntry = GlobalListRequests.Flink;

    while (requestListEntry != &GlobalListRequests) {

        request = CONTAINING_RECORD( requestListEntry,
                                     LDAP_REQUEST,
                                     RequestListEntry );

        request = ReferenceLdapRequest(request);

        requestListEntry = requestListEntry->Flink;

        IF_DEBUG(RECEIVEDATA) {
            LdapPrint1( "LdapGetResponseFromServer : searching for any msg for conn 0x%x\n", Connection );
        }

        if ( !request ) {
            continue;
        }

        if ( request->Closed ) {
            DereferenceLdapRequest(request);
            continue;
        }

        //
        //  Check if the message meets the requirements... is it for the
        //  correct connection, if they specified one.
        //

        if ( (request->Synchronous == FALSE ) &&
             ( (Connection == NULL) ||
               ((Connection != NULL) &&
                (request->PrimaryConnection == Connection)) ) ) {

            ACQUIRE_LOCK( &request->Lock );

            message = request->MessageLinkedList;

            if ((message != NULL) &&
                (AllOfMessage == LDAP_MSG_ALL)) {

                if (request->ResponsesOutstanding > 0) {

                    message = NULL;

                } else if (message->lm_msgtype == LDAP_RES_SEARCH_ENTRY) {

                    PLDAPMessage chainedMsg;

                    //
                    //  search down chain for LDAP_RES_SEARCH_RESULT message
                    //

                    for (chainedMsg = message;
                        ((chainedMsg != NULL) &&
                         (chainedMsg->lm_msgtype != LDAP_RES_SEARCH_RESULT));
                        chainedMsg = chainedMsg->lm_chain );

                    if (chainedMsg == NULL) {

                        //
                        //  Haven't received the whole message.  we're done
                        //  and haven't found it.
                        //

                        IF_DEBUG(RECEIVEDATA) {
                            LdapPrint1( "LdapGetResponseFromServer : haven't found whole msg 0x%x\n",
                                        Request->MessageId );
                        }
                        message = NULL;
                    }
                }
            }

            if (message != NULL) {

                //
                //  remove message from list of incoming messages for request
                //

                IF_DEBUG(RECEIVEDATA) {
                    LdapPrint2( "LdapGetResponseFromServer Msg 0x%x marked received for conn 0x%x\n",
                                        message->lm_msgid, message->Connection );
                }

                if ((AllOfMessage == LDAP_MSG_ONE) &&
                    (message->lm_chain != NULL)) {

                    message->lm_chain->lm_next = message->lm_next;
                    message->lm_next = message->lm_chain;
                    message->lm_chain = NULL;
                }

                request->MessageLinkedList = message->lm_next;
                message->lm_next = NULL;

                *Result = message;

                RELEASE_LOCK( &request->Lock );
                DereferenceLdapRequest(request);

                RELEASE_LOCK( &RequestListLock );
                return LDAP_SUCCESS;
            }

            IF_DEBUG(RECEIVEDATA) {
                LdapPrint1( "LdapGetResponseFromServer: no message found for 0x%x.\n",
                                    request->MessageId );
            }

            RELEASE_LOCK( &request->Lock );
        }

        DereferenceLdapRequest(request);
    }

    RELEASE_LOCK( &RequestListLock );

    //
    //  none found.
    //

    return LDAP_SUCCESS;
}


ULONG
DrainWinsock (
    ULONG milliseconds
    )
//
//  This uses "select" to drain all data from winsock into message structures.
//
//  This should not be called with any locks held.
//
//  It returns a Winsock error, 0 if success.
//
{
    PLDAP_RECVBUFFER buffer = NULL;

    USHORT waitHandles = 1;
    PLIST_ENTRY connListEntry;
    PLDAP_CONN recvConn = NULL;
    SOCKET socket;
    ULONG successfulReceives = 0;
    ULONG waitErr = WSA_WAIT_TIMEOUT;
    ULONG minKeepAliveCount = 0;
    ULONG err = 0;

    ACQUIRE_LOCK( &SelectLock2 );
    InsideSelect = TRUE;
    RELEASE_LOCK( &SelectLock2 );

    ASSERT( GlobalDrainWinsockThread == NULL );

    InterlockedExchange( (PLONG) &GlobalDrainWinsockThread, GetCurrentThreadId());
    
    //
    //  setup array to wait on
    //

    ACQUIRE_LOCK( &SelectLock1 );
    ACQUIRE_LOCK( &ConnectionListLock );

    //
    //  Well, clients don't want a maximum number of connections, so we'll
    //  have to take a peek into the select() control macros and manipulate
    //  the structures rather than use FD_SET, FD_SETSIZE, etc
    //

    if ((WinsockSelectReadSet == NULL) ||
        (GlobalConnectionCount >= (LONG) FD_SETSIZE)) {

        if (FD_SETSIZE == 0) {

            FD_SETSIZE = Real_FD_SETSIZE;
        }

        ULONG temp_FD_SETSIZE = FD_SETSIZE;

        if (WinsockSelectReadSet != NULL) {

            ASSERT( FD_SETSIZE > 0 );

            temp_FD_SETSIZE *= 2;      // double size of array.
        }

        fd_set *newSelectSet;

        newSelectSet = (fd_set *) ldapMalloc( sizeof( fd_set ) +
             ( ( temp_FD_SETSIZE - Real_FD_SETSIZE ) * sizeof( SOCKET )),
               LDAP_SELECT_READ_SIGNATURE );

        if (newSelectSet == NULL) {

            IF_DEBUG(ERRORS) {
                LdapPrint1( "wldap32: DrainWinsock couldn't allocate 0x%x select buffer.\n", temp_FD_SETSIZE );
            }

            if (WinsockSelectReadSet == NULL) {

                InsideSelect = FALSE;
                RELEASE_LOCK( &ConnectionListLock );
                err = ERROR_NOT_ENOUGH_MEMORY;
                goto error;
            }

            //
            //  if we fail, we just fall through here.  We just won't wait
            //  on all the connections.  Hopefully this won't deadlock us.
            //

        } else {

            FD_SETSIZE = temp_FD_SETSIZE;       // we've made it a variable

            ldapFree( WinsockSelectReadSet, LDAP_SELECT_READ_SIGNATURE );

            WinsockSelectReadSet = newSelectSet;
        }
    }

    FD_ZERO( WinsockSelectReadSet );

    ASSERT( LdapGlobalWakeupSelectHandle != INVALID_SOCKET);

    if ( LdapGlobalWakeupSelectHandle != INVALID_SOCKET ) {

        FD_SET( LdapGlobalWakeupSelectHandle, WinsockSelectReadSet );
    }

    connListEntry = GlobalListActiveConnections.Flink;

    while (connListEntry != &GlobalListActiveConnections) {

        recvConn = CONTAINING_RECORD( connListEntry, LDAP_CONN, ConnectionListEntry );
        recvConn = ReferenceLdapConnection(recvConn);

        if ( !recvConn ||
             recvConn->ServerDown ||
             ( recvConn->ConnObjectState == ConnObjectClosing ) ||
             ( recvConn->HostConnectState != HostConnectStateConnected ) ||
             ( recvConn->SslSetupInProgress )) {

           //
           // If this connection is in SSL setup, we do NOT want to
           // include it in the select or we will interfere with the
           // raw sspi token receive.
           //

           connListEntry = connListEntry->Flink;
           
           if (recvConn)
               DereferenceLdapConnection(recvConn);

           continue;
        }

        if (recvConn->UdpHandle != INVALID_SOCKET) {

            socket = recvConn->UdpHandle;

        } else if (recvConn->TcpHandle != INVALID_SOCKET) {

            socket = recvConn->TcpHandle;

        } else {

            connListEntry = connListEntry->Flink;
            DereferenceLdapConnection(recvConn);
            continue;
        }

        FD_SET( socket, WinsockSelectReadSet );

        if ((recvConn->ResponsesExpected > 0) &&
            (recvConn->KeepAliveSecondCount > 0)) {

            if (minKeepAliveCount == 0) {

                minKeepAliveCount = recvConn->KeepAliveSecondCount;

            } else {

                minKeepAliveCount = min( minKeepAliveCount, recvConn->KeepAliveSecondCount );
            }
        }

        if (++waitHandles == FD_SETSIZE) {
            break;
        }

        connListEntry = connListEntry->Flink;
        DereferenceLdapConnection(recvConn);
    }

    RELEASE_LOCK( &ConnectionListLock );


    //
    //  we have a set to wait on, let's call select to see which ones
    //  we need to put recv's on.
    //

    struct timeval winSock11Time;
    struct timeval *pWinSock11Time;
    int entries;

    entries = 0;

    pWinSock11Time = &winSock11Time;

    //
    //  if they specified infinite timeout, then we use the timeout value
    //  from the connection that has the min timeout value that has a response
    //  pending on it.
    //

    if (milliseconds == (ULONG) -1) {

        if (minKeepAliveCount == 0) {

            minKeepAliveCount = GlobalWaitSecondsForSelect;
        }

        if (minKeepAliveCount > 0) {

            winSock11Time.tv_sec = minKeepAliveCount;
            winSock11Time.tv_usec = 0;

        } else {

            pWinSock11Time = NULL;
        }

    } else if (milliseconds == 0) {

        winSock11Time.tv_sec = 0;
        winSock11Time.tv_usec = 0;

    } else {

        ULONG seconds = 0;
        ULONG msecs = max( milliseconds, 1 );

        if (milliseconds >= 1000) {

            seconds = milliseconds / 1000;
            msecs = milliseconds % 1000;
        }

        winSock11Time.tv_sec = seconds;
        winSock11Time.tv_usec = msecs * 1000;
    }

    entries = (*pselect)(   0,
                            WinsockSelectReadSet,
                            NULL,
                            NULL,
                            pWinSock11Time );

    InsideSelect = FALSE;

    if (entries == SOCKET_ERROR) {

        err = (*pWSAGetLastError)();
        goto error;
    }

    waitErr = WSA_WAIT_TIMEOUT;

    //
    //  check which connections had messages come in on them... or, if we timed
    //  out, then we check to see if the servers are up.
    //

    ACQUIRE_LOCK( &ConnectionListLock );

    connListEntry = GlobalListActiveConnections.Flink;

    while (connListEntry != &GlobalListActiveConnections) {

        recvConn = CONTAINING_RECORD( connListEntry, LDAP_CONN, ConnectionListEntry );
        recvConn = ReferenceLdapConnection( recvConn );

        if ( !recvConn ||
             recvConn->ServerDown ||
             ( recvConn->ConnObjectState == ConnObjectClosing ) ||
             ( recvConn->HostConnectState != HostConnectStateConnected ) ||
             ( recvConn->SslSetupInProgress )) {

            //
            // If this connection is in SSL setup, we do NOT want to
            // include it in the select or we will interfere with the
            // raw sspi token receive.
            //

            connListEntry = connListEntry->Flink;
            
            if (recvConn)
                DereferenceLdapConnection(recvConn);

            continue;
        }

        if (recvConn->UdpHandle != INVALID_SOCKET) {

            socket = recvConn->UdpHandle;

        } else if (recvConn->TcpHandle != INVALID_SOCKET) {

            socket = recvConn->TcpHandle;

        } else {

            connListEntry = connListEntry->Flink;
            DereferenceLdapConnection(recvConn);
            continue;
        }

        if ((entries != 0) &&
            (*pwsafdisset)( socket, WinsockSelectReadSet ) > 0) {

            recvConn->TimeOfLastReceive = LdapGetTickCount();
            recvConn->NumberOfPingsSent = 0;

            buffer = LdapGetReceiveStructure(INITIAL_MAX_RECEIVE_BUFFER);

            if (buffer == NULL) {

                IF_DEBUG(OUTMEMORY) {
                    LdapPrint0( "LdapDrainWinsock failed to get receive buffer\n");
                }

                RELEASE_LOCK( &ConnectionListLock );
                DereferenceLdapConnection(recvConn);
                err = WSA_NOT_ENOUGH_MEMORY;
                goto error;
            }

            waitErr = (*precv)( socket,
                                (PCHAR) &buffer->DataBuffer[0],
                                buffer->BufferSize,
                                0 );        // recv flags

            if (waitErr == SOCKET_ERROR) {

                waitErr = (*pWSAGetLastError)();

                IF_DEBUG(NETWORK_ERRORS) {
                    LdapPrint2( "LdapDrainWinsock failed recv, err = 0x%x for conn 0x%x.\n",
                                waitErr, recvConn);
                }

                ASSERT( waitErr != WSAEWOULDBLOCK );
                ASSERT( waitErr != WSA_IO_PENDING );

                if ((waitErr == WSAECONNRESET) ||
                    (waitErr == WSAECONNABORTED) ||
                    (waitErr == WSAENETDOWN) ||
                    (waitErr == WSAENETUNREACH) ||
                    (waitErr == WSAESHUTDOWN) ||
                    (waitErr == WSAEHOSTDOWN) ||
                    (waitErr == WSAEHOSTUNREACH) ||
                    (waitErr == WSAENETRESET) ||
                    (waitErr == WSAENOTCONN) ) {

                    IF_DEBUG(NETWORK_ERRORS) {
                        LdapPrint2( "LdapDrainWinsock marking connection 0x%x as down, rc = 0x%x\n",
                                    recvConn, waitErr);
                    }

                    buffer->NumberOfBytesReceived = 0;
                    recvConn->ServerDown = TRUE;

                    goto postReceive;

                } else if (waitErr != WSA_IO_PENDING) {

                    LdapFreeReceiveStructure( buffer, TRUE );
                }

            } else {

                //
                //  we received data here... call the callback routine.
                //

#if DBG
                if (InjectServerDowns > 0 && recvConn->BindInProgress == FALSE) {
                    if (--InjectServerDowns == 1) {
                        InjectServerDowns = INTJECTSERVERDOWNS;
                        waitErr = 0;
                    }
                }
#endif
                buffer->NumberOfBytesReceived = waitErr;

                if (waitErr == 0) {

                    IF_DEBUG(NETWORK_ERRORS) {
                        LdapPrint1( "LdapDrainWinsock marking connection 0x%x as gracefully down\n",
                                    recvConn);
                    }

                    recvConn->ServerDown = TRUE;
                    waitErr = LDAP_SERVER_DOWN;
                }
postReceive:
                buffer->Connection = recvConn;

                if ( recvConn->SecureStream ) {

                    InsertTailList( &recvConn->PendingCryptoList,
                                    &buffer->ReceiveListEntry );
                } else {

                    InsertTailList( &recvConn->CompletedReceiveList,
                                    &buffer->ReceiveListEntry );
                }

                if ( recvConn->ServerDown == FALSE ) {
                   successfulReceives++;
                }
            }

        } else if ((recvConn->TcpHandle != INVALID_SOCKET) &&
                   (recvConn->ResponsesExpected > 0) &&
                   (recvConn->PingLimit > 0) &&
                   (recvConn->KeepAliveSecondCount > 0)) {
            //
            //  if we're expecting a message from this server, then we check
            //  to see if it's time to send it a ping.
            //
            //  We do this only for a TCP connection; not for netlogon's UDP
            //  connections.
            //

            ULONGLONG tickCount = LdapGetTickCount();

            if (tickCount > recvConn->TimeOfLastReceive) {

                tickCount -= recvConn->TimeOfLastReceive;

                if (tickCount >= recvConn->KeepAliveSecondCount * 1000) {

                    RELEASE_LOCK( &ConnectionListLock );

                    //
                    //  send the server a ping.  if it returns ok, then we
                    //  know it's alive and we can reset the timer.  If it fails,
                    //  then we keep pinging until we exceed the ping limit,
                    //  in which case we mark the server as down.
                    //

                    ULONG err2 = LdapPingServer( recvConn );

                    ACQUIRE_LOCK( &ConnectionListLock );

                    if (err2 != LDAP_SUCCESS) {

                        recvConn->NumberOfPingsSent++;

                        if (recvConn->NumberOfPingsSent >= recvConn->PingLimit) {

                            buffer = LdapGetReceiveStructure(INITIAL_MAX_RECEIVE_BUFFER);

                            if (buffer != NULL) {

                                IF_DEBUG(NETWORK_ERRORS) {
                                    LdapPrint2( "LdapDrainWinsock marking connection 0x%x as down from 0x%x pings\n",
                                                recvConn,
                                                recvConn->NumberOfPingsSent);
                                }

                                buffer->NumberOfBytesReceived = 0;
                                recvConn->ServerDown = TRUE;

                                waitErr = WSAECONNRESET;
                                goto postReceive;
                            }

                            IF_DEBUG(OUTMEMORY) {
                                LdapPrint0( "LdapDrainWinsock failed to get receive buffer for ping limit\n");
                            }
                        }

                    } else {

                        recvConn->NumberOfPingsSent = 0;
                        recvConn->TimeOfLastReceive = LdapGetTickCount();
                    }
                }
            }
        }

        connListEntry = connListEntry->Flink;
        DereferenceLdapConnection( recvConn );
    }

    //
    // We got out of select because someone woke us up by sending
    // data on the wakeup socket. We will now free that data.
    //


    if ((entries != 0) &&
        (waitErr == WSA_WAIT_TIMEOUT) &&
        (successfulReceives == 0)) {

             char dummy;
             int lastError;

             //
             // pull data from the wakeup socket until there is no more.
             //

             while ((waitErr != 0) && (waitErr != SOCKET_ERROR)) {

                waitErr = (*precv)( LdapGlobalWakeupSelectHandle,
                                    &dummy,
                                    sizeof(dummy),
                                    0 );
             }

           if (waitErr == SOCKET_ERROR) {

               lastError = (*pWSAGetLastError)();

               if (lastError == WSAEWOULDBLOCK) {

                  //
                  // All is well, reset the error back to the true cause
                  //

                  waitErr = WSA_WAIT_TIMEOUT;

               } else {

                  waitErr = lastError;

                  IF_DEBUG(NETWORK_ERRORS) {
                      LdapPrint2( "LdapDrainWinsock recving wakup data, err = 0x%x for conn 0x%x.\n",
                                  waitErr, recvConn);
                  }
               }
            }
    }

    RELEASE_LOCK( &ConnectionListLock );
    InterlockedExchange( (PLONG) &GlobalDrainWinsockThread, NULL);
    RELEASE_LOCK( &SelectLock1 );
    return ((successfulReceives == 0) ? waitErr : 0);

error:
    InterlockedExchange( (PLONG) &GlobalDrainWinsockThread, NULL);
    RELEASE_LOCK( &SelectLock1 );
    return err;
}

ULONG
DrainPendingCryptoStream (
    PLDAP_CONN Connection
    )
//
//  This routine takes any received buffers from the connection block that
//  have not yet been decrypted and tries to decrypt them.
//
//  Note that the connectionlistlock must be held coming in here.
//
{
    ULONG LdapError = LDAP_SUCCESS;
    PLIST_ENTRY pendingCrypto = Connection->PendingCryptoList.Flink;
    PSECURESTREAM pSecureStream = (PSECURESTREAM) Connection->SecureStream;
    PLDAP_RECVBUFFER buffer;

    if ( pSecureStream == NULL ) {

        return LDAP_SUCCESS;
    }

    //
    //  Loop through all crypto buffers that have not yet been processed and
    //  try to process them.  Note that we take into account that buffers may
    //  remain on the pending list multiple times by pulling from the head
    //  of the list each time.
    //

    while (pendingCrypto != &Connection->PendingCryptoList) {

        //
        // DecryptLdapReceive will put the data on the
        // CompletedReceiveList as is appropriate.
        //

        buffer = CONTAINING_RECORD( pendingCrypto,
                                    LDAP_RECVBUFFER,
                                    ReceiveListEntry );

        if (buffer->NumberOfBytesReceived == 0) {
            //
            // The server disconnected the connection. Set the
            // connection state to Error process the rest of the buffers.
            //
        
            RemoveEntryList( &buffer->ReceiveListEntry );
            LdapFreeReceiveStructure( buffer, TRUE );
            buffer = NULL;
            pendingCrypto = Connection->PendingCryptoList.Flink;
            Connection->HostConnectState = HostConnectStateError;
            continue;
        }

        LdapError = pSecureStream->DecryptLdapReceive( buffer );

        //
        //  DecryptLdapReceive handles moving the receive to the appropriate
        //  list.  If it returns failure, then we are probably out of memory
        //  and we must not try to process any more for now.
        //

        if ( LdapError != LDAP_SUCCESS ) {

            IF_DEBUG(NETWORK_ERRORS) {
                LdapPrint2( "DrainPendingCrypt failed decrypt, err = 0x%x for conn 0x%x.\n",
                            LdapError, Connection);
            }

            return LdapError;
        }

        //
        //  If the buffer hasn't been pulled from the pending list, we've got
        //  a loop.  Can't have that.
        //

        pendingCrypto = Connection->PendingCryptoList.Flink;
    }

    return LdapError;
}

VOID
LdapWakeupSelect (
    VOID
    )
//
//  This sends a short message to a socket that select() is waiting on to
//  bring it back up. We wakeup select whenever we are trying to create a
//  new connection or close a socket. SelectLock2 MUST be held before coming
//  into this function.
//
{
    //
    //  there's minimum locking around LdapGlobalWakeupSelectHandle so
    //  we're careful in how we use it.
    //

   char DummyData = 'd';

   if (InsideSelect == TRUE) {

        ASSERT( LdapGlobalWakeupSelectHandle != INVALID_SOCKET);

        IF_DEBUG(RECEIVEDATA) {
            LdapPrint1( "ldap_connect : waking up select on handle 0x%x\n",
                        LdapGlobalWakeupSelectHandle );
        }

        //
        // Simply send some dummy data to the wakeup socket. This is
        // guaranteed not to block
        //

        (*psend)( LdapGlobalWakeupSelectHandle,
                  &DummyData,
                  sizeof(DummyData),
                  0 );
    }

    return;
}

// receive.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\referral.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    referral.c    handle referrerals from an LDAP server

Abstract:

   This module handles referrals

Author:

    Andy Herron    (andyhe)        19-Aug-1996
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

// prevent warnings about the unknown "prefast" #pragma
#pragma warning(disable:4068)

#define LDAP_SCOPE_UNDEFINED  0x03

ULONG
LdapChaseReferral (
    PLDAP_REQUEST Request,
    PLDAPMessage ResultMessage,
    PWCHAR HostAddr,
    PWCHAR NewDN,
    USHORT PortNumber,
    BOOLEAN FromSubordinateReferral,
    BOOLEAN Ssl
    );

ULONG
HandleReferral (
    PLDAP_CONN Connection,
    PLDAPMessage  SearchEntry,
    PLDAP_REQUEST Request
    );

ULONG
CheckForExistingReferral (
    PLDAP_REQUEST Request,
    PWCHAR HostAddr,
    USHORT PortNumber,
    PWCHAR NewDN
    );

BOOLEAN
DoSigningOptionsMatch(
    PLDAP_CONN pPrimary,
    PLDAP_CONN pReferral
    );

BOOLEAN
DoCredentialsMatch(
    PLDAP_CONN pReferral,
    DWORD BindMethod,
    CredHandle * pcomparisonHandle,
    PWCHAR comparisonBindName,
    PWCHAR comparisonBindPwd    
    );

#define LDAP_V2_URL_SEPARATOR ((USHORT) 0x0A)


ULONG
HandleReferrals (
    PLDAP_CONN Connection,
    PLDAPMessage *FirstSearchEntry,
    PLDAP_REQUEST Request
    )
//
//  The request and connection are both refererenced coming in here,
//  we don't have to worry about them going away.
//
//  This routine does the following :
//
//  Strip out all referrals from the current set of results
//  For each referral, try to chase it.
//
{
    ULONG hr = LDAP_LOCAL_ERROR;
    PLDAPMessage msg;
    ULONG referralsChased = 0;

    PLDAPMessage referralListHead = NULL;
    PLDAPMessage nonReferralListHead = NULL;
    PLDAPMessage referralListLast = NULL;
    PLDAPMessage nonReferralListLast = NULL;

    PLDAPMessage searchResultDoneList = NULL;
    PLDAPMessage searchResultDoneLast = NULL;

    PLDAPMessage EomMessage = NULL;

    IF_DEBUG(REFERRALS) {
        LdapPrint2( "HandleReferrels looking at request 0x%x, number 0x%x\n",
                        Request, Request->MessageId );
    }

    if (Request->ChaseReferrals == 0) {

        goto exitReferral;
    }

    //
    //  traverse the list of results and pull out all those that have
    //  referrals but have not yet been chased.  We do this by separating it
    //  out into two different lists... one of referrals, the other not.
    //

    msg = *FirstSearchEntry;

    while (msg != NULL) {

        PLDAPMessage nextOne = msg->lm_chain;
        msg->lm_chain = NULL;

        if (msg->lm_eom == TRUE) {

            EomMessage = msg;
        }

        //
        //  if we've already chased it OR it's a search result entry OR
        //  the return code is not referral, stick it on the non-referral list
        //

        if ((msg->lm_chased == TRUE ) ||
            (msg->lm_msgtype == LDAP_RES_SEARCH_ENTRY) ||
            ((msg->lm_msgtype != LDAP_RES_REFERRAL) &&
             (msg->lm_returncode != LDAP_REFERRAL) &&
             (msg->lm_returncode != LDAP_REFERRAL_V2))) {

            if (msg->lm_msgtype == LDAP_RES_SEARCH_RESULT) {

                if (searchResultDoneList == NULL) {

                    searchResultDoneList= msg;

                } else {

                    searchResultDoneLast->lm_chain = msg;
                }
                searchResultDoneLast = msg;

            } else {

                if (nonReferralListHead == NULL) {

                    nonReferralListHead = msg;

                } else {

                    nonReferralListLast->lm_chain = msg;
                }
                nonReferralListLast = msg;
            }

        } else {



            //
            //  otherwise, we stick it on the referral list
            //

            if (referralListHead == NULL) {

                referralListHead = msg;

            } else {

                referralListLast->lm_chain = msg;
            }
            referralListLast = msg;
        }
        msg = nextOne;
    }

    if (referralListHead == NULL) {

        //
        //  there are no referrals or we've chased them all, just return.
        //  note that all though we've redone the list, it should be in the
        //  exact same order it started in.
        //

        IF_DEBUG(REFERRALS) {
            LdapPrint2( "HandleReferrels no referrals for request 0x%x, number 0x%x\n",
                            Request, Request->MessageId );
        }
        goto exitReferral;
    }

    while (referralListHead != NULL) {

        PLDAPMessage nextReferral = referralListHead->lm_chain;
        referralListHead->lm_chain = NULL;

        referralListHead->lm_chased = TRUE;

        hr = HandleReferral( Connection, referralListHead, Request );

        if (hr == LDAP_SUCCESS) {

            referralsChased++;

            IF_DEBUG(REFERRALS) {
                LdapPrint2( "HandleReferrels successfully chased referral for 0x%x, number 0x%x\n",
                                Request, Request->MessageId );
            }

            if (EomMessage == referralListHead) {

                //
                //  Since we handled a referral, unmark the EOM marker on the
                //  last record, if there was one marked.
                //

                IF_DEBUG(REFERRALS) {
                    LdapPrint1( "HandleReferrals unmarking EOM for request 0x%x\n",
                                 Request );
                } else {
                    IF_DEBUG(EOM) {
                        LdapPrint2( "HandleReferrals unmarking EOM for request 0x%x, msg 0x%x\n",
                                     Request, EomMessage );
                    }
                }

                EomMessage->lm_eom = FALSE;
                EomMessage = NULL;
            }

            ldap_msgfree( referralListHead );

        } else {

            //
            //  put it on list of non referral messages since it failed.
            //

            IF_DEBUG(REFERRALS) {
                LdapPrint3( "HandleReferrels chasing referral for 0x%x, number 0x%x returned 0x%x\n",
                                Request, Request->MessageId, hr );
            }

            if (nonReferralListHead == NULL) {

                nonReferralListHead = referralListHead;

            } else {

                nonReferralListLast->lm_chain = referralListHead;
            }
            nonReferralListLast = referralListHead;
        }

        referralListHead = nextReferral;
    }

exitReferral:

    //
    //  Put the nonreferral results back on the pending list for the request
    //  iff we successfully chased a referral.
    //

    if (referralsChased > 0) {

        hr = LDAP_SUCCESS;

        if (nonReferralListLast != NULL) {

            ACQUIRE_LOCK( &Request->Lock );

            IF_DEBUG(REFERRALS) {
                LdapPrint1( "HandleReferrals putting msgs back on request 0x%x\n",
                             Request );
            }

            nonReferralListLast->lm_chain = Request->MessageLinkedList;
            Request->MessageLinkedList = nonReferralListHead;

            RELEASE_LOCK( &Request->Lock );
        }

        if (EomMessage != NULL) {

            //
            //  Since we handled a referral, unmark the EOM marker on the
            //  last record, if there was one marked.
            //

            IF_DEBUG(REFERRALS) {
                LdapPrint1( "HandleReferrals unmarking EOM for request 0x%x\n",
                             Request );
            } else {
                IF_DEBUG(EOM) {
                    LdapPrint2( "HandleReferrals unmarking EOM for request 0x%x, msg 0x%x\n",
                                 Request, EomMessage );
                }
            }

            EomMessage->lm_eom = FALSE;
        }

        //
        //  if the request has been marked closed, reopen it.  This is because
        //  a thread could have come along while we were processing the
        //  referral and marked it as closed because it thought it was the
        //  end of the responses.
        //

        if (Request->Closed == TRUE) {

            ACQUIRE_LOCK( &Request->Lock );

            if ((Request->Closed == TRUE) &&
                (Request->ResponsesOutstanding > 0)) {

                Request = ReferenceLdapRequest( Request );
                
                ASSERT ( Request );
                
                Request->Closed = FALSE;
                
                IF_DEBUG(REQUEST) {
                    LdapPrint1( "HandleReferrals reopening request 0x%x.\n", Request );
                }
            }
            
            RELEASE_LOCK( &Request->Lock );
        }

        ldap_msgfree( searchResultDoneList );

        //
        //  since we put the responses back on the request block, tell the caller
        //  that it no longer has results.
        //

        *FirstSearchEntry = NULL;

    } else {

        hr = LDAP_LOCAL_ERROR;

        //
        //  we give the responses back to the caller
        //

        if (nonReferralListLast != NULL) {

            nonReferralListLast->lm_chain = searchResultDoneList;

        } else {

            nonReferralListHead = searchResultDoneList;
        }

        *FirstSearchEntry = nonReferralListHead;
    }

    return hr;
}

ULONG
HandleReferral (
    PLDAP_CONN Connection,
    PLDAPMessage ResultMessage,
    PLDAP_REQUEST Request
    )
//
//  The request and connection are both refererenced coming in here,
//  we don't have to worry about them going away.
//
//  This routine does the following :
//
//  - check for a valid ldapv2 or set of ldapv3 referrals
//  - look for a connection to the referred server
//  - if none exist, create a connection to the referred server
//  - update the request block to reference the referred server
//  - send the request to the referred server
//  - return success
//
//
{
    ULONG hr = LDAP_LOCAL_ERROR;
    PWCHAR referralString = NULL;
    CLdapBer *lber = NULL;
    ULONG referralsChased = 0;
    PWCHAR referral;        // points to current location in referral
    USHORT  port;

    ASSERT( ResultMessage->lm_next == NULL );
    ASSERT( ResultMessage->lm_chain == NULL );

    //
    //  check for a referral included in the response.
    //

    lber = (CLdapBer *) (ResultMessage->lm_ber);

    if (lber == NULL) {

        IF_DEBUG(REFERRALS) {
            LdapPrint1( "HandleReferral no ber to decode for 0x%x\n",
                         Request );
        }
        goto exitReferral;
    }

    if ((ResultMessage->lm_msgtype != LDAP_RES_REFERRAL) &&
        (ResultMessage->lm_returncode == LDAP_REFERRAL_V2)) {

        if (Request->ReceivedData) {

            if ((Request->ChaseReferrals & LDAP_CHASE_SUBORDINATE_REFERRALS) == 0) {

                IF_DEBUG(REFERRALS) {
                    LdapPrint1( "HandleReferral not handling subordinate for 0x%x\n",
                                 Request );
                }
                goto exitReferral;
            }
        } else {

            if ((Request->ChaseReferrals & LDAP_CHASE_EXTERNAL_REFERRALS) == 0) {

                IF_DEBUG(REFERRALS) {
                    LdapPrint1( "HandleReferral not handling external for 0x%x\n",
                                 Request );
                }
                goto exitReferral;
            }
        }

        lber->Reset(FALSE);

        hr = LdapInitialDecodeMessage( Connection, ResultMessage );

        if (hr != NOERROR) {

            IF_DEBUG(REFERRALS) {
                LdapPrint2( "HandleReferral error 0x%x while decoding referral for 0x%x\n",
                             hr, Request );
            }
            goto exitReferral;
        }

        //
        //  LdapInitialDecodeMessage left the message half
        //  decoded...  we're sitting right at the matchedDN
        //
        //  matchedDN     LDAPDN,
        //  errorMessage  LDAPString... this is
        //                  "Referral0x0AText"
        //

        hr = lber->HrSkipElement();

        if (hr != NOERROR) {

            IF_DEBUG(REFERRALS) {
                LdapPrint2( "HandleReferral error 0x%x while skipping matchedDN for 0x%x\n",
                             hr, Request );
            }
            goto exitReferral;
        }

        hr = lber->HrGetValueWithAlloc( &referralString );

        if (hr != NOERROR || referralString == NULL) {

            IF_DEBUG(REFERRALS) {
                LdapPrint2( "HandleReferral error 0x%x while getting referral for 0x%x\n",
                             hr, Request );
            }
            goto exitReferral;
        }

        //
        //  If we didn't get a string back or if the string is different than
        //  "Referral"+0x0a, then we bail.
        //

        if ((referralString == NULL) ||
            (strlenW(referralString) < (sizeof("Referral:")-1)) ||
            (ldapWStringsIdentical( referralString,
                                    sizeof("Referral:")-1,
                                    L"Referral:",
                                    sizeof("Referral:")-1 ) == FALSE) ||
             (*(referralString+sizeof("Referral:")-1) == L'\0')) {

            IF_DEBUG(REFERRALS) {
                LdapPrint1( "HandleReferral not proper v2 referral for 0x%x\n",
                             Request );
            }
            hr = LDAP_LOCAL_ERROR;
            goto exitReferral;
        }

        referral = referralString + sizeof("Referral:")-1 + 1; // skip "Referral:/0x0A"

        IF_DEBUG(REFERRALS) {
            LdapPrint2( "HandleReferral chasing %S for request 0x%x\n",
                         referral, Request );
        }

        //
        //  we've got a referral here or maybe even a set of referrals.
        //  it is null terminated but could be multiple URLs separated
        //  by 0x0A (new line).
        //

        while ((referral != NULL) && (*referral != L'\0')) {

            BOOLEAN ssl = FALSE;

            if (ldapWStringsIdentical( referral,
                                       (LONG)(min(sizeof("ldap://")-1, strlenW(referral))),
                                       L"ldap://",
                                       sizeof("ldap://")-1 ) == FALSE) {

                if (ldapWStringsIdentical( referral,
                                           (LONG)(min(sizeof("ldaps://")-1, strlenW(referral))),
                                           L"ldaps://",
                                           sizeof("ldaps://")-1 ) == FALSE) {

                    //
                    // we've got a referral here that is not an LDAP referral.
                    // just skip it to see if there perhaps an LDAP URL following it.
                    //

                    while (*referral != LDAP_V2_URL_SEPARATOR &&
                           *referral != L'\0') {
                        referral++;
                    }

                    if (*referral == LDAP_V2_URL_SEPARATOR) {
                        referral++;
                    }

                    IF_DEBUG(REFERRALS) {
                        LdapPrint1( "HandleReferral non ldap referral skipped for 0x%x\n",
                                     Request );
                    }
                    continue;           // go check the next referral
                }

                ssl = TRUE;
#pragma prefast(suppress:305, "deliberately use the byte count as a ANSI character count (Prefast bug 544)")                
                referral += sizeof("ldaps://")-1;      // skip "ldaps://"

            } else {

#pragma prefast(suppress:305, "deliberately use the byte count as a ANSI character count (Prefast bug 544)")                
                referral += sizeof("ldap://")-1;      // skip "ldap://"
            }

            PWCHAR hostAddr = referral;
            PWCHAR newDN = NULL;

            //
            //  the URL is of the following forms :
            //    "hostaddr/DN"
            //    "hostaddr:port/DN"
            //    "hostaddr:port"
            //    "hostaddr"
            //
            //  find the end of the hostname and replace with a 0x00 to
            //  end it and begin DN.
            //

            while (*referral != L'/' &&
                   *referral != L'\\' &&
                   *referral != L':' &&
                   *referral != LDAP_V2_URL_SEPARATOR &&
                   *referral != L'\0') {
                referral++;
            }

            port = 0;

            if (*referral == L':') {

                *referral = L'\0';
                referral++;

                while (*referral != L'\0' &&
                       *referral != L'/' &&
                       *referral != L'\\' &&
                       *referral != LDAP_V2_URL_SEPARATOR) {

                    if (*referral >= L'0' &&
                        *referral <= L'9') {

                        port = (port * 10) + (*referral - L'0');
                    }
                    referral++;
                }
            }
            if (port == 0) {

                if (ssl || Request->PrimaryConnection->SslPort) {

                    port = LDAP_SERVER_PORT_SSL;

                } else {

                    port = LDAP_SERVER_PORT;
                }
            }

            if (*referral == L'/' || *referral == L'\\') {

                *referral = L'\0';
                referral++;

                if (*referral != L'\0' &&
                    *referral != LDAP_V2_URL_SEPARATOR) {

                    newDN = referral;

                    //
                    //  go to the end of the referral and replace 0x0A with
                    //  a 0x00 if it exists
                    //

                    while (*referral != LDAP_V2_URL_SEPARATOR &&
                           *referral != L'\0') {

                        referral++;
                    }

                    if (*referral != L'\0') {

                        *referral = L'\0';
                        referral++;
                    }
                }
            }

            //
            //  now that we have the new host name and possibly DN, chase
            //  the referral
            //
            //  note that if we've received any responses for this v2 request,
            //  then we should consider this a subordinate referral rather
            //  than external referral.  There is no subordinate referral in
            //  ldapv2, but if we've received search results, we can assume it.
            //

            hr = LdapChaseReferral( Request,
                                    ResultMessage,
                                    hostAddr,
                                    newDN,
                                    port,
                                    Request->ReceivedData,
                                    ssl );

            if (hr == LDAP_SUCCESS) {

                //
                //  if we succeeded in chasing one of these referrals, then
                //  we break out of the loop as we've followed one of them.
                //

                referralsChased++;
                break;
            }

            // on to next one
        }

    } else if ((ResultMessage->lm_msgtype == LDAP_RES_REFERRAL) ||
               (ResultMessage->lm_returncode == LDAP_REFERRAL)) {

        BOOLEAN fromSubordinateReferral;

        if (ResultMessage->lm_msgtype == LDAP_RES_REFERRAL) {

            if ((Request->ChaseReferrals & LDAP_CHASE_SUBORDINATE_REFERRALS) == 0) {

                IF_DEBUG(REFERRALS) {
                    LdapPrint1( "HandleReferral not handling subordinate for 0x%x\n",
                                 Request );
                }
                goto exitReferral;
            }

            fromSubordinateReferral = TRUE;

        } else {

            if ((Request->ChaseReferrals & LDAP_CHASE_EXTERNAL_REFERRALS) == 0) {

                IF_DEBUG(REFERRALS) {
                    LdapPrint1( "HandleReferral not handling external for 0x%x\n",
                                 Request );
                }
                goto exitReferral;
            }

            fromSubordinateReferral = FALSE;
        }

        lber->Reset(FALSE);

        hr = LdapInitialDecodeMessage( Connection, ResultMessage );

        if (hr != NOERROR) {

            IF_DEBUG(REFERRALS) {
                LdapPrint2( "HandleReferral error 0x%x while decoding referral for 0x%x\n",
                             hr, Request );
            }
            goto exitReferral;
        }

        //
        //  Two cases to consider here... a search result entry that is a
        //  referral type response or a general result from the server that
        //  contains a referral and a referral return code.  There's not much
        //  to handle in the former case, since the initial decode left us
        //  at the start of the referrals.
        //

        if (ResultMessage->lm_msgtype != LDAP_RES_REFERRAL) {

            //
            //  LdapInitialDecodeMessage left the message half
            //  decoded...  we're sitting right at the matchedDN
            //
            //  matchedDN     LDAPDN,
            //  errorMessage  LDAPString
            //  referral      [3] SEQUENCE OF LDAPURL
            //

            hr = lber->HrSkipElement();     // skip matched DN

            if (hr != NOERROR) {

                IF_DEBUG(REFERRALS) {
                    LdapPrint2( "HandleReferral error 0x%x while skipping matchedDN for 0x%x\n",
                                 hr, Request );
                }
                goto exitReferral;
            }

            hr = lber->HrSkipElement();     // skip error message

            if (hr != NOERROR) {

                IF_DEBUG(REFERRALS) {
                    LdapPrint2( "HandleReferral error 0x%x while skipping errmsg for 0x%x\n",
                                 hr, Request );
                }
                goto exitReferral;
            }

            hr = lber->HrStartReadSequence( 0xA3L ); // context specific + constructed : Referral
            if (hr != NOERROR) {

                IF_DEBUG(REFERRALS) {
                    LdapPrint2( "HandleReferral error 0x%x while parsing referral 0x%x\n",
                                 hr, Request );
                }
                goto exitReferral;
            }
        }

        while (1) {

            BOOLEAN ssl = FALSE;
            ULONG hrTemp;

            if (referralString != NULL) {

                ldapFree( referralString, LDAP_VALUE_SIGNATURE );
                referralString = NULL;
            }

            hrTemp = lber->HrGetValueWithAlloc( &referralString );

            if (hrTemp != NOERROR || referralString == NULL) {

                IF_DEBUG(REFERRALS) {
                    LdapPrint2( "HandleReferral error 0x%x while reading referral 0x%x\n",
                                 hrTemp, Request );
                }
                break;
            }

            referral = referralString;

            IF_DEBUG(REFERRALS) {
                LdapPrint2( "HandleReferral chasing %S for request 0x%x\n",
                             referral, Request );
            }

            if (ldapWStringsIdentical( referral,
                                       (LONG)(min(sizeof("ldap://")-1, strlenW(referral))),
                                       L"ldap://",
                                       sizeof("ldap://")-1 ) == FALSE) {

                if (ldapWStringsIdentical( referral,
                                           (LONG)(min(sizeof("ldaps://")-1, strlenW(referral))),
                                           L"ldaps://",
                                           sizeof("ldaps://")-1 ) == FALSE) {

                    continue;           // go check the next referral

                }

                ssl = TRUE;
#pragma prefast(suppress:305, "deliberately use the byte count as a ANSI character count (Prefast bug 544)")                                
                referral += sizeof("ldaps://")-1;      // skip "ldaps://"

            } else {

#pragma prefast(suppress:305, "deliberately use the byte count as a ANSI character count (Prefast bug 544)")                
                referral += sizeof("ldap://")-1;      // skip "ldap://"
            }

            PWCHAR hostAddr = referral;
            PWCHAR newDN = NULL;

            //
            //  the URL is of the following forms :
            //    "hostaddr/DN"
            //    "hostaddr:port/DN"
            //    "hostaddr:port"
            //    "hostaddr"
            //
            //  find the end of the hostname and replace with a 0x00 to
            //  end it and begin DN.
            //
            // AnoopA: The new LDAP URL is of the type
            //
            //  ldap://[<servername>:<port>][/<dn>[?[<attrib>[?[<scope>[?[<filter>[?[<extension>]]]]]]]]]
            //

            while (*referral != L'/' &&
                   *referral != L':' &&
                   *referral != L'\0') {
                referral++;
            }

            port = 0;

            if (*referral == L':') {

                *referral = L'\0';
                referral++;

                while (*referral != L'\0' &&
                       *referral != L'\\' &&
                       *referral != L'/') {

                    if (*referral >= L'0' &&
                        *referral <= L'9') {

                        port = (port * 10) + (*referral - L'0');
                    }
                    referral++;
                }
            }
            if (port == 0) {

                if (ssl || Request->PrimaryConnection->SslPort) {

                    port = LDAP_SERVER_PORT_SSL;

                } else {

                    port = LDAP_SERVER_PORT;
                }
            }

            if (*referral == L'/' || *referral == L'\\') {

                *referral = L'\0';
                referral++;

                if (*referral != L'\0') {

                    newDN = referral;
                }
            }

            hr = LdapChaseReferral( Request,
                                    ResultMessage,
                                    hostAddr,
                                    newDN,
                                    port,
                                    fromSubordinateReferral,
                                    ssl );

            if (hr == LDAP_SUCCESS) {
                //
                //  if we succeeded in chasing one of these referrals, then
                //  we break out of the loop as we've followed one of them.
                //

                referralsChased++;
                break;
            }
        }
    }

exitReferral:
    //
    //  Coming down to here, referralsChased is the number of successful
    //  referrals we've chased and hr is the error code if they all failed.
    //

    if (referralsChased > 0) {

        hr = LDAP_SUCCESS;

    } else {

        if ( hr == LDAP_SUCCESS ) {

            hr = LDAP_LOCAL_ERROR;
        }
    }

    if (referralString != NULL) {

        IF_DEBUG(REFERRALS) {
            LdapPrint3( "HandleReferral result 0x%x for request 0x%x while handling %S\n",
                         hr, Request, referralString );
        }

        ldapFree( referralString, LDAP_VALUE_SIGNATURE );

    } else {

        IF_DEBUG(REFERRALS) {
            LdapPrint2( "HandleReferral returning error of 0x%x for request 0x%x\n",
                         hr, Request );
        }
    }

    return hr;
}


ULONG
LdapChaseReferral (
    PLDAP_REQUEST Request,
    PLDAPMessage ResultMessage,
    PWCHAR HostAddr,
    PWCHAR NewUrlDN,
    USHORT PortNumber,
    BOOLEAN FromSubordinateReferral,
    BOOLEAN Ssl
    )
{
    ULONG hr;
    PREFERRAL_TABLE_ENTRY refTable;
    PLDAP_CONN newConnection = NULL;
    PLDAP_CONN originatingConnection = NULL;
    ULONG err;
    PWCHAR mappedHostAddrW = NULL;
    PCHAR  mappedHostAddrA = NULL;
    PWCHAR newDN = NewUrlDN;
    PREFERRAL_TABLE_ENTRY originalEntry;
    PWCHAR newReferralDN;
    PLIST_ENTRY listEntry;
    PLDAP_CONN searchConn;
    PLDAP_CONN primaryConn = NULL;
    USHORT referralNumber;

    BOOLEAN haveLock = FALSE;
    BOOLEAN searchWasSingleLevel = FALSE;
    BOOLEAN updatedReferralHandleCount = FALSE;
    BOOLEAN fNeedToRescramble = FALSE;
    QUERYFORCONNECTION *queryRoutine = NULL;
    NOTIFYOFNEWCONNECTION *notifyRoutine = NULL;
    DEREFERENCECONNECTION *dereferenceRoutine = NULL;
    LDAPReferralDN *pldapRefDN = NULL;
    PLDAP_CONN tempConn;

    BOOLEAN callDerefCallback = FALSE;

    PCHAR copyOfPrimaryCreds = NULL;

    USHORT i;
    PREFERRAL_TABLE_ENTRY workingEntry;

    //
    // If the referral is of the form LDAP://gc._msdcs.<DnsForest>, we have to 
    // special case it and strip off the "gc._msdcs." prefix.
    //

    #define GC_PREFIX      "gc._msdcs."
    #define GC_PREFIXW    L"gc._msdcs."
    
    if (ldapWStringsIdentical( HostAddr,
                               (LONG)min( sizeof(GC_PREFIX)-1, strlenW( HostAddr ) ),
                               GC_PREFIXW,
                               -1)) {
        //
        // Slide the hostname to the left thus, stripping off the prefix.
        //

        IF_DEBUG(REFERRALS) {
            LdapPrint1("Preprocessing GC referral to %S\n", HostAddr);
        }

        ldap_MoveMemory( (PCHAR)HostAddr,
                         (PCHAR)HostAddr + ((sizeof(GC_PREFIX)-1) * sizeof(WCHAR)),
                         (strlenW(HostAddr) - sizeof(GC_PREFIX) + 2) * sizeof(WCHAR) // len of str after prefix including \0
                         );
        
        IF_DEBUG(REFERRALS) {
            LdapPrint1("Chasing GC referral to %S instead\n", HostAddr);
        }
    }

    hr = FromUnicodeWithAlloc( HostAddr,
                               &mappedHostAddrA,
                               LDAP_ANSI_SIGNATURE,
                               LANG_ACP );

    mappedHostAddrW = ldap_dup_stringW(HostAddr, 0, LDAP_UNICODE_SIGNATURE);

    if (( mappedHostAddrW == NULL ) || (hr != NO_ERROR)) {

        goto exitReferral;
    }

    #if 0
    DebugReferralOutput( Request,
                         HostAddr,
                         NewUrlDN
                         );
    #endif

    //
    //  Go through the DN that came in on the URL and convert from the
    //  URL encoded form back to the DN by removing all %nn to 0xnn char
    //  Also, parse out the new style parameters.
    //

    if (NewUrlDN != NULL) {

        PWCHAR source = NewUrlDN;
        PWCHAR dest = NewUrlDN;

        while (*source != L'\0') {

            WCHAR ch = *(source++);

            if (ch == L'%') {

                //
                //  we convert %nn to the 0xnn character, despite the fact that
                //  we have a unicode string here
                //

                WCHAR upperNibble;
                WCHAR lowerNibble;

                upperNibble = *source;

                if (upperNibble == L'\0') {
                    break;
                }
                lowerNibble = *(source+1);

                if (lowerNibble == L'\0') {
                    break;
                }

                if ((HIBYTE(upperNibble) == 0) && (HIBYTE(lowerNibble) == 0)) {

                    UCHAR upNibble = LOBYTE( upperNibble );
                    UCHAR loNibble = LOBYTE( lowerNibble );

                    if ((ISHEX(upNibble) == TRUE) &&
                        (ISHEX(loNibble) == TRUE)) {

                        UCHAR c = (MAPHEXTODIGIT( upNibble ) << 4 ) |
                                   MAPHEXTODIGIT( loNibble );

                        source += 2;
                        ch = MAKEWORD( c, 0 );

                        if (ch == L'?') {

                            //
                            // Escape the ? in the DN/Filter as per RFC 2253 (sec 2.4)
                            // so that our DN parsing routine doesn't get confused.
                            // We know for sure that a ? cannot appear inside an
                            // AttributeDescription (RFC 2251 sec 4.1.4). It is ok to
                            // send these escaped characters on the wire as is.
                            //

                            *(dest++) = L'\\';
                            *(dest++) = L'3';
                            *(dest++) = L'F';
                            continue;
                        }
                    }
                }
            }

            *(dest++) = ch;
        }

        *dest = L'\0';

        if (*(newDN) == L'\0') {

            newDN = NULL;
        }
    }

    //
    // We will attempt to parse the entire DN, complete with the options
    //

    if (newDN) {

        pldapRefDN = LdapParseReferralDN( newDN );

        if (!pldapRefDN) {

            goto exitReferral;
        }
    }

    ACQUIRE_LOCK( &Request->Lock );
    haveLock = TRUE;

    primaryConn = Request->PrimaryConnection;

    if (Request->ReferralHopLimit <= Request->ReferralCount) {

        IF_DEBUG(REFERRALS) {
            LdapPrint2( "HandleReferral hit hop count limit of 0x%x while handling 0x%x\n",
                         hr, Request );
        }
        hr = LDAP_RESULTS_TOO_LARGE;
        goto exitReferral;
    }

    //
    //  determine the referral record that this particular response came from
    //

    referralNumber = ResultMessage->lm_referral;

    if (referralNumber == 0) {

        originatingConnection = Request->PrimaryConnection;

        if (newDN == NULL) {

            newDN = Request->OriginalDN;

        } else {

            newDN = pldapRefDN->ReferralDN;
        }

        if ((Request->Operation == LDAP_SEARCH_CMD) &&
            (Request->search.ScopeOfSearch == LDAP_SCOPE_ONELEVEL) ) {

            searchWasSingleLevel = TRUE;
        }

    } else {

        //
        //  We go to the nth-1 element in the array of referrals.. this is the
        //  one that originated this message.
        //

        originalEntry = Request->ReferralConnections;
        originalEntry += (referralNumber - 1);

        if (newDN == NULL) {

            newDN = originalEntry->ReferralDN;

        } else {

            newDN = pldapRefDN->ReferralDN;
        }

        originatingConnection = originalEntry->ReferralServer;

        if ((Request->Operation == LDAP_SEARCH_CMD) &&
            (originalEntry->SingleLevelSearch == TRUE ) &&
            (Request->search.ScopeOfSearch == LDAP_SCOPE_ONELEVEL)) {

            searchWasSingleLevel = TRUE;

        }
    }

    //
    //  first thing to do is to check the request to see if this one already
    //  has been chased.
    //

    hr = CheckForExistingReferral( Request, mappedHostAddrW, PortNumber, newDN );

    if (hr != LDAP_SUCCESS) {

        //
        //  we've already chased this one... don't chase our tail on it.
        //

        goto exitReferral;
    }

    RELEASE_LOCK( &Request->Lock );
    haveLock = FALSE;

    queryRoutine = primaryConn->ReferralQueryRoutine;
    dereferenceRoutine = primaryConn->DereferenceNotifyRoutine;

    //
    // If we are chasing a referral for a paged request, we must create a new
    // connection
    //

    if ((queryRoutine != NULL) &&
        (Request->PageRequest == NULL)) {

        LUID luid;

        ACQUIRE_LOCK( &primaryConn->StateLock );

        luid.LowPart = primaryConn->CurrentLogonId.LowPart;
        luid.HighPart = primaryConn->CurrentLogonId.HighPart;

        //
        //  we make a copy of the credentials so that we don't have to hold
        //  any locks across the callout.
        //

        if ((primaryConn->BindMethod != LDAP_AUTH_SIMPLE) &&
            (primaryConn->CurrentCredentials != NULL)) {

            PSEC_WINNT_AUTH_IDENTITY_A pIncoming =
                    (PSEC_WINNT_AUTH_IDENTITY_A) primaryConn->CurrentCredentials;
            BOOLEAN fromWide = (BOOLEAN) ((pIncoming->Flags &
                    SEC_WINNT_AUTH_IDENTITY_UNICODE) ? TRUE : FALSE);


            ACQUIRE_LOCK( &primaryConn->ScramblingLock );

            if (GlobalUseScrambling && primaryConn->Scrambled) {

                DecodeUnicodeString(&primaryConn->ScrambledCredentials );
                primaryConn->Scrambled = FALSE;
            }
            
            PSEC_WINNT_AUTH_IDENTITY_EXA pIncomingEX = (PSEC_WINNT_AUTH_IDENTITY_EXA) primaryConn->CurrentCredentials;

            if ((pIncomingEX->Version > 0xFFFF)||(pIncomingEX->Version == 0)) {

                //
                // we are using the older style security structure
                //

                err = LdapMakeCredsWide( (PCHAR) primaryConn->CurrentCredentials,
                                         &copyOfPrimaryCreds,
                                         fromWide
                                         );
            } else {

                //
                // We are using the newer style structure
                //

                err = LdapMakeEXCredsWide( (PCHAR) primaryConn->CurrentCredentials,
                                           &copyOfPrimaryCreds,
                                           fromWide
                                           );
            }

            if (GlobalUseScrambling && !primaryConn->Scrambled) {

                EncodeUnicodeString(&primaryConn->ScrambledCredentials );
                primaryConn->Scrambled = TRUE;
            }

            RELEASE_LOCK( &primaryConn->ScramblingLock );

            if (err != LDAP_SUCCESS) {

                RELEASE_LOCK( &primaryConn->StateLock );
                goto exitReferral;
            }
        }

        //
        //  call out to the app to see if they have one for us to use.
        //

        RELEASE_LOCK( &primaryConn->StateLock );

        PLDAP calloutReturnConn = NULL;

        err = (*queryRoutine)(  primaryConn->ExternalInfo,
                                originatingConnection->ExternalInfo,
                                NewUrlDN,
                                mappedHostAddrA,
                                PortNumber,
                                (PVOID) copyOfPrimaryCreds,
                                (PVOID) &luid,
                                &calloutReturnConn
                                );
        if (err != 0) {

            goto exitReferral;
        }

        newConnection = GetConnectionPointer(calloutReturnConn);

        if (newConnection != NULL) {

            IF_DEBUG(REFERRALS) {
                LdapPrint1( "HandleReferral: Given existing connection to %s\n",
                        mappedHostAddrA );
            }

            ACQUIRE_LOCK( &newConnection->StateLock);

            //
            // Check if the connection is in the process of being closed.
            // Anytime all handles given out go to zero, the connection
            // will be closed. There is a small timing window where
            // after the decision to close is made by another thread, we
            // can increment the handle count and have the conection
            // be closed under our feet. This check prevents that because
            // decrementing and checking happens with StateLock being held.
            //
            // Use this connection only if it is already connected. No point
            // in using a cached connection which is long dead. We might as
            // well create a new connection.
            //
            // Also, ensure that the sign/seal/ssl options are identical to that
            // of the primary connection, and that if we got a LDAPS (SSL) referral,
            // the cached connection uses SSL.
            //

            if ((newConnection->HandlesGivenToCaller == 0 &&
                 newConnection->HandlesGivenAsReferrals == 0) ||
                 (newConnection->HostConnectState != HostConnectStateConnected) ||
                 (!DoSigningOptionsMatch(primaryConn, newConnection)) ||
                 (newConnection->UserSealDataChoice != primaryConn->UserSealDataChoice) ||
                 (newConnection->SslPort != primaryConn->SslPort) ||
                 (Ssl && (!newConnection->SslPort)) ||
                 (newConnection->publicLdapStruct.ld_version < primaryConn->publicLdapStruct.ld_version))
            {
                RELEASE_LOCK( &newConnection->StateLock);
                DereferenceLdapConnection( newConnection );
                IF_DEBUG(REFERRALS) {
                    LdapPrint1("Rejecting given cached connection 0x%x\n", newConnection);
                }
                newConnection = NULL;
            }
            else
            {
                newConnection->HandlesGivenAsReferrals++;
                RELEASE_LOCK( &newConnection->StateLock);

                callDerefCallback = TRUE;
                dereferenceRoutine = newConnection->DereferenceNotifyRoutine;
            }
        }

    } else if (Request->PageRequest == NULL) {

        ULONG lenHostAddr = (ULONG) strlen( mappedHostAddrA );
        ULONG socket = (*phtons)( PortNumber );

        DWORD  comparisonBindMethod = 0;
        PWCHAR comparisonBindName = NULL;
        PWCHAR comparisonBindPwd = NULL;
        CredHandle comparisonHandle;


        //
        //  go through list of connections and try to match by name.
        //
        //  we already have an authenticated, decent connection already
        //  to this server.
        //

        // Descramble the credentials so we can compare them inside DoCredentialsMatch,
        // if using simple bind
        err = LDAP_SUCCESS;
        ACQUIRE_LOCK( &primaryConn->StateLock );

        comparisonBindMethod = primaryConn->BindMethod;
        comparisonHandle.dwLower = primaryConn->hCredentials.dwLower;
        comparisonHandle.dwUpper = primaryConn->hCredentials.dwUpper;
        
        if ( comparisonBindMethod == LDAP_AUTH_SIMPLE) {
            ACQUIRE_LOCK( &primaryConn->ScramblingLock ); 
            fNeedToRescramble = FALSE;
            if ( GlobalUseScrambling && primaryConn->Scrambled && primaryConn->CurrentCredentials) {

               DecodeUnicodeString(&primaryConn->ScrambledCredentials);
               primaryConn->Scrambled = FALSE;
               fNeedToRescramble = TRUE;
            } 

            comparisonBindName = ldap_dup_stringW( primaryConn->DNOnBind, 0, LDAP_UNICODE_SIGNATURE);
            comparisonBindPwd  = ldap_dup_stringW( primaryConn->CurrentCredentials, 0, LDAP_UNICODE_SIGNATURE);

            if ( ((comparisonBindName == NULL) && (primaryConn->DNOnBind != NULL)) ||
                 ((comparisonBindPwd == NULL) && (primaryConn->CurrentCredentials != NULL)) ) {

                err = LDAP_NO_MEMORY;
            }

            if (fNeedToRescramble && GlobalUseScrambling && !primaryConn->Scrambled && primaryConn->CurrentCredentials) {

               EncodeUnicodeString(&primaryConn->ScrambledCredentials);
               primaryConn->Scrambled = TRUE;
            }
            RELEASE_LOCK( &primaryConn->ScramblingLock );
        }
        
        RELEASE_LOCK( &primaryConn->StateLock );

        if (err != LDAP_SUCCESS) {

            ldapSecureFree(comparisonBindPwd, LDAP_UNICODE_SIGNATURE);
            ldapFree(comparisonBindName, LDAP_UNICODE_SIGNATURE);

            hr = err;
            goto exitReferral;
        }

                
        ACQUIRE_LOCK( &ConnectionListLock );

        listEntry = GlobalListActiveConnections.Flink;
        searchConn = NULL;

        while (listEntry != &GlobalListActiveConnections) {

            searchConn = CONTAINING_RECORD( listEntry, LDAP_CONN, ConnectionListEntry );

            //
            //  We check to see if the net addresses are the same, the net sockets
            //  are the same, and that the connection isn't being closed by a call
            //  to DereferenceLdapRequest2 where we've freed the connectionlistlock
            //  but not yet closed the connection.
            //

            if ((searchConn->ConnObjectState != ConnObjectClosing) &&
                (searchConn->HostConnectState == HostConnectStateConnected) &&
                ((searchConn->HandlesGivenToCaller > 0 ) ||
                     (searchConn->HandlesGivenAsReferrals > 0)) &&
                (searchConn->ServerDown == FALSE) &&
                (searchConn->SocketAddress.sin_port == socket) &&
                (DoSigningOptionsMatch(primaryConn, searchConn)) &&
                (searchConn->UserSealDataChoice == primaryConn->UserSealDataChoice) &&
                (searchConn->SslPort == primaryConn->SslPort) &&
                (!Ssl || (Ssl && searchConn->SslPort)) &&
                (DoCredentialsMatch(searchConn, comparisonBindMethod, &comparisonHandle, comparisonBindName, comparisonBindPwd)) &&
                (searchConn->publicLdapStruct.ld_version >= primaryConn->publicLdapStruct.ld_version) &&
                (ldapWStringsIdentical(
                                 mappedHostAddrW,
                                 lenHostAddr,
                                 searchConn->HostNameW,
                                 -1 )) ) {
                //
                //  check if the user context is the same.
                //

                if ((primaryConn->CurrentLogonId.LowPart ==
                      searchConn->CurrentLogonId.LowPart) &&
                    (primaryConn->CurrentLogonId.HighPart ==
                      searchConn->CurrentLogonId.HighPart) &&
                    ((primaryConn->CurrentLogonId.HighPart != 0) ||
                     (primaryConn->CurrentLogonId.LowPart  != 0)) ) {

                    break;
                }
            }
            listEntry = listEntry->Flink;
            searchConn = NULL;
        }


        ldapSecureFree(comparisonBindPwd, LDAP_UNICODE_SIGNATURE);
        ldapFree(comparisonBindName, LDAP_UNICODE_SIGNATURE);

        if (searchConn != NULL) {

            newConnection = ReferenceLdapConnection( searchConn );
            RELEASE_LOCK( &ConnectionListLock );
            
            if (newConnection)
            {
                ACQUIRE_LOCK( &newConnection->StateLock);

                if (newConnection->HandlesGivenToCaller == 0 &&
                    newConnection->HandlesGivenAsReferrals == 0)
                {
                    RELEASE_LOCK( &newConnection->StateLock);
                    DereferenceLdapConnection( newConnection);
                    newConnection = NULL;
                }
                else
                {
                    newConnection->HandlesGivenAsReferrals++;

                    RELEASE_LOCK( &newConnection->StateLock);

                    IF_DEBUG(REFERRALS) {
                        LdapPrint1( "HandleReferral: Found existing connection to %S\n",
                                mappedHostAddrW );
                    }
                }
            }
        }
        else {

            // searchConn == NULL
            RELEASE_LOCK( &ConnectionListLock );
        }
    }

    if (newConnection == NULL) {

        DWORD  comparisonBindMethod = 0;
        PWCHAR comparisonBindName = NULL;
        PWCHAR comparisonBindPwd = NULL;
        CredHandle comparisonHandle;

        newConnection = LdapAllocateConnection( mappedHostAddrW,
                                                PortNumber,
                                                Ssl,
                                                0 );

        if (newConnection == NULL) {

            IF_DEBUG(CONNECTION) {
                LdapPrint1( "HandleReferral failed to allocate, err 0x%x.\n", GetLastError());
            }

            hr = LDAP_UNAVAILABLE;
            goto exitReferral;
        }

        //
        //  open a connection to any of the servers specified
        //  No one has this connection yet, so no need to protect
        //

        err = LdapConnect( newConnection, NULL, FALSE );

        if (err != 0) {

            IF_DEBUG(CONNECTION) {
                LdapPrint1( "HandleReferral failed to connect, err 0x%x.\n", err);
            }

            CloseLdapConnection( newConnection );
            DereferenceLdapConnection( newConnection );
            newConnection = NULL;
            hr = LDAP_UNAVAILABLE;
            goto exitReferral;
        }

        ASSERT(newConnection->ConnObjectState == ConnObjectActive);


        // Descramble the credentials so we can compare them inside DoCredentialsMatch,
        // if using simple bind
        err = LDAP_SUCCESS;
        ACQUIRE_LOCK( &primaryConn->StateLock );

        comparisonBindMethod = primaryConn->BindMethod;
        comparisonHandle.dwLower = primaryConn->hCredentials.dwLower;
        comparisonHandle.dwUpper = primaryConn->hCredentials.dwUpper;
        
        if ( comparisonBindMethod == LDAP_AUTH_SIMPLE) {
            ACQUIRE_LOCK( &primaryConn->ScramblingLock );   
            fNeedToRescramble = FALSE;
            if ( GlobalUseScrambling && primaryConn->Scrambled && primaryConn->CurrentCredentials) {

               DecodeUnicodeString(&primaryConn->ScrambledCredentials);
               primaryConn->Scrambled = FALSE;
               fNeedToRescramble = TRUE;
            } 

            comparisonBindName = ldap_dup_stringW( primaryConn->DNOnBind, 0, LDAP_UNICODE_SIGNATURE);
            comparisonBindPwd  = ldap_dup_stringW( primaryConn->CurrentCredentials, 0, LDAP_UNICODE_SIGNATURE);

            if ( ((comparisonBindName == NULL) && (primaryConn->DNOnBind != NULL)) ||
                 ((comparisonBindPwd == NULL) && (primaryConn->CurrentCredentials != NULL)) ) {

                err = LDAP_NO_MEMORY;
            }

            if (fNeedToRescramble && GlobalUseScrambling && !primaryConn->Scrambled && primaryConn->CurrentCredentials) {

               EncodeUnicodeString(&primaryConn->ScrambledCredentials);
               primaryConn->Scrambled = TRUE;
            }
            RELEASE_LOCK( &primaryConn->ScramblingLock );
        }
        
        RELEASE_LOCK( &primaryConn->StateLock );

        if (err != LDAP_SUCCESS) {

            ldapSecureFree(comparisonBindPwd, LDAP_UNICODE_SIGNATURE);
            ldapFree(comparisonBindName, LDAP_UNICODE_SIGNATURE);
        
            CloseLdapConnection( newConnection );
            DereferenceLdapConnection( newConnection );
            newConnection = NULL;
            hr = err;
            goto exitReferral;
        }
        
        ACQUIRE_LOCK( &ConnectionListLock );

        //
        //  go through list of connections we already have and see if
        //  we already have an authenticated, decent connection already
        //  to this server.
        //

        listEntry = GlobalListActiveConnections.Flink;
        searchConn = NULL;

        while (listEntry != &GlobalListActiveConnections) {

            searchConn = CONTAINING_RECORD( listEntry, LDAP_CONN, ConnectionListEntry );

            //
            //  We check to see if the net addresses are the same, the net sockets
            //  are the same, and that the connection isn't being closed by a call
            //  to DereferenceLdapRequest2 where we've freed the connectionlistlock
            //  but not yet closed the connection.
            //

            if ((searchConn != newConnection ) &&
                (searchConn->ConnObjectState != ConnObjectClosing) &&
                (searchConn->BindInProgress == FALSE) &&
                (DoSigningOptionsMatch(primaryConn, searchConn)) &&
                (searchConn->UserSealDataChoice == primaryConn->UserSealDataChoice) &&
                (searchConn->SslPort == primaryConn->SslPort) &&
                (!Ssl || (Ssl && searchConn->SslPort)) &&
                (DoCredentialsMatch(searchConn, comparisonBindMethod, &comparisonHandle, comparisonBindName, comparisonBindPwd)) &&
                (searchConn->publicLdapStruct.ld_version >= primaryConn->publicLdapStruct.ld_version) &&                
                (searchConn->HostConnectState == HostConnectStateConnected)) {

                if ((searchConn->ServerDown == FALSE) &&
                    (searchConn->SocketAddress.sin_addr.s_addr ==
                     newConnection->SocketAddress.sin_addr.s_addr) &&
                    (searchConn->SocketAddress.sin_port ==
                     newConnection->SocketAddress.sin_port ) &&
                    ((searchConn->HandlesGivenToCaller > 0 ) ||
                     (searchConn->HandlesGivenAsReferrals > 0))) {

                    //
                    //  check if the user context is the same.
                    //

                    if ((primaryConn->CurrentLogonId.LowPart ==
                          searchConn->CurrentLogonId.LowPart) &&
                        (primaryConn->CurrentLogonId.HighPart ==
                          searchConn->CurrentLogonId.HighPart) &&
                        ((primaryConn->CurrentLogonId.HighPart != 0) ||
                         (primaryConn->CurrentLogonId.LowPart  != 0)) ) {

                        break;
                    }
                }
            }
            listEntry = listEntry->Flink;
            searchConn = NULL;
        }


        ldapSecureFree(comparisonBindPwd, LDAP_UNICODE_SIGNATURE);
        ldapFree(comparisonBindName, LDAP_UNICODE_SIGNATURE);

        if (searchConn != NULL) {

            //
            // We can get rid of newConnection and use this searchConn
            // only if we are able to reference it AND we are able
            // to increment HandlesGivenAsReferrals. So don't
            // do anyting hasty till we are absolutely sure we have
            // got our connection
            //
            // If we are unable to reuse searchConn, we set searchConn
            // to NULL, so we can use the newconnection
            //

            tempConn = ReferenceLdapConnection( searchConn );
            RELEASE_LOCK( &ConnectionListLock );

            if (tempConn)
            {
                ACQUIRE_LOCK( &tempConn->StateLock);

                if (tempConn->HandlesGivenToCaller == 0 &&
                    tempConn->HandlesGivenAsReferrals == 0)
                {
                    RELEASE_LOCK( &tempConn->StateLock);
                    DereferenceLdapConnection( tempConn);
                    tempConn = NULL;
                }
                else
                {
                    tempConn->HandlesGivenAsReferrals++;
                    RELEASE_LOCK( &tempConn->StateLock);

                    //
                    // Blow awy newly created connection
                    //

                    CloseLdapConnection( newConnection );
                    DereferenceLdapConnection( newConnection );

                    newConnection = tempConn;

                    IF_DEBUG(REFERRALS) {
                        LdapPrint1( "HandleReferral: Found existing connection to %S\n",
                                mappedHostAddrW );
                    }
                }
            }

            searchConn = tempConn;      // Set to NULL if necessary
        }
        else {
        
            RELEASE_LOCK( &ConnectionListLock );
        }

        if (searchConn == NULL) {

            //
            // For whatever reason, we couldn't reuse an existing conenction
            //
            //
            //  we make a copy of the credentials so that we don't have to hold
            //  any locks across the callout.
            //

            ACQUIRE_LOCK( &primaryConn->StateLock );

            ULONG primaryBindMethod = primaryConn->BindMethod;

            if ((primaryBindMethod != LDAP_AUTH_SIMPLE) &&
                (primaryConn->CurrentCredentials != NULL)) {

                PSEC_WINNT_AUTH_IDENTITY_A pIncoming =
                        (PSEC_WINNT_AUTH_IDENTITY_A) primaryConn->CurrentCredentials;
                BOOLEAN fromWide = (BOOLEAN) ((pIncoming->Flags &
                        SEC_WINNT_AUTH_IDENTITY_UNICODE) ? TRUE : FALSE);


                if (copyOfPrimaryCreds != NULL) {

                   ldapSecureFree( copyOfPrimaryCreds, LDAP_SECURITY_SIGNATURE );
                   copyOfPrimaryCreds = NULL;
                }


                ACQUIRE_LOCK( &primaryConn->ScramblingLock );

                if (GlobalUseScrambling && primaryConn->Scrambled) {

                   DecodeUnicodeString(&primaryConn->ScrambledCredentials );
                   primaryConn->Scrambled = FALSE;
                }
                
                PSEC_WINNT_AUTH_IDENTITY_EXA pIncomingEX = (PSEC_WINNT_AUTH_IDENTITY_EXA) primaryConn->CurrentCredentials;
    
                if ((pIncomingEX->Version > 0xFFFF)||(pIncomingEX->Version == 0)) {
    
                    //
                    // we are using the older style security structure
                    //
    
                    err = LdapMakeCredsWide( (PCHAR) primaryConn->CurrentCredentials,
                                             &copyOfPrimaryCreds,
                                             fromWide
                                             );
                } else {
    
                    //
                    // We are using the newer style structure
                    //
    
                    err = LdapMakeEXCredsWide( (PCHAR) primaryConn->CurrentCredentials,
                                               &copyOfPrimaryCreds,
                                               fromWide
                                               );
                }

                if (GlobalUseScrambling && !primaryConn->Scrambled) {

                   EncodeUnicodeString(&primaryConn->ScrambledCredentials );
                   primaryConn->Scrambled = TRUE;

                }

                RELEASE_LOCK( &primaryConn->ScramblingLock );

                if (err != LDAP_SUCCESS) {

                    RELEASE_LOCK( &primaryConn->StateLock );
                    CloseLdapConnection( newConnection );
                    goto exitReferral;
                }
            }

            //
            // Set up an SSL session if required.
            //

            DWORD opt = PtrToUlong( LDAP_OPT_ON );

            if ( primaryConn->SslPort ) {

                hr = LdapSetConnectionOption( newConnection, LDAP_OPT_SSL, &opt, TRUE );

                if (hr != LDAP_SUCCESS) {
                    IF_DEBUG(REFERRALS) {
                        LdapPrint0("Unable to setup SSL session on referral connection\n");
                    }
                    RELEASE_LOCK( &primaryConn->StateLock );
                    CloseLdapConnection( newConnection );
                    goto exitReferral;
                } else {
                    IF_DEBUG(REFERRALS) {
                        LdapPrint0("Successfully setup SSL session on referral connection\n");
                    }
                }
            }

            //
            // Mimic the sign/seal options of the primary connection.
            //

            // we go by what the user explicitly requested, not what we actually got
            // (which may differ because of global signing policy).  Global signing
            // policy will be enforced when we actually do the LdapBind.
            if (primaryConn->UserSignDataChoice) {

                hr = LdapSetConnectionOption( newConnection, LDAP_OPT_SIGN, &opt, TRUE );

                if (hr != LDAP_SUCCESS) {
                    IF_DEBUG(REFERRALS) {
                        LdapPrint0("Unable to setup Signing on referral connection\n");
                    }
                    RELEASE_LOCK( &primaryConn->StateLock );
                    CloseLdapConnection( newConnection );
                    goto exitReferral;
                } else {
                    IF_DEBUG(REFERRALS) {
                        LdapPrint0("Successfully setup Signing on referral connection\n");
                    }
                }
            }

            if (primaryConn->UserSealDataChoice) {
                
                hr = LdapSetConnectionOption( newConnection, LDAP_OPT_ENCRYPT, &opt, TRUE );
                
                if (hr != LDAP_SUCCESS) {
                    IF_DEBUG(REFERRALS) {
                        LdapPrint0("Unable to setup Sealing on referral connection\n");
                    }
                    RELEASE_LOCK( &primaryConn->StateLock );
                    CloseLdapConnection( newConnection );
                    goto exitReferral;
                } else {
                    IF_DEBUG(REFERRALS) {
                        LdapPrint0("Successfully setup Sealing on referral connection\n");
                    }
                }
            }

            //
            // Mimic the version of the primary connection
            //

            ULONG ver = primaryConn->publicLdapStruct.ld_version;
            hr = LdapSetConnectionOption( newConnection, LDAP_OPT_VERSION, &ver, TRUE);
            if (hr != LDAP_SUCCESS) {
                IF_DEBUG(REFERRALS) {
                    LdapPrint0("Unable to set version on referral connection\n");
                }
                RELEASE_LOCK( &primaryConn->StateLock );
                CloseLdapConnection( newConnection );
                goto exitReferral;
            } else {
                IF_DEBUG(REFERRALS) {
                    LdapPrint1("Successfully set version=%ul on referral connection\n", ver);
                }
            }
                
            RELEASE_LOCK( &primaryConn->StateLock );

            //
            // Note: From this point onward till updatedReferralHandleCount is
            // set to TRUE, we shouldn't jump out directly to exitReferral.
            // If we do, we will leak a connection
            //
            // No locks or checks needed here as no one else has access
            // connection (it is not yet in the connection list)
            //

            newConnection->HandlesGivenAsReferrals++;

            //
            // Add newConnection to connection list
            //

            ACQUIRE_LOCK( &ConnectionListLock );

            InsertTailList( &GlobalListActiveConnections, &newConnection->ConnectionListEntry );

            RELEASE_LOCK( &ConnectionListLock );

            //
            // Wake up select so that it picks up the new connection handle.
            //
        
            LdapWakeupSelect();

            //
            //  Send a bind request to the referred server.
            //  
            //  Make sure that if we are using clear text credentials, the session
            //  is protected by SSL.
            //
            //  We must *ALWAYS* send a bind request to the referred server because we
            //  don't know beforehand if it is a v2 or v3 server. v2 servers always require
            //  binds but v3 servers don't.
            //
            //  We will send a NULL simple bind (anonymous) bind to the server in the
            //  following cases:
            //
            //      - There was no bind performed initially. (primary server was v3)
            //      - A simple bind was originally performed without SSL protection.
            //        (primary server was v2/v3)
            //


            PWCHAR creds = (PWCHAR) copyOfPrimaryCreds;

            fNeedToRescramble = FALSE;
            if ((creds == NULL) && (primaryBindMethod != 0)) {


               ACQUIRE_LOCK( &primaryConn->StateLock );
               ACQUIRE_LOCK( &primaryConn->ScramblingLock );

               if (GlobalUseScrambling && primaryConn->Scrambled) {

                     DecodeUnicodeString( &primaryConn->ScrambledCredentials );
                     primaryConn->Scrambled = FALSE;
               }

               RELEASE_LOCK( &primaryConn->ScramblingLock );
               RELEASE_LOCK( &primaryConn->StateLock );
               
               creds = primaryConn->CurrentCredentials;
               fNeedToRescramble = TRUE;
            }

            BOOLEAN protectedAuth = FALSE;

            if (!((primaryBindMethod == 0) ||
                  (primaryBindMethod == LDAP_AUTH_SIMPLE) && (newConnection->SslPort == FALSE))) {
                
                protectedAuth = TRUE;
            }

            err = LdapBind( newConnection,
                            protectedAuth ? primaryConn->DNOnBind : NULL,
                            (primaryBindMethod == 0) ? LDAP_AUTH_SIMPLE : primaryBindMethod,
                            protectedAuth ? creds : NULL,
                            TRUE           // Synchronous
                            );

            IF_DEBUG(REFERRALS) {
                LdapPrint2( "HandleReferral: Bind to host %S returned 0x%x\n",
                        mappedHostAddrW, err );
            }

            if (fNeedToRescramble) {
            
               ACQUIRE_LOCK( &primaryConn->StateLock );
               ACQUIRE_LOCK( &primaryConn->ScramblingLock );

               if (GlobalUseScrambling && !primaryConn->Scrambled) {

                   EncodeUnicodeString(&primaryConn->ScrambledCredentials );
                   primaryConn->Scrambled = TRUE;
               }

               RELEASE_LOCK( &primaryConn->ScramblingLock );
               RELEASE_LOCK( &primaryConn->StateLock );
            }

            if (err != LDAP_SUCCESS) {
                
                hr = err;
                
                //
                // The cleanup code will make sure this connection is deleted.
                //
                
                updatedReferralHandleCount = TRUE;
                goto exitReferral;
            }

            newConnection->CurrentLogonId.LowPart = primaryConn->CurrentLogonId.LowPart;
            newConnection->CurrentLogonId.HighPart = primaryConn->CurrentLogonId.HighPart;

            notifyRoutine = primaryConn->ReferralNotifyRoutine;

            newConnection->ReferralNotifyRoutine = notifyRoutine;
            newConnection->ReferralQueryRoutine = queryRoutine;
            newConnection->DereferenceNotifyRoutine =
                            primaryConn->DereferenceNotifyRoutine;

            if (notifyRoutine != NULL) {

                if ((*notifyRoutine)(   primaryConn->ExternalInfo,
                                        originatingConnection->ExternalInfo,
                                        NewUrlDN,
                                        mappedHostAddrA,
                                        newConnection->ExternalInfo,
                                        PortNumber,
                                        (PVOID) copyOfPrimaryCreds,
                                        (PVOID) &newConnection->CurrentLogonId,
                                        err )) {

                    //
                    //  the callout routine has agreed to track it, we simply
                    //  need to mark it that it's been handed over.
                    //

                    ACQUIRE_LOCK( &newConnection->StateLock);

                    ASSERT(newConnection->HandlesGivenAsReferrals > 0);
                    newConnection->HandlesGivenToCaller++;

                    RELEASE_LOCK( &newConnection->StateLock);

                    IF_DEBUG(REFERRALS) {
                        LdapPrint2( "HandleReferral: Handle was given to callee for host %s, 0x%x\n",
                                mappedHostAddrA, newConnection );
                    }

                    callDerefCallback = TRUE;

                } else {

                    IF_DEBUG(REFERRALS) {
                        LdapPrint2( "HandleReferral: Handle was not given to callee for host %s, 0x%x\n",
                                mappedHostAddrA, newConnection );
                    }
                }
            }
        }
    }

    //
    //  make note of the fact that we've bumped the connection's
    //  HandlesGivenAsReferrals value... if we back out, we need to handle
    //  decrementing and possibly closing the connection.
    //

    updatedReferralHandleCount = TRUE;

    ACQUIRE_LOCK( &Request->Lock );
    haveLock = TRUE;

    if (Request->ReferralHopLimit <= Request->ReferralCount) {

        IF_DEBUG(REFERRALS) {
            LdapPrint2( "HandleReferral hit hop count limit of 0x%x while handling %0x%x\n",
                         Request->ReferralCount, Request );
        }
        hr = LDAP_RESULTS_TOO_LARGE;
        goto exitReferral;
    }

    //
    //  check the request again to see if this one already has been chased.
    //

    hr = CheckForExistingReferral( Request,
                                   newConnection->HostNameW,
                                   newConnection->PortNumber,
                                   newDN );

    if (hr != LDAP_SUCCESS) {

        //
        //  we've already chased this one... don't chase our tail on it.
        //

        goto exitReferral;
    }

    refTable = Request->ReferralConnections;

    //
    //  find a spot for this in the referral table
    //

    if (refTable == NULL) {

        refTable = (PREFERRAL_TABLE_ENTRY) ldapMalloc(
                        sizeof( REFERRAL_TABLE_ENTRY ) *
                        Request->ReferralHopLimit,
                        LDAP_REFTABLE_SIGNATURE );

        if (refTable == NULL) {

            IF_DEBUG(REFERRALS) {
                LdapPrint1( "HandleReferral could not allocate ref table while handling 0x%x\n",
                             Request );
            }
            hr = LDAP_NO_MEMORY;
            goto exitReferral;
        }
        Request->ReferralConnections = refTable;
        Request->ReferralTableSize = Request->ReferralHopLimit;
    }

    //
    // put the connection into the reference table... note that the index into
    // the referral table starts at 1, because the primary connection is 0.
    //

    i = 1;
    workingEntry = refTable;

    while ((i <= Request->ReferralTableSize) &&
           (workingEntry->ReferralServer != NULL)) {

        i++;
        workingEntry++;
    }

    if (i > Request->ReferralTableSize) {

        IF_DEBUG(REFERRALS) {
            LdapPrint2( "HandleReferral ref table full(0x%x) while handling %0x%x\n",
                         i, Request );
        }
        hr = LDAP_RESULTS_TOO_LARGE;
        goto exitReferral;

    }

    newReferralDN = ldap_dup_stringW( newDN, 0, LDAP_REFDN_SIGNATURE );

    if ((newReferralDN == NULL) && (newDN != NULL)) {

        IF_DEBUG(REFERRALS) {
            LdapPrint1( "HandleReferral could not allocate dn while handling 0x%x\n",
                         Request );
        }
        hr = LDAP_NO_MEMORY;
        goto exitReferral;
    }

    //
    //  put it in the table and reference the connection for the trouble.
    //  It'll be dereferenced when the request is freed.
    //

    workingEntry->ReferralServer = newConnection;
    workingEntry->ReferralInstance = i;
    workingEntry->ReferralDN = newReferralDN;
    workingEntry->ScopeOfSearch = pldapRefDN ? pldapRefDN->ScopeOfSearch : 0;
    workingEntry->SearchFilter = pldapRefDN ? pldapRefDN->SearchFilter : NULL;
    workingEntry->AttributeList = pldapRefDN ? pldapRefDN->AttributeList : NULL;
    workingEntry->CallDerefCallback = callDerefCallback;

    callDerefCallback = FALSE;

    if (searchWasSingleLevel && FromSubordinateReferral) {

        workingEntry->SingleLevelSearch = FALSE;

    } else {

        workingEntry->SingleLevelSearch = TRUE;
    }

    Request->ReferralCount++;

    newConnection = ReferenceLdapConnection( newConnection );
    ASSERT(newConnection);
    
    //
    //  all that remains is to send our request to the referred server.
    //
    
    RELEASE_LOCK( &Request->Lock );
    haveLock = FALSE;

    hr = LdapSendCommand( newConnection, Request, i );

    ACQUIRE_LOCK( &Request->Lock );
    haveLock = TRUE;

    if (hr != LDAP_SUCCESS) {

        workingEntry->ReferralServer = NULL;
        ldapFree( workingEntry->ReferralDN, LDAP_REFDN_SIGNATURE );
        workingEntry->ReferralDN = NULL;

        Request->ReferralCount--;

        RELEASE_LOCK( &Request->Lock );
        haveLock = FALSE;

        DereferenceLdapConnection( newConnection );

   } else {

       //
       // Check to see if this is a paged search request. If it is,
       // we just chased an external referral. This means that we have
       // to keep the connection around by referencing it. We also have
       // to hook up the new connection to the original conn so that all
       // future *paged* requests go to the new connection instead of the
       // old one.
       //

       if (Request->PageRequest != NULL) {

           IF_DEBUG(CONTROLS) {
               LdapPrint0("The parent search was a paged request\n");
           }

           if (newConnection != NULL) {

               IF_DEBUG(CONTROLS) {
                   LdapPrint2("Hooking up new connection 0x%x to req 0x%x\n", newConnection, Request->PageRequest);
               }

               //
               // We do this to counter the fact that this variable will be
               // decremented at the end of this function
               //

               ACQUIRE_LOCK(&newConnection->StateLock);

               ASSERT(newConnection->HandlesGivenAsReferrals > 0);
               newConnection->HandlesGivenAsReferrals++;

               RELEASE_LOCK(&newConnection->StateLock);

               //
               // As we are saving it off as a secondary connection, reference
               // it once more.
               //

               newConnection = ReferenceLdapConnection( newConnection );
               ASSERT(newConnection);

               Request->PageRequest->SecondaryConnection = newConnection;
           }
       }
    }

exitReferral:

    ldapFree( mappedHostAddrA, LDAP_ANSI_SIGNATURE );
    ldapFree( mappedHostAddrW, LDAP_UNICODE_SIGNATURE );

    if (haveLock) {
        RELEASE_LOCK( &Request->Lock );
    }

    if (callDerefCallback && dereferenceRoutine != NULL) {

        ASSERT( newConnection != NULL );

        (*dereferenceRoutine)( primaryConn->ExternalInfo,
                               newConnection->ExternalInfo );
    }

    if (hr != LDAP_SUCCESS) {

        if (updatedReferralHandleCount) {

            ASSERT( newConnection != NULL );

            ACQUIRE_LOCK( &newConnection->StateLock );

            ASSERT(newConnection->HandlesGivenAsReferrals > 0);
            newConnection->HandlesGivenAsReferrals--;

            if ((newConnection->HandlesGivenToCaller == 0 ) &&
                (newConnection->HandlesGivenAsReferrals == 0)) {

                RELEASE_LOCK( &newConnection->StateLock );

                CloseLdapConnection( newConnection );

            }
            else {
                RELEASE_LOCK( &newConnection->StateLock );
            }
        }
    }

    if (newConnection != NULL) {

        DereferenceLdapConnection( newConnection );
    }

    if (copyOfPrimaryCreds != NULL) {

        ldapSecureFree( copyOfPrimaryCreds, LDAP_SECURITY_SIGNATURE );
    }

    if (pldapRefDN != NULL) {

        ldapFree(pldapRefDN->ReferralDN, LDAP_URL_SIGNATURE);
        ldapFree(pldapRefDN->SearchFilter, LDAP_URL_SIGNATURE);
        ldapFree(pldapRefDN->Extension, LDAP_URL_SIGNATURE);
        ldapFree(pldapRefDN->BindName, LDAP_URL_SIGNATURE);

        if (pldapRefDN->AttributeList) {
            for (i=0; i<pldapRefDN->AttribCount; i++) {
                ldapFree(pldapRefDN->AttributeList[i], LDAP_URL_SIGNATURE);
            }
        }

        ldapFree(pldapRefDN->AttributeList, LDAP_URL_SIGNATURE);
        ldapFree(pldapRefDN, LDAP_URL_SIGNATURE);
    }

    return hr;
}

BOOLEAN
DoSigningOptionsMatch(
    PLDAP_CONN pPrimary,
    PLDAP_CONN pReferral
    )
{

    //
    // Signing can be enabled 2 ways: by the user's explicit request, and by a global policy.
    // Global policy is enforced by the LdapBind call, so we don't worry about it here --- whatever
    // signing setting is on the referral connection must be in agreement with the policy.
    // Therefore, we only need to deal with the user's explicit requests here.  If the user
    // requested the primary connection to be signed, the referral connection MUST
    // be signed.  (Note: It's possible that the user requested signing for the primary connection but
    // that the primary connection isn't actually signed, because a bind was never performed.  However,
    // to be safe and avoid opening any unexpected security holes, we require the referral to be signed
    // anyway.  This also duplicates the W2k behavior.)
    //
    if (pPrimary->UserSignDataChoice) {
        return (pReferral->CurrentSignStatus) ? TRUE : FALSE;
    }

    //
    // If the user didn't request signing on the primary, we just accept the referral
    // whether or not it's signed.  This could mean the referral is signed but the primary
    // isn't, but that's okay, we just get some extra security for free.  (We don't have to worry
    // about whether or not the referral meets policy guidelines, because LdapBind would have taken
    // care of that when the referral connection was opened.)
    //
    return TRUE;
}


BOOLEAN
DoCredentialsMatch(
    PLDAP_CONN pReferral,
    DWORD BindMethod,
    CredHandle * pcomparisonHandle,
    PWCHAR comparisonBindName,
    PWCHAR comparisonBindPwd    
    )
{
    BOOLEAN fMatch = FALSE;
    BOOLEAN fNeedToScramble = FALSE;

    //
    // For simplicity, we'll require that they be bound using the same package
    // to count as a match (otherwise, we'd wind up comparing simple binds to
    // Negotiate binds, etc.)
    //

    ACQUIRE_LOCK(&pReferral->StateLock);
    if (pReferral->BindMethod != BindMethod) {

        RELEASE_LOCK(&pReferral->StateLock);
        return FALSE;
    }
    RELEASE_LOCK(&pReferral->StateLock);

    //
    // Perform a match, using a method appropriate to the auth package
    // in question
    //
    switch (BindMethod) {

        case LDAP_AUTH_SIMPLE:
            // For simple bind, either both connections must have no username/password (anonymous),
            // or they must both have the same username/password

            ACQUIRE_LOCK( &pReferral->StateLock );

            if ((comparisonBindName == NULL) &&
                (comparisonBindPwd == NULL) &&
                (pReferral->DNOnBind == NULL) &&
                (pReferral->CurrentCredentials == NULL)) {

                // both anonymous --> they match
                fMatch = TRUE;
            }
            else if ( (comparisonBindName && !(pReferral->DNOnBind)) ||
                      (pReferral->DNOnBind && !(comparisonBindName)) ||
                      (comparisonBindPwd && !(pReferral->CurrentCredentials)) ||
                      (pReferral->CurrentCredentials && !(comparisonBindPwd)) ) {

                // they couldn't possibly match
                fMatch = FALSE;
            }
            else {

                ACQUIRE_LOCK( &pReferral->ScramblingLock );            

                if ( GlobalUseScrambling && pReferral->Scrambled && pReferral->CurrentCredentials) {

                   DecodeUnicodeString(&pReferral->ScrambledCredentials);
                   pReferral->Scrambled = FALSE;
                   fNeedToScramble = TRUE;
                }

                fMatch = FALSE;
                
                if ( (!pReferral->DNOnBind && !comparisonBindName) ||
                     (ldapWStringsIdentical(pReferral->DNOnBind, -1, comparisonBindName, -1)) ) {

                    if ( (!pReferral->CurrentCredentials && !comparisonBindPwd) ||
                         (ldapWStringsIdentical(pReferral->CurrentCredentials, -1, comparisonBindPwd, -1)) ) {

                        fMatch = TRUE;
                    }
                }

                if ( fNeedToScramble && GlobalUseScrambling && !pReferral->Scrambled && pReferral->CurrentCredentials) {

                   EncodeUnicodeString(&pReferral->ScrambledCredentials);
                   pReferral->Scrambled = TRUE;
                }

                RELEASE_LOCK( &pReferral->ScramblingLock );
            }

            RELEASE_LOCK( &pReferral->StateLock );
            
            break;

        case LDAP_AUTH_EXTERNAL:
            // In an External bind, the credentials are dependent on the client certificate
            // that was presented to the server during the SSL negotiations.  Rather than deal
            // with this, we'll just force a new connection.
            fMatch = FALSE;
            break;

        default:
            // All other binds methods, including Negotiate, Digest, etc.
            // We'll check to see if the connections are using the same credentials
            // handle.
            ACQUIRE_LOCK(&pReferral->StateLock);    
            if ( (pcomparisonHandle->dwLower == pReferral->hCredentials.dwLower) &&
                 (pcomparisonHandle->dwUpper == pReferral->hCredentials.dwUpper) ) {

                fMatch = TRUE;
            }
            else {

                fMatch = FALSE;
            }
            RELEASE_LOCK(&pReferral->StateLock);


            break;
    }


    return fMatch;
}


ULONG
CheckForExistingReferral (
    PLDAP_REQUEST Request,
    PWCHAR HostAddr,
    USHORT PortNumber,
    PWCHAR NewDN
    )
//
//  This routine checks if a request already has chased a given referral.
//
//  It returns LDAP_SUCCESS if it doesn't exist, LDAP_LOOP_DETECT if it does.
//
//  The request's lock must be held coming in to here!
//
{
    PREFERRAL_TABLE_ENTRY refTable;
    ULONG lenHostAddr;
    ULONG lenNewDN;
    ULONG socket = (*phtons)( PortNumber );
    USHORT refTableEntries = 0;

    if ((HostAddr == NULL) ||
        ((lenHostAddr = strlenW(HostAddr)) == 0)) {

        return LDAP_LOOP_DETECT;
    }

    ASSERT( Request->PrimaryConnection->publicLdapStruct.ld_host != NULL );

    lenNewDN = strlenW( NewDN );

    //
    //  if the one coming in is equal to the one we started with, bail.
    //

    if ((ldapWStringsIdentical(
                         HostAddr,
                         lenHostAddr,
                         Request->PrimaryConnection->HostNameW,
                         -1 )) &&
        (Request->PrimaryConnection->SocketAddress.sin_port == socket) &&
        (ldapWStringsIdentical( NewDN,
                                lenNewDN,
                                Request->OriginalDN,
                                -1))) {

        return LDAP_LOOP_DETECT;
    }

    refTable = Request->ReferralConnections;

    if (refTable == NULL) {

        return LDAP_SUCCESS;
    }

    while (refTableEntries < Request->ReferralTableSize) {

        if ((refTable->ReferralServer != NULL ) &&
            (ldapWStringsIdentical(
                             HostAddr,
                             lenHostAddr,
                             refTable->ReferralServer->HostNameW,
                             -1 )) &&
            (refTable->ReferralServer->SocketAddress.sin_port == socket) &&
            (ldapWStringsIdentical( NewDN,
                                    lenNewDN,
                                    refTable->ReferralDN,
                                    -1))) {

            return LDAP_LOOP_DETECT;
        }
        refTableEntries++;
        refTable++;
    }

    return LDAP_SUCCESS;
}


ULONG
LdapSendCommand (
    PLDAP_CONN Connection,
    PLDAP_REQUEST Request,
    USHORT ReferralNumber
    )
//
//  The request lock must be held coming in here.  We assume both the request
//  and connection blocks are referenced.
//
{
    ULONG hr;
    PREFERRAL_TABLE_ENTRY refTable;
    PWCHAR workingDN;
    LONG NewMessageId;
    CLdapBer **berMessage;

    if (ReferralNumber == 0) {

        refTable = NULL;
        workingDN = Request->OriginalDN;
        berMessage = (CLdapBer **) &Request->BerMessageSent;

    } else {

        //
        //  We go to the nth-1 element in the array of referrals.. this is the
        //  one that originated this message.
        //

        refTable = Request->ReferralConnections;
        refTable += (ReferralNumber - 1);

        workingDN = refTable->ReferralDN;
        berMessage = (CLdapBer **) &refTable->BerMessageSent;
    }

    NewMessageId = MAKE_MESSAGE_NUMBER( Request->MessageId, ReferralNumber );

    if ((refTable) &&
        (refTable->ScopeOfSearch == LDAP_SCOPE_UNDEFINED) &&
        (Request->Operation == LDAP_SEARCH_CMD)) {

        refTable->ScopeOfSearch = Request->search.ScopeOfSearch;
    }

    switch (Request->Operation) {
    case LDAP_SEARCH_CMD:

        hr  = SendLdapSearch(Request,
                             Connection,
                             workingDN,
                             ((refTable)? refTable->ScopeOfSearch : LDAP_SCOPE_BASE),
                             ((refTable && refTable->SearchFilter)? refTable->SearchFilter:Request->search.SearchFilter),
                             ((refTable && refTable->AttributeList)? refTable->AttributeList:Request->search.AttributeList),
                             Request->search.AttributesOnly,
                             Request->search.Unicode,
                             berMessage,
                             NewMessageId );
        break;

    case LDAP_MODIFY_CMD :

        hr = SendLdapModify( Request,
                             Connection,
                             workingDN,
                             berMessage,
                             Request->modify.AttributeList,
                             Request->modify.Unicode,
                             NewMessageId );
        break;

    case LDAP_ADD_CMD :

        hr = SendLdapAdd(   Request,
                            Connection,
                            workingDN,
                            Request->add.AttributeList,
                            berMessage,
                            Request->add.Unicode,
                            NewMessageId );
        break;

    case LDAP_DELETE_CMD :

        hr = SendLdapDelete( Request,
                             Connection,
                             workingDN,
                             berMessage,
                             NewMessageId );
        break;

    case LDAP_MODRDN_CMD :

        hr = SendLdapRename( Request,
                             Connection,
                             workingDN,
                             berMessage,
                             NewMessageId
                             );
        break;

    case LDAP_COMPARE_CMD :

        hr = SendLdapCompare( Request,
                              Connection,
                              berMessage,
                              workingDN,
                              NewMessageId
                              );
        break;

    case LDAP_EXTENDED_CMD :

        hr = SendLdapExtendedOp( Request,
                                 Connection,
                                 Request->OriginalDN,
                                 berMessage,
                                 NewMessageId );
        break;

    default:

        ASSERT(FALSE);

        hr = LDAP_LOCAL_ERROR;

        IF_DEBUG(REFERRALS) {
            LdapPrint2( "LdapSendCommand asked to send cmd of 0x%x handling %0x%x\n",
                         Request->Operation, Request );
        }

    }


    return hr;
}


PLDAPReferralDN
LdapParseReferralDN(
    PWCHAR newDN
    )
{

    PWCHAR CurrentPos, TempPos;
    PLDAPReferralDN pRefDN = NULL;
    int lengthOfDN = 0;
    ULONG i;
    WCHAR savedChar;

    if ((!newDN) || (*newDN == L'\0')) {

        return NULL;
    }

    CurrentPos = TempPos = newDN;

    pRefDN = (PLDAPReferralDN) ldapMalloc(sizeof(LDAPReferralDN), LDAP_URL_SIGNATURE);

    if (!pRefDN) {
        return NULL;
    }

    IF_DEBUG (REFERRALS) {
        LdapPrint1("LdapParseReferralDN: Given string is %S\n", CurrentPos);
    }

    pRefDN->ScopeOfSearch = LDAP_SCOPE_UNDEFINED;

    //
    // The first item in the string is the <dn>
    // If the next char is a \0 or a '?', then we didnt get a <dn>
    //

    if( *CurrentPos == L'?') {

        pRefDN->ReferralDN = NULL;
        CurrentPos++;
        TempPos++;

    } else {

        //
        // We found a DN. Discover the length and copy it.
        //

        while( *TempPos && (*TempPos != L'?')) {

            TempPos++;
            lengthOfDN++;
        }

        savedChar = *TempPos;
        *TempPos = L'\0';

        pRefDN->ReferralDN = ldap_dup_stringW( CurrentPos, 0, LDAP_URL_SIGNATURE );

        IF_DEBUG (REFERRALS) {
            LdapPrint1("LdapParseReferralDN: Discovered referralDN of %S\n", pRefDN->ReferralDN);
        }

        *TempPos = savedChar;
        CurrentPos = TempPos;

        if (*CurrentPos) {
            //
            // Skip over the next '?'
            //
            CurrentPos++;
            TempPos++;
        }
    }

    //
    // Next on line is the attributes for this search ...
    // There are no attributes if this is the end of the string
    // or the current character is a ?
    //

    if (!*CurrentPos) {

        pRefDN->AttributeList = NULL;
        goto DoneParsing;

    } else if ((*CurrentPos == L'?') && (*(CurrentPos-1) != L'\\' )) {

        pRefDN->AttributeList = NULL;
        CurrentPos++;
        TempPos++;

    } else {

        while( (*TempPos) &&
               (*TempPos != L'?') &&
               (*(TempPos-1) != L'\\')) {
            //
            // Seek the end of the attribute list
            //
            TempPos++;
        }

        if(*TempPos) {
            //
            // and null-terminate it.
            //

            *TempPos = L'\0';
            TempPos++;
        }

            //
            // Count the commas in the attrib string
            //

            PWCHAR lp = CurrentPos;

            while(*lp && *lp != L'\0') {

                if((*lp == L',') && (*(lp-1) != L'\\')) {

                    pRefDN->AttribCount++;
                }
                lp++;
            }

            pRefDN->AttribCount++; // one more attribute than commas

            //
            // allocate an extra location for the null-terminator
            //

            pRefDN->AttributeList = (PWCHAR*) ldapMalloc( sizeof(PWCHAR) * (pRefDN->AttribCount+1),
                                                           LDAP_URL_SIGNATURE);

            if ( pRefDN->AttributeList == NULL ) {

                ldapFree( pRefDN, LDAP_URL_SIGNATURE );
                return NULL;
            }

            PWCHAR lpEnd = CurrentPos; // points to start of attribute list

            for(i=0; i<pRefDN->AttribCount ; i++) {

                PWCHAR lpStart = lpEnd;

                while(*lpEnd && *lpEnd!= L',' && *(lpEnd-1)!= L'\\') {
                    lpEnd++;
                }

                lpStart = lpEnd;
                lpStart++;
                *lpEnd = L'\0';
                pRefDN->AttributeList[i] = ldap_dup_stringW(CurrentPos, 0, LDAP_URL_SIGNATURE);
                CurrentPos = lpStart;
            }

            pRefDN->AttributeList[++i] = NULL;

            //
            // Restore both ptrs to the end of the attribute list.
            //

            CurrentPos = TempPos;

            if (*CurrentPos) {
                //
                // Skip over the next '?'
                //
                CurrentPos++;
                TempPos++;
            }
    }


    //
    // Next is the scope which can be one of 3 values
    //

    if (!*CurrentPos) {

        pRefDN->ScopeOfSearch = LDAP_SCOPE_UNDEFINED;
        goto DoneParsing;

    } else if (*CurrentPos == L'?'){

        pRefDN->ScopeOfSearch = LDAP_SCOPE_UNDEFINED;
        CurrentPos++;
        TempPos++;

    } else {

        ULONG CurrentStrLen = strlenW( CurrentPos );

        if(ldapWStringsIdentical( CurrentPos, (LONG)min( sizeof("one")-1, CurrentStrLen), L"one", -1)) {

            pRefDN->ScopeOfSearch = LDAP_SCOPE_ONELEVEL;

#pragma prefast(suppress:305, "deliberately use the byte count as a ANSI character count (Prefast bug 544)")                            
            TempPos += sizeof("one") - 1;

        } else if(ldapWStringsIdentical( CurrentPos, (LONG)min( sizeof("sub")-1, CurrentStrLen), L"sub", -1)) {

            pRefDN->ScopeOfSearch = LDAP_SCOPE_SUBTREE;

#pragma prefast(suppress:305, "deliberately use the byte count as a ANSI character count (Prefast bug 544)")                            
            TempPos += sizeof("sub") - 1;

        } else if(ldapWStringsIdentical( CurrentPos, (LONG)min( sizeof("base")-1, CurrentStrLen), L"base", -1)) {

            pRefDN->ScopeOfSearch = LDAP_SCOPE_BASE;

#pragma prefast(suppress:305, "deliberately use the byte count as a ANSI character count (Prefast bug 544)")                            
            TempPos += sizeof("base") - 1;

        } else {

            pRefDN->ScopeOfSearch = LDAP_SCOPE_UNDEFINED;
            IF_DEBUG(REFERRALS) {
                LdapPrint0("LdapParseReferralDN: Did not find any scope\n");
            }
        }

        CurrentPos = TempPos;
    }


    //
    // Finally the filter
    //

    if(!*CurrentPos) {

        pRefDN->SearchFilter = NULL;

        IF_DEBUG(REFERRALS) {
            LdapPrint0("LdapParseReferralDN: NO search filter found in referral\n");
        }

    } else {

        if (*CurrentPos != L'?') {
            
            pRefDN->SearchFilter = NULL;
            LdapPrint0("LdapParseReferralDN: Invalid search filter found in referral\n ");
            goto DoneParsing;
        }

        CurrentPos++;
        TempPos++;

        if (*CurrentPos == L'?') {
            
            //
            // This URL has extensions which we will not parse
            //
            goto DoneParsing;
        }
        
        pRefDN->SearchFilter = ldap_dup_stringW(CurrentPos, 0, LDAP_URL_SIGNATURE);

        IF_DEBUG(REFERRALS) {
            LdapPrint1("LdapParseReferralDN: Found search filter %S\n", pRefDN->SearchFilter);
        }
    }

    //
    // For the time being, we will not bother about extensions.
    //

DoneParsing:

    return pRefDN;

}
// referral.c eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\rename.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rename.cxx handle rename requests to an LDAP server

Abstract:

   This module implements the LDAP rename APIs.

Author:

    Andy Herron (andyhe)        02-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG
LdapRename (
    PLDAP_CONN connection,
    PWCHAR   DistinguishedName,
    PWCHAR   NewDistinguishedName,
    PWCHAR   NewParent,
    INT      DeleteOldRdn,
    BOOLEAN  Unicode,
    BOOLEAN  Synchronous,
    PLDAPControlW   *ServerControls,
    PLDAPControlW   *ClientControls,
    ULONG           *MessageNumber
    )
{
    ULONG hr;
    PLDAP_REQUEST request = NULL;
    ULONG messageNumber;
    ULONG err;

    if (MessageNumber == NULL) {

        return LDAP_PARAM_ERROR;
    }

    *MessageNumber = (ULONG) -1;


    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {
       return err;
    }

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    request = LdapCreateRequest( connection, LDAP_MODRDN_CMD );

    if (request == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap_rename connection 0x%x couldn't allocate request.\n", connection);
        }
        hr = LDAP_NO_MEMORY;
        SetConnectionError( connection, hr, NULL );
        return hr;
    }

    messageNumber = request->MessageId;

    request->Synchronous = Synchronous;

    hr = LDAP_SUCCESS;

    if ((ServerControls != NULL) || (ClientControls != NULL)) {

        hr = LdapCheckControls( request,
                                ServerControls,
                                ClientControls,
                                Unicode,
                                0 );

        if (hr != LDAP_SUCCESS) {

            IF_DEBUG(CONTROLS) {
                LdapPrint2( "ldap_comp connection 0x%x trouble with SControl, err 0x%x.\n",
                            connection, hr );
            }
        }
    }

    if (hr == LDAP_SUCCESS) {

        request->rename.DeleteOldRdn         = DeleteOldRdn;

        if (Synchronous || (request->ChaseReferrals == 0)) {

            request->AllocatedParms = FALSE;
            request->OriginalDN = DistinguishedName;
            request->rename.NewDistinguishedName = NewDistinguishedName;
            request->rename.NewParent            = NewParent;

        } else {

            request->AllocatedParms = TRUE;

            if (DistinguishedName != NULL) {

                request->OriginalDN = ldap_dup_stringW( DistinguishedName, 0, LDAP_UNICODE_SIGNATURE );

                if (request->OriginalDN == NULL) {

                    hr = LDAP_NO_MEMORY;
                }
            }

            if ((hr == LDAP_SUCCESS) && (NewDistinguishedName != NULL)) {

                request->rename.NewDistinguishedName = ldap_dup_stringW( NewDistinguishedName, 0, LDAP_UNICODE_SIGNATURE );

                if (request->rename.NewDistinguishedName == NULL) {

                    hr = LDAP_NO_MEMORY;
                }
            }

            if ((hr == LDAP_SUCCESS) && (NewParent != NULL)) {

                request->rename.NewParent = ldap_dup_stringW( NewParent, 0, LDAP_UNICODE_SIGNATURE );

                if (request->rename.NewParent == NULL) {

                    hr = LDAP_NO_MEMORY;
                }
            }
        }
    }

    if (hr == LDAP_SUCCESS) {

        hr = SendLdapRename( request,
                             connection,
                             request->OriginalDN,
                             (CLdapBer **)&request->BerMessageSent,
                             0 );
    }

    if (hr != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_rename connection 0x%x errored with 0x%x.\n",
                        connection, hr );
        }

        messageNumber = (ULONG) -1;
        SetConnectionError( connection, hr, NULL );

        CloseLdapRequest( request );
    }

    *MessageNumber = messageNumber;

    DereferenceLdapRequest( request );
    return hr;
}


ULONG
SendLdapRename (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection,
    PWCHAR DistinguishedName,
    CLdapBer **Lber,
    LONG AltMsgId
    )
//
//  A modifyRdn (rename) looks like this :
//
//     ModifyRDNRequest ::=
//         [APPLICATION 12] SEQUENCE {
//              entry          LDAPDN,
//              newrdn         RelativeLDAPDN,
//              deleteoldrdn   BOOLEAN
//         }
//
//
{
    PWCHAR  NewDistinguishedName = Request->rename.NewDistinguishedName;
    PWCHAR  NewParent = Request->rename.NewParent;
    INT     DeleteOldRdn = Request->rename.DeleteOldRdn;

    ULONG err;

    CLdapBer *lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

    if (lber == NULL) {
        SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
        return LDAP_NO_MEMORY;
    }

    err = lber->HrStartWriteSequence();
    if (err != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldap_modrdn startWrite conn 0x%x encoding error of 0x%x.\n",
                        Connection, err );
        }

        err = LDAP_ENCODING_ERROR;
        goto returnError;

    } else {            // we can't forget EndWriteSequence

       if (AltMsgId != 0) {

          err = lber->HrAddValue((LONG) AltMsgId );

       } else {

          err = lber->HrAddValue((LONG) Request->MessageId );
       }

       if (err != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_modrdn MsgNo conn 0x%x encoding error of 0x%x.\n",
                            Connection, err );
            }
            err = LDAP_ENCODING_ERROR;
            goto returnError;
        }

        err = lber->HrStartWriteSequence(LDAP_MODRDN_CMD);
        if (err != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_modrdn cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, err );
            }
            err = LDAP_ENCODING_ERROR;
            goto returnError;

        } else {        // we can't forget EndWriteSequence

            err = lber->HrAddValue((const WCHAR *) DistinguishedName );
            if (err != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_modrdn DN conn 0x%x encoding error of 0x%x.\n",
                                Connection, err );
                }
                err = LDAP_ENCODING_ERROR;
                goto returnError;
            }

            err = lber->HrAddValue((const WCHAR *)NewDistinguishedName );
            if (err != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_modrdn newDN conn 0x%x encoding error of 0x%x.\n",
                                Connection, err );
                }
                err = LDAP_ENCODING_ERROR;
                goto returnError;
            }

            err = lber->HrAddValue((BOOLEAN) DeleteOldRdn, BER_BOOLEAN );
            if (err != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_modrdn delOldRdn conn 0x%x encoding error of 0x%x.\n",
                                Connection, err );
                }
                err = LDAP_ENCODING_ERROR;
                goto returnError;
            }

            if ((Connection->publicLdapStruct.ld_version != LDAP_VERSION2) &&
                (NewParent != NULL)) {

                // 0x80 comes from context specific, primitive, optional tag 0

                err = lber->HrAddValue((const WCHAR *) NewParent, 0x80 );
                if (err != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "ldap_modrdn newDN conn 0x%x encoding error of 0x%x.\n",
                                    Connection, err );
                    }
                    err = LDAP_ENCODING_ERROR;
                    goto returnError;
                }
            }

            err = lber->HrEndWriteSequence();
            ASSERT( err == NOERROR );
        }

        //
        //  put in the server controls here if required
        //

        if ( (Connection->publicLdapStruct.ld_version != LDAP_VERSION2) &&
             ( Request->ServerControls != NULL )) {

            err = InsertServerControls( Request, Connection, lber );

            if (err != LDAP_SUCCESS) {

                if (lber != NULL) {

                   delete lber;
                }
                return err;
            }
        }

        err = lber->HrEndWriteSequence();
        ASSERT( err == NOERROR );
    }

    //
    //  send the modrdn request.
    //

    ACQUIRE_LOCK( &Connection->ReconnectLock );
    
    AddToPendingList( Request, Connection );

    err = LdapSend( Connection, lber );

    if (err != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "SendLdapRename connection 0x%x send with error of 0x%x.\n",
                        Connection, err );
        }
        DecrementPendingList( Request, Connection );

    } else {

        //
        //  Save off the lber value, free any lber message that is already
        //  present.
        //

        lber = (CLdapBer *) InterlockedExchangePointer((PVOID *) Lber,
                                                       (PVOID) lber );
    }

    RELEASE_LOCK( &Connection->ReconnectLock );


returnError:

    if (lber != NULL) {

       delete lber;
    }
    return err;
}

ULONG __cdecl
ldap_modrdn2W (
    LDAP    *ExternalHandle,
    PWCHAR   DistinguishedName,
    PWCHAR   NewDistinguishedName,
    INT     DeleteOldRdn
    )
{
    ULONG err;
    ULONG msgId = (ULONG) -1;
    PLDAP_CONN connection = NULL;
    PWCHAR generatedNewDN = NULL;
    PWCHAR startOfRDN = NULL;
    PWCHAR equalPointer = NULL;
    PWCHAR startOfParent = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (NewDistinguishedName == NULL)) {

        SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
        err = (ULONG) -1;
        goto error;
    }

    //
    //  We have to normalize the newDN as we need to determine the RDN and the
    //  parent.
    //

    err = ldap_ufn2dnW( NewDistinguishedName, &generatedNewDN );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        err = (ULONG) -1;
        goto error;
    }

    //
    //  we have to break up the new DN into two pieces... one is the new RDN,
    //  the other is the new parent, if present.  Two cases to cover:
    //
    //  1)  cn=bob                result is simply cn=bob with null parent
    //  2)  cn=bob,ou=foo,o=bar   result is cn=bob, parent is ou=foo,o=bar
    //

    err = ParseLdapToken(   generatedNewDN,
                            &startOfRDN,
                            &equalPointer,
                            &startOfParent );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        err = (ULONG) -1;
        goto error;
    }

    if (startOfParent != NULL) {

        if (*startOfParent == L',') {

            //
            //  slam a null in at end of first token.  We effectively
            //  turn CN=BOB,OU=NT,O=MS,C=US into two parts...
            //       CN=BOB  and OU=NT,O=MS,C=US
            //

            *startOfParent = L'\0';
            startOfParent++;
        }
        if (*startOfParent == L'\0') {
            startOfParent = NULL;
        }
    }

    err = LdapRename(    connection,
                         DistinguishedName,
                         startOfRDN,
                         startOfParent,
                         DeleteOldRdn,
                         TRUE,
                         FALSE,
                         NULL,
                         NULL,
                         &msgId
                         );

    SetConnectionError( connection, err, NULL );

error:
    if (generatedNewDN)
        ldapFree( generatedNewDN, LDAP_GENERATED_DN_SIGNATURE );

    if (connection)
        DereferenceLdapConnection( connection );

    return msgId;
}

ULONG __cdecl
ldap_modrdn2 (
    LDAP    *ExternalHandle,
    PCHAR   DistinguishedName,
    PCHAR   NewDistinguishedName,
    INT     DeleteOldRdn
    )
{
    ULONG err;
    PWCHAR wName = NULL;
    PWCHAR wNewName = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);
    if (connection == NULL) {

        return (ULONG) -1;
    }

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        err = (ULONG) -1;
        goto error;
    }

    err = ToUnicodeWithAlloc( NewDistinguishedName, -1, &wNewName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        err = (ULONG) -1;
        goto error;
    }

    err = ldap_modrdn2W( connection->ExternalInfo, wName, wNewName, DeleteOldRdn );

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wNewName)
        ldapFree( wNewName, LDAP_UNICODE_SIGNATURE );

    DereferenceLdapConnection( connection );

    return err;
}


ULONG __cdecl
ldap_modrdn2_sW (
    LDAP    *ExternalHandle,
    PWCHAR   DistinguishedName,
    PWCHAR   NewDistinguishedName,
    INT     DeleteOldRdn
    )
{
    ULONG err;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;
    ULONG msgId;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    msgId = ldap_modrdn2W(  connection->ExternalInfo,
                            DistinguishedName,
                            NewDistinguishedName,
                            DeleteOldRdn
                            );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  otherwise we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                    );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( connection->ExternalInfo,
                                     results,
                                     TRUE
                                     );
        }
    } else {

        err = connection->publicLdapStruct.ld_errno;
    }

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_modrdn2_s (
    LDAP    *ExternalHandle,
    PCHAR   DistinguishedName,
    PCHAR   NewDistinguishedName,
    INT     DeleteOldRdn
    )
{
    ULONG err;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;
    ULONG msgId;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    msgId = ldap_modrdn2(   connection->ExternalInfo,
                            DistinguishedName,
                            NewDistinguishedName,
                            DeleteOldRdn
                            );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  otherwise we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                    );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( connection->ExternalInfo,
                                     results,
                                     TRUE
                                     );
        }
    } else {

        err = connection->publicLdapStruct.ld_errno;
    }

    DereferenceLdapConnection( connection );

    return err;
}

//
//  The old style call modrdn is still supported.
//

ULONG __cdecl
ldap_modrdnW (
    LDAP    *ExternalHandle,
    PWCHAR   DistinguishedName,
    PWCHAR   NewDistinguishedName
    )
{
    return( ldap_modrdn2W( ExternalHandle,
                           DistinguishedName,
                           NewDistinguishedName,
                           1
                           ) );
}

ULONG __cdecl
ldap_modrdn (
    LDAP    *ExternalHandle,
    PCHAR   DistinguishedName,
    PCHAR   NewDistinguishedName
    )
{
    return( ldap_modrdn2( ExternalHandle,
                          DistinguishedName,
                          NewDistinguishedName,
                          1
                          ) );
}

ULONG __cdecl
ldap_modrdn_sW (
    LDAP    *ExternalHandle,
    PWCHAR   DistinguishedName,
    PWCHAR   NewDistinguishedName
    )
{
  return( ldap_modrdn2_sW( ExternalHandle,
                           DistinguishedName,
                           NewDistinguishedName,
                           1
                           ) );
}

ULONG __cdecl
ldap_modrdn_s (
    LDAP    *ExternalHandle,
    PCHAR   DistinguishedName,
    PCHAR   NewDistinguishedName
    )
{
    return( ldap_modrdn2_s( ExternalHandle,
                            DistinguishedName,
                            NewDistinguishedName,
                            1
                            ) );
}

ULONG __cdecl
ldap_rename_extW(
        LDAP *ExternalHandle,
        PWCHAR DistinguishedName,
        PWCHAR NewRDN,
        PWCHAR NewParent,
        INT DeleteOldRdn,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           *MessageNumber
        )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }


    err = LdapRename(   connection,
                        DistinguishedName,
                        NewRDN,
                        NewParent,
                        DeleteOldRdn,
                        TRUE,
                        FALSE,
                        ServerControls,
                        ClientControls,
                        MessageNumber
                        );

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_rename_extA(
        LDAP *ExternalHandle,
        PCHAR DistinguishedName,
        PCHAR NewRDN,
        PCHAR NewParent,
        INT DeleteOldRdn,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        ULONG           *MessageNumber
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    ULONG msgId = (ULONG) -1;
    PLDAP_CONN connection = NULL;
    PWCHAR wNewRDN = NULL;
    PWCHAR wNewParent = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (MessageNumber == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *MessageNumber = (ULONG) -1;

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
        goto error;
    }

    err = ToUnicodeWithAlloc( NewRDN, -1, &wNewRDN, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
        goto error;
    }

    if (NewParent != NULL) {

        err = ToUnicodeWithAlloc( NewParent, -1, &wNewParent, LDAP_UNICODE_SIGNATURE, LANG_ACP );

        if (err != LDAP_SUCCESS) {

            SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
            goto error;
        }
    }

    err = LdapRename(    connection,
                         wName,
                         wNewRDN,
                         wNewParent,
                         DeleteOldRdn,
                         FALSE,
                         FALSE,
                         (PLDAPControlW *) ServerControls,
                         (PLDAPControlW *) ClientControls,
                         &msgId
                         );

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wNewRDN)
        ldapFree( wNewRDN, LDAP_UNICODE_SIGNATURE );

    if (wNewParent)
        ldapFree( wNewParent, LDAP_UNICODE_SIGNATURE );

    if (connection)
        DereferenceLdapConnection( connection );

    if (MessageNumber) {
        *MessageNumber = msgId;
    }

    return err;
}

ULONG __cdecl
ldap_rename_ext_sW(
        LDAP *ExternalHandle,
        PWCHAR DistinguishedName,
        PWCHAR NewRDN,
        PWCHAR NewParent,
        INT DeleteOldRdn,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls
        )
{
    ULONG msgId;
    ULONG err;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapRename(  connection,
                       DistinguishedName,
                       NewRDN,
                       NewParent,
                       DeleteOldRdn,
                       TRUE,
                       TRUE,
                       ServerControls,
                       ClientControls,
                       &msgId
                       );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                      );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( connection->ExternalInfo,
                                     results,
                                     TRUE
                                     );
        }
    }

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_rename_ext_sA(
        LDAP *ExternalHandle,
        PCHAR DistinguishedName,
        PCHAR NewRDN,
        PCHAR NewParent,
        INT DeleteOldRdn,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls
        )
{
    ULONG err;
    PWCHAR wName = NULL;
    ULONG msgId;
    LDAPMessage *results = NULL;
    PLDAP_CONN connection = NULL;
    PWCHAR wNewRDN = NULL;
    PWCHAR wNewParent = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    err = ToUnicodeWithAlloc( NewRDN, -1, &wNewRDN, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    if (NewParent != NULL) {

        err = ToUnicodeWithAlloc( NewParent, -1, &wNewParent, LDAP_UNICODE_SIGNATURE, LANG_ACP );

        if (err != LDAP_SUCCESS) {

            goto error;
        }
    }

    err = LdapRename(    connection,
                         wName,
                         wNewRDN,
                         wNewParent,
                         DeleteOldRdn,
                         FALSE,
                         TRUE,
                         (PLDAPControlW *) ServerControls,
                         (PLDAPControlW *) ClientControls,
                         &msgId
                         );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  otherwise we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error( connection,
                                      msgId,
                                      LDAP_MSG_ALL,
                                      NULL,           // no timeout value specified
                                      &results,
                                      NULL
                                    );

        if (results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( connection->ExternalInfo,
                                     results,
                                     TRUE
                                     );
        }
    }

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wNewRDN)
        ldapFree( wNewRDN, LDAP_UNICODE_SIGNATURE );

    if (wNewParent)
        ldapFree( wNewParent, LDAP_UNICODE_SIGNATURE );

    DereferenceLdapConnection( connection );

    return err;
}

// rename.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\request.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    request.cxx  request block maintencance for the LDAP api

Abstract:

   This module implements routines that maintain request blocks

Author:

    Andy Herron (andyhe)        03-Aug-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

PLDAP_REQUEST LdapCreateRequest (
    PLDAP_CONN Connection,
    UCHAR Operation
    )
//
//  This returns a block that is used to represent a client request.
//
{
    PLDAP_REQUEST request;

    ACQUIRE_LOCK( &RequestListLock );
    if (GlobalRejectNewRequests) {
        // fail if we're not currently permitting new requests
        return NULL;
    }
    RELEASE_LOCK( &RequestListLock );
    

    //
    // As we'll be storing a pointer to connection in the request block, we need to
    // reference the connection - this can fail if the connection is being closed.
    // So lets do it up fromt and fail if this fails
    //

    Connection = ReferenceLdapConnection( Connection );
    if (!Connection)
    {
        return NULL;
    }

    //
    //  allocate the request block and setup all the initial values
    //

    request = (PLDAP_REQUEST) ldapMalloc(   sizeof( LDAP_REQUEST),
                                            LDAP_REQUEST_SIGNATURE );

    if (request == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "LdapCreateRequest could not allocate 0x%x bytes.\n", sizeof( LDAP_REQUEST ) );
        }
        DereferenceLdapConnection(Connection);
        return(NULL);
    }

    //
    //  keep in mind the memory is already zero initialized
    //

    request->ReferenceCount = 2;

    __try {
        INITIALIZE_LOCK( &request->Lock );
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // Something went wrong
        //
        IF_DEBUG(REQUEST) {
            LdapPrint2( "LDAP failed to initialize critical sections while creating request at 0x%x, conn is 0x%x.\n",
                           request, Connection );
        }

        ldapFree(request, LDAP_REQUEST_SIGNATURE);
        DereferenceLdapConnection(Connection);

        return NULL;
    }

    request->PrimaryConnection = Connection;

    request->Operation = Operation;
    request->RequestTime = LdapGetTickCount();
    request->TimeLimit = Connection->publicLdapStruct.ld_timelimit;
    request->SizeLimit = Connection->publicLdapStruct.ld_sizelimit;
    request->ReferralHopLimit = LOWORD( Connection->publicLdapStruct.ld_refhoplimit );
    request->ResentAttempts = 0;

    request->ReferenceConnectionsPerMessage = Connection->ReferenceConnectionsPerMessage;

    if (Connection->publicLdapStruct.ld_options & LDAP_OPT_CHASE_REFERRALS) {

        request->ChaseReferrals = (LDAP_CHASE_SUBORDINATE_REFERRALS |
                                   LDAP_CHASE_EXTERNAL_REFERRALS);

    } else if (Connection->publicLdapStruct.ld_options & LDAP_OPT_RETURN_REFS) {

        request->ChaseReferrals = 0;

    } else {

        request->ChaseReferrals = (UCHAR) (Connection->publicLdapStruct.ld_options &
             (LDAP_CHASE_SUBORDINATE_REFERRALS | LDAP_CHASE_EXTERNAL_REFERRALS));
    }
    GET_NEXT_MESSAGE_NUMBER( request->MessageId );
    Connection->publicLdapStruct.ld_msgid = request->MessageId;

    //
    //  put this record into the global list of requests
    //

    ACQUIRE_LOCK( &RequestListLock );

    IF_DEBUG(REQUEST) {
        LdapPrint2( "LDAP creating request at 0x%x, conn is 0x%x.\n",
                       request, Connection );
    }

    InsertTailList( &GlobalListRequests, &request->RequestListEntry );
    GlobalRequestCount++;

    RELEASE_LOCK( &RequestListLock );

    return request;
}


VOID
DereferenceLdapRequest2 (
    PLDAP_REQUEST Request
    )
//
//  This frees all resources for a given request.
//
{
    PLDAP_CONN connection;
    USHORT connCount;
    PREFERRAL_TABLE_ENTRY referral;
    CLdapBer *lber;

    ACQUIRE_LOCK( &RequestListLock );

    IF_DEBUG(REQUEST) {
        LdapPrint2( "LDAP deleting request at 0x%x, conn is 0x%x.\n",
                       Request, Request->PrimaryConnection );
    }

    ACQUIRE_LOCK( &Request->Lock );

    //
    //  we should've come in here by calling at some point CloseLdapRequest
    //

    ASSERT( Request->Closed == TRUE );
    ASSERT( Request->PrimaryConnection );
    ASSERT( Request->ReferenceCount == 0 );

    ClearPendingListForRequest( Request );

    if (Request->RequestListEntry.Flink != NULL) {

        RemoveEntryList( &Request->RequestListEntry );
        Request->RequestListEntry.Flink = NULL;
    }

    GlobalRequestCount--;

    RELEASE_LOCK( &Request->Lock );
    RELEASE_LOCK( &RequestListLock );

    lber = (CLdapBer *) InterlockedExchangePointer(  &Request->BerMessageSent,
                                                     NULL );
    if (lber != NULL) {

        delete lber;
    }

    if (Request->SecondaryConnection != NULL) {

        IF_DEBUG(CONTROLS) {
            LdapPrint1("Last refcnt for sec conn is %d\n", Request->SecondaryConnection->ReferenceCount);
        }

        ACQUIRE_LOCK( &Request->SecondaryConnection->StateLock );

        if ((Request->SecondaryConnection->HandlesGivenToCaller == 0 ) &&
            (Request->SecondaryConnection->HandlesGivenAsReferrals == 0)) {

            RELEASE_LOCK( &Request->SecondaryConnection->StateLock );
            CloseLdapConnection( Request->SecondaryConnection );
        }
        else {
            RELEASE_LOCK( &Request->SecondaryConnection->StateLock );
        }

        DereferenceLdapConnection( Request->SecondaryConnection );

//        IF_DEBUG(CONTROLS) {
//            LdapPrint1("Final refcnt for sec conn is %d\n", Request->SecondaryConnection->ReferenceCount);
//        }

        Request->SecondaryConnection = NULL;
    }

    referral = Request->ReferralConnections;
    if (referral != NULL) {

        for (connCount = 0;
             connCount < Request->ReferralTableSize;
             connCount++ ) {

            connection = referral->ReferralServer;

            if (connection != NULL) {

                DEREFERENCECONNECTION *dereferenceRoutine = connection->DereferenceNotifyRoutine;

                if (referral->CallDerefCallback &&
                    (dereferenceRoutine != NULL)) {

                    (*dereferenceRoutine)( Request->PrimaryConnection->ExternalInfo,
                                           connection->ExternalInfo );
                    referral->CallDerefCallback = FALSE;
                }

                ACQUIRE_LOCK( &connection->StateLock );

                ASSERT(connection->HandlesGivenAsReferrals > 0);
                connection->HandlesGivenAsReferrals--;

                if ((connection->HandlesGivenToCaller == 0 ) &&
                    (connection->HandlesGivenAsReferrals == 0)) {

                    RELEASE_LOCK( &connection->StateLock );
                    CloseLdapConnection( connection );

                } else {

                    RELEASE_LOCK( &connection->StateLock );
                }

                DereferenceLdapConnection( connection );
                referral->ReferralServer = NULL;
            }

            if (referral->ReferralDN != NULL) {

                ldapFree( referral->ReferralDN, LDAP_REFDN_SIGNATURE );
                referral->ReferralDN = NULL;
            }

            lber = (CLdapBer *) InterlockedExchangePointer(  &referral->BerMessageSent,
                                                             NULL );
            if (lber != NULL) {

                delete lber;
            }
            referral++;     // on to next entry
        }

        ldapFree( Request->ReferralConnections, LDAP_REFTABLE_SIGNATURE );
        Request->ReferralConnections = NULL;
    }

    //
    //  Free all messages remaining on this request
    //

    PLDAPMessage nextMessage;
    PLDAPMessage message;

    message = Request->MessageLinkedList;

    while (message != NULL) {

        nextMessage = message->lm_next;
        message->lm_next = NULL;

        ldap_msgfree( message );

        message = nextMessage;
    }

    DELETE_LOCK( &Request->Lock );

    //
    //  Free all saved parameters for this request
    //

    if (Request->AllocatedParms == TRUE) {

        if (Request->OriginalDN != NULL) {

            ldapFree( Request->OriginalDN, LDAP_UNICODE_SIGNATURE );
        }

        switch (Request->Operation) {
        case LDAP_ADD_CMD:

            LdapFreeLDAPModStructure( Request->add.AttributeList,
                                      Request->add.Unicode );
            break;

        case LDAP_COMPARE_CMD:

            if ( Request->compare.Attribute != NULL ) {
                ldapFree( Request->compare.Attribute, LDAP_UNICODE_SIGNATURE );
            }
            if ( Request->compare.Value != NULL ) {
                ldapFree( Request->compare.Value, LDAP_UNICODE_SIGNATURE );
            }
            if ( Request->compare.Data.bv_val != NULL ) {
                ldapFree( Request->compare.Data.bv_val, LDAP_COMPARE_DATA_SIGNATURE );
            }
            break;

        case LDAP_MODRDN_CMD:

            if (Request->rename.NewDistinguishedName != NULL) {
                ldapFree( Request->rename.NewDistinguishedName, LDAP_UNICODE_SIGNATURE );
            }
            if (Request->rename.NewParent != NULL) {
                ldapFree( Request->rename.NewParent, LDAP_UNICODE_SIGNATURE );
            }
            break;

        case LDAP_MODIFY_CMD:

            LdapFreeLDAPModStructure( Request->modify.AttributeList,
                                      Request->modify.Unicode );
            break;

        case LDAP_SEARCH_CMD:

            if ( Request->search.SearchFilter != NULL ) {
                ldapFree( Request->search.SearchFilter, LDAP_UNICODE_SIGNATURE );
            }

            if ( Request->search.AttributeList != NULL ) {

                PWCHAR *attr = Request->search.AttributeList;

                while (*attr != NULL) {

                    if (Request->search.Unicode) {

                        ldapFree( *attr, LDAP_UNICODE_SIGNATURE );

                    } else {

                        ldapFree( *attr, LDAP_ANSI_SIGNATURE );
                    }
                    attr++;
                }

                ldapFree( Request->search.AttributeList, LDAP_MOD_VALUE_SIGNATURE );
            }

            break;

        case LDAP_EXTENDED_CMD:

            ldapFree( Request->extended.Data.bv_val, LDAP_EXTENDED_OP_SIGNATURE );
            break;

        case LDAP_DELETE_CMD :      // none saved other than DN
        case LDAP_BIND_CMD :        // no saved parameters
            break;

        default:

            IF_DEBUG(REQUEST) {
                LdapPrint2( "LDAP unknown request type of 0x%x, conn is 0x%x.\n",
                            Request->Operation, Request->PrimaryConnection);
            }
        }
    }

    if (Request->AllocatedControls) {

        ldap_controls_freeW( Request->ServerControls );
        ldap_controls_freeW( Request->ClientControls );
    }

    if (Request->PagedSearchServerCookie != NULL) {

        ber_bvfree( Request->PagedSearchServerCookie );
    }

    //
    // Dereference the primary connection
    //

    DereferenceLdapConnection( Request->PrimaryConnection );
    Request->PrimaryConnection = NULL;

    //
    // Dereference the associated search block if one exists
    //

    if ( Request->PageRequest ) {
        DereferenceLdapRequest( Request->PageRequest );
        Request->PageRequest = NULL;
    }

    ldapFree( Request, LDAP_REQUEST_SIGNATURE );

    return;
}


VOID
CloseLdapRequest (
    PLDAP_REQUEST Request
    )
{
    ACQUIRE_LOCK( &Request->Lock );

    if (Request->Closed == FALSE) {

        Request->Closed = TRUE;

        IF_DEBUG(REQUEST) {
            LdapPrint1( "CloseLdapRequest closing request 0x%x.\n", Request );
        }

        RELEASE_LOCK( &Request->Lock );

        DereferenceLdapRequest( Request );

    } else {

        IF_DEBUG(REQUEST) {
            LdapPrint1( "CloseLdapRequest couldn't close request 0x%x.\n", Request );
        }
        RELEASE_LOCK( &Request->Lock );
    }

    return;
}

PLDAP_REQUEST
FindLdapRequest(
    LONG MessageId
    )
{
    PLDAP_REQUEST request = NULL;
    PLIST_ENTRY listEntry;

    if (MessageId != 0) {

        ACQUIRE_LOCK( &ConnectionListLock );
        ACQUIRE_LOCK( &RequestListLock );

        listEntry = GlobalListRequests.Flink;

        while ((listEntry != &GlobalListRequests) &&
               (request == NULL)) {

            request = CONTAINING_RECORD( listEntry, LDAP_REQUEST, RequestListEntry );
            request = ReferenceLdapRequest( request );

            listEntry = listEntry->Flink;
            
            if (!request) {
                continue;
            }
            
            if (( request->MessageId == MessageId) &&
                ( request->Abandoned == FALSE ) &&
                ( request->Closed == FALSE) ) {

                break;
            }

            DereferenceLdapRequest( request );
            request = NULL;
        }

        if (request == NULL) {

            IF_DEBUG(REQUEST) {
                LdapPrint1( "FindLdapRequest couldn't find request 0x%x.\n", MessageId );
            }
        }
        
        RELEASE_LOCK( &RequestListLock );
        RELEASE_LOCK( &ConnectionListLock );
    }
    return request;
}

//
// These routines implements tracking the number of outstanding requests we have
// per LDAP connection.  We do this so that we don't hang.... if we go into
// DrainWinsock without actually having any requests pending.
//

ULONG
AddToPendingList (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection
    )
//
//  Add a new element to the list if required.  If it already exists in the
//  list then just bump the request count.
//
//  The Request->Lock will be taken in here.
//
{
    ULONG result = LDAP_SUCCESS;

    ACQUIRE_LOCK( &Request->Lock );

    if (Connection == Request->PrimaryConnection) {

        InterlockedIncrement( &Connection->ResponsesExpected );
        Request->ResponsesOutstanding++;
        Request->RequestsPending++;
        InterlockedIncrement( &GlobalCountOfOpenRequests );

        IF_DEBUG(REQUEST) {
            LdapPrint2( "LdapAddToPendingList bumping outstanding to 0x%x for 0x%x.\n",
                         Request->ResponsesOutstanding, Request );
        }
    } else {

        PREFERRAL_TABLE_ENTRY refTable = Request->ReferralConnections;
        USHORT limit = Request->ReferralTableSize;
        USHORT i = 0;
        BOOLEAN found = FALSE;

        result = LDAP_LOCAL_ERROR;

        if (refTable != NULL) {

            while (i < limit) {

                if (refTable->ReferralServer == Connection) {

                    InterlockedIncrement( &GlobalCountOfOpenRequests );

                    InterlockedIncrement( &Connection->ResponsesExpected );
                    Request->ResponsesOutstanding++;
                    refTable->RequestsPending++;
                    found = TRUE;

                    IF_DEBUG(REQUEST) {
                        LdapPrint2( "LdapAddToPendingList bumping outstanding to 0x%x for 0x%x.\n",
                                     Request->ResponsesOutstanding, Request );
                    }
                    result = LDAP_SUCCESS;
                    break;
                }
                i++;
                refTable++;
            }
        }

        if ( found == FALSE ) {
            IF_DEBUG(REQUEST) {
                LdapPrint1( "LdapAddToPendingList couldn't bump for request 0x%x.\n", Request );
            }
        }
    }

    RELEASE_LOCK( &Request->Lock );

    return result;
}

VOID
DecrementPendingList (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection
    )
//
//  The Request->Lock will be taken in here.
//
{
    CLdapBer *lber;

    ACQUIRE_LOCK( &Request->Lock );
    
    if ((Connection == Request->PrimaryConnection) &&
        (Request->RequestsPending > 0)) {

        InterlockedDecrement( &Connection->ResponsesExpected );
        Request->ResponsesOutstanding--;
        Request->RequestsPending--;
        InterlockedDecrement( &GlobalCountOfOpenRequests );

        lber = (CLdapBer *) InterlockedExchangePointer(  &Request->BerMessageSent,
                                                         NULL );
        if (lber != NULL) {
            delete lber;
        }

        IF_DEBUG(REQUEST) {
            LdapPrint2( "LdapDecrementPendingList bumping outstanding to 0x%x for 0x%x.\n",
                         Request->ResponsesOutstanding, Request );
        }

    } else {

        PREFERRAL_TABLE_ENTRY refTable = Request->ReferralConnections;
        BOOLEAN found = FALSE;

        if (refTable != NULL) {

            USHORT limit = Request->ReferralTableSize;
            USHORT i = 0;

            while (i < limit) {

                if ((refTable->ReferralServer == Connection) &&
                    (refTable->RequestsPending > 0)) {

                    InterlockedDecrement( &Connection->ResponsesExpected );
                    InterlockedDecrement( &GlobalCountOfOpenRequests );
                    Request->ResponsesOutstanding--;
                    refTable->RequestsPending--;
                    found = TRUE;

                    lber = (CLdapBer *) InterlockedExchangePointer(  &refTable->BerMessageSent,
                                                                     NULL );
                    if (lber != NULL) {
                        delete lber;
                    }

//                  IF_DEBUG(REQUEST) {
                    IF_DEBUG(SCRATCH) {
                        LdapPrint2( "LdapDecrementPendingList bumping outstanding to 0x%x for 0x%x.\n",
                                     Request->ResponsesOutstanding, Request );
                    }
                    break;
                }
                i++;
                refTable++;
            }
        }
        if ( found == FALSE ) {
//          IF_DEBUG(REQUEST) {
            IF_DEBUG(SCRATCH) {
                LdapPrint1( "LdapDecrementPendingList couldn't bump for request 0x%x.\n", Request );
            }
        }
    }

    RELEASE_LOCK( &Request->Lock );
    
    return;
}

VOID
ClearPendingListForRequest (
    PLDAP_REQUEST Request
    )
//
//  The Request->Lock must be held coming in here.
//
{
    ULONG i = Request->RequestsPending;
    PLDAP_CONN conn = Request->PrimaryConnection;

    //
    //  yes, I know this is slow, but the only protection we have for
    //  GlobalCountOfOpenRequests is interlockedIncrement/Decrement.
    //

    while ( i-- > 0) {

        InterlockedDecrement( &GlobalCountOfOpenRequests );

        if (conn != NULL) {
            InterlockedDecrement( &conn->ResponsesExpected );
        }
    }

    Request->RequestsPending = 0;
    Request->ResponsesOutstanding = 0;

    IF_DEBUG(REQUEST) {
        LdapPrint1( "LdapClearPendingList cleared request 0x%x.\n", Request );
    }

    PREFERRAL_TABLE_ENTRY refTable = Request->ReferralConnections;

    if (refTable != NULL) {

        USHORT limit = Request->ReferralTableSize;
        USHORT referralCount = 0;

        while (referralCount < limit) {

            i = refTable->RequestsPending;

            conn = refTable->ReferralServer;

            while ( i-- > 0) {

                InterlockedDecrement( &GlobalCountOfOpenRequests );

                if (conn != NULL) {
                    InterlockedDecrement( &conn->ResponsesExpected );
                }
            }
            refTable->RequestsPending = 0;

            referralCount++;
            refTable++;
        }
    }

    return;
}

VOID
ClearPendingListForConnection (
    PLDAP_CONN Connection
    )
//
//  The RequestListLock and Request->Lock will be taken in here.
//
//  Go through all requests and for each one, check to see if this connection
//  is included... if so, decrement the number of outstanding requests by the
//  number of pending requests.
//
{
    PLDAP_REQUEST request;
    PLIST_ENTRY listEntry;
    ULONG i;
    PMESSAGE_ID_LIST_ENTRY messageIdsToFree = NULL;
    PMESSAGE_ID_LIST_ENTRY currentNode = NULL;

    ACQUIRE_LOCK( &RequestListLock );

    IF_DEBUG(REQUEST) {
        LdapPrint1( "LdapClearPendingList cleared for conn 0x%x.\n", Connection );
    }

    listEntry = GlobalListRequests.Flink;

    while (listEntry != &GlobalListRequests) {

        //
        //  we may have to add an entry at the end of the request's message
        //  list since this connection went down.  We do this when this
        //  connection was the last connection we were waiting for and we
        //  have no more search entries to mark as end-of-message.
        //

        BOOLEAN markEom = FALSE;

        request = CONTAINING_RECORD( listEntry, LDAP_REQUEST, RequestListEntry );
        
        request = ReferenceLdapRequest(request);
        listEntry = listEntry->Flink;

        if ( !request ) {
            continue;
        }

        ACQUIRE_LOCK( &request->Lock );

        if (Connection == request->PrimaryConnection) {

            i = request->RequestsPending;

            //
            //  yes, I know this is slow, but the only protection we have for
            //  GlobalCountOfOpenRequests is interlockedIncrement/Decrement.
            //

            while ( i-- > 0) {
                InterlockedDecrement( &GlobalCountOfOpenRequests );
            }

            request->ResponsesOutstanding -= LOWORD( request->RequestsPending );
            request->RequestsPending = 0;

            if (request->ResponsesOutstanding == 0) {

                markEom = TRUE;
            }
        }

        //
        //  now we go through the referral table for this request...
        //

        PREFERRAL_TABLE_ENTRY refTable = request->ReferralConnections;

        if (refTable != NULL) {

            USHORT limit = request->ReferralTableSize;
            USHORT referralCount = 0;

            while (referralCount < limit) {

                if (refTable->ReferralServer == Connection) {

                    i = refTable->RequestsPending;

                    while ( i-- > 0) {
                        InterlockedDecrement( &GlobalCountOfOpenRequests );
                    }

                    request->ResponsesOutstanding -= LOWORD( refTable->RequestsPending );

                    if (request->ResponsesOutstanding == 0) {

                        markEom = TRUE;
                    }
                    refTable->RequestsPending = 0;
                }
                referralCount++;
                refTable++;
            }
        }

        if (markEom) {

            ULONG err = SimulateErrorMessage( Connection,
                                              request,
                                              LDAP_SERVER_DOWN
                                              );

            IF_DEBUG(SERVERDOWN) {
                LdapPrint2( "ldapClearPending thread 0x%x has connection 0x%x simulated as down\n",
                                GetCurrentThreadId(),
                                Connection );
            }
            if (err != LDAP_SUCCESS) {

                request->Abandoned = TRUE;
            }
            currentNode = (PMESSAGE_ID_LIST_ENTRY) ldapMalloc( sizeof( MESSAGE_ID_LIST_ENTRY ),
                                                           LDAP_MSGID_SIGNATURE );

            if (currentNode != NULL) {

                currentNode->Next = messageIdsToFree;
                currentNode->MessageId = request->MessageId;
                messageIdsToFree = currentNode;
            }

        }
        RELEASE_LOCK( &request->Lock );
        DereferenceLdapRequest( request );
    }

    //
    //  since we cleared out all requests for this conn, zero out the number
    //  of responses we're expecting.
    //

    Connection->ResponsesExpected = 0;

    RELEASE_LOCK( &RequestListLock );

    //
    //  Now we go through and wake up any threads that are waiting for these
    //  requests.
    //

    if (messageIdsToFree != NULL) {

        ACQUIRE_LOCK( &ConnectionListLock );

        while (messageIdsToFree != NULL) {

            currentNode = messageIdsToFree;
            messageIdsToFree = messageIdsToFree->Next;

            CheckForWaiters( currentNode->MessageId, FALSE, Connection );
            ldapFree( currentNode, LDAP_MSGID_SIGNATURE );
        }

        RELEASE_LOCK( &ConnectionListLock );

        LdapWakeupSelect();
    }

    return;
}

ULONG
SimulateErrorMessage (
    PLDAP_CONN Connection,
    PLDAP_REQUEST Request,
    ULONG Error
    )
{
    //
    //  we mark the last message received as EndOfMessage.  If there
    //  isn't one, we make up our own.
    //

    PLDAPMessage lastEntry = Request->MessageLinkedList;
    PLDAPMessage newEntry = NULL;

    if (lastEntry != NULL) {

        while (lastEntry->lm_chain != NULL) {
            lastEntry = lastEntry->lm_chain;
        }
    }

    if ((lastEntry == NULL) ||
        (lastEntry->lm_msgtype == LDAP_RES_SEARCH_ENTRY) ||
        (lastEntry->lm_msgtype == LDAP_RES_REFERRAL)) {

        newEntry = (PLDAPMessage) ldapMalloc( sizeof(LDAPMessage),
                                               LDAP_MESG_SIGNATURE );

        if (newEntry == NULL) {

            return LDAP_NO_MEMORY;
        }

        newEntry->Connection = Connection->ExternalInfo;
        newEntry->Request = Request;
        newEntry->lm_returncode = Error;
        newEntry->lm_time = GetTickCount();
        newEntry->lm_msgid = Request->MessageId;

        if (Request->Operation == LDAP_SEARCH_CMD) {

            newEntry->lm_msgtype = LDAP_RES_SEARCH_RESULT;

        } else if (Request->Operation == LDAP_BIND_CMD) {

            newEntry->lm_msgtype = LDAP_RES_BIND;

        } else if (Request->Operation == LDAP_MODIFY_CMD) {

            newEntry->lm_msgtype = LDAP_RES_MODIFY;

        } else if (Request->Operation == LDAP_ADD_CMD) {

            newEntry->lm_msgtype = LDAP_RES_ADD;

        } else if (Request->Operation == LDAP_DELETE_CMD) {

            newEntry->lm_msgtype = LDAP_RES_DELETE;

        } else if (Request->Operation == LDAP_MODRDN_CMD) {

            newEntry->lm_msgtype = LDAP_RES_MODRDN;

        } else if (Request->Operation == LDAP_COMPARE_CMD) {

            newEntry->lm_msgtype = LDAP_RES_COMPARE;

        } else if (Request->Operation == LDAP_EXTENDED_CMD) {

            newEntry->lm_msgtype = LDAP_RES_EXTENDED;

        } else {

            ASSERT( Request->Operation == LDAP_SEARCH_CMD );
            newEntry->lm_msgtype = LDAP_RES_SEARCH_RESULT;
        }

        if (lastEntry == NULL) {

            Request->MessageLinkedList = newEntry;

        } else {

            lastEntry->lm_chain = newEntry;
        }
        lastEntry = newEntry;
    }

    IF_DEBUG(EOM) {
         LdapPrint2( "LdapClearConn faking eom for request 0x%x, msg 0x%x\n",
                     Request, lastEntry );
    }
    lastEntry->lm_eom = TRUE;

    return LDAP_SUCCESS;
}

// request.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\results.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    results.cxx parse out results from LDAP servers

Abstract:

   This module implements the APIs to break apart LDAP results

Author:

    Andy Herron (andyhe)        02-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

PWCHAR * __cdecl
ldap_get_valuesW (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    PWCHAR           Attribute
    )
//
//  This routine gets the attribute value for a given attribute.
//
{
    PWCHAR *Output = NULL;
    ULONG hr;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    hr = LdapGetValues( connection,
                        Message,
                        Attribute,
                        FALSE,
                        TRUE,       // return in Unicode
                        (PVOID *) &Output
                        );

    if (hr != NOERROR) {
        IF_DEBUG(PARSE) {
            LdapPrint1( "ldap_get_values had decoding error of 0x0x%x .\n", hr);
        }
    }

    DereferenceLdapConnection( connection );

    return(Output);
}

PCHAR * __cdecl
ldap_get_values (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    PCHAR           Attribute
    )
//
//  This routine gets the attribute value for a given attribute.
//
{
    PCHAR *Output = NULL;
    ULONG hr = NOERROR;
    ULONG err;
    PWCHAR attr = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    err = ToUnicodeWithAlloc( Attribute, -1, &attr, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    hr = LdapGetValues( connection,
                        Message,
                        attr,
                        FALSE,
                        FALSE,
                        (PVOID *) &Output
                        );

error:
    if (attr)
        ldapFree( attr, LDAP_UNICODE_SIGNATURE );

    if (hr != NOERROR) {
        IF_DEBUG(PARSE) {
            LdapPrint1( "ldap_get_values had decoding error of 0x0x%x .\n", hr);
        }
    }

    DereferenceLdapConnection( connection );

    return(Output);
}

PCHAR * __cdecl
ldap_get_valuesA (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    PCHAR           Attribute
    )
{
    return ldap_get_values( ExternalHandle, Message, Attribute );
}


struct berval **__cdecl
ldap_get_values_lenW (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    PWCHAR          Attribute
    )
//
//  This routine gets the attribute value for a given attribute.  It returns
//  it as a berval structure rather than a string.
//
{
    struct berval **Output = NULL;
    ULONG hr;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    hr = LdapGetValues( connection,
                        Message,
                        Attribute,
                        TRUE,
                        TRUE,              // in unicode form
                        (PVOID *) &Output
                        );

    if (hr != NOERROR) {
        IF_DEBUG(PARSE) {
            LdapPrint1( "ldap_get_values_len had decoding error of 0x0x%x .\n", hr);
        }
    }

    DereferenceLdapConnection( connection );

    return(Output);
}

struct berval **__cdecl
ldap_get_values_len (
    LDAP            *ExternalHandle,
    LDAPMessage     *Message,
    PCHAR           Attribute
    )
//
//  This routine gets the attribute value for a given attribute.  It returns
//  it as a berval structure rather than a string.
//
{
    struct berval **Output = NULL;
    ULONG hr = NOERROR;
    ULONG err;
    PWCHAR attr = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return NULL;
    }

    err = ToUnicodeWithAlloc( Attribute, -1, &attr, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    hr = LdapGetValues( connection,
                        Message,
                        attr,
                        TRUE,
                        FALSE,              // not in unicode form
                        (PVOID *) &Output
                        );

error:
    if (attr)
        ldapFree( attr, LDAP_UNICODE_SIGNATURE );

    if (hr != NOERROR) {
        IF_DEBUG(PARSE) {
            LdapPrint1( "ldap_get_values_len had decoding error of 0x0x%x .\n", hr);
        }
    }

    DereferenceLdapConnection( connection );

    return(Output);
}

ULONG
LdapGetValues (
    PLDAP_CONN      connection,
    LDAPMessage     *Message,
    PWCHAR          attr,
    BOOLEAN         BerVal,     // do we put value out raw in buffer
    BOOLEAN         Unicode,    // do we leave value as unicode or convert to single
    PVOID           *Output
    )
//
//  This routine gets the attribute value for a given attribute.  It returns
//  it as a berval structure rather than a string.
//
{
    CLdapBer *lber = NULL;
    CLdapBer *newLber = NULL;
    ULONG hr;
    PLDAP_ATTR_NAME_THREAD_STORAGE threadAttr;
    DWORD currentThread;
    ULONG tag;
    BOOLEAN startAgain = TRUE;      // do we have to reparse message?
    struct berval **resultBer = NULL;
    WCHAR attributeType[MAX_ATTRIBUTE_NAME_LENGTH];
    BOOLEAN notFound = TRUE;
    ULONG resultCount = 0;      // current offset in table
    ULONG sizeResultTable = 2;  // current size of result table
    PWCHAR *resultWStr = NULL;
    PCHAR *resultStr = NULL;
    PVOID outputArray = NULL;

    PLIST_ENTRY pThreadListEntry = NULL;
    PTHREAD_ENTRY pThreadEntry = NULL;
    BOOLEAN fRetriedFindThread = FALSE;

    *Output = NULL;

    if (Message == NULL) {

        return LDAP_PARAM_ERROR;
    }

    if (Message->lm_msgtype != LDAP_RES_SEARCH_ENTRY) {

        SetConnectionError( connection, LDAP_DECODING_ERROR, NULL );
        return LDAP_DECODING_ERROR;
    }

    currentThread = GetCurrentThreadId();

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    lber = (CLdapBer *) Message->lm_ber;

    //
    //  depending on what the last call was, we're either at the start of a
    //  sequence for the next attribute or the start of a set of attribute
    //  values for the current attribute.  We'll peak at the tag and if
    //  we're at a set, we'll check the current attribute to see if we
    //  can just use these values.
    //

    hr = lber->HrPeekTag( &tag );

    if ((hr != LDAP_NO_SUCH_ATTRIBUTE) &&
        (tag == BER_SET)) {

        //
        // Find the buffer that stored the attribute name off of this connection
        // to check the attribute name of the current location.
        // This requires first finding the THREAD_ENTRY for this thread,
        // then the attribute entry for this connection off of that thread entry.
        //
retryFindThread:

        ACQUIRE_LOCK( &PerThreadListLock );

        pThreadListEntry = GlobalPerThreadList.Flink;

        // find the THREAD_ENTRY for this thread
        while (pThreadListEntry != &GlobalPerThreadList) {

            pThreadEntry = CONTAINING_RECORD( pThreadListEntry, THREAD_ENTRY, ThreadEntry );
            pThreadListEntry = pThreadListEntry->Flink;

            if (pThreadEntry->dwThreadID == currentThread) {
                break;
            }

            pThreadEntry = NULL;
        }


        if (!pThreadEntry && !fRetriedFindThread) {
            // this thread must have been created before this DLL was loaded-
            // create a per-thread entry for it now
            RELEASE_LOCK( &PerThreadListLock );
            IF_DEBUG(PARSE) {
                LdapPrint2( "LdapGetValues could not find ThreadEntry for conn 0x%x, thread 0x%x.  Creating one.\n",
                                connection, currentThread );
            }

            if (!AddPerThreadEntry(currentThread)) {
                IF_DEBUG(PARSE) {
                    LdapPrint2( "LdapGetValues AddPerThreadEntry failed, conn 0x%x, thread 0x%x.\n",
                                    connection, currentThread );
                }
                SetConnectionError( connection, LDAP_NO_MEMORY, NULL );
                return LDAP_NO_MEMORY;
            }

            fRetriedFindThread = TRUE;
            goto retryFindThread;
        }
        else if (!pThreadEntry) {
            // shouldn't happen --- somehow a thread entry wasn't created
            RELEASE_LOCK( &PerThreadListLock );
            IF_DEBUG(PARSE) {
                LdapPrint2( "LdapGetValues no per-thread entry, conn 0x%x, thread 0x%x.\n",
                                connection, currentThread );
            }            
            ASSERT(pThreadEntry);
            SetConnectionError( connection, LDAP_LOCAL_ERROR, NULL );
            return LDAP_LOCAL_ERROR;
        }


        // find the attribute entry for this connection
        threadAttr = pThreadEntry->pCurrentAttrList;

        while (threadAttr != NULL) {

            if (threadAttr->PrimaryConn == connection) {
                ASSERT(threadAttr->Thread == currentThread);
                break;
            }
            
            threadAttr = threadAttr->pNext;
        }

        RELEASE_LOCK( &PerThreadListLock );
        
        if (threadAttr != NULL) {

            if (ldapWStringsIdentical(  &(threadAttr->AttributeNameW[0]),
                                        -1,
                                        attr,
                                        -1) == TRUE) {

                startAgain = FALSE;
            }
        }
        
    }

    if (startAgain) {

        //
        //  Create a temp copy of the lber message and look for the attribute
        //  in the message
        //

        newLber = new CLdapBer( connection->publicLdapStruct.ld_version );

        if (newLber == NULL) {
            IF_DEBUG(OUTMEMORY) {
                LdapPrint1( "LdapGetValues conn 0x%x could not allocate message.\n",
                                connection);
            }
            hr = LDAP_NO_MEMORY;
            goto exitGetValues;
        }

        hr = newLber->CopyExistingBERStructure( lber );
        if (hr != NOERROR) {
            IF_DEBUG(OUTMEMORY) {
                LdapPrint2( "LdapGetValues conn 0x%x could not create message, 0x0x%x .\n",
                                connection, hr);
            }
            SetConnectionError( connection, LDAP_NO_MEMORY, NULL );
            goto exitGetValues;
        }

        lber = newLber;

        hr = LdapGoToFirstAttribute( connection, lber );
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "LdapGetValues 1 conn 0x%x received protocol error 0x%x .\n",
                                connection, hr);
            }

protocolError:
            SetConnectionError( connection, LDAP_DECODING_ERROR, NULL );
            goto exitGetValues;
        }

        while (notFound && (hr == NOERROR)) {

            hr = lber->HrStartReadSequence();

            if (hr != NOERROR) {
                IF_DEBUG(PARSE) {
                    LdapPrint2( "LdapGetValues 8 conn 0x%x received protocol error 0x%x .\n",
                                    connection, hr);
                }
                continue;
            }

            hr = lber->HrGetValue(  (WCHAR *) &(attributeType[0]),
                                    MAX_ATTRIBUTE_NAME_LENGTH - 1,
                                    BER_OCTETSTRING );

            if (hr == NOERROR) {

                if (ldapWStringsIdentical(  &(attributeType[0]),
                                            -1,
                                            attr,
                                            -1) == TRUE) {

                    notFound = FALSE;
                    continue;
                }

                //
                //  not this attribute, skip the value for it.  Note that if
                //  we get a protocol error here, we bail since it really is
                //  an error and not the end of data.
                //

                hr = lber->HrEndReadSequence(); // skip the attribute value

                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapGetValues 2 conn 0x%x received protocol error 0x%x .\n",
                                        connection, hr);
                    }
                    goto protocolError;
                }
            }
        }

        if ((hr != NOERROR) || notFound) {

            //
            //  we didn't find the attribute
            //

            IF_DEBUG(PARSE) {
                LdapPrint2( "LdapGetValues conn 0x%x did not find attribute %s\n",
                                connection, attr );
            }
            SetConnectionError( connection, hr, NULL );
            goto exitGetValues;
        }
    }

    //
    //  Read the set of values from the lber buffer one at a time.  We store
    //  them in a list of PVOID pointers.
    //

    hr = lber->HrStartReadSequence(BER_SET);
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "LdapGetValues 2 conn 0x%x received protocol error 0x%x .\n",
                            connection, hr);
        }
        goto protocolError;
    }

    if (BerVal) {

        //
        //  get the list of attribute values in BER_VAL structures
        //

        while (hr == NOERROR) {

            struct berval *attrValue;

            if ((resultBer == NULL) ||
                (resultCount >= (sizeResultTable-1))) {      // leave room for null

                if (sizeResultTable < 256) {    // only increase table size slowly
                    sizeResultTable *= 2;
                } else {
                    sizeResultTable += 256;
                }

                struct berval **newResultTable = (struct berval **)
                                ldapMalloc( sizeof(struct berval *) * sizeResultTable,
                                            LDAP_VALUE_LIST_SIGNATURE );

                if (newResultTable == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint2( "LdapGetValues 3 conn 0x%x could not allocate mem of 0x%x .\n",
                                        connection, sizeof(PCHAR) * sizeResultTable);
                    }
                    hr = LDAP_NO_MEMORY;

                    if (resultBer) {
                        // so we free it on exit
                        *(resultBer+resultCount) = NULL;
                        outputArray = resultBer;
                    }
                    
                    goto exitGetValues;
                }

                if (resultBer != NULL) {

                    CopyMemory( newResultTable,
                                resultBer,
                                sizeof(struct berval *) * resultCount );
                    ldapFree( resultBer, LDAP_VALUE_LIST_SIGNATURE );
                }
                resultBer = newResultTable;
            }

            hr = lber->HrGetValueWithAlloc( &attrValue );
            if (hr != NOERROR) {

                if (hr == LDAP_NO_MEMORY) {

                    // so we free it on exit
                    *(resultBer+resultCount) = NULL;
                    outputArray = resultBer;
                
                    goto exitGetValues;
                }
                
                //
                //  This will fail when we hit the end of the attribute list
                //

                IF_DEBUG(TRACE1) {
                    LdapPrint2( "LdapGetValues 4 conn 0x%x received error 0x%x .\n",
                                    connection, hr);
                }

                continue;       // rest of results may be valid
            }

            *(resultBer+resultCount) = attrValue;
            resultCount++;
        }

        outputArray = resultBer;

    } else if (Unicode) {

        //
        //  get the list of attribute values in form of unicode strings
        //

        while (hr == NOERROR) {

            PWCHAR attrWValue = NULL;

            if ((resultWStr == NULL) ||
                (resultCount >= (sizeResultTable-1))) {      // leave room for null

                if (sizeResultTable < 256) {    // only increase table size slowly
                    sizeResultTable *= 2;
                } else {
                    sizeResultTable += 256;
                }

                PWCHAR *newResultTable = (PWCHAR *) ldapMalloc( sizeof(PWCHAR) * sizeResultTable,
                                                    LDAP_VALUE_LIST_SIGNATURE );

                if (newResultTable == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint2( "LdapGetValues 3 conn 0x%x could not allocate mem of 0x%x .\n",
                                        connection, sizeof(PWCHAR) * sizeResultTable);
                    }
                    hr = LDAP_NO_MEMORY;

                    if (resultWStr) {
                        // so we free it on exit
                        *(resultWStr+resultCount) = NULL;
                        outputArray = resultWStr;
                    }
                    
                    goto exitGetValues;
                }

                if (resultWStr != NULL) {

                    CopyMemory( newResultTable, resultWStr, sizeof(PWCHAR) * resultCount );
                    ldapFree( resultWStr, LDAP_VALUE_LIST_SIGNATURE );
                }
                resultWStr = newResultTable;
            }

            hr = lber->HrGetValueWithAlloc( &attrWValue );
            if (hr != NOERROR) {

                if (hr == LDAP_NO_MEMORY) {

                    // so we free it on exit
                    *(resultWStr+resultCount) = NULL;
                    outputArray = resultWStr;
                
                    goto exitGetValues;
                }
                
                //
                //  This will fail when we hit the end of the attribute list
                //

                IF_DEBUG(TRACE1) {
                    LdapPrint2( "LdapGetValues 4 conn 0x%x received error 0x%x .\n",
                                    connection, hr);
                }
                continue;       // rest of results may be valid
            }

            *(resultWStr+resultCount) = attrWValue;
            resultCount++;
        }

        outputArray = resultWStr;

    } else {

        //
        //  get the list of attribute values in form of single byte strings
        //

        while (hr == NOERROR) {

            PCHAR attrValue = NULL;

            if ((resultStr == NULL) ||
                (resultCount >= (sizeResultTable-1))) {      // leave room for null

                if (sizeResultTable < 256) {    // only increase table size slowly
                    sizeResultTable *= 2;
                } else {
                    sizeResultTable += 256;
                }

                PCHAR *newResultTable = (PCHAR *) ldapMalloc( sizeof(PCHAR) * sizeResultTable,
                                                    LDAP_VALUE_LIST_SIGNATURE );

                if (newResultTable == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint2( "LdapGetValues 3 conn 0x%x could not allocate mem of 0x%x .\n",
                                        connection, sizeof(PCHAR) * sizeResultTable);
                    }
                    hr = LDAP_NO_MEMORY;

                    if (resultStr) {
                        *(resultStr+resultCount) = NULL;
                        outputArray = resultStr;
                    }
                    
                    goto exitGetValues;
                }

                if (resultStr != NULL) {

                    CopyMemory( newResultTable, resultStr, sizeof(PCHAR) * resultCount );
                    ldapFree( resultStr, LDAP_VALUE_LIST_SIGNATURE );
                }
                resultStr = newResultTable;
            }

            hr = lber->HrGetValueWithAlloc( &attrValue );
            if (hr != NOERROR) {

                if (hr == LDAP_NO_MEMORY) {

                    *(resultStr+resultCount) = NULL;
                    outputArray = resultStr;
                
                    goto exitGetValues;
                }
                
                //
                //  This will fail when we hit the end of the attribute list
                //

                IF_DEBUG(TRACE1) {
                    LdapPrint2( "LdapGetValues 4 conn 0x%x received error 0x%x .\n",
                                    connection, hr);
                }
                continue;       // rest of results may be valid
            }

            *(resultStr+resultCount) = attrValue;
            resultCount++;
        }

        outputArray = resultStr;
    }

    if (outputArray != NULL) {

        *(((PCHAR *) outputArray)+resultCount) = NULL;
    }

    hr = lber->HrEndReadSequence(); // for set of values
    ASSERT( hr == NOERROR );

exitGetValues:

    if (newLber != NULL) {
        delete newLber;
    }

    if (hr == LDAP_NO_MEMORY) {
        
        //
        // Cleanup any partial allocations.
        //
        
        ldap_value_free( (PCHAR*) outputArray );
        outputArray = NULL;
    }
    
    SetConnectionError( connection, hr, NULL );
    
    *Output = outputArray;
    return hr;
}



ULONG __cdecl
ldap_count_values (
    PCHAR *vals
    )
//
//  Count the number of values returned in a list of attribute value strings
//
{
    ULONG count;

    if (vals == NULL) {
        return 0;
    }

    for (count = 0; vals[count] != NULL; count++ );

    return count;
}

ULONG __cdecl
ldap_count_valuesW (
    PWCHAR *vals
    )
{
    return ldap_count_values((PCHAR *) vals);
}


ULONG __cdecl
ldap_value_free (
    PCHAR *vals
    )
//
//  Free a list of values returned in a list of attribute value strings
//
{
    ULONG count;

    if (vals == NULL) {
        return LDAP_SUCCESS;
    }

    for (count = 0; vals[count] != NULL; count++ ) {

        ldapFree( vals[count], LDAP_VALUE_SIGNATURE );
        vals[count] = NULL;     // aid debugging
    }
    ldapFree( vals, LDAP_VALUE_LIST_SIGNATURE );

    return LDAP_SUCCESS;
}

ULONG __cdecl
ldap_value_freeW (
    PWCHAR *vals
    )
{
    return ldap_value_free( (PCHAR *) vals );
}


ULONG __cdecl
ldap_count_values_len (
    struct berval **vals
    )
{
    return( ldap_count_values( (PCHAR *) vals ));
}

ULONG __cdecl
ldap_value_free_len (
    struct berval **vals
    )
{
    return( ldap_value_free( (PCHAR *) vals ));
}

PWCHAR __cdecl
ldap_get_dnW (
    LDAP *ExternalHandle,
    LDAPMessage *LdapMsg
    )
//
//  The offset of the DN within the LBER message is saved in the LDAPMessage
//  structure.  We allocate a buffer and copy the DN in.
//
{
    PLDAP_CONN connection = NULL;
    ULONG hr;
    PWCHAR  result = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (LdapMsg == NULL) {

        SetConnectionError( connection, LDAP_PARAM_ERROR, NULL );
        return(NULL);
    }

    if (connection == NULL) {
        return NULL;
    }

    CLdapBer *lber = (CLdapBer *) LdapMsg->lm_ber;

    hr = lber->HrGetDN((PWCHAR *) &result);

    SetConnectionError( connection, hr, NULL );

    if (connection)
        DereferenceLdapConnection( connection );

    return result;
}

PCHAR __cdecl
ldap_get_dn (
    LDAP *ExternalHandle,
    LDAPMessage *LdapMsg
    )
{
    PWCHAR wName;
    PCHAR dn = NULL;

    wName = ldap_get_dnW( ExternalHandle, LdapMsg );

    FromUnicodeWithAlloc( wName, &dn, LDAP_BUFFER_SIGNATURE, LANG_ACP );
    ldapFree( wName, LDAP_BUFFER_SIGNATURE );

    return dn;
}

// results.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\search.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    search.cxx handle search requests to an LDAP server

Abstract:

   This module implements the LDAP search APIs.

Author:

    Andy Herron (andyhe)        02-Jul-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG
LdapSearch (
        PLDAP_CONN connection,
        PWCHAR  DistinguishedName,
        ULONG   ScopeOfSearch,
        PWCHAR  SearchFilter,
        PWCHAR  AttributeList[],
        ULONG   AttributesOnly,
        BOOLEAN Unicode,
        BOOLEAN Synchronous,
        PLDAPControlW *ServerControls,
        PLDAPControlW *ClientControls,
        ULONG   TimeLimit,
        ULONG   SizeLimit,
        ULONG  *MessageNumber
    )
//
//  Here's where we get to the meat of this protocol.  This is the main client
//  API for performing an LDAP search.  Parameters are rather self explanatory,
//  see the LDAP RFC for detailed descriptions.
//
{
    ULONG err;
    ULONG messageNumber;
    PLDAP_REQUEST request = NULL;

    *MessageNumber = (ULONG) -1;


    err = LdapConnect( connection, NULL, FALSE );

    if (err != 0) {

       return err;
    }

    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    request = LdapCreateRequest( connection, LDAP_SEARCH_CMD );

    if (request == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap_search connection 0x%x couldn't allocate request.\n", connection);
        }
        err = LDAP_NO_MEMORY;
        SetConnectionError( connection, err, NULL );
        return err;
    }

    if (SearchFilter == NULL) {

       //
       // According to the LDAP spec, if the user comes in with a NULL filter,
       // we should convert it to (ObjectClass=*)
       //

       SearchFilter = L"ObjectClass=*";
    }

    messageNumber = request->MessageId;

    request->Synchronous = Synchronous;
    request->search.Unicode = Unicode;
    request->search.ScopeOfSearch = ScopeOfSearch;
    request->search.AttributesOnly = AttributesOnly;
    request->TimeLimit = TimeLimit;
    request->SizeLimit = SizeLimit;

    err = LDAP_SUCCESS;

    if ((ServerControls != NULL) || (ClientControls != NULL)) {

        err = LdapCheckControls( request,
                                 ServerControls,
                                 ClientControls,
                                 Unicode,
                                 0 );

        if (err != LDAP_SUCCESS) {

            IF_DEBUG(CONTROLS) {
                LdapPrint2( "ldap_search connection 0x%x trouble with SControl, err 0x%x.\n",
                            connection, err );
            }
        }
    }

    if (err == LDAP_SUCCESS) {

        if (Synchronous || (request->ChaseReferrals == 0)) {

            request->AllocatedParms = FALSE;
            request->OriginalDN = DistinguishedName;
            request->search.SearchFilter = SearchFilter;
            request->search.AttributeList = AttributeList;

        } else {

            err = LdapSaveSearchParameters( request,
                                            DistinguishedName,
                                            SearchFilter,
                                            AttributeList,
                                            Unicode );
        }
    }

    if (err == LDAP_SUCCESS) {

        if ( DSLOG_ACTIVE ) {

            START_LOGGING;
            DSLOG((DSLOG_FLAG_TAG_CNPN,
                   "[+][ID=%d][OP=ldap_search][ST=%I64d][DN=%ws][LV=%s]",
                   request->MessageId, request->RequestTime,
                   DistinguishedName,
                   (ScopeOfSearch == LDAP_SCOPE_BASE) ? "Base" :
                    (ScopeOfSearch == LDAP_SCOPE_ONELEVEL) ? "OneLevel" : "Subtree"
                ));

            if ( AttributesOnly ) {
                DSLOG((DSLOG_FLAG_NOTIME,"[FL=ATTONLY]"));
            }

            if ( request->ChaseReferrals ) {
                DSLOG((DSLOG_FLAG_NOTIME,"[FL=CHASEREF]"));
            }

            LogAttributesAndControls(AttributeList, NULL, ServerControls,Unicode);
            DSLOG((DSLOG_FLAG_NOTIME,"[FI=%ws][-]\n", SearchFilter));
            END_LOGGING;
        }

        //
        // We access the cache if this is a RootDSE search. We should also
        // mark the request as "cacheable" so that we know to save the search
        // results in our cache. Note that if there are controls associated
        // with the RootDSE search, we do not cache it.
        //

        if (!DisableRootDSECache &&
            ((request->OriginalDN == NULL) ||
            (*(request->OriginalDN) == L'\0')) &&
            (ServerControls == NULL) &&
            (ClientControls == NULL) &&
            (request->search.AttributeList != NULL) &&
            (request->search.ScopeOfSearch == LDAP_SCOPE_BASE) &&
            (connection->CurrentSignStatus == FALSE) &&
            (connection->CurrentSealStatus == FALSE) &&
            (connection->SecureStream == NULL) &&
            (connection->DnsSuppliedName != NULL)) {

            err = AccessLdapCache(request,
                                  connection,
                                  request->OriginalDN,
                                  request->search.ScopeOfSearch,
                                  request->search.SearchFilter,
                                  request->search.AttributeList,
                                  request->search.AttributesOnly,
                                  request->search.Unicode
                                  );

        } else {

            if ((request->OriginalDN == NULL) &&
                (request->search.AttributeList == NULL) &&
                (request->search.ScopeOfSearch == LDAP_SCOPE_BASE)) {

                IF_DEBUG(CACHE) {
                    LdapPrint1("WLDAP32: Process 0x%x is incorrectly making RootDSE searches which bypass the cache. Contact AnoopA with the process name.\n", GetCurrentProcessId());
                }
            }
            //
            // This is an ordinary search which is not cacheable.
            //

            err = SendLdapSearch(request,
                                 connection,
                                 request->OriginalDN,
                                 request->search.ScopeOfSearch,
                                 request->search.SearchFilter,
                                 request->search.AttributeList,
                                 request->search.AttributesOnly,
                                 request->search.Unicode,
                                 (CLdapBer **)&request->BerMessageSent,
                                 0 );
        }
    }

    if (err != LDAP_SUCCESS) {

        START_LOGGING;
        DSLOG((DSLOG_FLAG_TAG_CNPN,"[+]"));
        DSLOG((0,"[ID=%d][OP=ldap_search][ET=%I64d][ER=%d][-]\n",
                   request->MessageId, LdapGetTickCount(), err));
        END_LOGGING;

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_search connection 0x%x send with error of 0x%x.\n",
                        connection, err );
        }

        messageNumber = (ULONG) -1;
        SetConnectionError( connection, err, NULL );
        CloseLdapRequest( request );
    }

    DereferenceLdapRequest( request );
    *MessageNumber = messageNumber;
    return err;
}

ULONG __cdecl
ldap_searchW (
        LDAP    *ExternalHandle,
        PWCHAR  DistinguishedName,
        ULONG   ScopeOfSearch,
        PWCHAR  SearchFilter,
        PWCHAR  AttributeList[],
        ULONG   AttributesOnly
    )
{
    PLDAP_CONN connection = NULL;
    ULONG msgId = (ULONG) -1;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return (ULONG) -1;
    }

    err = LdapSearch(   connection,
                        DistinguishedName,
                        ScopeOfSearch,
                        SearchFilter,
                        AttributeList,
                        AttributesOnly,
                        TRUE,               // attribute list is in Unicode
                        FALSE,               // not synch
                        NULL,
                        NULL,
                        connection->publicLdapStruct.ld_timelimit,
                        connection->publicLdapStruct.ld_sizelimit,
                        &msgId
                        );
    DereferenceLdapConnection( connection );

    return msgId;
}

ULONG __cdecl
ldap_search (
        LDAP    *ExternalHandle,
        PCHAR   DistinguishedName,
        ULONG   ScopeOfSearch,
        PCHAR   SearchFilter,
        PCHAR   AttributeList[],
        ULONG   AttributesOnly
    )
{
    PWCHAR wName = NULL;
    PWCHAR wFilter = NULL;
    PLDAP_CONN connection = NULL;
    ULONG msgId = (ULONG) -1;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return (ULONG) -1;
    }

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP);

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        err = (ULONG) -1;
        goto error;
    }

    err = ToUnicodeWithAlloc( SearchFilter, -1, &wFilter, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        err = (ULONG) -1;
        goto error;
    }

    err = LdapSearch(   connection,
                        wName,
                        ScopeOfSearch,
                        wFilter,
                        (PWCHAR *) AttributeList,
                        AttributesOnly,
                        FALSE,              // attribute list isn't Unicode
                        FALSE,              // not synch
                        NULL,
                        NULL,
                        connection->publicLdapStruct.ld_timelimit,
                        connection->publicLdapStruct.ld_sizelimit,
                        &msgId
                        );

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wFilter)
        ldapFree( wFilter, LDAP_UNICODE_SIGNATURE );

    DereferenceLdapConnection( connection );

    return msgId;
}

ULONG __cdecl
ldap_search_sW (
        LDAP    *ExternalHandle,
        PWCHAR  DistinguishedName,
        ULONG   ScopeOfSearch,
        PWCHAR  SearchFilter,
        PWCHAR  AttributeList[],
        ULONG   AttributesOnly,
        LDAPMessage     **Results
    )
{
    return ldap_search_stW(ExternalHandle,
                           DistinguishedName,
                           ScopeOfSearch,
                           SearchFilter,
                           AttributeList,
                           AttributesOnly,
                           NULL,            // no timeout value specified
                           Results );
}

ULONG __cdecl
ldap_search_s (
        LDAP    *ExternalHandle,
        PCHAR   DistinguishedName,
        ULONG   ScopeOfSearch,
        PCHAR   SearchFilter,
        PCHAR   AttributeList[],
        ULONG   AttributesOnly,
        LDAPMessage     **Results
    )
{
    return ldap_search_st( ExternalHandle,
                           DistinguishedName,
                           ScopeOfSearch,
                           SearchFilter,
                           AttributeList,
                           AttributesOnly,
                           NULL,
                           Results );
}

ULONG __cdecl
ldap_search_stW (
        LDAP    *ExternalHandle,
        PWCHAR   DistinguishedName,
        ULONG    ScopeOfSearch,
        PWCHAR   SearchFilter,
        PWCHAR   AttributeList[],
        ULONG    AttributesOnly,
        struct l_timeval  *TimeOut,
        LDAPMessage     **Results
    )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (Results == NULL)) {
        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *Results = NULL;

    err = ldap_search_ext_sW(  ExternalHandle,
                               DistinguishedName,
                               ScopeOfSearch,
                               SearchFilter,
                               AttributeList,
                               AttributesOnly,
                               NULL,
                               NULL,
                               TimeOut,
                               connection->publicLdapStruct.ld_sizelimit,
                               Results );

#ifdef QFE_BUILD

    //
    // Mask results in the QFE build. Some folks still rely upon
    // LDAP_SUCCESS for retreiving entries
    //

    if ((*Results != NULL) &&
        (err != LDAP_SUCCESS) &&
        (err != LDAP_ADMIN_LIMIT_EXCEEDED) &&
        (ldap_count_records( connection, *Results, LDAP_RES_SEARCH_ENTRY ) > 0)) {

        err = LDAP_SUCCESS;
    }

#endif

error:
    if (connection)
        DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_search_st (
        LDAP    *ExternalHandle,
        PCHAR    DistinguishedName,
        ULONG    ScopeOfSearch,
        PCHAR    SearchFilter,
        PCHAR    AttributeList[],
        ULONG    AttributesOnly,
        struct l_timeval  *TimeOut,
        LDAPMessage     **Results
    )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (Results == NULL)) {
        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *Results = NULL;

    err = ldap_search_ext_sA(  ExternalHandle,
                               DistinguishedName,
                               ScopeOfSearch,
                               SearchFilter,
                               AttributeList,
                               AttributesOnly,
                               NULL,
                               NULL,
                               TimeOut,
                               connection->publicLdapStruct.ld_sizelimit,
                               Results );

#ifdef QFE_BUILD

    //
    // Mask results in the QFE build. Some folks still rely upon
    // LDAP_SUCCESS for retreiving entries
    //

    if ((*Results != NULL) &&
        (err != LDAP_SUCCESS) &&
        (err != LDAP_ADMIN_LIMIT_EXCEEDED) &&
        (ldap_count_records( connection, *Results, LDAP_RES_SEARCH_ENTRY ) > 0)) {

        err = LDAP_SUCCESS;
    }

#endif

error:
    if (connection)
        DereferenceLdapConnection( connection );

    return err;
}


WINLDAPAPI ULONG LDAPAPI ldap_search_extW(
        PLDAP           ExternalHandle,
        PWCHAR          DistinguishedName,
        ULONG           ScopeOfSearch,
        PWCHAR          SearchFilter,
        PWCHAR          AttributeList[],
        ULONG           AttributesOnly,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        ULONG           TimeLimit,
        ULONG           SizeLimit,
        ULONG          *MessageNumber
    )
{
    ULONG err;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return (ULONG) -1;
    }

    err = LdapSearch(   connection,
                        DistinguishedName,
                        ScopeOfSearch,
                        SearchFilter,
                        AttributeList,
                        AttributesOnly,
                        TRUE,               // attribute list is in Unicode
                        FALSE,               // not synch
                        ServerControls,
                        ClientControls,
                        TimeLimit,
                        SizeLimit,
                        MessageNumber
                        );

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_search_extA(
        PLDAP           ExternalHandle,
        PCHAR           DistinguishedName,
        ULONG           ScopeOfSearch,
        PCHAR           SearchFilter,
        PCHAR           AttributeList[],
        ULONG           AttributesOnly,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        ULONG           TimeLimit,
        ULONG           SizeLimit,
        ULONG          *MessageNumber
    )
{
    ULONG err;
    PWCHAR wName = NULL;
    PWCHAR wFilter = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    *MessageNumber = (ULONG) -1;

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        goto error;
    }

    err = ToUnicodeWithAlloc( SearchFilter, -1, &wFilter, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        SetConnectionError( connection, err, NULL );
        goto error;
    }

    err = LdapSearch(   connection,
                        wName,
                        ScopeOfSearch,
                        wFilter,
                        (PWCHAR *) AttributeList,
                        AttributesOnly,
                        FALSE,              // attribute list isn't Unicode
                        FALSE,              // not synch
                        (PLDAPControlW *) ServerControls,
                        (PLDAPControlW *) ClientControls,
                        TimeLimit,
                        SizeLimit,
                        MessageNumber
                        );

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wFilter)
        ldapFree( wFilter, LDAP_UNICODE_SIGNATURE );

    DereferenceLdapConnection( connection );

    return err;
}


WINLDAPAPI ULONG LDAPAPI ldap_search_ext_sW(
        PLDAP           ExternalHandle,
        PWCHAR          DistinguishedName,
        ULONG           ScopeOfSearch,
        PWCHAR          SearchFilter,
        PWCHAR          AttributeList[],
        ULONG           AttributesOnly,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        struct l_timeval  *timeout,
        ULONG           SizeLimit,
        LDAPMessage     **Results
    )
{
    ULONG msgId;
    ULONG err;
    PLDAP_CONN connection = NULL;
    ULONG timeLimit;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (Results == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *Results = NULL;

    if (timeout != NULL) {

        timeLimit = (ULONG) timeout->tv_sec + ( timeout->tv_usec / ( 1000 * 1000 ) );

    } else {

        timeLimit = connection->publicLdapStruct.ld_timelimit;
    }

    err = LdapSearch(   connection,
                        DistinguishedName,
                        ScopeOfSearch,
                        SearchFilter,
                        AttributeList,
                        AttributesOnly,
                        TRUE,               // attribute list is in Unicode
                        TRUE,               // synch
                        ServerControls,
                        ClientControls,
                        timeLimit,
                        SizeLimit,
                        &msgId
                        );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  otherwise we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error(  connection,
                                       msgId,
                                       LDAP_MSG_ALL,
                                       timeout,
                                       Results,
                                       NULL
                                       );

        if (*Results == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( ExternalHandle,
                                     *Results,
                                     FALSE
                                     );
        }
    }

error:
    if (connection)
        DereferenceLdapConnection( connection );

    return err;
}


WINLDAPAPI ULONG LDAPAPI ldap_search_ext_sA(
        PLDAP           ExternalHandle,
        PCHAR           DistinguishedName,
        ULONG           ScopeOfSearch,
        PCHAR           SearchFilter,
        PCHAR           AttributeList[],
        ULONG           AttributesOnly,
        PLDAPControlA   *ServerControls,
        PLDAPControlA   *ClientControls,
        struct l_timeval  *timeout,
        ULONG           SizeLimit,
        LDAPMessage     **Results
    )
{
    ULONG msgId;
    ULONG err;
    PWCHAR wName = NULL;
    PWCHAR wFilter = NULL;
    PLDAP_CONN connection = NULL;
    ULONG timeLimit;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (Results == NULL)) {

        err = LDAP_PARAM_ERROR;
        goto error;
    }

    *Results = NULL;

    if (timeout != NULL) {

        timeLimit = (ULONG) timeout->tv_sec + ( timeout->tv_usec / ( 1000 * 1000 ) );

    } else {

        timeLimit = connection->publicLdapStruct.ld_timelimit;
    }

    err = ToUnicodeWithAlloc( DistinguishedName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    err = ToUnicodeWithAlloc( SearchFilter, -1, &wFilter, LDAP_UNICODE_SIGNATURE, LANG_ACP );

    if (err != LDAP_SUCCESS) {

        goto error;
    }

    err = LdapSearch(   connection,
                        wName,
                        ScopeOfSearch,
                        wFilter,
                        (PWCHAR *) AttributeList,
                        AttributesOnly,
                        FALSE,              // attribute list isn't Unicode
                        TRUE,               // synch
                        (PLDAPControlW *) ServerControls,
                        (PLDAPControlW *) ClientControls,
                        timeLimit,
                        SizeLimit,
                        &msgId
                        );

    //
    //  if we error'd out before we sent the request, return the error here.
    //

    if (msgId != (ULONG) -1) {

        //
        //  otherwise we simply need to wait for the response to come in.
        //

        err = ldap_result_with_error(  connection,
                                       msgId,
                                       LDAP_MSG_ALL,
                                       timeout,
                                       Results,
                                       NULL
                                      );

        if ((*Results) == NULL) {

            LdapAbandon( connection, msgId, TRUE );

        } else {

            err = ldap_result2error( ExternalHandle,
                                     *Results,
                                     FALSE
                                     );
        }
    }

error:
    if (wName)
        ldapFree( wName, LDAP_UNICODE_SIGNATURE );

    if (wFilter)
        ldapFree( wFilter, LDAP_UNICODE_SIGNATURE );

    if (connection)
        DereferenceLdapConnection( connection );

    return err;
}



LDAPMessage * __cdecl
ldap_first_entry (
    LDAP    *ExternalHandle,
    LDAPMessage *Results
    )
{
    PLDAP_CONN connection = NULL;
    LDAPMessage *message;

    connection = GetConnectionPointer(ExternalHandle);

    message = ldap_first_record( connection, Results, LDAP_RES_SEARCH_ENTRY );

    if (connection)
        DereferenceLdapConnection( connection );

    return message;
}


LDAPMessage * __cdecl
ldap_next_entry (
    LDAP    *ExternalHandle,
    LDAPMessage *entry
    )
{
    PLDAP_CONN connection = NULL;
    LDAPMessage *message;

    connection = GetConnectionPointer(ExternalHandle);

    message = ldap_next_record( connection, entry, LDAP_RES_SEARCH_ENTRY );

    if (connection)
        DereferenceLdapConnection( connection );

    return message;
}


ULONG __cdecl
ldap_count_entries (
    LDAP *ExternalHandle,
    LDAPMessage *res
    )
{
    PLDAP_CONN connection = NULL;
    ULONG cnt;

    connection = GetConnectionPointer(ExternalHandle);

    cnt = ldap_count_records( connection, res, LDAP_RES_SEARCH_ENTRY );

    if (connection)
        DereferenceLdapConnection( connection );

    return cnt;
}


ULONG
LdapSaveSearchParameters (
    PLDAP_REQUEST Request,
    PWCHAR  DistinguishedName,
    PWCHAR  SearchFilter,
    PWCHAR  AttributeList[],
    BOOLEAN Unicode
    )
{
    ULONG err = LDAP_SUCCESS;

    Request->AllocatedParms = TRUE;

    if (DistinguishedName != NULL) {

        Request->OriginalDN = ldap_dup_stringW( DistinguishedName, 0, LDAP_UNICODE_SIGNATURE );

        if (Request->OriginalDN == NULL) {

            err = LDAP_NO_MEMORY;
        }
    }
    if ((SearchFilter != NULL) && (err == LDAP_SUCCESS)) {

        Request->search.SearchFilter = ldap_dup_stringW( SearchFilter, 0, LDAP_UNICODE_SIGNATURE );

        if (Request->search.SearchFilter == NULL) {

            err = LDAP_NO_MEMORY;
        }
    }
    if ( ( err == LDAP_SUCCESS ) && ( AttributeList != NULL )) {

        ULONG i = 0;
        ULONG valCount = 1;
        PWCHAR *attr = AttributeList;

        while (*(attr++) != NULL) {

            valCount++;
        }

        Request->search.AttributeList = (PWCHAR *) ldapMalloc(
                            valCount * sizeof( PWCHAR ),
                            LDAP_MOD_VALUE_SIGNATURE );

        if (Request->search.AttributeList == NULL) {

            IF_DEBUG(OUTMEMORY) {
                LdapPrint0( "LdapSearch 1 could not allocate memory.\n" );
            }
            err = LDAP_NO_MEMORY;
        }

        valCount--;
        attr = AttributeList;

        while ((i < valCount) && (err == LDAP_SUCCESS)) {

            if (Unicode) {

                Request->search.AttributeList[ i ] =
                    ldap_dup_stringW(   *attr,
                                        0,
                                        LDAP_UNICODE_SIGNATURE );

            } else {

                Request->search.AttributeList[ i ] = (PWCHAR)
                    ldap_dup_string(    (PCHAR) *attr,
                                        0,
                                        LDAP_ANSI_SIGNATURE );
            }


            if ( Request->search.AttributeList[i] == NULL ) {

                IF_DEBUG(OUTMEMORY) {
                    LdapPrint0( "LdapSearch 2 could not allocate memory.\n" );
                }
                err = LDAP_NO_MEMORY;
            }
            i++;
            attr++;
        }
    }

    return err;
}

// search.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\send.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    send.cxx  send a message to an LDAP server

Abstract:

   This module implements sending a message to an ldap server.

Author:

    Andy Herron (andyhe)        08-Jun-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

DWORD
LdapSend (
    IN PLDAP_CONN Connection,
    CLdapBer *lber )
{

    DWORD dwResult;
    PSECURESTREAM pSecureStream;

    ACQUIRE_LOCK( &(Connection->SocketLock) );

    if ( Connection->SecureStream || 
         Connection->SslPort ||
         Connection->CurrentSignStatus ||
         Connection->CurrentSealStatus) {

        //
        // You can't send on this connection if it's
        // currently doing SSL negotiation.
        //

        if ( Connection->SslSetupInProgress ) {

            IF_DEBUG(NETWORK_ERRORS) {
                LdapPrint1( "LdapSend denied - connection 0x%x is negotiating SSL.\n",
                            Connection );
            }

            RELEASE_LOCK( &(Connection->SocketLock) );
            return LDAP_LOCAL_ERROR;
        }

        pSecureStream = (PSECURESTREAM) Connection->SecureStream;

        if ( pSecureStream == NULL ) {

            //
            // If the stream object is NULL, then this connection
            // could not be negotiated and is being shut down.
            //

            dwResult = LDAP_LOCAL_ERROR;

        } else {

            dwResult = pSecureStream->LdapSendSsl( (PBYTE) (lber->PbData()),
                                                lber->CbData() );
        }

    } else {

        dwResult = LdapSendRaw( Connection,
                                (PCHAR) (lber->PbData()),
                                lber->CbData() );

    }

    RELEASE_LOCK( &(Connection->SocketLock) );

    return dwResult;
}

DWORD
LdapSendRaw (
    IN PLDAP_CONN Connection,
    PCHAR Data,
    ULONG DataCount
    )
{
    ULONG   bytesSent;
    ULONG   msgLength = DataCount;
    DWORD   rc = LDAP_SUCCESS;
    ULONG   retval = 0;

    fd_set SendSet;
    struct timeval tv= {2,0};

    BOOLEAN LimitReceives = (Connection->SendDrainTimeSeconds != (ULONG)-1) ? TRUE : FALSE;
    ULONG MillisecondsLeft = (Connection->SendDrainTimeSeconds * 1000);
    ULONG WaitTime;
    
    ULONGLONG BeginTime;
    ULONGLONG EndTime;
    ULONG TimeUsed;
               
    if (Connection->UdpHandle == INVALID_SOCKET) {

        for ( bytesSent = 0 ; bytesSent < msgLength ; bytesSent += retval) {

            //
            // Make sure the socket is ready to send.  If we're feeding large blocks
            // of data to it rapidly, send() may fail with WSAWOULDBLOCK because we're
            // momentarily out of send buffer space.  The select() will momentarily block
            // if that's the case, saving us the lengthy delays of going through the
            // LdapWaitForResponseFromServer path when send() isn't blocked because of the
            // receiving server.
            //
            FD_ZERO(&SendSet);
            FD_SET(Connection->TcpHandle, &SendSet);

            (*pselect)(0,
                       NULL,
                       &SendSet,
                       NULL,
                       &tv);

             Connection->SentPacket = TRUE;

             retval = (*psend)(  Connection->TcpHandle,
                         Data + bytesSent,
                         msgLength - bytesSent,
                         0 );

             if (retval == SOCKET_ERROR) {

                rc = (*pWSAGetLastError)();

                if (rc == WSAEWOULDBLOCK) {

                   if ((!LimitReceives) ||
                       (MillisecondsLeft > 0)) {


                       //
                       // We have to ensure that we will not go into the autoreconnect
                       // logic here. Downed servers should be picked up in the receive
                       // path.
                       //

                        if (LimitReceives) {

                            if ((Connection->KeepAliveSecondCount * 1000) > MillisecondsLeft) {
                                WaitTime = MillisecondsLeft;
                            }
                            else {
                                WaitTime = Connection->KeepAliveSecondCount * 1000;
                            }
                        }
                        else {

                            WaitTime = Connection->KeepAliveSecondCount * 1000;
                        }

                        BeginTime = LdapGetTickCount();

                        rc = LdapWaitForResponseFromServer( Connection,
                                                            NULL,
                                                            WaitTime,
                                                            LDAP_MSG_ONE,
                                                            NULL,        // no results
                                                            TRUE         // Disable reconnect
                                                            );

                        EndTime = LdapGetTickCount();

                        TimeUsed = (ULONG)(EndTime-BeginTime);

                        if (LimitReceives) {

                            if (TimeUsed > MillisecondsLeft) {
                                MillisecondsLeft = 0;
                            }
                            else {
                                MillisecondsLeft -= TimeUsed;
                            }
                        }

                        if (rc == LDAP_SERVER_DOWN) {

                           //
                           // We will pickup the serverdown in the receive path.
                           //

                            return LDAP_SUCCESS;
                        }

                        retval = 0;     // retry the send.
                    }
                    else {
                        bytesSent = retval;
                        break;
                    }
                    
                } else {
                    bytesSent = retval;
                    break;
                }
             }
        }

    } else {

        Connection->SentPacket = TRUE;

        bytesSent = (*psend)(   Connection->UdpHandle,
                                Data,
                                msgLength,
                                0 );
    }

    if (bytesSent != msgLength) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint3( "LDAP error during send. sent= 0x%x, len=0x%x, err = 0x%x\n",
                        bytesSent,
                        msgLength,
                        (*pWSAGetLastError)()  );
        }

        //
        //  we pick up a down server in the receive path.  If the server is
        //  down, we'll retransmit the request when we get a connection to
        //  the server again.
        //

        if (bytesSent == SOCKET_ERROR) {

            rc = (*pWSAGetLastError)();

            switch (rc) {
            case WSAECONNRESET:
            case WSAECONNABORTED:
            case WSAENETDOWN:
            case WSAENETUNREACH:
            case WSAESHUTDOWN:
            case WSAEHOSTDOWN:
            case WSAEHOSTUNREACH:
            case WSAENETRESET:
            case WSAENOTCONN:
//              rc = LDAP_SERVER_DOWN;
                rc = LDAP_SUCCESS;
                break;
            case WSAEWOULDBLOCK:
                rc = LDAP_TIMEOUT;
                SetConnectionError( Connection, rc, NULL);
                break;
            default:
                rc = LDAP_LOCAL_ERROR;
                SetConnectionError( Connection, rc, NULL );
            }
        }
    }

    return rc;
}

// send.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\security.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    security.cxx  security handler for LDAP client DLL

Abstract:

   This module implements SSPI security handlers for LDAP client DLL.

Author:

    Andy Herron    (andyhe)        26-Aug-1996
    Cory West      (corywest)      01-Oct-1996
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

#include "precomp.h"
#include "ldapp2.hxx"
#pragma hdrstop

FGETTOKENINFORMATION pGetTokenInformation = 0;
FOPENTHREADTOKEN pOpenThreadToken = 0;
FOPENPROCESSTOKEN pOpenProcessToken = 0;

FSASLINITIALIZESECURITYCONTEXTW pSaslInitializeSecurityContextW = NULL;
FSASLGETPROFILEPACKAGEW pSaslGetProfilePackageW = NULL;
FQUERYCONTEXTATTRIBUTESW pQueryContextAttributesW = NULL;

FSECINITSECURITYINTERFACEW pSspiInitialize = NULL;
FSECINITSECURITYINTERFACEW pSslInitialize = NULL;

ULONG LdapGlobalMsnSecurityFlags = 0;
ULONG LdapGlobalDpaSecurityFlags = 0;

BOOLEAN
LdapLoadSecurityDLL (
    PCHAR DllName
    );

BOOLEAN
LdapInitSecurity (
    VOID
    )
//
//  Returns TRUE if we have an SSPI function table to call through to.
//
{
    if (SecurityLibraryHandle != NULL) {

        return TRUE;      // we have a security DLL loaded, must be right one
    }

    if (pSspiInitialize != NULL) {

        return FALSE;   // dll is not loaded but we have an entry point..
                        // this prevents us from trying to loading
                        // the DLL every time if it failed on first try.
    }

    ACQUIRE_LOCK( &LoadLibLock );

    if (SecurityLibraryHandle != NULL) {

        RELEASE_LOCK( &LoadLibLock );
        return TRUE;      // we have a security DLL loaded, must be right one
    }

    if (pSspiInitialize != NULL) {

        RELEASE_LOCK( &LoadLibLock );
        return FALSE;   // dll is not loaded but we have an entry point..
                        // this prevents us from trying to loading
                        // the DLL every time if it failed on first try.
    }

    NumberSecurityPackagesInstalled = 0;
    SecurityPackagesInstalled = NULL;
    SspiFunctionTableW = NULL;
    SspiFunctionTableA = NULL;

    if ((GlobalWin9x == FALSE) && (AdvApi32LibraryHandle == NULL)) {

        //
        //  if we're on NT, pick up the address of the routine to use to get
        //  the currently logged in user's LUID.
        //

        AdvApi32LibraryHandle = LoadSystem32LibraryA( "ADVAPI32.DLL" );

    }
    
    if ((GlobalWin9x == FALSE) && (AdvApi32LibraryHandle != NULL)) {

        pGetTokenInformation = (FGETTOKENINFORMATION) GetProcAddress(
                                        AdvApi32LibraryHandle,
                                        "GetTokenInformation" );
        pOpenThreadToken = (FOPENTHREADTOKEN) GetProcAddress(
                                        AdvApi32LibraryHandle,
                                        "OpenThreadToken" );
        pOpenProcessToken = (FOPENPROCESSTOKEN) GetProcAddress(
                                        AdvApi32LibraryHandle,
                                        "OpenProcessToken" );
    }

    //
    // All exports in security.dll are forwarded to secur32.dll. so, we will try
    // to load it first.
    //

    if ((LdapLoadSecurityDLL("SECUR32.DLL") == FALSE) &&
        (LdapLoadSecurityDLL("SECURITY.DLL")  == FALSE)) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LDAP client failed to load security, err = 0x%x.\n", GetLastError());
        }

        //
        //  remember that we failed so we don't keep retrying
        //

        pSspiInitialize = (FSECINITSECURITYINTERFACEW) -1;

        RELEASE_LOCK( &LoadLibLock );
        return FALSE;
    }

    ASSERT( pSspiInitialize != NULL );

    SspiFunctionTableW = LdapSspiInitialize();

    //
    // There is no Kerberos support in Win9x for now
    //
    if (! GlobalWin9x)
    {
        pSaslInitializeSecurityContextW = (FSASLINITIALIZESECURITYCONTEXTW) GetProcAddress( SecurityLibraryHandle,
                                                        "SaslInitializeSecurityContextW" );

        pSaslGetProfilePackageW = (FSASLGETPROFILEPACKAGEW) GetProcAddress( SecurityLibraryHandle,
                                                        "SaslGetProfilePackageW" );

        pQueryContextAttributesW = (FQUERYCONTEXTATTRIBUTESW) GetProcAddress( SecurityLibraryHandle,
                                                        "QueryContextAttributesW" );

        if (pSaslInitializeSecurityContextW == NULL) {

            LdapPrint0("Failed to load SaslInitializeSecurityContextW\n");
        }

        if ( pSaslGetProfilePackageW == NULL ) {

            LdapPrint0("Failed to load SaslGetProfilePackageW\n");
        }

        if ( pQueryContextAttributesW == NULL ) {

            LdapPrint0("Failed to load QueryContextAttributesW\n");
        }
    }

    if (SspiFunctionTableW == NULL) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LDAP client failed InitSecurityInterface, err = 0x%x.\n", GetLastError());
        }

        //
        //  we definitely failed, so free the library so we don't keep retrying
        //

        FreeLibrary( SecurityLibraryHandle );
        SecurityLibraryHandle = NULL;

        RELEASE_LOCK( &LoadLibLock );
        return FALSE;
    }

    SECURITY_STATUS sErr;

    sErr = SspiFunctionTableW->EnumerateSecurityPackagesW(
                            &NumberSecurityPackagesInstalled,
                            &SecurityPackagesInstalled );
    if (sErr != SEC_E_OK) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LDAP client failed EnumSecurityPackages, err = 0x%x.\n", sErr);
        }

        RELEASE_LOCK( &LoadLibLock );
        return FALSE;
    }

    //
    //  check which security packages are installed.
    //

    ULONG i;
    PSecPkgInfoW packages = SecurityPackagesInstalled;

    if (packages != NULL) {

        for (i = 0; i < NumberSecurityPackagesInstalled; i++) {

            if (ldapWStringsIdentical(
                               packages->Name,
                               -1,
                               L"Kerberos",
                               -1)) {

                SspiPackageKerberos = packages;

            } else if (ldapWStringsIdentical(
                               (const PWCHAR) packages->Name,
                               -1,
                               (const PWCHAR) L"MSN",
                               -1)) {

                SspiPackageSicily = packages;

            } else if (ldapWStringsIdentical(
                               (const PWCHAR) packages->Name,
                               -1,
                               (const PWCHAR) L"NTLM",
                               -1)) {

                SspiPackageNtlm = packages;

            } else if (ldapWStringsIdentical(
                           (const PWCHAR) packages->Name,
                           -1,
                           (const PWCHAR) L"DPA",
                           -1)) {

                SspiPackageDpa = packages;

            } else if (ldapWStringsIdentical(
                           (const PWCHAR) packages->Name,
                           -1,
                           (const PWCHAR) L"wDigest",
                           -1)) {

                SspiPackageDigest = packages;

            } else if (ldapWStringsIdentical(
                           (const PWCHAR) packages->Name,
                           -1,
                           (const PWCHAR) L"Negotiate",
                           -1)) {

                SspiPackageNegotiate = packages;

            }

            //
            // Keep track of the largest token buffer that we'll need.
            //

            if ( packages->cbMaxToken > SspiMaxTokenSize) {
                SspiMaxTokenSize = packages->cbMaxToken;
            }

            packages++;
        }
    }

    RELEASE_LOCK( &LoadLibLock );
    return TRUE;
}

BOOLEAN
LdapInitSsl (
    VOID
    )
//
//  Returns TRUE if we have an SSL SSPI function table to call through to.
//
//  We treat SCHANNEL.DLL separately because on Win9x, it's not accessible
//  through the normal security dll.
//
{
    if (SslLibraryHandle != NULL) {

        return TRUE;      // we have a security DLL loaded, must be right one
    }

    if (pSslInitialize != NULL) {

        return FALSE;   // dll is not loaded but we have an entry point..
                        // this prevents us from trying to loading
                        // the DLL every time if it failed on first try.
    }

    ACQUIRE_LOCK( &LoadLibLock );

    if (SslLibraryHandle != NULL) {

        RELEASE_LOCK( &LoadLibLock );
        return TRUE;      // we have a security DLL loaded, must be right one
    }

    if (pSslInitialize != NULL) {

        RELEASE_LOCK( &LoadLibLock );
        return FALSE;   // dll is not loaded but we have an entry point..
                        // this prevents us from trying to loading
                        // the DLL every time if it failed on first try.
    }

    NumberSslPackagesInstalled = 0;
    SslPackagesInstalled = NULL;
    SslFunctionTableW = NULL;
    SslFunctionTableA = NULL;

    ASSERT( SslLibraryHandle == NULL );

    SslLibraryHandle = LoadSystem32LibraryA( "SCHANNEL.DLL" );

    if (SslLibraryHandle == NULL) {

        //
        //  remember that we failed so we don't keep retrying
        //

        pSslInitialize = (FSECINITSECURITYINTERFACEW) -1;

        RELEASE_LOCK( &LoadLibLock );
        return FALSE;
    }

    //
    //  if it's the wrong library for some reason, fail it and free the library.
    //

    if (GlobalWin9x)
    {
        pSslInitialize = (FSECINITSECURITYINTERFACEW) GetProcAddress( SslLibraryHandle,
                                                    "InitSecurityInterfaceA" );
    }
    else
    {
        pSslInitialize = (FSECINITSECURITYINTERFACEW) GetProcAddress( SslLibraryHandle,
                                                        "InitSecurityInterfaceW" );
    }

    if (pSslInitialize == NULL) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LDAP failed GetProcAddress for InitSecurityInterface, err = 0x%x.\n", GetLastError());
        }

        FreeLibrary( SslLibraryHandle );
        SslLibraryHandle = NULL;

        //
        //  remember that we failed so we don't keep retrying
        //

        pSslInitialize = (FSECINITSECURITYINTERFACEW) -1;

        RELEASE_LOCK( &LoadLibLock );
        return FALSE;
    }

    SslFunctionTableW = LdapSslInitialize();

    if (SslFunctionTableW == NULL) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LDAP client failed SSL InitSecurityInterface, err = 0x%x.\n", GetLastError());
        }

        //
        //  we definitely failed, so free the library so we don't keep retrying
        //

        FreeLibrary( SslLibraryHandle );
        pSslInitialize = (FSECINITSECURITYINTERFACEW) -1;
        SslLibraryHandle = NULL;

        RELEASE_LOCK( &LoadLibLock );
        return FALSE;
    }


    SECURITY_STATUS sErr;

    sErr = SslFunctionTableW->EnumerateSecurityPackagesW(
                            &NumberSslPackagesInstalled,
                            &SslPackagesInstalled );
    if (sErr != SEC_E_OK) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LDAP client failed SSL EnumSecurityPackages, err = 0x%x.\n", sErr);
        }
        RELEASE_LOCK( &LoadLibLock );
        return FALSE;
    }

    //
    //  check which security packages are installed.
    //

    ULONG i;
    PSecPkgInfoW packages = SslPackagesInstalled;

    for (i = 0; i < NumberSslPackagesInstalled; i++) {

        if (ldapWStringsIdentical(
                           (const PWCHAR) packages->Name,
                           -1,
                           (const PWCHAR) L"Microsoft Unified Security Protocol Provider",
                           -1)) {

            SspiPackageSslPct = packages;
        }

        //
        // Keep track of the largest token buffer that we'll need.
        //

        if ( packages->cbMaxToken > SspiMaxTokenSize) {
            SspiMaxTokenSize = packages->cbMaxToken;
        }

        packages++;
    }

    RELEASE_LOCK( &LoadLibLock );
    return TRUE;
}


BOOLEAN
LdapLoadSecurityDLL (
    PCHAR DllName
    )
{
    ASSERT( SecurityLibraryHandle == NULL );

    SecurityLibraryHandle = LoadSystem32LibraryA( DllName );

    if (SecurityLibraryHandle == NULL) {

        return FALSE;
    }

    //
    //  if it's the wrong library for some reason, fail it and free the library.
    //

    if (GlobalWin9x)
    {
        pSspiInitialize = (FSECINITSECURITYINTERFACEW) GetProcAddress( SecurityLibraryHandle,
                                                    "InitSecurityInterfaceA" );
    }
    else
    {
        pSspiInitialize = (FSECINITSECURITYINTERFACEW) GetProcAddress( SecurityLibraryHandle,
                                                        "InitSecurityInterfaceW" );
    }

    if (pSspiInitialize == NULL) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LDAP failed GetProcAddress for InitSecurityInterface, err = 0x%x.\n", GetLastError());
        }

        FreeLibrary( SecurityLibraryHandle );
        SecurityLibraryHandle = NULL;

        return FALSE;
    }
    return TRUE;
}

BOOLEAN
CheckForNullCredentials (
    PLDAP_CONN Connection
    )
{
    if ((Connection->hCredentials.dwLower == (ULONG_PTR) -1) &&
        (Connection->hCredentials.dwUpper == (ULONG_PTR) -1)) {

        return TRUE;
    }
    return FALSE;
}

VOID
CloseCredentials (
    PLDAP_CONN Connection
    )
{
    SECURITY_STATUS sErr;

    ACQUIRE_LOCK( &Connection->StateLock);

    if ((Connection->SecurityContext.dwLower != (ULONG_PTR) -1) ||
        (Connection->SecurityContext.dwUpper != (ULONG_PTR) -1)) {

        sErr = SspiFunctionTableW->DeleteSecurityContext( &Connection->SecurityContext );
//      ASSERT(sErr == SEC_E_OK);

        Connection->SecurityContext.dwLower = (ULONG_PTR) -1;
        Connection->SecurityContext.dwUpper = (ULONG_PTR) -1;
    }

    if (CheckForNullCredentials(Connection) == FALSE) {

        ASSERT( SspiFunctionTableW != NULL );

        sErr = SspiFunctionTableW->FreeCredentialHandle( &Connection->hCredentials );
//      ASSERT(sErr == SEC_E_OK);

        Connection->hCredentials.dwLower = (ULONG_PTR) -1;
        Connection->hCredentials.dwUpper = (ULONG_PTR) -1;
    }

    Connection->CurrentLogonId.LowPart = 0;
    Connection->CurrentLogonId.HighPart = 0;

    RELEASE_LOCK( &Connection->StateLock);
    
    return;
}


VOID
CloseCredentialsByHandle (
    CredHandle * phCredentials
    )
{
    SECURITY_STATUS sErr;

    if (!((phCredentials->dwLower == (ULONG_PTR) -1) &&
          (phCredentials->dwUpper == (ULONG_PTR) -1))) {

        ASSERT( SspiFunctionTableW != NULL );

        sErr = SspiFunctionTableW->FreeCredentialHandle( phCredentials );

        phCredentials->dwLower = (ULONG_PTR) -1;
        phCredentials->dwUpper = (ULONG_PTR) -1;
    }
   
    return;
}


VOID
SetNullCredentials (
    PLDAP_CONN Connection
    )
{
    Connection->hCredentials.dwLower = (ULONG_PTR) -1;
    Connection->hCredentials.dwUpper = (ULONG_PTR) -1;

    Connection->SecurityContext.dwLower = (ULONG_PTR) -1;
    Connection->SecurityContext.dwUpper = (ULONG_PTR) -1;
    return;
}


VOID
ClearSecurityContext (
    PLDAP_CONN Connection
    )
{

    ACQUIRE_LOCK( &Connection->StateLock);

    if ((Connection->SecurityContext.dwLower != (ULONG_PTR) -1) ||
        (Connection->SecurityContext.dwUpper != (ULONG_PTR) -1)) {

        SspiFunctionTableW->DeleteSecurityContext( &Connection->SecurityContext );

        Connection->SecurityContext.dwLower = (ULONG_PTR) -1;
        Connection->SecurityContext.dwUpper = (ULONG_PTR) -1;
    }

    RELEASE_LOCK( &Connection->StateLock);    
}


VOID
ClearSecurityContextByHandle (
    CtxtHandle * pSecurityContext
    )
{


    if ((pSecurityContext->dwLower != (ULONG_PTR) -1) ||
        (pSecurityContext->dwUpper != (ULONG_PTR) -1)) {

        ASSERT( SspiFunctionTableW != NULL );
        SspiFunctionTableW->DeleteSecurityContext( pSecurityContext );

        pSecurityContext->dwLower = (ULONG_PTR) -1;
        pSecurityContext->dwUpper = (ULONG_PTR) -1;
    }

}


ULONG
LdapConvertSecurityError (
    PLDAP_CONN Connection,
    SECURITY_STATUS sErr
    )
//
//  Map a security return code to an ldap return code.
//
{
    ULONG err;

    switch (sErr) {
    case SEC_E_OK:
        err = LDAP_SUCCESS;
        break;

    case SEC_E_NO_CREDENTIALS:
    case SEC_E_NOT_OWNER:
    case SEC_E_LOGON_DENIED:
        err = LDAP_INVALID_CREDENTIALS;
        break;

    case SEC_E_UNKNOWN_CREDENTIALS:
    case SEC_E_SECPKG_NOT_FOUND:
        err = LDAP_AUTH_UNKNOWN;
        break;

    case SEC_E_INSUFFICIENT_MEMORY:
        err = LDAP_NO_MEMORY;
        break;

    case ERROR_BAD_NET_RESP:
        err = LDAP_SERVER_DOWN;
        break;

    case ERROR_TIMEOUT:
        err = LDAP_TIMEOUT;
        break;
    
    case SEC_E_INTERNAL_ERROR:
    default:

        SetConnectionError (Connection, sErr, NULL);
        err = LDAP_LOCAL_ERROR;
    }

    return err;
}

ULONG
LdapSspiBind (
    PLDAP_CONN Connection,
    PSecPkgInfoW Package,
    ULONG UserMethod,
    ULONG SspiFlags,
    PWCHAR UserName,
    PWCHAR TargetName,
    PWCHAR Credentials
)
/*+++

Description:

    Given an SSPI package, the method that the user request, a user name,
    the package specific data, a password, and a set of security
    requirements, complete the SSPI authentication to the server for the
    current bind request.

    The user supplied authentication method influences how the bind
    packet is formed; othewise, this code is generic for any SSPI package.

---*/
{
    ULONG err;
    SECURITY_STATUS sErr;
    PSecBufferDesc pInboundToken = NULL;
    ULONG          LocalSspiFlags = SspiFlags;
    BOOLEAN        InitFailedOnce = FALSE;
    BOOLEAN        KerberosCapableServer = TRUE;
    BOOLEAN        CheckedForKerberos = FALSE;
    SecBuffer      OutBuffer[1], InBuffer[1];
    PWCHAR newCreds = NULL;
    BOOLEAN fSentMessage = FALSE;
    
    BOOLEAN fRequireSigning = FALSE;
    BOOLEAN fSign = FALSE;
    BOOLEAN fSignableServer = Connection->WhistlerServer;

    // The security context we negotiate using this bind.  This will become
    // the connection's security context once the bind is complete.
    CtxtHandle BindSecurityContext = {-1, -1};     // SSPI security context
    CredHandle hBindCredentials = {-1, -1};        // credential handle from SSPI
    TimeStamp  BindCredentialExpiry;    // local time credential expires.

    //
    // Determine our signing requirements.  Global signing policy only
    // applies if we're not doing SSL.
    //
    if (Connection->UserSignDataChoice) {
        fRequireSigning = TRUE;
        fSign = TRUE;
    }
    else {
        // If user didn't explicitly request signing, it's still possible signing bits
        // are set in NegotiateFlags (& variables derived from NegotiateFlags) from a previous
        // bind that turned on signing by policy.  Make sure those bits are cleared in
        // preparation for this bind --- we'll turn them back on below if policy dictates.
        SspiFlags &= ~(ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT);
        LocalSspiFlags &= ~(ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT);
        Connection->NegotiateFlags &= ~(ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT);
    }

    if (!Connection->SslPort) {
    
        if (GlobalIntegrityDefault == DEFAULT_INTEGRITY_REQUIRED) {

            fRequireSigning = TRUE;
        }

        //
        // If we have integrity (signing) globally turned on,
        // turn it on for this connection.  Note, that if we only
        // "prefer" signing and fail to establish it, we'll later need
        // to reset the connection to its unsigned state.
        //
        if ( ((GlobalIntegrityDefault == DEFAULT_INTEGRITY_PREFERRED) && (fSignableServer)) ||
             (GlobalIntegrityDefault == DEFAULT_INTEGRITY_REQUIRED) ) {

            SspiFlags |= (ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT);
            LocalSspiFlags |= (ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT);
            fSign=TRUE;
        }
    }
    
    //
    // Make sure the security provider has been initialized.
    //

    OutBuffer[0].pvBuffer = NULL;

    ASSERT( SspiFunctionTableW != NULL );

    //
    // The client can perform multiple binds in
    // a single session.  So we set up a new security context and credential
    // handle for this bind, and cleanup the old context/credentials once the
    // bind is complete to avoid leaks.  We need to keep the old context
    // around because the connection may be currently signed/sealed, so we need
    // to use the old context to sign/seal the bind until a new context is
    // established.
    //

    LdapClearSspiState( Connection );

    //
    // If we are currently autoreconnecting, do not recreate the credential
    // handle since we already have it. This will ensure that we use the
    // same credential context used on the primary bind.
    //

    if ( Connection->Reconnecting ) {

        //
        // Use the existing credential handle for the new security context.
        //

        hBindCredentials = Connection->hCredentials;

    } else {

        //
        // It is valid to issue multiple binds on the same connection.
        // Create a new credential handle for the newly passed-in credentials.
        //

    
        //
        //  If alternate credentials were passed in and we have a
        //  SEC_WINNT_AUTH_IDENTITY structure, ensure it's the right format.
        //
    
        if ( Credentials != NULL) {
    
           err = ProcessAlternateCreds( Connection,
                                        Package,
                                        Credentials,
                                        &newCreds
                                         );
           if (err != LDAP_SUCCESS) {
    
              LdapPrint0(" Error in processing alternate credentials\n");
              return err;
    
           }
        }
    
        sErr = SspiFunctionTableW->AcquireCredentialsHandleW(
                   NULL,                          // User name for the credentials (ignored).
                   Package->Name,                 // Security package name.
                   SECPKG_CRED_OUTBOUND,          // These are outbound only credentials.
                   NULL,                          // The user LUID - not used.
                   newCreds,                      // The package specific data.
                   NULL,                          // The specific get key function.
                   NULL,                          // Argument to the get key function.
                   &hBindCredentials,     // OUT: Pointer to the credential.
                   &BindCredentialExpiry  // OUT: Credential expiration time.
        );
    
        err = LdapConvertSecurityError( Connection, sErr );
    
        if ( err != LDAP_SUCCESS ) {
    
            IF_DEBUG( NETWORK_ERRORS ) {
                LdapPrint2( "LdapSspiBind Connection 0x%x received 0x%x on \
                             AcquireCredentialsHandle.\n",
                            Connection, sErr );
            }
            goto ExitWithCleanup;
        }
    }

    //
    // Get the opaque SSPI token for the remote peer.
    //

    SecBufferDesc  OutboundToken, InboundToken;
    DWORD          ContextAttr;
    TimeStamp      tsExpiry;

    ContextAttr = 0;

    OutBuffer[0].pvBuffer = ldapMalloc( SspiMaxTokenSize,
                                        LDAP_SECURITY_SIGNATURE );
    if ( OutBuffer[0].pvBuffer == NULL ) {
        err = LDAP_NO_MEMORY;
        goto ExitWithCleanup;
    }

    OutBuffer[0].cbBuffer = SspiMaxTokenSize,
    OutBuffer[0].BufferType = SECBUFFER_TOKEN;

    OutboundToken.cBuffers = 1;
    OutboundToken.pBuffers = OutBuffer;
    OutboundToken.ulVersion = SECBUFFER_VERSION;

    InBuffer[0].cbBuffer = 0;
    InBuffer[0].BufferType = SECBUFFER_TOKEN;
    InBuffer[0].pvBuffer = NULL;

    InboundToken.cBuffers = 1;
    InboundToken.pBuffers = InBuffer;
    InboundToken.ulVersion = SECBUFFER_VERSION;

ITERATE_BIND:


    if ((pSaslInitializeSecurityContextW) &&
        (UserMethod == LDAP_AUTH_NEGOTIATE) &&
        (Connection->PreferredSecurityPackage)) {

        sErr = (*pSaslInitializeSecurityContextW)(
                   &hBindCredentials,                    // The credential.
                   Connection->CurrentAuthLeg ?
                     &BindSecurityContext : NULL,        // The partially formed context.
                   TargetName,                           // Target name.
                   LocalSspiFlags,                       // Required attributes.
                   0,                                    // Reserved - must be zero.
                   SECURITY_NATIVE_DREP,                 // Data representation on target.
                   pInboundToken,                        // Pointer to the input buffers.
                   0,                                    // Reserved - must be zero.
                   &BindSecurityContext,                 // OUT: New context handle.
                   &OutboundToken,                       // OUT: Opaque token.
                   &ContextAttr,                         // OUT: Context established attributes.
                   &tsExpiry                             // OUT: Expiration time for context.
        );

    } else {


        sErr = SspiFunctionTableW->InitializeSecurityContextW(
                   &hBindCredentials,                    // The credential.
                   Connection->CurrentAuthLeg ?
                     &BindSecurityContext : NULL,        // The partially formed context.
                   TargetName,                           // Target name.
                   LocalSspiFlags,                       // Required attributes.
                   0,                                    // Reserved - must be zero.
                   SECURITY_NATIVE_DREP,                 // Data representation on target.
                   pInboundToken,                        // Pointer to the input buffers.
                   0,                                    // Reserved - must be zero.
                   &BindSecurityContext,                 // OUT: New context handle.
                   &OutboundToken,                       // OUT: Opaque token.
                   &ContextAttr,                         // OUT: Context established attributes.
                   &tsExpiry                             // OUT: Expiration time for context.
        );

    }

    //
    // If the SSPI package is the MSN Sicily package and
    // we failed because of a lack of credentials, then
    // throw up the "Logon to MSN" dialog.
    //

    if (LocalSspiFlags & ISC_REQ_PROMPT_FOR_CREDS) {

        InitFailedOnce = TRUE;
    }

    if ( ( ( UserMethod == LDAP_AUTH_SICILY ) ||
           ( UserMethod == LDAP_AUTH_DPA ) ||
           ( UserMethod == LDAP_AUTH_MSN ) ) &&
         ( sErr == SEC_E_NO_CREDENTIALS ) &&
         ( Connection->PromptForCredentials ) &&
         ( !InitFailedOnce ) ) {

        InitFailedOnce = TRUE;
        SetFlag( LocalSspiFlags, ISC_REQ_PROMPT_FOR_CREDS );
        goto ITERATE_BIND;
    }

    if ( InitFailedOnce ) {
        ClearFlag( LocalSspiFlags, ISC_REQ_PROMPT_FOR_CREDS );
        InitFailedOnce = FALSE;
    }

    //
    // If there was an inbound token, then we're in an intermediate
    // leg of a multi-leg authentication procedure.  We need to free
    // the LDAP response that holds the most recent inbound token.
    //

    if ( ( pInboundToken ) &&
         ( pInboundToken->pBuffers[0].pvBuffer != NULL ) ) {

        pInboundToken->pBuffers[0].pvBuffer = NULL;
        pInboundToken->pBuffers[0].cbBuffer = 0;

        pInboundToken = NULL;

        ldap_msgfree( Connection->BindResponse );
        Connection->BindResponse = NULL;
    }

    //
    // Check the return code and set the proper SSPI
    // continue flags in the connection data structure.
    //

    err = LdapSetSspiContinueState( Connection, sErr );

    if ( err != LDAP_SUCCESS ) {
        goto ExitWithCleanup;
    }

    //
    // If we determine that the server is capable of kerberos but the it
    // does not advertise GSSAPI or GSS_SPENGO in it's RootDSE, we should
    // fail the bind request because this could be a downgrade attack to
    // collect NTLM passwords.
    //

    if (( CheckedForKerberos == FALSE ) &&
        ( UserMethod == LDAP_AUTH_NEGOTIATE ) &&
        ( pQueryContextAttributesW != NULL )) {

        SecPkgContext_NegotiationInfoW NegoInfo;
        
        ULONG status = pQueryContextAttributesW( &BindSecurityContext,
                                           SECPKG_ATTR_NEGOTIATION_INFO,
                                           &NegoInfo );
        
        if (NT_SUCCESS(status)) {

            CheckedForKerberos = TRUE;

            if (ldapWStringsIdentical(
                                      NegoInfo.PackageInfo->Name,
                                      -1,
                                      L"Kerberos",
                                      -1 )) {

                IF_DEBUG(BIND) {
                    LdapPrint0("wldap32:Server is capable of Kerberos\n");
                }
                KerberosCapableServer = TRUE;
    
            } else {

                IF_DEBUG(BIND) {
                    LdapPrint1("wldap32:Server is capable of %S\n", NegoInfo.PackageInfo->Name);
                }
                KerberosCapableServer = FALSE;
            }       
                
            SspiFunctionTableW->FreeContextBuffer( NegoInfo.PackageInfo );
        
            if (KerberosCapableServer &&
                !(Connection->SupportsGSSAPI || Connection->SupportsGSS_SPNEGO)) {

                //
                // This is a rogue server trying to trick us into sending it NTLM
                // creds or an SPN misconfiguration.
                //
    
                err = LDAP_UNWILLING_TO_PERFORM;
                goto ExitWithCleanup;
            
            } else if (!KerberosCapableServer && !Connection->PreferredSecurityPackage) {

                if (!(Connection->SupportsGSS_SPNEGO || Connection->SupportsGSSAPI)) {

                    if (Connection->HighestSupportedLdapVersion == LDAP_VERSION3) {
                        //
                        // This must be an Exchange/SiteServer server which does not support
                        // kerberos. No point in getting LdapExchangeOpaqueToken to label
                        // it as a GSSAPI blob. We will retry with sicily authentication.
                        //

                        err = LDAP_AUTH_METHOD_NOT_SUPPORTED;
                        goto ExitWithCleanup;
                    
                    } else {
                        //
                        // This must be a v2 server. Obviously it will not understand gssapi
                        // we must back off to v2 and try with Sicily auth.
                        //

                        ASSERT(Connection->publicLdapStruct.ld_version == LDAP_VERSION3);
                        err = LDAP_PROTOCOL_ERROR;
                        goto ExitWithCleanup;

                    }
                }
            }

        } else {

            LdapPrint1("QueryContextAttributes failed with 0x%x\n", status)
            err = LDAP_LOCAL_ERROR;
            goto ExitWithCleanup;
        }
    }

    //
    // We can't have a partial response here since the
    // token was part of an LDAP message!!
    //

    ASSERT( Connection->SspiNeedsMoreData == FALSE );

    //
    // Complete the token if the SSPI provider requires.
    //

    if ( Connection->TokenNeedsCompletion ) {

        sErr = SspiFunctionTableW->CompleteAuthToken(
                   &BindSecurityContext,
                   &OutboundToken );

        err = LdapConvertSecurityError( Connection, sErr );

        if ( err != LDAP_SUCCESS ) {

            IF_DEBUG( NETWORK_ERRORS ) {
                LdapPrint1( "LdapSspiBind couldn't complete the \
                             auth token.  sErr = 0x%x\n", sErr );
            }

            goto ExitWithCleanup;
        }

        Connection->TokenNeedsCompletion = FALSE;
    }

    //
    // Send the token if one was provided.  The response
    // will contain the SSPI SecBuffer that we need to
    // continue if this is a multi-leg auth package. The other
    // case is during GSSAPI auth for the server initiation of
    // the roundtrip where we have to send an empty bind request.
    //

    if (( OutBuffer[0].cbBuffer != 0 ) ||
        (( OutBuffer[0].cbBuffer == 0) &&
          (sErr == SEC_I_CONTINUE_NEEDED))) {

        //
        // Ensure that we sign/seal during the bind stage
        // with the options CURRENTLY being used on this connection,
        // not with what we're TRYING to establish with this bind
        //        

        err = LdapExchangeOpaqueToken( Connection,
                                       UserMethod,
                                       Connection->SaslMethod,     // User preferred SASL mechanism
                                       UserName,
                                       OutboundToken.pBuffers[0].pvBuffer,
                                       OutboundToken.pBuffers[0].cbBuffer,
                                       &InboundToken,
                                       NULL,            // server returned cred
                                       NULL,            // server ctrls
                                       NULL,            // Client Ctrls
                                       NULL,            // return msgNumber
                                       FALSE,           // Send only
                                       FALSE,           // Unicode
                                       &fSentMessage);  // did we send bind message


        if (( err != LDAP_SUCCESS ) &&
            ( err != LDAP_SASL_BIND_IN_PROGRESS )) {

            goto ExitWithCleanup;
        }

    }

    //
    // If SSPI expects the response token, send it on up.
    //

    if ( Connection->SspiNeedsResponse ) {

        if ( Package == SspiPackageDpa ) {

            LocalSspiFlags |= LdapGlobalDpaSecurityFlags;
            LdapGlobalDpaSecurityFlags = 0;
        }

        if ( Package == SspiPackageSicily ) {

            LocalSspiFlags |= LdapGlobalMsnSecurityFlags;
            LdapGlobalMsnSecurityFlags = 0;
        }

        pInboundToken = &InboundToken;

        if ( (pInboundToken->pBuffers[0].pvBuffer == NULL) ||
             (pInboundToken->pBuffers[0].cbBuffer == 0) ) {

            LdapPrint0("Expecting response creds from remote server but got back none\n") 
            err = LDAP_PROTOCOL_ERROR;
            goto ExitWithCleanup;
        }

        //
        // Reset the outbound token size.
        //

        OutBuffer[0].cbBuffer = SspiMaxTokenSize;

        goto ITERATE_BIND;
    }


    //
    // security check: If we asked for a connection that supports
    // signing/sealing, make sure we got one.
    //

    // first check signing.  We have to deal with the possibility
    // that signing may have been preferred but not required.
    if ( ((SspiFlags & ISC_REQ_INTEGRITY) &&
          (!(ContextAttr & ISC_REQ_INTEGRITY))) ||
          
         ((SspiFlags & ISC_REQ_SEQUENCE_DETECT) &&
          (!(ContextAttr & ISC_REQ_SEQUENCE_DETECT))) ) {


        IF_DEBUG(SSL) {
            LdapPrint2("LdapSspiBind: asked for connection supporting SspiFlags = 0x%x, \
                        got connection supporting ContextAttr = 0x%x\n", SspiFlags, ContextAttr);
        }

        if (fRequireSigning) {
            err = LDAP_UNWILLING_TO_PERFORM;
            goto ExitWithCleanup;
        }
        else {
            // must be just signing preferred.  reset the signing status
            // on the connection.
            SspiFlags &= ~(ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT);
            LocalSspiFlags &= ~(ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT);
            fSign = FALSE;
        }
    }

    // check sealing
    if ((SspiFlags & ISC_REQ_CONFIDENTIALITY) &&
          (!(ContextAttr & ISC_REQ_CONFIDENTIALITY))) {


        IF_DEBUG(SSL) {
            LdapPrint2("LdapSspiBind: asked for connection supporting SspiFlags = 0x%x, \
                        got connection supporting ContextAttr = 0x%x\n", SspiFlags, ContextAttr);
        }
 
        err = LDAP_UNWILLING_TO_PERFORM;
        goto ExitWithCleanup;
    }


    // if user explicitly asked for mutual auth, make sure the user got it
    if ((Connection->UserMutualAuthChoice) &&
        (!(ContextAttr & ISC_REQ_MUTUAL_AUTH))) {

        IF_DEBUG(BIND) {
            LdapPrint2("LdapSspiBind: asked for connection supporting SspiFlags = 0x%x, \
                        got connection supporting ContextAttr = 0x%x\n", SspiFlags, ContextAttr);
        }
 
        err = LDAP_UNWILLING_TO_PERFORM;
        goto ExitWithCleanup;
    }

ExitWithCleanup:

    //
    // Regardless of whether we succeeded or failed, we need to get rid of
    // the old context if we started the bind protocol with the server
    //  * If we failed, the old context is no good anyway
    //  (see RFC 2251, section 4.2.1, about subsequent binds : "Authentication
    //  from earlier binds are subsequently ignored, and so if the bind fails,
    //  the connection will be treated as anonymous.")
    //  * If we succeeded, the new context will replace the old context.
    //

    // We skip only if it failed before we got to the point of sending anything
    // to the server (since in that case the server doesn't know anything is wrong)
    if (! ((!fSentMessage) && (err != LDAP_SUCCESS)) ) {

            
        if ( Connection->Reconnecting ) {

            //
            // This could be a transient security failure.
            // Get rid of the security context but save the credential handle.
            // If we are asked to autorebind in future, we will need it.
            //
            
            ClearSecurityContext( Connection );

        } else {

            CloseCredentials( Connection );
        }

        //
        // Clear the secure stream left over from the previous bind,
        // if it was a SASL (sign/seal) secure stream
        //
        ACQUIRE_LOCK(&ConnectionListLock)

        if ((Connection->SecureStream) &&
            (Connection->CurrentSignStatus || Connection->CurrentSealStatus)) {


            PSECURESTREAM pTemp;
            pTemp = (PSECURESTREAM) Connection->SecureStream;
            delete pTemp;
            
            Connection->SecureStream = NULL;
            Connection->CurrentSignStatus = FALSE;
            Connection->CurrentSealStatus = FALSE;
        }

        RELEASE_LOCK(&ConnectionListLock)            
    }

    //
    // If we failed, close the new SSPI credentials.
    //

    if ( err != LDAP_SUCCESS ) {

        if ( Connection->Reconnecting ) {
    
            // we created a new security context but used the old credential handle,
            // so we just need to clean up the new context
    
            IF_DEBUG( RECONNECT ) {
                LdapPrint1("LDAP rebind failed due to security error 0x%x", sErr);
            }
            
            ClearSecurityContextByHandle( &BindSecurityContext );
    
        } else {

            //
            // Get rid of the new context as well as the new credentials. This bind has
            // no chance of recovering.
            //

            ClearSecurityContextByHandle( &BindSecurityContext );
            CloseCredentialsByHandle( &hBindCredentials );
        }

 
        if (( err == LDAP_INVALID_CREDENTIALS ) &&
            ( Connection->PromptForCredentials )) {

            if ( Package == SspiPackageDpa ) {

                //
                //  if we failed due to invalid credentials, prompt for
                //  credentials the next time we come in here.
                //

                LdapGlobalDpaSecurityFlags = ISC_REQ_PROMPT_FOR_CREDS;
            }
            if ( Package == SspiPackageSicily ) {

                //
                //  if we failed due to invalid credentials, prompt for
                //  credentials the next time we come in here.
                //

                LdapGlobalMsnSecurityFlags = ISC_REQ_PROMPT_FOR_CREDS;
            }
        }

        if (!CheckedForKerberos) {
            //
            // We don't know for sure if the server is kerberos capable. We
            // failed before getting to that step. Let's give it the benefit
            // of the doubt.
            //
            
            KerberosCapableServer = FALSE;
        }

        if (KerberosCapableServer &&
            (( err == LDAP_PROTOCOL_ERROR ) ||
             ( err == LDAP_AUTH_METHOD_NOT_SUPPORTED ) )) {
            
            //
            // Make sure that we don't fall back to NTLM/Sicily if a server tries
            // to fool us with a bogus return code.
            //

            err = LDAP_UNWILLING_TO_PERFORM;
        }

        if (newCreds != NULL) {

            ldapSecureFree( newCreds, LDAP_SECURITY_SIGNATURE );
        }

    } else {

        Connection->BindMethod = UserMethod;
        Connection->CurrentCredentials = newCreds;
        // update the current sign/seal status with the signing/sealing
        // we just negotiated
        Connection->CurrentSignStatus = fSign;
        Connection->CurrentSealStatus = Connection->UserSealDataChoice;
        
        // If the bind we negotiated has signing enabled, but our connection's NegotiateFlags
        // don't indicate signing, then we must have turned on signing by integrity policy and
        // need to update NegotiateFlags to reflect this fact
        if ( (SspiFlags & (ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT)) &&
             (!(Connection->NegotiateFlags & (ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT)))) {

            Connection->NegotiateFlags |= (ISC_REQ_INTEGRITY | ISC_REQ_SEQUENCE_DETECT);
        }

        //
        // Copy the new credentials/context into the connection
        // (the old credentials/context have already been freed).
        //
        if ( Connection->Reconnecting ) {

            // reconnects recycle the old credential handle,
            // so we just need to copy the context
            Connection->SecurityContext = BindSecurityContext;
    
        } else {
        
            Connection->SecurityContext = BindSecurityContext;
            Connection->hCredentials = hBindCredentials;
            Connection->CredentialExpiry = BindCredentialExpiry;

        }

        //
        // Scramble stored password if necessary.
        //
        // CurrentCredentials points to an authidentity/_EX struct
        // which inturn, points to plaintext credentials. We will encrypt
        // only the password.
        //

        if ((Connection->CurrentCredentials) && GlobalUseScrambling) {

            PSEC_WINNT_AUTH_IDENTITY_EXW temp = (PSEC_WINNT_AUTH_IDENTITY_EXW) Connection->CurrentCredentials;
    
            ACQUIRE_LOCK( &Connection->ScramblingLock );
    
            if (( temp->Version > 0xFFFF )||( temp->Version == 0 )) {
    
               //
               // we are using the older style authIdentity structure.
               //
    
                PSEC_WINNT_AUTH_IDENTITY_W pAuth = (PSEC_WINNT_AUTH_IDENTITY_W) Connection->CurrentCredentials;
    
                if (pAuth->Password) {
    
                      pRtlInitUnicodeString( &Connection->ScrambledCredentials, pAuth->Password);
                      RoundUnicodeStringMaxLength(&Connection->ScrambledCredentials, DES_BLOCKLEN);
                      EncodeUnicodeString(&Connection->ScrambledCredentials);

                      Connection->Scrambled = TRUE;
                }
    
            } else {
    
                //
                // We are using the newer style _EX structure.
                //
                
                PSEC_WINNT_AUTH_IDENTITY_EXW pAuthEX = (PSEC_WINNT_AUTH_IDENTITY_EXW) Connection->CurrentCredentials;
    
                if (pAuthEX->Password) {
    
                      pRtlInitUnicodeString( &Connection->ScrambledCredentials, pAuthEX->Password);
                      RoundUnicodeStringMaxLength(&Connection->ScrambledCredentials, DES_BLOCKLEN);
                      EncodeUnicodeString(&Connection->ScrambledCredentials);

                      Connection->Scrambled = TRUE;
                }
    
            }
            
            RELEASE_LOCK( &Connection->ScramblingLock );

        }

        //
        // If this is an auto-rebind, we should already have a LUID so,
        // don't overwrite it with a new one.
        //

        if ( Connection->Reconnecting == FALSE ) {

            GetCurrentLuid( &Connection->CurrentLogonId );
        }

        if (Connection->CurrentSignStatus || Connection->CurrentSealStatus) {

            ASSERT( SspiFunctionTableW != NULL );

            PSECURESTREAM pSecureStream;

            IF_DEBUG(SSL) {
                LdapPrint0("Creating Cryptstream object to handle signing/sealing\n");
            }

            pSecureStream = new CryptStream( Connection, SspiFunctionTableW, FALSE );

            if ( pSecureStream == NULL ) {

               err = ERROR_NOT_ENOUGH_MEMORY;

            } else {
               ACQUIRE_LOCK(&ConnectionListLock)
               Connection->SecureStream = (PVOID)pSecureStream;
               RELEASE_LOCK(&ConnectionListLock)               
            }
        }
    }

    ldapFree( OutBuffer[0].pvBuffer, LDAP_SECURITY_SIGNATURE );

    return err;

}

VOID
GetCurrentLuid (
    PLUID Luid
    )
{
    HANDLE           TokenHandle = NULL ;
    TOKEN_STATISTICS TokenInformation ;
    DWORD            ReturnLength ;
    BOOLEAN          setIt = FALSE;

    //
    //  Get the logon token for the current user making the bind call
    //
    //  Note that we only do this if we're on WinNT, not Win9x since Win9x
    //  doesn't have the concept of different user contexts.
    //

    if ((pGetTokenInformation != 0) &&
        (pOpenThreadToken != 0)) {

        //
        // Try thread first. If fail, try process.
        //

        if ((*pOpenThreadToken)(    GetCurrentThread(),
                                    TOKEN_QUERY,
                                    TRUE,
                                    &TokenHandle) ||
            ((pOpenProcessToken != 0) &&
             (*pOpenProcessToken)(  GetCurrentProcess(),
                                    TOKEN_QUERY,
                                    &TokenHandle))) {

            //
            // Get the TokenSource info to pull out the luid.
            //

            if ((*pGetTokenInformation)(    TokenHandle,
                                            TokenStatistics,
                                            &TokenInformation,
                                            sizeof(TokenInformation),
                                            &ReturnLength)) {

                *Luid = TokenInformation.AuthenticationId ;
                setIt = TRUE;
            }
            CloseHandle(TokenHandle) ;
        }
    }
    if (!setIt) {

        Luid->LowPart = 0;
        Luid->HighPart = 0;
    }

    return;
}

ULONG
LdapSetSspiContinueState(
    PLDAP_CONN Connection,
    SECURITY_STATUS sErr
)
/*+++

Description:

    Given a response code from InitializeSecurityContext,
    set the appropriate state in the connection structure.

---*/
{

    ULONG err = LDAP_SUCCESS;

    switch ( sErr ) {

        case SEC_E_OK:

            Connection->SspiNeedsResponse = FALSE;
            Connection->SspiNeedsMoreData = FALSE;
            Connection->TokenNeedsCompletion = FALSE;
            break;

        case SEC_I_CONTINUE_NEEDED:

            Connection->SspiNeedsResponse = TRUE;
            Connection->SspiNeedsMoreData = FALSE;
            Connection->TokenNeedsCompletion = FALSE;
            break;

        case SEC_I_COMPLETE_NEEDED:

            Connection->TokenNeedsCompletion = TRUE;
            Connection->SspiNeedsResponse = FALSE;
            Connection->SspiNeedsMoreData = FALSE;
            break;

        case SEC_I_COMPLETE_AND_CONTINUE:

            Connection->SspiNeedsResponse = TRUE;
            Connection->TokenNeedsCompletion = TRUE;
            Connection->SspiNeedsMoreData = FALSE;
            break;

        case SEC_E_INCOMPLETE_MESSAGE:

            //
            // If the error is incomplete message, don't
            // touch any other parts of the state - we still
            // need them.
            //

            Connection->SspiNeedsMoreData = TRUE;
            break;

        default:

            err = LdapConvertSecurityError( Connection, sErr );

            IF_DEBUG(NETWORK_ERRORS) {

                LdapPrint2(
                    "LdapSetSspiContinueState: Conn 0x%x received 0x%x.\n",
                    Connection, sErr
                );
            }

            break;
    }

    return err;

}

VOID
LdapClearSspiState(
    PLDAP_CONN Connection
) {

    Connection->SspiNeedsResponse = FALSE;
    Connection->SspiNeedsMoreData = FALSE;
    Connection->TokenNeedsCompletion = FALSE;
    Connection->CurrentAuthLeg = 0;

}


ULONG
LdapExchangeOpaqueToken(
    PLDAP_CONN Connection,
    ULONG UserMethod,
    PWCHAR MethodOID,
    PWCHAR UserName,
    PVOID pOutboundToken,
    ULONG cbTokenLength,
    SecBufferDesc *pInboundToken,
    BERVAL **ServerCred,
    PLDAPControlW  *ServerControls,
    PLDAPControlW  *ClientControls,
    PULONG  MessageNumber,
    BOOLEAN SendOnly,
    BOOLEAN Unicode,
    BOOLEAN * pSentMessage    
)
/*+++

Description:

    This routine takes the opaque SSPI token and exchanges it with
    the server specified in the connection structure.  The format
    of the token depends on the user method specified.

Arguments:

    Connection     - The connection we are binding.
    UserMethod     - The user specified method for bind (affect packet format).
    UserName       - The user to bind.
    pOutboundToken - The outbound opaque SSPI token for the user.
    cbTokenLength  - The length of the outbound token.
    pInboundToken  - The security buffer descriptor for the inbound token.

 ---*/
{
    ULONG hr;
    CLdapBer lber( Connection->publicLdapStruct.ld_version );
    ULONG LdapErr;
    PLDAP_REQUEST LdapRequest;
    PLDAPMessage LdapMessage = NULL;
    CLdapBer *ReplyBer;
    ULONG WaitTime;
    PWCHAR ErrorMessage = NULL;

    //
    // We have to support these bind methods:
    //
    //     LDAP_AUTH_SICILY
    //     LDAP_AUTH_NEGOTIATE
    //     LDAP_AUTH_DPA
    //     LDAP_AUTH_MSN
    //     LDAP_AUTH_NTLM
    //     LDAP_AUTH_SASL
    //
    // These are not valid on this path:
    //
    //     LDAP_AUTH_SIMPLE
    //

    //
    // Allocate the request.
    //

    ldap_msgfree( Connection->BindResponse );
    Connection->BindResponse = NULL;

    LdapRequest = LdapCreateRequest( Connection, LDAP_BIND_CMD );

    if ( LdapRequest == NULL ) {
        return LDAP_NO_MEMORY;
    }

    LdapRequest->ChaseReferrals = 0;
    
    //
    // Make sure this no other waiting thread steals a response meant
    // for us.
    //

    LdapRequest->Synchronous = TRUE;

    //
    // Figure out how the packet should look.
    //

    switch ( UserMethod ) {

        case LDAP_AUTH_SICILY:
        case LDAP_AUTH_DPA:
        case LDAP_AUTH_MSN:
        case LDAP_AUTH_NTLM:

            LONG SicilyAuthTag;

            LdapErr = LDAP_ENCODING_ERROR;

            hr = lber.HrStartWriteSequence();
            if (hr != NOERROR) {
                goto ExitWithCleanup;
            }

            hr = lber.HrAddValue( (LONG) LdapRequest->MessageId );
            if (hr != NOERROR) {
                goto ExitWithCleanup;
            }

            hr = lber.HrStartWriteSequence( LDAP_BIND_CMD );
            if (hr != NOERROR) {
                goto ExitWithCleanup;
            }

                hr = lber.HrAddValue( (LONG) Connection->publicLdapStruct.ld_version );
                if (hr != NOERROR) {
                    goto ExitWithCleanup;
                }

                //
                // Set the leg specific data.
                //

                if ( Connection->CurrentAuthLeg == 0 ) {

                   SicilyAuthTag = BIND_SSPI_NEGOTIATE;

                   hr = lber.HrAddValue( (const WCHAR *) UserName );
                   if (hr != NOERROR) {
                       goto ExitWithCleanup;
                   }

                } else {

                   SicilyAuthTag = BIND_SSPI_RESPONSE;

                   hr = lber.HrAddValue( (const CHAR *) "" );
                   if (hr != NOERROR) {
                       goto ExitWithCleanup;
                   }

                }

                hr = lber.HrAddBinaryValue( (BYTE *)pOutboundToken,
                                            cbTokenLength,
                                            SicilyAuthTag );
                if (hr != NOERROR) {
                    goto ExitWithCleanup;
                }

            hr = lber.HrEndWriteSequence();
            if (hr != NOERROR) {
                goto ExitWithCleanup;
            }

            hr = lber.HrEndWriteSequence();
            if (hr != NOERROR) {
                goto ExitWithCleanup;
            }

            break;

    case LDAP_AUTH_NEGOTIATE:
    case LDAP_AUTH_SASL:
    case LDAP_AUTH_DIGEST:

            LdapErr = LDAP_ENCODING_ERROR;

            hr = lber.HrStartWriteSequence();
            if (hr != NOERROR) {
                goto ExitWithCleanup;
            }

                hr = lber.HrAddValue( (LONG) LdapRequest->MessageId );
                if (hr != NOERROR) {
                    goto ExitWithCleanup;
                }

                hr = lber.HrStartWriteSequence( LDAP_BIND_CMD );
                if (hr != NOERROR) {
                    goto ExitWithCleanup;
                }

                    hr = lber.HrAddValue( (LONG) Connection->publicLdapStruct.ld_version );
                    if (hr != NOERROR) {
                        goto ExitWithCleanup;
                    }

                    hr = lber.HrAddValue( (const WCHAR *) UserName );
                    if (hr != NOERROR) {
                        goto ExitWithCleanup;
                    }

                    //
                    // Now add the SASL wrapper
                    //

                    hr = lber.HrStartWriteSequence( BER_TAG_CONSTRUCTED );
                    if (hr != NOERROR) {
                        goto ExitWithCleanup;
                    }

                    if ((MethodOID != NULL)) {

                        //
                        // User has explicitly requested a sasl method. Stick to it.
                        //

                        hr = lber.HrAddValue( (const WCHAR *) MethodOID );

                    } else if ((UserMethod == LDAP_AUTH_NEGOTIATE) &&
                               (Connection->SupportsGSS_SPNEGO == TRUE) &&
                               (MethodOID == NULL)) {

                        //
                        // This is a NT5 Beta3 server which expects a negotiate
                        // blob or a third pary server which expects a negotiate
                        // blob. Also, the user has not specified a preferred package
                        // to be used.
                        //

                        hr = lber.HrAddValue( (const CHAR *) "GSS-SPNEGO" );

                    } else if (UserMethod == LDAP_AUTH_DIGEST) {

                        hr = lber.HrAddValue( (const CHAR *) "DIGEST-MD5" );
                        
                    } else {

                        //
                        // Send a GSSAPI request. This could be a Beta2 server
                        // or third party server expecting true Kerberos. A true
                        // kerberos blob will be sent *only* if user sets
                        // LDAP_OPT_SASL_METHOD with "GSSAPI". We should remove
                        // this behavior after Beta3.
                        //

                        hr = lber.HrAddValue( (const CHAR *) "GSSAPI" );
                    }

                        if (hr != NOERROR) {
                            goto ExitWithCleanup;
                        }

                        hr = lber.HrAddBinaryValue( (BYTE *)pOutboundToken,
                                                    cbTokenLength );

                        if (hr != NOERROR) {
                            goto ExitWithCleanup;
                        }

                    hr = lber.HrEndWriteSequence();
                    if (hr != NOERROR) {
                        goto ExitWithCleanup;
                    }

                hr = lber.HrEndWriteSequence();
                if (hr != NOERROR) {
                    goto ExitWithCleanup;
                }

            hr = lber.HrEndWriteSequence();
            if (hr != NOERROR) {
                goto ExitWithCleanup;
            }

            break;

        default:

            //
            // Unsupported authentication type.
            //

            IF_DEBUG(ERRORS) {
                LdapPrint1( "LdapExchangeOpaqueToken: Unsupported authentication type %d.\n",
                            UserMethod );
            }

            LdapErr = LDAP_AUTH_METHOD_NOT_SUPPORTED;
            goto ExitWithCleanup;
    }

    //
    // See if we need to process controls
    //

    if (ServerControls || ClientControls) {

        LdapErr = LdapCheckControls( LdapRequest,
                                     ServerControls,
                                     ClientControls,
                                     Unicode,         // unicode?
                                     0 );

        if ( (Connection->publicLdapStruct.ld_version != LDAP_VERSION2) &&
             ( LdapRequest->ServerControls != NULL )) {

            LdapErr = InsertServerControls( LdapRequest, Connection, &lber );

            if (LdapErr != LDAP_SUCCESS) {

                goto ExitWithCleanup;
            }
        }
    }
    //
    // Send the packet and get the response token.
    //

    ACQUIRE_LOCK( &Connection->ReconnectLock );

    AddToPendingList( LdapRequest, Connection );

    LdapErr = LdapSend( Connection, &lber );

    if ( LdapErr != LDAP_SUCCESS ) {

        DecrementPendingList( LdapRequest, Connection );
        RELEASE_LOCK( &Connection->ReconnectLock );
        goto ExitWithCleanup;
    }

    if (pSentMessage) {
        *pSentMessage = TRUE;
    }

    RELEASE_LOCK( &Connection->ReconnectLock );

    if ( SendOnly ) {

        *MessageNumber = LdapRequest->MessageId;
        goto ExitWithCleanup;
    }

    if ( Connection->publicLdapStruct.ld_timelimit ) {
        WaitTime = Connection->publicLdapStruct.ld_timelimit * 1000;
    } else {
        WaitTime = LDAP_BIND_TIME_LIMIT_DEFAULT;
    }

    LdapErr = LdapWaitForResponseFromServer( Connection,
                                             LdapRequest,
                                             WaitTime,
                                             FALSE,
                                             &LdapMessage,
                                             TRUE     // Disable autorec during bind
                                             );

    Connection->BindResponse = LdapMessage;

    if ( (LdapErr != LDAP_SUCCESS) && (LdapMessage == NULL)) {

        goto ExitWithCleanup;
    }

    if ( LdapMessage == NULL ) {
        IF_DEBUG(SERVERDOWN) {
            LdapPrint2( "ldapExchangeOpaque thread 0x%x has connection 0x%x as down.\n",
                            GetCurrentThreadId(),
                            Connection );
        }
        LdapErr = LDAP_SERVER_DOWN;
        goto ExitWithCleanup;
    }

    LdapErr = LdapMessage->lm_returncode;

    if (( LdapErr != LDAP_SUCCESS ) &&
        ( LdapErr != LDAP_SASL_BIND_IN_PROGRESS ))  {

        LdapPrint1("Bailing out of LdapExchangeOpaqueToken because server returned 0x%x\n", LdapErr);
        goto ExitWithCleanup;
    }

    //
    // Describe the inbound token from the message.
    //

    ReplyBer = (CLdapBer*) LdapMessage->lm_ber;

    if (ReplyBer == NULL) {

        hr = LDAP_LOCAL_ERROR;
        goto ExitWithCleanup;
    }

    if ( ( UserMethod == LDAP_AUTH_SICILY ) ||
         ( UserMethod == LDAP_AUTH_MSN ) ||
         ( UserMethod == LDAP_AUTH_DPA ) ||
         ( UserMethod == LDAP_AUTH_NTLM )) {

        //
        // Neither v2 nor v3 exactly.
        //
        LdapErr = LDAP_DECODING_ERROR;
        

        hr = ReplyBer->HrGetBinaryValuePointer(
                 (PBYTE *) &(pInboundToken->pBuffers[0].pvBuffer),
                           &(pInboundToken->pBuffers[0].cbBuffer)
             );
        if ( hr != NOERROR ) {
            goto ExitWithCleanup;
        }

    } else if ( (( UserMethod == LDAP_AUTH_NEGOTIATE ) || ( UserMethod == LDAP_AUTH_DIGEST )) || 
                (( UserMethod == LDAP_AUTH_SASL ) && ( ServerCred )) ) {

        ULONG Tag;
        LdapErr = LDAP_DECODING_ERROR;

        //
        // Skip the matched DN.
        //

        hr = ReplyBer->HrSkipElement();
        if (hr != NOERROR) {
            goto ExitWithCleanup;
        }

        //
        // Skip the error message.
        //

        hr = ReplyBer->HrSkipElement();
        if (hr != NOERROR) {
            goto ExitWithCleanup;
        }

        //
        // Check for the optional elements.
        //

        hr = ReplyBer->HrPeekTag( &Tag );

        if (hr == NOERROR) {
        
            //
            // Got a optional element
            //

            if ( Tag == 0x83 ) {    /* Referral */

               hr = ReplyBer->HrSkipElement();
               if (hr != NOERROR) {
                   goto ExitWithCleanup;
               }

               hr = ReplyBer->HrPeekTag( &Tag );
               if (hr != NOERROR) {
                   goto ExitWithCleanup;
               }
            }

            if ( Tag == 0x85 ) {    /* SupportedVersion */

               hr = ReplyBer->HrSkipElement();
               if (hr != NOERROR) {
                   goto ExitWithCleanup;
               }

               hr = ReplyBer->HrPeekTag( &Tag );
               if (hr != NOERROR) {
                   goto ExitWithCleanup;
               }
            }

            if ( Tag == 0x86 ) {    /* ServerURL */

               hr = ReplyBer->HrSkipElement();
               if (hr != NOERROR) {
                   goto ExitWithCleanup;
               }

               hr = ReplyBer->HrPeekTag( &Tag );
               if (hr != NOERROR) {
                   goto ExitWithCleanup;
               }
            }


            if ( Tag == 0xa7 ) {

                //
                // This is the old style bind response returned from the
                // server. You never know when you might need this code for 
                // backward compatibility. Better to be safe than sorry.
                //
                // BindResponse ::= [APPLICATION 1] SEQUENCE {
                //      COMPONENTS OF LDAPResult,
                //      serverCreds    [7] SaslCredentials OPTIONAL }
                //
                // SaslCredentials ::= SEQUENCE {
                //      mechanism      LDAPString,
                //      credentials    OCTET STRING }
                //
                // We are at the constructed, context-specific
                // option 7, which is the SaslCredentials.
                //

                hr = ReplyBer->HrStartReadSequence( Tag );
                if (hr != NOERROR) {
                    goto ExitWithCleanup;
                }

                //
                // We should be at the constructed, context-specific
                // option 3, which is the SASL packet.
                //

                hr = ReplyBer->HrPeekTag( &Tag );
                if (hr != NOERROR) {
                    goto ExitWithCleanup;
                }

                if ( Tag != 0xa3 ) {
                    goto ExitWithCleanup;
                }

                hr = ReplyBer->HrStartReadSequence( Tag );
                if (hr != NOERROR) {
                    goto ExitWithCleanup;
                }

                //
                // Skip the name element, which we know
                // to be GSSAPI.
                //

                hr = ReplyBer->HrSkipElement();
                if (hr != NOERROR) {
                    goto ExitWithCleanup;
                }

                if ( ServerCred )
                {
                    //
                    // Copy the data to a berval signature
                    //

                    hr = ReplyBer->HrGetValueWithAlloc( ServerCred, TRUE );
                }
                else {

                    hr = ReplyBer->HrGetBinaryValuePointer(
                                        (PBYTE *) &(pInboundToken->pBuffers[0].pvBuffer),
                                        &(pInboundToken->pBuffers[0].cbBuffer) );

                }

                if ( hr != NOERROR ) {
                    goto ExitWithCleanup;
                }
				

            } else  if ( Tag == 0x87 ) {

                //
                // This is the new RFC 2251 style bind response.
                //
                // BindResponse ::= [APPLICATION 1] SEQUENCE {
                //          COMPONENTS OF LDAPResult,
                //          serverSaslCreds    [7] OCTET STRING OPTIONAL }
                //
                // ServerSaslCreds is a primitive encoding of context-specific option 7.
                //

                if ( ServerCred )
                {
                    //
                    // Copy the data to a berval signature
                    //

                    hr = ReplyBer->HrGetValueWithAlloc( ServerCred, TRUE );
                }
                else {
                
                    hr = ReplyBer->HrGetBinaryValuePointer(
                                        (PBYTE *) &(pInboundToken->pBuffers[0].pvBuffer),
                                        &(pInboundToken->pBuffers[0].cbBuffer),
                                        Tag );
                }

                if (hr != NOERROR) {
                    goto ExitWithCleanup;

                }
					

            } else {

                //
                // If the server does not return the credential blob, we let SSPI
                // flag an error at a later stage.
                //

                goto ExitWithCleanup;

            }
        }

    }

    //
    // We parsed the response, so all must be ok.
    // Bump the authentication leg counter and return.
    // We don't free the LDAP request here since it contains
    // the response and we have to pass that to SSPI.
    //

    Connection->CurrentAuthLeg++;
    LdapErr = LDAP_SUCCESS;

ExitWithCleanup:

    //
    // Try to get back a server Error string if one was returned.
    //

    if (LdapMessage) {

        LdapParseResult(Connection,
                        LdapMessage,
                        0,                   // return code
                        NULL,                // Matched DNs
                        &ErrorMessage,       // Server returned err msg
                        NULL,                // No need for referrals
                        NULL,                // or controls
                        FALSE,               // and don't free the message
                        LANG_UNICODE
                        );

        InsertErrorMessage( Connection, ErrorMessage );
    }

    CloseLdapRequest( LdapRequest );

    DereferenceLdapRequest( LdapRequest );

    if ((LdapErr != LDAP_SUCCESS) || (ServerCred != NULL)) {

        ldap_msgfree( Connection->BindResponse );
        Connection->BindResponse = NULL;
    }

    return LdapErr;
}

ULONG
LdapGetSicilyPackageList(
    PLDAP_CONN Connection,
    PBYTE PackageList,
    ULONG Length,
    PULONG pResponseLen
)
/*+++

Description:

    This sends the package list request to a sicily server.

    Connection  - The connection to the sicily server.
    PackageList - The buffer to write the package list into.
    Length      - The length of the buffer.

---*/
{

    ULONG hr;
    CLdapBer lber( Connection->publicLdapStruct.ld_version );
    CLdapBer *ReplyBer;
    ULONG LdapErr = LDAP_ENCODING_ERROR;
    PLDAP_REQUEST LdapRequest;
    PLDAPMessage LdapMessage = NULL;

    //
    // Form up the package request.
    //

    LdapRequest = LdapCreateRequest( Connection, LDAP_BIND_CMD );

    if ( LdapRequest == NULL ) {
        return LDAP_NO_MEMORY;
    }

    LdapRequest->ChaseReferrals = FALSE;

    hr = lber.HrStartWriteSequence();
    if ( hr != NOERROR ) {
        goto ExitWithCleanup;
    }

    hr = lber.HrAddValue( (LONG) LdapRequest->MessageId );
    if ( hr != NOERROR ) {
        goto ExitWithCleanup;
    }

    hr = lber.HrStartWriteSequence( LDAP_BIND_CMD );
    if ( hr != NOERROR ) {
        goto ExitWithCleanup;
    }

        hr = lber.HrAddValue( (LONG) Connection->publicLdapStruct.ld_version );
        if ( hr != NOERROR ) {
            goto ExitWithCleanup;
        }

        hr = lber.HrAddValue( (const CHAR *) NULL );
        if ( hr != NOERROR ) {
            goto ExitWithCleanup;
        }

        hr = lber.HrAddBinaryValue( (BYTE *) NULL, 0, BIND_SSPI_PACKAGEREQ );
        if ( hr != NOERROR ) {
            goto ExitWithCleanup;
        }

    hr = lber.HrEndWriteSequence();
    if ( hr != NOERROR ) {
        goto ExitWithCleanup;
    }

    hr = lber.HrEndWriteSequence();
    if ( hr != NOERROR ) {
        goto ExitWithCleanup;
    }

    //
    // Send the packet and get the response.
    //

    AddToPendingList( LdapRequest, Connection );

    LdapErr = LdapSend( Connection, &lber );

    if ( LdapErr != LDAP_SUCCESS ) {

        DecrementPendingList( LdapRequest, Connection );
        goto ExitWithCleanup;
    }

    LdapErr = LdapWaitForResponseFromServer( Connection,
                                             LdapRequest,
                                             LDAP_BIND_TIME_LIMIT_DEFAULT,
                                             FALSE,
                                             &LdapMessage,
                                             TRUE     // Disable autorec during bind
                                             );

    if ( ( LdapErr != LDAP_SUCCESS ) && (LdapMessage == NULL) ) {
        goto ExitWithCleanup;
    }

    if ( LdapMessage == NULL ) {
        IF_DEBUG(SERVERDOWN) {
            LdapPrint2( "ldapGetSicilyList thread 0x%x has connection 0x%x as down.\n",
                            GetCurrentThreadId(),
                            Connection );
        }
        LdapErr = LDAP_SERVER_DOWN;
        goto ExitWithCleanup;
    }

    LdapErr = LdapMessage->lm_returncode;

    if ( LdapErr != LDAP_SUCCESS ) {
        goto ExitWithCleanup;
    }

    //
    // Copy out the package list.
    //

    ReplyBer = (CLdapBer*) LdapMessage->lm_ber;

    if (ReplyBer == NULL) {

        hr = LDAP_LOCAL_ERROR;
        goto ExitWithCleanup;
    }

    hr = ReplyBer->HrGetBinaryValue( PackageList,
                                     Length,
                                     BER_OCTETSTRING,
                                     pResponseLen );

    if ( hr != NOERROR ) {
        LdapErr = LDAP_DECODING_ERROR;
        goto ExitWithCleanup;
    }

    LdapErr = LDAP_SUCCESS;

ExitWithCleanup:

    if ( LdapMessage != NULL ) {
        ldap_msgfree( LdapMessage );
    }

    CloseLdapRequest( LdapRequest );

    DereferenceLdapRequest( LdapRequest );

    return LdapErr;

}

ULONG
LdapTryAllMsnAuthentication(
    PLDAP_CONN Connection,
    PWCHAR BindCred
    )
{

    ULONG LdapErr, ResponseLen, PackageCount = 0, Len = 0;
    PBYTE PackageList = NULL;
    PWCHAR CurrentPackage = NULL, wPackageList = NULL;
    PSecPkgInfoW SecurityPackage;

    //
    // Negotiate the supported sicily packages.
    //


   PackageList = (PBYTE) ldapMalloc( GENERIC_SECURITY_SIZE,
                                     LDAP_SECURITY_SIGNATURE );

   if ( PackageList == NULL ) {
       return LDAP_NO_MEMORY;
   }

   LdapErr = LdapGetSicilyPackageList( Connection,
                                       PackageList,
                                       GENERIC_SECURITY_SIZE,
                                       &ResponseLen );

   if ( LdapErr != LDAP_SUCCESS ) {
       goto ExitWithCleanup;
   }

   //
   // convert the ANSI packagelist into Unicode
   //

   LdapErr = ToUnicodeWithAlloc ( (PCHAR) PackageList,
                                  ResponseLen,
                                  &wPackageList,
                                  LDAP_UNICODE_SIGNATURE,
                                  LANG_ACP
                                  );

   if ( LdapErr != LDAP_SUCCESS ) {
       goto ExitWithCleanup;
   }

   //
   // Convert the semicolon separators to NULLs.
   //

   CurrentPackage = wPackageList;

   while ( Len < ResponseLen ) {

       if ( *CurrentPackage == L';' ) {
           *CurrentPackage = L'\0';
           PackageCount++;
       }

       Len++;
       CurrentPackage++;
   }

   //
   // Don't forget to include the last package.
   //

   *CurrentPackage = L'\0';
   PackageCount++;

   CurrentPackage = wPackageList;

   //
   // Try to authenticate using each package until success.
   //

   LdapErr = LDAP_AUTH_METHOD_NOT_SUPPORTED;

   while ( ( LdapErr != LDAP_SUCCESS ) &&
           ( PackageCount > 0 ) ) {

       SecurityPackage = NULL;

       if ( ldapWStringsIdentical(
                           (const PWCHAR)CurrentPackage,
                           -1,
                           L"MSN",
                           -1 )) {

          SecurityPackage = SspiPackageSicily;

      } else if ( ldapWStringsIdentical(
                                 (const PWCHAR)CurrentPackage,
                                  -1,
                                  L"DPA",
                                  -1 )) {

          SecurityPackage = SspiPackageDpa;

      } else if ( ldapWStringsIdentical(
                                 (const PWCHAR)CurrentPackage,
                                  -1,
                                  L"NTLM",
                                  -1 )) {

          SecurityPackage = SspiPackageNtlm;

      }

      if ( SecurityPackage ) {

          LdapErr = LdapSspiBind( Connection,
                                  SecurityPackage,
                                  LDAP_AUTH_SICILY,
                                  0,
                                  CurrentPackage,
                                  NULL,
                                  BindCred );

          if ( ( LdapErr == LDAP_INVALID_CREDENTIALS ) &&
               ( SecurityPackage != SspiPackageNtlm ) ) {

              //
              //  if we've prompted the user for credentials and it failed
              //  with an invalid password, we fail the call since we
              //  prompted the user for a password.
              //

              goto ExitWithCleanup;
          }
      }

      //
      // Find the next package.
      //

      while ( *CurrentPackage != '\0' ) {
          CurrentPackage++;
      }

      CurrentPackage++;
      PackageCount--;

   }

ExitWithCleanup:

    ldapFree( PackageList, LDAP_SECURITY_SIGNATURE );
    ldapFree( wPackageList, LDAP_UNICODE_SIGNATURE );

    return LdapErr;
}

ULONG
LdapSetupSslSession (
    PLDAP_CONN Connection
    )
//
//  This must return a Win32 error code.
//
{

    ULONG err;
    PSECURESTREAM pSecureStream;

    (VOID) LdapInitSsl();

    if ( SspiPackageSslPct == NULL ) {
       return ERROR_NO_SUCH_PACKAGE;
    }

    ACQUIRE_LOCK( &Connection->StateLock );

    //
    // You can not negotiate an SSL connection while
    // a bind is in progress b/c the two procedures
    // use some common state variables...
    //

    if ( Connection->BindInProgress ) {
        RELEASE_LOCK( &Connection->StateLock );
        return ERROR_LOGON_SESSION_COLLISION;
    }

    //
    // You can't negotiate a secure connection more than once.
    //

    if ( Connection->SecureStream ) {
        RELEASE_LOCK( &Connection->StateLock );
        return ERROR_LOGON_SESSION_COLLISION;
    }

    //
    // You can't have both sealing/signing and SSL at the same time.
    //

    if ( Connection->UserSignDataChoice || Connection->UserSealDataChoice || Connection->CurrentSignStatus || Connection->CurrentSealStatus) {
        RELEASE_LOCK( &Connection->StateLock );
        return LDAP_UNWILLING_TO_PERFORM;
    }

    Connection->BindInProgress = TRUE;
    Connection->SslSetupInProgress = TRUE;

    LdapClearSspiState( Connection );

    RELEASE_LOCK( &Connection->StateLock );

    //
    // Set up the connection via the steam management object.
    //

    ASSERT( SslFunctionTableW != NULL );

    pSecureStream = new CryptStream( Connection, SslFunctionTableW, TRUE );

    if ( pSecureStream == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    err = pSecureStream->NegotiateSecureConnection( SspiPackageSslPct );

    if ( err != 0 ) {
        delete pSecureStream;
        Connection->SecureStream = NULL;
    } else {
        Connection->SecureStream = (PVOID)pSecureStream;
    }

    Connection->BindInProgress = FALSE;
    Connection->SslSetupInProgress = FALSE;

    return err;

}

ULONG
LdapMakeCredsWide(
    PCHAR pAnsiAuthIdent,
    PCHAR *ppWideAuthIdent,
    BOOLEAN FromWide
)
/*+++

Description:

    Take a SEC_WINNT_AUTH_IDENTITY_A and return
    a SEC_WINNT_AUTH_IDENTITY_W.  We do this because
    the NT SSPI providers only support unicode.  The
    caller must free the SEC_WINNT_AUTH_IDENTITY_W.

    Note that the lengths in this structure are the
    number the wchars in the string, but the strings
    still must be NULL terminated.

 ---*/
{

    PSEC_WINNT_AUTH_IDENTITY_A pIncoming;
    PSEC_WINNT_AUTH_IDENTITY_W pOutgoing = NULL;
    ULONG dwBytesNeeded, dwWcharsWritten;
    PWCHAR outputBuff;

    pIncoming = ( PSEC_WINNT_AUTH_IDENTITY_A ) pAnsiAuthIdent;

    //
    // Compute the necessary target buffer size.
    //
    // Account for possible alignment byte needed.
    //

    dwBytesNeeded = sizeof( SEC_WINNT_AUTH_IDENTITY_W ) + 1;

    dwBytesNeeded += ( ( pIncoming->UserLength + 1 ) * sizeof( WCHAR ) );
    dwBytesNeeded += ( ( pIncoming->DomainLength + 1 ) * sizeof( WCHAR ) );
    dwBytesNeeded += ( ( pIncoming->PasswordLength + 1 ) * sizeof( WCHAR ) );

    // We'll need up to DES_BLOCKLEN-1 bytes of padding for RtlEncryptMemory
    // (plus 1 byte for alignment if that is a odd number)
    dwBytesNeeded += (DES_BLOCKLEN-1);
    dwBytesNeeded += ((((DES_BLOCKLEN-1)%2) == 0) ? 0 : 1);

    //
    // Allocate the block.
    //

    pOutgoing = ( PSEC_WINNT_AUTH_IDENTITY_W )
                ldapMalloc( dwBytesNeeded, LDAP_SECURITY_SIGNATURE );

    if ( !pOutgoing ) {
        return LDAP_NO_MEMORY;
    }

    //
    // Set up the wide pointers, pre-marshalled.
    //

    outputBuff = (PWCHAR) ( ( ( PBYTE ) pOutgoing ) +
                                 sizeof( SEC_WINNT_AUTH_IDENTITY_W ) );

    // ensure alignment is correct for PUSHORT

    outputBuff = (PWCHAR)(PCHAR) ( (((ULONG_PTR) outputBuff) + 1) & ~1 );

    //
    // Convert the parameters to unicode.
    //

    if ( pIncoming->User ) {


        if ( pIncoming->UserLength ) {

            if (FromWide == TRUE) {

                dwWcharsWritten = pIncoming->UserLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->User,
                            dwWcharsWritten * sizeof(WCHAR) );
            } else {

                dwWcharsWritten = MultiByteToWideChar( CP_ACP,
                                                       0,
                                                       (const char *)pIncoming->User,
                                                       pIncoming->UserLength,
                                                       outputBuff,
                                                       pIncoming->UserLength );

                if (dwWcharsWritten == 0) {
                    goto exitWithCleanup;
                }
                
            }
        } else {

            dwWcharsWritten = 0;
        }

        pOutgoing->UserLength = dwWcharsWritten;
        pOutgoing->User = (unsigned short *)outputBuff;

        outputBuff += dwWcharsWritten;
        *(outputBuff++) = L'\0';

    } else {

        pOutgoing->User = NULL;
        pOutgoing->UserLength = 0;
    }

    if ( pIncoming->Domain ) {

        if ( pIncoming->DomainLength ) {

            if (FromWide == TRUE) {

                dwWcharsWritten = pIncoming->DomainLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->Domain,
                            dwWcharsWritten * sizeof(WCHAR) );
            } else {

                dwWcharsWritten = MultiByteToWideChar( CP_ACP,
                                                       0,
                                                       (const char *)pIncoming->Domain,
                                                       pIncoming->DomainLength,
                                                       outputBuff,
                                                       pIncoming->DomainLength );

                if (dwWcharsWritten == 0) {
                    goto exitWithCleanup;
                }                                       
            }
        } else {

            dwWcharsWritten = 0;
        }

        pOutgoing->DomainLength = dwWcharsWritten;
        pOutgoing->Domain = (unsigned short *)outputBuff;

        outputBuff += dwWcharsWritten;
        *(outputBuff++) = L'\0';

    } else {

        pOutgoing->Domain = NULL;
        pOutgoing->DomainLength = 0;
    }

    if ( pIncoming->Password ) {

        if ( pIncoming->PasswordLength ) {

            if (FromWide == TRUE) {

                dwWcharsWritten = pIncoming->PasswordLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->Password,
                            dwWcharsWritten * sizeof(WCHAR) );
            } else {

                dwWcharsWritten = MultiByteToWideChar( CP_ACP,
                                                      0,
                                                      (const char *)pIncoming->Password,
                                                      pIncoming->PasswordLength,
                                                      outputBuff,
                                                      pIncoming->PasswordLength );
                if (dwWcharsWritten == 0) {
                    goto exitWithCleanup;
                }                                                                                            
            }
        } else {

            dwWcharsWritten = 0;
        }

        pOutgoing->PasswordLength = dwWcharsWritten;
        pOutgoing->Password = (unsigned short *)outputBuff;

        outputBuff += dwWcharsWritten;
        *(outputBuff++) = L'\0';

        // advance the buffer ptr by however many padding bytes we added.
        // outputBuff is a WCHAR ptr, so we have to convert from bytes to WCHARs
        outputBuff += (((DES_BLOCKLEN-1) + ((((DES_BLOCKLEN-1)%2) == 0) ? 0 : 1)) / sizeof (WCHAR));

    } else {

        pOutgoing->Password = NULL;
        pOutgoing->PasswordLength = 0;
    }

    //
    // Stuff in the flags and return.
    //

    pOutgoing->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    *ppWideAuthIdent = ( PCHAR ) pOutgoing;

    return LDAP_SUCCESS;

exitWithCleanup:

    if (pOutgoing) {
        ldapSecureFree(pOutgoing, LDAP_SECURITY_SIGNATURE);
    }

    return LDAP_NO_MEMORY;
}

ULONG
LdapMakeCredsThin(
    PCHAR pWideAuthIdent,
    PCHAR *ppAnsiAuthIdent,
    BOOLEAN FromWide
)
/*+++

Description:

    Take a SEC_WINNT_AUTH_IDENTITY_W and return
    a SEC_WINNT_AUTH_IDENTITY_A.  We do this because
    the Win9x SSPI providers only support ansi.  The
    caller must free the SEC_WINNT_AUTH_IDENTITY_A.

    Note that the lengths in this structure are the
    number the chars in the string, but the strings
    still must be NULL terminated.

 ---*/
{

    PSEC_WINNT_AUTH_IDENTITY_W pIncoming;
    PSEC_WINNT_AUTH_IDENTITY_A pOutgoing = NULL;
    ULONG dwBytesNeeded, dwCharsWritten;
    PUCHAR outputBuff;

    pIncoming = ( PSEC_WINNT_AUTH_IDENTITY_W ) pWideAuthIdent;

    //
    // Compute the necessary target buffer size.
    //
    // Account for possible alignment byte needed.
    //

    dwBytesNeeded = sizeof( SEC_WINNT_AUTH_IDENTITY_A ) + 1;

    //
    //  We multiply by 2 so that we don't worry about long DBCS names.
    //

    dwBytesNeeded += ( pIncoming->UserLength + 1 ) * sizeof(WCHAR);
    dwBytesNeeded += ( pIncoming->DomainLength + 1 ) * sizeof(WCHAR);
    dwBytesNeeded += ( pIncoming->PasswordLength + 1 ) * sizeof(WCHAR);

    // We'll need up to DES_BLOCKLEN-1 bytes of padding for RtlEncryptMemory
    // (plus 1 byte for alignment if that is a odd number)
    dwBytesNeeded += (DES_BLOCKLEN-1);
    dwBytesNeeded += ((((DES_BLOCKLEN-1)%2) == 0) ? 0 : 1);

    //
    // Allocate the block.
    //

    pOutgoing = ( PSEC_WINNT_AUTH_IDENTITY_A )
                ldapMalloc( dwBytesNeeded, LDAP_SECURITY_SIGNATURE );

    if ( !pOutgoing ) {
        return LDAP_NO_MEMORY;
    }

    //
    // Set up the wide pointers, pre-marshalled.
    //

    outputBuff = (PUCHAR) ( ( ( PBYTE ) pOutgoing ) +
                                 sizeof( SEC_WINNT_AUTH_IDENTITY_A ) );

    //
    // Convert the parameters from unicode.
    //

    if ( pIncoming->User ) {

        if ( pIncoming->UserLength ) {

            if (FromWide == FALSE) {

                dwCharsWritten = pIncoming->UserLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->User,
                            dwCharsWritten );
            } else {

                dwCharsWritten = WideCharToMultiByte(  CP_ACP,
                                                       0,
                                                       (LPCWSTR)pIncoming->User,
                                                       pIncoming->UserLength,
                                                       (PCHAR) outputBuff,
                                                       pIncoming->UserLength + 1,
                                                       NULL,
                                                       NULL );
                if (dwCharsWritten == 0) {
                    goto exitWithCleanup;
                }                                                                                      
            }
        } else {

            dwCharsWritten = 0;
        }

        pOutgoing->UserLength = dwCharsWritten;
        pOutgoing->User = outputBuff;

        outputBuff += dwCharsWritten;
        *(outputBuff++) = '\0';

    } else {

        pOutgoing->User = NULL;
        pOutgoing->UserLength = 0;
    }

    if ( pIncoming->Domain ) {

        if ( pIncoming->DomainLength ) {

            if (FromWide == FALSE) {

                dwCharsWritten = pIncoming->DomainLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->Domain,
                            dwCharsWritten );
            } else {

                dwCharsWritten =  WideCharToMultiByte(  CP_ACP,
                                                       0,
                                                       (LPCWSTR)pIncoming->Domain,
                                                       pIncoming->DomainLength,
                                                       (PCHAR) outputBuff,
                                                       pIncoming->DomainLength + 1,
                                                       NULL,
                                                       NULL );
                                                       
                if (dwCharsWritten == 0) {
                    goto exitWithCleanup;
                }                                                                                                                                             
            }
        } else {

            dwCharsWritten = 0;
        }

        pOutgoing->DomainLength = dwCharsWritten;
        pOutgoing->Domain = outputBuff;

        outputBuff += dwCharsWritten;
        *(outputBuff++) = '\0';

    } else {

        pOutgoing->Domain = NULL;
        pOutgoing->DomainLength = 0;
    }

    if ( pIncoming->Password ) {

        if ( pIncoming->PasswordLength ) {

            if (FromWide == FALSE) {

                dwCharsWritten = pIncoming->PasswordLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->Password,
                            dwCharsWritten );
            } else {

                dwCharsWritten =  WideCharToMultiByte( CP_ACP,
                                                       0,
                                                       (LPCWSTR)pIncoming->Password,
                                                       pIncoming->PasswordLength,
                                                       (PCHAR) outputBuff,
                                                       pIncoming->PasswordLength + 1,
                                                       NULL,
                                                       NULL );

                if (dwCharsWritten == 0) {
                    goto exitWithCleanup;
                }                                                                                                                                             
            }
        } else {

            dwCharsWritten = 0;
        }

        pOutgoing->PasswordLength = dwCharsWritten;
        pOutgoing->Password = outputBuff;

        outputBuff += dwCharsWritten;
        *(outputBuff++) = '\0';

        // advance the buffer ptr by however many padding bytes we added.
        // outputBuff is a WCHAR ptr, so we have to convert from bytes to WCHARs
        outputBuff += (((DES_BLOCKLEN-1) + ((((DES_BLOCKLEN-1)%2) == 0) ? 0 : 1)) / sizeof (WCHAR));

    } else {

        pOutgoing->Password = NULL;
        pOutgoing->PasswordLength = 0;
    }

    //
    // Stuff in the flags and return.
    //

    pOutgoing->Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

    *ppAnsiAuthIdent = ( PCHAR ) pOutgoing;

    return LDAP_SUCCESS;

exitWithCleanup:

    if (pOutgoing) {
        ldapSecureFree(pOutgoing, LDAP_SECURITY_SIGNATURE);
    }

    return LDAP_NO_MEMORY;    
}



ULONG
LdapMakeEXCredsWide(
    PCHAR pAnsiAuthIdent,
    PCHAR *ppWideAuthIdent,
    BOOLEAN FromWide
)
/*+++

Description:

    Take a SEC_WINNT_AUTH_IDENTITY_EXA and return
    a SEC_WINNT_AUTH_IDENTITY_EXW.  We do this because
    the NT SSPI providers only support unicode.  The
    caller must free the SEC_WINNT_AUTH_IDENTITY_W.

    Note that the lengths in this structure are the
    number the wchars in the string, but the strings
    still must be NULL terminated.

 ---*/
{

    PSEC_WINNT_AUTH_IDENTITY_EXA pIncoming;
    PSEC_WINNT_AUTH_IDENTITY_EXW pOutgoing = NULL;
    ULONG dwBytesNeeded, dwWcharsWritten;
    PWCHAR outputBuff;

    pIncoming = ( PSEC_WINNT_AUTH_IDENTITY_EXA ) pAnsiAuthIdent;

    //
    // Compute the necessary target buffer size.
    //
    // Account for possible alignment byte needed.
    //

    dwBytesNeeded = sizeof( SEC_WINNT_AUTH_IDENTITY_EXW ) + 1;

    dwBytesNeeded += ( ( pIncoming->UserLength + 1 ) * sizeof( WCHAR ) );
    dwBytesNeeded += ( ( pIncoming->DomainLength + 1 ) * sizeof( WCHAR ) );
    dwBytesNeeded += ( ( pIncoming->PasswordLength + 1 ) * sizeof( WCHAR ) );
    dwBytesNeeded += ( ( pIncoming->PackageListLength + 1 ) * sizeof( WCHAR ) );

    // We'll need up to DES_BLOCKLEN-1 bytes of padding for RtlEncryptMemory
    // (plus 1 byte for alignment if that is a odd number)
    dwBytesNeeded += (DES_BLOCKLEN-1);
    dwBytesNeeded += ((((DES_BLOCKLEN-1)%2) == 0) ? 0 : 1);

    //
    // Allocate the block.
    //

    pOutgoing = ( PSEC_WINNT_AUTH_IDENTITY_EXW )
                ldapMalloc( dwBytesNeeded, LDAP_SECURITY_SIGNATURE );

    if ( !pOutgoing ) {
        return LDAP_NO_MEMORY;
    }

    //
    // Set up the wide pointers, pre-marshalled.
    //

    outputBuff = (PWCHAR) ( ( ( PBYTE ) pOutgoing ) +
                                 sizeof( SEC_WINNT_AUTH_IDENTITY_EXW ) );

    // ensure alignment is correct for PUSHORT

    outputBuff = (PWCHAR)(PCHAR) ( (((ULONG_PTR) outputBuff) + 1) & ~1 );

    //
    // Convert the parameters to unicode.
    //

    if ( pIncoming->User ) {


        if ( pIncoming->UserLength ) {

            if (FromWide == TRUE) {

                dwWcharsWritten = pIncoming->UserLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->User,
                            dwWcharsWritten * sizeof(WCHAR) );
            } else {

                dwWcharsWritten = MultiByteToWideChar( CP_ACP,
                                                       0,
                                                       (const char *)pIncoming->User,
                                                       pIncoming->UserLength,
                                                       outputBuff,
                                                       pIncoming->UserLength );

                if (dwWcharsWritten == 0) {
                    goto exitWithCleanup;
                }                                                                                              
            }
        } else {

            dwWcharsWritten = 0;
        }

        pOutgoing->UserLength = dwWcharsWritten;
        pOutgoing->User = (unsigned short *)outputBuff;

        outputBuff += dwWcharsWritten;
        *(outputBuff++) = L'\0';

    } else {

        pOutgoing->User = NULL;
        pOutgoing->UserLength = 0;
    }

    if ( pIncoming->Domain ) {

        if ( pIncoming->DomainLength ) {

            if (FromWide == TRUE) {

                dwWcharsWritten = pIncoming->DomainLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->Domain,
                            dwWcharsWritten * sizeof(WCHAR) );
            } else {

                dwWcharsWritten = MultiByteToWideChar( CP_ACP,
                                                       0,
                                                       (const char *)pIncoming->Domain,
                                                       pIncoming->DomainLength,
                                                       outputBuff,
                                                       pIncoming->DomainLength );

                if (dwWcharsWritten == 0) {
                    goto exitWithCleanup;
                }                                                                                              
            }
        } else {

            dwWcharsWritten = 0;
        }

        pOutgoing->DomainLength = dwWcharsWritten;
        pOutgoing->Domain = (unsigned short *)outputBuff;

        outputBuff += dwWcharsWritten;
        *(outputBuff++) = L'\0';

    } else {

        pOutgoing->Domain = NULL;
        pOutgoing->DomainLength = 0;
    }

    if ( pIncoming->Password ) {

        if ( pIncoming->PasswordLength ) {

            if (FromWide == TRUE) {

                dwWcharsWritten = pIncoming->PasswordLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->Password,
                            dwWcharsWritten * sizeof(WCHAR) );
            } else {

                dwWcharsWritten = MultiByteToWideChar( CP_ACP,
                                                      0,
                                                      (const char *)pIncoming->Password,
                                                      pIncoming->PasswordLength,
                                                      outputBuff,
                                                      pIncoming->PasswordLength );
                                                      
                if (dwWcharsWritten == 0) {
                    goto exitWithCleanup;
                }                                                                                             
            }
        } else {

            dwWcharsWritten = 0;
        }

        pOutgoing->PasswordLength = dwWcharsWritten;
        pOutgoing->Password = (unsigned short *)outputBuff;

        outputBuff += dwWcharsWritten;
        *(outputBuff++) = L'\0';

        // advance the buffer ptr by however many padding bytes we added.
        // outputBuff is a WCHAR ptr, so we have to convert from bytes to WCHARs
        outputBuff += (((DES_BLOCKLEN-1) + ((((DES_BLOCKLEN-1)%2) == 0) ? 0 : 1)) / sizeof (WCHAR));


    } else {

        pOutgoing->Password = NULL;
        pOutgoing->PasswordLength = 0;
    }

    if ( pIncoming->PackageList ) {

        if ( pIncoming->PackageListLength ) {

            if (FromWide == TRUE) {

                dwWcharsWritten = pIncoming->PackageListLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->PackageList,
                            dwWcharsWritten * sizeof(WCHAR) );
            } else {

                dwWcharsWritten = MultiByteToWideChar( CP_ACP,
                                                      0,
                                                      (const char *)pIncoming->PackageList,
                                                      pIncoming->PackageListLength,
                                                      outputBuff,
                                                      pIncoming->PackageListLength );

                if (dwWcharsWritten == 0) {
                    goto exitWithCleanup;
                }                                                                                             
            }
        } else {

            dwWcharsWritten = 0;
        }

        pOutgoing->PackageListLength = dwWcharsWritten;
        pOutgoing->PackageList = (unsigned short *)outputBuff;

        outputBuff += dwWcharsWritten;
        *(outputBuff++) = L'\0';

    } else {

        pOutgoing->PackageList = NULL;
        pOutgoing->PackageListLength = 0;
    }

    //
    // Stuff in the flags, the version and the length.
    //

    pOutgoing->Version = pIncoming->Version;
    pOutgoing->Length  = sizeof( SEC_WINNT_AUTH_IDENTITY_EXW );
    pOutgoing->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    *ppWideAuthIdent = ( PCHAR ) pOutgoing;

    return LDAP_SUCCESS;

exitWithCleanup:

    if (pOutgoing) {
        ldapSecureFree(pOutgoing, LDAP_SECURITY_SIGNATURE);
    }

    return LDAP_NO_MEMORY;
}


ULONG
LdapMakeEXCredsThin(
    PCHAR pWideAuthIdent,
    PCHAR *ppAnsiAuthIdent,
    BOOLEAN FromWide
)
/*+++

Description:

    Take a SEC_WINNT_AUTH_IDENTITY_EXW and return
    a SEC_WINNT_AUTH_IDENTITY_EXA.  We do this because
    the Win9x SSPI providers only support ansi.  The
    caller must free the SEC_WINNT_AUTH_IDENTITY_EXA.

    Note that the lengths in this structure are the
    number the chars in the string, but the strings
    still must be NULL terminated.

 ---*/
{

    PSEC_WINNT_AUTH_IDENTITY_EXW pIncoming;
    PSEC_WINNT_AUTH_IDENTITY_EXA pOutgoing = NULL;
    ULONG dwBytesNeeded, dwCharsWritten;
    PUCHAR outputBuff;

    pIncoming = ( PSEC_WINNT_AUTH_IDENTITY_EXW ) pWideAuthIdent;

    //
    // Compute the necessary target buffer size.
    //
    // Account for possible alignment byte needed.
    //

    dwBytesNeeded = sizeof( SEC_WINNT_AUTH_IDENTITY_EXA ) + 1;

    //
    //  We multiply by 2 so that we don't worry about long DBCS names.
    //

    dwBytesNeeded += ( pIncoming->UserLength + 1 ) * sizeof(WCHAR);
    dwBytesNeeded += ( pIncoming->DomainLength + 1 ) * sizeof(WCHAR);
    dwBytesNeeded += ( pIncoming->PasswordLength + 1 ) * sizeof(WCHAR);
    dwBytesNeeded += ( pIncoming->PackageListLength + 1 ) * sizeof(WCHAR);

    // We'll need up to DES_BLOCKLEN-1 bytes of padding for RtlEncryptMemory
    // (plus 1 byte for alignment if that is a odd number)
    dwBytesNeeded += (DES_BLOCKLEN-1);
    dwBytesNeeded += ((((DES_BLOCKLEN-1)%2) == 0) ? 0 : 1);


    //
    // Allocate the block.
    //

    pOutgoing = ( PSEC_WINNT_AUTH_IDENTITY_EXA )
                ldapMalloc( dwBytesNeeded, LDAP_SECURITY_SIGNATURE );

    if ( !pOutgoing ) {
        return LDAP_NO_MEMORY;
    }

    //
    // Set up the wide pointers, pre-marshalled.
    //

    outputBuff = (PUCHAR) ( ( ( PBYTE ) pOutgoing ) +
                                 sizeof( SEC_WINNT_AUTH_IDENTITY_EXA ) );

    //
    // Convert the parameters from unicode.
    //

    if ( pIncoming->User ) {

        if ( pIncoming->UserLength ) {

            if (FromWide == FALSE) {

                dwCharsWritten = pIncoming->UserLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->User,
                            dwCharsWritten );
            } else {

                dwCharsWritten = WideCharToMultiByte(  CP_ACP,
                                                       0,
                                                       (LPCWSTR)pIncoming->User,
                                                       pIncoming->UserLength,
                                                       (PCHAR) outputBuff,
                                                       pIncoming->UserLength + 1,
                                                       NULL,
                                                       NULL );

                if (dwCharsWritten == 0) {
                    goto exitWithCleanup;
                }                                                                                                                                             
            }
        } else {

            dwCharsWritten = 0;
        }

        pOutgoing->UserLength = dwCharsWritten;
        pOutgoing->User = outputBuff;

        outputBuff += dwCharsWritten;
        *(outputBuff++) = '\0';

    } else {

        pOutgoing->User = NULL;
        pOutgoing->UserLength = 0;
    }

    if ( pIncoming->Domain ) {

        if ( pIncoming->DomainLength ) {

            if (FromWide == FALSE) {

                dwCharsWritten = pIncoming->DomainLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->Domain,
                            dwCharsWritten );
            } else {

                dwCharsWritten =  WideCharToMultiByte(  CP_ACP,
                                                       0,
                                                       (LPCWSTR)pIncoming->Domain,
                                                       pIncoming->DomainLength,
                                                       (PCHAR) outputBuff,
                                                       pIncoming->DomainLength + 1,
                                                       NULL,
                                                       NULL );

                if (dwCharsWritten == 0) {
                    goto exitWithCleanup;
                }                                                                                                                                             
            }
        } else {

            dwCharsWritten = 0;
        }

        pOutgoing->DomainLength = dwCharsWritten;
        pOutgoing->Domain = outputBuff;

        outputBuff += dwCharsWritten;
        *(outputBuff++) = '\0';

    } else {

        pOutgoing->Domain = NULL;
        pOutgoing->DomainLength = 0;
    }

    if ( pIncoming->Password ) {

        if ( pIncoming->PasswordLength ) {

            if (FromWide == FALSE) {

                dwCharsWritten = pIncoming->PasswordLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->Password,
                            dwCharsWritten );
            } else {

                dwCharsWritten =  WideCharToMultiByte( CP_ACP,
                                                       0,
                                                       (LPCWSTR)pIncoming->Password,
                                                       pIncoming->PasswordLength,
                                                       (PCHAR) outputBuff,
                                                       pIncoming->PasswordLength + 1,
                                                       NULL,
                                                       NULL );

                if (dwCharsWritten == 0) {
                    goto exitWithCleanup;
                }                                                                                                                                             
            }
        } else {

            dwCharsWritten = 0;
        }

        pOutgoing->PasswordLength = dwCharsWritten;
        pOutgoing->Password = outputBuff;

        outputBuff += dwCharsWritten;
        *(outputBuff++) = '\0';

        // advance the buffer ptr by however many padding bytes we added.
        // outputBuff is a WCHAR ptr, so we have to convert from bytes to WCHARs
        outputBuff += (((DES_BLOCKLEN-1) + ((((DES_BLOCKLEN-1)%2) == 0) ? 0 : 1)) / sizeof (WCHAR));

    } else {

        pOutgoing->Password = NULL;
        pOutgoing->PasswordLength = 0;
    }


    if ( pIncoming->PackageList ) {

        if ( pIncoming->PackageListLength ) {

            if (FromWide == FALSE) {

                dwCharsWritten = pIncoming->PackageListLength;

                CopyMemory( outputBuff,
                            (const char *)pIncoming->PackageList,
                            dwCharsWritten );
            } else {

                dwCharsWritten =  WideCharToMultiByte( CP_ACP,
                                                       0,
                                                       (LPCWSTR)pIncoming->PackageList,
                                                       pIncoming->PackageListLength,
                                                       (PCHAR) outputBuff,
                                                       pIncoming->PackageListLength + 1,
                                                       NULL,
                                                       NULL );
                                                       
                if (dwCharsWritten == 0) {
                    goto exitWithCleanup;
                }                                                                                                                                             
            }
        } else {

            dwCharsWritten = 0;
        }

        pOutgoing->PackageListLength = dwCharsWritten;
        pOutgoing->PackageList = outputBuff;

        outputBuff += dwCharsWritten;
        *(outputBuff++) = '\0';

    } else {

        pOutgoing->PackageList = NULL;
        pOutgoing->PackageListLength = 0;
    }

    //
    // Stuff in the flags, the version and the length
    //

    pOutgoing->Version = pIncoming->Version;
    pOutgoing->Length  = sizeof( SEC_WINNT_AUTH_IDENTITY_EXA );
    pOutgoing->Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

    *ppAnsiAuthIdent = ( PCHAR ) pOutgoing;

    return LDAP_SUCCESS;

exitWithCleanup:

    if (pOutgoing) {
        ldapSecureFree(pOutgoing, LDAP_SECURITY_SIGNATURE);
    }

    return LDAP_NO_MEMORY;    
}




ULONG
ProcessAlternateCreds (
      PLDAP_CONN Connection,
      PSecPkgInfoW Package,
      PWCHAR Credentials,
      PWCHAR *newcreds
      )
{
      ULONG err;
      BOOLEAN toWide;

      ASSERT( Credentials != NULL );


      if ((Package == SspiPackageSicily) ||
           (Package == SspiPackageDpa)) {

          toWide = FALSE;


       } else {

           //
           //  Win9x takes ANSI only
           //

           toWide = (BOOLEAN) (GlobalWin9x ? FALSE : TRUE);

       }

       ASSERT( sizeof( SEC_WINNT_AUTH_IDENTITY_A ) ==
               sizeof( SEC_WINNT_AUTH_IDENTITY_W ) );

       //
       // We have to detect whether the user has passed us an old style
       // SEC_WINNT_AUTH_IDENTITY structure or a newer style
       // SEC_WINNT_AUTH_IDENTITY_EX
       //
       // We examine the first field of the incoming structure. If it is a
       // pointer to a string or NULL, then it is an old style structure. New
       // style structures have a small non-zero verion in this field
       //

       PSEC_WINNT_AUTH_IDENTITY_EXA pIncomingEX = (PSEC_WINNT_AUTH_IDENTITY_EXA) Credentials;


       if ((pIncomingEX->Version > 0xFFFF)||(pIncomingEX->Version == 0)) {

          //
          // If we are using the older style structure
          //

          IF_DEBUG(TRACE1) {

             LdapPrint0(" The older style SEC_WINNT_AUTH_IDENTITY was detected\n");
          }


       PSEC_WINNT_AUTH_IDENTITY_A pIncoming = (PSEC_WINNT_AUTH_IDENTITY_A) Credentials;

       //
       //  if neither flag (or both) was specified, error out with invalid parameter
       //

       if ( (( pIncoming->Flags &
             ( SEC_WINNT_AUTH_IDENTITY_ANSI | SEC_WINNT_AUTH_IDENTITY_UNICODE))
             == 0 ) ||
            (( pIncoming->Flags &
             ( SEC_WINNT_AUTH_IDENTITY_ANSI | SEC_WINNT_AUTH_IDENTITY_UNICODE))
             == ( SEC_WINNT_AUTH_IDENTITY_ANSI | SEC_WINNT_AUTH_IDENTITY_UNICODE)) ) {

           IF_DEBUG( NETWORK_ERRORS ) {
               LdapPrint2( "LdapSspiBind Connection 0x%x had auth flags of 0x%x.\n",
                           Connection, pIncoming->Flags );
           }

           return LDAP_PARAM_ERROR;
       }

       //
       //  make a copy of the credentials to save on the connection for
       //  chasing referrals.
       //

       BOOLEAN fromWide = (BOOLEAN) ((pIncoming->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE) ?
                                       TRUE : FALSE);

       if (toWide == FALSE) {

          //
          // On Win9x, we convert from Unicode to ANSI
          //

           err = LdapMakeCredsThin( (PCHAR) pIncoming, (PCHAR *) newcreds, fromWide );

       } else {

          //
          // On NT, we convert from ANSI to Unicode
          //

           err = LdapMakeCredsWide( (PCHAR) pIncoming, (PCHAR *) newcreds, fromWide );
       }

           return err;


       } else {

          //
          // We are using the new style SEC_WINNT_AUTH_IDENTITY_EX structure
          //
          IF_DEBUG(TRACE1) {

          LdapPrint0(" The newer style SEC_WINNT_AUTH_IDENTITY_EX was detected\n");
          }
          //
          //  if neither flag (or both) was specified, error out with invalid parameter
          //

          if ( (( pIncomingEX->Flags &
                ( SEC_WINNT_AUTH_IDENTITY_ANSI | SEC_WINNT_AUTH_IDENTITY_UNICODE))
                == 0 ) ||
               (( pIncomingEX->Flags &
                ( SEC_WINNT_AUTH_IDENTITY_ANSI | SEC_WINNT_AUTH_IDENTITY_UNICODE))
                == ( SEC_WINNT_AUTH_IDENTITY_ANSI | SEC_WINNT_AUTH_IDENTITY_UNICODE)) ) {

              IF_DEBUG( NETWORK_ERRORS ) {
                  LdapPrint2( "LdapSspiBind Connection 0x%x had auth flags of 0x%x.\n",
                              Connection, pIncomingEX->Flags );
              }

              return LDAP_PARAM_ERROR;
          }

          //
          //  make a copy of the credentials to save on the connection for
          //  chasing referrals.
          //

          BOOLEAN fromWide = (BOOLEAN) ((pIncomingEX->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE) ?
                                          TRUE : FALSE);

          if (toWide == FALSE) {

              err = LdapMakeEXCredsThin( (PCHAR) pIncomingEX, (PCHAR *) newcreds, fromWide );

          } else {

              err = LdapMakeEXCredsWide( (PCHAR) pIncomingEX, (PCHAR *) newcreds, fromWide );
          }

          if (err != LDAP_SUCCESS) {

              return err;
          }
          ASSERT( newcreds != NULL );

          return err;

       }

}


int __cdecl ldap_sasl_bindA(
      LDAP  *ExternalHandle,
      const  PCHAR DistName,
      const  PCHAR  AuthMechanism,
      const  BERVAL   *cred,
      PLDAPControlA *ServerCtrls,
      PLDAPControlA *ClientCtrls,
      int *MessageNumber
     )
 {
     PLDAP_CONN Connection = NULL;
     ULONG rc = 0;
     PWCHAR wName = NULL, wMechanism = NULL;

     Connection = GetConnectionPointer(ExternalHandle);

     if (!Connection || !DistName || !AuthMechanism || !cred || !MessageNumber) {
         rc = LDAP_PARAM_ERROR;
         goto error;
     }

     rc = ToUnicodeWithAlloc( DistName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP);

     if (rc != LDAP_SUCCESS) {

         SetConnectionError( Connection, rc, NULL );
         goto error;
     }

     rc = ToUnicodeWithAlloc( AuthMechanism, -1, &wMechanism, LDAP_UNICODE_SIGNATURE, LANG_ACP );

     if (rc != LDAP_SUCCESS) {

         SetConnectionError( Connection, rc, NULL );
         goto error;
     }

     rc = LdapExchangeOpaqueToken(Connection,
                             LDAP_AUTH_SASL,        // auth mechanism
                             wMechanism,            // oid
                             wName,                 // username
                             cred->bv_val,          // Credentials
                             cred->bv_len,          // Credential length
                             NULL,                  // return data
                             NULL,                  // return data in berval form
                             (PLDAPControlW *)ServerCtrls,           // server controls
                             (PLDAPControlW *)ClientCtrls,           // client controls
                             (PULONG) MessageNumber,
                             TRUE,                  // Send only
                             FALSE,                 // controls are not unicode
                             NULL                   // was message sent?
                             );

error:
    if (wName)
         ldapFree( wName, LDAP_UNICODE_SIGNATURE );

     if (wMechanism)
         ldapFree( wMechanism, LDAP_UNICODE_SIGNATURE );

     if (Connection)
         DereferenceLdapConnection( Connection );

     return rc;


 }



int __cdecl
ldap_sasl_bindW(
         LDAP  *ExternalHandle,
         const PWCHAR DistName,
         const PWCHAR AuthMechanism,
         const BERVAL   *cred,
         PLDAPControlW *ServerCtrls,
         PLDAPControlW *ClientCtrls,
         int *MessageNumber
         )
 {
     PLDAP_CONN Connection = NULL;
     ULONG rc = 0;

     Connection = GetConnectionPointer(ExternalHandle);

     if (!Connection || !DistName || !AuthMechanism || !cred || !MessageNumber) {
         rc = LDAP_PARAM_ERROR;
         goto error;
     }

     rc = LdapExchangeOpaqueToken(Connection,
                             LDAP_AUTH_SASL,        // auth mechanism
                             AuthMechanism,         // oid
                             DistName,              // username
                             cred->bv_val,          // Credentials
                             cred->bv_len,          // Credential length
                             NULL,                  // return data
                             NULL,                  // return data in berval form
                             ServerCtrls,           // server controls
                             ClientCtrls,           // client controls
                             (PULONG )MessageNumber,
                             TRUE,                  // Send only
                             TRUE,                  // Controls are unicode
                             NULL                   // was message sent?                             
                             );

error:
     if (Connection)
         DereferenceLdapConnection( Connection );

    return rc;
 }


int __cdecl
ldap_sasl_bind_sA(
          LDAP  *ExternalHandle,
          const PCHAR DistName,
          const PCHAR AuthMechanism,
          const BERVAL   *cred,
          PLDAPControlA *ServerCtrls,
          PLDAPControlA *ClientCtrls,
          PBERVAL *ServerData
         )
 {

     PLDAP_CONN Connection = NULL;
     ULONG rc = 0;
     PWCHAR wName = NULL, wMechanism = NULL;

     Connection = GetConnectionPointer(ExternalHandle);

     if (!Connection || !DistName ||
          !AuthMechanism || !cred ) {
         rc = LDAP_PARAM_ERROR;
         goto error;
     }

     rc = ToUnicodeWithAlloc( DistName, -1, &wName, LDAP_UNICODE_SIGNATURE, LANG_ACP);

     if (rc != LDAP_SUCCESS) {

         SetConnectionError( Connection, rc, NULL );
         goto error;
     }

     rc = ToUnicodeWithAlloc( AuthMechanism, -1, &wMechanism, LDAP_UNICODE_SIGNATURE, LANG_ACP );

     if (rc != LDAP_SUCCESS) {

         SetConnectionError( Connection, rc, NULL );
         goto error;
     }

     rc = LdapExchangeOpaqueToken(Connection,
                             LDAP_AUTH_SASL,        // auth mechanism
                             wMechanism,            // oid
                             wName,                 // username
                             cred->bv_val,          // Credentials
                             cred->bv_len,          // Credential length
                             NULL,                  // return data
                             ServerData,            // return data in berval form
                             (PLDAPControlW *)ServerCtrls,           // server controls
                             (PLDAPControlW *)ClientCtrls,           // client controls
                             0,                     // Message Number
                             FALSE,                 // Send only
                             FALSE,                 // Controls are not unicode
                             NULL                   // was message sent?                             
                             );

error:
    if (wName)
         ldapFree( wName, LDAP_UNICODE_SIGNATURE );

     if (wMechanism)
         ldapFree( wMechanism, LDAP_UNICODE_SIGNATURE );

     if (Connection)
         DereferenceLdapConnection( Connection );

     return rc;

 }


int __cdecl ldap_sasl_bind_sW(
         LDAP  *ExternalHandle,
         const PWCHAR DistName,
         const PWCHAR AuthMechanism,
         const BERVAL   *cred,
         PLDAPControlW *ServerCtrls,
         PLDAPControlW *ClientCtrls,
         PBERVAL *ServerData
         )
 {

     PLDAP_CONN Connection = NULL;
     ULONG err = 0;

     Connection = GetConnectionPointer(ExternalHandle);

     if (!Connection || !DistName ||
          !AuthMechanism || !cred ) {
         err = LDAP_PARAM_ERROR;
         goto error;
     }

     err = LdapExchangeOpaqueToken(Connection,
                             LDAP_AUTH_SASL,        // auth mechanism
                             AuthMechanism,         // oid
                             DistName,              // username
                             cred->bv_val,          // Credentials
                             cred->bv_len,          // Credential length
                             NULL,                  // return data
                             ServerData,            // return data in berval form
                             ServerCtrls,           // server controls
                             ClientCtrls,           // client controls
                             0,                     // Message Number
                             FALSE,                 // Send only
                             TRUE,                  // Controls are unicode
                             NULL                   // was message sent?                             
                             );

error:
     if (Connection)
         DereferenceLdapConnection( Connection );

    return err;
 }



// security.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\sort.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sort.cxx  sort control support routines for the LDAP api

Abstract:

   This module implements routines that handle sorting controls

Author:

    Andy Herron (andyhe)        27-Aug-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG
LdapCreateSortControlWithAlloc(
        PLDAP           ExternalHandle,
        PLDAPSortKeyW  *SortKeys,
        UCHAR           IsCritical,
        PLDAPControlW  *Control,
        ULONG           CodePage
        );

ULONG
LdapParseSortControl (
        PLDAP_CONN      connection,
        PLDAPControlW  *Control,
        ULONG          *Result,
        PWCHAR         *Attribute,
        ULONG           CodePage
        );

ULONG
LdapEncodeSortControl (
    PLDAP_CONN      connection,
    PLDAPSortKeyW  *SortKeys,
    PLDAPControlW  OutputControl,
    BOOLEAN Criticality,
    ULONG CodePage
    )
{
    ULONG err;
    CLdapBer *lber = NULL;
    PLDAPSortKeyW sortKey;

    if ((connection == NULL) || (OutputControl == NULL) || (SortKeys == NULL)) {

        return LDAP_PARAM_ERROR;
    }

    OutputControl->ldctl_oid = NULL;
    OutputControl->ldctl_iscritical = Criticality;

    if (CodePage == LANG_UNICODE) {

        OutputControl->ldctl_oid = ldap_dup_stringW( LDAP_SERVER_SORT_OID_W,
                                                     0,
                                                     LDAP_VALUE_SIGNATURE );
    } else {

        OutputControl->ldctl_oid = (PWCHAR) ldap_dup_string(  LDAP_SERVER_SORT_OID,
                                                     0,
                                                     LDAP_VALUE_SIGNATURE );
    }

    if (OutputControl->ldctl_oid == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodeSortControl;
    }

    lber = new CLdapBer( connection->publicLdapStruct.ld_version );

    if (lber == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodeSortControl;
    }

    //
    //  for each sort key, insert it into the control :
    //
    //   SortKeyList ::= SEQUENCE OF SEQUENCE {
    //      attributeType   AttributeType,
    //      orderingRule    [0] MatchingRuleId OPTIONAL,
    //      reverseOrder    [1] BOOLEAN DEFAULT FALSE }
    //


    err = lber->HrStartWriteSequence();

    if (err != LDAP_SUCCESS) {

        goto exitEncodeSortControl;
    }

    while (*SortKeys != NULL) {

        sortKey = *SortKeys;

        err = lber->HrStartWriteSequence();

        if (err != LDAP_SUCCESS) {

            goto exitEncodeSortControl;
        }

        if (CodePage == LANG_UNICODE) {

            err = lber->HrAddValue((const WCHAR *) sortKey->sk_attrtype );

        } else {

            err = lber->HrAddValue((const CHAR *) sortKey->sk_attrtype );
        }

        if (err != LDAP_SUCCESS) {

            goto exitEncodeSortControl;
        }

        if (sortKey->sk_matchruleoid != NULL) {

            if (CodePage == LANG_UNICODE) {

              err = lber->HrAddValue((const WCHAR *) sortKey->sk_matchruleoid,
                   BER_CLASS_CONTEXT_SPECIFIC | 0x00 );

            } else {

              err = lber->HrAddValue((const CHAR *) sortKey->sk_matchruleoid,
                   BER_CLASS_CONTEXT_SPECIFIC | 0x00 );
            }

            if (err != LDAP_SUCCESS) {

                goto exitEncodeSortControl;
            }
        }

        if (sortKey->sk_reverseorder != FALSE) {

            err = lber->HrAddValue((BOOLEAN) 1, BER_CLASS_CONTEXT_SPECIFIC | 0x01 );

            if (err != LDAP_SUCCESS) {

                goto exitEncodeSortControl;
            }
        }

        err = lber->HrEndWriteSequence();
        ASSERT( err == NOERROR );

        SortKeys++;
    }

    err = lber->HrEndWriteSequence();
    ASSERT( err == NOERROR );

    OutputControl->ldctl_value.bv_len = lber->CbData();

    if (OutputControl->ldctl_value.bv_len == 0) {

        err = LDAP_LOCAL_ERROR;
        goto exitEncodeSortControl;
    }

    OutputControl->ldctl_value.bv_val = (PCHAR) ldapMalloc(
                            OutputControl->ldctl_value.bv_len,
                            LDAP_CONTROL_SIGNATURE );

    if (OutputControl->ldctl_value.bv_val == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodeSortControl;
    }

    CopyMemory( OutputControl->ldctl_value.bv_val,
                lber->PbData(),
                OutputControl->ldctl_value.bv_len );

    err = LDAP_SUCCESS;

exitEncodeSortControl:

    if (err != LDAP_SUCCESS) {

        if (OutputControl->ldctl_oid != NULL) {

            ldapFree( OutputControl->ldctl_oid, LDAP_VALUE_SIGNATURE );
            OutputControl->ldctl_oid = NULL;
        }

        OutputControl->ldctl_value.bv_len = 0;
    }

    if (lber != NULL) {
        delete lber;
    }
    return err;
}

WINLDAPAPI
ULONG LDAPAPI
ldap_create_sort_controlA (
        PLDAP           ExternalHandle,
        PLDAPSortKeyA  *SortKeys,
        UCHAR           IsCritical,
        PLDAPControlA  *Control
        )
{
    return LdapCreateSortControlWithAlloc( ExternalHandle,
                                           (PLDAPSortKeyW  *) SortKeys,
                                           IsCritical,
                                           (PLDAPControlW  *) Control,
                                           LANG_ACP );
}

WINLDAPAPI
ULONG LDAPAPI
ldap_create_sort_controlW (
        PLDAP           ExternalHandle,
        PLDAPSortKeyW  *SortKeys,
        UCHAR           IsCritical,
        PLDAPControlW  *Control
        )
{
    return LdapCreateSortControlWithAlloc( ExternalHandle,
                                           SortKeys,
                                           IsCritical,
                                           Control,
                                           LANG_UNICODE );
}

ULONG
LdapCreateSortControlWithAlloc(
        PLDAP           ExternalHandle,
        PLDAPSortKeyW  *SortKeys,
        UCHAR           IsCritical,
        PLDAPControlW  *Control,
        ULONG           CodePage
        )
{
    ULONG err;
    BOOLEAN criticality = ( (IsCritical > 0) ? TRUE : FALSE );
    PLDAPControlW  control = NULL;
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if ((connection == NULL) || (Control == NULL)) {
        err = LDAP_PARAM_ERROR;
        goto error;
    }

    control = (PLDAPControlW) ldapMalloc( sizeof( LDAPControlW ), LDAP_CONTROL_SIGNATURE );

    if (control == NULL) {

        *Control = NULL;
        err = LDAP_NO_MEMORY;
        goto error;
    }

    err = LdapEncodeSortControl(  connection,
                                  SortKeys,
                                  control,
                                  criticality,
                                  CodePage );

    if (err != LDAP_SUCCESS) {

        ldap_control_freeW( control );
        control = NULL;
    }

    *Control = control;

error:
    if (connection)
        DereferenceLdapConnection( connection );

    return err;
}


//
//  These routines parse the search control returned by the server
//

WINLDAPAPI
ULONG LDAPAPI
ldap_parse_sort_controlA (
        PLDAP           ExternalHandle,
        PLDAPControlA  *Control,
        ULONG          *Result,
        PCHAR          *Attribute
        )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapParseSortControl(     connection,
                                    (PLDAPControlW  *) Control,
                                    Result,
                                    (PWCHAR *) Attribute,
                                    LANG_ACP );

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI
ULONG LDAPAPI
ldap_parse_sort_controlW (
        PLDAP           ExternalHandle,
        PLDAPControlW  *Control,
        ULONG          *Result,
        PWCHAR         *Attribute
        )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err  = LdapParseSortControl(    connection,
                                    Control,
                                    Result,
                                    Attribute,
                                    LANG_UNICODE );

    DereferenceLdapConnection( connection );

    return err;
}

ULONG
LdapParseSortControl (
        PLDAP_CONN      connection,
        PLDAPControlW  *ServerControls,
        ULONG          *Result,
        PWCHAR         *Attribute,
        ULONG           CodePage
        )
{
    ULONG err = LDAP_CONTROL_NOT_FOUND;
    PCHAR *ansiAttribute = (PCHAR *) Attribute;
    CLdapBer *lber = NULL;

    //
    //  First thing is to zero out the parms passed in.
    //

    if (Result != NULL) {

        *Result = 0;
    }

    if (Attribute != NULL) {

        *Attribute = NULL;
    }

    if (ServerControls != NULL) {

        PLDAPControlW *controls = ServerControls;
        PLDAPControlW currentControl;
        ULONG bytesTaken;
        LONG  sortError;

        while (*controls != NULL) {

            currentControl = *controls;

            //
            //  check to see if the current control is the SORT control
            //

            if ( ((CodePage == LANG_UNICODE) &&
                  ( ldapWStringsIdentical( currentControl->ldctl_oid,
                                           -1,
                                           LDAP_SERVER_RESP_SORT_OID_W,
                                           -1 ) == TRUE )) ||
                 ((CodePage == LANG_ACP) &&
                  ( CompareStringA( LDAP_DEFAULT_LOCALE,
                                    NORM_IGNORECASE,
                                    (PCHAR) currentControl->ldctl_oid,
                                    -1,
                                    LDAP_SERVER_RESP_SORT_OID,
                                    sizeof(LDAP_SERVER_RESP_SORT_OID) ) == 2)) ) {

                lber = new CLdapBer( connection->publicLdapStruct.ld_version );

                if (lber == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint1( "LdapParseSortControl: unable to alloc msg for 0x%x.\n",
                                    connection );
                    }

                    err = LDAP_NO_MEMORY;
                    break;
                }

                err = lber->HrLoadBer(   (const BYTE *) currentControl->ldctl_value.bv_val,
                                         currentControl->ldctl_value.bv_len,
                                         &bytesTaken,
                                         TRUE );    // we have the whole message guarenteed

                if (err != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseSortControl: loadBer error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    break;
                }

                err = lber->HrStartReadSequence();
                if (err != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseSortControl: loadBer error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    break;
                }

                err = lber->HrGetEnumValue( &sortError );
                if (err != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseSortControl: getEnumValue error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    break;
                }

                if (Result != NULL) {

                    *Result = sortError;
                }

                if (Attribute != NULL) {

                    if ( CodePage == LANG_UNICODE) {

                        err = lber->HrGetValueWithAlloc( Attribute );

                    } else {

                        err = lber->HrGetValueWithAlloc( ansiAttribute );
                    }

                    if (err != NOERROR) {

                        //
                        //  Since it's an optional string, only bail out if we
                        //  got a legit error from decoding.
                        //

                        IF_DEBUG(PARSE) {
                            LdapPrint2( "LdapParseSortControl: GetAttribute error of 0x%x for 0x%x.\n",
                                        err, connection );
                        }

                        if ( (err != LDAP_NO_SUCH_ATTRIBUTE ) &&
                             (err != LDAP_DECODING_ERROR) ) {

                            break;
                        }
                    }
                }

                err = LDAP_SUCCESS;
                break;                  // done with loop... look no more
            }
            controls++;
        }
    }

    if (lber != NULL) {

        delete lber;
    }

    SetConnectionError( connection, err, NULL );
    return err;
}

//
//  These two APIs are old and will be eliminated after NT 5.0 beta 1.
//

WINLDAPAPI ULONG LDAPAPI ldap_encode_sort_controlW (
        PLDAP           ExternalHandle,
        PLDAPSortKeyW  *SortKeys,
        PLDAPControlW  Control,
        BOOLEAN Criticality
        )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapEncodeSortControl(   connection,
                                   SortKeys,
                                   Control,
                                   Criticality,
                                   LANG_UNICODE );

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI ULONG LDAPAPI ldap_encode_sort_controlA (
        PLDAP           ExternalHandle,
        PLDAPSortKeyA  *SortKeys,
        PLDAPControlA  Control,
        BOOLEAN Criticality
        )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapEncodeSortControl(   connection,
                                   (PLDAPSortKeyW *)SortKeys,
                                   (PLDAPControlW)Control,
                                   Criticality,
                                   LANG_ACP );

    DereferenceLdapConnection( connection );

    return err;
}

// sort.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\subord.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    subord.cxx parse subordinate references from an LDAP server

Abstract:

   This module implements the gathering/parsing routines for subordinate
   referrals (references) for ldap search results.

Author:

    Andy Herron (andyhe)        30-Apr-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG
LdapParseReference (
        PLDAP_CONN connection,
        LDAPMessage *ResultMessage,
        PWCHAR **Referrals,                  // free with ldap_value_freeW
        BOOLEAN Unicode
        );

LDAPMessage * __cdecl
ldap_first_reference (
    LDAP *ExternalHandle,
    LDAPMessage *Results
    )
{
    PLDAP_CONN connection = NULL;
    LDAPMessage *result;

    connection = GetConnectionPointer(ExternalHandle);

    result = ldap_first_record( connection, Results, LDAP_RES_REFERRAL );

    if (connection)
        DereferenceLdapConnection( connection );

    return result;
}

LDAPMessage * __cdecl
ldap_next_reference (
    LDAP *ExternalHandle,
    LDAPMessage *entry
    )
{
    PLDAP_CONN connection = NULL;
    LDAPMessage *result;

    connection = GetConnectionPointer(ExternalHandle);

    result = ldap_next_record( connection, entry, LDAP_RES_REFERRAL );

    if (connection)
        DereferenceLdapConnection( connection );

    return result;
}


//
//  Count the number of subordinate references returned by the server in a
//  response to a search request.
//

ULONG __cdecl
ldap_count_references (
    LDAP *ExternalHandle,
    LDAPMessage *entry
    )
{
    PLDAP_CONN connection = NULL;
    ULONG cnt;

    connection = GetConnectionPointer(ExternalHandle);

    cnt = ldap_count_records( connection, entry, LDAP_RES_REFERRAL );

    if (connection)
        DereferenceLdapConnection( connection );

    return cnt;
}

PLDAPMessage
ldap_first_record (
    PLDAP_CONN connection,
    LDAPMessage *Results,
    ULONG MessageType
    )
{
    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    //
    //  return the first entry of a resultant message passed in.  skip any
    //  search result messages that may be in the middle of the message.
    //

    if (Results == (LDAPMessage *) -1 ) {

        return NULL;
    }

    while ((Results != NULL) &&
           (Results->lm_msgtype != MessageType )) {

        Results = Results->lm_chain;
    }

    return Results;
}


//
//  Return the next entry of a message.  It is freed when the message is
//  freed so should not be freed explicitly.
//
PLDAPMessage
ldap_next_record (
    PLDAP_CONN connection,
    LDAPMessage *entry,
    ULONG MessageType
    )
{
    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    //
    //  return the first entry of a resultant message passed in.
    //

    if (entry == NULL) {

        return NULL;
    }

    //
    //  skip any search result messages that may be in the middle of the
    //  message.
    //

    entry = entry->lm_chain;

    while ((entry != NULL) &&
           (entry->lm_msgtype != MessageType )) {

        entry = entry->lm_chain;
    }

    return entry;
}


ULONG
ldap_count_records (
    PLDAP_CONN connection,
    LDAPMessage *res,
    ULONG MessageType
    )
{
    SetConnectionError( connection, LDAP_SUCCESS, NULL );

    ULONG count = 0;

    if ( (LONG_PTR) res != -1 ) {

        while (res != NULL) {

            if (res->lm_msgtype == MessageType) {

                count++;
            }
            res = res->lm_chain;
        }
    }
    return(count);
}

//
//  We return the list of subordinate referrals in a search response message.
//

ULONG __cdecl
ldap_parse_referenceW (
        LDAP *ExternalHandle,
        LDAPMessage *ResultMessage,
        PWCHAR **Referrals                   // free with ldap_value_freeW
        )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapParseReference(   connection,
                                ResultMessage,
                                Referrals,
                                TRUE );

    DereferenceLdapConnection( connection );

    return err;
}

ULONG __cdecl
ldap_parse_referenceA (
        LDAP *ExternalHandle,
        LDAPMessage *ResultMessage,
        PCHAR **Referrals                   // free with ldap_value_freeA
        )
{
    PLDAP_CONN connection = NULL;
    ULONG err;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapParseReference(   connection,
                                ResultMessage,
                                (PWCHAR **) Referrals,
                                FALSE );

    DereferenceLdapConnection( connection );

    return err;
}


ULONG
LdapParseReference (
        PLDAP_CONN connection,
        LDAPMessage *ResultMessage,
        PWCHAR **Referrals,                  // free with ldap_value_freeW
        BOOLEAN Unicode
        )
{
    CLdapBer *lber = NULL;
    ULONG hr;
    PWCHAR referralString = NULL;
    ULONG count = 0;
    ULONG arraySize = 0;

    if ((connection == NULL) ||
        (ResultMessage == NULL) ||
        (ResultMessage == (PLDAPMessage) -1) ||
        (ResultMessage->lm_msgtype != LDAP_RES_REFERRAL) ||
        (Referrals == NULL)) {

        return LDAP_PARAM_ERROR;
    }

    *Referrals = NULL;

    lber = (CLdapBer *) (ResultMessage->lm_ber);

    if (lber == NULL) {

        return LDAP_LOCAL_ERROR;
    }

    lber->Reset(FALSE);

    hr = LdapInitialDecodeMessage( connection, ResultMessage );

    if (hr != NOERROR) {

        IF_DEBUG(REFERRALS) {
            LdapPrint2( "HandleReferral error 0x%x while decoding referral for 0x%x\n",
                         hr, connection );
        }
        return hr;
    }

    while (hr == NOERROR) {

        if (Unicode) {

            hr = lber->HrGetValueWithAlloc( &referralString );

        } else {

            hr = lber->HrGetValueWithAlloc( (PCHAR *) &referralString );
        }

        if (hr != NOERROR || referralString == NULL) {

            IF_DEBUG(REFERRALS) {
                LdapPrint2( "HandleReferral error 0x%x while reading referral for 0x%x\n",
                             hr, connection );
            }
            break;
        }

        if (add_string_to_list( Referrals, &arraySize, referralString, FALSE ) > 0) {

            count++;

        } else {

            ldapFree( referralString, LDAP_VALUE_SIGNATURE );
        }
    }

    if (count > 0) {

        hr = LDAP_SUCCESS;
    }

    return hr;
}

// subord.cxx  eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\transact.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    transact.cxx  Transaction support routines for the LDAP api

Abstract:

   This module implements routines that handle LDAP transactions.

Author:

    Anoop Anantha (AnoopA)        21-Feb-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

#define LDAP_START_TRANSACTION           1
#define LDAP_COMMIT_AND_END_TRANSACTION  2
#define LDAP_ABANDON_TRANSACTION         3

#define LDAP_SIMPLE_TRANSACTION          0
#define LDAP_DISTRIBUTED_TRANSACTION     1

ULONG
LdapCreateTransactionControlWithAlloc(
    IN  PLDAP_CONN connection,
    IN  PBERVAL Cookie,
    IN  BOOLEAN IsCritical,
    OUT PLDAPControlW *TransactionControl,
    ULONG CodePage
    );


//
// Move this section to winldap.h and add this file to the sources file
// to re-enable transaction support once the server folks are ready to
// support it.
//

#if 0


//
// The transaction APIs are used to start/end/abandon LDAP transaction. Typically
// the user calls ldap_start_transaction_s and gets back a transaction control from
// the server. This control is to be passed in with all subsequent requests which
// are part of that transaction. Finally, the transaction is ended/committed by
// calling ldap_end_transaction_s.
//

#define LDAP_TRANSACT_EXTENDED_OP_OID    "1.2.840.113556.1.4.1501"
#define LDAP_TRANSACT_EXTENDED_OP_OID_W L"1.2.840.113556.1.4.1501"

#define LDAP_SIMPLE_TRANSACT_OID    "1.2.840.113556.1.4.1502"
#define LDAP_SIMPLE_TRANSACT_OID_W L"1.2.840.113556.1.4.1502"

#define LDAP_DISTRIBUTED_TRANSACT_OID    "1.2.840.113556.1.4.1503"
#define LDAP_DISTRIBUTED_TRANSACT_OID_W L"1.2.840.113556.1.4.1503"



WINLDAPAPI ULONG LDAPAPI ldap_start_transaction_sW (
    IN   PLDAP          Connection,
    OUT  PULONG         ServerReturnValue,
    OUT  PULONG         TransactionTimeLimit,
    IN   PBERVAL        DistributedTransactionHandle,
    OUT  PLDAPControlW  *TransactionControl,
    IN   PLDAPControlW  *ServerControls,
    IN   PLDAPControlW  *ClientControls,
    IN   struct l_timeval  *TimeOut
);


WINLDAPAPI ULONG LDAPAPI ldap_start_transaction_sA (
    IN   PLDAP          Connection,
    OUT  PULONG         ServerReturnValue,
    OUT  PULONG         TransactionTimeLimit,
    IN   PBERVAL        DistributedTransactionHandle,
    OUT  PLDAPControlA  *TransactionControl,
    IN   PLDAPControlA  *ServerControls,
    IN   PLDAPControlA  *ClientControls,
    IN   struct l_timeval  *TimeOut
);

WINLDAPAPI ULONG LDAPAPI ldap_parse_transaction_controlA (
    IN    PLDAP           Connection,
    IN    PLDAPControlA  *ResponseControl,
    OUT   ULONG          *ServerError
    );

WINLDAPAPI ULONG LDAPAPI ldap_parse_transaction_controlW (
    IN    PLDAP           Connection,
    IN    PLDAPControlW  *ResponseControl,
    OUT   ULONG          *ServerError
    );

WINLDAPAPI ULONG LDAPAPI ldap_end_transaction_sW (
    IN  PLDAP       Connection,
    IN  PLDAPControlW TransactionControl,
    OUT PULONG      ServerReturnValue,
    IN  BOOLEAN     Abandon,
    IN  PLDAPControlW     *ServerControls,
    IN  PLDAPControlW     *ClientControls,
    IN  struct l_timeval  *TimeOut
    );

WINLDAPAPI ULONG LDAPAPI ldap_end_transaction_sA (
    IN  PLDAP         Connection,
    IN  PLDAPControlA TransactionControl,
    OUT PULONG        ServerReturnValue,
    IN  BOOLEAN          Abandon,
    IN  PLDAPControlA    *ServerControls,
    IN  PLDAPControlA    *ClientControls,
    IN  struct l_timeval  *TimeOut
    );


#if LDAP_UNICODE

#define ldap_start_transaction_s ldap_start_transaction_sW
#define ldap_end_transaction_s   ldap_end_transaction_sW
#define ldap_parse_transaction_control ldap_parse_transaction_controlW

#else

#define ldap_start_transaction_s ldap_start_transaction_sA
#define ldap_end_transaction_s   ldap_end_transaction_sA
#define ldap_parse_transaction_control ldap_parse_transaction_controlA

#endif


#endif

ULONG
LdapExchangeTransactionRequest(
    IN  PLDAP_CONN  Connection,
    IN  ULONG   TransactionOperation,
    OUT PULONG  ServerReturnValue,
    OUT PULONG  TransactionTimeLimit,
    IN  struct l_timeval  *TimeOut,
    IN  PBERVAL  cookie,
    IN OUT PLDAPControlW  *TransactionControl,
    IN  PLDAPControlW *ServerControls,
    IN  PLDAPControlW *ClientControls,
    ULONG CodePage
)
//
// This is the meat of the protocol. This is the main client interfact for
// exchanging a start/end/abandon transaction request.
// If the request was for starting a transaction, it allocate a transaction
// control for subsequent use.
//
// During a StartTransaction Operation, if the cookie is non-null, it represents a
// DistributedTransactionHandle.
//

{
    PLDAPSearch search;
    ULONG err;
    LDAPMessage   *Result = NULL;
    BERVAL  lauRequest = {0};
    PBERVAL ResultData = NULL;
    PWCHAR  ResultOID = NULL;
    ULONG msgId;
    ULONG hr;
    ULONG TransactionType;

    if ( TransactionControl  && ( TransactionOperation == LDAP_START_TRANSACTION)) {

        *TransactionControl = NULL;
    }

    if ( TransactionTimeLimit ) {

        *TransactionTimeLimit = 0;
    }
    
    if ( ServerReturnValue ) {

        *ServerReturnValue = LDAP_SUCCESS;
    }
    
    err = LdapConnect( Connection, NULL, FALSE );

    if (err != LDAP_SUCCESS) {
    
       SetConnectionError( Connection, err, NULL );
       return err;
    }
    
    //
    // Determine if this is a simple or distributed transaction
    //

    if ( TransactionOperation == LDAP_START_TRANSACTION ) {

        if (( cookie == NULL ) || ( cookie->bv_len == 0 ) ) {

            TransactionType = LDAP_SIMPLE_TRANSACTION;
        } else {
            TransactionType = LDAP_DISTRIBUTED_TRANSACTION;
        }
    
    } else if (( TransactionOperation == LDAP_COMMIT_AND_END_TRANSACTION ) ||
               ( TransactionOperation == LDAP_ABANDON_TRANSACTION )) {

        //
        // Look into the control to determine the control value. Note that
        // to reduce code, we are overloading the TransactionControl parameter
        // to also take in pointer to an LDAP control which we will examine
        // here.
        //

        ASSERT( TransactionControl != NULL );

        PLDAPControlW pTxControl = (PLDAPControlW) TransactionControl;
        PWCHAR temp = NULL;

        if ( CodePage == LANG_ACP) {
            
            err = ToUnicodeWithAlloc( (PCHAR) pTxControl->ldctl_oid,
                                      -1,
                                      &temp,
                                      LDAP_VALUE_SIGNATURE,
                                      LANG_ACP );
            
            if ( err != LDAP_SUCCESS) {
                SetConnectionError( Connection, err, NULL );
                return err;
            }
        }

        if ( ldapWStringsIdentical( (CodePage == LANG_UNICODE)?pTxControl->ldctl_oid:temp,
            -1,
            LDAP_SIMPLE_TRANSACT_OID_W,
            -1 ) ) {
                
            TransactionType = LDAP_SIMPLE_TRANSACTION;
            
        } else {
                
            TransactionType = LDAP_DISTRIBUTED_TRANSACTION;
        }

        ldapFree( temp, LDAP_VALUE_SIGNATURE );

    } else {

        return LDAP_PARAM_ERROR;
    }


    SetConnectionError( Connection, LDAP_SUCCESS, NULL );

    //
    // Send the extended request. It looks like this:
    //
    // An LDAP ExtendedRequest is defined as follows:
    //
    // ExtendedRequest ::= [APPLICATION 23] SEQUENCE {
    //         requestName             [0] LDAPOID,     // 1.2.840.113556.1.4.1501
    //         requestValue            [1] OCTET STRING OPTIONAL }
    //
    // A Start Transaction extended request is formed by setting the requestName
    // field to the OID of LDAP_TRANSACT_EXTENDED_OP_OID
    //
    // The requestValue is an OCTET STRING wrapping the BER-encoded version of
    // the following.
    //
    // lAUValue ::= SEQUENCE {
    //   semanticsOID    1.2.840.113556.1.4.1502   // Simple/Dist transaction semantics
    //   flag            integer                   // Start/End/Abandon transaction
    //   cookie          OCTET STRING              // Initial cookie
    // }
    //
    //

    CLdapBer *lber = NULL;

    lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

    if (lber == NULL) {
    
        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldapstarttransaction Connection 0x%x couldn't allocate lber.\n", Connection);
        }
        err = LDAP_NO_MEMORY;
        goto returnError;
    }
    
    hr = lber->HrStartWriteSequence();

    if (hr != NOERROR) {

        err = LDAP_ENCODING_ERROR;
        goto returnError;
    }
    
    hr = lber->HrAddValue( TransactionType == LDAP_SIMPLE_TRANSACTION ? LDAP_SIMPLE_TRANSACT_OID_W : LDAP_DISTRIBUTED_TRANSACT_OID_W );
    
    if (hr != NOERROR) {

        err = LDAP_ENCODING_ERROR;
        goto returnError;
    }
    
    hr = lber->HrAddValue( (LONG) TransactionOperation );

    if (hr != NOERROR) {

        err = LDAP_ENCODING_ERROR;
        goto returnError;
    }

    if (( cookie == NULL ) || ( cookie->bv_len == 0 )) {

        //
        // Send over a NULL cookie.
        //

        hr = lber->HrAddBinaryValue( (PBYTE) NULL,
                                     0
                                     );
    
    } else {

        hr = lber->HrAddBinaryValue( (PBYTE) cookie->bv_val,
                                     cookie->bv_len
                                     );
    }
                     
    if (hr != NOERROR) {

        err = LDAP_ENCODING_ERROR;
        goto returnError;
    }

    hr = lber->HrEndWriteSequence();
    ASSERT( hr == NOERROR );

    lauRequest.bv_len = lber->CbData();

    if (lauRequest.bv_len == 0) {

        err = LDAP_LOCAL_ERROR;
        goto returnError;
    }

    lauRequest.bv_val = (PCHAR) ldapMalloc( lauRequest.bv_len, LDAP_CONTROL_SIGNATURE );

    if (lauRequest.bv_val == NULL) {
    
        err = LDAP_NO_MEMORY;
        goto returnError;
    }
    
    CopyMemory( lauRequest.bv_val,
                lber->PbData(),
                lauRequest.bv_len );
    
    //
    // Send the extended request to the server.
    //

    err = LdapExtendedOp( Connection,
                          LDAP_TRANSACT_EXTENDED_OP_OID_W,
                          &lauRequest,
                          TRUE,          // Unicode
                          TRUE,          // Synchronous
                          ServerControls,
                          ClientControls,
                          &msgId
                          );

    //
    // Free the extended data we just sent across. We no longer need it.
    //

    ldapFree( lauRequest.bv_val, LDAP_CONTROL_SIGNATURE );

    if (msgId != (ULONG) -1) {
    
        //
        //  otherwise we simply need to wait for the response to come in.
        //
    
        err = ldap_result_with_error(  Connection,
                                       msgId,
                                       LDAP_MSG_ALL,
                                       TimeOut,
                                       &Result,
                                       NULL
                                       );
    
        if (Result != NULL) {
            
            err = ldap_result2error( Connection->ExternalInfo,
                                     Result,
                                     FALSE
                                     );
        }
    }


    if (err == LDAP_SUCCESS) {
        
        //
        // Parse the extended response for the cookie.
        //
        
        err = LdapParseExtendedResult( Connection,
                                       Result,
                                       &ResultOID,
                                       &ResultData,
                                       TRUE,       // Free the message
                                       LANG_UNICODE
                                       );

        if (err == LDAP_SUCCESS) {

            //
            // Verify that the response OID is indeed what we expect it to be.
            //

            if (!ldapWStringsIdentical( ResultOID,
                                       -1,
                                        LDAP_TRANSACT_EXTENDED_OP_OID_W,
                                       -1 )) {

                err = LDAP_OPERATIONS_ERROR;
                goto returnError;
            }

            //
            // Parse the response data to pick out the cookie and other fields.
            //
            // lAUValue ::= SEQUENCE {
            //
            //   error      ENUMERATED {
            //                success(0),
            //                gen failure (1),
            //                ...TBD...
            //               }
            //   timeout    integer
            //   cookie     OCTET STRING
            //  }
            //

            if ((ResultData == NULL) || (ResultData->bv_len == 0)) {
                
                //
                // Something wrong here.
                //

                LdapPrint2("ResultData is 0x%x len is 0x%x\n", ResultData, ResultData->bv_len);

                err = LDAP_OPERATIONS_ERROR;
                goto returnError;
            
            } else {

                BerElement *ber = NULL;
                PBERVAL    localCookie = NULL;
                int retval = LDAP_SUCCESS;
                int timeout = 0;

                ber = ber_init( ResultData );

                if ( ber == NULL ) {
                    err = LDAP_DECODING_ERROR;
                    goto returnError;
                }

                //
                // Pick out the enumerated server return value.
                //

                err = ber_scanf( ber, "{e", &retval  );

                if (err != LDAP_SUCCESS) {

                    ber_free( ber, 1);
                    goto returnError;
                }

                if ( ServerReturnValue ) {

                    *ServerReturnValue = retval;
                }
                
                //
                // Look for the timeout and cookie
                //

                err = ber_scanf( ber, "i", &timeout );

                if ((err != LDAP_SUCCESS) && ( TransactionOperation == LDAP_START_TRANSACTION )) {
                    ber_free( ber, 1);
                    goto returnError;
                }

                if ((err == LDAP_SUCCESS) && ( TransactionTimeLimit )) {

                    *TransactionTimeLimit = timeout;
                }

                err = ber_scanf( ber, "O", &localCookie  );

                if ((err != LDAP_SUCCESS) && ( TransactionOperation == LDAP_START_TRANSACTION )) {
                    ber_free( ber, 1);
                    goto returnError;
                }
                
                ber_free( ber, 1);
                
                err = LDAP_SUCCESS;

                //
                // Allocate a control and fill in the cookie as appropriate.
                //

                if ( TransactionOperation == LDAP_START_TRANSACTION ) {

                    err = LdapCreateTransactionControlWithAlloc( Connection,
                                                                 localCookie,
                                                                 TRUE,  // Criticality
                                                                 TransactionControl,
                                                                 CodePage
                                                                 );
                }
            }
        }
    }

returnError:

    if (lber != NULL) {
        delete lber;
    }

    //
    // We must always abandon the request because the library does not know
    // when an extended response ends.
    //

    LdapAbandon( Connection, msgId, FALSE );
    SetConnectionError( Connection, err, NULL );
    
    return err;

}



ULONG
LdapStartTransaction(
    IN  PLDAP  ExternalHandle,
    OUT PULONG  ServerReturnValue,
    OUT PULONG  TransactionTimeLimit,
    IN  struct l_timeval  *TimeOut,
    IN  PBERVAL  DistributedTransactionHandle,
    OUT PLDAPControlW  *TransactionControl,
    IN  PLDAPControlW  *ServerControls,
    IN  PLDAPControlW  *ClientControls,
    ULONG CodePage
)
//
// Sends out a Start Transaction PDU to the server. This is a synchronous call
// controlled by a client side timeout. On success, it allocates a Transaction
// control which must be later freed using ldap_control_free.
//
{
    PLDAP_CONN connection = NULL;
    ULONG err = 0;

    if ( TransactionControl == NULL ) {
    
        return LDAP_PARAM_ERROR;
    
    }
    
    connection = GetConnectionPointer(ExternalHandle);
    
    if (connection == NULL) {
    
        return LDAP_PARAM_ERROR;
    }

    err = LdapExchangeTransactionRequest( connection,
                                          LDAP_START_TRANSACTION,
                                          ServerReturnValue,
                                          TransactionTimeLimit,
                                          TimeOut,
                                          DistributedTransactionHandle,
                                          TransactionControl,
                                          ServerControls,
                                          ClientControls,
                                          CodePage );
    
    DereferenceLdapConnection( connection );

    return err;
}


ULONG
LdapEndTransaction(
    IN  PLDAP    ExternalHandle,
    IN  PLDAPControlW  TransactionControl,
    OUT PULONG ReturnValue,
    IN  BOOLEAN Abandon,
    IN  struct l_timeval  *TimeOut,
    IN  PLDAPControlW  *ServerControls,
    IN  PLDAPControlW  *ClientControls,
    IN  ULONG CodePage
)
//
// Sends out a Start Transaction PDU to the server. This is a synchronous call
// controlled by a client side timeout. On success, it denotes a successful
// End transaction exchange. The user still has to examine the ServerReturn value
// to determine if the commit/abandon succeeded.
//
{
    PLDAP_CONN connection = NULL;
    ULONG err;
    BerElement *pBer = NULL;
    PBERVAL    cookie = NULL;

    
    if ( TransactionControl == NULL ) {

        return LDAP_PARAM_ERROR;
    }

    connection = GetConnectionPointer(ExternalHandle);
    
    if (connection == NULL) {
    
        return LDAP_PARAM_ERROR;
    }

    //
    // Crack the control to retrieve the cookie to be used in this exchange.
    //

    pBer = ber_init( &(TransactionControl->ldctl_value) );

    if (pBer == NULL) {
        err = LDAP_DECODING_ERROR;
        goto returnError;
    }

    err = ber_scanf( pBer, "{O", &cookie  );

    if (err != LDAP_SUCCESS) {
        goto returnError;
    }


    err = LdapExchangeTransactionRequest ( connection,
                                           Abandon ? LDAP_ABANDON_TRANSACTION : LDAP_COMMIT_AND_END_TRANSACTION,
                                           ReturnValue,
                                           NULL,             // TransactionTimeLimit
                                           TimeOut,
                                           cookie,           // serverreturnedCookie
                                           (PLDAPControlW*) TransactionControl,
                                           ServerControls,
                                           ClientControls,
                                           CodePage
                                           );

  returnError:

    DereferenceLdapConnection( connection );

    if ( pBer ) {
        ber_free( pBer, 1);
    }

    if ( cookie ) {
        ber_bvfree( cookie );
    }
    
    return err;

}

ULONG
LdapEncodeTransactionControl (
    PLDAP_CONN      connection,
    PBERVAL  cookie,
    PLDAPControlW  OutputControl,
    BOOLEAN Criticality,
    ULONG CodePage
    )
{
    ULONG err;
    CLdapBer *lber = NULL;
    PLDAPSortKeyW sortKey;
    ULONG hr = NOERROR;

    if ((connection == NULL) || (OutputControl == NULL)) {

        return LDAP_PARAM_ERROR;
    }

    OutputControl->ldctl_oid = NULL;
    OutputControl->ldctl_iscritical = Criticality;

    if (CodePage == LANG_UNICODE) {

        OutputControl->ldctl_oid = ldap_dup_stringW( LDAP_SIMPLE_TRANSACT_OID_W,
                                                     0,
                                                     LDAP_VALUE_SIGNATURE );
    } else {

        OutputControl->ldctl_oid = (PWCHAR) ldap_dup_string(  LDAP_SIMPLE_TRANSACT_OID,
                                                              0,
                                                              LDAP_VALUE_SIGNATURE );
    }

    if (OutputControl->ldctl_oid == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodeTransactControl;
    }

    lber = new CLdapBer( connection->publicLdapStruct.ld_version );

    if (lber == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodeTransactControl;
    }

    //
    //
    // The lAUControlValue is an OCTET STRING wrapping the BER-encoded
    // version of the lAU identifier cookie:
    // lAUControlValue ::= SEQUENCE {
    //            cookie          OCTET STRING
    // }
    //


    hr = lber->HrStartWriteSequence();

    if (hr != LDAP_SUCCESS) {

        err = LDAP_ENCODING_ERROR;
        goto exitEncodeTransactControl;
    }

    hr = lber->HrAddBinaryValue( (PBYTE) cookie->bv_val, cookie->bv_len, BER_OCTETSTRING );

    if (hr != LDAP_SUCCESS) {

        err = LDAP_ENCODING_ERROR;
        goto exitEncodeTransactControl;
    }

    hr = lber->HrEndWriteSequence();
    ASSERT( hr == NOERROR );

    OutputControl->ldctl_value.bv_len = lber->CbData();

    if (OutputControl->ldctl_value.bv_len == 0) {

        err = LDAP_LOCAL_ERROR;
        goto exitEncodeTransactControl;
    }

    OutputControl->ldctl_value.bv_val = (PCHAR) ldapMalloc(
                            OutputControl->ldctl_value.bv_len,
                            LDAP_CONTROL_SIGNATURE );

    if (OutputControl->ldctl_value.bv_val == NULL) {

        err = LDAP_NO_MEMORY;
        goto exitEncodeTransactControl;
    }

    CopyMemory( OutputControl->ldctl_value.bv_val,
                lber->PbData(),
                OutputControl->ldctl_value.bv_len );

    err = LDAP_SUCCESS;

exitEncodeTransactControl:

    if (err != LDAP_SUCCESS) {

        if (OutputControl->ldctl_oid != NULL) {

            ldapFree( OutputControl->ldctl_oid, LDAP_VALUE_SIGNATURE );
            OutputControl->ldctl_oid = NULL;
        }

        OutputControl->ldctl_value.bv_len = 0;
    }

    if (lber != NULL) {
        delete lber;
    }
    
    return err;

}



ULONG
LdapCreateTransactionControlWithAlloc(
    IN  PLDAP_CONN connection,
    IN  PBERVAL Cookie,
    IN  BOOLEAN IsCritical,
    OUT PLDAPControlW *TransactionControl,
    ULONG CodePage
    )
{
    ULONG err;
    BOOLEAN criticality = IsCritical;
    PLDAPControlW  control = NULL;

    control = (PLDAPControlW) ldapMalloc( sizeof( LDAPControlW ), LDAP_CONTROL_SIGNATURE );

    if (control == NULL) {

        *TransactionControl = NULL;
        return LDAP_NO_MEMORY;
    }

    err = LdapEncodeTransactionControl(  connection,
                                         Cookie,
                                         control,
                                         criticality,
                                         CodePage );

    if (err != LDAP_SUCCESS) {

        ldap_control_freeW( control );
        control = NULL;
    }

    *TransactionControl = control;

    return err;

}



ULONG
LdapParseTransactionControl (
        IN  PLDAP_CONN      connection,
        IN  PLDAPControlW  *ServerControls,
        OUT ULONG          *Result,
        IN  ULONG           CodePage
        )
{
    ULONG err = LDAP_CONTROL_NOT_FOUND;
    CLdapBer *lber = NULL;
    ULONG  hr = NOERROR;

    //
    //  First thing is to zero out the parms passed in.
    //

    if (Result != NULL) {

        *Result = 0;
    }

    if (ServerControls != NULL) {

        PLDAPControlW *controls = ServerControls;
        PLDAPControlW currentControl;
        ULONG bytesTaken;
        LONG  txError;

        while (*controls != NULL) {

            currentControl = *controls;

            //
            //  check to see if the current control is the Transaction control
            //

            if ( ((CodePage == LANG_UNICODE) &&
                  ( ldapWStringsIdentical( currentControl->ldctl_oid,
                                           -1,
                                           LDAP_SIMPLE_TRANSACT_OID_W,
                                           -1 ) == TRUE )) ||
                 ((CodePage == LANG_ACP) &&
                  ( CompareStringA( LDAP_DEFAULT_LOCALE,
                                    NORM_IGNORECASE,
                                    (PCHAR) currentControl->ldctl_oid,
                                    -1,
                                    LDAP_SIMPLE_TRANSACT_OID,
                                    sizeof(LDAP_SIMPLE_TRANSACT_OID) ) == 2)) ) {

                //
                // The lAUResponseControlValue is defined as follows:
                //
                //  lAUResponseControlValue ::= SEQUENCE {
                //
                //          lauResult  ENUMERATED {
                //                        success (0),
                //                        timeLimitExceeded (3),
                //                        busy(51),
                //                        unwillingToPerform (53),
                //                        other(80) }
                //            }
                //

                lber = new CLdapBer( connection->publicLdapStruct.ld_version );

                if (lber == NULL) {

                    IF_DEBUG(OUTMEMORY) {
                        LdapPrint1( "LdapParseTxControl: unable to alloc msg for 0x%x.\n",
                                    connection );
                    }

                    err = LDAP_NO_MEMORY;
                    break;
                }

                hr = lber->HrLoadBer(   (const BYTE *) currentControl->ldctl_value.bv_val,
                                         currentControl->ldctl_value.bv_len,
                                         &bytesTaken,
                                         TRUE );    // we have the whole message guarenteed

                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseTxControl: loadBer error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    err = LDAP_DECODING_ERROR;
                    break;
                }

                hr = lber->HrStartReadSequence();
                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseTxControl: loadBer error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    err = LDAP_DECODING_ERROR;
                    break;
                }

                hr = lber->HrGetEnumValue( &txError );
                if (hr != NOERROR) {

                    IF_DEBUG(PARSE) {
                        LdapPrint2( "LdapParseTxControl: getEnumValue error of 0x%x for 0x%x.\n",
                                    err, connection );
                    }
                    err = LDAP_DECODING_ERROR;
                    break;
                }

                if (Result != NULL) {

                    *Result = txError;
                }

                err = LDAP_SUCCESS;
                break;                  // done with loop... look no more
            }
            controls++;
        }
    }
    
    if (lber != NULL) {

        delete lber;
    }

    SetConnectionError( connection, err, NULL );
    return err;
}


WINLDAPAPI
ULONG LDAPAPI
ldap_start_transaction_sW (
    IN   PLDAP          ExternalHandle,
    OUT  PULONG         ServerReturnValue,
    OUT  PULONG         TransactionTimeLimit,
    IN   PBERVAL        DistributedTransactionHandle,
    OUT  PLDAPControlW  *TransactionControl,
    IN   PLDAPControlW  *ServerControls,
    IN   PLDAPControlW  *ClientControls,
    IN   struct l_timeval  *TimeOut
)
{

    return LdapStartTransaction( ExternalHandle,
                                 ServerReturnValue,
                                 TransactionTimeLimit,
                                 TimeOut,
                                 DistributedTransactionHandle,
                                 TransactionControl,
                                 ServerControls,
                                 ClientControls,
                                 LANG_UNICODE
                                 );
}

WINLDAPAPI
ULONG LDAPAPI
ldap_start_transaction_sA (
    IN   PLDAP          ExternalHandle,
    OUT  PULONG         ServerReturnValue,
    OUT  PULONG         TransactionTimeLimit,
    IN   PBERVAL        DistributedTransactionHandle,
    OUT  PLDAPControlA  *TransactionControl,
    IN   PLDAPControlA  *ServerControls,
    IN   PLDAPControlA  *ClientControls,
    IN   struct l_timeval  *TimeOut
)
{

    return LdapStartTransaction( ExternalHandle,
                                 ServerReturnValue,
                                 TransactionTimeLimit,
                                 TimeOut,
                                 DistributedTransactionHandle,
                                 (PLDAPControlW *) TransactionControl,
                                 (PLDAPControlW *) ServerControls,
                                 (PLDAPControlW *) ClientControls,
                                 LANG_ACP
                                 );
}


WINLDAPAPI
ULONG LDAPAPI
ldap_parse_transaction_controlA (
        IN   PLDAP           ExternalHandle,
        IN   PLDAPControlA  *ResponseControl,
        OUT  ULONG          *ServerError
        )
{

    PLDAP_CONN connection = NULL;
    ULONG err;
    
    connection = GetConnectionPointer(ExternalHandle);
    
    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    err = LdapParseTransactionControl( connection,
                                       (PLDAPControlW *) ResponseControl,
                                       ServerError,
                                       LANG_ACP
                                       );
    
    DereferenceLdapConnection( connection );

    return err;
}


WINLDAPAPI
ULONG LDAPAPI
ldap_parse_transaction_controlW (
        IN   PLDAP           ExternalHandle,
        IN   PLDAPControlW  *ResponseControl,
        OUT  ULONG          *ServerError
        )
{

    PLDAP_CONN connection = NULL;
    ULONG err;
    
    connection = GetConnectionPointer(ExternalHandle);
    
    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }


    err = LdapParseTransactionControl( connection,
                                       ResponseControl,
                                       ServerError,
                                       LANG_UNICODE
                                       );

    DereferenceLdapConnection( connection );

    return err;
}

WINLDAPAPI
ULONG LDAPAPI
ldap_end_transaction_sW (
    IN  PLDAP    ExternalHandle,
    IN  PLDAPControlW TransactionControl,
    OUT PULONG ReturnValue,
    IN  BOOLEAN Abandon,
    IN  PLDAPControlW  *ServerControls,
    IN  PLDAPControlW  *ClientControls,
    IN  struct l_timeval  *TimeOut
)
{

    return LdapEndTransaction( ExternalHandle,
                               TransactionControl,
                               ReturnValue,
                               Abandon,
                               TimeOut,
                               ServerControls,
                               ClientControls,
                               LANG_UNICODE);
}

WINLDAPAPI
ULONG LDAPAPI
ldap_end_transaction_sA (
    IN  PLDAP         ExternalHandle,
    IN  PLDAPControlA TransactionControl,
    OUT PULONG       ReturnValue,
    IN  BOOLEAN          Abandon,
    IN  PLDAPControlA  *ServerControls,
    IN  PLDAPControlA  *ClientControls,
    IN  struct l_timeval  *TimeOut
)
{

    return LdapEndTransaction( ExternalHandle,
                               (PLDAPControlW) TransactionControl,
                               ReturnValue,
                               Abandon,
                               TimeOut,
                               (PLDAPControlW *) ServerControls,
                               (PLDAPControlW *) ClientControls,
                               LANG_ACP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\starttls.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    starttls.cxx  StartTLS support routines for the LDAP api

Abstract:

   This module implements routines that handle establishment of
   Transport layer security on the fly. This implementation is
   based on v6 of the draft. draft-ietf-ldapext-ldapv3-tls-06.txt

Author:

    Anoop Anantha (AnoopA)        20-Mar-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"


ULONG
LdapStartTLS ( 
    IN  PLDAP ExternalHandle,
    OUT PULONG ServerReturnValue,
    OUT LDAPMessage  **result,
    IN  PLDAPControlW *ServerControls,
    IN  PLDAPControlW *ClientControls,
    IN  ULONG CodePage
 )
//
// This API is called by users to initiate Transport Level Security on an
// LDAP connection. If the server accepts our proposal and initiates TLS,
// this API will return LDAP_SUCCESS.
//
// If the server failed request for whatever reason, the API returns LDAP_OTHER
// and the ServerReturnValue will contain the error code from the server.
//
// It is possible that the server returns a referral - either in response to the
// StartTLS request or during the subsequent encrypted session. For security
// reasons, we have decided to NOT chase referrals by default. In the former case,
// the referral message is returned as an LDAPMessage to the user.
//
// The operation has a default timeout of about 30 seconds as defined by
// LDAP_SSL_NEGOTIATE_TIME_DEFAULT
//
{
    PLDAP_CONN connection = NULL;
    ULONG err;
    ULONG secErr = LDAP_SUCCESS;
    PLIST_ENTRY listEntry;
    PLDAP_REQUEST request;
    ULONG msgId;
    LDAPMessage   *Res = NULL;
    PWCHAR  ResultOID = NULL;
    ULONG ServerError = LDAP_PROTOCOL_ERROR;

    DBG_UNREFERENCED_PARAMETER( CodePage );
    
    connection = GetConnectionPointer(ExternalHandle);
    
    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    if (ServerReturnValue) {
        *ServerReturnValue = NULL;
    }

    if (result) {
        *result = NULL;
    }

    err = LdapConnect( connection, NULL, FALSE );
    
    if (err != LDAP_SUCCESS) {
    
       SetConnectionError( connection, err, NULL );
       DereferenceLdapConnection(connection);
       return err;
    }

    ACQUIRE_LOCK( &connection->StateLock );
    
    //
    // We fail the request if 
    // - TLS is already established.
    // - Signing/sealing is on.
    // - Bind is in progress
    //

    if ((connection->SecureStream)       ||
        (connection->SslSetupInProgress) ||
        (connection->BindInProgress)) {

        RELEASE_LOCK( &connection->StateLock );
        DereferenceLdapConnection(connection);
        return LDAP_UNWILLING_TO_PERFORM;
    }

    RELEASE_LOCK( &connection->StateLock );

    //
    // Step through the global request list to see if this connection has
    // any outstanding requests.
    //

    ACQUIRE_LOCK( &RequestListLock );

    listEntry = GlobalListRequests.Flink;

    while (listEntry != &GlobalListRequests) {

        request = CONTAINING_RECORD( listEntry, LDAP_REQUEST, RequestListEntry );
        request = ReferenceLdapRequest(request);

        if (!request) {
            listEntry = listEntry->Flink;
            continue;
        }

        ACQUIRE_LOCK( &request->Lock );

        if (connection == request->PrimaryConnection) {

            //
            // Bummer, we have outstanding requests on this connection.
            //

            DereferenceLdapRequest( request );
            RELEASE_LOCK( &request->Lock );
            RELEASE_LOCK( &RequestListLock );

            DereferenceLdapConnection(connection);
            return LDAP_UNWILLING_TO_PERFORM;
        }

        DereferenceLdapRequest( request );
        RELEASE_LOCK( &request->Lock );
    }

    //
    // We have no outstanding requests at this point. Hang on to the
    // requestlistlock to ensure that no new requests slip in.
    //
    //
    // Send the StartTLS PDU to the server. It looks like this
    //
    // An LDAP ExtendedRequest is defined as follows:
    //
    // ExtendedRequest ::= [APPLICATION 23] SEQUENCE {
    //         requestName             [0] LDAPOID,     // 1.3.6.1.4.1.1466.20037
    //         requestValue            [1] OCTET STRING OPTIONAL }
    //
    // The requestValue field is absent.
    //

    err = LdapExtendedOp( connection,
                          LDAP_START_TLS_OID_W, // requestName
                          NULL,          // requestValue
                          TRUE,          // Unicode
                          TRUE,          // Synchronous
                          ServerControls,
                          ClientControls,
                          &msgId
                          );

    if (err != LDAP_SUCCESS) {

        goto returnError;
    }

    if (msgId != (ULONG) -1) {
    
        //
        //  otherwise we simply need to wait for the response to come in.
        //
    
        struct l_timeval Timeout;

        Timeout.tv_sec = LDAP_SSL_NEGOTIATE_TIME_DEFAULT;
        Timeout.tv_usec = 0;

        // We need to release the lock in order to avoid risking violating the
        // locking order.
        GlobalRejectNewRequests++;
        RELEASE_LOCK( &RequestListLock );
        
        err = ldap_result_with_error(  connection,
                                       msgId,
                                       LDAP_MSG_ALL,
                                       &Timeout,
                                       &Res,
                                       NULL
                                       );
                                       
        ACQUIRE_LOCK( &RequestListLock );
        GlobalRejectNewRequests--;
    
        if (err != LDAP_SUCCESS) {

            goto returnError;
        }
        
        if (Res != NULL) {

            ServerError = ldap_result2error( connection->ExternalInfo,
                                             Res,
                                             FALSE
                                             );

            if (ServerReturnValue) {
                *ServerReturnValue = ServerError;
            }
        }
    }

    if (ServerError != LDAP_SUCCESS) {

        //
        // The server did not like our request for whatever reason. The user
        // has to consult the ServerReturnValue for more info.
        //

        err = LDAP_OTHER;
    }

    if ((ServerError == LDAP_REFERRAL) ||
         (ServerError == LDAP_REFERRAL_V2)) {
        
        //
        // Return the referral to the user.
        //

        if (result) {
            *result = Res;
        }
    }

    if (err == LDAP_SUCCESS) {
        
        //
        // Parse the extended response for the OID
        //
        
        err = LdapParseExtendedResult( connection,
                                       Res,
                                       &ResultOID,
                                       NULL,
                                       TRUE,       // Free the message
                                       LANG_UNICODE
                                       );

        if (err == LDAP_SUCCESS) {

            //
            // Verify that the response OID is indeed what we expect it to be.
            //

            if (!ldapWStringsIdentical( ResultOID,
                                       -1,
                                        LDAP_START_TLS_OID_W,
                                       -1 )) {

                err = LDAP_OPERATIONS_ERROR;
                goto returnError;
            }

        }
    }

    if (err != LDAP_SUCCESS) {

        goto returnError;
    }

    secErr = LdapConvertSecurityError( connection,
                                       LdapSetupSslSession( connection )
                                     );


    err = secErr;

returnError:

    RELEASE_LOCK( &RequestListLock );

    //
    // We must always abandon the request because the library does not know
    // when an extended response ends.
    //

    if (msgId != (ULONG) -1) {
        LdapAbandon( connection, msgId, FALSE );
    }

    if (err == LDAP_SUCCESS) {
        
        //
        // Disable automatic referral chasing on this connection.
        //
        
        ACQUIRE_LOCK( &connection->StateLock );

        connection->PreTLSOptions = connection->publicLdapStruct.ld_options;
        connection->publicLdapStruct.ld_options &= ~LDAP_OPT_CHASE_REFERRALS;
        connection->publicLdapStruct.ld_options &= ~LDAP_CHASE_SUBORDINATE_REFERRALS;
        connection->publicLdapStruct.ld_options &= ~LDAP_CHASE_EXTERNAL_REFERRALS;

        //
        // Disable autoreconnect on this connection.
        //
        
        connection->AutoReconnect = FALSE;

        connection->SslPort = TRUE;
        RELEASE_LOCK( &connection->StateLock );

    }
    else if (secErr != LDAP_SUCCESS) {
        //
        // We failed during SSL negotiations.
        // Terminate the connection.
        //
        //
        // We can't call CloseLdapConnection() because the user can't unbind the connection
        // due to the connection state being set to closed, thus leaking the connection.
        // Our only option is to set the state to HostConnectState to Error and set
        // autoreconnect to OFF. This will prevent autoreconnects yet convey an 
        // error (LDAP_SERVER_DOWN) to the user.  Preventing autoreconnect ensures that the
        // user won't unknowingly get reconnected with a non-secure connection.
        //

        connection->ServerDown = TRUE;
        connection->HostConnectState = HostConnectStateError;
        connection->AutoReconnect = FALSE;
    }

    DereferenceLdapConnection(connection);
    SetConnectionError( connection, err, NULL );
    return err;

}


WINLDAPAPI
BOOLEAN LDAPAPI
ldap_stop_tls_s ( 
    IN  PLDAP ExternalHandle
 )
//
// This API is called by the user to stop Transport Level Security on an open
// LDAP connection on which TLS has already been started.
//
// If the operation succeeds, the user can resume normal plaintext LDAP
// operations on the connection.
//
// If the operation fails, the user MUST close the connection by calling
// ldap_unbind as the TLS state of the connection will be indeterminate.
//
// The operation has a default timeout of about 30 seconds as defined by
// LDAP_SSL_NEGOTIATE_TIME_DEFAULT
//
{
    PLDAP_CONN connection = NULL;
    ULONG err;
    PLIST_ENTRY listEntry;
    PLDAP_REQUEST request;
    PSECURESTREAM pSecureStream;
    
    connection = GetConnectionPointer(ExternalHandle);
    
    if (connection == NULL) {
        return FALSE;
    }

    ACQUIRE_LOCK( &connection->StateLock );
    
    //
    // We fail the request if 
    //
    // - The connection is not actively connected to the server.
    // - TLS is not already established.
    // - Signing/sealing is on.
    // - Bind is in progress
    //

    pSecureStream = (PSECURESTREAM) connection->SecureStream;

    if ((connection->HostConnectState != HostConnectStateConnected)  ||
        (!pSecureStream) ||
//      (connection->UserSignDataChoice) ||
//      (connection->UserSealDataChoice) ||
        (connection->CurrentSignStatus) ||
        (connection->CurrentSealStatus) ||
        (connection->SslSetupInProgress) ||
        (connection->BindInProgress)) {

        RELEASE_LOCK( &connection->StateLock );
        DereferenceLdapConnection(connection);
        return FALSE;
    }

    RELEASE_LOCK( &connection->StateLock );

    //
    //  Abandon all requests where this connection is the primary conn
    //
    
    ACQUIRE_LOCK( &RequestListLock );

    listEntry = GlobalListRequests.Flink;

    while (listEntry != &GlobalListRequests) {

        request = CONTAINING_RECORD( listEntry, LDAP_REQUEST, RequestListEntry );

        request = ReferenceLdapRequest( request );

        if (!request) {
            listEntry = listEntry->Flink;
            continue;
        }

        ACQUIRE_LOCK( &request->Lock );

        if ( (request->PrimaryConnection == connection) &&
             (request->Closed == FALSE)) {

            RELEASE_LOCK( &request->Lock );
            RELEASE_LOCK( &RequestListLock );

            //
            //  Abandon the request explicitly.
            //

            LdapAbandon( request->PrimaryConnection,
                         request->MessageId,
                         TRUE );

            DereferenceLdapRequest( request );

            ACQUIRE_LOCK( &RequestListLock );

            //
            //  We have to start at the top of the list again because the
            //  list may have changed since we freed the lock.  Not the
            //  best, but unless we change the locking order, it will have
            //  to do.
            //

            listEntry = GlobalListRequests.Flink;

        } else {

            RELEASE_LOCK( &request->Lock );
            listEntry = listEntry->Flink;
            DereferenceLdapRequest( request );
        }
    }

    //
    // Bring down the TLS connection.
    //

    err = LdapConvertSecurityError( connection, 
                                    pSecureStream->TearDownSecureConnection()
                                    );

    if (err != LDAP_SUCCESS) {

        LdapPrint1("TearDownSecureConnection returned 0x%x\n", err);
    }

    delete pSecureStream;
    connection->SecureStream = NULL;

    RELEASE_LOCK( &RequestListLock );
    
    //
    // Restore the referral chasing and autoreconnect options on the connection.
    //

    ACQUIRE_LOCK( &connection->StateLock );
    
    connection->publicLdapStruct.ld_options |= connection->PreTLSOptions;
    connection->AutoReconnect = connection->UserAutoRecChoice;
    connection->SslPort = FALSE;

    RELEASE_LOCK( &connection->StateLock );

    DereferenceLdapConnection(connection);
    SetConnectionError( connection, err, NULL );
    return (err == LDAP_SUCCESS) ? TRUE : FALSE;
}


WINLDAPAPI
ULONG LDAPAPI
ldap_start_tls_sW (
    IN   PLDAP          ExternalHandle,
    OUT  PULONG         ServerReturnValue,
    OUT  LDAPMessage    **result,
    IN   PLDAPControlW  *ServerControls,
    IN   PLDAPControlW  *ClientControls
)
{

    return LdapStartTLS( ExternalHandle,
                         ServerReturnValue,
                         result,
                         ServerControls,
                         ClientControls,
                         LANG_UNICODE
                         );
}

WINLDAPAPI
ULONG LDAPAPI
ldap_start_tls_sA (
    IN   PLDAP          ExternalHandle,
    OUT  PULONG         ServerReturnValue,
    OUT  LDAPMessage    **result,
    IN   PLDAPControlA  *ServerControls,
    IN   PLDAPControlA  *ClientControls
)
{

    return LdapStartTLS( ExternalHandle,
                         ServerReturnValue,
                         result,
                         (PLDAPControlW *) ServerControls,
                         (PLDAPControlW *) ClientControls,
                         LANG_ACP
                         );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\unbind.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    unbind.c  unbind a connection to an LDAP server

Abstract:

   This module implements the LDAP ldap_unbind API.

   It also implements routines to clean up LDAP connection blocks.

Author:

    Andy Herron    (andyhe)        17-May-1996
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"


//
//  This routine is one of the main entry points for clients calling into the
//  ldap API.
//

ULONG __cdecl
ldap_unbind (
    LDAP *ExternalHandle
    )
{
    PLDAP_CONN connection = NULL;

    connection = GetConnectionPointer(ExternalHandle);

    if (connection == NULL) {
        return LDAP_PARAM_ERROR;
    }

    IF_DEBUG(CONNECTION) {
        LdapPrint2( "ldap_unbind called for conn 0x%x, host is %s.\n",
                        connection, connection->publicLdapStruct.ld_host);
    }

    DSLOG((DSLOG_FLAG_TAG_CNPN,"[+][ID=0][OP=ldap_unbind]"));
    DSLOG((0,"[-]\n"));

    ACQUIRE_LOCK( &connection->StateLock);

    if (connection->HandlesGivenToCaller > 0) {

       connection->HandlesGivenToCaller--;
    }

    if ((connection->HandlesGivenToCaller == 0 ) &&
        (connection->HandlesGivenAsReferrals == 0)) {

        RELEASE_LOCK( &connection->StateLock);

        CloseLdapConnection( connection );

    }
    else {

        RELEASE_LOCK( &connection->StateLock);
    }

    DereferenceLdapConnection( connection );

    return LDAP_SUCCESS;
}


ULONG __cdecl
ldap_unbind_s (
    LDAP *ExternalHandle
    )
{
    return( ldap_unbind( ExternalHandle ) );
}

VOID
CloseLdapConnection (
    IN PLDAP_CONN Connection
    )

/*++

Routine Description:

    This function closes a connection (virtual circuit).

    *** This routine must NOT be entered with the connection lock held!

Arguments:

    Connection - Supplies a pointer to a Connection Block

Return Value:

    None.

--*/

{
    CLdapBer *lber;
    LONG messageNumber = 0;
    ULONG err;
    PLIST_ENTRY listEntry;
    PLDAP_MESSAGEWAIT waitStructure = NULL;

    ASSERT( Connection != NULL );

    //
    // Acquire the lock that guards the connection's state field.
    //

    ACQUIRE_LOCK( &Connection->StateLock);

    //
    // If the connection hasn't already been closed, do so now.
    //

    if (Connection->ConnObjectState == ConnObjectActive) {

        IF_DEBUG(CONNECTION) {
            LdapPrint1( "Closing connection at %lx\n", Connection );
        }

        Connection->ConnObjectState = ConnObjectClosing;

        RELEASE_LOCK( &Connection->StateLock );

        //
        // Wake up select
        //

        LdapWakeupSelect();

        //
        //  Signal all waiting threads.  This should cause the waiting thread
        //  to delete the wait block.
        //

        ACQUIRE_LOCK( &ConnectionListLock );

        listEntry = GlobalListWaiters.Flink;

        while (listEntry != &GlobalListWaiters) {

            waitStructure = CONTAINING_RECORD( listEntry,
                                               LDAP_MESSAGEWAIT,
                                               WaitListEntry );
            listEntry = listEntry->Flink;

            if (waitStructure->Connection == Connection) {

                waitStructure->Satisfied = TRUE;
                SetEvent( waitStructure->Event );
            }
        }

        RELEASE_LOCK( &ConnectionListLock );

        if ((Connection->TcpHandle != INVALID_SOCKET) &&
            (Connection->SentPacket == TRUE)          &&
            (Connection->HostConnectState == HostConnectStateConnected)) {

            //
            //  Send the server an unbind message if we actually have a connection
            //  to the server.
            //
            //  the ldapv2 disconnect message looks like this :
            //
            //  UnbindRequest ::= [APPLICATION 2] NULL
            //

            lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

            if (lber != NULL) {

                GET_NEXT_MESSAGE_NUMBER( messageNumber );
                Connection->publicLdapStruct.ld_msgid = messageNumber;

                err = lber->HrStartWriteSequence();

                if (err == NOERROR) {
                    err = lber->HrAddValue( messageNumber );

                    if (err == NOERROR) {
                        err = lber->HrAddTag(LDAP_UNBIND_CMD);

                        if (err == NOERROR) {
                            err = lber->HrEndWriteSequence();

                            if (err == NOERROR) {
                            
                                //
                                //  send the unbind request.
                                //

                                err = LdapSend( Connection, lber );

                                if (err != LDAP_SUCCESS) {

                                    IF_DEBUG(NETWORK_ERRORS) {
                                        LdapPrint2( "LdapCloseConn connection 0x%x send with error of 0x%x.\n",
                                                    Connection, err );
                                    }
                                }
                            }
                        }
                    }
                }
                
                delete lber;

            } else {

                IF_DEBUG(OUTMEMORY) {
                    LdapPrint1( "LdapCloseConn connection 0x%x could not allocate unbind.\n",
                                Connection );
                }
            }
        }

        CloseCredentials( Connection );

        //
        //  Remove all requests where this connection is the primary conn
        //

        ACQUIRE_LOCK( &RequestListLock );

        listEntry = GlobalListRequests.Flink;

        PLDAP_REQUEST request;

        while (listEntry != &GlobalListRequests) {

            request = CONTAINING_RECORD( listEntry, LDAP_REQUEST, RequestListEntry );

            request = ReferenceLdapRequest( request );

            if (!request) {
                listEntry = listEntry->Flink;
                continue;
            }

            if ( (request->PrimaryConnection == Connection) &&
                 (request->Closed == FALSE)) {

                RELEASE_LOCK( &RequestListLock );

                //
                //  CloseLdapMessage MUST remove it from the list or we loop here.
                //

                CloseLdapRequest( request );

                DereferenceLdapRequest( request );

                ACQUIRE_LOCK( &RequestListLock );

                //
                //  We have to start at the top of the list again because the
                //  list may have changed since we freed the lock.  Not the
                //  best, but unless we change the locking order, it will have
                //  to do.
                //

                listEntry = GlobalListRequests.Flink;

            } else {

                listEntry = listEntry->Flink;
                DereferenceLdapRequest( request );
            }
        }

        RELEASE_LOCK( &RequestListLock );

        //
        // We always dereference the connection after we call CloseLdapConnection
        // So, the ref count has to be greater than 1.
        //

        ASSERT( Connection->ReferenceCount > 1 );
        DereferenceLdapConnection( Connection );

        ACQUIRE_LOCK( &Connection->StateLock );

        Connection->ConnObjectState = ConnObjectClosed;

        RELEASE_LOCK( &Connection->StateLock );

    } else {

        RELEASE_LOCK( &Connection->StateLock);
    }

    return;

} // CloseLdapConnection


VOID
DereferenceLdapConnection2 (
    PLDAP_CONN Connection
    )
{
    PLIST_ENTRY receiveList;
    PERROR_ENTRY errorEntry;
    PLIST_ENTRY  errorList;
    PLDAP_RECVBUFFER buffer;
    PSECURESTREAM pSecureStream;
    ULONG CurrentThreadId = GetCurrentThreadId();
    PLIST_ENTRY pThreadListEntry = NULL;

    ASSERT( Connection->ConnObjectState == ConnObjectClosed );

    ldap_msgfree( Connection->BindResponse );

    //
    //  remove from global list of connections
    //

    ACQUIRE_LOCK( &ConnectionListLock );

    if (Connection->ConnectionListEntry.Flink != NULL) {

        RemoveEntryList( &Connection->ConnectionListEntry );
        Connection->ConnectionListEntry.Flink = NULL;
    }
    RELEASE_LOCK( &ConnectionListLock );

    //
    //  delete any partial messages we have allocated.
    //

    if (Connection->PendingMessage != NULL) {

        CLdapBer *lber = (CLdapBer *) Connection->PendingMessage->lm_ber;

        if (lber != NULL) {

            delete lber;
        }
        ldapFree( Connection->PendingMessage, LDAP_MESG_SIGNATURE );
        Connection->PendingMessage = NULL;
    }

    InterlockedDecrement( &GlobalConnectionCount );

    //
    //  now that conn is dead, free all receive buffers allocated for
    //  this connection.
    //

    receiveList = Connection->PendingCryptoList.Flink;
    while (receiveList != &Connection->PendingCryptoList) {

        buffer = CONTAINING_RECORD(   receiveList,
                                      LDAP_RECVBUFFER,
                                      ReceiveListEntry );

        receiveList = receiveList->Flink;

        LdapFreeReceiveStructure( buffer, TRUE );
    }

    receiveList = Connection->CompletedReceiveList.Flink;
    while (receiveList != &Connection->CompletedReceiveList) {

        buffer = CONTAINING_RECORD(   receiveList,
                                      LDAP_RECVBUFFER,
                                      ReceiveListEntry );

        receiveList = receiveList->Flink;

        LdapFreeReceiveStructure( buffer, TRUE );
    }

    //
    // Delete the error and attribute entries corresponding to
    // this connection for all threads.
    //
    ACQUIRE_LOCK( &PerThreadListLock );
    pThreadListEntry = GlobalPerThreadList.Flink;

    // iterate through each thread's THREAD_ENTRY
    while (pThreadListEntry != &GlobalPerThreadList) {
        PTHREAD_ENTRY pThreadEntry = NULL;

        PERROR_ENTRY pErrorEntry;
        PERROR_ENTRY * ppNextError;

        PLDAP_ATTR_NAME_THREAD_STORAGE pAttrEntry;
        PLDAP_ATTR_NAME_THREAD_STORAGE * ppNextAttr;
        
        pThreadEntry = CONTAINING_RECORD( pThreadListEntry, THREAD_ENTRY, ThreadEntry );
        pThreadListEntry = pThreadListEntry->Flink;

        // error entries
        pErrorEntry = pThreadEntry->pErrorList;
        ppNextError = &(pThreadEntry->pErrorList);

        while (pErrorEntry) {

            if (pErrorEntry->Connection == Connection) {
                *ppNextError = pErrorEntry->pNext;

                if (pErrorEntry->ErrorMessage != NULL) {

                    ldap_memfreeW( pErrorEntry->ErrorMessage );
                    pErrorEntry->ErrorMessage = NULL;
                }
                
                ldapFree( pErrorEntry, LDAP_ERROR_SIGNATURE );
                break;
            }

            ppNextError = &(pErrorEntry->pNext);
            pErrorEntry = pErrorEntry->pNext;
        }

        // attribute entries
        pAttrEntry = pThreadEntry->pCurrentAttrList;
        ppNextAttr = &(pThreadEntry->pCurrentAttrList);

        while (pAttrEntry) {

            if (pAttrEntry->PrimaryConn == Connection) {
                *ppNextAttr = pAttrEntry->pNext;
                ldapFree( pAttrEntry, LDAP_ATTR_THREAD_SIGNATURE );
                break;
            }

            ppNextAttr = &(pAttrEntry->pNext);
            pAttrEntry = pAttrEntry->pNext;
        }
        
    }
    
    RELEASE_LOCK( &PerThreadListLock );


    pSecureStream = (PSECURESTREAM) Connection->SecureStream;
    delete pSecureStream;

    DELETE_LOCK( &Connection->ScramblingLock );

    Connection->ExternalInfo = NULL;        // cause GET_CONN_POINTER to fail

    if (Connection->ConnectEvent != NULL) {

        CloseHandle( Connection->ConnectEvent );
    }

    if (GlobalDrainWinsockThread != CurrentThreadId) {
        
        //
        // Make sure there is no thread in DrainWinsock.
        //

        BeginSocketProtection( Connection );
    
    } else {

        //
        // We are being called from DrainWinsock. Since, we 
        // already own SelectLock1, we should not try to grab
        // SelectLock2 or we might deadlock.
        //

        ACQUIRE_LOCK( &Connection->SocketLock );
    }

    if (Connection->TcpHandle != INVALID_SOCKET) {

        int sockerr = (*pclosesocket)(Connection->TcpHandle);
        ASSERT(sockerr == 0); 
        Connection->TcpHandle = INVALID_SOCKET;
    }

    if (Connection->UdpHandle != INVALID_SOCKET) {

        int sockerr = (*pclosesocket)(Connection->UdpHandle);
        ASSERT(sockerr == 0); 
        Connection->UdpHandle = INVALID_SOCKET;
    }

    if (GlobalDrainWinsockThread != GetCurrentThreadId()) {
        
        EndSocketProtection( Connection );

    } else {

        RELEASE_LOCK( &Connection->SocketLock );
    }

    DELETE_LOCK( &Connection->SocketLock );
    DELETE_LOCK( &Connection->ReconnectLock );
    DELETE_LOCK( &Connection->StateLock );

    ldapFree( Connection->DNOnBind, LDAP_USER_DN_SIGNATURE );
    ldapFree( Connection->ListOfHosts, LDAP_HOST_NAME_SIGNATURE );
    ldapFree( Connection->ServiceNameForBind, LDAP_SERVICE_NAME_SIGNATURE );
    ldapFree( Connection->publicLdapStruct.ld_host, LDAP_HOST_NAME_SIGNATURE );

    if (Connection->ExplicitHostName != Connection->ListOfHosts) {

        ldapFree( Connection->ExplicitHostName, LDAP_HOST_NAME_SIGNATURE );
    }

    if (( Connection->HostNameW != Connection->ExplicitHostName ) &&
       ( Connection->HostNameW != Connection->ListOfHosts )) {

        ldapFree( Connection->HostNameW, LDAP_HOST_NAME_SIGNATURE );
    }

    if (Connection->DnsSuppliedName) {
       ldapFree( Connection->DnsSuppliedName, LDAP_HOST_NAME_SIGNATURE );
       Connection->DnsSuppliedName = NULL;
    }

    if (Connection->DomainName != NULL) {
       ldapFree( Connection->DomainName, LDAP_HOST_NAME_SIGNATURE );
       Connection->DomainName = NULL;
    }

    if (Connection->OptHostNameA != NULL) {
        ldapFree(Connection->OptHostNameA, LDAP_BUFFER_SIGNATURE);
        Connection->OptHostNameA = NULL;
    }

    if (Connection->SaslMethod != NULL) {
        ldapFree( Connection->SaslMethod, LDAP_SASL_SIGNATURE );
        Connection->SaslMethod = NULL;
    }

    FreeCurrentCredentials( Connection );

    ldapFree( Connection, LDAP_CONN_SIGNATURE );

    return;
}

// unbind.c eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\srchenc.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    srchenc.cxx handle encoding of search requests

Abstract:

   This module helps implements the LDAP search APIs.

Author:

    Andy Herron    (andyhe)        20-Jan-1997
    Anoop Anantha  (AnoopA)        24-Jun-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

// maximum number of levels we'll recursively parse of the search
// filter
#define MAX_FILTER_RECURSION 100

ULONG
LdapEncodeFilter (
    CLdapBer *Lber,
    PWCHAR SearchFilter,
    ULONG ulRecursionLevel
    );

ULONG
LdapEncodeSimpleFilter (
    CLdapBer *Lber,
    PWCHAR SearchFilter
    );

LONG
FindRightParen (
    PWCHAR CurrentLocation
    );

ULONG
SendLdapSearch (
    PLDAP_REQUEST Request,
    PLDAP_CONN Connection,
    PWCHAR  DistinguishedName,
    ULONG   ScopeOfSearch,
    PWCHAR  SearchFilter,
    PWCHAR  AttributeList[],
    ULONG   AttributesOnly,
    BOOLEAN Unicode,
    CLdapBer **Lber,
    LONG AltMsgId
    )
//
//  Here's where we get to the meat of this protocol.  This is the main client
//  API for performing an LDAP search.  Parameters are rather self explanatory,
//  see the LDAP RFC for detailed descriptions.
//
{
    CLdapBer *lber = NULL;
    ULONG hr;

    //
    //  If we have not yet bound, we set the Connection version to LDAPv3,
    //  since LDAPv2 doesn't allow operations without binding.
    //

    if ( (Connection->publicLdapStruct.ld_version == LDAP_VERSION2) &&
         (Connection->UdpHandle == INVALID_SOCKET) &&
         (Connection->BindPerformed == FALSE) ) {

        Connection->publicLdapStruct.ld_version = LDAP_VERSION3;
    }

    if ( (Connection->publicLdapStruct.ld_version == LDAP_VERSION2) &&
         ( LdapCheckForMandatoryControl( Request->ServerControls ) == TRUE )) {

        IF_DEBUG(CONTROLS) {
            LdapPrint1( "SendLdapSearch Connection 0x%x has mandatory controls.\n", Connection);
        }
        SetConnectionError( Connection, LDAP_UNAVAILABLE_CRIT_EXTENSION, NULL );
        return LDAP_UNAVAILABLE_CRIT_EXTENSION;
    }

    lber = new CLdapBer( Connection->publicLdapStruct.ld_version );

    if (lber == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap_search Connection 0x%x couldn't allocate lber.\n", Connection);
        }
        SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
        return LDAP_NO_MEMORY;
    }

    //
    //  The request looks like the following :
    //
    //     SearchRequest ::=
    //         [APPLICATION 3] SEQUENCE {
    //             baseObject    LDAPDN,
    //             scope         ENUMERATED {
    //                                baseObject            (0),
    //                                singleLevel           (1),
    //                                wholeSubtree          (2)
    //                           },
    //             derefAliases  ENUMERATED {
    //                                        neverDerefAliases     (0),
    //                                        derefInSearching      (1),
    //                                        derefFindingBaseObj   (2),
    //                                        derefAlways           (3)
    //                                   },
    //             sizeLimit     INTEGER (0 .. maxInt),
    //             timeLimit     INTEGER (0 .. maxInt),
    //             attrsOnly     BOOLEAN,
    //             filter        Filter,
    //             attributes    SEQUENCE OF AttributeType
    //     }
    //
    //     Filter ::=
    //         CHOICE {
    //             and                [0] SET OF Filter,
    //             or                 [1] SET OF Filter,
    //             not                [2] Filter,
    //             equalityMatch      [3] AttributeValueAssertion,
    //             substrings         [4] SubstringFilter,
    //             greaterOrEqual     [5] AttributeValueAssertion,
    //             lessOrEqual        [6] AttributeValueAssertion,
    //             present            [7] AttributeType,
    //             approxMatch        [8] AttributeValueAssertion
    //             extensibleMatch    [9] MatchingRuleAssertion
    //         }
    //
    //     SubstringFilter
    //         SEQUENCE {
    //             type               AttributeType,
    //             SEQUENCE OF CHOICE {
    //                 initial        [0] LDAPString,
    //                 any            [1] LDAPString,
    //                 final          [2] LDAPString
    //             }
    //         }
    //
    //     MatchingRuleAssertion ::= SEQUENCE {
    //           matchingRule    [1] MatchingRuleId OPTIONAL,
    //           type            [2] AttributeDescription OPTIONAL,
    //           matchValue      [3] AssertionValue,
    //           dnAttributes    [4] BOOLEAN DEFAULT FALSE }
    //
    //

    hr = lber->HrStartWriteSequence();
    if (hr != NOERROR) {

        IF_DEBUG(PARSE) {
            LdapPrint2( "ldap_search startWrite conn 0x%x encoding error of 0x%x.\n",
                        Connection, hr );
        }

        hr = LDAP_ENCODING_ERROR;
        goto returnError;

    } else {            // we can't forget EndWriteSequence

       if (AltMsgId != 0) {

          hr = lber->HrAddValue((LONG) AltMsgId );

       } else {

          hr = lber->HrAddValue((LONG) Request->MessageId );
       }

        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_search MsgNo conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;
        }

        if ((Connection->UdpHandle != INVALID_SOCKET) &&
            (Connection->publicLdapStruct.ld_version == LDAP_VERSION2)) {

            hr = lber->HrAddValue((const WCHAR *) Connection->DNOnBind );

            //  if we couldn't put the DN in the packet, don't worry about it
            //  as it wasn't actually used for authentication in CLDAP v2.
        }

        hr = lber->HrStartWriteSequence(LDAP_SEARCH_CMD);
        if (hr != NOERROR) {

            IF_DEBUG(PARSE) {
                LdapPrint2( "ldap_search cmd conn 0x%x encoding error of 0x%x.\n",
                            Connection, hr );
            }
            hr = LDAP_ENCODING_ERROR;
            goto returnError;

        } else {        // we can't forget EndWriteSequence

            hr = lber->HrAddValue((const WCHAR *) DistinguishedName );
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_search DN conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                hr = LDAP_ENCODING_ERROR;
                goto returnError;
            }

            if ((ScopeOfSearch != LDAP_SCOPE_BASE) &&
                (ScopeOfSearch != LDAP_SCOPE_ONELEVEL) &&
                (ScopeOfSearch != LDAP_SCOPE_SUBTREE)) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_search conn 0x%x invalid scope of 0x%x.\n",
                                Connection, ScopeOfSearch );
                }

                hr = LDAP_PARAM_ERROR;
                goto returnError;
            }

            hr = lber->HrAddValue((LONG) ScopeOfSearch, BER_ENUMERATED);
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_search scope conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                hr = LDAP_ENCODING_ERROR;
                goto returnError;
            }

            if ((Connection->publicLdapStruct.ld_deref != LDAP_DEREF_NEVER) &&
                (Connection->publicLdapStruct.ld_deref != LDAP_DEREF_SEARCHING) &&
                (Connection->publicLdapStruct.ld_deref != LDAP_DEREF_FINDING) &&
                (Connection->publicLdapStruct.ld_deref != LDAP_DEREF_ALWAYS)) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_search conn 0x%x invalid derefOption of 0x%x.\n",
                                Connection, Connection->publicLdapStruct.ld_deref );
                }

                hr = LDAP_PARAM_ERROR;
                goto returnError;
            }

            hr = lber->HrAddValue((LONG) Connection->publicLdapStruct.ld_deref, BER_ENUMERATED);
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_search derefOption conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                hr = LDAP_ENCODING_ERROR;
                goto returnError;
            }

            hr = lber->HrAddValue((LONG) Request->SizeLimit );
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_search size conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                hr = LDAP_ENCODING_ERROR;
                goto returnError;
            }

            hr = lber->HrAddValue((LONG) Request->TimeLimit );
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_search time conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                hr = LDAP_ENCODING_ERROR;
                goto returnError;
            }

            hr = lber->HrAddValue((BOOLEAN) AttributesOnly, BER_BOOLEAN );
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_search attrOnly conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                hr = LDAP_ENCODING_ERROR;
                goto returnError;
            }

            //
            //  now the fun one... encode the filter
            //

            if (SearchFilter != NULL ) {

                //
                //  we have to make a duplicate of the filter because it may
                //  be that the filter is in a read only piece of memory and
                //  since we're modifying it, it's not a good thing to cause
                //  an access violatation.
                //

                PWCHAR filter;
                ULONG remaining = strlenW( SearchFilter ) + 1;

                if (remaining == 1) {

                    hr = LDAP_FILTER_ERROR;

                } else {

                    filter = (PWCHAR) ldapMalloc( remaining * sizeof(WCHAR),
                                                  LDAP_STRING_SIGNATURE );

                    if (filter == NULL) {

                        hr = LDAP_NO_MEMORY;
                        IF_DEBUG(FILTER) {
                            LdapPrint1( "ldap_search : could not allocate memory 0x%x.\n", remaining );
                        }
                        goto returnError;
                    }

                    CopyMemory( filter, SearchFilter, remaining * sizeof(WCHAR));

                    hr = LdapEncodeFilter(  lber, filter, 0 );

                    ldapFree( filter, LDAP_STRING_SIGNATURE );
                }

            } else {

                hr = LDAP_FILTER_ERROR;
            }

            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_search filter conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                goto returnError;
            }

            //
            //  add the attribute list and we're done.
            //

            hr = lber->HrStartWriteSequence();
            if (hr != NOERROR) {

                IF_DEBUG(PARSE) {
                    LdapPrint2( "ldap_search attrlist conn 0x%x encoding error of 0x%x.\n",
                                Connection, hr );
                }
                hr = LDAP_ENCODING_ERROR;
                goto returnError;

            } else {        // we can't forget EndWriteSequence

                if (AttributeList != NULL) {

                    ULONG count = 0;

                    while (AttributeList[count] != NULL) {

                        if (Unicode) {

                            hr = lber->HrAddValue((const WCHAR *) AttributeList[count]);

                        } else {

                            hr = lber->HrAddValue((const CHAR *) AttributeList[count]);
                        }

                        if (hr != NOERROR) {
                            IF_DEBUG(PARSE) {
                                if (Unicode) {
                                    LdapPrint3( "ldap_search conn 0x%x encoding error of 0x%x, attr = %S.\n",
                                                Connection, hr, AttributeList[count] );
                                } else {
                                    LdapPrint3( "ldap_search conn 0x%x encoding error of 0x%x, attr = %s.\n",
                                                Connection, hr, AttributeList[count] );
                                }
                            }
                            hr = LDAP_ENCODING_ERROR;
                            goto returnError;
                        }
                        count++;
                    }
                }

                hr = lber->HrEndWriteSequence();
                ASSERT( hr == NOERROR );
            }

            hr = lber->HrEndWriteSequence();
            ASSERT( hr == NOERROR );
        }

        //
        //  put in the server controls here if required
        //

        if ( (Connection->publicLdapStruct.ld_version != LDAP_VERSION2) &&
             ( Request->ServerControls != NULL )) {

            hr = InsertServerControls( Request, Connection, lber );

            if (hr != LDAP_SUCCESS) {

                goto returnError;
            }
        }

        hr = lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );
    }

    //
    //  send the search request.
    //

    ACQUIRE_LOCK( &Connection->ReconnectLock );

    AddToPendingList( Request, Connection );

    hr = LdapSend( Connection, lber );

    if (hr != LDAP_SUCCESS) {

        IF_DEBUG(NETWORK_ERRORS) {
            LdapPrint2( "ldap_search Connection 0x%x send with error of 0x%x.\n",
                        Connection, hr );
        }
        DecrementPendingList( Request, Connection );

    } else {

        //
        //  Save off the lber value, free any lber message that is already
        //  present.
        //

        lber = (CLdapBer *) InterlockedExchangePointer(  (PVOID *) Lber,
                                                         (PVOID) lber );
    }

    RELEASE_LOCK( &Connection->ReconnectLock );

returnError:

    SetConnectionError( Connection, hr, NULL );

    if (lber != NULL) {

       delete lber;
    }

    return hr;
}

WINLDAPAPI ULONG LDAPAPI ldap_check_filterW(
        LDAP    *ExternalHandle,
        PWCHAR  SearchFilter
    )
{
    PLDAP_CONN connection = NULL;
    PWCHAR filter;
    CLdapBer *lber;
    ULONG hr;

    connection = GetConnectionPointer(ExternalHandle);

    if (SearchFilter == NULL || connection == NULL) {

        hr = LDAP_PARAM_ERROR;
        goto error;
    }

    lber = new CLdapBer( connection->publicLdapStruct.ld_version );

    if (lber == NULL) {

        IF_DEBUG(FILTER) {
            LdapPrint0( "ldap_check_filter : could not allocate lber.\n" );
        }
        hr = LDAP_NO_MEMORY;
        goto error;
    }

    filter = ldap_dup_stringW( SearchFilter, 0, LDAP_STRING_SIGNATURE );

    if (filter == NULL) {

        IF_DEBUG(FILTER) {
            LdapPrint0( "ldap_check_filter : could not allocate memory.\n" );
        }
        delete lber;
        hr = LDAP_NO_MEMORY;
        goto error;
    }

    hr = LdapEncodeFilter( lber, filter, 0 );

    ldapFree( filter, LDAP_STRING_SIGNATURE );
    delete lber;

error:
    if (connection)
        DereferenceLdapConnection( connection );

    return hr;
}


WINLDAPAPI ULONG LDAPAPI ldap_check_filterA(
        LDAP    *ld,
        PCHAR   SearchFilter
    )
{
    PWCHAR filter;
    ULONG err;

    err = ToUnicodeWithAlloc( SearchFilter,
                              -1,
                              &filter,
                              LDAP_STRING_SIGNATURE,
                              LANG_ACP );
    if (err == LDAP_SUCCESS) {

        err = ldap_check_filterW( ld, filter );
        ldapFree( filter, LDAP_STRING_SIGNATURE );
    }
    return err;
}

ULONG
LdapEncodeFilter (
    CLdapBer *Lber,
    PWCHAR SearchFilter,
    ULONG ulRecursionLevel
    )
//
//  Encode a search filter per RFC 2254.  We take the string and encode it into
//  the BER object specified by Lber.
//
//     Filter ::=
//         CHOICE {
//             and                [0] SET OF Filter,
//             or                 [1] SET OF Filter,
//             not                [2] Filter,
//             equalityMatch      [3] AttributeValueAssertion,
//             substrings         [4] SubstringFilter,
//             greaterOrEqual     [5] AttributeValueAssertion,
//             lessOrEqual        [6] AttributeValueAssertion,
//             present            [7] AttributeType,
//             approxMatch        [8] AttributeValueAssertion
//             extensibleMatch    [9] MatchingRuleAssertion
//         }
//
//     SubstringFilter
//         SEQUENCE {
//             type               AttributeType,
//             SEQUENCE OF CHOICE {
//                 initial        [0] LDAPString,
//                 any            [1] LDAPString,
//                 final          [2] LDAPString
//             }
//         }
//
//     MatchingRuleAssertion ::= SEQUENCE {
//           matchingRule    [1] MatchingRuleId OPTIONAL,
//           type            [2] AttributeDescription OPTIONAL,
//           matchValue      [3] AssertionValue,
//           dnAttributes    [4] BOOLEAN DEFAULT FALSE }
//
//

{
    ULONG hr = LDAP_FILTER_ERROR;
    PWCHAR currentPtr = SearchFilter;
    LONG   componentLength;
    WCHAR savedChar;
    ULONG parensCount = 0;
    BOOLEAN atEndOfString = FALSE;
    BOOLEAN definitiveError = TRUE;

    IF_DEBUG(FILTER) {
        LdapPrint1( "LdapEncodeFilter : Filter is %S\n", SearchFilter );
    }

    ASSERT( currentPtr != NULL );

    if (ulRecursionLevel >= MAX_FILTER_RECURSION) {
        IF_DEBUG(FILTER) {
            LdapPrint0( "LdapEncodeFilter : too much recursion\n");
        }
        hr = LDAP_FILTER_ERROR;
        goto encodingError;
    }

    ulRecursionLevel++;

    while (*currentPtr == L' ') {
        currentPtr++;
    }

    //
    //  if the filter was empty or only made up of spaces, error out with
    //  bad filter
    //

    if (*currentPtr != L'\0') {

        while ((atEndOfString == FALSE) && (*currentPtr != L'\0')) {

            switch ( *currentPtr ) {
            case L'(':

                parensCount++;

                currentPtr++;

                while (*currentPtr == L' ') {
                    currentPtr++;
                }

                switch ( *currentPtr ) {
                case L'&':       // handle "(&(cn=bob)(phone=12345))"
                case L'|':       // handle "(|(cn=bob)(cn=mary))"

                    if (*currentPtr == L'&') {

                        hr = Lber->HrStartWriteSequence(LDAP_FILTER_AND);

                    } else {

                        hr = Lber->HrStartWriteSequence(LDAP_FILTER_OR);
                    }

                    if (hr != NOERROR) {
                        IF_DEBUG(FILTER) {
                            LdapPrint2( "LdapEncodeFilter : 1 Filter is %S, err 0x%x\n", SearchFilter, hr );
                        }
                        hr = LDAP_FILTER_ERROR;
                        goto encodingError;
                    }

                    currentPtr++;

                    //
                    //  encode each FILTER separately
                    //

                    componentLength = FindRightParen( currentPtr );

                    if (componentLength == -1) {
                        IF_DEBUG(FILTER) {
                            LdapPrint1( "LdapEncodeFilter : 2 Filter is %S, no right ')'\n", SearchFilter );
                        }
                        hr = LDAP_FILTER_ERROR;
                        goto encodingError;
                    }

                    //
                    //  save off char at end and slam in null to mark end of subfilter
                    //

                    savedChar = *(currentPtr + componentLength );

                    ASSERT( savedChar == L')' );

                    *(currentPtr + componentLength ) = L'\0';

                    //
                    //  recursively call ourselves to process list of filters
                    //

                    hr = LdapEncodeFilter( Lber, currentPtr, ulRecursionLevel );
                    if (hr != NOERROR) {
                        IF_DEBUG(FILTER) {
                            LdapPrint2( "LdapEncodeFilter : 3 Filter is %S, err 0x%x\n", SearchFilter, hr );
                        }
                        definitiveError = FALSE;
                        goto encodingError;
                    }

                    *(currentPtr + componentLength ) = savedChar;

                    currentPtr += (componentLength + 1);

                    parensCount--;      // account for ')'

                    hr = Lber->HrEndWriteSequence();
                    if (hr != NOERROR) {
                        IF_DEBUG(FILTER) {
                            LdapPrint2( "LdapEncodeFilter : 4 Filter is %S, err 0x%x\n", SearchFilter, hr );
                        }
                        hr = LDAP_FILTER_ERROR;
                        goto encodingError;
                    }
                    break;

                case L'!':       // handle "(!(ou=foo))"

                    hr = Lber->HrStartWriteSequence(LDAP_FILTER_NOT);

                    if (hr != NOERROR) {
                        IF_DEBUG(FILTER) {
                            LdapPrint2( "LdapEncodeFilter : 5 Filter is %S, err 0x%x\n", SearchFilter, hr );
                        }
                        hr = LDAP_FILTER_ERROR;
                        goto encodingError;
                    }

                    currentPtr++;

                    //
                    //  encode the single FILTER
                    //

                    componentLength = FindRightParen( currentPtr );

                    if (componentLength == -1) {
                        IF_DEBUG(FILTER) {
                            LdapPrint1( "LdapEncodeFilter : 6 Filter is %S, no right ')'\n", SearchFilter  );
                        }
                        hr = LDAP_FILTER_ERROR;
                        goto encodingError;
                    }

                    //
                    //  save off char at end and slam in null to mark end of subfilter
                    //

                    savedChar = *(currentPtr + componentLength );

                    ASSERT( savedChar == L')' );

                    *(currentPtr + componentLength ) = L'\0';

                    //
                    //  recursively call ourselves to process filter
                    //

                    hr = LdapEncodeFilter( Lber, currentPtr, ulRecursionLevel );
                    if (hr != NOERROR) {
                        IF_DEBUG(FILTER) {
                            LdapPrint2( "LdapEncodeFilter : 7 Filter is %S, err 0x%x\n", SearchFilter, hr );
                        }
                        definitiveError = FALSE;
                        goto encodingError;
                    }

                    *(currentPtr + componentLength ) = savedChar;

                    currentPtr += (componentLength + 1);

                    parensCount--;      // account for ')'

                    hr = Lber->HrEndWriteSequence();
                    if (hr != NOERROR) {
                        IF_DEBUG(FILTER) {
                            LdapPrint2( "LdapEncodeFilter : 8 Filter is %S, err 0x%x\n", SearchFilter, hr );
                        }
                        hr = LDAP_FILTER_ERROR;
                        goto encodingError;
                    }
                    break;

                case L')':       // handle "()" by reporting error

                    hr = LDAP_FILTER_ERROR;
                    IF_DEBUG(FILTER) {
                        LdapPrint1( "LdapEncodeFilter : Filter is %S, () not allowed\n", SearchFilter);
                    }
                    goto encodingError;

                default:        // handle "(cn=bob)"

                    //
                    //  encode the single FILTER
                    //

                    componentLength = FindRightParen( currentPtr );

                    if (componentLength == -1) {
                        IF_DEBUG(FILTER) {
                            LdapPrint1( "LdapEncodeFilter : 9 Filter is %S, no right ')'\n", SearchFilter  );
                        }
                        hr = LDAP_FILTER_ERROR;
                        goto encodingError;
                    }

                    //
                    //  save off char at end and slam in null to mark end of subfilter
                    //

                    savedChar = *(currentPtr + componentLength );

                    ASSERT( savedChar == L')' );

                    *(currentPtr + componentLength ) = L'\0';

                    //
                    //  recursively call ourselves to process filter
                    //

                    hr = LdapEncodeFilter( Lber, currentPtr, ulRecursionLevel );
                    if (hr != NOERROR) {
                        IF_DEBUG(FILTER) {
                            LdapPrint2( "LdapEncodeFilter : 10 Filter is %S, err 0x%x\n", SearchFilter, hr );
                        }
                        definitiveError = FALSE;
                        goto encodingError;
                    }

                    *(currentPtr + componentLength ) = savedChar;

                    currentPtr += (componentLength + 1);

                    parensCount--;      // account for ')'
                }
                break;

            case L')':
                parensCount--;      // intentionally no break

            case L' ':
                currentPtr++;
                break;

            case L'&':
            case L'|':
                hr = LDAP_FILTER_ERROR;
                IF_DEBUG(FILTER) {
                    LdapPrint1( "LdapEncodeFilter : invalid filter is %S\n", SearchFilter);
                }
                goto encodingError;

            default:                // handle "cn=bob"

                //
                //  duplicate the string since we update it and it won't be
                //  cool to change the client's filter.
                //

                PWCHAR duplicate = ldap_dup_stringW( currentPtr,
                                                     0,
                                                     LDAP_STRING_SIGNATURE );

                if (duplicate == NULL) {

                    hr = LDAP_NO_MEMORY;
                    IF_DEBUG(FILTER) {
                        LdapPrint2( "LdapEncodeFilter : 11 Filter is %S, err 0x%x\n", SearchFilter, hr );
                    }
                    goto encodingError;
                }

                hr = LdapEncodeSimpleFilter( Lber, duplicate );

                ldapFree( duplicate, LDAP_STRING_SIGNATURE );

                if (hr != NOERROR) {
                    IF_DEBUG(FILTER) {
                        LdapPrint2( "LdapEncodeFilter : 12 Filter is %S, err 0x%x\n", SearchFilter, hr );
                    }
                    goto encodingError;
                }

                atEndOfString = TRUE;     // we're done with string
            }
        }

        return ((parensCount == 0) ? NOERROR : LDAP_FILTER_ERROR );
    }

encodingError:

    return hr;
}


ULONG
LdapEncodeSimpleFilter (
    CLdapBer *Lber,
    PWCHAR SearchFilter
    )
//
//  Encode a single search filter such as :
//
//      "cn=bob"            straight equality
//      "size >= 2"         greater than
//      "size <= 5"         less than
//      "mail=*"            present
//      "ou = DBSD*"        contains
//      "printer ~= laser"  approximately equal
//
//
//  AnoopA: Added support for Extensible matches (1/29/98)
//
//       "cn:1.2.3.4.5:=Fred Flintstone"
//       "sn:dn:2.4.6.8.10:=Barney Rubble"
//       "o:dn:=Ace Industry"
//       ":dn:2.4.6.8.10:=Dino"
//  Note that all leading escape markers have already been removed.
//
{
    ULONG hr;
    PWCHAR ptrToEqual = SearchFilter;
    PWCHAR ptrToValue;
    LONG operation;

    PWCHAR ptrToOid = SearchFilter;
    WCHAR  savedchar;
    PWCHAR ptrToType = SearchFilter;
    PWCHAR ptrToTypeEnd = ptrToType;
    PWCHAR ptrToDN = SearchFilter;
    BOOLEAN DNdetected = FALSE;
    BOOLEAN bOidPresent = FALSE;
    BOOLEAN bSubstringValuePresent = FALSE;

    IF_DEBUG(FILTER) {
        LdapPrint1( "LdapEncodeSimpleFilter : Filter is %S\n", SearchFilter );
    }

    //
    //  Determine what the desired operation is by skipping to the = sign.
    //

    while ((*ptrToEqual != L'=') && (*ptrToEqual != L'\0')) {

        ptrToEqual++;
    }

    if ((*ptrToEqual == L'\0') || (ptrToEqual == SearchFilter)) {

        return LDAP_FILTER_ERROR;
    }

    ptrToValue = ptrToEqual + 1;

    //
    //  strip off leading blanks from value
    //

    while (*ptrToValue == L' ' && *ptrToValue != L'\0') {

        ptrToValue++;
    }

    if (*ptrToValue == L'\0') {

        return LDAP_FILTER_ERROR;
    }

    //
    //  strip off trailing blanks from value
    //

#if 0
    while (*(ptrToValue+strlenW(ptrToValue)-1) == L' ') {

        *(ptrToValue+strlenW(ptrToValue)-1) = L'\0';
    }
#endif

    switch (*(ptrToEqual-1)) {
    case L'~':
        operation = LDAP_FILTER_APPROX;
        *(ptrToEqual-1) = L'\0';
        break;
    case L'>':
        operation = LDAP_FILTER_GE;
        *(ptrToEqual-1) = L'\0';
        break;
    case L'<':
        operation = LDAP_FILTER_LE;
        *(ptrToEqual-1) = L'\0';
        break;
    case L':':
        operation = LDAP_FILTER_EXTENSIBLE;


        savedchar = *(ptrToEqual-1);
        *(ptrToEqual-1) = L'\0';

        hr = Lber->HrStartWriteSequence(LDAP_FILTER_EXTENSIBLE);
        if (hr != NOERROR) {
           IF_DEBUG(FILTER) {
              LdapPrint2( "LdapEncodeSimpleFilter : 3 Filter is %S, err 0x%x\n", SearchFilter, hr );
           }
           goto encodingError;
        }

        //
        // We have to detect the matching rule ID if one is present
        //

        while ((ptrToOid != ptrToEqual) && (*ptrToOid != L'\0')) {
           if (*ptrToOid == L'.') {
              bOidPresent = TRUE;
              break;
           }
           ptrToOid++;
        }
        ptrToOid = SearchFilter; // Reset to beginning of filter

        if (bOidPresent == TRUE) {

           //
           // We have an OID preceding the colon. Now, start from the
           // beginning and skip over spaces looking for the '.'of the OID
           //

           while ((*ptrToOid != L':') &&
                  (*ptrToOid != L'\0')) {

               ptrToOid++;
           }

           if (*ptrToOid == L'\0') {

               return LDAP_FILTER_ERROR;
           } else {

              ptrToOid++;
           }
        hr = Lber->HrAddValue ((const WCHAR *) ptrToOid, BER_CLASS_CONTEXT_SPECIFIC | 0x01);
        if (hr != NOERROR) {
            IF_DEBUG(FILTER) {
                LdapPrint2( "LdapEncodeSimpleFilter : 2 Filter is %S, err 0x%x\n", SearchFilter, hr );
                }
            goto encodingError;
            }

        }
        *(ptrToEqual-1) = savedchar;  // Restore the colon

        //
        // We detect the type if one is present
        //


        while ((*ptrToType == L' ') && (*ptrToType != L'\0')) {

           ptrToType++;
        }
        if (*ptrToType == L'\0') {

            return LDAP_FILTER_ERROR;

        } else {

           if (*ptrToType != L':') {

              //
              // If we don't start off with a ":" it means we have a type present
              //

              while (*ptrToTypeEnd != L':') {

                 ptrToTypeEnd++;
              }

              savedchar = *ptrToTypeEnd;  // save off the colon
              *ptrToTypeEnd = L'\0';
              hr = Lber->HrAddValue ((const WCHAR *) ptrToType, BER_CLASS_CONTEXT_SPECIFIC | 0x02);
              if (hr != NOERROR) {
                 IF_DEBUG(FILTER) {
                    LdapPrint2( "LdapEncodeSimpleFilter : 2 Filter is %S, err 0x%x\n", SearchFilter, hr );
                 }
                 goto encodingError;
              }
              *ptrToTypeEnd = savedchar;   // restore the colon
           }
        }

        //
        // Deal with the matchValue
        //

           hr = Lber->HrAddValue ((const WCHAR *) ptrToEqual+1, BER_CLASS_CONTEXT_SPECIFIC | 0x03);
           if (hr != NOERROR) {
               IF_DEBUG(FILTER) {
                   LdapPrint2( "LdapEncodeSimpleFilter : 2 Filter is %S, err 0x%x\n", SearchFilter, hr );
                   }
               goto encodingError;
               }

        //
        // Deal with the dnAttributes
        //

        while ((*ptrToDN != L'\0')&&((*(ptrToDN+1)) != L'\0')&&((*(ptrToDN+2)) != L'\0')) {

           if (*ptrToDN == L':') {
              if ((*(ptrToDN+1) == L'd') || (*(ptrToDN+1) == L'D')) {
                 if ((*(ptrToDN+2) == L'n') || (*(ptrToDN+2) == L'N')) {
                    if (*(ptrToDN+3) == L':') {

                       DNdetected = TRUE;
                       break;
                    }
                 }
              }

           }
           ptrToDN++;
        }

           hr = Lber->HrAddValue((BOOLEAN) DNdetected, BER_CLASS_CONTEXT_SPECIFIC | 0x04  );

           if (hr != NOERROR) {
               IF_DEBUG(FILTER) {
                   LdapPrint2( "LdapEncodeSimpleFilter : 2 Filter is %S, err 0x%x\n", SearchFilter, hr );
                   }
               goto encodingError;
               }


        hr = Lber->HrEndWriteSequence();
        ASSERT( hr == NOERROR );

        goto encodingError;

        break;

    default:

        PWCHAR checkForAsterisk = ptrToValue;

        *ptrToEqual = L'\0';

        if ((*ptrToValue == L'*') && (*(ptrToValue+1) == L'\0')) {

            //
            //  value is simply "*", therefore we check for presence.
            //

            hr = Lber->HrAddValue((const WCHAR *) SearchFilter, LDAP_FILTER_PRESENT );
            if (hr != NOERROR) {
                IF_DEBUG(FILTER) {
                    LdapPrint2( "LdapEncodeSimpleFilter : 2 Filter is %S, err 0x%x\n", SearchFilter, hr );
                }
                goto encodingError;
            }

            return(hr);
        }

        //
        //  allow that we may have some embedded '*' escaped
        //

        ULONG remaining = strlenW( ptrToValue ) + 1;

        //
        //  note that we also use a length check here "remaining" so that
        //  we don't blow up if we hit something like "abc\\0" where the
        //  null terminator is escaped.
        //

        while ((*checkForAsterisk != L'\0') &&
               (*checkForAsterisk != L'*') &&
                remaining > 0) {

            checkForAsterisk++;
            remaining--;
        }

        if (*checkForAsterisk != L'*') {

            //
            //  value does not contain an '*' therefore we test for equality
            //

            operation = LDAP_FILTER_EQUALITY;

        } else {

            //
            //  value is a substring such as "cn=bob*"
            //
            //         SEQUENCE {
            //             type               AttributeType,
            //             SEQUENCE OF CHOICE {
            //                 initial        [0] LDAPString,
            //                 any            [1] LDAPString,
            //                 final          [2] LDAPString
            //             }
            //

            PWCHAR   NextAsterisk;
            BOOLEAN foundAsterisk = FALSE;

            hr = Lber->HrStartWriteSequence(LDAP_FILTER_SUBSTRINGS);
            if (hr != NOERROR) {
                IF_DEBUG(FILTER) {
                    LdapPrint2( "LdapEncodeSimpleFilter : 3 Filter is %S, err 0x%x\n", SearchFilter, hr );
                }
                goto encodingError;
            }

            hr = Lber->HrAddValue((const WCHAR *) SearchFilter );
            if (hr != NOERROR) {
                IF_DEBUG(FILTER) {
                    LdapPrint2( "LdapEncodeSimpleFilter : 4 Filter is %S, err 0x%x\n", SearchFilter, hr );
                }
                goto encodingError;
            }

            hr = Lber->HrStartWriteSequence();
            if (hr != NOERROR) {
                IF_DEBUG(FILTER) {
                    LdapPrint2( "LdapEncodeSimpleFilter : 5 Filter is %S, err 0x%x\n", SearchFilter, hr );
                }
                goto encodingError;
            }

            while (ptrToValue != NULL) {

                //
                //  find the next asterisk in the substring
                //

                remaining = strlenW( ptrToValue ) + 1;

                NextAsterisk = ptrToValue;

                //
                //  note that we also use a length check here "remaining" so that
                //  we don't blow up if we hit something like "abc\\0" where the
                //  null terminator is escaped.
                //

                while ((*NextAsterisk != L'\0') &&
                       (*NextAsterisk != L'*') &&
                       (remaining > 0)) {

                    NextAsterisk++;
                    remaining--;
                }

                //
                //  if we found another asterisk, set the byte to 0 to mark
                //  end of partial value.
                //

                if (*NextAsterisk == L'*') {

                    *NextAsterisk = L'\0';
                    NextAsterisk++;

                } else {

                    NextAsterisk = NULL;
                }

                if (! foundAsterisk) {

                    operation = LDAP_SUBSTRING_INITIAL;
                    foundAsterisk = TRUE;

                } else if (NextAsterisk != NULL) {

                    operation = LDAP_SUBSTRING_ANY;

                } else {

                    operation = LDAP_SUBSTRING_FINAL;
                }

                if (*ptrToValue != L'\0') {

                    hr = Lber->HrAddEscapedValue( ptrToValue, operation );
                    if (hr != NOERROR) {
                        IF_DEBUG(FILTER) {
                            LdapPrint2( "LdapEncodeSimpleFilter : 6 Filter is %S, err 0x%x\n", SearchFilter, hr );
                        }
                        goto encodingError;
                    }
                    bSubstringValuePresent = TRUE;
                }

                ptrToValue = NextAsterisk;
            }

            //
            // We got a substring filter containing only asterisks, no values.
            // This isn't a valid filter.
            //
            if (!bSubstringValuePresent) {
                hr = LDAP_FILTER_ERROR;
                goto encodingError;
            }

            hr = Lber->HrEndWriteSequence();
            ASSERT( hr == NOERROR );

            hr = Lber->HrEndWriteSequence();
            ASSERT( hr == NOERROR );
            return hr;
        }
    }

    hr = Lber->HrStartWriteSequence(operation);
    if (hr != NOERROR) {
        IF_DEBUG(FILTER) {
            LdapPrint2( "LdapEncodeSimpleFilter : 3 Filter is %S, err 0x%x\n", SearchFilter, hr );
        }
        goto encodingError;
    }

    hr = Lber->HrAddValue((const WCHAR *) SearchFilter );
    if (hr != NOERROR) {
        IF_DEBUG(FILTER) {
            LdapPrint2( "LdapEncodeSimpleFilter : 4 Filter is %S, err 0x%x\n", SearchFilter, hr );
        }
        goto encodingError;
    }

    //
    //  translate escaping characters from filter value
    //

    hr = Lber->HrAddEscapedValue( ptrToValue, BER_OCTETSTRING );

    if (hr != NOERROR) {
        IF_DEBUG(FILTER) {
            LdapPrint2( "LdapEncodeSimpleFilter : 5 Filter is %S, err 0x%x\n", SearchFilter, hr );
        }
        goto encodingError;
    }

    hr = Lber->HrEndWriteSequence();
    ASSERT( hr == NOERROR );

encodingError:
    return(hr);
}


LONG
FindRightParen (
    PWCHAR CurrentLocation
    )
{
    BOOLEAN escaped = FALSE;
    LONG count = 0;
    ULONG parens = 0;
    WCHAR ch;

    //
    //  search the remainder of the string for a closing ')'
    //

    while (*CurrentLocation != L'\0') {

        if (! escaped) {

            ch = *CurrentLocation;

            if (ch == L'(') {

                parens++;

            } else if (ch == L')') {

                if (parens == 0) {
                    return count;
                }
                parens--;

            } else if ( ch == L'\\' ) {

                escaped = TRUE;
            }

        } else {

            escaped = FALSE;

            if (*CurrentLocation == L'\0') {
                break;
            }

        }
        count++;
        CurrentLocation++;
    }
    //
    //  no closing right parens was found.  this is an error
    //

    return(-1);
}

//
//  Extended API to support allowing opaque blobs of data in search filters.
//  This API takes any filter element and adds necessary escape characters
//  such that when the element hits the wire in the search request, it will
//  be equal to the opaque blob past in here as source.
//

ULONG __cdecl
ldap_escape_filter_elementW (
   PCHAR   sourceFilterElement,
   ULONG   sourceLength,            // size in bytes
   PWCHAR  destFilterElement,
   ULONG   destLength               // size in bytes
   )
{
    ULONG err;
    PCHAR dest;
    ULONG lengthRequired;
    ULONG sLength;

    //
    //  figure out how long of a buffer we need.
    //

    lengthRequired = ldap_escape_filter_element( sourceFilterElement,
                                                 sourceLength,
                                                 NULL,
                                                 0 );
    if (destFilterElement == NULL) {

        //
        //  If they didn't specify an output buffer, tell them how big the
        //  output buffer should be.
        //

        return lengthRequired * sizeof(WCHAR);
    }

    if ((sourceFilterElement == NULL) ||
        (destLength < lengthRequired * sizeof(WCHAR))) {

        return LDAP_PARAM_ERROR;
    }

    dest = (PCHAR) ldapMalloc( lengthRequired, LDAP_ANSI_SIGNATURE );

    if (dest == NULL) {

        return LDAP_NO_MEMORY;
    }

    err = ldap_escape_filter_element( sourceFilterElement,
                                      sourceLength,
                                      dest,
                                      lengthRequired );

    if (err != 0) {

        ldapFree( dest, LDAP_ANSI_SIGNATURE );
        return err;
    }

    //
    //  determine length of required string
    //

    sLength = MultiByteToWideChar(  CP_ACP,
                                    0,
                                    dest,
                                    (int) -1,
                                    NULL,
                                    0 );

    if ((sLength == 0) || ((sLength*sizeof(WCHAR)) > destLength)) {

        ldapFree( dest, LDAP_ANSI_SIGNATURE );
        return LDAP_PARAM_ERROR;
    }

    sLength =  MultiByteToWideChar(  CP_ACP,
                                     0,
                                     dest,
                                     (int) -1,
                                     destFilterElement,
                                     (int) destLength/2 );

    if (dest != NULL) {

       ldapFree( dest, LDAP_ANSI_SIGNATURE );
    }

    return LDAP_SUCCESS;
}

ULONG __cdecl
ldap_escape_filter_element (
   PCHAR   sourceFilterElement,
   ULONG   sourceLength,
   PCHAR   destFilterElement,
   ULONG   destLength
   )
{
    ULONG sourceCount;
    ULONG destCount = 0;
    PCHAR source = sourceFilterElement;
    PCHAR dest = destFilterElement;
    CHAR ch;

    sourceCount = sourceLength;

    if (source != NULL) {

        while ((sourceCount--) > 0) {

            ch = *(source++);

            if (((ch >= 'A') && (ch <= 'Z')) ||
                ((ch >= 'a') && (ch <= 'z')) ||
                ((ch >= '0') && (ch <= '9'))) {

                destCount++;

            } else {

                destCount += 3;             // sizeof '\xx'
            }
        }
    }

    if (destFilterElement == NULL) {

        //
        //  This is a bit of a hack.. if they didn't specify a destination,
        //  then we return the required size of the buffer.
        //

        return (destCount + 1);
    }

    if ((source == NULL) || ((destCount + 1) > destLength)) {

        return LDAP_PARAM_ERROR;
    }

    //
    //  For each char in the source string, copy it to dest string
    //  but if it is not alphanumeric, we first expand it out such that
    //  each nibble is it's own character and each pair has a leading backslash.
    //

    source = sourceFilterElement;
    sourceCount = sourceLength;

    while ((sourceCount--) > 0) {

        ch = *source;

        if (((ch >= 'A') && (ch <= 'Z')) ||
            ((ch >= 'a') && (ch <= 'z')) ||
            ((ch >= '0') && (ch <= '9'))) {

            *(dest++) = ch;

        } else {

            *(dest++) = '\\';

            ch = ( (*source) & 0xF0 ) >> 4;

            *(dest++) = LdapHexToCharTable[ch];

            ch = (*source) & 0x0F;

            *(dest++) = LdapHexToCharTable[ch];
        }

        source++;
    }

    *dest = '\0';

    return LDAP_SUCCESS;
}

// search.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\utf8.cxx ===
/*++

Copyright (c) 1991-1996,  Microsoft Corporation  All rights reserved.

Module Name:

    utf.c

Abstract:

    This file contains functions that convert UTF strings to Unicode
    strings and Unicode string to UTF strings.

    External Routines found in this file:
      UTFCPInfo
      UTFToUnicode
      UnicodeToUTF

Revision History:

    02-06-96    JulieB    Created.
    03-05-97    AndyHe    Hacked up a piece of it for LDAP client since
                          Win9x doesn't have UTF-8 codepage available.
    06-29-99    AnoopA    Added Surrogate UTF-8 surrogate pair support.

--*/



//
//  Include Files.
//
#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

//
//  Constant Declarations.
//

#define ASCII             0x007f

#define SHIFT_IN          '+'     // beginning of a shift sequence
#define SHIFT_OUT         '-'     // end       of a shift sequence

#define UTF8_2_MAX        0x07ff  // max UTF8 2-byte sequence (32 * 64 = 2048)
#define UTF8_1ST_OF_2     0xc0    // 110x xxxx
#define UTF8_1ST_OF_3     0xe0    // 1110 xxxx
#define UTF8_1ST_OF_4         0xf0    // 1111 xxxx
#define UTF8_TRAIL        0x80    // 10xx xxxx

#define HIGHER_6_BIT(u)    ((u) >> 12)
#define MIDDLE_6_BIT(u)   (((u) & 0x0fc0) >> 6)
#define LOWER_6_BIT(u)    ((u) & 0x003f)

#define BIT7(a)           ((a) & 0x80)
#define BIT6(a)           ((a) & 0x40)

#define HIGH_SURROGATE_START  0xd800
#define HIGH_SURROGATE_END    0xdbff
#define LOW_SURROGATE_START   0xdc00
#define LOW_SURROGATE_END     0xdfff

////////////////////////////////////////////////////////////////////////////
//
//  UTF8ToUnicode
//
//  Maps a UTF-8 character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

WINLDAPAPI int LDAPAPI LdapUTF8ToUnicode(
    LPCSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest)
{
    int nTB = 0;                   // # trail bytes to follow
    int cchWC = 0;                 // # of Unicode code points generated
    LPCSTR pUTF8 = lpSrcStr;
    DWORD dwSurrogateChar = 0;     // Full surrogate char
    BOOL bSurrogatePair = FALSE;   // Indicate we'r collecting a surrogate pair
    char UTF8;


    while ((cchSrc--) && ((cchDest == 0) || (cchWC < cchDest)))
    {
        //
        //  See if there are any trail bytes.
        //
        if (BIT7(*pUTF8) == 0)
        {
            //
            //  Found ASCII.
            //
            if (cchDest)
            {
                lpDestStr[cchWC] = (WCHAR)*pUTF8;
            }
            bSurrogatePair = FALSE;
            cchWC++;
        }
        else if (BIT6(*pUTF8) == 0)
        {
            //
            //  Found a trail byte.
            //  Note : Ignore the trail byte if there was no lead byte.
            //
            if (nTB != 0)
            {
                //
                //  Decrement the trail byte counter.
                //
                nTB--;

                if (bSurrogatePair)
                {
                    dwSurrogateChar <<= 6;
                    dwSurrogateChar |= LOWER_6_BIT(*pUTF8);

                    if (nTB == 0)
                    {
                        if (cchDest)
                        {
                            if ((cchWC + 1) < cchDest)
                            {
                                lpDestStr[cchWC]   = (WCHAR)
                                                     (((dwSurrogateChar - 0x10000) >> 10) + HIGH_SURROGATE_START);

                                lpDestStr[cchWC+1] = (WCHAR)
                                                     ((dwSurrogateChar - 0x10000)%0x400 + LOW_SURROGATE_START);
                            }
                        }

                        cchWC += 2;
                        bSurrogatePair = FALSE;
                    }
                }
                else
                {
                    //
                    //  Make room for the trail byte and add the trail byte
                    //  value.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] <<= 6;
                        lpDestStr[cchWC] |= LOWER_6_BIT(*pUTF8);
                    }

                    if (nTB == 0)
                    {
                        //
                        //  End of sequence.  Advance the output counter.
                        //
                        cchWC++;
                    }
                }
            }
            else
            {
                // error - not expecting a trail byte
                bSurrogatePair = FALSE;
            }
        }
        else
        {
            //
            //  Found a lead byte.
            //
            if (nTB > 0)
            {
                //
                //  Error - previous sequence not finished.
                //
                nTB = 0;
                bSurrogatePair = FALSE;
                cchWC++;
            }
            else
            {
                //
                //  Calculate the number of bytes to follow.
                //  Look for the first 0 from left to right.
                //
                UTF8 = *pUTF8;
                while (BIT7(UTF8) != 0)
                {
                    UTF8 <<= 1;
                    nTB++;
                }

                //
                // If this is a surrogate unicode pair
                //
                if (nTB == 4)
                {
                    dwSurrogateChar = UTF8 >> nTB;
                    bSurrogatePair = TRUE;
                }

                //
                //  Store the value from the first byte and decrement
                //  the number of bytes to follow.
                //
                if (cchDest)
                {
                    lpDestStr[cchWC] = UTF8 >> nTB;
                }
                nTB--;
            }
        }

        pUTF8++;
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of Unicode characters written.
    //
    SetLastError(ERROR_SUCCESS);
    return (cchWC);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF8
//
//  Maps a Unicode character string to its UTF-8 string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

WINLDAPAPI int LDAPAPI LdapUnicodeToUTF8(
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPSTR lpDestStr,
    int cchDest)
{
    LPCWSTR lpWC = lpSrcStr;
    int     cchU8 = 0;                // # of UTF8 chars generated
    DWORD   dwSurrogateChar;
    WCHAR   wchHighSurrogate = 0;
    BOOL    bHandled;


    while ((cchSrc--) && ((cchDest == 0) || (cchU8 < cchDest)))
    {
        bHandled = FALSE;

        //
        // Check if high surrogate is available
        //
        if ((*lpWC >= HIGH_SURROGATE_START) && (*lpWC <= HIGH_SURROGATE_END))
        {
            if (cchDest)
            {
                // Another high surrogate, then treat the 1st as normal
                // Unicode character.
                if (wchHighSurrogate)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
                    }
                    else
                    {
                        // not enough buffer
                        cchSrc++;
                        break;
                    }
                }
            }
            else
            {
                cchU8 += 3;
            }
            wchHighSurrogate = *lpWC;
            bHandled = TRUE;
        }

        if (!bHandled && wchHighSurrogate)
        {
            if ((*lpWC >= LOW_SURROGATE_START) && (*lpWC <= LOW_SURROGATE_END))
            {
                 // wheee, valid surrogate pairs

                 if (cchDest)
                 {
                     if ((cchU8 + 3) < cchDest)
                     {
                         dwSurrogateChar = (((wchHighSurrogate-0xD800) << 10) + (*lpWC - 0xDC00) + 0x10000);

                         lpDestStr[cchU8++] = (UTF8_1ST_OF_4 |
                                               (unsigned char)(dwSurrogateChar >> 18));           // 3 bits from 1st byte

                         lpDestStr[cchU8++] =  (UTF8_TRAIL |
                                                (unsigned char)((dwSurrogateChar >> 12) & 0x3f)); // 6 bits from 2nd byte

                         lpDestStr[cchU8++] = (UTF8_TRAIL |
                                               (unsigned char)((dwSurrogateChar >> 6) & 0x3f));   // 6 bits from 3rd byte

                         lpDestStr[cchU8++] = (UTF8_TRAIL |
                                               (unsigned char)(0x3f & dwSurrogateChar));          // 6 bits from 4th byte
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
                 else
                 {
                     // we already counted 3 previously (in high surrogate)
                     cchU8 += 1;
                 }

                 bHandled = TRUE;
            }
            else
            {
                 // Bad Surrogate pair : ERROR
                 // Just process wchHighSurrogate , and the code below will
                 // process the current code point
                 if (cchDest)
                 {
                     if ((cchU8 + 2) < cchDest)
                     {
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
            }

            wchHighSurrogate = 0;
        }

        if (!bHandled)
        {
            if (*lpWC <= ASCII)
            {
                //
                //  Found ASCII.
                //
                if (cchDest)
                {
                    if (cchU8<cchDest)
                    {
                        lpDestStr[cchU8] = (char)*lpWC;
                    }
                    else
                    {
                        //
                        // Error - buffer too small.
                        // 
                        cchSrc++;
                        break;            
                    }
                }
                cchU8++;
            }
            else if (*lpWC <= UTF8_2_MAX)
            {
                //
                //  Found 2 byte sequence if < 0x07ff (11 bits).
                //
                if (cchDest)
                {
                    if ((cchU8 + 1) < cchDest)
                    {
                        //
                        //  Use upper 5 bits in first byte.
                        //  Use lower 6 bits in second byte.
                        //
                        lpDestStr[cchU8++] = UTF8_1ST_OF_2 | (*lpWC >> 6);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 2;
                }
            }
            else
            {
                //
                //  Found 3 byte sequence.
                //
                if (cchDest)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        //
                        //  Use upper  4 bits in first byte.
                        //  Use middle 6 bits in second byte.
                        //  Use lower  6 bits in third byte.
                        //
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(*lpWC);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(*lpWC);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 3;
                }
            }
        }

        lpWC++;
    }

    //
    // If the last character was a high surrogate, then handle it as a normal
    // unicode character.
    //
    if ((cchSrc < 0) && (wchHighSurrogate != 0))
    {
        if (cchDest)
        {
            if ((cchU8 + 2) < cchDest)
            {
                lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
            }
            else
            {
                cchSrc++;
            }
        }
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }
    
    //
    //  Return the number of UTF-8 characters written.
    //
    return (cchU8);
}

// utf8.cxx eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\util.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c  utility routines for LDAP client DLL

Abstract:

   This module contains general utility routines for LDAP client DLL.

Author:

    Andy Herron (andyhe)        08-May-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ldapp2.hxx"

ULONG LdapAllocatedHeap = 0;

FNLOADSTRINGA pfLoadStringA = NULL;
FNWSPRINTFW pfwsprintfW = NULL;
FNMESAGEBOXW pfMessageBoxW = NULL;
BOOLEAN Faileduser32LoadLib = FALSE;
HINSTANCE USER32LibraryHandle = NULL;


PLDAP_CONN
GetConnectionPointer(
    LDAP *ExternalHandle
    )
{
    PLDAP_CONN connection = NULL;

    __try
    {
        if (ExternalHandle == NULL)
            return NULL;

        connection = (PLDAP_CONN)((PCHAR)ExternalHandle - FIELD_OFFSET(LDAP_CONN, TcpHandle));

        if (connection->ExternalInfo != ExternalHandle)
            return NULL;

        ACQUIRE_LOCK( &connection->StateLock );

        if (connection->ReferenceCount == 0) {

            RELEASE_LOCK( &connection->StateLock );
            return NULL;
        }

        if (connection->ConnObjectState != ConnObjectActive) {

            RELEASE_LOCK( &connection->StateLock );
            return NULL;
        }

        connection->ReferenceCount++;

        RELEASE_LOCK( &connection->StateLock );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return NULL;
    }

    return connection;
}

PLDAP_CONN
GetConnectionPointer2(
    LDAP *ExternalHandle
    )
{
    //
    // Special routine called during ldap_get_option and ldap_msgfree to reference
    // a connection which may have been closed. Note that we don't care about the
    // state of the connection during this operation.
    //

    PLDAP_CONN connection = NULL;

    __try
    {
        if (ExternalHandle == NULL)
            return NULL;

        connection = (PLDAP_CONN)((PCHAR)ExternalHandle - FIELD_OFFSET(LDAP_CONN, TcpHandle));

        if (connection->ExternalInfo != ExternalHandle)
            return NULL;

        ACQUIRE_LOCK( &connection->StateLock );

        if (connection->ReferenceCount == 0) {

            RELEASE_LOCK( &connection->StateLock );
            return NULL;
        }

        connection->ReferenceCount++;

        RELEASE_LOCK( &connection->StateLock );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return NULL;
    }

    return connection;
}

PLDAP_CONN
ReferenceLdapConnection(
    PLDAP_CONN connection
    )
{
    __try
    {
        if (connection == NULL)
            return NULL;

        ACQUIRE_LOCK( &connection->StateLock );

        if (connection->ReferenceCount == 0) {

            RELEASE_LOCK( &connection->StateLock );
            return NULL;
        }

        if (connection->ConnObjectState != ConnObjectActive) {

            RELEASE_LOCK( &connection->StateLock );
            return NULL;
        }

        connection->ReferenceCount++;

        RELEASE_LOCK( &connection->StateLock );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return NULL;
    }

    return connection;
}

PLDAP_REQUEST
ReferenceLdapRequest(
    PLDAP_REQUEST request
    )
{
    __try
    {
        if ( request == NULL)
            return NULL;

        ACQUIRE_LOCK( &request->Lock );

        if (request->ReferenceCount == 0) {

            RELEASE_LOCK( &request->Lock );
            return NULL;
        }

        request->ReferenceCount++;

        RELEASE_LOCK( &request->Lock );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return NULL;
    }

    return request;
}

LPVOID
ldapMalloc (
    DWORD Bytes,
    ULONG Tag
    )
{
    PLDAP_MEMORY_DESCRIPTOR allocBlock;

#if 0
    ASSERT( HeapValidate( LdapHeap, 0, 0 ) );
#endif

    allocBlock = (PLDAP_MEMORY_DESCRIPTOR) HeapAlloc( LdapHeap,
                            HEAP_ZERO_MEMORY,
                            Bytes + sizeof( LDAP_MEMORY_DESCRIPTOR ));

    IF_DEBUG(HEAP) {
        LdapPrint3( "ldapMalloc allocated 0x%x bytes at addr 0x%x of tag 0x%x.\n",
                Bytes, allocBlock, Tag );
    }

    if (allocBlock != NULL) {

        allocBlock->Tag = Tag;
        allocBlock->Length = Bytes;

        allocBlock++;   // skip over memory block descriptor

        LdapAllocatedHeap += Bytes;
    }

    IF_DEBUG(HEAP) {
        LdapPrint4( "ldapMalloc 0x%08x bytes at addr 0x%x of tag %x, tot=%d.\n",
                    Bytes, allocBlock, Tag, LdapAllocatedHeap );
    }

    return allocBlock;
}

VOID
ldapSecureFree (
    LPVOID Block,
    ULONG  Tag
    )
{

    PLDAP_MEMORY_DESCRIPTOR allocBlock;

    if (Block == NULL) {
        return;
    }

    allocBlock = (PLDAP_MEMORY_DESCRIPTOR) Block;
    allocBlock--;   // point to header

    if (allocBlock->Tag == LDAP_DONT_FREE_SIGNATURE) {
        return;
    }


    SecureZeroMemory(Block, allocBlock->Length);

    ldapFree(Block, Tag);
}

VOID
ldapFree (
    LPVOID Block,
    ULONG  Tag
    )
{
    PLDAP_MEMORY_DESCRIPTOR allocBlock;

    if (Block == NULL) {
        return;
    }

    allocBlock = (PLDAP_MEMORY_DESCRIPTOR) Block;
    allocBlock--;   // point to header

    if (allocBlock->Tag == LDAP_DONT_FREE_SIGNATURE) {
        return;
    }

    if (allocBlock->Tag == LDAP_FREED_SIGNATURE) {

        LdapPrint1("Freeing memory at 0x%x which is already freed\n", Block);
        ASSERT( allocBlock->Tag != LDAP_FREED_SIGNATURE );
    }

    IF_DEBUG(HEAP) {
        LdapPrint3( "ldapfree freed       0x%x bytes at addr 0x%x of tag 0x%x.\n",
                allocBlock->Length, allocBlock, Tag );
    }


    if (allocBlock->Tag != Tag) {

        LdapPrint2("Expected tag 0x%x but found tag 0x%x\n", Tag, allocBlock->Tag );
        ASSERT( allocBlock->Tag == Tag );
    }


    LdapAllocatedHeap -= allocBlock->Length;

    IF_DEBUG(HEAP) {
       LdapPrint4( "ldapFree   0x%08x bytes at addr 0x%x of tag %x, tot=%d.\n",
                    allocBlock->Length, Block, Tag, LdapAllocatedHeap );
    }

    IF_DEBUG(HEAP) {
        ASSERT( HeapValidate( LdapHeap, 0, 0 ) );
    }

#if 0
    ASSERT( HeapValidate( LdapHeap, 0, 0 ) );
#endif

    allocBlock->Tag = LDAP_FREED_SIGNATURE;
    HeapFree( LdapHeap, 0, allocBlock );

    return;
}

BOOLEAN
ldapSwapTags (
    LPVOID Block,
    ULONG  OldTag,
    ULONG  NewTag
    )
{
    PLDAP_MEMORY_DESCRIPTOR allocBlock;
    BOOLEAN rc;

    if (Block == NULL) {
        return FALSE;
    }

    allocBlock = (PLDAP_MEMORY_DESCRIPTOR) Block;
    allocBlock--;   // point to header

    rc = (( allocBlock->Tag == OldTag ) ? TRUE : FALSE );

    allocBlock->Tag = NewTag;

    IF_DEBUG(HEAP) {
       ASSERT( HeapValidate( LdapHeap, 0, allocBlock ) );
    }

    return rc;
}


PLDAP_RECVBUFFER
LdapGetReceiveStructure (
    DWORD cbBuffer
    )
//
//  This routine allocates a receive buffer for a connection and puts it on
//  the pending list for the connection.  It then posts the receive to the
//  transport for overlapped i/o.
//
{
    PLDAP_RECVBUFFER receiveBuffer;

    receiveBuffer = (PLDAP_RECVBUFFER) ldapMalloc( sizeof( LDAP_RECVBUFFER ) +
                                                   cbBuffer,
                                                   LDAP_RECV_SIGNATURE );

    if (receiveBuffer == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint1( "ldap GetReceiveStructure failed alloc of 0x%x.\n",
                        sizeof( LDAP_RECVBUFFER ) +
                        INITIAL_MAX_RECEIVE_BUFFER );
        }

        return NULL;
    }

    //
    //  zero filled from malloc.  Fill in rest of fields.
    //

    receiveBuffer->BufferSize = cbBuffer;

    return receiveBuffer;
}

VOID
LdapFreeReceiveStructure (
    IN PLDAP_RECVBUFFER ReceiveBuffer,
    IN BOOLEAN HaveLock
    )
{
    PLDAP_CONN connection;

    connection = (PLDAP_CONN) InterlockedExchangePointer(  (PVOID *) &ReceiveBuffer->Connection,
                                                           NULL );

    if (connection != NULL) {

        if (!HaveLock) {
            ACQUIRE_LOCK( &ConnectionListLock );
        }

        RemoveEntryList( &ReceiveBuffer->ReceiveListEntry );

        if (!HaveLock) {
            RELEASE_LOCK( &ConnectionListLock );
        }
    }

    ldapFree( ReceiveBuffer, LDAP_RECV_SIGNATURE );

    return;
}


PLDAP_MESSAGEWAIT
LdapGetMessageWaitStructure (
    IN PLDAP_CONN Connection,
    IN ULONG CompleteMessages,
    IN ULONG MessageNumber,
    IN BOOLEAN PendingSendOnly
    )
//
//  The structure returned can has a few fields of interest :
//    - event for thread to wait on that is triggered when message comes in
//    - message number that waiting thread is interested in (none if interested
//      in all messages from server)
//    - list entry for per connection list of outstanding wait structures
//
{
    PLDAP_MESSAGEWAIT message = NULL;
    HANDLE event;

    event = CreateEvent( NULL, FALSE, FALSE, NULL );

    if (event == NULL) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "ldap GetMessageWaitStructure conn 0x%x failed alloc of event.\n",
                            Connection );
        }

        return NULL;
    }

    message = (PLDAP_MESSAGEWAIT) ldapMalloc( sizeof( LDAP_MESSAGEWAIT ),
                                                      LDAP_WAIT_SIGNATURE );

    if (message == NULL) {

        IF_DEBUG(OUTMEMORY) {
            LdapPrint2( "ldap GetMessageWaitStructure conn 0x%x failed alloc of 0x%x.\n",
                            Connection,
                            sizeof( LDAP_MESSAGEWAIT ));
        }

        CloseHandle( event );
        return NULL;
    }

    //
    //  zero filled from malloc.  Fill in rest of fields.
    //

    if (Connection != NULL) {

        //
        // Note that this can fail and return NULL if the
        // connection is being closed. This is fine, we'll
        // store NULL in the wait structure and it will
        // be taken care of when the structure is freed.
        //

        Connection = ReferenceLdapConnection( Connection );
    }

    message->Connection = Connection;
    message->MessageNumber = MessageNumber;
    message->Event = event;
    message->Satisfied = FALSE;
    message->MessageNumber = MessageNumber;
    message->AllOfMessage = CompleteMessages;
    message->PendingSendOnly = PendingSendOnly;

    ResetEvent( event );

    ACQUIRE_LOCK( &ConnectionListLock );
    InsertTailList( &GlobalListWaiters, &message->WaitListEntry );
    GlobalWaiterCount++;
    RELEASE_LOCK( &ConnectionListLock );

    return( message );
}

VOID
LdapFreeMessageWaitStructure (
    PLDAP_MESSAGEWAIT Message
    )
//
//  Free the wait structure.  The connectionListLock must be held here.
//
{
    PLDAP_CONN connection = Message->Connection;

    RemoveEntryList( &Message->WaitListEntry );
    GlobalWaiterCount--;

    //
    //  if this is the last waiter and we're shutting down, clear the
    //  shutdown event.
    //

    if ((GlobalWaiterCount == 0) &&
        (GlobalLdapShuttingDown == TRUE) &&
        (GlobalLdapShutdownEvent != NULL)) {

        SetEvent( GlobalLdapShutdownEvent );
    }

    if (connection != NULL) {

        DereferenceLdapConnection( connection );
    }

    CloseHandle( Message->Event );

    ldapFree( Message, LDAP_WAIT_SIGNATURE );

    return;
}


VOID
SetConnectionError (
    PLDAP_CONN Connection,
    ULONG   LdapError,
    PCHAR   DNNameInError
    )
{
    if (GlobalTlsLastErrorIndex != 0xFFFFFFFF) {

        TlsSetValue( GlobalTlsLastErrorIndex, UIntToPtr( LdapError ));
    }

    if ((Connection != NULL) && (LoadUser32Now())) {

        Connection->publicLdapStruct.ld_errno = LdapError;

        if ((int) LdapError < LDAP_SUCCESS ||
            LdapError >= LDAP_MAX_ERROR_STRINGS) {

            IF_DEBUG(API_ERRORS) {
                LdapPrint1( "ldap SetConnectionError do not have text for message 0x%x.\n",
                                LdapError );
            }

            Connection->publicLdapStruct.ld_error = LdapErrorStrings[LDAP_OTHER];

        } else {

            Connection->publicLdapStruct.ld_error = LdapErrorStrings[LdapError];
        }
        Connection->publicLdapStruct.ld_matched = DNNameInError;

        if (*(Connection->publicLdapStruct.ld_error) == '\0') {

            IF_DEBUG(API_ERRORS) {
                LdapPrint1( "ldap SetConnectionError do not have text for message 0x%x.\n",
                                LdapError );
            }
            Connection->publicLdapStruct.ld_error = LdapErrorStrings[LDAP_OTHER];
        }
    }

    return;
}

ULONG __cdecl
ldap_msgfree (
    LDAPMessage *res
    )
{
    PLDAPMessage nextMessage;
    LBER *lber;

    if (res == NULL) {

        return LDAP_SUCCESS;
    }

    //
    //  free this plus all chained messages
    //

    while (res != NULL) {

        ASSERT( res->lm_next == NULL );

        nextMessage = res->lm_chain;

        lber = (LBER *) res->lm_ber;

        if (lber != NULL) {
            delete lber;
        }

        if (res->ConnectionReferenced && res->Connection != NULL) {

            PLDAP_CONN connection = NULL;

            //
            // We need to reference the connection even if it is in a closed
            // state. Hence the call to GetConnectionPointer2.
            //

            connection = GetConnectionPointer2(res->Connection);

            if (connection != NULL) {
                
                IF_DEBUG(REFCNT) {
                    LdapPrint2("Derefing Conn 0x%x with ref count 0x%x\n", connection, connection->ReferenceCount);
                }
                DereferenceLdapConnection( connection );
                
                //
                // Our intent is to dereference it - do it twice to compensate for
                // GetConnectionPointer2 referencing it again
                //
                
                DereferenceLdapConnection( connection );
                res->Connection = NULL;
            
            } else {
                IF_DEBUG(ERRORS) {
                    LdapPrint1("Referencing Conn 0x%x failed.\n", res->Connection);
                }
            }
        }

        ldapFree( res, LDAP_MESG_SIGNATURE );
        res = nextMessage;
    }

    return LDAP_SUCCESS;
}

PWCHAR __cdecl
ldap_err2stringW (
    ULONG err
    )
{
    PWCHAR msg = NULL;

    if (!LoadUser32Now()) {
       return NULL;
    }

    if (err < LDAP_MAX_ERROR_STRINGS ) {

        msg = &LdapErrorStringsW[err][0];
    }

    if (msg == NULL) {

        msg = &LdapErrorStringsW[LDAP_LOCAL_ERROR][0];
    }

    return msg;
}

PCHAR __cdecl
ldap_err2string (
    ULONG err
    )
{
    PCHAR msg = NULL;

    if (!LoadUser32Now()) {
       return NULL;
    }

    if (err < LDAP_MAX_ERROR_STRINGS ) {

        msg = &LdapErrorStrings[err][0];
    }

    if (msg == NULL) {

        msg = &LdapErrorStrings[LDAP_LOCAL_ERROR][0];
    }

    return msg;
}

void __cdecl
ldap_perror (
    LDAP *ld,
    PCHAR msg
    )
{
    //
    //  This is suppose to bring up a dialog showing the user what the
    //  error is.  Not useful in this implementation.
    //

    return;
}


VOID  __cdecl
ldap_memfree(
    PCHAR  Block
    )
{
    ULONG tag = LDAP_BUFFER_SIGNATURE;

    //
    //  This is used to free allocated DNs etc where there is no explicit free.
    //

    if (Block != NULL) {

        PLDAP_MEMORY_DESCRIPTOR allocBlock;

        allocBlock = (PLDAP_MEMORY_DESCRIPTOR) Block;
        allocBlock--;   // point to header

        if ( allocBlock->Tag == LDAP_GENERATED_DN_SIGNATURE ) {

            tag = LDAP_GENERATED_DN_SIGNATURE;

        } else if ( allocBlock->Tag == LDAP_VALUE_SIGNATURE ) {

            tag = LDAP_VALUE_SIGNATURE;

        } else if ( allocBlock->Tag == LDAP_ERROR_SIGNATURE ) {

            tag  = LDAP_ERROR_SIGNATURE;

        } if ( allocBlock->Tag == LDAP_CONTROL_SIGNATURE ) {

            tag = LDAP_CONTROL_SIGNATURE;
        }

        ldapFree( Block, tag );
    }
    return;
}


VOID  __cdecl
ldap_memfreeW(
    PWCHAR  Block
    )
{
    ldap_memfree( (PCHAR) Block );
    return;
}

//
//  misc functions for debugging etc.
//

ULONG __cdecl
ldap_set_dbg_flags (
    ULONG NewFlags
    )
//
//  Set the debug out flags to whatever is passed in.
//
{
    ULONG oldValue = LdapDebug;

#if LDAPDBG
        LdapPrint2( "ldap_set_dbg_flags setting debug outs to 0x%x, old value = 0x%x.\n",
                          NewFlags, oldValue );
#endif

    LdapDebug = NewFlags;
    return oldValue;
}

typedef ULONG (_cdecl *DBGPRINT)( PCH Format, ... );

VOID __cdecl
ldap_set_dbg_routine (
    DBGPRINT DebugPrintRoutine
    )
//
//  Set the debugout routine to whatever is passed in.
//
{
#if LDAPDBG
    if (DebugPrintRoutine == NULL) {

        LdapPrint0( "ldap_set_dbg_routine setting routine back to NULL.\n" );

//      GlobalLdapDbgPrint = DbgPrint;
        GlobalLdapDbgPrint = NULL;

        LdapPrint0( "ldap_set_dbg_routine setting routine back to DbgPrint.\n" );

    } else {

        LdapPrint1( "ldap_set_dbg_routine setting routine to 0x%x.\n", DebugPrintRoutine );

        GlobalLdapDbgPrint = DebugPrintRoutine;

        LdapPrint1( "ldap_set_dbg_routine setting routine to 0x%x.\n", DebugPrintRoutine );
    }
#endif

    return;
}

PCHAR
ldap_dup_string (
    PCHAR String,
    ULONG Extra,
    ULONG Tag
    )
{
    PCHAR newString;
    PCHAR ptr = String;
    ULONG i = 1;

    if (String == NULL) {
        return NULL;
    }

    while (*ptr != '\0') {
        ptr++;
        i++;
    }

    newString = (PCHAR) ldapMalloc( i + Extra, Tag );

    if (newString == NULL) {
        return NULL;
    }

    CopyMemory( newString, String, i );

    return newString;
}

PWCHAR
ldap_dup_stringW (
    PWCHAR String,
    ULONG Extra,
    ULONG Tag
    )
{
    PWCHAR newString;
    PWCHAR ptr = String;
    ULONG i = 1;

    if (String == NULL) {
        return NULL;
    }

    while (*ptr != L'\0') {
        ptr++;
        i++;
    }

    newString = (PWCHAR) ldapMalloc( (i + Extra) * sizeof(WCHAR), Tag );

    if (newString == NULL) {
        return NULL;
    }

    CopyMemory( newString, String, i * sizeof(WCHAR) );

    return newString;
}

#define INITIAL_NUMBER_OF_ENTRIES   6

ULONG
add_string_to_list (
    PWCHAR **ArrayToReturn,
    ULONG *ArraySize,
    PWCHAR StringToAdd,
    BOOLEAN CreateCopy
    )
//
//  This routine adds a duplicate of a string to an array of strings
//  by allocating both the duplicate and the array (if necessary).
//
//  Returns number of entries in the list, 0 if couldn't allocate
//
{
    PWCHAR string;
    PWCHAR *arrayEntries;
    ULONG entryCount = 1;
    ULONG totalEntries = *ArraySize;

    if (CreateCopy) {

        string = ldap_dup_stringW( StringToAdd, 0, LDAP_VALUE_SIGNATURE );

    } else {

        string = StringToAdd;
    }

    if (string == NULL) {

        return 0;
    }

    if (*ArrayToReturn == NULL) {

        arrayEntries = (PWCHAR *) ldapMalloc( INITIAL_NUMBER_OF_ENTRIES * sizeof( PWCHAR ),
                                              LDAP_VALUE_LIST_SIGNATURE );

        if (arrayEntries == NULL) {

            if (CreateCopy) {
                ldapFree( string, LDAP_VALUE_SIGNATURE );
            }
            return 0;
        }

        *ArrayToReturn = arrayEntries;
        *ArraySize = totalEntries = INITIAL_NUMBER_OF_ENTRIES;
        *arrayEntries = NULL;

    } else {

        arrayEntries = *ArrayToReturn;

        while (*arrayEntries != NULL) {

            arrayEntries++;
            entryCount++;
        }
    }

    if (entryCount == totalEntries) {

        PWCHAR *newArray;
        PWCHAR *oldArray;

        //
        //  have to realloc the list since it's too small
        //

        totalEntries *= 2;

        newArray = (PWCHAR *) ldapMalloc( totalEntries * sizeof( PWCHAR ),
                                          LDAP_VALUE_LIST_SIGNATURE );

        if (newArray == NULL) {

            if (CreateCopy) {
                ldapFree( string, LDAP_VALUE_SIGNATURE );
            }
            return 0;
        }

        arrayEntries = *ArrayToReturn;      // start at beginning for copy

        oldArray = *ArrayToReturn;          // save off old one to free

        *ArrayToReturn = newArray;          // save off start of new one

        while (*arrayEntries != NULL) {     // copy old to new one

            *(newArray++) = *(arrayEntries++);
        }
        arrayEntries = newArray;            // make the new one current

        ldapFree( oldArray, LDAP_VALUE_LIST_SIGNATURE );

        *ArraySize = totalEntries;
    }

    *arrayEntries = string;
    *(arrayEntries+1) = NULL;

    return entryCount+1;
}

//
//  some folks don't want us to pull in msvcrt dll... we'll use our own
//  routine for this.
//

VOID
ldap_MoveMemory (
    PCHAR dest,
    PCHAR source,
    ULONG length
    )
{
    if (dest > source) {

        dest += length;
        source += length;

        while (length-- > 0) {

            *(--dest) = *(--source);
        }

    } else if (dest != source) {

        while (length-- > 0) {

            *(dest++) = *(source++);
        }
    }
    return;
}

ULONG
FromUnicodeWithAlloc (
    PWCHAR Source,
    PCHAR *Output,
    ULONG Tag,
    ULONG Language
    )
{
    INT sLength = 0;
    INT tLength;

    *Output = NULL;

    if (Source == NULL) {
        return LDAP_SUCCESS;
    }

    sLength = strlenW( Source );

    //
    //  determine length of required string
    //

    if (Language == LANG_UTF8) {

        tLength = LdapUnicodeToUTF8( Source, sLength, NULL, 0 );

    } else {

        tLength = WideCharToMultiByte(  CP_ACP,
                                        0,
                                        Source,
                                        sLength,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL );
    }

    if ((tLength == 0) && (sLength > 0)) {

        return LDAP_PARAM_ERROR;
    }

    *Output = (PCHAR) ldapMalloc( tLength + 1, Tag );

    if (*Output == NULL) {

        return LDAP_NO_MEMORY;
    }

    if (sLength == 0) {

        tLength = 0;

    } else {

        if (Language == LANG_UTF8) {

            tLength = LdapUnicodeToUTF8( Source, sLength, *Output, tLength );

        } else {

            tLength = WideCharToMultiByte(  CP_ACP,
                                            0,
                                            Source,
                                            sLength,
                                            *Output,
                                            tLength,
                                            NULL,
                                            NULL );
        }
    }

    *((*Output)+tLength) = '\0';

    return LDAP_SUCCESS;
}

ULONG
ToUnicodeWithAlloc (
    PCHAR Source,
    LONG SourceLength,
    PWCHAR *Output,
    ULONG Tag,
    ULONG Language
    )
{
    INT sLength = 0;
    INT tLength;

    *Output = NULL;

    if (Source == NULL) {
        return LDAP_SUCCESS;
    }

    //
    //  determine length of required string
    //

    if (SourceLength == -1) {

        SourceLength = (LONG) strlen( Source );
    }

    if (Language == LANG_UTF8) {

        sLength = LdapUTF8ToUnicode( Source, SourceLength, NULL, 0 );

    } else {


        sLength = MultiByteToWideChar(  CP_ACP,
                                        0,
                                        Source,
                                        SourceLength,
                                        NULL,
                                        0 );
    }

    if ((sLength == 0) && (SourceLength != 0)) {

        return LDAP_PARAM_ERROR;
    }

    *Output = (PWCHAR) ldapMalloc( ( sLength + 1 ) * sizeof(WCHAR) , Tag );

    if (*Output == NULL) {

        return LDAP_NO_MEMORY;
    }

    if (Language == LANG_UTF8) {

        tLength = LdapUTF8ToUnicode( Source, SourceLength, *Output, sLength );

    } else {

        tLength = MultiByteToWideChar(  CP_ACP,
                                        0,
                                        Source,
                                        SourceLength,
                                        *Output,
                                        sLength );
    }

    *((*Output)+tLength) = L'\0';

    return LDAP_SUCCESS;
}

ULONG
strlenW(
    PWCHAR string
    )
{
    ULONG count = 0;

    while (string != NULL && *string != L'\0') {
        count++;
        string++;
    }

    return count;
}


BOOLEAN
ldapWStringsIdentical (
    PWCHAR string1,
    LONG length1,
    PWCHAR string2,
    LONG length2
    )
//
//  Win9x doesn't implement CompareStringW, so we'll roll our own here.
//
{
    BOOLEAN rc = FALSE;
    ULONG err;

    if (string1 == NULL) {

        return (string2 == NULL) ? TRUE : FALSE;

    } else if (string2 == NULL) {

        return FALSE;
    }

    if (! GlobalWin9x ) {

        err = CompareStringW( LDAP_DEFAULT_LOCALE,
                              NORM_IGNORECASE,
                              string1,
                              length1,
                              string2,
                              length2
                              );

        rc = (err == 2) ? TRUE : FALSE;

    } else {

        WCHAR savedChar1 = L'\0';
        WCHAR savedChar2 = L'\0';
        BOOLEAN saved1 = FALSE;
        BOOLEAN saved2 = FALSE;

        if (length1 == (ULONG) -1) {

            length1 = strlenW( string1 );

        } else if (*(string1+length1) != L'\0') {

            saved1 = TRUE;
            savedChar1 = *(string1+length1);
            *(string1+length1) = L'\0';
        }

        if (length2 == (ULONG) -1) {

            length2 = strlenW( string2 );

        } else if (*(string2+length2) != L'\0') {

            saved2 = TRUE;
            savedChar2 = *(string2+length2);
            *(string2+length2) = L'\0';
        }

        if (length1 != length2) {

            rc = FALSE;

        } else {

            //
            //  we convert the strings to single byte codepage and then do the
            //  compare.
            //

            PCHAR smallString1 = NULL;
            PCHAR smallString2 = NULL;

            err = FromUnicodeWithAlloc( string1,
                                        &smallString1,
                                        LDAP_ANSI_SIGNATURE,
                                        LANG_ACP );

            if (err != LDAP_SUCCESS) {

                rc = FALSE;

            } else {

                err = FromUnicodeWithAlloc( string2,
                                            &smallString2,
                                            LDAP_ANSI_SIGNATURE,
                                            LANG_ACP );

                if (err != LDAP_SUCCESS) {

                    rc =  FALSE;

                } else {

                    err = CompareStringA( LDAP_DEFAULT_LOCALE,
                                          NORM_IGNORECASE,
                                          smallString1,
                                          (ULONG) -1,
                                          smallString2,
                                          (ULONG) -1
                                          );

                    rc = (err == 2) ? TRUE : FALSE;

                    ldapFree( smallString2, LDAP_ANSI_SIGNATURE );
                }

                ldapFree( smallString1, LDAP_ANSI_SIGNATURE );
            }
        }

        if (saved1 == TRUE) {
            *(string1+length1) = savedChar1;
        }
        if (saved2 == TRUE) {
            *(string2+length2) = savedChar2;
        }
    }

    return rc;
}

//
//  Thread Safe way to get last error code returned by LDAP API is to call
//  LdapGetLastError();
//

ULONG __cdecl
LdapGetLastError( VOID )
{
    ULONG err;

    if (GlobalTlsLastErrorIndex != 0xFFFFFFFF) {

        err = PtrToUlong(TlsGetValue( GlobalTlsLastErrorIndex ));

    } else {

        err = LDAP_LOCAL_ERROR;
    }
    return err;
}

//
//  Translate from LdapError to closest Win32 error code.
//

ULONG __cdecl
LdapMapErrorToWin32( ULONG LdapError )
{
    ULONG err;

    switch (LdapError) {

    case LDAP_SUCCESS :
        err = NO_ERROR ;
        break;

    case LDAP_ADMIN_LIMIT_EXCEEDED :
        err = ERROR_NOT_ENOUGH_QUOTA ;
        break;

    case LDAP_OPERATIONS_ERROR :
        err = ERROR_OPEN_FAILED ;
        break;

    case LDAP_PROTOCOL_ERROR :
        err = ERROR_INVALID_LEVEL ;
        break;

    case LDAP_TIMELIMIT_EXCEEDED :
        err = ERROR_TIMEOUT;
        break;

    case LDAP_SIZELIMIT_EXCEEDED :
        err = ERROR_MORE_DATA ;
        break;

    case LDAP_AUTH_METHOD_NOT_SUPPORTED :
        err = ERROR_ACCESS_DENIED ;
        break;

    case LDAP_STRONG_AUTH_REQUIRED :
        err = ERROR_ACCESS_DENIED ;
        break;

    // LDAP_REFERRAL_V2 has same value as LDAP_PARTIAL_RESULTS
    case LDAP_REFERRAL :
    case LDAP_PARTIAL_RESULTS :
        err = ERROR_MORE_DATA ;
        break;

    case LDAP_INVALID_SYNTAX :
        err = ERROR_INVALID_NAME ;
        break;

    case LDAP_NO_SUCH_OBJECT :
        err = ERROR_FILE_NOT_FOUND ;
        break;

    case LDAP_INVALID_DN_SYNTAX :
        err = ERROR_INVALID_PARAMETER ;
        break;

    case LDAP_INAPPROPRIATE_AUTH :
        err = ERROR_ACCESS_DENIED ;
        break;

    case LDAP_INVALID_CREDENTIALS :
        err = ERROR_WRONG_PASSWORD ;
        break;

    case LDAP_INSUFFICIENT_RIGHTS :
        err = ERROR_ACCESS_DENIED ;
        break;

    case LDAP_BUSY :
        err = ERROR_BUSY ;
        break;

    case LDAP_UNAVAILABLE :
        err = ERROR_DEV_NOT_EXIST ;
        break;

    case LDAP_UNWILLING_TO_PERFORM :
        err = ERROR_CAN_NOT_COMPLETE ;
        break;

    case LDAP_SORT_CONTROL_MISSING :
        err = ERROR_DS_SORT_CONTROL_MISSING;
        break;
    
    case LDAP_OFFSET_RANGE_ERROR :
        err = ERROR_DS_OFFSET_RANGE_ERROR;
        break;

    case LDAP_NAMING_VIOLATION :
        err = ERROR_INVALID_PARAMETER ;
        break;

    case LDAP_OBJECT_CLASS_VIOLATION :
        err = ERROR_INVALID_PARAMETER ;
        break;

    case LDAP_ALREADY_EXISTS :
        err = ERROR_ALREADY_EXISTS ;
        break;

    case LDAP_RESULTS_TOO_LARGE :
        err = ERROR_INSUFFICIENT_BUFFER ;
        break;

    case LDAP_OTHER :
        err = ERROR_DS_GENERIC_ERROR ;
        break;

    case LDAP_SERVER_DOWN :
        err = ERROR_BAD_NET_RESP ;
        break;

    case LDAP_LOCAL_ERROR :
        err = ERROR_DS_GENERIC_ERROR ;
        break;

    case LDAP_ENCODING_ERROR :
        err = ERROR_UNEXP_NET_ERR ;
        break;

    case LDAP_DECODING_ERROR :
        err = ERROR_UNEXP_NET_ERR ;
        break;

    case LDAP_TIMEOUT :
        err = ERROR_SERVICE_REQUEST_TIMEOUT ;
        break;

    case LDAP_AUTH_UNKNOWN :
        err = ERROR_WRONG_PASSWORD ;
        break;

    case LDAP_FILTER_ERROR :
        err = ERROR_INVALID_PARAMETER ;
        break;

    case LDAP_USER_CANCELLED :
        err = ERROR_CANCELLED ;
        break;

    case LDAP_PARAM_ERROR :
        err = ERROR_INVALID_PARAMETER ;
        break;

    case LDAP_NO_MEMORY :
        err = ERROR_NOT_ENOUGH_MEMORY ;
        break;

    case LDAP_CONSTRAINT_VIOLATION :
        err = ERROR_INVALID_PARAMETER ;
        break;

    case LDAP_UNAVAILABLE_CRIT_EXTENSION :
        err = ERROR_CAN_NOT_COMPLETE ;
        break;

    case LDAP_NO_SUCH_ATTRIBUTE :
        err = ERROR_INVALID_PARAMETER ;
        break;

    case LDAP_INAPPROPRIATE_MATCHING :
        err = ERROR_INVALID_PARAMETER ;
        break;

    case LDAP_ATTRIBUTE_OR_VALUE_EXISTS :
        err = ERROR_ALREADY_EXISTS;
        break;

    case LDAP_NOT_ALLOWED_ON_NONLEAF :
        err = ERROR_CAN_NOT_COMPLETE ;
        break;

    case LDAP_NOT_SUPPORTED :
        err = ERROR_CAN_NOT_COMPLETE ;
        break;

    case LDAP_NO_RESULTS_RETURNED :

    case LDAP_MORE_RESULTS_TO_RETURN :
        err = ERROR_MORE_DATA ;
        break;

    case LDAP_CONNECT_ERROR :
        err = ERROR_CONNECTION_REFUSED;
        break;

    case LDAP_NOT_ALLOWED_ON_RDN :
        err = ERROR_ACCESS_DENIED ;
        break;

    case LDAP_NO_OBJECT_CLASS_MODS :
        err = ERROR_ACCESS_DENIED ;
        break;

    case LDAP_AFFECTS_MULTIPLE_DSAS :
        err = ERROR_CAN_NOT_COMPLETE ;
        break;

    case LDAP_CONTROL_NOT_FOUND:
        err = ERROR_NOT_FOUND;
        break;

    case LDAP_COMPARE_TRUE :
    case LDAP_COMPARE_FALSE :
    case LDAP_UNDEFINED_TYPE :
    case LDAP_ALIAS_PROBLEM :
    case LDAP_IS_LEAF :
    case LDAP_ALIAS_DEREF_PROBLEM :
    case LDAP_LOOP_DETECT :

        err = ERROR_DS_GENERIC_ERROR ;
        break;

    default:

        IF_DEBUG(ERRORS) {
            LdapPrint1( "wldap32 : MapLdapErrorToWin32 couldn't map 0x%x.\n", LdapError );
        }
        err = ERROR_DS_GENERIC_ERROR ;
        break;
    }

    return err;
}



BOOLEAN LoadUser32Now(
    VOID
    )
{
    //
    // if the user32 DLL is not loaded, we make sure its loaded now.
    //

   if (Faileduser32LoadLib) {

      return FALSE;
   }

   if (pfLoadStringA) {

        return TRUE;
   }

    ACQUIRE_LOCK( &LoadLibLock );

    USER32LibraryHandle = LoadSystem32LibraryA( "USER32.DLL" );

    if (USER32LibraryHandle != NULL) {

       pfLoadStringA = (FNLOADSTRINGA) GetProcAddress( USER32LibraryHandle, "LoadStringA" );
       pfwsprintfW = (FNWSPRINTFW) GetProcAddress( USER32LibraryHandle, "wsprintfW" );
       pfMessageBoxW = (FNMESAGEBOXW) GetProcAddress( USER32LibraryHandle, "MessageBoxW" );

       if (pfLoadStringA == NULL) {

          //
          // No big deal. We won't die if we don't get these functions
          // Just don't try to load the dll again.
          //

          Faileduser32LoadLib = TRUE;
          FreeLibrary( USER32LibraryHandle );
          USER32LibraryHandle = NULL;
          RELEASE_LOCK( &LoadLibLock );
          return FALSE;

       } else {

          //
          //  Load the strings from the resource file
          //

          int i;

          for (i = 0; i < LDAP_MAX_ERROR_STRINGS; i++ ) {

                   pfLoadStringA(  GlobalLdapDllInstance,
                                   WINLDAP_BASE_MSG + i,
                                   &(LdapErrorStrings[i][0]),
                                   LDAP_ERROR_STR_LENGTH );

              MultiByteToWideChar(  CP_ACP,
                                    0,
                                    &(LdapErrorStrings[i][0]),
                                    (int) -1,
                                    &(LdapErrorStringsW[i][0]),
                                    LDAP_ERROR_STR_LENGTH );
          }

          RELEASE_LOCK( &LoadLibLock );
          return TRUE;
       }

    } else {

       //
       // We couldn't load the library. Don't try to load it again.
       //

          Faileduser32LoadLib = TRUE;
          RELEASE_LOCK( &LoadLibLock );
          return FALSE;
    }
}


//
// This routine walks the list of error messages for the current thread looking
// for the given connection. If it finds one, it deletes the old message and appends
// the new one. If it doesn't find an existing entry, it creates one and and inserts
// it into the list.
//
// There can be a maximum of one error string per thread per connection at a time.
//
VOID
InsertErrorMessage(
     PLDAP_CONN Connection,
     PWCHAR ErrorMessage
      )
{
    PLIST_ENTRY pThreadListEntry = NULL;
    PTHREAD_ENTRY pThreadEntry = NULL;

    PERROR_ENTRY pErrorEntry;
    PERROR_ENTRY * ppNext = NULL;
    
    ULONG CurrentThreadId = GetCurrentThreadId();
    BOOLEAN fRetriedFindThread = FALSE;

retryFindThread:

    ACQUIRE_LOCK( &PerThreadListLock );

    pThreadListEntry = GlobalPerThreadList.Flink;

    //
    // Search for this thread's THREAD_ENTRY
    //
    while (pThreadListEntry != &GlobalPerThreadList) {

        pThreadEntry = CONTAINING_RECORD( pThreadListEntry, THREAD_ENTRY, ThreadEntry );
        pThreadListEntry = pThreadListEntry->Flink;

        if (pThreadEntry->dwThreadID == CurrentThreadId) {
            break;
        }

        pThreadEntry = NULL;
    }

    if (!pThreadEntry && !fRetriedFindThread) {
        // this thread must have been created before this DLL was loaded-
        // create a per-thread entry for it now
        RELEASE_LOCK( &PerThreadListLock );
        
        IF_DEBUG(PARSE) {
            LdapPrint2( "InsertErrorMessage could not find ThreadEntry for conn 0x%x, thread 0x%x.  Creating one.\n",
                            Connection, CurrentThreadId );
        }

        if (!AddPerThreadEntry(CurrentThreadId)) {
            IF_DEBUG(PARSE) {
                LdapPrint2( "InsertErrorMessage AddPerThreadEntry failed, conn 0x%x, thread 0x%x.\n",
                                Connection, CurrentThreadId );
            }
            SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
            return;
        }

        fRetriedFindThread = TRUE;
        goto retryFindThread;
    }
    else if (!pThreadEntry) {
        // shouldn't happen --- somehow a thread entry wasn't created
        RELEASE_LOCK( &PerThreadListLock );
        IF_DEBUG(PARSE) {
            LdapPrint2( "InsertErrorMessage no per-thread entry, conn 0x%x, thread 0x%x.\n",
                            Connection, CurrentThreadId );
        }            
        ASSERT(pThreadEntry);
        SetConnectionError( Connection, LDAP_LOCAL_ERROR, NULL );
        return;
    }


    //
    // Now walk the error record list looking for a matching
    // connection
    //
    pErrorEntry = pThreadEntry->pErrorList;
    ppNext = &(pThreadEntry->pErrorList);

    while (pErrorEntry != NULL) {

        if (pErrorEntry->Connection == Connection) {
            ASSERT(pErrorEntry->ThreadId == CurrentThreadId);
            break;
        }

        ppNext = &(pErrorEntry->pNext);
        pErrorEntry = pErrorEntry->pNext;
    }

    if (pErrorEntry) {
        //
        // Found an existing error record for this connection,
        // recycle it
        //
        if (pErrorEntry->ErrorMessage != NULL) {

            ldap_memfreeW( pErrorEntry->ErrorMessage );
        }

        pErrorEntry->ErrorMessage = ErrorMessage;
    }
    else {
        pErrorEntry = (PERROR_ENTRY) ldapMalloc( sizeof( ERROR_ENTRY ), LDAP_ERROR_SIGNATURE);

        if (pErrorEntry != NULL) {

            pErrorEntry->Connection = Connection;
            pErrorEntry->ThreadId = CurrentThreadId;
            pErrorEntry->ErrorMessage = ErrorMessage;
            pErrorEntry->pNext = NULL;

            *ppNext = pErrorEntry;
            
        } else {
            RELEASE_LOCK( &PerThreadListLock );    
            SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
            return;
        }

    }

    RELEASE_LOCK( &PerThreadListLock );    

}


//
// This routine walks the list of error messages for the current thread looking
// for the given connection. If it finds an entry it makes a copy of the error message
// and returns it. If not, it returns NULL. The returned string should be freed
// by calling ldap_memfree
//
// There can be a maximum of one error string per thread per connection at a time.
//

PVOID
GetErrorMessage(
     PLDAP_CONN Connection,
     BOOLEAN    Unicode
      )
{
    PLIST_ENTRY pThreadListEntry = NULL;
    PTHREAD_ENTRY pThreadEntry = NULL;

    PERROR_ENTRY pErrorEntry;

    PVOID ErrorString = NULL;
    ULONG err = 0;

    ULONG CurrentThreadId = GetCurrentThreadId();
    BOOLEAN fRetriedFindThread = FALSE;

retryFindThread:

    ACQUIRE_LOCK( &PerThreadListLock );

    pThreadListEntry = GlobalPerThreadList.Flink;

    //
    // Search for this thread's THREAD_ENTRY
    //
    while (pThreadListEntry != &GlobalPerThreadList) {

        pThreadEntry = CONTAINING_RECORD( pThreadListEntry, THREAD_ENTRY, ThreadEntry );
        pThreadListEntry = pThreadListEntry->Flink;

        if (pThreadEntry->dwThreadID == CurrentThreadId) {
            break;
        }

        pThreadEntry = NULL;
    }
    
    if (!pThreadEntry && !fRetriedFindThread) {
        // this thread must have been created before this DLL was loaded-
        // create a per-thread entry for it now
        RELEASE_LOCK( &PerThreadListLock );
        
        IF_DEBUG(PARSE) {
            LdapPrint2( "GetErrorMessage could not find ThreadEntry for conn 0x%x, thread 0x%x.  Creating one.\n",
                            Connection, CurrentThreadId );
        }

        if (!AddPerThreadEntry(CurrentThreadId)) {
            IF_DEBUG(PARSE) {
                LdapPrint2( "GetErrorMessage AddPerThreadEntry failed, conn 0x%x, thread 0x%x.\n",
                                Connection, CurrentThreadId );
            }
            SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
            return NULL;
        }

        fRetriedFindThread = TRUE;
        goto retryFindThread;
    }
    else if (!pThreadEntry) {
        // shouldn't happen --- somehow a thread entry wasn't created
        RELEASE_LOCK( &PerThreadListLock );
        IF_DEBUG(PARSE) {
            LdapPrint2( "GetErrorMessage no per-thread entry, conn 0x%x, thread 0x%x.\n",
                            Connection, CurrentThreadId );
        }            
        ASSERT(pThreadEntry);
        SetConnectionError( Connection, LDAP_LOCAL_ERROR, NULL );
        return NULL;
    }

    //
    // Now walk the error record list looking for a matching
    // connection
    //
    pErrorEntry = pThreadEntry->pErrorList;

    while (pErrorEntry != NULL) {

        if (pErrorEntry->Connection == Connection) {
            ASSERT(pErrorEntry->ThreadId == CurrentThreadId);
            break;
        }

        pErrorEntry = pErrorEntry->pNext;
    }

    RELEASE_LOCK( &PerThreadListLock );

    //
    // Copy the error string found
    //
    if (pErrorEntry != NULL) {

        if (pErrorEntry->ErrorMessage != NULL) {

            if (Unicode) {

                ErrorString = ldap_dup_stringW( pErrorEntry->ErrorMessage,
                                                0,
                                                LDAP_ERROR_SIGNATURE  );

                if (ErrorString == NULL) {

                    SetConnectionError( Connection, LDAP_NO_MEMORY, NULL );
                }

            } else {

                err = FromUnicodeWithAlloc( pErrorEntry->ErrorMessage,
                                            (char**) &ErrorString,
                                            LDAP_ERROR_SIGNATURE,
                                            LANG_ACP );

                if (err != LDAP_SUCCESS) {

                    SetConnectionError( Connection, err, NULL );
                }
            }
        }
    }

    return ErrorString;
}


WINLDAPAPI LDAP * LDAPAPI ldap_conn_from_msg (
    LDAP *PrimaryConn,
    LDAPMessage *res
    )
//
//  Given an LDAP message, return the connection pointer where the message
//  came from.  It can return NULL if the connection has already been freed.
//
{
    PLDAP connection = NULL;

    //
    //  if the result is not null and the connection is either the primary or
    //  a referenced connection, then we return it.
    //

    if ((res != NULL) &&
        ((res->Connection == PrimaryConn) ||
          res->ConnectionReferenced) ) {

        connection = res->Connection;
    }

    return connection;
}

BOOLEAN
IsMessageIdValid(
     LONG MessageId
     )
{
    //
    // Walk through our list of active requests to find out if any outstanding
    // request is using this messageId.
    //

    PLDAP_REQUEST request = NULL;
    PLIST_ENTRY listEntry;

    if (MessageId == 0) {
        return FALSE;
    }

    ACQUIRE_LOCK( &RequestListLock );

    listEntry = GlobalListRequests.Flink;

    while ((listEntry != &GlobalListRequests) &&
           (request == NULL)) {

        request = CONTAINING_RECORD( listEntry, LDAP_REQUEST, RequestListEntry );
        request = ReferenceLdapRequest( request );

        listEntry = listEntry->Flink;
        
        if (!request) {
            continue;
        }
        
        if ( request->MessageId == MessageId) {

            DereferenceLdapRequest( request );
            RELEASE_LOCK( &RequestListLock );
            LdapPrint1("Message Id 0x%x is already in use \n", MessageId)
            return FALSE;
        }
            
        DereferenceLdapRequest( request );
        request = NULL;
    }

    RELEASE_LOCK( &RequestListLock );

    return TRUE;
}




VOID
DebugReferralOutput(
    PLDAP_REQUEST Request,
    PWCHAR HostAddr,
    PWCHAR NewUrlDN
    )

{
   WCHAR buffer[5000];
   int j;

   if ( PopupRegKeyFound && pfwsprintfW ) {

         j =  pfwsprintfW(buffer, L"Chasing referral to %s\n\
                           \tReferral DN is: %s\n\
                           \tParent searchDN was: %s\n\
                           \tParent search filter was: %s\n\
                           \tParent search filter was: %d\n",
                           HostAddr,
                           NewUrlDN,
                           Request->OriginalDN,
                           Request->search.SearchFilter,
                           Request->search.ScopeOfSearch);
      #if 0
         j += pfwsprintfW(buffer, L"Referral DN is %S\n", NewUrlDN);
         j += pfwsprintfW(buffer, L"Parent searchDN was %S\n", Request->OriginalDN);
         j += pfwsprintfW(buffer, L"Parent search filter was %S\n", Request->search.SearchFilter);

         if (Request->search.ScopeOfSearch == LDAP_SCOPE_SUBTREE) {
            j += pfwsprintfW(buffer, L"Searchscope was Subtree\n");
         } else if (Request->search.ScopeOfSearch == LDAP_SCOPE_BASE) {
            j += pfwsprintfW(buffer, L"Searchscope was base\n");
         } else {
            j += pfwsprintfW(buffer, L"Searchscope was Onelevel\n");
         }
      #endif

         DbgPrint("%S",buffer);

         if (pfMessageBoxW) {

            pfMessageBoxW(NULL, buffer, L"WLDAP32.DLL: Referral alert", MB_OK|MB_APPLMODAL);
         }

   }
}


VOID
LogAttributesAndControls(
    PWCHAR  AttributeList[],
    LDAPModW *ModificationList[],
    PLDAPControlW *ServerControls,
    BOOLEAN Unicode
    )
{
#if DBG
    if ( !DSLOG_ACTIVE ) {
        return;
    }

    DWORD len;
    DWORD i;

    if ( (AttributeList != NULL) && (AttributeList[0] != NULL) ) {

        i=0; len=0;

next_line1:
        while (AttributeList[i] != NULL) {
            if ( Unicode ) {
                DSLOG((DSLOG_FLAG_NOTIME,"[ATTR=%ws]", AttributeList[i]));
                len += strlenW(AttributeList[i]);
            } else {
                DSLOG((DSLOG_FLAG_NOTIME,"[ATTR=%s]", AttributeList[i]));
                len += (DWORD) strlen((PCHAR)AttributeList[i]);
            }
            i++;

            if ( (len > 40) && (AttributeList[i] != NULL) ) {
                len = 0;
                goto next_line1;
            }
        }
        DSLOG((0,"\n"));
    }

    if ( (ModificationList != NULL) && (ModificationList[0] != NULL) ) {

        i=0;

        while (ModificationList[i] != NULL) {
            if ( Unicode ) {
                DSLOG((DSLOG_FLAG_NOTIME,"[ML=op %d type %ws]\n",
                       ModificationList[i]->mod_op & 3,
                       ModificationList[i]->mod_type
                       ));
            } else {
                DSLOG((DSLOG_FLAG_NOTIME,"[ML=op %d type %s]\n",
                       ModificationList[i]->mod_op & 3,
                       ModificationList[i]->mod_type
                       ));
            }
            i++;
        }
    }

    if ( ServerControls != NULL ) {
        DWORD j=0;
        while ( ServerControls[j] != NULL ) {
            if ( Unicode ) {
                DSLOG((DSLOG_FLAG_NOTIME,"[CT=%ws]",ServerControls[j]->ldctl_oid));
            } else {
                DSLOG((DSLOG_FLAG_NOTIME,"[CT=%s]",ServerControls[j]->ldctl_oid));
            }
            j++;
        }
    }
#endif
} // LogAttributesAndControls


ULONGLONG
LdapGetTickCount(
    VOID
    )
/*++

Routine Description:

    Get current time with a resolution of 1 milli second.

Arguments:

    None.

Return Value:

    A 64 bit value representing time since Jan 1, 1601 in 1 millisecond intervals.

--*/
{

    FILETIME FileTime;

    GetSystemTimeAsFileTime( &FileTime );

    //
    // Convert nano seconds to milliseconds and return the value.
    //

    return ((((ULONGLONG)FileTime.dwHighDateTime)<<32) | FileTime.dwLowDateTime)/10000;

}

ULONG
LdapGetModuleBuildNum(
    VOID
    )
/*++

Routine Description:

    Get the SDK version of wldap32.dll.

Arguments:

    None.

Return Value:

    A 32 bit value denoting the SDK version of wldap32.dll.

--*/
{
    return LDAP_VENDOR_VERSION; // NT 5.1 * 100
}



VOID
RoundUnicodeStringMaxLength(
    UNICODE_STRING *pString,
    USHORT dwMultiple
    )
/*++

Routine Description:

    Adjusts the max length field of a UNICODE_STRING so
    that it is a multiple of dwMultiple.

    IMPORTANT: This function assumes that the UNICODE_STRING
    already points to a buffer of sufficient size.  To do this,
    make sure the buffer has at least dwMultiple-1 spare bytes.

Arguments:

    pString - ptr to UNICODE_STRING to adjust
    dwMultiple - multiple to round the strings max length up to

Return Value:

    none

--*/

{
    USHORT extra = (pString->MaximumLength % dwMultiple);
    ASSERT(extra < dwMultiple);

    if (extra == 0) {
        //
        // Already an exact multiple of dwMultiple, nothing
        // more to do
        //
        return;
    }

    pString->MaximumLength += (dwMultiple - extra);
}



VOID
EncodeUnicodeString(
    UNICODE_STRING *pString
    )
/*++

Routine Description:

    Encodes a Unicode string, using RtlEncryptMemory if available,
    else using RtlEncodeUnicodeString

Arguments:

    pString - ptr to UNICODE_STRING to encode

Return Value:

    none

--*/
    
{
    NTSTATUS stat;

    ASSERT(GlobalUseScrambling == TRUE);
    ASSERT(pRtlEncryptMemory || pRtlRunEncodeUnicodeString);
    ASSERT((pString->MaximumLength % DES_BLOCKLEN) == 0);

    if ((pString->Buffer == NULL) ||
        (pString->MaximumLength == 0)) {

        // nothing to encode, so do nothing
        // (RtlEncryptMemory will otherwise return an error);
        return;
    }

    if (pRtlEncryptMemory) {
        stat = pRtlEncryptMemory(pString->Buffer, pString->MaximumLength, 0);
        ASSERT(stat == STATUS_SUCCESS);        
    }
    else {
        pRtlRunEncodeUnicodeString(&GlobalSeed, pString);
    }
}



VOID
DecodeUnicodeString(
    UNICODE_STRING *pString
    )
/*++

Routine Description:

    Decodes a Unicode string, using RtlDecryptMemory if available,
    else using RtlDecodeUnicodeString

Arguments:

    pString - ptr to UNICODE_STRING to decode

Return Value:

    none

--*/
    
{
    NTSTATUS stat;

    ASSERT(GlobalUseScrambling == TRUE);
    ASSERT(pRtlDecryptMemory || pRtlRunDecodeUnicodeString);
    ASSERT((pString->MaximumLength % DES_BLOCKLEN) == 0);    

    if ((pString->Buffer == NULL) ||
        (pString->MaximumLength == 0)) {

        // nothing to decode, so do nothing
        // (RtlDecryptMemory will otherwise return an error);
        return;
    }
    
    if (pRtlDecryptMemory) {
        stat = pRtlDecryptMemory(pString->Buffer, pString->MaximumLength, 0);
        ASSERT(stat == STATUS_SUCCESS);
    }
    else {
        pRtlRunDecodeUnicodeString(GlobalSeed, pString);
    }
}


// This function is like LoadLibraryA, but it prepends the
// path to the system32 directory, to prevent inadvertently
// loading a bad DLL that happens to have the same name
HMODULE 
LoadSystem32LibraryA(
  PCHAR lpFileName
)
{
    DWORD dwLen = MAX_PATH+1;
    UINT err;
    
    PCHAR pszDllName = NULL;
    HMODULE hDll = NULL;


    //
    // Allocate enough space to hold the concatenated DLL name
    //
    dwLen += strlen(lpFileName);
    dwLen += 2;                     // to add in the backslash, and NULL terminator

    pszDllName = (PCHAR) ldapMalloc(dwLen * sizeof(CHAR), LDAP_ANSI_SIGNATURE);
    if (!pszDllName) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LoadSystem32LibraryA couldn't alloc 0x%x bytes.\n", dwLen );
        }

        goto exit;
    }


    //
    // Get the path to \windows\system32
    //
    err = GetSystemDirectoryA(pszDllName, MAX_PATH+1);

    if ( (err == 0) || (err > MAX_PATH+1)) {

        IF_DEBUG(ERRORS) {
            LdapPrint1( "LoadSystem32LibraryA: GetSystemDirectory failed, err = 0x%x.\n", err );
        }

        goto exit;
    }

    if (pszDllName[err-1] != '\\') {
        // append a backslash separator if needed.  The "-1" is because the function returns
        // a count of chars (not including the NULL terminator).  We subtract
        // one to convert the 1-based count to a 0-based index.
        strcat(pszDllName, "\\");
    }
    strcat(pszDllName, lpFileName);


    //
    // Load the DLL
    //
    hDll = LoadLibraryA(pszDllName);

exit:

    if (pszDllName) {
        ldapFree(pszDllName, LDAP_ANSI_SIGNATURE);
    }


    return hDll;
}


// util.cxx eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\netmon_parser\ldap.c ===
//==========================================================================================================================
//  MODULE: LDAP.c
//
//  Description: Lightweight Directory Access Protocol (LDAP) Parser
//
//  Bloodhound parser for LDAP, in the xxxx DLL
//                                                                                                                 
//  Note: info for this parser was gleaned from:
//  rfc 1777, March 1995
//  recommendation x.209 BER for ASN.1
//  recommendation x.208 ASN.1
//  draft-ietf-asid-ladpv3-protocol-05    <06/05/97>
//
//  Modification History                                                                                           
//                                                                                                                 
//  Arthur Brooking     05/08/96        Created from GRE Parser
//  Peter  Oakley       06/29/97        Updated for LDAP version 3
//==========================================================================================================================
                    
#include "LDAP.h"
#include <netmon.h>

//======== Globals
HPROTOCOL hLDAP = NULL;

// Define the entry points that we will pass back at dll entry time...
ENTRYPOINTS LDAPEntryPoints =
{
    // LDAP Entry Points
    LDAPRegister,
    LDAPDeregister,
    LDAPRecognizeFrame,
    LDAPAttachProperties,
    LDAPFormatProperties
};

//==========================================================================================================================
//  FUNCTION: LDAPRegister()
//
//  Modification History
//
//  Arthur Brooking     03/05/94        Created from GRE Parser
//==========================================================================================================================
void BHAPI LDAPRegister(HPROTOCOL hLDAP)
{
    WORD i;
    DWORD_PTR   res;

    res = CreatePropertyDatabase(hLDAP, nNumLDAPProps);

    #ifdef DEBUG
    if (res != NMERR_SUCCESS)
    {
        dprintf("LDAP Parser failed CreateProperty");
        BreakPoint();
    }
    #endif

    for (i = 0; i < nNumLDAPProps; i++)
    {
        res = AddProperty(hLDAP,&LDAPPropertyTable[i]);

        #ifdef DEBUG
        if (res == NULL)
        {
            dprintf("LDAP Parser failed AddProperty %d", i);
            BreakPoint();
        }
        #endif
    }
}



//==========================================================================================================================
//  FUNCTION: LDAPDeregister()
//
//  Modification History
//
//  Arthur Brooking     03/05/94        Created from GRE Parser
//==========================================================================================================================

VOID WINAPI LDAPDeregister(HPROTOCOL hLDAP)
{
    DestroyPropertyDatabase(hLDAP);
}


//==========================================================================================================================
//  FUNCTION: LDAPRecognizeFrame()
//
//  Modification History
//
//  Arthur Brooking     03/05/94        Created from GRE Parser
//==========================================================================================================================

LPBYTE BHAPI LDAPRecognizeFrame(  HFRAME      hFrame,                //... frame handle.
                                 ULPBYTE     lpMacFrame,              //... frame pointer.
                                 ULPBYTE     lpLDAPFrame,              //... relative pointer.
                                 DWORD       MacType,               //... MAC type.
                                 DWORD       BytesLeft,             //... Bytes left.
                                 HPROTOCOL   hPrevProtocol,         //... Handle of Previous Protocol
                                 DWORD       nPrevProtOffset,       //... Offset of Previous protocol
                                 LPDWORD     lpProtocolStatus,      //... Recognized/Not/Next Protocol
                                 LPHPROTOCOL lphNextProtocol,       //... Pointer to next offset to be called
                                 PDWORD_PTR  InstData)              //... Instance data to be passed to next
                                                                    //... Protocol
{
   
    DWORD DataLength;
    DWORD HeaderLength = 0;
    BYTE  Tag;
    
    //
    // Check for the initial sequence tag and if that's not found look
    // for a signature.
    //
    if( (0x30 != GetTag(lpLDAPFrame)) &&
        ((BytesLeft <= 3)              ||
        (FALSE == LdapParseSig(hFrame, &lpLDAPFrame, &BytesLeft, FALSE))))
    {
        *lpProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
        return NULL;
    }
    lpLDAPFrame++;
    DataLength = GetLength(lpLDAPFrame,&HeaderLength);
    lpLDAPFrame += HeaderLength;
   
    //make sure that the message ID is good
    // and make sure that the identifier is 0x02 (univeral, primative, tag=0x02=integer)
    if( GetTag(lpLDAPFrame) != 0x02 )
    {
        // the message ID did not check out
        *lpProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
        return NULL;
    }

    *lpProtocolStatus = PROTOCOL_STATUS_CLAIMED;
    return NULL;
}

//==========================================================================================================================
//  FUNCTION: LDAPAttachProperties()
//
//  Modification History
//
//  Arthur Brooking     03/05/94        Created from GRE Parser
//==========================================================================================================================

LPBYTE BHAPI LDAPAttachProperties(  HFRAME      hFrame,                //... frame handle.
                                   ULPBYTE     lpMacFrame,              //... frame pointer.
                                   ULPBYTE     lpLDAPFrame,          //... relative pointer.
                                   DWORD       MacType,               //... MAC type.
                                   DWORD       BytesLeft,             //... Bytes left.
                                   HPROTOCOL   hPrevProtocol,         //... Handle of Previous Protocol
                                   DWORD       nPrevProtOffset,       //... Offset of Previous protocol
                                   DWORD_PTR       InstData)              //... Instance data to be passed to next

{
    ULPBYTE pCurrent = lpLDAPFrame;
    DWORD  HeaderLength;
    DWORD  DataLength;
    BYTE   Tag;
    DWORD  dwTmpBytesLeft = 0;



    // attach summary
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_SUMMARY].hProperty,
                            (WORD)BytesLeft,
                            pCurrent,
                            0, 0, 0);

    if (0x30 != GetTag(pCurrent)) {
        LdapParseSig(hFrame, &pCurrent, &dwTmpBytesLeft, TRUE);

    }

    while( (long)BytesLeft > 0 )
    {
        // starting sequence
        Tag = GetTag(pCurrent);
        pCurrent += TAG_LENGTH;
        DataLength = GetLength(pCurrent,&HeaderLength);
        pCurrent += HeaderLength;
        BytesLeft -= HeaderLength+TAG_LENGTH;
       
        // MessageID
        // integer
        Tag = GetTag(pCurrent);
        pCurrent += TAG_LENGTH;
        DataLength = GetLength(pCurrent,&HeaderLength);
        pCurrent += HeaderLength;
        BytesLeft -= HeaderLength+TAG_LENGTH;

        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_MESSAGE_ID].hProperty,
                                DataLength,
                                pCurrent,
                                0, 1, IFLAG_SWAPPED);
        pCurrent += DataLength;
        BytesLeft -= DataLength;

        // protocolOp
        Tag = GetTag(pCurrent);
        // we don't care what class or type this tag is, only its value
        Tag = Tag & TAG_MASK;
        
        // the tag will be 0x30 if this is a SearchResponseFull
        if( Tag == 0x30 )
        {
            // hack the data so that we look normal later
            Tag = LDAPP_PROTOCOL_OP_SEARCH_RESPONSE_FULL;
            
        }
        AttachPropertyInstanceEx( hFrame,
                                  LDAPPropertyTable[LDAPP_PROTOCOL_OP].hProperty,
                                  sizeof( BYTE ),
                                  pCurrent,
                                  sizeof(BYTE),
                                  &Tag,
                                  0, 1, 0);

        pCurrent += TAG_LENGTH;
        DataLength = GetLength(pCurrent, &HeaderLength);
        BytesLeft -= (HeaderLength + TAG_LENGTH);
        pCurrent += HeaderLength;
        // attach properties according to message type
        // the current position is the data portion of the 
        // main sequence.
      
        switch( Tag )
        {
            default:
            case LDAPP_PROTOCOL_OP_UNBIND_REQUEST:
                // no further properties
                break;

            case LDAPP_PROTOCOL_OP_BIND_RESPONSE:
                AttachLDAPBindResponse( hFrame,&pCurrent,&BytesLeft );
                break;

            case LDAPP_PROTOCOL_OP_SEARCH_RES_DONE:
            case LDAPP_PROTOCOL_OP_MODIFY_RESPONSE:
            case LDAPP_PROTOCOL_OP_ADD_RESPONSE:
            case LDAPP_PROTOCOL_OP_DEL_RESPONSE:
            case LDAPP_PROTOCOL_OP_MODIFY_RDN_RESPONSE:
            case LDAPP_PROTOCOL_OP_COMPARE_RESPONSE:
                AttachLDAPResult( hFrame, &pCurrent, &BytesLeft, 2);
                break;

            case LDAPP_PROTOCOL_OP_BIND_REQUEST:
                
                AttachLDAPBindRequest( hFrame, &pCurrent, &BytesLeft );
                break;

            case LDAPP_PROTOCOL_OP_SEARCH_REQUEST:
                AttachLDAPSearchRequest( hFrame, &pCurrent, &BytesLeft );
                break;

            case LDAPP_PROTOCOL_OP_SEARCH_RES_ENTRY:
            case LDAPP_PROTOCOL_OP_ADD_REQUEST:
                AttachLDAPSearchResponse( hFrame, &pCurrent, &BytesLeft, 2);
                break;

            case LDAPP_PROTOCOL_OP_MODIFY_REQUEST:
                AttachLDAPModifyRequest( hFrame, &pCurrent, &BytesLeft );
                break;
            
            case LDAPP_PROTOCOL_OP_DEL_REQUEST:
                pCurrent -= 2;
                BytesLeft += (HeaderLength);
                AttachLDAPDelRequest( hFrame, &pCurrent, &BytesLeft );
                break;

            case LDAPP_PROTOCOL_OP_MODIFY_RDN_REQUEST:
                AttachLDAPModifyRDNRequest( hFrame, &pCurrent, &BytesLeft );
                break;

            case LDAPP_PROTOCOL_OP_COMPARE_REQUEST:
                AttachLDAPCompareRequest( hFrame, &pCurrent, &BytesLeft );
                break;

            case LDAPP_PROTOCOL_OP_ABANDON_REQUEST:
                AttachLDAPAbandonRequest( hFrame, &pCurrent, &BytesLeft );
        
                break;

            case LDAPP_PROTOCOL_OP_SEARCH_RES_REFERENCE:
                AttachLDAPSearchResponseReference( hFrame, &pCurrent, &BytesLeft, 2);
                break;

            case LDAPP_PROTOCOL_OP_SEARCH_RESPONSE_FULL:
                AttachLDAPSearchResponseFull( hFrame, &pCurrent, &BytesLeft );
                break;

            case LDAPP_PROTOCOL_OP_EXTENDED_REQUEST:
                AttachLDAPExtendedRequest( hFrame, &pCurrent, &BytesLeft, DataLength );
                break;
            case LDAPP_PROTOCOL_OP_EXTENDED_RESPONSE:
                AttachLDAPExtendedResponse( hFrame, &pCurrent, &BytesLeft, DataLength );
                break;
        }
        // look for optional controls
        AttachLDAPOptionalControls( hFrame, &pCurrent, &BytesLeft );
    };

    return NULL;
};

//==========================================================================================================================
//  FUNCTION: FormatLDAPSum()
//
//  Modification History
//
//  Arthur Brooking     03/05/94        Created from GRE Parser
//==========================================================================================================================
VOID WINAPIV FormatLDAPSum(LPPROPERTYINST lpProp )
{
    ULPBYTE  pCurrent;
    LPBYTE   s;

    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;
    LPBYTE szProtOp;
    DWORD  BytesLeft;

    // I like to fill in variables seperate from their declaration 
    pCurrent  = lpProp->lpByte;
    BytesLeft = lpProp->DataLength;
    s         = lpProp->szPropertyText;

    if (0x30 != GetTag(pCurrent)) {
        LdapParseSig(NULL, &pCurrent, &BytesLeft, FALSE);
    }

    // dig in and grab the ProtocolOp...
    // skip the sequence
    Tag = GetTag(pCurrent);
    pCurrent += TAG_LENGTH;
    DataLength = GetLength(pCurrent, &HeaderLength);
    pCurrent += HeaderLength;
    
    
    // skip the 
    Tag = GetTag(pCurrent);
    pCurrent += TAG_LENGTH;
    DataLength = GetLength(pCurrent, &HeaderLength);
    pCurrent += (HeaderLength + DataLength);
    

    // grab the ProtocolOp
    Tag = GetTag(pCurrent) & TAG_MASK;
    pCurrent += TAG_LENGTH;
    DataLength = GetLength(pCurrent, &HeaderLength);
    pCurrent += (HeaderLength + DataLength);
   
    
    if( Tag == 0x30 )
    {
        szProtOp  = LookupByteSetString( &LDAPProtocolOPsSET, 
                        LDAPP_PROTOCOL_OP_SEARCH_RESPONSE_FULL );
        wsprintf( s, "ProtocolOp: %s", szProtOp);
        return;
    }
    szProtOp  = LookupByteSetString( &LDAPProtocolOPsSET, Tag );

    // fill in the string
    wsprintf( s, "ProtocolOp: %s (%d)",
              szProtOp, Tag );
}

//==========================================================================================================================
//  FUNCTION: LDAPFormatProperties()
//
//  Modification History
//
//  Arthur Brooking     03/05/94        Created from GRE Parser
//==========================================================================================================================
typedef VOID (WINAPIV *FORMATPROC)(LPPROPERTYINST);

DWORD BHAPI LDAPFormatProperties( HFRAME          hFrame,
                                  ULPBYTE         MacFrame,
                                  ULPBYTE         ProtocolFrame,
                                  DWORD           nPropertyInsts,
                                  LPPROPERTYINST  p)
{
    while(nPropertyInsts--)
    {
        ((FORMATPROC)p->lpPropertyInfo->InstanceData)(p);
        p++;
    }

    return(NMERR_SUCCESS);
}

BOOL LdapParseSig(HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, BOOL bAttach)
{
    BYTE     Tag;
    BOOL     fRecognized = FALSE;
    DWORD    DataLength;
    DWORD    HeaderLength;
    ULPBYTE  pSignature = *ppCurrent;

    // Skip over the 4 byte SASL length field.
    *ppCurrent += 4;
    *pBytesLeft -= 4;

    // Check for a SASL signature
    Tag = GetTag(*ppCurrent);
    (*ppCurrent)++; (*pBytesLeft)--;

    if (0x30 == Tag) {
        // This is probably a signed frame with the signature at the end.
        fRecognized = TRUE;
    } else if ((0x60 == Tag) && (*pBytesLeft > 46)) {
        // Check to see if this is a kerb signature at the beginning
        // See RFC's 2743 secction 3.1 and RFC 1964
        DataLength = GetLength(*ppCurrent, &HeaderLength);

        *ppCurrent += HeaderLength; *pBytesLeft -= HeaderLength;

        if ((*pBytesLeft) < 32) {
            goto exit;
        }

        Tag = GetTag(*ppCurrent);
        if (0x06 != Tag) {
            goto exit;
        }
        (*ppCurrent)++; (*pBytesLeft)--;

        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += DataLength + HeaderLength + 32;
        *pBytesLeft -= DataLength + HeaderLength + 32;

        if ((*pBytesLeft) <= 1) {
            goto exit;
        }
        if (0x30 == GetTag(*ppCurrent)) {
            fRecognized = TRUE;
        }
    }

    if (fRecognized && bAttach) {
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_SASL_SIG].hProperty,
                                (DWORD)((*ppCurrent) - pSignature),
                                pSignature,
                                0, 1, 0);
    }

exit:

    return fRecognized;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\netmon_parser\ldap.h ===
//=================================================================================================================
//  MODULE: ldap.h
//                                                                                                                 
//  Description: Lightweight Directory Access Protocol (LDAP) Parser
//
//  Bloodhound parser for LDAP, in the xxxx DLL
//                                                                                                                 
//  Note: info for this parser was gleaned from:
//  rfc 1777, March 1995
//  recommendation x.209 BER for ASN.1
//  recommendation x.208 ASN.1
//  draft-ietf-asid-ladpv3-protocol-05    <06/05/97>
//
//  Modification History                                                                                           
//                                                                                                                 
//  Arthur Brooking     05/08/96        Created from GRE Parser
//  Peter  Oakley       06/29/97        Updated for LDAP version 3
//=================================================================================================================
#ifndef _LDAP_H_
#define _LDAP_H_

#include <windows.h>
#include <ctype.h>
#include <netmon.h>
#include <stdlib.h>
#include <string.h>
#include <winldap.h>
#include <ntldap.h>
#include <winber.h>

typedef struct LDAPOID {
    unsigned int    length;
    unsigned char   *value;
} LDAPOID;
    
typedef
void
(* PATTACHFUNC)(
    IN     HFRAME hFrame,
    IN OUT ULPBYTE * ppCurrent,
    IN OUT LPDWORD pBytesLeft,
    IN     DWORD cbCtrlValue
    );

typedef struct OIDATTACHENTRY {
    LDAPOID      Oid;
    DWORD        LabelId;
    PATTACHFUNC  pAttachFunction;
} OIDATTACHENTRY;

// macro
#define LEVEL(level) ((level<14)?level:14)
#define DEFINE_LDAP_STRING(x)  {(sizeof(x)-1),(PUCHAR)x}


//=================================================================================================================
// Globals
//=================================================================================================================
// in LDAP.C
extern HPROTOCOL   hLDAP;
extern ENTRYPOINTS LDAPEntryPoints;

// in LDAPDATA.C
extern SET          LDAPProtocolOPsSET;
extern SET          LDAPResultCodesSET;
extern SET          LDAPAuthenticationTypesSET;
extern SET          LDAPOperationsSET;
extern SET          LDAPScopesSET;
extern SET          LDAPDerefAliasesSET;
extern SET          LDAPLimitsSET;
extern SET          LDAPFilterTypesSET;
extern SET          LDAPSDControlValsSET;
extern SET          LDAPDirSyncFlagsSET;
extern SET          LDAPSearchOptsSET;
extern PROPERTYINFO LDAPPropertyTable[];
extern DWORD        nNumLDAPProps;
extern OIDATTACHENTRY  KnownControls[];
extern DWORD        nNumKnownControls;
extern OIDATTACHENTRY  KnownExtendedRequests[];
extern DWORD        nNumKnownExtendedRequests;
extern OIDATTACHENTRY  KnownExtendedResponses[];
extern DWORD        nNumKnownExtendedResponses;
extern OIDATTACHENTRY  KnownMatchingRules[];
extern DWORD        nNumKnownMatchingRules;


//=================================================================================================================
// Constants
//=================================================================================================================
// PROPERTY ORDINALS                
#define LDAPP_SUMMARY                           0
#define LDAPP_MESSAGE_ID                        1
#define LDAPP_PROTOCOL_OP                       2
#define LDAPP_RESULT_CODE                       3
#define LDAPP_MATCHED_DN                        4
#define LDAPP_ERROR_MESSAGE                     5
#define LDAPP_VERSION                           6
#define LDAPP_NAME                              7
#define LDAPP_AUTHENTICATION_TYPE               8
#define LDAPP_AUTHENTICATION                    9
#define LDAPP_OBJECT_NAME                      10
#define LDAPP_ATTRIBUTE_TYPE                   11
#define LDAPP_ATTRIBUTE_VALUE                  12
#define LDAPP_OPERATION                        13
#define LDAPP_NEW_RDN                          14
#define LDAPP_BASE_OBJECT                      15
#define LDAPP_SCOPE                            16
#define LDAPP_DEREF_ALIASES                    17
#define LDAPP_SIZE_LIMIT                       18
#define LDAPP_TIME_LIMIT                       19
#define LDAPP_ATTRS_ONLY                       20
#define LDAPP_FILTER_TYPE                      21
#define LDAPP_SUBSTRING_INITIAL                22
#define LDAPP_SUBSTRING_ANY                    23
#define LDAPP_SUBSTRING_FINAL                  24
#define LDAPP_REFERRAL_SERVER                  25   
#define LDAPP_SASL_MECHANISM                   26
#define LDAPP_SASL_CREDENTIALS                 27 
#define LDAPP_DELETE_OLD_RDN                   28
#define LDAPP_NEW_SUPERIOR                     29
#define LDAPP_REQUEST_NAME                     30
#define LDAPP_REQUEST_VALUE                    31
#define LDAPP_RESPONSE_NAME                    32
#define LDAPP_RESPONSE_VALUE                   33
#define LDAPP_DN_ATTRIBUTES                    34
#define LDAPP_CONTROL_TYPE                     35
#define LDAPP_CRITICALITY                      36
#define LDAPP_CONTROL_VALUE                    37
#define LDAPP_CONTROL_PAGED                    38
#define LDAPP_CONTROL_PAGED_SIZE               39
#define LDAPP_CONTROL_PAGED_COOKIE             40
#define LDAPP_ATTR_DESCR_LIST                  41
#define LDAPP_FILTER                           42
#define LDAPP_CONTROLS                         43
#define LDAPP_CONTROL_VLVREQ                   44
#define LDAPP_CONTROL_VLVREQ_BCOUNT            45
#define LDAPP_CONTROL_VLVREQ_ACOUNT            46
#define LDAPP_CONTROL_VLVREQ_OFFSET            47
#define LDAPP_CONTROL_VLV_CONTENTCOUNT         48
#define LDAPP_CONTROL_VLVREQ_GE                49
#define LDAPP_CONTROL_VLV_CONTEXT              50
#define LDAPP_CONTROL_VLVRESP_TARGETPOS        51
#define LDAPP_CONTROL_VLVRESP_RESCODE          52
#define LDAPP_CONTROL_VLVRESP                  53
#define LDAPP_CONTROL_SORTREQ                  54
#define LDAPP_CONTROL_SORTREQ_ATTRTYPE         55
#define LDAPP_CONTROL_SORTREQ_MATCHINGRULE     56
#define LDAPP_CONTROL_SORTREQ_REVERSE          57
#define LDAPP_CONTROL_SORTRESP                 58
#define LDAPP_CONTROL_SORTRESP_RESCODE         59
#define LDAPP_CONTROL_SORTRESP_ATTRTYPE        60
#define LDAPP_CONTROL_SD                       61
#define LDAPP_CONTROL_SD_VAL                   62
#define LDAPP_CONTROL_SHOWDELETED              63
#define LDAPP_CONTROL_TREEDELETE               64
#define LDAPP_CONTROL_EXTENDEDDN               65
#define LDAPP_CONTROL_LAZYCOMMIT               66
#define LDAPP_CONTROL_NOTIFY                   67
#define LDAPP_CONTROL_DOMAINSCOPE              68
#define LDAPP_CONTROL_PERMISSIVEMOD            69
#define LDAPP_CONTROL_ASQ                      70
#define LDAPP_CONTROL_ASQ_SRCATTR              71
#define LDAPP_CONTROL_ASQ_RESCODE              72
#define LDAPP_CONTROL_DIRSYNC                  73
#define LDAPP_CONTROL_DIRSYNC_FLAGS            74
#define LDAPP_CONTROL_DIRSYNC_SIZE             75
#define LDAPP_CONTROL_DIRSYNC_COOKIE           76
#define LDAPP_CONTROL_CROSSDOM                 77
#define LDAPP_CONTROL_CROSSDOM_NAME            78
#define LDAPP_CONTROL_STAT                     79
#define LDAPP_CONTROL_STAT_FLAG                80
#define LDAPP_CONTROL_STAT_THREADCOUNT         81
#define LDAPP_CONTROL_STAT_CORETIME            82
#define LDAPP_CONTROL_STAT_CALLTIME            83
#define LDAPP_CONTROL_STAT_SUBSEARCHOPS        84
#define LDAPP_CONTROL_STAT_ENTRIES_RETURNED    85
#define LDAPP_CONTROL_STAT_ENTRIES_VISITED     86
#define LDAPP_CONTROL_STAT_FILTER              87
#define LDAPP_CONTROL_STAT_INDEXES             88
#define LDAPP_CONTROL_GCVERIFYNAME             89
#define LDAPP_CONTROL_GCVERIFYNAME_FLAGS       90
#define LDAPP_CONTROL_GCVERIFYNAME_NAME        91
#define LDAPP_CONTROL_SEARCHOPTS               92
#define LDAPP_CONTROL_SEARCHOPTS_OPTION        93
#define LDAPP_EXT_RESP_NOTICE_OF_DISCONNECT    94
#define LDAPP_EXT_RESP_TLS                     95
#define LDAPP_EXT_RESP_TTL                     96
#define LDAPP_EXT_RESP_TTL_TIME                97
#define LDAPP_EXT_REQ_TLS                      98
#define LDAPP_EXT_REQ_TTL                      99
#define LDAPP_EXT_REQ_TTL_ENTRYNAME           100
#define LDAPP_EXT_REQ_TTL_TIME                101
#define LDAPP_MATCHING_RULE                   102
#define LDAPP_MATCHINGRULE_BIT_AND            103
#define LDAPP_MATCHINGRULE_BIT_OR             104
#define LDAPP_SASL_SIG                        105

// Operation defines
#define LDAPP_PROTOCOL_OP_BIND_REQUEST             0
#define LDAPP_PROTOCOL_OP_BIND_RESPONSE            1
#define LDAPP_PROTOCOL_OP_UNBIND_REQUEST           2
#define LDAPP_PROTOCOL_OP_SEARCH_REQUEST           3
#define LDAPP_PROTOCOL_OP_SEARCH_RES_ENTRY         4
#define LDAPP_PROTOCOL_OP_SEARCH_RES_DONE          5
#define LDAPP_PROTOCOL_OP_MODIFY_REQUEST           6
#define LDAPP_PROTOCOL_OP_MODIFY_RESPONSE          7
#define LDAPP_PROTOCOL_OP_ADD_REQUEST              8
#define LDAPP_PROTOCOL_OP_ADD_RESPONSE             9
#define LDAPP_PROTOCOL_OP_DEL_REQUEST             10
#define LDAPP_PROTOCOL_OP_DEL_RESPONSE            11
#define LDAPP_PROTOCOL_OP_MODIFY_RDN_REQUEST      12
#define LDAPP_PROTOCOL_OP_MODIFY_RDN_RESPONSE     13
#define LDAPP_PROTOCOL_OP_COMPARE_REQUEST         14
#define LDAPP_PROTOCOL_OP_COMPARE_RESPONSE        15
#define LDAPP_PROTOCOL_OP_ABANDON_REQUEST         16
#define LDAPP_PROTOCOL_OP_EXTENDED_REQUEST        23
#define LDAPP_PROTOCOL_OP_EXTENDED_RESPONSE       24
#define LDAPP_PROTOCOL_OP_SEARCH_RES_REFERENCE    19
#define LDAPP_PROTOCOL_OP_SEARCH_RESPONSE_FULL    ((BYTE)-1)

// result code defines                             
#define LDAPP_RESULT_CODE_SUCCESS                         0
#define LDAPP_RESULT_CODE_OPERATIONS_ERROR                1
#define LDAPP_RESULT_CODE_PROTOCOL_ERROR                  2
#define LDAPP_RESULT_CODE_TIME_LIMIT_EXCEEDED             3
#define LDAPP_RESULT_CODE_SIZE_LIMIT_EXCEEDED             4
#define LDAPP_RESULT_CODE_COMPARE_FALSE                   5
#define LDAPP_RESULT_CODE_COMPARE_TRUE                    6
#define LDAPP_RESULT_CODE_AUTH_METHOD_NOT_SUPPORTED       7
#define LDAPP_RESULT_CODE_STRONG_AUTH_REQUIRED            8
#define LDAPP_RESULT_CODE_REFERRAL                       10
#define LDAPP_RESULT_CODE_ADMIN_LIMIT_EXCEEDED           11
#define LDAPP_RESULT_CODE_UNAVAILABLE_CRITICAL_EXTENSION 12
#define LDAPP_RESULT_CODE_CONFIDENTIALITY_REQUIRED       13
#define LDAPP_RESULT_CODE_SASL_BIND_IN_PROGRESS          14
#define LDAPP_RESULT_CODE_NO_SUCH_ATTRIBUTE              16
#define LDAPP_RESULT_CODE_UNDEFINED_ATTRIBUTE_TYPE       17
#define LDAPP_RESULT_CODE_INAPPROPRIATE_MATCHING         18
#define LDAPP_RESULT_CODE_CONSTRAINT_VIOLATION           19
#define LDAPP_RESULT_CODE_ATTRIBUTE_OR_VALUE_EXISTS      20
#define LDAPP_RESULT_CODE_INVALID_ATTRIBUTE_SYNTAX       21
#define LDAPP_RESULT_CODE_NO_SUCH_OBJECT                 32
#define LDAPP_RESULT_CODE_ALIAS_PROBLEM                  33
#define LDAPP_RESULT_CODE_INVALID_DN_SYNTAX              34
#define LDAPP_RESULT_CODE_IS_LEAF                        35
#define LDAPP_RESULT_CODE_ALIAS_DEREFERENCING_PROBLEM    36
#define LDAPP_RESULT_CODE_INAPPROPRIATE_AUTHENTICATION   48
#define LDAPP_RESULT_CODE_INVALID_CREDENTIALS            49
#define LDAPP_RESULT_CODE_INSUFFICIENT_ACCESS_RIGHTS     50
#define LDAPP_RESULT_CODE_BUSY                           51
#define LDAPP_RESULT_CODE_UNAVAILABLE                    52
#define LDAPP_RESULT_CODE_UNWILLING_TO_PERFORM           53
#define LDAPP_RESULT_CODE_LOOP_DETECT                    54

#define LDAPP_RESULT_CODE_SORT_CONTROL_MISSING           60
#define LDAPP_RESULT_CODE_INDEX_RANGE_ERROR              61
#define LDAPP_RESULT_CODE_NAMING_VIOLATION               64
#define LDAPP_RESULT_CODE_OBJECT_CLASS_VIOLATION         65

#define LDAPP_RESULT_CODE_NOT_ALLOWED_ON_LEAF            66
#define LDAPP_RESULT_CODE_NOT_ALLOWED_ON_RDN             67
#define LDAPP_RESULT_CODE_ENTRY_ALREADY_EXISTS           68
#define LDAPP_RESULT_CODE_OBJECT_CLASS_MODS_PROHIBITED   69
#define LDAPP_RESULT_CODE_RESULTS_TOO_LARGE              70
#define LDAPP_RESULT_CODE_AFFECTS_MULTIPLE_DSAS          71
#define LDAPP_RESULT_CODE_CONTROL_ERROR                  76
#define LDAPP_RESULT_CODE_OTHER                          80

// authentication types
#define LDAPP_AUTHENTICATION_TYPE_SIMPLE      0
#define LDAPP_AUTHENTICATION_TYPE_KRBV42LDAP  1
#define LDAPP_AUTHENTICATION_TYPE_KRBV42DSA   2
#define LDAPP_AUTHENTICATION_TYPE_SASL        3

// Operations
#define LDAPP_OPERATION_ADD     0
#define LDAPP_OPERATION_DELETE  1
#define LDAPP_OPERATION_REPLACE 2
 
// Scopes
#define LDAPP_SCOPE_BASE_OBJECT      0
#define LDAPP_SCOPE_SINGLE_LEVEL     1
#define LDAPP_SCOPE_WHOLE_SUBTREE    2

// Deref Aliases
#define LDAPP_DEREF_ALIASES_NEVER            0
#define LDAPP_DEREF_ALIASES_IN_SEARCHING     1
#define LDAPP_DEREF_ALIASES_FINDING_BASE_OBJ 2
#define LDAPP_DEREF_ALIASES_ALWAYS           3

// size and time limits
#define LDAPP_LIMITS_NONE 0

// Request optional fields
#define LDAPP_EX_REQ_NAME   0
#define LDAPP_EX_REQ_VALUE  1

// Result optional fields
#define LDAPP_RESULT_REFERRAL       3
#define LDAPP_RESULT_SASL_CRED      7
#define LDAPP_RESULT_EX_RES_NAME    10
#define LDAPP_RESULT_EX_RES_VALUE   11

// filter types
#define LDAPP_FILTER_TYPE_AND                0
#define LDAPP_FILTER_TYPE_OR                 1
#define LDAPP_FILTER_TYPE_NOT                2
#define LDAPP_FILTER_TYPE_EQUALITY_MATCH     3
#define LDAPP_FILTER_TYPE_SUBSTRINGS         4
#define LDAPP_FILTER_TYPE_GREATER_OR_EQUAL   5
#define LDAPP_FILTER_TYPE_LESS_OR_EQUAL      6
#define LDAPP_FILTER_TYPE_PRESENT            7
#define LDAPP_FILTER_TYPE_APPROX_MATCH       8
#define LDAPP_FILTER_TYPE_EXTENSIBLE_MATCH   9

// extended filter types
#define LDAPP_FILTER_EX_MATCHING_RULE    1
#define LDAPP_FILTER_EX_TYPE             2
#define LDAPP_FILTER_EX_VALUE            3
#define LDAPP_FILTER_EX_ATTRIBUTES       4

// substring types
#define LDAPP_SUBSTRING_CHOICE_INITIAL  0
#define LDAPP_SUBSTRING_CHOICE_ANY      1
#define LDAPP_SUBSTRING_CHOICE_FINAL    2

// controls type
#define LDAPP_CONTROLS_TAG     0

// Boolean Values
#define LDAPP_BOOLEAN_TRUE  0xFF
#define LDAPP_BOOLEAN_FALSE 0

// some BER imports --------------------

#define TAG_MASK        0x1f
#define BER_FORM_MASK       0x20
#define BER_CLASS_MASK      0xc0

// forms
#define BER_FORM_PRIMATIVE          0x00
#define BER_FORM_CONSTRUCTED        0x20

// classes
#define BER_CLASS_UNIVERSAL         0x00
#define BER_CLASS_APPLICATION       0x40    
#define BER_CLASS_CONTEXT_SPECIFIC  0x80

// Standard BER tags    
#define BER_TAG_INVALID         0x00
#define BER_TAG_BOOLEAN         0x01
#define BER_TAG_INTEGER         0x02
#define BER_TAG_BITSTRING       0x03
#define BER_TAG_OCTETSTRING     0x04
#define BER_TAG_NULL            0x05
#define BER_TAG_ENUMERATED      0x0a
#define BER_TAG_SEQUENCE        0x30
#define BER_TAG_SET             0x31

#define TAG_LENGTH              1

// ---------------------------------------

// control special extensions
#define LDAPP_CTRL_NONE      0
#define LDAPP_CTRL_PAGED     1

// vlv control related
#define LDAPP_VLV_REQ_BYOFFSET_TAG 0

// sort control related
#define LDAPP_SORT_REQ_ORDERINGRULE_TAG 0
#define LDAPP_SORT_REQ_REVERSEORDER_TAG 1

#define LDAPP_SORT_RESP_ATTRTYPE_TAG    0

// stat control related
#define LDAPP_SO_NORMAL        0
#define LDAPP_SO_STATS         1
#define LDAPP_SO_ONLY_OPTIMIZE 2

enum LDAPP_STAT_TYPE {
    STAT_THREADCOUNT = 1,
    STAT_CORETIME = 2,
    STAT_CALLTIME = 3,
    STAT_SUBSRCHOP = 4,
    STAT_ENTRIES_RETURNED = 5,
    STAT_ENTRIES_VISITED = 6,
    STAT_FILTER = 7,
    STAT_INDEXES = 8,
    STAT_NUM_STATS = 8
};

//
// Private controls
//

#define LDAPP_SERVER_GET_STATS_OID           "1.2.840.113556.1.4.970"


//
// Extended Request/Response related
//

#define LDAPP_EXT_REQ_TTL_DN_TAG        0
#define LDAPP_EXT_REQ_TTL_TIME_TAG      1

#define LDAPP_EXT_RESP_TTL_TIME_TAG     1

//=================================================================================================================
// Functions
//=================================================================================================================
// in LDAP-Tags.c
extern BYTE GetTag( ULPBYTE pCurrent );
extern DWORD GetLength( ULPBYTE pInitialPointer, DWORD * LenLen);
extern LONG GetInt(ULPBYTE pCurrent, DWORD Length);
extern BOOL AreOidsEqual(IN LDAPOID *String1, IN LDAPOID *String2);

// in LDAP.C
extern VOID   WINAPI LDAPRegister(HPROTOCOL hLDAP);
extern VOID   WINAPI LDAPDeregister(HPROTOCOL hLDAP);
extern LPBYTE WINAPI LDAPRecognizeFrame(HFRAME, LPVOID, LPVOID, DWORD, DWORD, HPROTOCOL, DWORD, LPDWORD, LPHPROTOCOL, PDWORD_PTR);
extern LPBYTE WINAPI LDAPAttachProperties(HFRAME, LPVOID, ULPBYTE, DWORD, DWORD, HPROTOCOL, DWORD, DWORD_PTR);
extern DWORD  WINAPI LDAPFormatProperties(HFRAME hFrame, ULPBYTE MacFrame, ULPBYTE ProtocolFrame, DWORD nPropertyInsts, LPPROPERTYINST p);
extern VOID WINAPIV FormatLDAPSum(LPPROPERTYINST lpProp );
extern BOOL LdapParseSig(HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, BOOL bAttach);

// in LDAPP_ATT.C
extern void AttachLDAPResult( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD Level);
extern void AttachLDAPBindRequest( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft);
extern void AttachLDAPBindResponse( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft);
extern void AttachLDAPSearchRequest( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft);
extern void AttachLDAPSearchResponse( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD Level);
extern void AttachLDAPModifyRequest( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft);
extern void AttachLDAPDelRequest( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft);
extern void AttachLDAPModifyRDNRequest( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft);
extern void AttachLDAPCompareRequest( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft);
extern void AttachLDAPAbandonRequest( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft);
extern void AttachLDAPFilter( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD Level);
extern void AttachLDAPSearchResponseReference( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD Level);
extern void AttachLDAPSearchResponseFull( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft);
extern void AttachLDAPExtendedRequest( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD ReqSize);
extern void AttachLDAPExtendedReqValTTL( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbReqValue);
extern void AttachLDAPExtendedResponse( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD RespSize);
extern void AttachLDAPExtendedRespValTTL( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbRespValue);
extern void AttachLDAPOptionalControls( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft);
extern void AttachLDAPControl( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft);
extern void AttachLDAPControlValPaged( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValVLVReq( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValVLVResp( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValSortReq( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValSortResp( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValSD( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValASQ( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValDirSync( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValCrossDomMove( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValStats( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValGCVerify( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);
extern void AttachLDAPControlValSearchOpts( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\client\win9x.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    win9x.cxx

Abstract:

   This module implements Win9x wrappers for Unicode security APIs


Author:

    Srinivasan Chandrasekar (srinivac)  20-Feb-1999

Revision History:

--*/

#include "precomp.h"
#include "ldapp2.hxx"
#pragma hdrstop

//
// Forward declarations
//
SECURITY_STATUS SEC_ENTRY Win9xEnumerateSecurityPackages(
    unsigned long SEC_FAR * pcPackages,
    PSecPkgInfoW SEC_FAR * ppPackageInfo
    );

SECURITY_STATUS SEC_ENTRY Win9xQueryCredentialsAttributes(
    PCredHandle phCredential,
    unsigned long ulAttribute,
    void SEC_FAR * pBuffer
    );

SECURITY_STATUS SEC_ENTRY
Win9xAcquireCredentialsHandle(
    SEC_WCHAR SEC_FAR * pszPrincipal,
    SEC_WCHAR SEC_FAR * pszPackage,
    unsigned long fCredentialUse,
    void SEC_FAR * pvLogonId,
    void SEC_FAR * pAuthData,
    SEC_GET_KEY_FN pGetKeyFn,
    void SEC_FAR * pvGetKeyArgument,
    PCredHandle phCredential,
    PTimeStamp ptsExpiry
    );

SECURITY_STATUS SEC_ENTRY
Win9xInitializeSecurityContext(
    PCredHandle phCredential,
    PCtxtHandle phContext,
    SEC_WCHAR SEC_FAR * pszTargetName,
    unsigned long fContextReq,
    unsigned long Reserved1,
    unsigned long TargetDataRep,
    PSecBufferDesc pInput,
    unsigned long Reserved2,
    PCtxtHandle phNewContext,
    PSecBufferDesc pOutput,
    unsigned long SEC_FAR * pfContextAttr,
    PTimeStamp ptsExpiry
    );

SECURITY_STATUS SEC_ENTRY
Win9xQueryContextAttributes(
    PCtxtHandle phContext,
    unsigned long ulAttribute,
    void SEC_FAR * pBuffer
    );

SECURITY_STATUS SEC_ENTRY
Win9xQuerySecurityPackageInfo(
    SEC_WCHAR SEC_FAR * pszPackageName,
    PSecPkgInfoW SEC_FAR *ppPackageInfo
    );

SECURITY_STATUS SEC_ENTRY
Win9xImportSecurityContext(
    SEC_WCHAR SEC_FAR *  pszPackage,
    PSecBuffer           pPackedContext,
    void SEC_FAR *       Token,
    PCtxtHandle          phContext
    );

BOOL ConvertPackagesToUnicode(
    PSecPkgInfoA pPackageInfoA,
    DWORD  cbNumPackages
    );

SECURITY_STATUS SEC_ENTRY Win9xSslEnumerateSecurityPackages(
    unsigned long SEC_FAR * pcPackages,
    PSecPkgInfoW SEC_FAR * ppPackageInfo
    );

SECURITY_STATUS SEC_ENTRY Win9xSslQueryCredentialsAttributes(
    PCredHandle phCredential,
    unsigned long ulAttribute,
    void SEC_FAR * pBuffer
    );

SECURITY_STATUS SEC_ENTRY
Win9xSslAcquireCredentialsHandle(
    SEC_WCHAR SEC_FAR * pszPrincipal,
    SEC_WCHAR SEC_FAR * pszPackage,
    unsigned long fCredentialUse,
    void SEC_FAR * pvLogonId,
    void SEC_FAR * pAuthData,
    SEC_GET_KEY_FN pGetKeyFn,
    void SEC_FAR * pvGetKeyArgument,
    PCredHandle phCredential,
    PTimeStamp ptsExpiry
    );

SECURITY_STATUS SEC_ENTRY
Win9xSslInitializeSecurityContext(
    PCredHandle phCredential,
    PCtxtHandle phContext,
    SEC_WCHAR SEC_FAR * pszTargetName,
    unsigned long fContextReq,
    unsigned long Reserved1,
    unsigned long TargetDataRep,
    PSecBufferDesc pInput,
    unsigned long Reserved2,
    PCtxtHandle phNewContext,
    PSecBufferDesc pOutput,
    unsigned long SEC_FAR * pfContextAttr,
    PTimeStamp ptsExpiry
    );

SECURITY_STATUS SEC_ENTRY
Win9xSslQuerySecurityPackageInfo(
    SEC_WCHAR SEC_FAR * pszPackageName,
    PSecPkgInfoW SEC_FAR *ppPackageInfo
    );

SECURITY_STATUS SEC_ENTRY
Win9xSslImportSecurityContext(
    SEC_WCHAR SEC_FAR *  pszPackage,
    PSecBuffer           pPackedContext,
    void SEC_FAR *       Token,
    PCtxtHandle          phContext
    );

//
// Global function table that maps to our conversion functions
//
SecurityFunctionTableW   UnicodeSecurityFunctionTable;
SecurityFunctionTableW   UnicodeSslFunctionTable;

PSecurityFunctionTableW Win9xSspiInitialize(
    void
    )
{
    FSECINITSECURITYINTERFACEA  pSspiInitializeA;

    ASSERT(pSspiInitialize);

    //
    // The global function pointer actually points to an ANSI function
    // In Win9x. We'll cast in call into it.
    //
    pSspiInitializeA = (FSECINITSECURITYINTERFACEA)pSspiInitialize;

    SspiFunctionTableA = (*pSspiInitializeA)();

    if (! SspiFunctionTableA)
    {
        //
        // The caller will take apropriate action
        //
        return NULL;
    }

    //
    // Now construct a Unicode function table and return it to the caller
    //
    UnicodeSecurityFunctionTable.dwVersion = SspiFunctionTableA->dwVersion;

    UnicodeSecurityFunctionTable.EnumerateSecurityPackagesW =
            (ENUMERATE_SECURITY_PACKAGES_FN_W)Win9xEnumerateSecurityPackages;

    UnicodeSecurityFunctionTable.QueryCredentialsAttributesW =
            (QUERY_CREDENTIALS_ATTRIBUTES_FN_W)Win9xQueryCredentialsAttributes;

    UnicodeSecurityFunctionTable.AcquireCredentialsHandleW =
            (ACQUIRE_CREDENTIALS_HANDLE_FN_W)Win9xAcquireCredentialsHandle;

    UnicodeSecurityFunctionTable.FreeCredentialsHandle =
            SspiFunctionTableA->FreeCredentialsHandle;

    UnicodeSecurityFunctionTable.InitializeSecurityContextW =
            (INITIALIZE_SECURITY_CONTEXT_FN_W)Win9xInitializeSecurityContext;

    UnicodeSecurityFunctionTable.AcceptSecurityContext =
            SspiFunctionTableA->AcceptSecurityContext;

    UnicodeSecurityFunctionTable.CompleteAuthToken =
            SspiFunctionTableA->CompleteAuthToken;

    UnicodeSecurityFunctionTable.DeleteSecurityContext =
            SspiFunctionTableA->DeleteSecurityContext;

    UnicodeSecurityFunctionTable.ApplyControlToken =
            SspiFunctionTableA->ApplyControlToken;

    UnicodeSecurityFunctionTable.QueryContextAttributesW =
            (QUERY_CONTEXT_ATTRIBUTES_FN_W)Win9xQueryContextAttributes;

    UnicodeSecurityFunctionTable.ImpersonateSecurityContext =
            SspiFunctionTableA->ImpersonateSecurityContext;

    UnicodeSecurityFunctionTable.RevertSecurityContext =
            SspiFunctionTableA->RevertSecurityContext;

    UnicodeSecurityFunctionTable.MakeSignature =
            SspiFunctionTableA->MakeSignature;

    UnicodeSecurityFunctionTable.VerifySignature =
            SspiFunctionTableA->VerifySignature;

    UnicodeSecurityFunctionTable.FreeContextBuffer =
            SspiFunctionTableA->FreeContextBuffer;

    UnicodeSecurityFunctionTable.QuerySecurityPackageInfoW =
            (QUERY_SECURITY_PACKAGE_INFO_FN_W)Win9xQuerySecurityPackageInfo;

    UnicodeSecurityFunctionTable.ExportSecurityContext =
            SspiFunctionTableA->ExportSecurityContext;

    UnicodeSecurityFunctionTable.ImportSecurityContextW =
            (IMPORT_SECURITY_CONTEXT_FN_W)Win9xImportSecurityContext;

    UnicodeSecurityFunctionTable.QuerySecurityContextToken =
            SspiFunctionTableA->QuerySecurityContextToken;

    UnicodeSecurityFunctionTable.EncryptMessage =
            (ENCRYPT_MESSAGE_FN) SspiFunctionTableA->Reserved3;

    UnicodeSecurityFunctionTable.DecryptMessage =
            (DECRYPT_MESSAGE_FN) SspiFunctionTableA->Reserved4;

    return (PSecurityFunctionTableW) &UnicodeSecurityFunctionTable;
}

//
// Function table wrapper functions for Win9x
//

SECURITY_STATUS SEC_ENTRY Win9xEnumerateSecurityPackages(
    unsigned long SEC_FAR * pcPackages,     // Receives num. packages
    PSecPkgInfoW SEC_FAR * ppPackageInfo    // Receives array of info
    )
{
    PSecPkgInfoA  pPackageInfoA = NULL;
    SECURITY_STATUS rc;

    //
    // Call Ansi function
    //
    ASSERT(SspiFunctionTableA);
    ASSERT(SspiFunctionTableA->EnumerateSecurityPackagesA);

    rc = SspiFunctionTableA->EnumerateSecurityPackagesA(
                                pcPackages,
                                &pPackageInfoA);

    if (rc != SEC_E_OK)
        goto error;

    //
    // Convert returned values to Unicode
    //
    if (!ConvertPackagesToUnicode(pPackageInfoA, *pcPackages))
    {
        rc = SEC_E_INSUFFICIENT_MEMORY;
        goto error;
    }

    *ppPackageInfo = (PSecPkgInfoW)pPackageInfoA;
    pPackageInfoA = NULL;

error:
    //
    // Clean up and leave
    //
    if (pPackageInfoA)
        SspiFunctionTableA->FreeContextBuffer((void*)pPackageInfoA);

    return rc;
}


SECURITY_STATUS SEC_ENTRY Win9xQueryCredentialsAttributes(
    PCredHandle phCredential,           // Credential to query
    unsigned long ulAttribute,          // Attribute to query
    void SEC_FAR * pBuffer              // Buffer for attributes
    )
{
    //
    // This function is not used by us
    //


    ASSERT(FALSE);
    return SEC_E_UNSUPPORTED_FUNCTION;
}

SECURITY_STATUS SEC_ENTRY
Win9xAcquireCredentialsHandle(
    SEC_WCHAR SEC_FAR * pszPrincipal,   // Name of principal
    SEC_WCHAR SEC_FAR * pszPackage,     // Name of package
    unsigned long fCredentialUse,       // Flags indicating use
    void SEC_FAR * pvLogonId,           // Pointer to logon ID
    void SEC_FAR * pAuthData,           // Package specific data
    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey()
    PCredHandle phCredential,           // (out) Cred Handle
    PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    )
{
    SEC_CHAR  *pszPrincipalA = NULL;
    SEC_CHAR  *pszPackageA = NULL;
    ULONG err;
    SECURITY_STATUS rc = SEC_E_INSUFFICIENT_MEMORY;

    //
    // Convert parameters to Ansi
    //
    err = FromUnicodeWithAlloc(pszPrincipal,
                               &pszPrincipalA,
                               LDAP_ANSI_SIGNATURE,
                               LANG_ACP);
    if (err != LDAP_SUCCESS)
        goto error;

    err = FromUnicodeWithAlloc(pszPackage,
                               &pszPackageA,
                               LDAP_ANSI_SIGNATURE,
                               LANG_ACP);
    if (err != LDAP_SUCCESS)
        goto error;

    //
    // Call Ansi function
    //
    ASSERT(SspiFunctionTableA);
    ASSERT(SspiFunctionTableA->AcquireCredentialsHandleA);

    rc = SspiFunctionTableA->AcquireCredentialsHandleA(
                                    pszPrincipalA,
                                    pszPackageA,
                                    fCredentialUse,
                                    pvLogonId,
                                    pAuthData,
                                    pGetKeyFn,
                                    pvGetKeyArgument,
                                    phCredential,
                                    ptsExpiry);

error:
    //
    // Clean up and leave
    //
    if (pszPrincipalA)
        ldapFree(pszPrincipalA, LDAP_ANSI_SIGNATURE);

    if (pszPackageA)
        ldapFree(pszPackageA, LDAP_ANSI_SIGNATURE);

    return rc;
}


SECURITY_STATUS SEC_ENTRY
Win9xInitializeSecurityContext(
    PCredHandle phCredential,               // Cred to base context
    PCtxtHandle phContext,                  // Existing context (OPT)
    SEC_WCHAR SEC_FAR * pszTargetName,      // Name of target
    unsigned long fContextReq,              // Context Requirements
    unsigned long Reserved1,                // Reserved, MBZ
    unsigned long TargetDataRep,            // Data rep of target
    PSecBufferDesc pInput,                  // Input Buffers
    unsigned long Reserved2,                // Reserved, MBZ
    PCtxtHandle phNewContext,               // (out) New Context handle
    PSecBufferDesc pOutput,                 // (inout) Output Buffers
    unsigned long SEC_FAR * pfContextAttr,  // (out) Context attrs
    PTimeStamp ptsExpiry                    // (out) Life span (OPT)
    )
{
    PSTR pszTargetNameA = NULL;
    ULONG err;
    SECURITY_STATUS rc = SEC_E_INSUFFICIENT_MEMORY;

    //
    // Convert parameters to Ansi
    //
    err = FromUnicodeWithAlloc(pszTargetName,
                               &pszTargetNameA,
                               LDAP_ANSI_SIGNATURE,
                               LANG_ACP);
    if (err != LDAP_SUCCESS)
        goto error;

    //
    // Call Ansi function
    //
    ASSERT(SspiFunctionTableA);
    ASSERT(SspiFunctionTableA->InitializeSecurityContextA);

    rc = SspiFunctionTableA->InitializeSecurityContextA(
                                    phCredential,
                                    phContext,
                                    pszTargetNameA,
                                    fContextReq,
                                    Reserved1,
                                    TargetDataRep,
                                    pInput,
                                    Reserved2,
                                    phNewContext,
                                    pOutput,
                                    pfContextAttr,
                                    ptsExpiry);

error:
    //
    // Clean up and leave
    //
    if (pszTargetNameA)
        ldapFree((void*)pszTargetNameA, LDAP_ANSI_SIGNATURE);

    return rc;
}


SECURITY_STATUS SEC_ENTRY
Win9xQueryContextAttributes(
    PCtxtHandle phContext,              // Context to query
    unsigned long ulAttribute,          // Attribute to query
    void SEC_FAR * pBuffer              // Buffer for attributes
    )
{
    //
    // Call Ansi function
    //
    ASSERT(FALSE);
    return SEC_E_UNSUPPORTED_FUNCTION;
}

SECURITY_STATUS SEC_ENTRY
Win9xQuerySecurityPackageInfo(
    SEC_WCHAR SEC_FAR * pszPackageName,     // Name of package
    PSecPkgInfoW SEC_FAR *ppPackageInfo     // Receives package info
    )
{
    //
    // This function is not used by us
    //
    ASSERT(FALSE);
    return SEC_E_UNSUPPORTED_FUNCTION;
}


SECURITY_STATUS SEC_ENTRY
Win9xImportSecurityContext(
    SEC_WCHAR SEC_FAR *  pszPackage,
    PSecBuffer           pPackedContext,        // (in) marshalled context
    void SEC_FAR *       Token,                 // (in, optional) handle to token for context
    PCtxtHandle          phContext              // (out) new context handle
    )
{
    //
    // This function is not used by us
    //
    ASSERT(FALSE);
    return SEC_E_UNSUPPORTED_FUNCTION;
}

BOOL
ConvertPackagesToUnicode(
    PSecPkgInfoA pPackageInfoA,
    DWORD  cbNumPackages
    )
{
    DWORD i;
    ULONG err;
    BOOL  rc = FALSE;

    //
    //  Note that the memory we are allocating here gets freed only when wldap32
    //  gets unloaded. This is not serious since this gets called only once,
    //  for about half a dozen security packages.
    //
    for (i = 0; i < cbNumPackages; i++)
    {
        err = ToUnicodeWithAlloc(pPackageInfoA->Name,
                                 -1,
                                 (PWSTR*)&pPackageInfoA->Name,
                                 LDAP_UNICODE_SIGNATURE,
                                 LANG_ACP);
        if (err != LDAP_SUCCESS)
            goto error;

        err = ToUnicodeWithAlloc(pPackageInfoA->Comment,
                                 -1,
                                 (PWSTR*)&pPackageInfoA->Comment,
                                 LDAP_UNICODE_SIGNATURE,
                                 LANG_ACP);
        if (err != LDAP_SUCCESS)
            goto error;

        pPackageInfoA++;
    }

    rc = TRUE;

error:
    return rc;
}


// ------------

PSecurityFunctionTableW Win9xSslInitialize(
    void
    )
{
    FSECINITSECURITYINTERFACEA  pSslInitializeA;

    ASSERT(pSslInitialize);

    //
    // The global function pointer actually points to an ANSI function
    // In Win9x. We'll cast in call into it.
    //
    pSslInitializeA = (FSECINITSECURITYINTERFACEA)pSslInitialize;

    SslFunctionTableA = (*pSslInitializeA)();

    if (! SslFunctionTableA)
    {
        //
        // The caller will take apropriate action
        //
        return NULL;
    }

    //
    // Now construct a Unicode function table and return it to the caller
    //
    UnicodeSslFunctionTable.dwVersion = SslFunctionTableA->dwVersion;

    UnicodeSslFunctionTable.EnumerateSecurityPackagesW =
            (ENUMERATE_SECURITY_PACKAGES_FN_W)Win9xSslEnumerateSecurityPackages;

    UnicodeSslFunctionTable.QueryCredentialsAttributesW =
            (QUERY_CREDENTIALS_ATTRIBUTES_FN_W)Win9xSslQueryCredentialsAttributes;

    UnicodeSslFunctionTable.AcquireCredentialsHandleW =
            (ACQUIRE_CREDENTIALS_HANDLE_FN_W)Win9xSslAcquireCredentialsHandle;

    UnicodeSslFunctionTable.FreeCredentialsHandle =
            SslFunctionTableA->FreeCredentialsHandle;

    UnicodeSslFunctionTable.InitializeSecurityContextW =
            (INITIALIZE_SECURITY_CONTEXT_FN_W)Win9xSslInitializeSecurityContext;

    UnicodeSslFunctionTable.AcceptSecurityContext =
            SslFunctionTableA->AcceptSecurityContext;

    UnicodeSslFunctionTable.CompleteAuthToken =
            SslFunctionTableA->CompleteAuthToken;

    UnicodeSslFunctionTable.DeleteSecurityContext =
            SslFunctionTableA->DeleteSecurityContext;

    UnicodeSslFunctionTable.ApplyControlToken =
            SslFunctionTableA->ApplyControlToken;

    UnicodeSslFunctionTable.QueryContextAttributesW =
            SslFunctionTableA->QueryContextAttributes;

    UnicodeSslFunctionTable.ImpersonateSecurityContext =
            SslFunctionTableA->ImpersonateSecurityContext;

    UnicodeSslFunctionTable.RevertSecurityContext =
            SslFunctionTableA->RevertSecurityContext;

    UnicodeSslFunctionTable.MakeSignature =
            SslFunctionTableA->MakeSignature;

    UnicodeSslFunctionTable.VerifySignature =
            SslFunctionTableA->VerifySignature;

    UnicodeSslFunctionTable.FreeContextBuffer =
            SslFunctionTableA->FreeContextBuffer;

    UnicodeSslFunctionTable.QuerySecurityPackageInfoW =
            (QUERY_SECURITY_PACKAGE_INFO_FN_W)Win9xSslQuerySecurityPackageInfo;

    UnicodeSslFunctionTable.ExportSecurityContext =
            SslFunctionTableA->ExportSecurityContext;

    UnicodeSslFunctionTable.ImportSecurityContextW =
            (IMPORT_SECURITY_CONTEXT_FN_W)Win9xSslImportSecurityContext;

    UnicodeSslFunctionTable.QuerySecurityContextToken =
            SslFunctionTableA->QuerySecurityContextToken;

    UnicodeSslFunctionTable.EncryptMessage =
            (ENCRYPT_MESSAGE_FN) SslFunctionTableA->Reserved3;

    UnicodeSslFunctionTable.DecryptMessage =
            (DECRYPT_MESSAGE_FN) SslFunctionTableA->Reserved4;

    return (PSecurityFunctionTableW) &UnicodeSslFunctionTable;
}


SECURITY_STATUS SEC_ENTRY Win9xSslEnumerateSecurityPackages(
    unsigned long SEC_FAR * pcPackages,     // Receives num. packages
    PSecPkgInfoW SEC_FAR * ppPackageInfo    // Receives array of info
    )
{
    PSecPkgInfoA  pPackageInfoA = NULL;
    SECURITY_STATUS rc;

    //
    // Call Ansi function
    //
    ASSERT(SslFunctionTableA);
    ASSERT(SslFunctionTableA->EnumerateSecurityPackagesA);

    rc = SslFunctionTableA->EnumerateSecurityPackagesA(
                                pcPackages,
                                &pPackageInfoA);

    if (rc != SEC_E_OK)
        goto error;

    //
    // Convert returned values to Unicode
    //
    if (!ConvertPackagesToUnicode(pPackageInfoA, *pcPackages))
    {
        rc = SEC_E_INSUFFICIENT_MEMORY;
        goto error;
    }

    *ppPackageInfo = (PSecPkgInfoW)pPackageInfoA;
    pPackageInfoA = NULL;

error:
    //
    // Clean up and leave
    //
    if (pPackageInfoA)
        SslFunctionTableA->FreeContextBuffer((void*)pPackageInfoA);

    return rc;
}


SECURITY_STATUS SEC_ENTRY Win9xSslQueryCredentialsAttributes(
    PCredHandle phCredential,           // Credential to query
    unsigned long ulAttribute,          // Attribute to query
    void SEC_FAR * pBuffer              // Buffer for attributes
    )
{
    //
    // This function is not used by us
    //
    ASSERT(FALSE);
    return SEC_E_UNSUPPORTED_FUNCTION;
}

SECURITY_STATUS SEC_ENTRY
Win9xSslAcquireCredentialsHandle(
    SEC_WCHAR SEC_FAR * pszPrincipal,   // Name of principal
    SEC_WCHAR SEC_FAR * pszPackage,     // Name of package
    unsigned long fCredentialUse,       // Flags indicating use
    void SEC_FAR * pvLogonId,           // Pointer to logon ID
    void SEC_FAR * pAuthData,           // Package specific data
    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey()
    PCredHandle phCredential,           // (out) Cred Handle
    PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    )
{
    SEC_CHAR  *pszPrincipalA = NULL;
    SEC_CHAR  *pszPackageA = NULL;
    ULONG err;
    SECURITY_STATUS rc = SEC_E_INSUFFICIENT_MEMORY;

    //
    // Convert parameters to Ansi
    //
    err = FromUnicodeWithAlloc(pszPrincipal,
                               &pszPrincipalA,
                               LDAP_ANSI_SIGNATURE,
                               LANG_ACP);
    if (err != LDAP_SUCCESS)
        goto error;

    err = FromUnicodeWithAlloc(pszPackage,
                               &pszPackageA,
                               LDAP_ANSI_SIGNATURE,
                               LANG_ACP);
    if (err != LDAP_SUCCESS)
        goto error;

    //
    // Call Ansi function
    //
    ASSERT(SslFunctionTableA);
    ASSERT(SslFunctionTableA->AcquireCredentialsHandleA);

    rc = SslFunctionTableA->AcquireCredentialsHandleA(
                                    pszPrincipalA,
                                    pszPackageA,
                                    fCredentialUse,
                                    pvLogonId,
                                    pAuthData,
                                    pGetKeyFn,
                                    pvGetKeyArgument,
                                    phCredential,
                                    ptsExpiry);

error:
    //
    // Clean up and leave
    //
    if (pszPrincipalA)
        ldapFree(pszPrincipalA, LDAP_ANSI_SIGNATURE);

    if (pszPackageA)
        ldapFree(pszPackageA, LDAP_ANSI_SIGNATURE);

    return rc;
}


SECURITY_STATUS SEC_ENTRY
Win9xSslInitializeSecurityContext(
    PCredHandle phCredential,               // Cred to base context
    PCtxtHandle phContext,                  // Existing context (OPT)
    SEC_WCHAR SEC_FAR * pszTargetName,      // Name of target
    unsigned long fContextReq,              // Context Requirements
    unsigned long Reserved1,                // Reserved, MBZ
    unsigned long TargetDataRep,            // Data rep of target
    PSecBufferDesc pInput,                  // Input Buffers
    unsigned long Reserved2,                // Reserved, MBZ
    PCtxtHandle phNewContext,               // (out) New Context handle
    PSecBufferDesc pOutput,                 // (inout) Output Buffers
    unsigned long SEC_FAR * pfContextAttr,  // (out) Context attrs
    PTimeStamp ptsExpiry                    // (out) Life span (OPT)
    )
{
    PSTR pszTargetNameA = NULL;
    ULONG err;
    SECURITY_STATUS rc = SEC_E_INSUFFICIENT_MEMORY;

    //
    // Convert parameters to Ansi
    //
    err = FromUnicodeWithAlloc(pszTargetName,
                               &pszTargetNameA,
                               LDAP_ANSI_SIGNATURE,
                               LANG_ACP);
    if (err != LDAP_SUCCESS)
        goto error;

    //
    // Call Ansi function
    //
    ASSERT(SslFunctionTableA);
    ASSERT(SslFunctionTableA->InitializeSecurityContextA);

    rc = SslFunctionTableA->InitializeSecurityContextA(
                                    phCredential,
                                    phContext,
                                    pszTargetNameA,
                                    fContextReq,
                                    Reserved1,
                                    TargetDataRep,
                                    pInput,
                                    Reserved2,
                                    phNewContext,
                                    pOutput,
                                    pfContextAttr,
                                    ptsExpiry);

error:
    //
    // Clean up and leave
    //
    if (pszTargetNameA)
        ldapFree((void*)pszTargetNameA, LDAP_ANSI_SIGNATURE);

    return rc;
}

SECURITY_STATUS SEC_ENTRY
Win9xSslQuerySecurityPackageInfo(
    SEC_WCHAR SEC_FAR * pszPackageName,     // Name of package
    PSecPkgInfoW SEC_FAR *ppPackageInfo     // Receives package info
    )
{
    //
    // This function is not used by us
    //
    ASSERT(FALSE);
    return SEC_E_UNSUPPORTED_FUNCTION;
}


SECURITY_STATUS SEC_ENTRY
Win9xSslImportSecurityContext(
    SEC_WCHAR SEC_FAR *  pszPackage,
    PSecBuffer           pPackedContext,        // (in) marshalled context
    void SEC_FAR *       Token,                 // (in, optional) handle to token for context
    PCtxtHandle          phContext              // (out) new context handle
    )
{
    //
    // This function is not used by us
    //
    ASSERT(FALSE);
    return SEC_E_UNSUPPORTED_FUNCTION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\netmon_parser\ldapdata.c ===
//=================================================================================================================
//  MODULE: ldapdata.c
//                                                                                                                 
//  Description: Data structures for the Lightweight Directory Access Protocol (LDAP) Parser
//
//  Bloodhound parser for LDAP
//                                                                                                                 
//  Note: info for this parser was gleaned from:
//  rfc 1777, March 1995
//  recommendation x.209 BER for ASN.1
//  recommendation x.208 ASN.1
//  draft-ietf-asid-ladpv3-protocol-05    <06/05/97>
//
//  Modification History                                                                                           
//                                                                                                                 
//  Arthur Brooking     05/08/96        Created from GRE Parser
//  Peter  Oakley       06/29/97        Added datatypes for LDAP version 3
//=================================================================================================================
#include "ldap.h"
#include "draatt.h"
    
// text for protocol types
LABELED_BYTE LDAPProtocolOPs[] =
{
    { LDAPP_PROTOCOL_OP_BIND_REQUEST,          "BindRequest"},      
    { LDAPP_PROTOCOL_OP_BIND_RESPONSE,         "BindResponse"},     
    { LDAPP_PROTOCOL_OP_UNBIND_REQUEST,        "UnbindRequest"},    
    { LDAPP_PROTOCOL_OP_SEARCH_REQUEST,        "SearchRequest"},    
    { LDAPP_PROTOCOL_OP_SEARCH_RES_ENTRY,      "SearchResponse"},   
    { LDAPP_PROTOCOL_OP_SEARCH_RES_DONE,       "SearchResponse (simple)"}, 
    { LDAPP_PROTOCOL_OP_SEARCH_RES_REFERENCE,  "SearchResponse Reference"},
    { LDAPP_PROTOCOL_OP_MODIFY_REQUEST,        "ModifyRequest"},    
    { LDAPP_PROTOCOL_OP_MODIFY_RESPONSE,       "ModifyResponse"},   
    { LDAPP_PROTOCOL_OP_ADD_REQUEST,           "AddRequest"},       
    { LDAPP_PROTOCOL_OP_ADD_RESPONSE,          "AddResponse"},      
    { LDAPP_PROTOCOL_OP_DEL_REQUEST,           "DelRequest"},       
    { LDAPP_PROTOCOL_OP_DEL_RESPONSE,          "DelResponse"},      
    { LDAPP_PROTOCOL_OP_MODIFY_RDN_REQUEST,    "ModifyDNRequest"}, 
    { LDAPP_PROTOCOL_OP_MODIFY_RDN_RESPONSE,   "ModifyDNResponse"},
    { LDAPP_PROTOCOL_OP_COMPARE_REQUEST,       "CompareRequest"},   
    { LDAPP_PROTOCOL_OP_COMPARE_RESPONSE,      "CompareResponse"},  
    { LDAPP_PROTOCOL_OP_ABANDON_REQUEST,       "AbandonRequest"},
    { LDAPP_PROTOCOL_OP_EXTENDED_REQUEST,      "ExtendedRequest"},
    { LDAPP_PROTOCOL_OP_EXTENDED_RESPONSE,     "ExtendedResponse"},
    { LDAPP_PROTOCOL_OP_SEARCH_RESPONSE_FULL,  "SearchResponseFull"}
};
SET LDAPProtocolOPsSET = {(sizeof(LDAPProtocolOPs)/sizeof(LABELED_BYTE)), LDAPProtocolOPs };

// text for result codes
LABELED_DWORD LDAPResultCodes[] =
{
    { LDAPP_RESULT_CODE_SUCCESS                          ,"Success"},      
    { LDAPP_RESULT_CODE_OPERATIONS_ERROR                 ,"Operations Error"},      
    { LDAPP_RESULT_CODE_PROTOCOL_ERROR                   ,"Protocol Error"},      
    { LDAPP_RESULT_CODE_TIME_LIMIT_EXCEEDED              ,"Time Limit Exceeded"},      
    { LDAPP_RESULT_CODE_SIZE_LIMIT_EXCEEDED              ,"Size Limit Exceeded"},      
    { LDAPP_RESULT_CODE_COMPARE_FALSE                    ,"Compare False"},      
    { LDAPP_RESULT_CODE_COMPARE_TRUE                     ,"Compare True"},      
    { LDAPP_RESULT_CODE_AUTH_METHOD_NOT_SUPPORTED        ,"Auth Method Not Supported"},      
    { LDAPP_RESULT_CODE_STRONG_AUTH_REQUIRED             ,"Strong Auth Required"},
    { LDAPP_RESULT_CODE_REFERRAL                         ,"Referral"},
    { LDAPP_RESULT_CODE_ADMIN_LIMIT_EXCEEDED             ,"Admin Limit Exceeded"},
    { LDAPP_RESULT_CODE_UNAVAILABLE_CRITICAL_EXTENSION   ,"Unavailable Critical Extension"},
    { LDAPP_RESULT_CODE_CONFIDENTIALITY_REQUIRED         ,"Confidentiality Required"},
    { LDAPP_RESULT_CODE_SASL_BIND_IN_PROGRESS            ,"Sasl Bind In Progress"},
    { LDAPP_RESULT_CODE_NO_SUCH_ATTRIBUTE                ,"No Such Attribute"},      
    { LDAPP_RESULT_CODE_UNDEFINED_ATTRIBUTE_TYPE         ,"Undefined Attribute Type"},      
    { LDAPP_RESULT_CODE_INAPPROPRIATE_MATCHING           ,"Inappropriate Matching"},      
    { LDAPP_RESULT_CODE_CONSTRAINT_VIOLATION             ,"Constraint Violation"},      
    { LDAPP_RESULT_CODE_ATTRIBUTE_OR_VALUE_EXISTS        ,"Attribute Or Value Exists"},      
    { LDAPP_RESULT_CODE_INVALID_ATTRIBUTE_SYNTAX         ,"Invalid Attribute Syntax"},      
    { LDAPP_RESULT_CODE_NO_SUCH_OBJECT                   ,"No Such Object"},      
    { LDAPP_RESULT_CODE_ALIAS_PROBLEM                    ,"Alias Problem"},      
    { LDAPP_RESULT_CODE_INVALID_DN_SYNTAX                ,"Invalid Dn Syntax"},      
    { LDAPP_RESULT_CODE_IS_LEAF                          ,"Is Leaf"},      
    { LDAPP_RESULT_CODE_ALIAS_DEREFERENCING_PROBLEM      ,"Alias Dereferencing Problem"},      
    { LDAPP_RESULT_CODE_INAPPROPRIATE_AUTHENTICATION     ,"Inappropriate Authentication"},      
    { LDAPP_RESULT_CODE_INVALID_CREDENTIALS              ,"Invalid Credentials"},      
    { LDAPP_RESULT_CODE_INSUFFICIENT_ACCESS_RIGHTS       ,"Insufficient Access Rights"},      
    { LDAPP_RESULT_CODE_BUSY                             ,"Busy"},    
    { LDAPP_RESULT_CODE_UNAVAILABLE                      ,"Unavailable"},
    { LDAPP_RESULT_CODE_UNWILLING_TO_PERFORM             ,"Unwilling to Perform"},
    { LDAPP_RESULT_CODE_SORT_CONTROL_MISSING             ,"Sort Control Missing"},
    { LDAPP_RESULT_CODE_INDEX_RANGE_ERROR                ,"Index Range Error"},
    { LDAPP_RESULT_CODE_NAMING_VIOLATION                 ,"Naming Violation"},
    { LDAPP_RESULT_CODE_OBJECT_CLASS_VIOLATION           ,"Object Class Violation"},
    { LDAPP_RESULT_CODE_LOOP_DETECT                      ,"Loop Detect"},
    { LDAPP_RESULT_CODE_NOT_ALLOWED_ON_LEAF              ,"Not Allowed on Leaf"},
    { LDAPP_RESULT_CODE_NOT_ALLOWED_ON_RDN               ,"Not Allowed on RDN"},
    { LDAPP_RESULT_CODE_ENTRY_ALREADY_EXISTS             ,"Entry Already Exists"},
    { LDAPP_RESULT_CODE_OBJECT_CLASS_MODS_PROHIBITED     ,"Object Class Mods Prohibited"},
    { LDAPP_RESULT_CODE_RESULTS_TOO_LARGE                ,"Results Too Large"},
    { LDAPP_RESULT_CODE_AFFECTS_MULTIPLE_DSAS            ,"Affects Multiple DSAs"},
    { LDAPP_RESULT_CODE_CONTROL_ERROR                    ,"Control Error"},
    { LDAPP_RESULT_CODE_OTHER                            ,"Other"},
};
SET LDAPResultCodesSET = {(sizeof(LDAPResultCodes)/sizeof(LABELED_DWORD)), LDAPResultCodes };

LABELED_BYTE LDAPAuthenticationTypes[] =
{
    { LDAPP_AUTHENTICATION_TYPE_SIMPLE    ,"Simple"},      
    { LDAPP_AUTHENTICATION_TYPE_KRBV42LDAP,"krbv42LDAP"},      
    { LDAPP_AUTHENTICATION_TYPE_KRBV42DSA ,"krbv42DSA"}, 
    { LDAPP_AUTHENTICATION_TYPE_SASL      ,"Sasl"},
};
SET LDAPAuthenticationTypesSET = {(sizeof(LDAPAuthenticationTypes)/sizeof(LABELED_BYTE)), LDAPAuthenticationTypes };

LABELED_DWORD LDAPOperations[] =
{
    { LDAPP_OPERATION_ADD    ,"Add"},      
    { LDAPP_OPERATION_DELETE ,"Delete"},      
    { LDAPP_OPERATION_REPLACE,"Replace"},      
};
SET LDAPOperationsSET = {(sizeof(LDAPOperations)/sizeof(LABELED_DWORD)), LDAPOperations };

LABELED_DWORD LDAPScopes[] =
{
    { LDAPP_SCOPE_BASE_OBJECT  ,"Base Object"},      
    { LDAPP_SCOPE_SINGLE_LEVEL ,"Single Level"},      
    { LDAPP_SCOPE_WHOLE_SUBTREE,"Whole Subtree"},      
};
SET LDAPScopesSET = {(sizeof(LDAPScopes)/sizeof(LABELED_DWORD)), LDAPScopes };

LABELED_DWORD LDAPDerefAliases[] =
{
    { LDAPP_DEREF_ALIASES_NEVER           ,"Never Deref Aliases"},      
    { LDAPP_DEREF_ALIASES_IN_SEARCHING    ,"Deref In Searching"},      
    { LDAPP_DEREF_ALIASES_FINDING_BASE_OBJ,"Deref Finding Base Objects"},      
    { LDAPP_DEREF_ALIASES_ALWAYS          ,"Always Deref Aliases"},      
};
SET LDAPDerefAliasesSET = {(sizeof(LDAPDerefAliases)/sizeof(LABELED_DWORD)), LDAPDerefAliases };

LABELED_DWORD LDAPLimits[] =
{
    { LDAPP_LIMITS_NONE ,"No Limit"},      
};
SET LDAPLimitsSET = {(sizeof(LDAPLimits)/sizeof(LABELED_DWORD)), LDAPLimits };

LABELED_BYTE LDAPFilterTypes[] =
{
    { LDAPP_FILTER_TYPE_AND             ,"And"},      
    { LDAPP_FILTER_TYPE_OR              ,"Or"},      
    { LDAPP_FILTER_TYPE_NOT             ,"Not"},      
    { LDAPP_FILTER_TYPE_EQUALITY_MATCH  ,"Equality Match"},      
    { LDAPP_FILTER_TYPE_SUBSTRINGS      ,"Substrings"},      
    { LDAPP_FILTER_TYPE_GREATER_OR_EQUAL,"Greater Or Equal"},      
    { LDAPP_FILTER_TYPE_LESS_OR_EQUAL   ,"Less Or Equal"},      
    { LDAPP_FILTER_TYPE_PRESENT         ,"Present"},      
    { LDAPP_FILTER_TYPE_APPROX_MATCH    ,"Approximate Match"},
    { LDAPP_FILTER_TYPE_EXTENSIBLE_MATCH ,"Extensible Match"},
};
SET LDAPFilterTypesSET = {(sizeof(LDAPFilterTypes)/sizeof(LABELED_BYTE)), LDAPFilterTypes };

LABELED_BYTE LDAPBoolean[] =
{
    { LDAPP_BOOLEAN_TRUE             ,"True"},      
    { LDAPP_BOOLEAN_FALSE            ,"False"},      
   
};
SET LDAPBooleanSET = {(sizeof(LDAPBoolean)/sizeof(LABELED_BYTE)), LDAPBoolean };

LABELED_DWORD LDAPSDControlVals[] =
{
    { OWNER_SECURITY_INFORMATION           ,"Owner"},      
    { GROUP_SECURITY_INFORMATION           ,"Group"},      
    { DACL_SECURITY_INFORMATION            ,"DACL"},      
    { SACL_SECURITY_INFORMATION            ,"SACL"},      
    { PROTECTED_DACL_SECURITY_INFORMATION  ,"Protected DACL"},      
    { PROTECTED_SACL_SECURITY_INFORMATION  ,"Protected SACL"},      
    { UNPROTECTED_DACL_SECURITY_INFORMATION,"Unprotected DACL"},      
    { UNPROTECTED_SACL_SECURITY_INFORMATION,"Unprotected SACL"},      
};
SET LDAPSDControlValsSET = {(sizeof(LDAPSDControlVals)/sizeof(LABELED_DWORD)), LDAPSDControlVals };

LABELED_DWORD LDAPStatFlags[] =
{
    { LDAPP_SO_NORMAL        ,"LDAPP_SO_NORMAL"},      
    { LDAPP_SO_STATS         ,"LDAPP_SO_STATS"},
    { LDAPP_SO_ONLY_OPTIMIZE ,"LDAPP_SO_ONLY_OPTIMIZE"},
};
SET LDAPStatFlagsSET = {(sizeof(LDAPStatFlags)/sizeof(LABELED_DWORD)), LDAPStatFlags };

LABELED_DWORD LDAPSearchOpts[] =
{
    { SERVER_SEARCH_FLAG_DOMAIN_SCOPE  ,"Domain Scope"},      
    { SERVER_SEARCH_FLAG_PHANTOM_ROOT  ,"Phantom Root"},
};
SET LDAPSearchOptsSET = {(sizeof(LDAPSearchOpts)/sizeof(LABELED_DWORD)), LDAPSearchOpts };

LABELED_DWORD LDAPDirSyncFlags[] =
{
    { DRS_DIRSYNC_PUBLIC_DATA_ONLY, "Public Data" },
    { DRS_DIRSYNC_INCREMENTAL_VALUES, "Incremental Values"},
    { DRS_DIRSYNC_OBJECT_SECURITY, "Object-level Security"},
    { DRS_DIRSYNC_ANCESTORS_FIRST_ORDER, "Include Ancestors"},
};
SET LDAPDirSyncFlagsSET = {(sizeof(LDAPDirSyncFlags)/sizeof(LABELED_DWORD)), LDAPDirSyncFlags };

// Properties
PROPERTYINFO    LDAPPropertyTable[] = 
{
    // LDAPP_SUMMARY 0
    { 0, 0,
      "Summary",
      "Summary of the LDAP Packet",
      PROP_TYPE_SUMMARY,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatLDAPSum
    },

    // LDAPP_MESSAGE_ID 1
    { 0, 0,
      "MessageID",
      "Message ID",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_PROTOCOL_OP 2
    { 0, 0,
      "ProtocolOp",
      "Gives the frame type",
      PROP_TYPE_BYTE,
      PROP_QUAL_LABELED_SET,
      &LDAPProtocolOPsSET,
      80,
      FormatPropertyInstance
    },

    // LDAPP_RESULT_CODE 3
    { 0, 0,
      "Result Code",
      "Status of the response",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPResultCodesSET,
      80,
      FormatPropertyInstance
    },

    // LDAPP_MATCHED_DN 4
    { 0, 0,
      "Matched DN",
      "Matched DN",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_ERROR_MESSAGE 5
    { 0, 0,
      "Error Message",
      "Error Message",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_VERSION 6
    { 0, 0,
      "Version",
      "Version",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_NAME 7
    { 0, 0,
      "Name",
      "null name implies anonymous bind",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_AUTHENTICATION_TYPE 8
    { 0, 0,
      "Authentication Type",
      "Authentication Type",
      PROP_TYPE_BYTE,
      PROP_QUAL_LABELED_SET,
      &LDAPAuthenticationTypesSET,
      80,
      FormatPropertyInstance
    },

    // LDAPP_AUTHENTICATION 9
    { 0, 0,
      "Authentication",
      "Authentication",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_OBJECT_NAME 10
    { 0, 0,
      "Object Name",
      "Object Name",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_ATTRIBUTE_TYPE 11
    { 0, 0,
      "Attribute Type",
      "Attribute Type",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_ATTRIBUTE_VALUE 12
    { 0, 0,
      "Attribute Value",
      "Attribute Value",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_OPERATION 13
    { 0, 0,
      "Operation",
      "Operation",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPOperationsSET,
      80,
      FormatPropertyInstance
    },

    // LDAPP_NEW_RDN 14
    { 0, 0,
      "New RDN",
      "New RDN",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_BASE_OBJECT 15
    { 0, 0,
      "Base Object",
      "Base Object",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_SCOPE 16
    { 0, 0,
      "Scope",
      "Scope",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPScopesSET,
      80,
      FormatPropertyInstance
    },

    // LDAPP_DEREF_ALIASES 17
    { 0, 0,
      "Deref Aliases",
      "Deref Aliases",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPDerefAliasesSET,
      80,
      FormatPropertyInstance
    },

    // LDAPP_SIZE_LIMIT 18
    { 0, 0,
      "Size Limit",
      "Size Limit",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPLimitsSET,
      80,
      FormatPropertyInstance
    },

    // Time Limit 19
    { 0, 0,
      "Time Limit",
      "Time Limit",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPLimitsSET,
      80,
      FormatPropertyInstance
    },

    // LDAPP_ATTRS_ONLY 20
    { 0, 0,
      "Attrs Only",
      "Attrs Only",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

    // LDAPP_FILTER_TYPE 21
    { 0, 0,
      "Filter Type",
      "Filter Type",
      PROP_TYPE_BYTE,
      PROP_QUAL_LABELED_SET,
      &LDAPFilterTypesSET,
      80,
      FormatPropertyInstance
    },

    // LDAPP_SUBSTRING_INITIAL 22
    { 0, 0,
      "Substring (Initial)",
      "Substring (Initial)",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_SUBSTRING_ANY 23
    { 0, 0,
      "Substring (Any)",
      "Substring (Any)",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_SUBSTRING_FINAL 24
    { 0, 0,
      "Substring (Final)",
      "Substring (Final)",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_REFERRAL_SERVER 25
    { 0, 0,
      "Referral Server",
      "Server",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

    // LDAPP_SASL_MECHANISM 26
    { 0, 0,
      "Sasl Mechanism",
      "Mechanism",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },
     
      // LDAPP_SASL_CREDENTIALS 27
    { 0, 0,
      "Sasl Credentials",
      "Credentials",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

      // LDAPP_DELETE_OLD_RDN 28
    { 0, 0,
      "Delete Old RDN",
      "Delete Old RDN",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

       // LDAPP_NEW_SUPERIOR 29
    { 0, 0,
      "New Superior",
      "New Superior",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },
       
       // LDAPP_REQUEST_NAME  30
    { 0, 0,
      "Request Name",
      "Request",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

       // LDAPP_REQUEST_VALUE  31
    { 0, 0,
      "Request Value",
      "Value",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

        // LDAPP_RESPONSE_NAME  32
    { 0, 0,
      "Response Name",
      "Name",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

       // LDAPP_RESPONSE_VALUE  33
    { 0, 0,
      "Response Value",
      "Value",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

        // LDAPP_DN_ATTRIBUTES 34
    { 0, 0,
      "dnAttributes",
      "dnAttributes",
      PROP_TYPE_BYTE,
      PROP_QUAL_LABELED_SET,
      &LDAPBooleanSET,
      80,
      FormatPropertyInstance
      },

        // LDAPP_CONTROL_TYPE 35
    { 0, 0,
      "Control Type",
      "Control Type",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

        // LDAPP_CRITICALITY 36
    { 0, 0,
      "Criticality",
      "Criticality",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

        // LDAPP_CONTROL_VALUE 37
    { 0, 0,
      "Control Value",
      "Control Value",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

            // LDAPP_CONTROL_PAGED 38
     { 0, 0,
      "Paged Control",
      "Paged Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },


            // LDAPP_CONTROL_PAGED_SIZE 39
    { 0, 0,
      "Page Size",
      "Size",
      PROP_TYPE_BYTE,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

            // LDAPP_CONTROL_PAGED_COOKIE 40
    { 0, 0,
      "Paged Cookie",
      "Paged Control Cookie",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },
       
            // LDAPP_ATTR_DESCR_LIST 41
    { 0, 0,
      "Attribute Description List",
      "Attribute Description List",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

            // LDAPP_FILTER 42
    { 0, 0,
      "Filter",
      "Filter",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

            // LDAPP_CONTROLS 43
    { 0, 0,
      "Controls",
      "Controls",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

            // LDAPP_CONTROL_VLVREQ 44
     { 0, 0,
      "VLV Request Control",
      "VLV Request Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },
    
     // LDAPP_CONTROL_VLVREQ_BCOUNT 45
    { 0, 0,
      "VLV Before Count",
      "VLV Request Before Count",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },
    
    // LDAPP_CONTROL_VLVREQ_ACOUNT 46
    { 0, 0,
      "VLV After Count",
      "VLV Request After Count",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

        // LDAPP_CONTROL_VLVREQ_OFFSET 47
    { 0, 0,
      "VLV Offset",
      "VLV Request Offset",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

        // LDAPP_CONTROL_VLV_CONTENTCOUNT 48
    { 0, 0,
      "VLV Content Count",
      "VLV ContentCount",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

        // LDAPP_CONTROL_VLVREQ_GE 49
    { 0, 0,
      "VLV Greater Than Or Equal To",
      "VLV Request greaterThanOrEqual",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

        // LDAPP_CONTROL_VLV_CONTEXT 50
    { 0, 0,
      "VLV ContextID",
      "VLV ContextID",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_VLVRESP_TARGETPOS 51
    { 0, 0,
      "VLV Target Position",
      "VLV Response Target Position",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

        // LDAPP_CONTROL_VLVRESP_RESCODE 52
    { 0, 0,
      "VLV Result Code",
      "VLV Response Result Code",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPResultCodesSET,
      80,
      FormatPropertyInstance
    },
            
        // LDAPP_CONTROL_VLVRESP 53
     { 0, 0,
      "VLV Response Control",
      "VLV Response Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

        // LDAPP_CONTROL_SORTREQ 54
     { 0, 0,
      "Sort Request Control",
      "Sort Request Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },
    
        // LDAPP_CONTROL_SORTREQ_ATTRTYPE 55
    { 0, 0,
      "Sort Request Attribute Type",
      "Sort Request Attribute Type",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },
        // LDAPP_CONTROL_SORTREQ_MATCHINGRULE 56
     { 0, 0,
      "Sort Matching Rule ID",
      "Sort Request Matching Rule ID",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

        // LDAPP_CONTROL_SORTREQ_REVERSE 57
    { 0, 0,
      "Sort Reverse Order",
      "Sort Request Reverse Order",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

        // LDAPP_CONTROL_SORTRESP 58
     { 0, 0,
      "Sort Response Control",
      "Sort Response Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
      },

        // LDAPP_CONTROL_SORTRESP_RESCODE 59
    { 0, 0,
      "Sort Result Code",
      "Sort Response Result Code",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPResultCodesSET,
      80,
      FormatPropertyInstance
    },

        // LDAPP_CONTROL_SORTRESP_ATTRTYPE 60
    { 0, 0,
      "Sort Response Attribute Type",
      "Sort Response Attribute Type",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_SD 61
    { 0, 0,
      "Security Descriptor Control",
      "Security Descriptor Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_SD_VAL 62
    { 0, 0,
      "SD Val",
      "Security Descriptor Control Values",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPSDControlValsSET,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_SHOWDELETED 63
    { 0, 0,
      "Show Deleted Objects Control",
      "Show Deleted Objects Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_TREEDELETE 64
    { 0, 0,
      "Tree Delete Control",
      "Tree Delete Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_EXTENDEDDN 65
    { 0, 0,
      "Extended DN Control",
      "Extended DN Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_LAZYCOMMIT 66
    { 0, 0,
      "Lazy Commit Control",
      "Lazy Commit Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_NOTIFY 67
    { 0, 0,
      "Notification Control",
      "Notification Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_DOMAINSCOPE 68
    { 0, 0,
      "Domain Scope Control",
      "Domain Scope Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_PERMISSIVEMOD 69
    { 0, 0,
      "Permissive Modify Control",
      "Permissive Modify Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_ASQ 70
    { 0, 0,
      "Attribute Scoped Query Control",
      "ASQ Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_ASQ_SRCATTR 71
    { 0, 0,
      "ASQ Source Attribute",
      "ASQ Source Attribute",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

        // LDAPP_CONTROL_ASQ_RESCODE 72
    { 0, 0,
      "ASQ Result Code",
      "ASQ Response Result Code",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPResultCodesSET,
      80,
      FormatPropertyInstance
    },
            
            // LDAPP_CONTROL_DIRSYNC 73
    { 0, 0,
      "DirSync Control",
      "DirSync Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

        // LDAPP_CONTROL_DIRSYNC_FLAGS 74
    { 0, 0,
      "DirSync Flags",
      "DirSync Flags",
      PROP_TYPE_DWORD,
      PROP_QUAL_LABELED_SET,
      &LDAPDirSyncFlagsSET,
      80,
      FormatPropertyInstance
    },
            
        // LDAPP_CONTROL_DIRSYNC_SIZE 75
    { 0, 0,
      "DirSync Size",
      "DirSync Size",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },
            
            // LDAPP_CONTROL_DIRSYNC_COOKIE 76
    { 0, 0,
      "DirSync Cookie",
      "DirSync Cookie",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_CROSSDOM 77
    { 0, 0,
      "Cross Domain Move Control",
      "Cross Domain Move Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_CROSSDOM_NAME 78
    { 0, 0,
      "CDM Target",
      "Cross Domain Move Control Target Server Field",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_STAT 79
    { 0, 0,
      "Server Stats Control",
      "Server Stats Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_STAT_FLAG 80
    { 0, 0,
      "Stat Flags",
      "Stat Flags",
      PROP_TYPE_DWORD,
      PROP_QUAL_LABELED_SET,
      &LDAPStatFlagsSET,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_STAT_THREADCOUNT 81
    { 0, 0,
      "Stat Threadcount",
      "Stat Threadcount",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_STAT_CORETIME 82
    { 0, 0,
      "Stat Core Time (ms)",
      "Stat Core Time in milliseconds",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_STAT_CALLTIME 83
    { 0, 0,
      "Stat Call Time (ms)",
      "Stat Call Time in milliseconds",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_STAT_SUBSEARCHOPS 84
    { 0, 0,
      "Stat Subsearch Ops",
      "Stat Subsearch Ops",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_STAT_ENTRIES_RETURNED 85
    { 0, 0,
      "Stat Entries Returned",
      "Stat Entries Returned",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_STAT_ENTRIES_VISITED 86
    { 0, 0,
      "Stat Entries Visited",
      "Stat Entries Visited",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_STAT_FILTER 87
    { 0, 0,
      "Stat Filter Used",
      "Stat Filter Used",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_STAT_INDEXES 88
    { 0, 0,
      "Stat Indexes Used",
      "Stat Indexes Used",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_GCVERIFYNAME 89
    { 0, 0,
      "GC Verify Name Control",
      "GC Verify Name Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_GCVERIFYNAME_FLAGS 90
    { 0, 0,
      "GCVerify Flags",
      "GC Verify Name Control Flags",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_GCVERIFYNAME_NAME 91
    { 0, 0,
      "GCVerify Server Name",
      "GC Verify Name Control Name",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_SEARCHOPTS 92
    { 0, 0,
      "Search Options Control",
      "Search Options Control",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_CONTROL_SEARCHOPTS_OPTION 93
    { 0, 0,
      "Search Option",
      "Search Option",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_LABELED_SET,
      &LDAPSearchOptsSET,
      80,
      FormatPropertyInstance
    },

            // LDAPP_EXT_RESP_NOTICE_OF_DISCONNECT 94
    { 0, 0,
      "Notice Of Disconnect",
      "Notice Of Disconnect",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_EXT_RESP_TLS 95
    { 0, 0,
      "TLS Response",
      "TLS Response",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_EXT_RESP_TTL 96
    { 0, 0,
      "TTL Response",
      "TTL Response",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_EXT_RESP_TTL_TIME 97
    { 0, 0,
      "TTL Response Time",
      "TTL Response Time",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_EXT_REQ_TLS 98
    { 0, 0,
      "TLS Request",
      "TLS Request",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_EXT_REQ_TTL 99
    { 0, 0,
      "TTL Request",
      "TTL Request",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_EXT_REQ_TTL_ENTRYNAME 100
    { 0, 0,
      "TTL Request Entry Name",
      "TTL Request Entry Name",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_EXT_REQ_TTL_TIME 101
    { 0, 0,
      "TTL Request Time",
      "TTL Request Time",
      PROP_TYPE_VAR_LEN_SMALL_INT,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_MATCHING_RULE 102
    { 0, 0,
      "Matching Rule",
      "Matching Rule",
      PROP_TYPE_STRING,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },

            // LDAPP_MATCHINGRULE_BIT_AND 103
    { 0, 0,
      "Bitwise AND",
      "Bitwise AND",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },
            
            // LDAPP_MATCHINGRULE_BIT_OR 104
    { 0, 0,
      "Bitwise OR",
      "Bitwise OR",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },
            
            // LDAPP_SASL_SIG 105
    { 0, 0,
      "SASL Signature",
      "SASL Signature",
      PROP_TYPE_VOID,
      PROP_QUAL_NONE,
      NULL,
      80,
      FormatPropertyInstance
    },
};
DWORD   nNumLDAPProps = (sizeof(LDAPPropertyTable)/sizeof(PROPERTYINFO));

#define LDAP_SERVER_GET_STATS_OID           "1.2.840.113556.1.4.970"

OIDATTACHENTRY KnownControls[] = {
    // Paged
    {
        DEFINE_LDAP_STRING(LDAP_PAGED_RESULT_OID_STRING),   // 319
        LDAPP_CONTROL_PAGED,
        AttachLDAPControlValPaged
    },

    // Security Descriptor
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_SD_FLAGS_OID),       // 801
        LDAPP_CONTROL_SD,
        AttachLDAPControlValSD
    },

    // Sort request
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_SORT_OID),           // 473
        LDAPP_CONTROL_SORTREQ,
        AttachLDAPControlValSortReq
    },
    
    // Sort response
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_RESP_SORT_OID),      // 474
        LDAPP_CONTROL_SORTRESP,
        AttachLDAPControlValSortResp
    },
    
    // Notification
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_NOTIFICATION_OID),   // 528
        LDAPP_CONTROL_NOTIFY,
        NULL
    },
    
    // Show Deleted
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_SHOW_DELETED_OID),   // 417
        LDAPP_CONTROL_SHOWDELETED,
        NULL
    },
    
    // Lazy Commit
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_LAZY_COMMIT_OID),    // 619
        LDAPP_CONTROL_LAZYCOMMIT,
        NULL
    },
    
    // DirSync
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_DIRSYNC_OID),        // 841
        LDAPP_CONTROL_DIRSYNC,
        AttachLDAPControlValDirSync
    },
    
    // Extended DN
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_EXTENDED_DN_OID),    // 529
        LDAPP_CONTROL_EXTENDEDDN,
        NULL
    },
    
    // Tree Delete
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_TREE_DELETE_OID),    // 805
        LDAPP_CONTROL_TREEDELETE,
        NULL
    },
    
    // Cross Domain Move
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_CROSSDOM_MOVE_TARGET_OID),   // 521
        LDAPP_CONTROL_CROSSDOM,
        AttachLDAPControlValCrossDomMove
    },
    
    // Stats
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_GET_STATS_OID),      // 970
        LDAPP_CONTROL_STAT,
        AttachLDAPControlValStats
    },
    
    // GC Verify Name
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_VERIFY_NAME_OID),    // 1338
        LDAPP_CONTROL_GCVERIFYNAME,
        AttachLDAPControlValGCVerify
    },
    
    // Domain Scope
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_DOMAIN_SCOPE_OID),   // 1339
        LDAPP_CONTROL_DOMAINSCOPE,
        NULL
    },
    
    // Search Options
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_SEARCH_OPTIONS_OID), // 1340 
        LDAPP_CONTROL_SEARCHOPTS,
        AttachLDAPControlValSearchOpts
    },
    
    // Permissive Modify
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_PERMISSIVE_MODIFY_OID),//1413
        LDAPP_CONTROL_PERMISSIVEMOD,
        NULL
    },
    
    // VLV request
    {
        DEFINE_LDAP_STRING(LDAP_CONTROL_VLVREQUEST),         // 9
        LDAPP_CONTROL_VLVREQ,
        AttachLDAPControlValVLVReq
    },
    
    // VLV response
    {
        DEFINE_LDAP_STRING(LDAP_CONTROL_VLVRESPONSE),        // 10
        LDAPP_CONTROL_VLVRESP,
        AttachLDAPControlValVLVResp
    },
    
    // ASQ 
    {
        DEFINE_LDAP_STRING(LDAP_SERVER_ASQ_OID),             // 1504
        LDAPP_CONTROL_ASQ,
        AttachLDAPControlValASQ
    },
};
DWORD nNumKnownControls = (sizeof(KnownControls)/sizeof(OIDATTACHENTRY));

OIDATTACHENTRY KnownExtendedRequests [] = {
    
    // TLS
    {
        DEFINE_LDAP_STRING(LDAP_START_TLS_OID),
        LDAPP_EXT_REQ_TLS,
        NULL
    },

    // TTL
    {
        DEFINE_LDAP_STRING(LDAP_TTL_EXTENDED_OP_OID),
        LDAPP_EXT_REQ_TTL,
        AttachLDAPExtendedReqValTTL
    },
};
DWORD nNumKnownExtendedRequests = (sizeof(KnownExtendedRequests)/sizeof(OIDATTACHENTRY));

OIDATTACHENTRY KnownExtendedResponses [] = {
    
    // Notice of Disconnect
    {
        DEFINE_LDAP_STRING("1.3.6.1.4.1.1466.20036"),
        LDAPP_EXT_RESP_NOTICE_OF_DISCONNECT,
        NULL
    },
    
    // TLS
    {
        DEFINE_LDAP_STRING(LDAP_START_TLS_OID),        // 20037
        LDAPP_EXT_RESP_TLS,
        NULL
    },

    // TTL
    {
        DEFINE_LDAP_STRING(LDAP_TTL_EXTENDED_OP_OID),   // 119.1  
        LDAPP_EXT_RESP_TTL,
        AttachLDAPExtendedRespValTTL
    },
};
DWORD nNumKnownExtendedResponses = (sizeof(KnownExtendedResponses)/sizeof(OIDATTACHENTRY));

OIDATTACHENTRY KnownMatchingRules[] = {

    // Bitwise AND
    {
        DEFINE_LDAP_STRING("1.2.840.113556.1.4.803"),
        LDAPP_MATCHINGRULE_BIT_AND,
        NULL
    },

    // Bitwise OR
    {
        DEFINE_LDAP_STRING("1.2.840.113556.1.4.804"),
        LDAPP_MATCHINGRULE_BIT_OR,
        NULL
    },

};
DWORD nNumKnownMatchingRules = (sizeof(KnownMatchingRules)/sizeof(OIDATTACHENTRY));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\netmon_parser\ldap_att.c ===
//=================================================================================================================
//  MODULE: ldap_att.h
//                                                                                                                 
//  Description: Attachment functions for the Lightweight Directory Access Protocol (LDAP) Parser
//
//  Bloodhound parser for LDAP
//                                                                                                                 
//  Note: info for this parser was gleaned from:
//  rfc 1777, March 1995
//  recommendation x.209 BER for ASN.1
//  recommendation x.208 ASN.1
//  draft-ietf-asid-ladpv3-protocol-05    <06/05/97>
//  
//  Modification History                                                                                           
//                                                                                                                 
//  Arthur Brooking     05/08/96        Created from GRE Parser
//  Peter  Oakley       06/29/97        Updated for LDAP version 3
//=================================================================================================================
#include "ldap.h"
#include <netmon.h>
    
//==========================================================================================================================
//  FUNCTION: AttachLDAPResult()
//==========================================================================================================================
void AttachLDAPResult( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD Level)
{
    
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    DWORD  SeqLength;
    BYTE   Tag;

    // result code ---------------------------
    Tag = GetTag(*ppCurrent);
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
   
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_RESULT_CODE].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LEVEL(Level), IFLAG_SWAPPED);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // matched DN -----------------------------
    Tag = GetTag(*ppCurrent);
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    if(DataLength > 0)
    {
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_MATCHED_DN].hProperty,
                                DataLength,
                                ((DataLength > 0)?*ppCurrent:*ppCurrent-1),
                                0, LEVEL(Level), 0);
    }

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // error message --------------------------
    Tag = GetTag(*ppCurrent);
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    if(DataLength > 0)
    {
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_ERROR_MESSAGE].hProperty,
                                DataLength,
                                ((DataLength > 0)?*ppCurrent:*ppCurrent-1),
                                0, LEVEL(Level), 0);
    }
        *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // now look for optional referral strings
    if((long) *pBytesLeft > 0)
    {
        // try to get a header and see what it is
        // if it's not ours, we have to put everything back
        Tag = GetTag(*ppCurrent);
        *ppCurrent += TAG_LENGTH;
        SeqLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        
        if((Tag & TAG_MASK) == LDAPP_RESULT_REFERRAL)
        {
           
            while( SeqLength > 0 )
            {
                
                Tag = GetTag(*ppCurrent);
                *ppCurrent += TAG_LENGTH;
                DataLength = GetLength(*ppCurrent, &HeaderLength);
                *ppCurrent += HeaderLength;
                *pBytesLeft -= (HeaderLength + TAG_LENGTH);

                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LDAPP_REFERRAL_SERVER].hProperty,
                                        DataLength,
                                        *ppCurrent,
                                        0, LEVEL(Level), 0);
                *ppCurrent += DataLength;
                *pBytesLeft -= DataLength;

                SeqLength -= (HeaderLength + DataLength + TAG_LENGTH);
            } 
        } 
        else
        {
            // put everything back the way it was
            *pBytesLeft += (HeaderLength + TAG_LENGTH);
            *ppCurrent -= (HeaderLength + TAG_LENGTH);
        }
    }
                      
}

//==========================================================================================================================
//  FUNCTION: AttachLDAPBindRequest()
//==========================================================================================================================
void AttachLDAPBindRequest( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)
{
   
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    DWORD  SeqLength;
    BYTE   Tag;

    // version
    Tag = GetTag(*ppCurrent);
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_VERSION].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, IFLAG_SWAPPED);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;


    // name
    Tag = GetTag(*ppCurrent);
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    // if length is 0, then no name
    if(DataLength > 0)
    {
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_NAME].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, 2, 0);
    }

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;


    // authentication type
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    // if length is 0, done
    if(DataLength == 0)
    {
        return;
    }
    
    AttachPropertyInstanceEx( hFrame,
                              LDAPPropertyTable[LDAPP_AUTHENTICATION_TYPE].hProperty,
                              sizeof(BYTE),
                              *ppCurrent,
                              sizeof(BYTE),
                              &Tag,
                              0, 2, 0); 
    
  
    switch( Tag ) 
    {
    default:
    case LDAPP_AUTHENTICATION_TYPE_SIMPLE:
            
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_AUTHENTICATION].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, 3, 0);
        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
     break;

    case LDAPP_AUTHENTICATION_TYPE_SASL:
        // we've already got the header of the sequence
        SeqLength = DataLength;
        while( (long)SeqLength > 0)
        {
            // sasl mechanism
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            
            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_SASL_MECHANISM].hProperty,
                                    DataLength,
                                    ((DataLength > 0)?*ppCurrent:*ppCurrent-1),
                                    0, 4, 0);
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;
            SeqLength -= (HeaderLength + DataLength + TAG_LENGTH);

            // look for the optional credentials 
            if((long)SeqLength > 0) 
            {
                Tag = GetTag(*ppCurrent) & TAG_MASK;
                *ppCurrent += TAG_LENGTH;
                DataLength = GetLength(*ppCurrent, &HeaderLength);
                *ppCurrent += HeaderLength;
                *pBytesLeft -= (HeaderLength + TAG_LENGTH);
                      
                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LDAPP_SASL_CREDENTIALS].hProperty,
                                        DataLength,
                                        ((DataLength > 0)?*ppCurrent:*ppCurrent-1),
                                        0, 4, 0);
                *ppCurrent += DataLength;
                *pBytesLeft -= DataLength;
                SeqLength -= (HeaderLength + DataLength + TAG_LENGTH);
            }
        } // end while
    break; 
    }
    
}
 
//==========================================================================================================================
//  FUNCTION: AttachLDAPBindResponse()
//==========================================================================================================================
void AttachLDAPBindResponse( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)
{
   
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;

    // COMPONENTS of LDAPP_RESULT
    AttachLDAPResult( hFrame, ppCurrent, pBytesLeft, 2);
    
    if( (long) *pBytesLeft > 0 ) 
    {
        // now look for the optional serverSaslCredentials
     
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        
        if(Tag == 5)
        {
            // I have no idea what a tag of 5 is for
            // so we'll just get another one
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;
            
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        }    
        
        if(Tag == LDAPP_RESULT_SASL_CRED && DataLength)
        {


            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_SASL_CREDENTIALS].hProperty,
                                    DataLength,
                                    ((DataLength > 0)?*ppCurrent:*ppCurrent-1),
                                    0, 2, 0);
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;
                 
        }
    }
}

//==========================================================================================================================
//  FUNCTION: AttachLDAPSearchRequest()
//==========================================================================================================================
void AttachLDAPSearchRequest( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)
{
   
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    DWORD  SeqLength;
    DWORD  BytesLeftTemp;
    BYTE   Tag;


    // base object
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_BASE_OBJECT].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, 0);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // scope
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_SCOPE].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, IFLAG_SWAPPED);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // deref aliases
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_DEREF_ALIASES].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, IFLAG_SWAPPED);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // size limit
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_SIZE_LIMIT].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, IFLAG_SWAPPED);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // time limit
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_TIME_LIMIT].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, IFLAG_SWAPPED);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // Attrs Only
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_ATTRS_ONLY].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, IFLAG_SWAPPED);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // filter
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_FILTER].hProperty,
                            0,
                            *ppCurrent,
                            0, 2, IFLAG_SWAPPED);
    
    AttachLDAPFilter( hFrame, ppCurrent, pBytesLeft, 3);
    
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    SeqLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    // if the attribute description list exists then label it.
    if (SeqLength > 0) {

        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_ATTR_DESCR_LIST].hProperty,
                                SeqLength,
                                *ppCurrent,
                                0, 2, IFLAG_SWAPPED);

        // walk thru the attributes
        while ( (long)SeqLength > 0)
        {

            // attribute type
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);

            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_ATTRIBUTE_TYPE].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    0, 3, 0);   
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;

            SeqLength -= (HeaderLength + DataLength + TAG_LENGTH);
        }
    }
}

//==========================================================================================================================
//  FUNCTION: AttachLDAPSearchResponse()
//==========================================================================================================================
void AttachLDAPSearchResponse( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft, DWORD Level)
{
    
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;
    DWORD  OverallSequenceLength;
    DWORD  SetLength;

    // object name
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_OBJECT_NAME].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LEVEL(Level), 0);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // grab the overall sequence header
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    OverallSequenceLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
   
    // step thru all of the sequences
    while( OverallSequenceLength > 0 )
    {
        // grab the next inner sequence
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        // account for this inner sequence in the overall one
        OverallSequenceLength -= (HeaderLength + DataLength + TAG_LENGTH);

        // attribute type
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_ATTRIBUTE_TYPE].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LEVEL(Level), 0);
        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;

        // grab the set header
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        *ppCurrent += TAG_LENGTH;
        SetLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

       while( SetLength > 0 )
        {
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            
            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_ATTRIBUTE_VALUE].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    0, LEVEL(Level+1), 0);
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;
        
            // account for this attribute out of this set
            SetLength -= (HeaderLength + DataLength + TAG_LENGTH);
        }
    }
}

//==========================================================================================================================
//  FUNCTION: AttachLDAPModifyRequest()
//==========================================================================================================================
void AttachLDAPModifyRequest( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)
{
    
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;
    DWORD  SetLength;
    DWORD  OverallSequenceLength;
    
    // object name
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_OBJECT_NAME].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, 0);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;
    
    // grab the overall sequence header
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    OverallSequenceLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    while( OverallSequenceLength > 0 )
    {
        
         // grab the next inner sequence
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        // account for this inner sequence in the overall one
        OverallSequenceLength -= (HeaderLength + DataLength + TAG_LENGTH);

        // operation
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_OPERATION].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, 2, IFLAG_SWAPPED);
        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;


        // skip modification sequence
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        // attribute type
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_ATTRIBUTE_TYPE].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, 3, 0);
        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;

        // grab the set header
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        *ppCurrent += TAG_LENGTH;
        SetLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        // loop thru attribute values
        while( SetLength > 0 )
        {
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            
            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_ATTRIBUTE_VALUE].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    0, 4, 0);
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;

            SetLength -= (HeaderLength + DataLength + TAG_LENGTH);
        }
    }
}

//==========================================================================================================================
//  FUNCTION: AttachLDAPDelRequest()
//==========================================================================================================================
void AttachLDAPDelRequest( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)
{
  
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;

    // object name
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_OBJECT_NAME].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, 0);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

}

//==========================================================================================================================
//  FUNCTION: AttachLDAPModifyRDNRequest()
//==========================================================================================================================
void AttachLDAPModifyRDNRequest( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)
{
    
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;

    // object name
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_OBJECT_NAME].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, 0);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // new RDN
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_NEW_RDN].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, 0);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    if((long) *pBytesLeft > 0) 
    {
        // get the stuff for v3
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_DELETE_OLD_RDN].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, 2, 0);
        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;

        if((long) *pBytesLeft > 0)
        {
            // now try for the optional string
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            
            AttachPropertyInstance( hFrame,
                           LDAPPropertyTable[LDAPP_NEW_SUPERIOR].hProperty,
                           DataLength,
                           *ppCurrent,
                           0, 2, 0);
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;
        }
    }
}

//==========================================================================================================================
//  FUNCTION: AttachLDAPCompareRequest()
//==========================================================================================================================
void AttachLDAPCompareRequest( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)
{
  
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;

    // object name
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_OBJECT_NAME].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, 0);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // skip the sequence header
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    // attribute type
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_ATTRIBUTE_TYPE].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 2, 0);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // attribute value
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_ATTRIBUTE_VALUE].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 3, 0);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;
}


//==========================================================================================================================
//  FUNCTION: AttachLDAPAbandonRequest()
//==========================================================================================================================
void AttachLDAPAbandonRequest( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)
{
  
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;

    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    if(Tag == BER_TAG_INTEGER)
    {
       
         // MessageID
        
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_MESSAGE_ID].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, 2, IFLAG_SWAPPED);
        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
    }
    else
    {
        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
    }

}


//==========================================================================================================================
//  FUNCTION: AttachLDAPFilter()
//==========================================================================================================================
void AttachLDAPFilter( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft, DWORD Level)
{
    DWORD  BytesLeftTemp;
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    DWORD  SeqLength;
    BYTE   Tag;
    BYTE   BoolVal;
    LDAPOID OID;
    BOOLEAN fRuleRecognized;
    DWORD  dwRule;
    DWORD  LabelId;

    // grab our choice
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    
    AttachPropertyInstanceEx( hFrame,
                              LDAPPropertyTable[LDAPP_FILTER_TYPE].hProperty,
                              sizeof(BYTE),
                              *ppCurrent,
                              sizeof(BYTE),
                              &Tag,
                              0, LEVEL(Level), 0);
   

    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    // what type of filter is this
    
    switch( Tag )
    {
        case LDAPP_FILTER_TYPE_AND:
        case LDAPP_FILTER_TYPE_OR:
            // walk thru component filters
            while( (long)DataLength > 0 )
            {
                BytesLeftTemp = *pBytesLeft;
                AttachLDAPFilter( hFrame, ppCurrent, pBytesLeft, Level+1);
                DataLength -= (BytesLeftTemp - *pBytesLeft);
            }
            break;   

        case LDAPP_FILTER_TYPE_NOT:
            // a single filter
            AttachLDAPFilter( hFrame, ppCurrent, pBytesLeft, Level+1);
            break;
    
        case LDAPP_FILTER_TYPE_EQUALITY_MATCH:
        case LDAPP_FILTER_TYPE_GREATER_OR_EQUAL:
        case LDAPP_FILTER_TYPE_LESS_OR_EQUAL:
        case LDAPP_FILTER_TYPE_APPROX_MATCH:
            // attribute type
            
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            
            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_ATTRIBUTE_TYPE].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    0, LEVEL(Level+1), 0);
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;

            // attribute value
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            
            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_ATTRIBUTE_VALUE].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    0, LEVEL(Level+1), 0);
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;
            break;

        case LDAPP_FILTER_TYPE_PRESENT:
            // attribute type
            // we already have the header and DataLength
            // and are at the correct position to attach
            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_ATTRIBUTE_TYPE].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    0, LEVEL(Level+1), 0);
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;
            break;

        case LDAPP_FILTER_TYPE_EXTENSIBLE_MATCH:
            // Extensible match
            SeqLength = DataLength;

            // get the sequence header
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            SeqLength -= (HeaderLength + TAG_LENGTH);

            if (LDAPP_FILTER_EX_MATCHING_RULE == Tag) {
                fRuleRecognized = FALSE;
                OID.value = *ppCurrent;
                OID.length = DataLength;
                for (dwRule = 0; dwRule < nNumKnownMatchingRules; dwRule++) {
                    if (AreOidsEqual(&OID, &(KnownMatchingRules[dwRule].Oid))) {
                        fRuleRecognized = TRUE;
                        break;
                    }
                }

                if (fRuleRecognized) {
                    LabelId = KnownMatchingRules[dwRule].LabelId;
                } else {
                    LabelId = LDAPP_MATCHING_RULE;
                }

                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LabelId].hProperty,
                                        DataLength,
                                        *ppCurrent,
                                        0, LEVEL(Level+1), 0);

                *ppCurrent += DataLength;
                *pBytesLeft -= DataLength;
                SeqLength -= DataLength;
                if (SeqLength > 0) {
                    Tag = GetTag(*ppCurrent) & TAG_MASK;
                    *ppCurrent += TAG_LENGTH;
                    DataLength = GetLength(*ppCurrent, &HeaderLength);
                    *ppCurrent += HeaderLength;
                    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
                    SeqLength -= (HeaderLength + TAG_LENGTH);
                } else {
                    Tag = 0;
                }

            }

            if (LDAPP_FILTER_EX_TYPE == Tag) {
                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LDAPP_ATTRIBUTE_TYPE].hProperty,
                                        DataLength,
                                        *ppCurrent,
                                        0, LEVEL(Level+1), 0);

                *ppCurrent += DataLength;
                *pBytesLeft -= DataLength;
                SeqLength -= DataLength;
                if (SeqLength > 0) {
                    Tag = GetTag(*ppCurrent) & TAG_MASK;
                    *ppCurrent += TAG_LENGTH;
                    DataLength = GetLength(*ppCurrent, &HeaderLength);
                    *ppCurrent += HeaderLength;
                    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
                    SeqLength -= (HeaderLength + TAG_LENGTH);
                } else {
                    Tag = 0;
                }

            }

            if (LDAPP_FILTER_EX_VALUE == Tag) {
                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LDAPP_ATTRIBUTE_VALUE].hProperty,
                                        DataLength,
                                        *ppCurrent,
                                        0, LEVEL(Level+1), 0);

                *ppCurrent += DataLength;
                *pBytesLeft -= DataLength;
                SeqLength -= DataLength;
                if (SeqLength > 0) {
                    Tag = GetTag(*ppCurrent) & TAG_MASK;
                    *ppCurrent += TAG_LENGTH;
                    DataLength = GetLength(*ppCurrent, &HeaderLength);
                    *ppCurrent += HeaderLength;
                    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
                    SeqLength -= (HeaderLength + TAG_LENGTH);
                } else {
                    Tag = 0;
                }

            }

            if (LDAPP_FILTER_EX_ATTRIBUTES == Tag) {
                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LDAPP_DN_ATTRIBUTES].hProperty,
                                        DataLength,
                                        *ppCurrent,
                                        0, LEVEL(Level+1), 0);

                *ppCurrent += DataLength;
                *pBytesLeft -= DataLength;
            } else {
                BoolVal = 0;
                
                AttachPropertyInstanceEx( hFrame,
                                          LDAPPropertyTable[LDAPP_DN_ATTRIBUTES].hProperty,
                                          DataLength,
                                          *ppCurrent,
                                          sizeof(BYTE),
                                          &BoolVal,
                                          0, LEVEL(Level+1), 0);
                
            }            
            
            break;

        case LDAPP_FILTER_TYPE_SUBSTRINGS:
            // substring filter
            
            // attribute type
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            
            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_ATTRIBUTE_TYPE].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    0, LEVEL(Level+1), 0);
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;

            // grab the sequence header
            Tag = GetTag(*ppCurrent) & TAG_MASK;
            *ppCurrent += TAG_LENGTH;
            SeqLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);

            // loop thru the choices
            while( SeqLength > 0 )
            {
                // grab this choice
                Tag = GetTag(*ppCurrent) & TAG_MASK;
                *ppCurrent += TAG_LENGTH;
                DataLength = GetLength(*ppCurrent, &HeaderLength);
                *ppCurrent += HeaderLength;
                *pBytesLeft -= (HeaderLength + TAG_LENGTH);
                
                SeqLength -= (HeaderLength + DataLength + TAG_LENGTH);

                switch( Tag )
                {
                    case LDAPP_SUBSTRING_CHOICE_INITIAL:
                        
                        AttachPropertyInstance( hFrame,
                                                LDAPPropertyTable[LDAPP_SUBSTRING_INITIAL].hProperty,
                                                DataLength,
                                                *ppCurrent,
                                                0, LEVEL(Level+1), 0);
                        *ppCurrent += DataLength;
                        *pBytesLeft -= DataLength;
                        break;

                    case LDAPP_SUBSTRING_CHOICE_ANY:
                        
                        AttachPropertyInstance( hFrame,
                                                LDAPPropertyTable[LDAPP_SUBSTRING_ANY].hProperty,
                                                DataLength,
                                                *ppCurrent,
                                                0, LEVEL(Level+1), 0);
                        *ppCurrent += DataLength;
                        *pBytesLeft -= DataLength;
                        break;

                    case LDAPP_SUBSTRING_CHOICE_FINAL:
                        
                        AttachPropertyInstance( hFrame,
                                                LDAPPropertyTable[LDAPP_SUBSTRING_FINAL].hProperty,
                                                DataLength,
                                                *ppCurrent,
                                                0, LEVEL(Level+1), 0);
                        *ppCurrent += DataLength;
                        *pBytesLeft -= DataLength;
                        break;
                }
            } // while
            break;
         }
    
}

//==========================================================================================================================
//  FUNCTION: AttachLDAPSearchResponseReference()
//==========================================================================================================================
void AttachLDAPSearchResponseReference( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft, DWORD Level)
{
    
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;
  
    // get the reference string
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_REFERRAL_SERVER].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LEVEL(Level+1), 0);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

   
}

//==========================================================================================================================
//  FUNCTION: AttachLDAPSearchResponseFull()
//==========================================================================================================================
void AttachLDAPSearchResponseFull( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)
{
  
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;
    DWORD  OverallSequenceLength;

    
    // grab the overall sequence header
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    OverallSequenceLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    // step thru all of the entries
    while( OverallSequenceLength > 0 )
    {
        // grab the indicator for the entry
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        
       
        AttachPropertyInstanceEx( hFrame,
                                  LDAPPropertyTable[LDAPP_PROTOCOL_OP].hProperty,
                                  sizeof( BYTE ),
                                  *ppCurrent,
                                  sizeof(BYTE),
                                  &Tag,
                                  0, 2, 0);
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        // account for this entry in the overall sequence
        OverallSequenceLength -= (HeaderLength + DataLength + TAG_LENGTH);

        // call the proper worker for the body of this entry
        switch( Tag )
        {
            case LDAPP_PROTOCOL_OP_SEARCH_RES_DONE:
                AttachLDAPResult( hFrame, ppCurrent, pBytesLeft, 3);
                break;

            case LDAPP_PROTOCOL_OP_SEARCH_RES_ENTRY:
                AttachLDAPSearchResponse( hFrame, ppCurrent, pBytesLeft, 3);
                break;

            case LDAPP_PROTOCOL_OP_SEARCH_RES_REFERENCE:
                AttachLDAPSearchResponseReference( hFrame, ppCurrent, pBytesLeft, 3);
                break;
        }
    }
}

#define LDAPP_EXT_VAL_LEVEL  3

//==========================================================================================================================
//  FUNCTION: AttachLDAPExtendedRequest()
//==========================================================================================================================
void AttachLDAPExtendedRequest( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft, DWORD ReqSize)
{
    
    DWORD   HeaderLength = 0;
    DWORD   DataLength;
    BYTE    Tag;
    LDAPOID OID;
    BOOL    fReqFound = FALSE;
    DWORD   LabelId;
    DWORD   ReqType;

    // get the name of the request and attach it
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    
    OID.value = *ppCurrent;
    OID.length = DataLength;
    for (ReqType = 0; ReqType < nNumKnownExtendedRequests; ReqType++) {
        if (AreOidsEqual(&OID, &(KnownExtendedRequests[ReqType].Oid))) {
            fReqFound = TRUE;
            break;
        }
    }

    if (fReqFound) {
        LabelId = KnownExtendedRequests[ReqType].LabelId;

        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LabelId].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, 2, 0);
    } else {
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_REQUEST_NAME].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, 2, 0);
    }
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // optionals, if there is data left, get it
    if((long) *pBytesLeft > 0)
    {
        // Request value
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        
        
        if(Tag == LDAPP_EX_REQ_VALUE)
        {
            // get the string and attach it
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);

            if (fReqFound &&
                KnownExtendedRequests[ReqType].pAttachFunction) {
                // We know how to break this one open some more.
                KnownExtendedRequests[ReqType].pAttachFunction(hFrame,
                                                               ppCurrent,
                                                               pBytesLeft,
                                                               DataLength);
            } else {
                // Don't know this one so just mark the value.
                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LDAPP_REQUEST_VALUE].hProperty,
                                        DataLength,
                                        *ppCurrent,
                                        0, 2, 0);
                *ppCurrent += DataLength;
                *pBytesLeft -= DataLength;
            }
        }
    }
    
}
 
void AttachLDAPExtendedReqValTTL( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbReqValue)
{
    DWORD   HeaderLength = 0;
    DWORD   DataLength;
    BYTE    Tag;

    if (*pBytesLeft >= cbReqValue) {
        // Skip the sequence tag.
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        // Get the entryName
        Tag = GetTag(*ppCurrent) & TAG_MASK;

        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_EXT_REQ_TTL_ENTRYNAME].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_EXT_VAL_LEVEL, 0);

        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;

        // Get the time.
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_EXT_REQ_TTL_TIME].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_EXT_VAL_LEVEL, IFLAG_SWAPPED);

        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
    }
}

//==========================================================================================================================
//  FUNCTION: AttachLDAPExtendedResponse()
//==========================================================================================================================
void AttachLDAPExtendedResponse( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft, DWORD RespSize)
{
  
    DWORD   HeaderLength = 0;
    DWORD   DataLength;
    BYTE    Tag;
    LDAPOID OID;
    BOOL    fRespFound = FALSE;
    DWORD   LabelId;
    DWORD   RespType;

    // COMPONENTS of LDAPP_RESULT as defined in the draft
    AttachLDAPResult( hFrame, ppCurrent, pBytesLeft, 2);
    
    // now get the extras if there is something left
    if((long) *pBytesLeft > 0)
    {
        // we want to get the Response Name, it is optional
        // but it is defined to come first. We decide if it is there by
        // its custom tag.
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        
        if(Tag == LDAPP_RESULT_EX_RES_NAME)
        {
            
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            
            OID.value = *ppCurrent;
            OID.length = DataLength;
            for (RespType = 0; RespType < nNumKnownExtendedResponses; RespType++) {
                if (AreOidsEqual(&OID, &(KnownExtendedResponses[RespType].Oid))) {
                    fRespFound = TRUE;
                    break;
                }
            }

            if (fRespFound) {
                LabelId = KnownExtendedResponses[RespType].LabelId;

                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LabelId].hProperty,
                                        DataLength,
                                        *ppCurrent,
                                        0, 2, 0);
            } else {
                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LDAPP_RESPONSE_NAME].hProperty,
                                        DataLength,
                                        *ppCurrent,
                                        0, 2, 0);
            }
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;
        }
    }

    if((long) *pBytesLeft > 0)
    {    

        // response value or else nothing (optional)
        Tag = GetTag(*ppCurrent) & TAG_MASK;
        
        if(Tag == LDAPP_RESULT_EX_RES_VALUE)
        {
            // get the actual string
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            
            if (fRespFound &&
                KnownExtendedResponses[RespType].pAttachFunction) {
                // We known this one so break it open.
                KnownExtendedResponses[RespType].pAttachFunction(hFrame,
                                                                 ppCurrent,
                                                                 pBytesLeft,
                                                                 DataLength);
            } else {
                // Didn't find this one just mark at the response value.
                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LDAPP_RESPONSE_VALUE].hProperty,
                                        DataLength,
                                        *ppCurrent,
                                        0, 2, 0);
                *ppCurrent += DataLength;
                *pBytesLeft -= DataLength;
            }
        }
    }
} 

void AttachLDAPExtendedRespValTTL( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbRespValue)
{
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    BYTE   Tag;

    if (*pBytesLeft >= cbRespValue) {
        // First skip the sequence header
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        
        Tag = GetTag(*ppCurrent) & TAG_MASK; 
            
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_EXT_RESP_TTL_TIME].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_EXT_VAL_LEVEL, IFLAG_SWAPPED);

        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;

    }
}

void AttachLDAPOptionalControls( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)      
{
    DWORD  HeaderLength = 0;
    DWORD  DataLength;
    DWORD  RemainingCtrlsLength;
    DWORD  TmpBytesLeft;
    BYTE   Tag;

    if ((long)*pBytesLeft > 0)
    {
        
        // try to get the tag from the sequence header, it is optional but something
        // is here if there are bytes left in the frame
        Tag = GetTag(*ppCurrent) & TAG_MASK; 
            
        // controls is a sequence of individual controls
        if(Tag == LDAPP_CONTROLS_TAG)
        {
            *ppCurrent += TAG_LENGTH;
            RemainingCtrlsLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);

            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_CONTROLS].hProperty,
                                    RemainingCtrlsLength,
                                    *ppCurrent,
                                    0, 2, 0);

            while (RemainingCtrlsLength != 0 && *pBytesLeft > 0) {            
                // get the next control
                TmpBytesLeft = *pBytesLeft;
                AttachLDAPControl( hFrame, ppCurrent, pBytesLeft );
                RemainingCtrlsLength -= TmpBytesLeft - *pBytesLeft;
            }
        }  // if Tag == LDAPP_CONTROLS_TAG ...
    } // if *pBytesLeft > 0 ...
}

void AttachLDAPControl( HFRAME hFrame, ULPBYTE * ppCurrent,LPDWORD pBytesLeft)
{
    DWORD   HeaderLength = 0;
    DWORD   DataLength;
    DWORD   ControlType;
    DWORD   LabelId = LDAPP_CONTROL_TYPE;
    BOOL    ControlRecognized = FALSE;
    LDAPOID OID;
    BYTE    Tag;
    BYTE    Temp_Data = 0;
    BYTE    SpecialFlag = LDAPP_CTRL_NONE;

    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        // control type
    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    OID.value = *ppCurrent;
    OID.length = DataLength;
    for (ControlType = 0; ControlType < nNumKnownControls; ControlType++) {
        if (AreOidsEqual(&OID, &(KnownControls[ControlType].Oid))) {
            ControlRecognized = TRUE;
            break;
        }
    }

    if (ControlRecognized) {
        LabelId = KnownControls[ControlType].LabelId;
    }
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LabelId].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, 3, 0);


    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // look for an optional boolean
    if((long) *pBytesLeft > 0) 
    {
        Tag = GetTag(*ppCurrent) & TAG_MASK;

        if(Tag == BER_TAG_BOOLEAN) // boolean
        {

                *ppCurrent += TAG_LENGTH;
                DataLength = GetLength(*ppCurrent, &HeaderLength);
                *ppCurrent += HeaderLength;
                *pBytesLeft -= (HeaderLength + TAG_LENGTH);  

                AttachPropertyInstance( hFrame,
                                        LDAPPropertyTable[LDAPP_CRITICALITY].hProperty,
                                        DataLength,
                                        *ppCurrent,
                                        0, 4, 0);
                *ppCurrent += DataLength;
                *pBytesLeft -= DataLength;

                Tag = GetTag(*ppCurrent) & TAG_MASK;
        }
        else
        {

                // fill in the default boolean value
                AttachPropertyInstanceEx( hFrame,
                          LDAPPropertyTable[LDAPP_CRITICALITY].hProperty,
                          sizeof( BYTE ),
                          NULL,
                          sizeof(BYTE),
                          &Temp_Data,
                          0, 4, 0);
        }

        // if we are a string and there is data left, then process it
        if(Tag == BER_TAG_OCTETSTRING && (long)*pBytesLeft > 0) 
        {
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH); 

            if (DataLength > 0) {

                // can we crack the control value open?                
                if (ControlRecognized &&
                    NULL != KnownControls[ControlType].pAttachFunction) {

                    // Yes, attach the value.
                    KnownControls[ControlType].pAttachFunction(hFrame,
                                                               ppCurrent,
                                                               pBytesLeft,
                                                               DataLength);

                } else {

                    // Nope, do nothing.
                    AttachPropertyInstance( hFrame,
                                            LDAPPropertyTable[LDAPP_CONTROL_VALUE].hProperty,
                                            DataLength,
                                            ((DataLength > 0)?*ppCurrent:*ppCurrent-1),
                                            0, 4, 0);
                    *ppCurrent += DataLength;
                    *pBytesLeft -= DataLength;

                }
            } // if DataLength > 0
        } // if Tag == LDAPP_BER_STRING ...
    } // if *pBytesLeft > 0 ...
}

#define LDAPP_CONTROL_VAL_LEVEL 4

void AttachLDAPControlValPaged( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{

    DWORD    DataLength;
    DWORD    HeaderLength;

    // skip the sequence header
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 

    // look for an integer 'size'
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_CONTROL_PAGED_SIZE].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // look for the 'Cookie'
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 

    if (DataLength) {    
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_CONTROL_PAGED_COOKIE].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, 0);
        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
    }
}


void AttachLDAPControlValVLVReq( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    DWORD    VLVLength;
    DWORD    TmpBytesLeft;
    BYTE     Tag;

    // skip the sequence header saving the length of the control value.
    *ppCurrent += TAG_LENGTH;
    VLVLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    TmpBytesLeft = *pBytesLeft;

    // get the before count
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_CONTROL_VLVREQ_BCOUNT].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // get the after count
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_CONTROL_VLVREQ_ACOUNT].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    *pBytesLeft -= TAG_LENGTH;

    if (LDAPP_VLV_REQ_BYOFFSET_TAG == Tag) {
        // get the length of the sequence and skip the following tag.
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength + TAG_LENGTH;
        *pBytesLeft -= HeaderLength + TAG_LENGTH;

        // get the offset
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= HeaderLength;

        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_CONTROL_VLVREQ_OFFSET].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);

        // skip to the contentCount
        *ppCurrent += DataLength + TAG_LENGTH;
        *pBytesLeft -= DataLength + TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= HeaderLength;

        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_CONTROL_VLV_CONTENTCOUNT].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);        
    } else {
        // get the assertionValue
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= HeaderLength;
    
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_CONTROL_VLVREQ_GE].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);
    }

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // is there a contextID?
    if (VLVLength > (TmpBytesLeft - *pBytesLeft)) {
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_CONTROL_VLV_CONTEXT].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);

        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
    }

}


void AttachLDAPControlValVLVResp( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    DWORD    VLVLength;
    DWORD    TmpBytesLeft;
    BYTE     Tag;

    // skip the sequence header saving the length of the control value.
    *ppCurrent += TAG_LENGTH;
    VLVLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 
    TmpBytesLeft = *pBytesLeft;

    // get the targetPosition
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_CONTROL_VLVRESP_TARGETPOS].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // get the contentCount
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_CONTROL_VLV_CONTENTCOUNT].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);

    *ppCurrent += DataLength + TAG_LENGTH;
    *pBytesLeft -= DataLength + TAG_LENGTH;

    // get the result code
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= HeaderLength;
    
    AttachPropertyInstance( hFrame,
                        LDAPPropertyTable[LDAPP_CONTROL_VLVRESP_RESCODE].hProperty,
                        DataLength,
                        *ppCurrent,
                        0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // is there a contextID?
    if (VLVLength > (TmpBytesLeft - *pBytesLeft)) {
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_CONTROL_VLV_CONTEXT].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);

        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
    }

}

void AttachLDAPControlValSortReq( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    DWORD    SortLengthOuter;
    DWORD    TmpBytesLeftOuter;
    DWORD    SortLengthInner;
    DWORD    TmpBytesLeftInner;
    BYTE     DefaultReverseFlag = 0;
    PBYTE    pReverseFlag = NULL;
    BYTE     Tag;
    
    // skip the sequence header saving the length of the control value.
    *ppCurrent += TAG_LENGTH;
    SortLengthOuter = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 
    TmpBytesLeftOuter = *pBytesLeft;

    while (SortLengthOuter > (TmpBytesLeftOuter - *pBytesLeft)) {


        // skip the sequence header saving the length of the inner sequence.
        *ppCurrent += TAG_LENGTH;
        SortLengthInner = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH); 
        TmpBytesLeftInner = *pBytesLeft;

        // get the attributeType
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_CONTROL_SORTREQ_ATTRTYPE].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, 0);

        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;

        if (SortLengthInner > (TmpBytesLeftInner - *pBytesLeft)) {
            Tag = GetTag(*ppCurrent);
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        }
        else {
            Tag = LDAPP_SORT_REQ_REVERSEORDER_TAG;
            DataLength = 0;
        }

        // If there is an orderingRul get that.
        if (LDAPP_SORT_REQ_ORDERINGRULE_TAG == (Tag & TAG_MASK)) {
            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_CONTROL_SORTREQ_MATCHINGRULE].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    0, LDAPP_CONTROL_VAL_LEVEL, 0);
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;

            if (SortLengthInner > (TmpBytesLeftInner - *pBytesLeft)) {
                Tag = GetTag(*ppCurrent);
                *ppCurrent += TAG_LENGTH;
                DataLength = GetLength(*ppCurrent, &HeaderLength);
                *ppCurrent += HeaderLength;
                *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            }
            else {
                Tag = LDAPP_SORT_REQ_REVERSEORDER_TAG;
                DataLength = 0;
            }
        }

        // if the reverse flag wasn't specified set up the default.
        if (0 == DataLength) {
            pReverseFlag = &DefaultReverseFlag;
        }
        else {
            pReverseFlag = *ppCurrent;
        }

        AttachPropertyInstanceEx( hFrame,
                                  LDAPPropertyTable[LDAPP_CONTROL_SORTREQ_REVERSE].hProperty,
                                  DataLength,
                                  *ppCurrent,
                                  sizeof(BYTE),
                                  pReverseFlag,
                                  0, LDAPP_CONTROL_VAL_LEVEL, 0);

        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
    }
}

void AttachLDAPControlValSortResp( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    DWORD    SortLength;
    DWORD    TmpBytesLeft;
    BYTE     DefaultReverseFlag = 0;
    PBYTE    pReverseFlag = NULL;
    BYTE     Tag;
    
    // skip the sequence header saving the length of the control value.
    *ppCurrent += TAG_LENGTH;
    SortLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 
    TmpBytesLeft = *pBytesLeft;

    // get the result code
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_CONTROL_SORTRESP_RESCODE].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // if there is an attribute type, get it
    if (SortLength > (TmpBytesLeft - *pBytesLeft)) {
        Tag = GetTag(*ppCurrent);
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_CONTROL_SORTRESP_ATTRTYPE].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, 0);
        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
    }
}

void AttachLDAPControlValSD( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    DWORD    SDVal;
    DWORD    MaskedSDVal;
    DWORD    i;
    
    // skip the sequence header
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 

    // Get the flags.
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 

    SDVal = (DWORD) GetInt(*ppCurrent, DataLength);

    for(i=0; i < LDAPSDControlValsSET.nEntries; i++) {
        MaskedSDVal = SDVal & ((LPLABELED_DWORD)LDAPSDControlValsSET.lpDwordTable)[i].Value;
        if (MaskedSDVal) {
            AttachPropertyInstanceEx( hFrame,
                                      LDAPPropertyTable[LDAPP_CONTROL_SD_VAL].hProperty,
                                      DataLength,
                                      *ppCurrent,
                                      sizeof(DWORD),
                                      &MaskedSDVal,
                                      0, LDAPP_CONTROL_VAL_LEVEL, 0);
        }
    }

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;
}


void AttachLDAPControlValASQ( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    DWORD    i;
    BYTE     Tag;
    DWORD    LabelId = 0;
    
    // skip the sequence header
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 

    Tag = GetTag(*ppCurrent);
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    if (BER_TAG_ENUMERATED == Tag) {
        LabelId = LDAPP_CONTROL_ASQ_RESCODE;
    } else if (BER_TAG_OCTETSTRING == Tag) {
        LabelId = LDAPP_CONTROL_ASQ_SRCATTR;
    }
    if (LabelId != 0) {    
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LabelId].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);
    }
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;
}

void AttachLDAPControlValDirSync( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    DWORD    Flags;
    DWORD    MaskedFlags;
    DWORD    i;
    
    // skip the sequence header
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 

    // get the flags
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    Flags = (DWORD) GetInt(*ppCurrent, DataLength);

    //
    // iterate through each possible flag attaching a label if it exists.
    //
    for (i=0; i < LDAPDirSyncFlagsSET.nEntries; i++) {
        MaskedFlags = Flags & ((LPLABELED_DWORD)LDAPDirSyncFlagsSET.lpDwordTable)[i].Value;
        if (MaskedFlags) {
            AttachPropertyInstanceEx( hFrame,
                                    LDAPPropertyTable[LDAPP_CONTROL_DIRSYNC_FLAGS].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    sizeof(DWORD),
                                    &MaskedFlags,
                                    0, LDAPP_CONTROL_VAL_LEVEL, 0);
        }
    }

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;
    
    // Get the size
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_CONTROL_DIRSYNC_SIZE].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);
    
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // Get the cookie if there is one.
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    if (DataLength > 0) {
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_CONTROL_DIRSYNC_COOKIE].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, 0);

        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
    }
}

void AttachLDAPControlValCrossDomMove( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_CONTROL_CROSSDOM_NAME].hProperty,
                            cbCtrlValue,
                            *ppCurrent,
                            0, LDAPP_CONTROL_VAL_LEVEL, 0);

    *ppCurrent += cbCtrlValue;
    *pBytesLeft -= cbCtrlValue;

}

void AttachLDAPControlValStats( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    DWORD    StatsLength;
    DWORD    TmpBytesLeft;
    DWORD    LabelId;
    DWORD    StatType;
    
    if (sizeof(DWORD) == cbCtrlValue) {
        // This is the stats request request (as opposed to the response) 
        // and some flags were passed.        
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_CONTROL_STAT_FLAG].hProperty,
                                cbCtrlValue,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);
        *ppCurrent += cbCtrlValue;
        *pBytesLeft -= cbCtrlValue;
        return;
    }

    //
    // this must be a stats response.
    //
    
    // skip the sequence header saving the length of the sequence.
    *ppCurrent += TAG_LENGTH;
    StatsLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 
    TmpBytesLeft = *pBytesLeft;

    while (StatsLength > (TmpBytesLeft - *pBytesLeft)) {
        //
        // get this stat's header
        //
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;

        StatType = GetInt(*ppCurrent, DataLength);

        *ppCurrent += DataLength;
        *pBytesLeft -= HeaderLength + DataLength + TAG_LENGTH;

        // now position on the stat itself
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= HeaderLength + TAG_LENGTH;

        // find the label to use and attach it.
        switch (StatType) {
        case STAT_THREADCOUNT:
            LabelId = LDAPP_CONTROL_STAT_THREADCOUNT;
            break;
        case STAT_CORETIME:
            LabelId = LDAPP_CONTROL_STAT_CORETIME;
            break;
        case STAT_CALLTIME:
            LabelId = LDAPP_CONTROL_STAT_CALLTIME;
            break;
        case STAT_SUBSRCHOP:
            LabelId = LDAPP_CONTROL_STAT_SUBSEARCHOPS;
            break;
        case STAT_ENTRIES_RETURNED:
            LabelId = LDAPP_CONTROL_STAT_ENTRIES_RETURNED;
            break;
        case STAT_ENTRIES_VISITED:
            LabelId = LDAPP_CONTROL_STAT_ENTRIES_VISITED;
            break;
        case STAT_FILTER:
            LabelId = LDAPP_CONTROL_STAT_FILTER;
            break;
        case STAT_INDEXES:
            LabelId = LDAPP_CONTROL_STAT_INDEXES;
            break;
        default:
            LabelId = -1;
        }

        if (-1 != LabelId) {
            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LabelId].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);
        }

        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
    }
}

void AttachLDAPControlValGCVerify( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    
    // skip the sequence header
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 

    // get the flags
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_CONTROL_GCVERIFYNAME_FLAGS].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // get the server name
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_CONTROL_GCVERIFYNAME_NAME].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LDAPP_CONTROL_VAL_LEVEL, 0);

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;
}

void AttachLDAPControlValSearchOpts( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    DWORD    SearchOpts;
    DWORD    MaskedSearchOpts;
    DWORD    i;
    
    // skip the sequence header
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 

    // get the flags
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    SearchOpts = GetInt(*ppCurrent, DataLength);

    //
    // Iterate through the possible search options labeling as appropriate.
    //
    for (i=0; i < LDAPSearchOptsSET.nEntries; i++) {
        MaskedSearchOpts = ((LPLABELED_DWORD)LDAPSearchOptsSET.lpDwordTable)[i].Value;
        if (MaskedSearchOpts) {
            AttachPropertyInstanceEx( hFrame,
                                    LDAPPropertyTable[LDAPP_CONTROL_SEARCHOPTS_OPTION].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    sizeof(DWORD),
                                    &MaskedSearchOpts,
                                    0, LDAPP_CONTROL_VAL_LEVEL, 0);
        }
    }
    
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\netmon_parser\ldap_ber.c ===
//==========================================================================================================================
//  MODULE: LDAP_BER.c
//
//  Description: Lightweight Directory Access Protocol (LDAP) Parser
//
//  Helpers for BER in the Bloodhound parser for LDAP
//                                                                                                                 
//  Note: info for this parser was gleaned from:
//  rfc 1777, March 1995
//  recommendation x.209 BER for ASN.1
//  recommendation x.208 ASN.1
//
//  Modification History                                                                                           
//                                                                                                                 
//  Arthur Brooking     05/08/96        Created from GRE Parser
//==========================================================================================================================
#include "LDAP.h"

// needed constants
#define	BER_TAG_MASK        0x1f
#define	BER_FORM_MASK       0x20
#define BER_CLASS_MASK      0xc0
#define GetBerTag(x)    (x & BER_TAG_MASK)
#define GetBerForm(x)   (x & BER_FORM_MASK)
#define GetBerClass(x)  (x & BER_CLASS_MASK)

// forms
#define BER_FORM_PRIMATIVE          0x00
#define BER_FORM_CONSTRUCTED        0x20

// classes
#define BER_CLASS_UNIVERSAL         0x00
#define BER_CLASS_APPLICATION       0x40	
#define BER_CLASS_CONTEXT_SPECIFIC  0x80

// Standard BER tags    
#define BER_TAG_INVALID         0x00
#define BER_TAG_BOOLEAN         0x01
#define BER_TAG_INTEGER         0x02
#define	BER_TAG_BITSTRING       0x03
#define BER_TAG_OCTETSTRING     0x04
#define BER_TAG_NULL            0x05
#define	BER_TAG_ENUMERATED      0x0a
#define BER_TAG_SEQUENCE        0x30
#define BER_TAG_SET             0x31

// Length field identifiers
#define BER_LEN_IND_MASK        0x80
#define GetBerLenInd(x)         (x & BER_LEN_IND_MASK)
#define BER_LEN_IMMEDIATE       0x00
#define BER_LEN_INDEFINITE      0x80

#define BER_LEN_MASK            (~BER_LEN_IND_MASK)
#define GetBerLen(x)            (x & BER_LEN_MASK)

// local function prototypes
BOOL BERGetLength( ULPBYTE pInitialPointer, 
                   ULPBYTE *ppContents, 
                   LPDWORD pHeaderLength,
                   LPDWORD pDataLength, 
                   ULPBYTE *ppNext);

//==========================================================================================================================
// BERGetInteger - given a pointer, decode it as an integer; applies to INTEGER, BOOL, and ENUMERATED
//==========================================================================================================================
BOOL _cdecl BERGetInteger( ULPBYTE  pCurrentPointer,
                           ULPBYTE *ppValuePointer,
                           LPDWORD pHeaderLength,
                           LPDWORD pDataLength,
                           ULPBYTE *ppNext)
{
    BOOL ReturnCode = TRUE;

    // ----------
    // IDENTIFIER
    // ----------
    // make sure that it is universal
    if( GetBerClass( *pCurrentPointer ) != BER_CLASS_UNIVERSAL )
    {
        // it is not universal
#ifdef DEBUG
        dprintf("BERGetInteger:Integer identifier not universal\n");
#endif
        ReturnCode = FALSE;
    }

    // make sure it is a primative
    if( GetBerForm(*pCurrentPointer) != BER_FORM_PRIMATIVE )
    {
        // it is not a primative
#ifdef DEBUG
        dprintf("BERGetInteger:Integer identifier not primative\n");
#endif
        ReturnCode = FALSE;
    }

    // make sure that it can be put into a dword 
    if( GetBerTag(*pCurrentPointer) != BER_TAG_BOOLEAN &&
        GetBerTag(*pCurrentPointer) != BER_TAG_INTEGER &&
        GetBerTag(*pCurrentPointer) != BER_TAG_ENUMERATED )
    {
        // it is not a type compatable with a dword
#ifdef DEBUG
        dprintf("BERGetInteger:Integer identifier not INT/BOOL/ENUM (0x%X)\n", 
                 GetBerTag(*pCurrentPointer));
#endif
        ReturnCode = FALSE;
    }

    // we will procede normally even if the identifier did not check out...
    pCurrentPointer++;

    //-------
    // LENGTH
    //-------
    // decode the length and step over it...
    if( BERGetLength( pCurrentPointer, ppValuePointer, pHeaderLength, pDataLength, ppNext)  == FALSE )
    {
        ReturnCode = FALSE;
    }

    // we are now done
    return ReturnCode;
}

//==========================================================================================================================
// BERGetString - given a pointer, decode it as a string
//==========================================================================================================================
BOOL _cdecl BERGetString( ULPBYTE  pCurrentPointer,
                          ULPBYTE *ppValuePointer,
                          LPDWORD pHeaderLength,
                          LPDWORD pDataLength,
                          ULPBYTE *ppNext)
{
    BOOL ReturnCode = TRUE;

    // ----------
    // IDENTIFIER
    // ----------
    // make sure that it is universal
    if( GetBerClass( *pCurrentPointer ) != BER_CLASS_UNIVERSAL )
    {
        // it is not universal
#ifdef DEBUG
        dprintf("BERGetString:String identifier not universal\n");
#endif
        ReturnCode = FALSE;
    }

    // make sure it is a primative
    if( GetBerForm(*pCurrentPointer) != BER_FORM_PRIMATIVE )
    {
        // it is not a primative
#ifdef DEBUG
        dprintf("BERGetString:String identifier not primative\n");
#endif
        ReturnCode = FALSE;
    }

    // make sure that it is a string type
    if( GetBerTag(*pCurrentPointer) != BER_TAG_BITSTRING &&
        GetBerTag(*pCurrentPointer) != BER_TAG_OCTETSTRING )
    {
        // it is not a type compatable with a dword
#ifdef DEBUG
        dprintf("BERGetString:String identifier not string type (0x%X)\n", 
                 GetBerTag(*pCurrentPointer));
#endif
        ReturnCode = FALSE;
    }

    // we will procede normally even if the identifier did not check out...
    pCurrentPointer++;

    //-------
    // LENGTH
    //-------
    // decode the length and step over it...
    if( BERGetLength( pCurrentPointer, ppValuePointer, pHeaderLength, pDataLength, ppNext) == FALSE )
    {
        ReturnCode = FALSE;
    }

    // we are now done
    return ReturnCode;
}

//==========================================================================================================================
// BERGetheader - given a pointer, decode it as a choice header
//==========================================================================================================================
BOOL _cdecl BERGetHeader( ULPBYTE  pCurrentPointer,
                          ULPBYTE  pTag,
                          LPDWORD pHeaderLength,
                          LPDWORD pDataLength,
                          ULPBYTE *ppNext)
{
    BOOL ReturnCode = TRUE;
    BYTE  Dummy;
    LPBYTE pDummy = &Dummy;

    // ----------
    // IDENTIFIER
    // ----------
    // make sure it is a constructed
   /* if( GetBerForm(*pCurrentPointer) != BER_FORM_CONSTRUCTED )
    {
        // it is not a constructed
#ifdef DEBUG
        dprintf("BERGetChoice:Choice identifier not constructed\n");
#endif
        ReturnCode = FALSE;
    } */

    // pull out the tag
    *pTag = GetBerTag(*pCurrentPointer);

    // we will procede normally even if the identifier did not check out...
    pCurrentPointer++;

    //-------
    // LENGTH
    //-------
    // decode the length and step over it...
    // note that the Next pointer being passed back is really a pointer to the
    // header contents
    if( BERGetLength( pCurrentPointer, ppNext, pHeaderLength, pDataLength, &pDummy) == FALSE )
    {
        ReturnCode = FALSE;
    }


    // we are now done
    return ReturnCode;
}

//==========================================================================================================================
// BERGetLength - given a pointer, decode it as the length portion of a BER entry
//==========================================================================================================================
BOOL BERGetLength( ULPBYTE pInitialPointer, 
                   ULPBYTE *ppContents, 
                   LPDWORD pHeaderLength,
                   LPDWORD pDataLength, 
                   ULPBYTE *ppNext)
{
    ULPBYTE pTemp;
    DWORD  ReturnCode = 0;
    DWORD  LengthLength;
    DWORD  i;

    // is this a marker for an indefinite (i.e. has an end marker)
    if( *pInitialPointer == BER_LEN_INDEFINITE )
    {
        // the header length is two (id and length bytes)
        *pHeaderLength = 2;

        // the contents start just after the marker
        *ppContents = pInitialPointer + 1;

        // walk to find 2 null or fault
        pTemp = pInitialPointer;
        try
        {
            do
            {
                // step to the next spot
                pTemp++;

            } while( *(pTemp)   != 0 ||
                     *(pTemp+1) != 0 );
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            // if we faulted, then pCurrent points to the last
            // legal spot
            // we can just fall thru
            // SUNDOWN HACK - cast to DWORD
            *pDataLength = (DWORD)(pTemp - *ppContents);
            *ppNext = pTemp;
            return FALSE;
        }

        // the last thing in this data is the second null byte
        // SUNDOWN HACK - cast to DWORD
        *pDataLength = (DWORD)((pTemp + 1) - *ppContents);

        // the next field will start after the second null
        *ppNext = pTemp+2;
        return TRUE;
    }

    // is this a definite short form (immediate) value
    if( GetBerLenInd( *pInitialPointer ) == BER_LEN_IMMEDIATE )
    {
        // this byte contains the length
        *pHeaderLength = 2;
        *pDataLength = GetBerLen( *pInitialPointer );
        *ppContents = pInitialPointer + 1;
        *ppNext = *ppContents + *pDataLength;
        return TRUE;
    }

    // this must be a definite long form (indirect) value,
    // it indicates how many bytes of length data follow
    LengthLength = GetBerLen( *pInitialPointer );

    // we can now calculate the header length:
    // 1 byte for id, 1 byte for the definite indicator, and x for the actual length
    *pHeaderLength = 1 + 1 + LengthLength;

    // move to the first byte of the true length
    pInitialPointer++;
    
    // the contents start just after the length
    *ppContents = pInitialPointer + LengthLength;

    // construct the value
    *pDataLength = 0;
    for( i = 0; i < LengthLength; i++)
    {
        // have we run over the size of a dword?
        if( i >= sizeof(DWORD) )
        {
            // this had better be a zero
            if( pInitialPointer[i] != 0 )
            {
#ifdef DEBUG
                dprintf("BERGetLength:Length Length too long to fit in a dword(0x%X)\n", 
                         LengthLength - i );
#endif
                *pDataLength = (DWORD)-1;
                *ppNext = pInitialPointer + *pDataLength;
                return FALSE;
            }

            // skip to the next one
            continue;
        }

        // we are still within a DWORD
        *pDataLength += pInitialPointer[i] << ((LengthLength - 1) - i );
    }

    // we escaped, no problems
    // the next field starts just after this one's content
    *ppNext = *ppContents + *pDataLength;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\netmon_parser\ldap_tags.c ===
#include "ldap.h"

// Length field identifiers
#define BER_LEN_IND_MASK        0x80
#define GetBerLenInd(x)         (x & BER_LEN_IND_MASK)
#define BER_LEN_IMMEDIATE       0x00
#define BER_LEN_INDEFINITE      0x80

#define BER_LEN_MASK            (BYTE)(~BER_LEN_IND_MASK)
#define GetBerLen(x)            (BYTE)(x & BER_LEN_MASK)

BYTE GetTag(ULPBYTE pCurrent)
{

    return pCurrent[0];

}

DWORD GetLength(ULPBYTE pInitialPointer, DWORD *LenLen)
{

  // we assume that the current pointer points at the length bytes
  // the first byte will either be the length or else it will be the
  // indicator for subsequent lengths.

    DWORD theLength = 0;
    DWORD tempLength = 0;
    BYTE  tLen;
    BYTE  i;

    *LenLen = 0;

    if(*pInitialPointer & BER_LEN_IND_MASK)
    {
        // this is going to contain many octets of length data
        tLen = GetBerLen(*pInitialPointer);
        if(tLen > sizeof(DWORD)) return (DWORD)0;
        
        // do some shifting. There are more efficient ways to do this
        for(i = 1; i<tLen; i++)
        {
            tempLength = pInitialPointer[i];
            theLength |= tempLength;
            theLength =  theLength << 8;
        }
        tempLength = pInitialPointer[tLen];
        theLength |= tempLength;


        *LenLen = tLen + 1;
        return theLength;
    }
    else
    {
        // the length is encoded directly
        *LenLen = 1;
        i = GetBerLen(*pInitialPointer);
        return (DWORD)i;
    }
}

LONG GetInt(ULPBYTE pCurrent, DWORD Length)
{
    ULONG   ulVal=0, ulTmp=0;
    ULONG   cbDiff;
    BOOL    fSign = FALSE;
    DWORD   dwRetVal;

    // We assume the tag & length have already been taken off and we're
    // at the value part.

    if (Length > sizeof(LONG)) {

        dwRetVal = 0x7FFFFFFF;
        return dwRetVal;
    }

    cbDiff = sizeof(LONG) - Length;

    // See if we need to sign extend;

    if ((cbDiff > 0) && (*pCurrent & 0x80)) {

        fSign = TRUE;
    }

    while (Length > 0)
    {
        ulVal <<= 8;
        ulVal |= (ULONG)*pCurrent++;
        Length--;
    }

    // Sign extend if necessary.
    if (fSign) {

        dwRetVal = 0x80000000;
        dwRetVal >>= cbDiff * 8;
        dwRetVal |= ulVal;

    } else {

        dwRetVal = (LONG) ulVal;
    }

    return dwRetVal;
}

BOOL AreOidsEqual(IN LDAPOID *String1, IN LDAPOID *String2)
{
    INT len;

    if ( String1->length == String2->length ) {
        for ( len = String1->length-1; len >= 0; len-- ) {
            if ( String1->value[len] != String2->value[len] ) {
                return FALSE;
            }
        }
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ldap\netmon_parser\ldapinit.c ===
//=================================================================================================================//
//  MODULE: LDAPinit.c
//
//  Description:
//
//  Attach properties for the BLOODHOUND LDAP Parser.
//
//  Modification History
//
//  Arthur Brooking     05/08/96        Created from PPP Parser
//=================================================================================================================//
#include "ldap.h"

extern ENTRYPOINTS LDAPEntryPoints;
extern HPROTOCOL hLDAP;

char    IniFile[INI_PATH_LENGTH];

//==========================================================================================================================
//  FUNCTION: DllMain()
//
//  Modification History
//
//  Arthur Brooking     05/08/96        Created from PPP Parser
//==========================================================================================================================
DWORD Attached = 0;


BOOL WINAPI DllMain(HANDLE hInst, ULONG ulCommand, LPVOID lpReserved)
{

    if (ulCommand == DLL_PROCESS_ATTACH)
    {
        if (Attached++ == 0)
        {
            hLDAP    = CreateProtocol("LDAP",     &LDAPEntryPoints, ENTRYPOINTS_SIZE);
            
            if (BuildINIPath(IniFile, "LDAP.DLL") == NULL)
            {

#ifdef DEBUG
                BreakPoint();
#endif
                return FALSE;
            }


        }                  
    }
    else if (ulCommand == DLL_PROCESS_DETACH)
    {
        if (--Attached == 0)
        {
            DestroyProtocol(hLDAP);
        }
    }
            
    return TRUE;

    //... Make the compiler happy.

    UNREFERENCED_PARAMETER(hInst);
    UNREFERENCED_PARAMETER(lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\boot\addobj.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1989 - 1999
//
//  File:       AddObj.cxx
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Adds the First set of objects to the DS
    Run during Install.

Author:

    Rajivendra Nath (RajNath) 07-07-96

Revision History:

--*/

#include <ntdspchX.h>

#include <schedule.h>       // new replication schedule format definitions

#include <sddlp.h>      //

#include "SchGen.hxx"

#define DEBSUB "ADDOBJ:"
extern "C"
{
    #include <permit.h>
    #include <ntdsa.h>
    #include <fileno.h>
    #include <drsuapi.h>
    #include <drserr.h>
    #include <mdlocal.h>
    #include <drancrep.h>      // For the draDecodeDraError... routine.
    #define  FILENO FILENO_ADDOBJ

    extern DWORD  dbCreateRoot();
    extern DWORD DBMoveObjectDeletionTimeToInfinite(DSNAME * pdsa);

    extern unsigned StringToOID ( char* Stroid, OID_t *Obj );
}

extern BOOL gInstallHasDoneSchemaMove;


NTSTATUS
AddOneObjectEx(
    IN NODE* NewNode,
    IN WCHAR* DN,
    IN UUID * pObjectGuid,
    IN BOOL fVerbose = TRUE
    );

VOID
FreeAttrBlk(
        ATTR* Attr,
        ULONG Count
        );

VOID
StrToAttrib (
        char*  strval,
        WCHAR *wstrval,
        ATTCACHE *pAC,
        UCHAR** ptr,
        DWORD&    siz);

DWORD
StrToOctet(char * String);

char*
PreProcessInifileShortcuts (
        char* strval,
        ATTCACHE* pAC,
        OUT  WCHAR **Widepp
        );

DWORD
AppendRDNStr(
    IN WCHAR *BaseName,
    IN unsigned ccBaseName,
    IN OUT WCHAR *NewName,
    IN unsigned ccNewName,
    IN WCHAR *Rdn,
    IN unsigned ccRdn,
    IN ATTRTYP AttrType
    );

BOOL
GetDefaultReplScheduleString (
        char *bData,
        ULONG cb
        );


// Define the default replication schedule header
SCHEDULE g_sched = {
    sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES,   // Size field
    0,                                          // Bandwidth
    1,                                          // NumberOfSchedules
    {
        SCHEDULE_INTERVAL,                      // Type
        sizeof(SCHEDULE),                       // Offset
    },
};

// Define the default intra-site replication interval in new format - once every
// hour.  Each byte in the data represents an hour of a week, lower 4 bits
// represent if replication takes place in each quarter of the hour, and the
// upper 4 bits are reserved for future use (7 * 24 = 168 entries).
//
// Note:- If you change this, please make sure that gpDefaultIntrasiteSchedule
//        definition in ds\src\kcc\kccmain.cxx is changed appropriately.
BYTE g_defaultSchedDBData[SCHEDULE_DATA_ENTRIES] =
{
    // 12 columns & 14 rows = 168
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,

    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,

    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,

    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
};

//
// This heap is meant for the InstallBaseNTDS routines to allocate
// from; at the end of InstallBaseNTDS the heap is destroyed.
// Note that the heap handle is set to NULL in DestroyInstallHeap so that
// it can be created again.
HANDLE ghInstallHeap = NULL;
SIZE_T gulInstallHeapSize = 0;

void
CreateInstallHeap(void)
{
    ghInstallHeap = RtlCreateHeap((HEAP_NO_SERIALIZE
                                   | HEAP_GROWABLE
                                   | HEAP_ZERO_MEMORY
                                   | HEAP_CLASS_1),
                                  0,
                                  32*1024*1024, // reserve 32M of VA
                                  409600, // initial size of 400K
                                  0,
                                  0);
    if (!ghInstallHeap) {
        XOUTOFMEMORY();
    }

}

void
DestroyInstallHeap(void)
{
    if (ghInstallHeap) {
        RtlDestroyHeap(ghInstallHeap);
        ghInstallHeap = NULL;

        DPRINT1(0, "Destroying Install Heap, size = 0x%x\n",
                gulInstallHeapSize);

        gulInstallHeapSize = 0;
    }
}

void
XFree(void *p)
{
#if DBG
    gulInstallHeapSize -= RtlSizeHeap(ghInstallHeap, 0, p);
#endif
    RtlFreeHeap(ghInstallHeap, 0, p);
}

PVOID
XCalloc(DWORD Num,DWORD Size)
{
    PVOID ret;

    if (!ghInstallHeap) {
        CreateInstallHeap();
    }

    ret=RtlAllocateHeap(ghInstallHeap, HEAP_ZERO_MEMORY, Num*Size);
    if (ret==NULL)
    {
        XOUTOFMEMORY();
    }

#if DBG
    gulInstallHeapSize += Size;
#endif

    return ret;
}

PVOID
XRealloc(PVOID IBuff,DWORD Size)
{
    PVOID ret;

#if DBG
    gulInstallHeapSize -= RtlSizeHeap(ghInstallHeap, 0, IBuff);
    gulInstallHeapSize += Size;
#endif

    ret=RtlReAllocateHeap(ghInstallHeap, 0, IBuff, Size);
    if (ret==NULL)
    {
        XOUTOFMEMORY();
    }
    return ret;
}

char*
XStrdup(char* str)
{
    ULONG len;
    char* s;


    if (!ghInstallHeap) {
        CreateInstallHeap();
    }

    len = strlen(str) + 1;
    s = (char*)RtlAllocateHeap(ghInstallHeap, 0, len*sizeof(char));
    if (s==NULL)
    {
        XOUTOFMEMORY();
    }
    memcpy(s, str, len);

#if DBG
    gulInstallHeapSize += len;
#endif

    return s;
}


WCHAR gDsaNode[MAX_PATH];
char gDsaname[64];
int  gfDsaNode=0;


WCHAR ggSchemaname[MAX_PATH];
char gSchemaname[64];
int  gfgSchemaname=0;


WCHAR *gNcCurrentlyCreating = NULL;
ULONG  gNcObjectsRemaining = 0;

VOID
UpdateCreateNCInstallMessage(
    IN WCHAR *NewNcToCreate,  OPTIONAL
    IN ULONG NcIndex
    )
//
// This function is one large hack o' rama and it works.
//
{

    ULONG DefaultNcCount[3] = {
                               1586,  // Schema
                               140,   // Config
                               13    // Domain
                               };
    if ( NewNcToCreate )
    {
        Assert( NcIndex < 3 );
        gNcObjectsRemaining = DefaultNcCount[NcIndex];
        gNcCurrentlyCreating = NewNcToCreate;
    }

    if ( gNcCurrentlyCreating )
    {
        WCHAR ObjectsRemainingString[32];

        if ( gNcObjectsRemaining > 0 )
        {
            gNcObjectsRemaining--;
        }

        _itow( gNcObjectsRemaining, ObjectsRemainingString, 10 );

        SetInstallStatusMessage( DIRMSG_INSTALL_CREATE_PROGRESS,
                                 gNcCurrentlyCreating,
                                 ObjectsRemainingString,
                                 NULL,
                                 NULL,
                                 NULL
                                 );

    }

}

//-----------------------------------------------------------------------
//
// Function Name:   WalkTree
//
// Routine Description:
//
//    Recursively creates the DIT
//
// Author: RajNath
//
// Arguments:
//
//    NODE* pNode,         Start Node
//    char* ParentPath,    DN of the parent
//
// Return Value:
//
//    int        Zero On Succeess
//
//-----------------------------------------------------------------------
NTSTATUS
WalkTree(
    IN NODE* pNode,
    IN WCHAR* Parentpath,
    IN BOOL fVerbose)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    static Depth=1;
    WCHAR *cpath;
    YAHANDLE     handle;
    NODE*        child;
    CLASSCACHE  *pCC;
    ULONG        ret;
    PWCHAR       pwbData;
    PWCHAR       pwbConfigAllocData = NULL;
    DWORD        cwbData;
    unsigned ccwstrval, ccParentpath, cccpath;

    child = pNode->GetNextChild(handle);
    while (child!=NULL)
    {
        WCHAR        *wstrval = NULL;

        Assert(NULL == pwbConfigAllocData);
        cpath = NULL;

        pCC = child->GetClass();

        //
        // Lets see if we need to read registry or env to get the Name
        //
        char* strval = child->GetRDNOfObject();

        if ( !strval ) {
           // no object-name specified in the section. Use the
           // section name itself as the RDN of the object. This
           // is ok as long as section names are unique
           strval = child->NodeName();
        }
        else {
           DPRINT1(1,"Picked up non-section-name RDN %s\n", strval);
        }

        if (strncmp(REGENTRY,strval,sizeof(REGENTRY)-1)==0)
        {
            LONG   err;
            DWORD  dwType = REG_SZ;
            PWCHAR RegistryName;

            if (0 == (cwbData =  MultiByteToWideChar(
                               CP_ACP,
                               MB_PRECOMPOSED,
                               &strval[sizeof(REGENTRY)-1],
                               -1,
                               NULL,
                               0)))

            {
                DPRINT2(0, "WalkTree: MultiByteToWideChar failed with %d, line %d\n", GetLastError(), __LINE__);
                return STATUS_UNSUCCESSFUL;
            }

            RegistryName = (PWCHAR) XCalloc(cwbData, sizeof(WCHAR));

            if ( (0 == MultiByteToWideChar(
                               CP_ACP,
                               MB_PRECOMPOSED,
                               &strval[sizeof(REGENTRY)-1],
                               -1,
                               RegistryName,
                               cwbData)))

            {
                DPRINT2(0, "WalkTree: MultiByteToWideChar failed with %d, line %d\n", GetLastError(), __LINE__);
                XFree(RegistryName); RegistryName = NULL;
                return STATUS_UNSUCCESSFUL;
            }

            err =  GetConfigParamAllocW(RegistryName,
                                        (PVOID*)&pwbConfigAllocData,
                                        &cwbData);

            XFree(RegistryName); RegistryName = NULL;

            if (err!=0)
            {
                DPRINT2(0, "Could Not Read Registry %s REG_SZ. Error %d\n",
                        &strval[sizeof(REGENTRY)-1],GetLastError());
                return STATUS_OBJECT_NAME_NOT_FOUND;
            }

            wstrval = (WCHAR*) pwbConfigAllocData;

        }
        else if (strncmp(ENVENTRY,strval,sizeof(ENVENTRY)-1)==0)
        {
            LONG   err;
            PWCHAR EnvVarName;

            if ( 0 == ( cwbData =  MultiByteToWideChar(
                               CP_ACP,
                               MB_PRECOMPOSED,
                               &strval[sizeof(ENVENTRY)-1],
                               -1,
                               NULL,
                               0)))

            {
                DPRINT2(0, "WalkTree: MultiByteToWideChar failed with %d, line %d\n", GetLastError(), __LINE__);
                return STATUS_UNSUCCESSFUL;
            }

            EnvVarName = (PWCHAR) XCalloc( cwbData, sizeof(WCHAR) );

            if ( (0 == MultiByteToWideChar(
                   CP_ACP,
                   MB_PRECOMPOSED,
                   &strval[sizeof(ENVENTRY)-1],
                   -1,
                   EnvVarName,
                   cwbData)))

            {
                DPRINT2(0, "WalkTree: MultiByteToWideChar failed with %d, line %d\n", GetLastError(), __LINE__);
                XFree(EnvVarName); EnvVarName = NULL;
                return STATUS_UNSUCCESSFUL;
            }

            cwbData = GetEnvironmentVariableW(EnvVarName,
                                         NULL,
                                         0);

            if (cwbData == 0 )
            {
                DPRINT1(0, "Could Not Read Environment Var %s \n",
                        &strval[sizeof(ENVENTRY)-1]);
                return STATUS_OBJECT_NAME_NOT_FOUND;
            }

            pwbData = (PWCHAR) XCalloc( cwbData, sizeof(WCHAR) );
            cwbData = GetEnvironmentVariableW(EnvVarName,
                                         pwbData,
                                         cwbData);

            XFree(EnvVarName); EnvVarName = NULL;

            if (cwbData == 0) {
                XFree(pwbData);
                DPRINT1(0, "Could Not Read Environment Var %s \n",
                        &strval[sizeof(ENVENTRY)-1]);
                return STATUS_OBJECT_NAME_NOT_FOUND;
            }
            
            wstrval = (PWCHAR) pwbData;
        }

        if ( !wstrval )
        {

            ccwstrval = MultiByteToWideChar(CP_ACP,
                                            MB_PRECOMPOSED,
                                            strval,
                                            -1,
                                            NULL,
                                            0);

            if (0 == ccwstrval) {
                DPRINT2(0, "WalkTree: MultiByteToWideChar failed with %d, line %d\n", GetLastError(), __LINE__);
                return STATUS_UNSUCCESSFUL;
            }

            wstrval = (PWCHAR) XCalloc(ccwstrval, sizeof(WCHAR));
            ccwstrval = MultiByteToWideChar(CP_ACP,
                                            MB_PRECOMPOSED,
                                            strval,
                                            -1,
                                            wstrval,
                                            ccwstrval);

            if (0 == ccwstrval) {
                DPRINT2(0, "WalkTree: MultiByteToWideChar failed with %d, line %d\n", GetLastError(), __LINE__);
                XFree(wstrval); wstrval = NULL;
                return STATUS_UNSUCCESSFUL;
            }
        }
        else {
            ccwstrval = wcslen(wstrval);
        }

        ccParentpath = wcslen(Parentpath);
        cccpath = ccParentpath + ccwstrval + 20;
        cpath = (WCHAR*)XCalloc(cccpath, sizeof(WCHAR));

        AppendRDNStr(Parentpath,
                     ccParentpath,
                     cpath,
                     cccpath,
                     wstrval,
                     ccwstrval,
                     pCC->RdnIntId);

        if (pwbConfigAllocData) {
            //
            // wstrval was originally allocated by GetConfigParamAlloc
            // So it must be free'd with free().
            //
            Assert(wstrval == pwbConfigAllocData);
            free(pwbConfigAllocData); pwbConfigAllocData = NULL;            
            wstrval = NULL;
        } else {
            XFree(wstrval); wstrval = NULL;
        }

        if (strcmp(child->m_NodeName,gDsaname)==0)
        {
            wcscpy(gDsaNode,cpath);
            gfDsaNode=TRUE;
            DPRINT1(1,"MACHINE-NODE = %s\n",gDsaNode);
        }
        else if (strcmp(child->m_NodeName,gSchemaname)==0)
        {

            wcscpy(ggSchemaname,cpath);
            gfgSchemaname=TRUE;
            DPRINT1(1,"Schema-NODE = %s\n",ggSchemaname);

        }

        NtStatus = AddOneObjectEx( child,
                                   cpath,
                                   NULL,
                                   fVerbose );

        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }

        UpdateCreateNCInstallMessage( NULL, 0 );  // Parameters are ignored

        HEAPVALIDATE
        Depth++;
        NtStatus = WalkTree(child,cpath,fVerbose);
        if (!NT_SUCCESS(NtStatus)) {
            XFree(cpath);
            return NtStatus;
        }
        Depth--;
        child = pNode->GetNextChild(handle);

        XFree(cpath);

    }

    return NtStatus;
}


#define MAX_ATTRIBUTES 256

//-----------------------------------------------------------------------
//
// Function Name:            AddOneObject
//
// Routine Description:
//
//    Adds one object to the dit
//
// Author: RajNath
//
// Arguments:
//
//    NODE* NewNode,       The Object to Add
//    char* DN,            The DN of the object
//    UUID * pObjectGuid   Pre-determined GUID for the object, or NULL
//
// Return Value:
//
//    NTSTATUS code indicating the nature of the error; STATUS_SUCCESS if
//    success
//
//-----------------------------------------------------------------------

NTSTATUS
AddOneObjectEx(
    IN NODE* NewNode,
    IN WCHAR* DN,
    IN UUID * pObjectGuid,
    BOOL fVerbose
    )
{
    NTSTATUS   NtStatus;
    ATTR       attarray[MAX_ATTRIBUTES];
    ADDARG     AddArg;
    BOOL       fFoundDeleted = FALSE;

    COMMARG*   pcarg = &AddArg.CommArg;
    PDSNAME    pdsa  = NULL;
    DWORD      cbSize;
    ATTRBLOCK* pABlk = &AddArg.AttrBlock;

    ZeroMemory(&AddArg, sizeof(AddArg));

    cbSize = (DWORD)DSNameSizeFromLen(wcslen(DN));
    pdsa = (PDSNAME) XCalloc( cbSize, 1 );    
    BuildDefDSName(pdsa,DN,pObjectGuid);
    
    AddArg.pObject = pdsa;

    pABlk->pAttr=attarray;
    ZeroMemory(attarray,sizeof(attarray));


    InitCommarg(pcarg);
    pcarg->fLazyCommit = 1;

    YAHANDLE yh;
    ATTCACHE* pAC;
    char* strval;
    ULONG count=0;
    while (pAC = NewNode->GetNextAttribute(yh,&strval))
    {
        if(pAC->id == ATT_IS_DELETED) {
            fFoundDeleted = TRUE;
        }
        CreateAttr(attarray,count,pAC,strval);
    }

    pABlk->attrCount=count;

    NtStatus = CallCoreToAddObj(&AddArg,fVerbose);

    if(NT_SUCCESS(NtStatus) && fFoundDeleted) {
        // We added a value of the is-deleted attribute.  In this case, call the
        // special routine to set the deletion time to INFINITE (i.e. if you
        // went to the trouble of adding a deleted object via this code path,
        // we assume you don't want it garbage collected.
        if(DBMoveObjectDeletionTimeToInfinite(pdsa)) {
            // Failed.
            XFree(pdsa); pdsa = NULL;
            return STATUS_UNSUCCESSFUL;
        }
    }

    XFree(pdsa);
    return NtStatus;
}

DWORD
RemoteAddOneObject(
    IN LPWSTR  pServerName,
    IN NODE  * NewNode,
    IN WCHAR * DN,
    OUT UUID  * pObjectGuid, OPTIONAL
    OUT NT4SID *pObjectSid   OPTIONAL
    )
//
// This function is used to add an NTDSA object only
//
{
    DWORD      err;
    PDSNAME    dsabuff;
    DWORD       cbSize;
    ATTR       attarray[MAX_ATTRIBUTES];
    YAHANDLE yh;
    ATTCACHE* pAC;
    char* strval;
    ULONG count=0;
    ENTINFLIST eiList;
    ADDENTRY_REPLY_INFO *infoList;
    GUID* guidList;
    NT4SID*  sidList;


    ZeroMemory(attarray,sizeof(attarray));

    cbSize = (DWORD)DSNameSizeFromLen(wcslen(DN));
    dsabuff = (PDSNAME) XCalloc(cbSize, 1);
    BuildDefDSName(dsabuff, DN, NULL);

    while (pAC = NewNode->GetNextAttribute(yh,&strval))
    {
        CreateAttr(attarray,count,pAC,strval);
    }

    RtlZeroMemory( &eiList, sizeof(eiList) );
    eiList.pNextEntInf = NULL;
    eiList.Entinf.pName = dsabuff;
    eiList.Entinf.ulFlags = 0;  //this is not used
    eiList.Entinf.AttrBlock.attrCount = count;
    eiList.Entinf.AttrBlock.pAttr = attarray;

    err =  I_DRSIsExtSupported(pTHStls,
                               pServerName,
                               DRS_EXT_POST_BETA3 );

    if ( err == ERROR_NOT_SUPPORTED ) {

        //
        // Ok, whack the server reference attribute
        //
        Assert( eiList.Entinf.AttrBlock.pAttr[count-1].attrTyp == ATT_SERVER_REFERENCE );
        eiList.Entinf.AttrBlock.attrCount--;
    }

    err =  RemoteAddOneObjectSimply(pServerName,
                                    NULL,
                                    &eiList,
                                    &infoList);

    if(pTHStls->errCode){
        // RemoteAddOneObjectSimply() sets the thread state error and
        // returns pTHS->errCode.  So crack out the real Win32 error
        // out of the thread error state, clear the errors and continue
        Assert(err == pTHStls->errCode);
        err = Win32ErrorFromPTHS(pTHStls);
        if(err == ERROR_DS_REMOTE_CROSSREF_OP_FAILED){
            // Note: Usually you can just use Win32ErrorFromPTHS(), but
            // if the remote side of the RemoteAddObject routine 
            // got a typical thread error state set, then this function
            // sets that this was a remote crossRef creation that failed in
            // the regular extendedErr and moves the error that caused the 
            // remote add op to fail in the extendedData field.
            err = GetTHErrorExtData(pTHStls);
        }
        Assert(err);
        THClearErrors();
    }
        

    if ( ERROR_SUCCESS == err ) {

        if ( pObjectGuid ) {
            *pObjectGuid = infoList[0].objGuid;
        }
        if ( pObjectSid ) {
            *pObjectSid = infoList[0].objSid;
        }

    }

    XFree(dsabuff);

    return err;
}

DWORD
RemoteAddOneObjectSimply(
    IN   LPWSTR pServerName,
    IN   SecBufferDesc * pClientCreds,
    IN   ENTINFLIST* pEntInfList,
    OUT  ADDENTRY_REPLY_INFO **infoList
    )
/*

  NOTE: This function now sets the thread state error and returns a
  pTHS->errCode.
  
*/
{
    THSTATE * pTHS = pTHStls;
    DRS_MSG_ADDENTRYREQ_V2 Req;
    DRS_MSG_ADDENTRYREPLY Reply;
    DWORD dwReplyVer;
    DWORD err;
    ULONG RetryMs;              // sleep time in milliseconds
    ULONG RetryTotalMs = 0;     // total of all sleeps in milliseconds
    ULONG RetryLimit = 100;     // in milliseconds
    ULONG RetryMaxMs = 60000;   // total of all sleeps cannot exceed 60 seconds

    Assert(pTHS);
    Req.EntInfList = *pEntInfList;

    DPRINT2(1,"About to add '%S' on server '%S'\n",
            Req.EntInfList.Entinf.pName->StringName,
            pServerName);

    err = I_DRSAddEntry(pTHS,
                        pServerName,
                        (DRS_SecBufferDesc *) pClientCreds,
                        &Req,
                        &dwReplyVer,
                        &Reply);
    // In a few cases, retry for a bit if BUSY is returned
    while ( TRUE ){
        // Continues on until we break from this if/else
        //   We break if we have an error that isn't BUSY
        //   or if we've tried for too long.

        if (err) {
            // We've hit a critical error, we couldn't even reach
            // the server, so break.
            break;
        }

        if(dwReplyVer == 2){           
            // Win2k response, determine if not busy, then break.
            if(! (Reply.V2.problem == SV_PROBLEM_BUSY &&
                  (Reply.V2.extendedErr == DIRERR_DATABASE_ERROR ||
                   Reply.V2.extendedErr == ERROR_DS_BUSY) &&
                  RetryTotalMs < RetryMaxMs) ){
                // Don't retry.
                break;
            }

        } else if(dwReplyVer == 3){
            
            if(Reply.V3.dwErrVer != 1){
                Assert(!"Unknown error version!");
                break;
            }
            if(Reply.V3.pErrData == NULL){
                // This means the the DRS_AddEntry call failed because
                // the DC was shutting down or out of memory.
                break;
            }
            if(Reply.V3.pErrData->V1.errCode && (Reply.V3.pErrData->V1.pErrInfo == NULL) ){
                Assert(!"We've got a bad error message.  Bailing.");
                // Be cool if we kept track of the DSID as well.
                err = ERROR_DS_CODE_INCONSISTENCY;
                break;
            }
            if(! (Reply.V3.pErrData->V1.errCode == serviceError &&
                  Reply.V3.pErrData->V1.pErrInfo->SvcErr.problem == SV_PROBLEM_BUSY &&
                  (Reply.V3.pErrData->V1.pErrInfo->SvcErr.extendedErr == DIRERR_DATABASE_ERROR ||
                   Reply.V3.pErrData->V1.pErrInfo->SvcErr.extendedErr == ERROR_DS_BUSY) &&
                  RetryTotalMs < RetryMaxMs )
                  ){
                // if not busy break
                break;
            }

        } else {
            Assert(!"Code Inconsistency!");
            // Punt the error ... but do set an error!
            err = ERROR_DS_CODE_INCONSISTENCY;
        }

        // Compute milliseconds to sleep before retry.
        srand((UINT)GetTickCount());
        RetryMs = rand() % RetryLimit;

        // Double the limit on each retry
        RetryLimit <<= 1;

        // Total of all sleeps can't exceed RetryMaxMs (60 seconds)
        RetryTotalMs += RetryMs;
        if (RetryTotalMs > RetryMaxMs) {
            RetryMs -= RetryTotalMs - RetryMaxMs;
        }

        // Wait a bit and then retry the remote operation
        DPRINT2(0, "REMOTE RETRY AddEntry(%ws) in %d msecs.\n",
                Req.EntInfList.Entinf.pName->StringName,
                RetryMs);
        Sleep(RetryMs);
        err = I_DRSAddEntry(pTHS,
                            pServerName,
                            (DRS_SecBufferDesc *) pClientCreds,
                            &Req,
                            &dwReplyVer,
                            &Reply);
    }

    if (err) {
        
        // Got an error on the local repl API side or we couldn't understand
        // the reply packet (like if the error state wasn't correct), set an
        // intelligent error in the extendedErr, and specify it was from the 
        // DRA in the extendedData.
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                    err);

    } else {

        // We at least got to the remote side ... so if there is an
        // error it needs to be gotten out of the reply message.
        if(dwReplyVer == 2){

            // This is OK to do, because the only time we get a reply
            // of version 2, is from a Win2k box, so this must be dcpromo
            // calling us, so we know that they're just going to look 
            // at the extended error and return it.
            if (Reply.V2.errCode ||
                Reply.V2.extendedErr ||
                Reply.V2.extendedData ||
                Reply.V2.dsid ) {

                Assert(Reply.V2.errCode && Reply.V2.extendedErr);
                // If there was an error
                SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                            Reply.V2.extendedErr);

            }
            DPRINT7(0, "Win2k RemoteAddEntry(%ws). Error %d, errCode %d, extData %d, problem %d, extErr %d, dsid %08x\n",
                    Req.EntInfList.Entinf.pName->StringName,
                    err,
                    Reply.V2.errCode,
                    Reply.V2.extendedData,
                    Reply.V2.problem,
                    Reply.V2.extendedErr,
                    Reply.V2.dsid);

        } else if(dwReplyVer == 3){

            // The unpacking and setting of the thread state error all
            // happens in this function.
            draDecodeDraErrorDataAndSetThError(Reply.V3.dwErrVer, 
                                               Reply.V3.pErrData, 
                                               ERROR_DS_REMOTE_CROSSREF_OP_FAILED,
                                               pTHS);

        }
    }

    // We should have ALOT more helpful information than we reported in Win2k!
    DPRINT7(1, "RemoteAddEntry(%ws), Error %d, dwRepError = %d, errCode %d, extErr %d, extData %d, dsid %08x\n",
            Req.EntInfList.Entinf.pName->StringName,
            err,
            (dwReplyVer == 3 && Reply.V3.pErrData) ? Reply.V3.pErrData->V1.dwRepError : 0,
            pTHS->errCode,
            Win32ErrorFromPTHS(pTHS),
            GetTHErrorExtData(pTHS),
            GetTHErrorDSID(pTHS)
            );

    if ( ERROR_SUCCESS == err ) {
        if ( infoList ) {
            *infoList = (dwReplyVer == 3) ? Reply.V3.infoList : Reply.V2.infoList;
        }
    } else {
        DPRINT2(0,"RemoteAdd failed, extended error was %u, DSID %08X\n",
                Win32ErrorFromPTHS(pTHStls),
                GetTHErrorDSID(pTHStls)
                );
    }

    return(pTHS->errCode);
}

//-----------------------------------------------------------------------
//
// Function Name:            BuildDefDSName
//
// Routine Description:
//
//    Builds a DSNAME from char*
//
// Author: RajNath
//
// Arguments:
//
//    PDSSNAME pDsa ,              Returned DSNAME, Its preallocaterd
//    char* DN             The name
//    GUID* guid               The Guid [Optional]
//
// Return Value:
//
//    VOID             No Return
//
//-----------------------------------------------------------------------

VOID
BuildDefDSName(PDSNAME pDsa,char* DN,GUID* guid)
{
    pDsa->NameLen  =strlen(DN);
    pDsa->structLen=DSNameSizeFromLen(pDsa->NameLen);

    MultiByteToWideChar(CP_ACP,
                        0,
                        DN,
                        pDsa->NameLen,
                        pDsa->StringName,
                        pDsa->NameLen);

    pDsa->StringName[pDsa->NameLen]=L'\0';

    if (guid) {
        CopyMemory(&(pDsa->Guid),guid,sizeof(GUID));
    }
    else {
        memset(&pDsa->Guid, 0, sizeof(GUID));
    }
    pDsa->SidLen = 0;
}

//-----------------------------------------------------------------------
//
// Function Name:            BuildDefDSName
//
// Routine Description:
//
//    Builds a DSNAME from char*
//
// Author: RajNath
//
// Arguments:
//
//    PDSSNAME pDsa ,              Returned DSNAME, Its preallocaterd
//    WCHAR* DN             The name
//    GUID* guid               The Guid [Optional]
//
// Return Value:
//
//    VOID             No Return
//
//-----------------------------------------------------------------------
VOID
BuildDefDSName(PDSNAME pDsa,WCHAR* DN,GUID* guid)
{
    pDsa->NameLen  =wcslen(DN);
    pDsa->structLen=DSNameSizeFromLen(pDsa->NameLen);

    wcscpy(pDsa->StringName,DN);
    pDsa->StringName[pDsa->NameLen]=L'\0';

    if (guid) {
        CopyMemory(&(pDsa->Guid),guid,sizeof(GUID));
    }
    else {
        memset(&pDsa->Guid, 0, sizeof(GUID));
    }
    pDsa->SidLen = 0;
}

//
unsigned cssdcSavedLen = 0;
char *   cssdcSavedStr = NULL;
PSECURITY_DESCRIPTOR cssdcSavedSD = NULL;
ULONG    cssdcSavedSize = 0;

BOOL
CachedStringSDConverter(char *strval,
                        PSECURITY_DESCRIPTOR *ppbuf,
                        ULONG *posiz)
{
    unsigned len;
    BOOL flag;

    len = strlen(strval);

    if (   (len == cssdcSavedLen)
        && (0 == memcmp(strval, cssdcSavedStr, len))) {
        // We can use the existing cached SD
        flag = TRUE;
    }
    else {
        // Not the same SD as last time, so cache a new one.
        if (cssdcSavedSD) {
            LocalFree(cssdcSavedSD);
        }
        if (cssdcSavedStr) {
            LocalFree(cssdcSavedStr);
            cssdcSavedStr = NULL;
        }
        flag = ConvertStringSDToSDRootDomainA
          (
           gpRootDomainSid,
           strval,
           SDDL_REVISION_1,
           &cssdcSavedSD,
           &cssdcSavedSize
           );
        if (flag) {
            // if we succeeded, remember the arguments
            cssdcSavedStr = (char *) LocalAlloc(0, len);
            if (cssdcSavedStr) {
                cssdcSavedLen = len;
                memcpy(cssdcSavedStr, strval, len);
            }
            else {
                cssdcSavedLen = 0;
            }
        }
        else {
            // if we failed, forget everything
            cssdcSavedSD = NULL;
            cssdcSavedLen = 0;
            cssdcSavedStr = NULL;
        }
    }

    if (flag) {
        // No matter how we got here, if flag is set then we want to copy
        // the cached SD.
        *ppbuf = LocalAlloc(0, cssdcSavedSize);
        if (*ppbuf) {
            memcpy(*ppbuf, cssdcSavedSD, cssdcSavedSize);
            *posiz = cssdcSavedSize;
        }
        else {
            flag = FALSE;
        }
    }
    return flag;
}
//

//-----------------------------------------------------------------------
//
// Function Name:            CreateAttr
//
// Routine Description:
//
//    Converts a string to its actual type
//
// Author: RajNath
//
// Arguments:
//
//    ATTR* attr,              OUT value, Preallocated space
//    ULONG ndx,               Counter - IN OUT Param
//    ATTCACHE* pAC,           The Attribute class of this string
//    strval,                  String representation of the attribute value
//
//
//
// Return Value:
//
//    VOID             No Return, Exception on Failure
//
//-----------------------------------------------------------------------

VOID
CreateAttr(ATTR* attr,ULONG& ndx,ATTCACHE* pAC,char* strval)
{
    THSTATE *pTHS = pTHStls;
    UCHAR* obuf;
    ULONG  osiz;
    WCHAR  *Widepp = NULL;

    //
    // Some Syntaxes need to be preprocessed becuase they are in
    // a human readable form...eg OM_S_OBJECT_IDENTIFIER_STRING
    //
    char* pp=PreProcessInifileShortcuts(strval,pAC, &Widepp);


    //
    // Some Attributes need to be preprocessed becuase they are in
    // a human readable form...eg ATT_NT_SECURITY_DESCRIPTOR
    //
    switch (pAC->id) {
    case ATT_SCHEMA_ID_GUID:
    case ATT_ATTRIBUTE_SECURITY_GUID:
        {
            // Need to byte swap (character swap) the string for little
            // endian machine representation.  Note that we use the
            // string directly w/o swapping when generating ntdsguid.c
            // which is correct as the compiler will do the swap when
            // constructing the static value.

            // To be clear - the values in schema.ini are generated
            // programatically by UuidCreate() followed by UuidToString()
            // and the resulting string is written to schema.ini.
            // UuidToString already does the byte swap so that with
            // the insertion of require braces and commas, the string
            // can be used as a static initializer - as we do in ntdsguid.c.
            // However, byte swapping is required in order to construct
            // an array of bytes which will be identical to the array
            // of bytes found in memory for something created via the
            // static initializer.

            DWORD   i;
            CHAR    c;

            // Validate string.

            Assert((34 == strlen(strval)) &&
                   ('\\' == strval[0]) &&
                   (('x' == strval[1]) || ('X' == strval[1])));

            for ( i = 2; i < 34; i++ )
            {
                c = strval[i];

                Assert(((c >= '0') && (c <= '9')) ||
                       ((c >= 'a') && (c <= 'f')) ||
                       ((c >= 'A') && (c <= 'F')))
            }

            // Do the swap.  String representation requires two bytes per
            // byte of resulting data, thus alias a USHORT array on top
            // of the string data.

            USHORT *data = (USHORT *) &strval[2];
            USHORT us;

            us = data[3];
            data[3] = data[0];
            data[0] = us;
            us = data[2];
            data[2] = data[1];
            data[1] = us;
            us = data[5];
            data[5] = data[4];
            data[4] = us;
            us = data[7];
            data[7] = data[6];
            data[6] = us;

            StrToAttrib(strval, NULL, pAC, &obuf,osiz);
        }

        break;

    case ATT_NT_SECURITY_DESCRIPTOR:
        {
            DWORD err;
            BOOL  flag = TRUE;
            WCHAR strsecdesc[1024];

            flag = CachedStringSDConverter(strval,
                                           (PSECURITY_DESCRIPTOR*)&obuf,
                                           &osiz);

            if (!flag)
            {
                err = GetLastError();
                DPRINT2(0,
                        "Security descriptor(%s) conversion failed, error %x\n",
                        strval,err);
                XINVALIDINIFILE();
            }

            UCHAR* buff=(UCHAR*)XCalloc(1,osiz);
            CopyMemory(buff,obuf,osiz);

            LocalFree(obuf); // Converted SD is LocalAlloced
            obuf=buff;
        }
        break;
    case ATT_OBJECT_CATEGORY:
    case ATT_DEFAULT_OBJECT_CATEGORY:
        {
            // These two attributes are DS-DN syntaxed, but in schema.ini,
            // they are just specified as the cn. We need to form the whole
            // DN before we pass it off


            PWCHAR pwbBuf;
            DWORD  cwbBufSize;
            PWCHAR pTmpBuf = NULL;
            DWORD  tmpSize = 0;
            DWORD  err;
            int i = 0;


            //
            // First need to allocate a buffer of appropriate size.  Start by
            // counting the sizes of all the parts in characters.
            //
            cwbBufSize = sizeof("CN=,");

            if (!gInstallHasDoneSchemaMove) {
                cwbBufSize += sizeof("CN=Schema,O=Boot");
            } else {
                err = GetConfigParamAllocW(MAKE_WIDE(SCHEMADNNAME), (PVOID *)&pTmpBuf, &tmpSize);
                if (ERROR_OUTOFMEMORY == err) {
                    DPRINT(0, "GetConfigParamAlloc could not allocate enough memory.\n");
                    XOUTOFMEMORY();
                } else if (err) {
                    DPRINT1(0,
                            "GetConfigParam failed, error 0x%x\n",
                            err);
                    XINVALIDINIFILE();
                }
                Assert(!(tmpSize % 2));  // Should get an even number of bytes
                                         // since we are expecting a Wide Char string.
                cwbBufSize += tmpSize / sizeof(WCHAR);
            }

            // 
            // tmpSize will be in characters this time.
            //
            tmpSize = MultiByteToWideChar(CP_ACP,
                                          0,
                                          strval,
                                          strlen(strval),
                                          NULL,
                                          0);
            if (0 == tmpSize) {
                DPRINT1(0,
                        "MultiByteToWideChar failed, error 0x%x\n",
                        GetLastError());
                if (pTmpBuf) free(pTmpBuf);
                XINVALIDINIFILE();
            }

            cwbBufSize += tmpSize;

            //
            // Now allocate the buffer.
            //
            pwbBuf = (PWCHAR) XCalloc(cwbBufSize, sizeof(WCHAR));
            
            wcscpy(pwbBuf, L"CN=");
            i += 3;
            MultiByteToWideChar(CP_ACP,
                                0,
                                strval,
                                strlen(strval),
                                &pwbBuf[i],
                                cwbBufSize - 3);
            i += strlen(strval);
            wcscpy(&pwbBuf[i++],L",");
            if(!gInstallHasDoneSchemaMove) {
                // The schema is still in the boot dit configuration.  Hardcode
                // the boot schema dn
                wcscpy(&pwbBuf[i],L"CN=Schema,O=Boot");
            }
            else {
                wcscpy(&pwbBuf[i],pTmpBuf);
                free(pTmpBuf); pTmpBuf = NULL;
            }

            // Ok, we have a null-terminated string. Now pass this
            // to StrToAttrib
            StrToAttrib(NULL, pwbBuf, pAC, &obuf,osiz);
            XFree(pwbBuf);
        }
        break;

    default:
        {
            if ( Widepp )
            {
                pp = NULL;
            }

            StrToAttrib(pp, Widepp, pAC, &obuf,osiz);
        }
        break;
    }


    //
    // See if we already have a ATTR for this type
    //
    for (ULONG i=0;i<ndx;i++)
    {
        if (pAC->id==attr[i].attrTyp)
        {
            attr[i].AttrVal.pAVal=
                (ATTVAL*)XRealloc(attr[i].AttrVal.pAVal,
                                  (attr[i].AttrVal.valCount+1)*sizeof(ATTRVAL));
            break;
        }
    }

    if (i==ndx)
    {
        attr[i].AttrVal.pAVal=(ATTVAL*)XCalloc(1,sizeof(ATTRVAL));
        ndx++;
    }

    attr[i].attrTyp=pAC->id;
    attr[i].AttrVal.pAVal[attr[i].AttrVal.valCount].pVal=obuf;
    attr[i].AttrVal.pAVal[attr[i].AttrVal.valCount].valLen=osiz;

    if ( ATT_INVOCATION_ID == attr[i].attrTyp )
    {
        // rajnath : dirty hack to fix Invocation-ID on machine object
        memcpy(attr[i].AttrVal.pAVal[attr[i].AttrVal.valCount].pVal,
               &pTHS->InvocationID,
               sizeof(pTHS->InvocationID));
    }

    attr[i].AttrVal.valCount++;
}


//-----------------------------------------------------------------------
//
// Function Name:            FreeAttrBlock
//
// Routine Description:
//
//    Frees memory associated with a AttrBlock
//
// Author: RajNath
//
// Arguments:
//
//
// Return Value:
//
//    VOID             No Return
//
//-----------------------------------------------------------------------

VOID FreeAttrBlk(ATTR* Attr,ULONG Count)
{
    for (ULONG i=0;i<Count;i++)
    {
        for (ULONG j=0;j<Attr[i].AttrVal.valCount;j++)
        {
            XFree(Attr[i].AttrVal.pAVal[j].pVal);
        }
        XFree(Attr[i].AttrVal.pAVal);
    }
}



//-----------------------------------------------------------------------
//
// Function Name:            StrToAttrib
//
// Routine Description:
//
//    Helper Function for converting String Value into  its proper type
//    Now even handles useful input strings.
//
// Arguments:
//
//    char* strval             The string value
//    DWORD omsyntax               OM Syntax of the attribute
//    DWORD syntax,            Syntax
//    UCHAR** ptr,             Returned value
//    DWORD& siz               The size of the returned value
//
//
// Return Value:
//
//    VOID             No Return, Exception on failure
//
//-----------------------------------------------------------------------

VOID StrToAttrib
(
   char*     strval,
   WCHAR*    wstrval,
   ATTCACHE  *pAC,
   UCHAR**   ptr,
   DWORD&    siz
)
{

    PWCHAR Buffer2 = NULL;
    PCHAR  IntegerBuffer = NULL;
    DWORD size;

    if ( pAC->OMsyntax == OM_S_OBJECT )
    {
        //
        // This function supports only wide characters for object names
        //
        if ( !wstrval )
        {
            //
            // Make the string wide char
            //
            size = MultiByteToWideChar(CP_ACP,
                                       0,
                                       strval,
                                       -1,
                                       NULL,
                                       0);

            if (0 == size) {
                DPRINT2(0, "StrToAttrib: MultiByteToWideChar failed with %d, line %d\n", GetLastError(), __LINE__);
                XINVALIDINIFILE();
            }
            
            Buffer2 = (PWCHAR) XCalloc(size, sizeof(WCHAR));

            MultiByteToWideChar(CP_ACP,
                                0,
                                strval,
                                -1,
                                Buffer2,
                                size);
            wstrval = Buffer2;

        }
    }
    else if ( pAC->OMsyntax == OM_S_UNICODE_STRING )
    {
        // This function supports both for unicode string
        Assert( wstrval || strval );
    }
    else if ( pAC->OMsyntax == OM_S_INTEGER )
    {
        // Convert to mbcs if necessary. 
        if (strval == NULL) {

            DWORD ret;
            Assert(wstrval);
            size = wcslen(wstrval);
            IntegerBuffer = (PCHAR) XCalloc(size + 1, sizeof(CHAR));
            ret = (DWORD) wcstombs(IntegerBuffer, 
                                   wstrval, 
                                   (size+1) * sizeof(CHAR));
            if (ret != (size * sizeof(CHAR))) {
                XINVALIDINIFILE();
            }
            strval = IntegerBuffer;
        }
    }
    else
    {
        //
        // This function supports only ascii for other types
        //
        Assert( NULL == wstrval );
        Assert( strval );
    }


    switch(pAC->OMsyntax)
    {

        case OM_S_BOOLEAN:
        case OM_S_INTEGER:
        case OM_S_ENUMERATION:
        {

            /* all basically integers */
            *ptr=(UCHAR*)XCalloc(1,sizeof(SYNTAX_INTEGER));
            // first, find the sign
            if(*strval == '-') {
                *((LONG *)(*ptr)) = strtol(strval, (char **)NULL, 0);
            }
            else {
                *((ULONG *)(*ptr)) = strtoul(strval, (char**)NULL, 0);
            }
            siz=sizeof(SYNTAX_INTEGER);
        }
        break;

        case OM_S_I8:
        {
          /* Large Interger */
            int len;
            SYNTAX_I8 *pInt;
            LONG sign=1;
            int i;

            *ptr=(UCHAR*)XCalloc(1,sizeof(SYNTAX_I8));
            pInt = (SYNTAX_I8 *)(*ptr);
            len = strlen(strval);

            pInt->QuadPart = 0;
            i=0;
            if(strval[i] == '-') {
                sign = -1;
                i++;
            }

            if(i==len) {
                //  no string, or just a '-'
                XINVALIDINIFILE();
            }

            for(;i<len;i++) {
                // Parse the string one character at a time to detect any
                // non-allowed characters.
                if((strval[i] < '0') || (strval[i] > '9')) {
                   XINVALIDINIFILE();
                }

                pInt->QuadPart = ((pInt->QuadPart * 10) +
                                  strval[i] - '0');
            }
            pInt->QuadPart *= sign;

            siz=sizeof(SYNTAX_I8);
        }
        break;

        case OM_S_OCTET_STRING:
        {

            OID_t Obj;

            if (StringToOID(strval,&Obj))
            {
                XINVALIDINIFILE();
            }

            *ptr = (UCHAR*)Obj.elements;
            siz  = Obj.length;
        }
        break;

        case OM_S_OBJECT_IDENTIFIER_STRING:
        {

            ATTRTYP at;
            if (OidStrToAttrType(pTHStls, TRUE, strval, &at))
            {
                XINVALIDINIFILE();
            }

            *ptr=(UCHAR*)XCalloc(1,sizeof(ULONG));
            *(ULONG *)(*ptr)=at;
            siz=sizeof(ULONG);
        }
        break;


        case OM_S_TELETEX_STRING:
        case OM_S_IA5_STRING:
        case OM_S_PRINTABLE_STRING:
        {

            *ptr = (UCHAR*)XStrdup(strval);
             siz = strlen(strval);
        }
        break;

        case OM_S_UNICODE_STRING:
        {
            WCHAR* wide;
            ULONG  Length;

            if ( wstrval )
            {
                Length = wcslen( wstrval );
                wide= (WCHAR*) XCalloc(1, (Length+1)*sizeof(WCHAR) );
                wcscpy( wide, wstrval );
            }
            else
            {
                Assert( strval );
                Length = strlen( strval );
                wide= (WCHAR*) XCalloc(1, (Length+1)*sizeof(WCHAR) );
                MultiByteToWideChar(CP_ACP,
                                    0,
                                    strval,
                                    Length + 1,
                                    wide,
                                    Length + 1);
            }

            *ptr = (UCHAR*)wide;
             siz = sizeof(WCHAR)*Length;
        }
        break;

        case OM_S_OBJECT:
        {

            switch(pAC->syntax) {
            case SYNTAX_DISTNAME_BINARY_TYPE:
                {
                    PDSNAME pdsn=NULL;
                    SYNTAX_DISTNAME_STRING* pDN_Addr;
                    ULONG stringLength=0;
                    SYNTAX_ADDRESS *pAddress=NULL;
                    ULONG i,j;
                    BOOL fDone=FALSE;

                    // Get the length of the string portion

                    for(i=0;!fDone && i<wcslen(wstrval);i++) {
                        // Parse the string one character at a time to detect
                        // any non-allowed characters.
                        if(wstrval[i] == L':') {
                            fDone = TRUE;
                            continue;
                        }

                        if(!(((wstrval[i] >= L'0') && (wstrval[i] <= L'9')) ||
                             ((wstrval[i] >= L'a') && (wstrval[i] <= L'f')) ||
                             ((wstrval[i] >= L'A') && (wstrval[i] <= L'F')))) {
                            XINVALIDINIFILE();
                        }

                        stringLength = (stringLength * 10) + wstrval[i] - L'0';
                    }
                    if(!fDone) {
                        // Didn't find the ':'
                        XINVALIDINIFILE();
                    }

                    // Make sure there is a ':' between the string and the dn
                    if(wstrval[i+stringLength] != L':') {
                        XINVALIDINIFILE();
                    }


                    if(stringLength & 1) {
                        // This must be even
                        XINVALIDINIFILE();
                    }
                    stringLength /= 2;

                    // Now, get the string
                    pAddress = (SYNTAX_ADDRESS *)
                        XCalloc(1, STRUCTLEN_FROM_PAYLOAD_LEN( stringLength ));




                    for(j=0;j<stringLength;j++, i += 2) {
                        // get the next two characters as a byte.
                        WCHAR acTmp[3];

                        acTmp[0] = towlower(wstrval[i]);
                        acTmp[1] = towlower(wstrval[i +  1 ]);
                        acTmp[2] = L'\0';

                        if(iswxdigit(acTmp[0]) && iswxdigit(acTmp[1])) {
                            pAddress->byteVal[j] = (UCHAR)wcstol(acTmp,
                                                                 NULL,
                                                                 16);
                        }
                        else {
                            XINVALIDINIFILE();
                        }
                    }

                    pAddress->structLen = STRUCTLEN_FROM_PAYLOAD_LEN( stringLength );
                    // Now, the DSNAME


                    i++;
                    
                    size = (DWORD)DSNameSizeFromLen(wcslen(&wstrval[i]));
                    pdsn = (PDSNAME) XCalloc(1, size);
                    BuildDefDSName(pdsn,&wstrval[i],NULL);

                    // Now, synthesize

                    pDN_Addr = (SYNTAX_DISTNAME_STRING*)
                        XCalloc(1,
                                (USHORT)DERIVE_NAME_DATA_SIZE(pdsn, pAddress));

                    BUILD_NAME_DATA( pDN_Addr, pdsn, pAddress );

                    *ptr = (UCHAR*)pDN_Addr;
                    siz  = (USHORT)DERIVE_NAME_DATA_SIZE(pdsn, pAddress);
                    XFree(pdsn);
                }

                break;

                case SYNTAX_DISTNAME_STRING_TYPE:
                {

                    Assert(!"SYNTAX_DISTNAME_STRING_TYPE not supported");
                    XINVALIDINIFILE();
#if 0
// Obviously this code has never been tested (See above assert), but I
// am leaving it in as a useful starting point if this functionality is
// ever needed. But be careful, the code does not support UNICODE chars.

                    PDSNAME pdsn=NULL;
                    SYNTAX_DISTNAME_STRING* pDN_Addr;
                    ULONG stringLength=0;
                    SYNTAX_ADDRESS *pAddress=NULL;
                    ULONG i;
                    BOOL fDone=FALSE;

                    // Get the length of the string portion

                    for(i=0;!fDone && i<strlen(strval);i++) {
                        // Parse the string one character at a time to detect
                        // any non-allowed characters.
                        if(strval[i] == ':') {
                            fDone = TRUE;
                            continue;
                        }

                        stringLength = (stringLength * 10) + strval[i] - '0';
                    }
                    if(!fDone) {
                        // Didn't find the ':'
                        XINVALIDINIFILE();
                    }

                    // Make sure there is a ':' between the string and the dn
                    if(strval[i+stringLength] != ':') {
                        XINVALIDINIFILE();
                    }


                    // Now, get the string
                    pAddress = (SYNTAX_ADDRESS *)
                        XCalloc(1, STRUCTLEN_FROM_PAYLOAD_LEN( stringLength ));


                    // What is stringLength ???

                    memcpy(pAddress->uVal,
                           &wstrval[i],
                           stringLength);

                    pAddress->structLen = STRUCTLEN_FROM_PAYLOAD_LEN( stringLength );

                    // Now, the DSNAME


                    size = DSNameSizeFromLen(strlen(&strval[i + stringLength + 1]));
                    pdsn = XCalloc(1, size);

                    BuildDefDSName(pdsn,&strval[i + stringLength + 1],NULL);

                    // Now, synthesize

                    pDN_Addr = (SYNTAX_DISTNAME_STRING*)
                        XCalloc(1,
                                (USHORT)DERIVE_NAME_DATA_SIZE(pdsn, pAddress));

                    BUILD_NAME_DATA( pDN_Addr, pdsn, pAddress );

                    *ptr = (UCHAR*)pDN_Addr;
                    siz  = (USHORT)DERIVE_NAME_DATA_SIZE(pdsn, pAddress);
                    XFree(pdsn);
#endif 0 SYNTAX_DISTNAME_STRING_TYPE NOT SUPPORTED
                }
                break;

            case SYNTAX_ADDRESS_TYPE:
                {
                    Assert(!"SYNTAX_ADDRESS_TYPE not supported");
                    XINVALIDINIFILE();
#if 0
// Obviously this code has never been tested (See above assert), but I
// am leaving it in as a useful starting point if this functionality is
// ever needed.

                    SYNTAX_ADDRESS* pNodeAddr=(SYNTAX_ADDRESS*)
                        XCalloc(1, STRUCTLEN_FROM_PAYLOAD_LEN( 0 ));

                    pNodeAddr->structLen = STRUCTLEN_FROM_PAYLOAD_LEN( 0 );

                    *ptr = (UCHAR*)pNodeAddr;
                    siz  = STRUCTLEN_FROM_PAYLOAD_LEN( 0 );
#endif 0 SYNTAX_ADDRESS_TYPE NOT SUPPORTED
                }
                break;

            case SYNTAX_DISTNAME_TYPE:
                {
                    ULONG namelen=wcslen(wstrval)+1;
                    ULONG strulen=DSNameSizeFromLen( namelen );

                    PDSNAME ds=(PDSNAME)XCalloc(1,strulen);

                    BuildDefDSName(ds,wstrval,NULL);
                    *ptr=(UCHAR*)ds;
                    siz=strulen;

                }
                break;

                default:
                    XINVALIDINIFILE()
                    break;
            }
        }
        break;
    default:
        XINVALIDINIFILE()
            break;
    }
    if (Buffer2) {
        XFree(Buffer2);
    }
    if (IntegerBuffer) {
        XFree(IntegerBuffer);
    }
}

DWORD
StrToOctet(char * String)
{
    DWORD u, index = 0, count;
    char * t = String;

    /* first, check for string = "0".  This is a special case. */
    if ((*t == '0') && (t[1] == '\0')) {
        String[0] = 0;
        return 1;
    }

    /* Now, skip over initial \x or \X, if it exists. */
    if(*t == '\\') {
        t++;
        if((*t != 'x') && (*t != 'X')) {
            XINVALIDINIFILE();
        }
        t++;
    }

    while (*t != '\0') {
        u = 0;
        for (count=0; count<2; count++) {
            if ((*t >= 'A') && (*t <= 'F'))
                u = u * 16 + (unsigned)*t - 'A' + 10;
            else if ((*t >= 'a') && (*t <= 'f'))
                u = u * 16 + (unsigned)*t - 'a' + 10;
            else if ((*t >= '0') && (*t <= '9'))
                u = u * 16 + (unsigned)*t - '0';
            else {
                XINVALIDINIFILE();
            }

            t++;
        }

        String[index]=(char)u;
        index++;

    }

    return index;
}

BOOL
GetDefaultReplScheduleString(char *pStr, ULONG cb)
{
    // Each byte of SCHEDULE will translate into two chars in the string form
    // and we prepend that with "\x" to say that it is a hex string. And we put
    // a null-terminator.
    if (cb < (g_sched.Size * 2 + 3)) {
        return FALSE;
    }

    // pre-pend the "\x" first
    *pStr++ = '\\';
    *pStr++ = 'x';

    ULONG i;

    // append the schedule header part
    BYTE *pb = (BYTE *) &g_sched;
    for (i = 0; i < sizeof(SCHEDULE); i++) {
        sprintf(pStr, "%02x", *pb++);
        pStr += 2;
    }

    // append the data part
    pb = g_defaultSchedDBData;
    for (i = 0; i < SCHEDULE_DATA_ENTRIES; i++) {
        sprintf(pStr, "%02x", *pb++);
        pStr += 2;
    }

    // null-terminate
    *pStr = '\0';

    return TRUE;
}

//-----------------------------------------------------------------------
//
// Function Name:            PreProcessInifileShortcuts
//
// Routine Description:
//
//    Converts inifile values into the actual string values.
//    eg ref to Attribute/Class Schema Names get converted into equiv OIDs
//       ref to Registry/Environment var get converted into there actual
//               string value.
//
// Author: RajNath
//
// Arguments:
//
//    char* strval,            The String Value Read In
//    ATTCACHE* pAC,             The Attribute of this value
//
//
// Return Value:
//
//    char*                NULL on Failure
//
//-----------------------------------------------------------------------

char*
PreProcessInifileShortcuts
(
   char* strval,
   ATTCACHE* pAC,
   WCHAR **Widepp
)
{
    static char StaticBuff[512];
    static char bData[512];

    static WCHAR wStaticBuff[512];
    static WCHAR wbData[512];

    char*  ret=StaticBuff;

    *Widepp = NULL;

    ret[0]='\0';


    //
    // Lets see if we need to read registry or env
    //
    if (strncmp(EMBEDDED,strval,sizeof(EMBEDDED)-1)==0)
    {
        LONG  err;
        DWORD dwType = REG_SZ;
        DWORD cbData = sizeof(wbData);
        DWORD index = 0;

        WCHAR KeyName[512];
        ULONG KeyLength;

        // There should be an embedded regentry in here.

        while(strval[index + sizeof(EMBEDDED) - 1] != '<') {
            mbtowc( &wbData[index], &strval[index + sizeof(EMBEDDED) - 1], sizeof(CHAR) );
            index++;
        }
        cbData -= index;

        MultiByteToWideChar(CP_ACP,
                            0,
                            &strval[sizeof(EMBEDDED) + index],
                            strlen(&strval[sizeof(EMBEDDED) + index])+1,
                            KeyName,
                            512);

        err =  GetConfigParamW(KeyName,
                               &wbData[index],
                               cbData);

        if (err!=0)
        {
            DPRINT2(0, "Could Not Read Registry %s REG_SZ. Error %d\n",
                    &strval[sizeof(EMBEDDED)-1],GetLastError());
            XINVALIDINIFILE();
        };

        *Widepp = wbData;

        strval=bData;


    }
    else if (strncmp(REGENTRY,strval,sizeof(REGENTRY)-1)==0)
    {
        LONG  err;
        DWORD cbData = sizeof(wbData);
        CHAR  *TempString = &strval[sizeof(REGENTRY)-1];

        WCHAR KeyName[512];
        ULONG KeyLength;


        MultiByteToWideChar(CP_ACP,
                            0,
                            TempString,
                            strlen(TempString)+1,
                            KeyName,
                            512);

        err =  GetConfigParamW( KeyName, wbData, cbData );

        if (err!=0)
        {
            DPRINT2(0, "Could Not Read Registry %s REG_SZ. Error %d\n",
                    &strval[sizeof(REGENTRY)-1],GetLastError());
            XINVALIDINIFILE();
        }

        *Widepp = wbData;
        strval=bData;

    }
    else if (strncmp(ENVENTRY,strval,sizeof(ENVENTRY)-1)==0)
    {
        LONG  err;

        // Get OBJECT/UNICODE-syntaxed values in Unicode, get everything else
        // in ascii only

        if ( (pAC->OMsyntax == OM_S_OBJECT)
                || (pAC->OMsyntax == OM_S_UNICODE_STRING) ) {
            WCHAR EnvVarName[512];
            MultiByteToWideChar( CP_ACP,
                                 0,
                                 &strval[sizeof(ENVENTRY)-1],
                                 strlen(&strval[sizeof(ENVENTRY)-1]) + 1,
                                 EnvVarName,
                                 512);

            err = GetEnvironmentVariableW(EnvVarName,
                                         wbData,
                                         sizeof(wbData)/sizeof(WCHAR));
        }
        else {
            err = GetEnvironmentVariable(&strval[sizeof(ENVENTRY)-1],bData,
                                         sizeof(bData));
        }

        if (err == 0 )
        {
            DPRINT1(0, "Could Not Read Environment Var %s \n",
                    &strval[sizeof(ENVENTRY)-1]);
            XINVALIDINIFILE();
        }

        *Widepp = wbData;
        strval = bData;
    }
    else if (strncmp(SYSDEFENTRY, strval, sizeof(SYSDEFENTRY)-1) == 0)
    {
        // right now REPLSCHEDULE is the only SYSDEFENTRY in schema.ini
        // we might add more in this category if needed
        if (_stricmp(REPLSCHEDULE, &strval[sizeof(SYSDEFENTRY)-1]) == 0)
        {
            // use the default repl schedule
            if (!GetDefaultReplScheduleString(bData, 512))
            {
                XINVALIDINIFILE();
            }

            strval = bData;
        }
        else
        {
            // SYSDEFENTRY with empty value
            XINVALIDINIFILE();
        }
    }


    //
    // Translate Attribute/Schema Class Names to OIDs
    //
    switch(pAC->OMsyntax) {

    case OM_S_BOOLEAN:
        {
            // In Inifile its TRUE/FALSE
            BOOL num=(_stricmp(strval,"FALSE")!=0);
            sprintf(ret,"%d",num);
            break;
        }

    case OM_S_OBJECT_IDENTIFIER_STRING:
        //In Inifile we may put the name of object instead eg in MAY-CONTAIN
        //These are either Attr or class objs
        if (strval[0]!='\\') {
            OID_t OID;
            OID.length = 0;
            OID.elements = NULL;
            ATTCACHE *pACtemp=NULL;
            CLASSCACHE *pCCtemp=NULL;
            DWORD i;

            if(pACtemp =
               SCGetAttByName(pTHStls, strlen(strval), (PUCHAR) strval)) {
                // Yep.  Put into ret the \x000000 form of the attribute id.
                AttrTypeToOid(pACtemp->id, &OID);

            }
            else if(pCCtemp =
                    SCGetClassByName(pTHStls, strlen(strval), (PUCHAR)strval)) {
                // Yep.  Put into ret the \x000000 form of the class id
                AttrTypeToOid(pCCtemp->ClassId, &OID);
            }
            else {
                DPRINT1(0, "%s is not a Class or Attribute\n",strval);
                XINVALIDINIFILE();
            }

            ret[0]='\\';
            ret[1]='x';

            for(i=0;i<OID.length;i++) {
                sprintf(&ret[2+2*i],"%02X",((PUCHAR)OID.elements)[i]);
            }
            ret[2+2*i]=0;
        }
        else {
            ret=strval;
        }
        break;

    default:
        ret=strval;
        break;
    }

    return ret;
}


NTSTATUS
CallCoreToAddObj(ADDARG* addarg, BOOL fVerbose)
{
     NTSTATUS NtStatus = STATUS_SUCCESS;
     ULONG err;
     ADDRES *pAddRes;

     TIMECALL(DirAddEntry(addarg, &pAddRes),err);

    //
    // Discard the thread's error state to avoid impacting 
    // other calls to the Dir* routines. Otherwise, the other
    // calls will return this error (return (pTHS->errCode))
    // even if they finished w/o error. Clearing the thread's
    // error state does not affect pAddRes or err.
    //
    if ( err != 0 ) {
        THClearErrors();
    }

     if ( err || fVerbose )
     {
         // Display error messages
         DPRINT2(0,"DirAddEntry(%ws). Error %d\n",
             addarg->pObject->StringName,
             err);
     }

     if (err) {
         DUMP_ERROR_INFO();
     }


     if ( pAddRes )
     {
         NtStatus = DirErrorToNtStatus(err, &pAddRes->CommRes);
     }
     else
     {
         NtStatus = STATUS_NO_MEMORY;
     }

     return NtStatus;
}

DWORD
AppendRDNStr(
    IN WCHAR *BaseName,
    IN unsigned ccBaseName,
    IN OUT WCHAR *NewName,
    IN unsigned ccNewName,
    IN WCHAR *Rdn,
    IN unsigned ccRdn,
    IN ATTRTYP AttrType
    )
{
    DSNAME *BaseDsName;
    DSNAME *NewDsName;
    int err;
    unsigned ccNeeded = ccBaseName + ccRdn + 20;

    BaseDsName = (DSNAME*)XCalloc(1, DSNameSizeFromLen(ccBaseName));
    NewDsName =  (DSNAME*)XCalloc(1, DSNameSizeFromLen(ccNeeded));

    BuildDefDSName( BaseDsName,
                    BaseName,
                    NULL  // no guid
                  );


    err = AppendRDN(BaseDsName,
                    NewDsName,
                    DSNameSizeFromLen(ccNeeded),
                    Rdn,
                    0,
                    AttrType);
    Assert(err == 0);

    if (ccNewName >= NewDsName->NameLen) {
        memcpy(NewName,
               NewDsName->StringName,
               NewDsName->NameLen * sizeof(WCHAR));
        err = 0;
    }
    else {
        err = NewDsName->NameLen;
        Assert(err == 0);
    }

    XFree(BaseDsName);
    XFree(NewDsName);

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\boot\inicache.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       inicache.cxx
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Based on the observation that mkdit.exe spends most of its time
    calling GetPrivateProfileSection (much less on the same sections
    over and over and over again), this file implements a simple
    .ini file section cache.  Performance could be better improved
    by other means, but considering that mkdit is run rarely, this
    is probably a good enough solution.

Author:

    Dave Straube (DaveStr) 26-Dec-1996

Revision History:

--*/

#include <ntdspchX.h>
#include "SchGen.HXX"

typedef struct IniCacheItem
{
    CHAR    *sectionName;
    CHAR    *buffer;
    DWORD   cchBuffer;
} IniCacheItem;

#define         IniCacheIncrement 1000

IniCacheItem    *IniCache = NULL;       // cache is an array of IniCacheItem
DWORD           cIniCache = 0;          // # of items in cache
DWORD           cIniCacheMax = 0;       // # of items which can fit in cache

void
CleanupIniCache(void)
{
    ULONG i;

    if ( IniCache ) {
        for (i = 0; i < cIniCache; i++) {
            XFree(IniCache[i].sectionName);
            XFree(IniCache[i].buffer);
        }
        XFree(IniCache);
        IniCache = NULL;
        cIniCache = 0;
        cIniCacheMax = 0;
    }
}


int _cdecl CompareIniCacheItem(
    const void *pv1,
    const void *pv2)
{
   return(_stricmp(
               ((IniCacheItem *) pv1)->sectionName,
               ((IniCacheItem *) pv2)->sectionName));
}

void SortIniCache(void)
{
    if ( cIniCache < 2 )
        return;

    qsort(
        (void *) IniCache,
        (size_t) cIniCache,
        (size_t) sizeof(IniCacheItem),
        CompareIniCacheItem);
}

IniCacheItem * FindIniCacheItem(
    CHAR    *sectionName
    )
{
    IniCacheItem    *pItem = NULL;
    IniCacheItem    searchItem = { sectionName, NULL, 0 };

    if ( 0 == cIniCache )
        return(NULL);

    pItem = (IniCacheItem *) bsearch(
                    (void *) &searchItem,
                    (void *) IniCache,
                    (size_t) cIniCache,
                    (size_t) sizeof(IniCacheItem),
                    CompareIniCacheItem);

    return(pItem);
}

DWORD GetPrivateProfileSectionEx(
    CHAR    *sectionName,   // IN
    CHAR    **ppBuffer,     // OUT
    CHAR    *iniFile)       // IN

/*++

Routine Description:

    Cached version of GetPrivateProfileSection().  Doesn't clean up
    allocations on error under the assumption that upper levels are
    going to bail anyway and we're not worried about memory leaks on
    exit in mkhdr/mkdit.

Parameters:

    sectionName - Name of the desired .ini file section.

    ppBuffer - Address of return buffer pointer.  Filled in by this routine
        on success and allocated with XCalloc().

    iniFile - Name of .ini file.

Return Values:

    Buffer size on success.  0 on failure.

--*/

{
    IniCacheItem    *pItem;
    IniCacheItem    *tmpCache;
    DWORD           cch;
    DWORD           sectionSize;
    BOOL            fDone;

    // The sectionSize returned by GetPrivateProfileSection() doesn't 
    // include the final terminating NULL character.  Upper layer code
    // assumes the terminating character is there - so we need to 
    // allocate and copy it as required. IniCacheItem.cchBuffer 
    // represents the "real" buffer size.  

    if ( NULL != (pItem = FindIniCacheItem(sectionName)) )
    {
        // Cache hit - just realloc the section buffer.
        // printf("Cache hit(%s[%d])\n", pItem->sectionName, pItem->cchBuffer);

        *ppBuffer = (CHAR *) XCalloc(1, pItem->cchBuffer);

        if ( NULL == *ppBuffer )
        {
            return(0);
        }
        else
        {
            memcpy(*ppBuffer, pItem->buffer, pItem->cchBuffer);

            // Return sectionSize which is 1 less than buffer size.
            return(pItem->cchBuffer - 1);
        }
    }

    // Item isn't in the cache yet.  Go get it for real.
    // Empirical testing shows that the majority of schema.ini entries
    // require 1024 bytes, so we start there.

#define BufferIncrement 1024

    cch = BufferIncrement;

    do
    {
        *ppBuffer = (CHAR *) XCalloc(1, cch);

        if ( NULL == *ppBuffer )
            return(0);

        /*
        if ( BufferIncrement != cch )
            printf("GetPrivateProfileSection(%s[%d])\n", sectionName, cch);
        */

        sectionSize = GetPrivateProfileSection(
                                    sectionName,
                                    *ppBuffer,
                                    cch,
                                    iniFile);

        if ( sectionSize == (cch-2) )
        {
            // Buffer was too small - grow it and try again.

            XFree(*ppBuffer);
            cch += BufferIncrement;
        }
        else if ( 0 == sectionSize )
        {
            // Section doesn't exist.

            return(0);
        }
        else
        {
            // Section found - break out of loop.

            break;
        }
    } while ( TRUE );

    // Section found - add item to cache and return copy to caller.
    // Caller's copy is already in *ppBuffer and length is in sectionSize.

    if ( 0 == cIniCacheMax )
    {
        // Perform initial cache allocation.

        IniCache = (IniCacheItem *)
            XCalloc(1, IniCacheIncrement * sizeof(IniCacheItem));

        if ( NULL == IniCache )
            return(0);

        cIniCacheMax += IniCacheIncrement;
    }
    else if ( cIniCache == cIniCacheMax )
    {
        // Cache is full - grow it.

        tmpCache = (IniCacheItem *)
            XCalloc(1, (cIniCache + IniCacheIncrement) * sizeof(IniCacheItem));

        if ( NULL == tmpCache )
            return(0);

        cIniCacheMax += IniCacheIncrement;

        // Swap old and new.

        memcpy(tmpCache, IniCache, cIniCache * sizeof(IniCacheItem));
        XFree(IniCache);
        IniCache = tmpCache;
    }

    // There's room in the cache - insert new entry.

    IniCache[cIniCache].sectionName =
        (CHAR *) XCalloc(1, sizeof(CHAR) * (1 + strlen(sectionName)));

    if ( NULL == IniCache[cIniCache].sectionName )
        return(0);

    strcpy(IniCache[cIniCache].sectionName, sectionName);

    IniCache[cIniCache].buffer = (CHAR *) XCalloc(1, sectionSize + 1);

    if ( NULL == IniCache[cIniCache].buffer )
        return(0);

    memcpy(IniCache[cIniCache].buffer, *ppBuffer, sectionSize + 1);
    IniCache[cIniCache].cchBuffer = sectionSize + 1;

    cIniCache++;

    SortIniCache();

    return(sectionSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\boot\install.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       install.cxx
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Installs the DIT Fresh or through replication.

    The general idea here is that when InstallBaseNTDS is called, both the
    dblayer and replication client components have been initialized, so that we
    call can call Dir* and DirReplica* functions to fill the database with
    entries from either an existing dsa or we can create entries from fresh.
                                  
    Using the Dir* and DirReplica* primitives, InstallBaseNTDS is responsible
    for locally creating three naming contexts: the schema, the configuration
    and the first authoritative domain.  There are three ways this is done
    today: 

    1) create all three based on the definition file schema.ini (use Dir* api)
    2) replicate all three naming contexts (use DirReplica* api)
    3) replicate just the schema and configuration naming contexts and create 
       the domain naming context (use both sets of Api)

    As well InstallBaseNTDS creates an NTDS-DSA in every case for this new dsa
    that is being created.

    A note about error spaces:
    --------------------------

    The only client of InstallBaseNTDS is DoInitialize(), which is ultimately
    called by an NT subsystem, so we need to return somewhat accurate status of
    the install operation via an ntstatus code.   More extensive error reporting
    should be done via the event log and a log file if appropriate.

Author:

    Rajivendra Nath (RajNath) 07-Jul-1996

Revision History:

    Colin Brace  (ColinBr) August 11, 1997.

        Cleanup - first pass before beta 1.

        . make the return value of InstallBaseNTDS, the entry point into this
        module, boot.lib, return a valid NTSTATUS
        . function comments when possible

    BUGBUG : beta2 more cleanup required.
        . get rid of static buffers if possible

--*/
#include <ntdspchX.h>

//
// This header has definitions global to the boot.lib module
//
#include "SchGen.HXX"

extern "C"
{
    #include <ntlsa.h>
    #include <lsarpc.h>
    #include <lsaisrv.h>
    // DB layer based password encryption
    #include <wxlpc.h>
    #include <pek.h>
    #include <dsrolep.h> //for DSROLE_DC_IS_GC flag
    
    #include <drserr.h>
    #include <dns.h>
    #include <sdprop.h>
    #include "dsaapi.h"
    #include "tchar.h"
    #include "drsuapi.h"
    #include "drancrep.h"
    #include "drautil.h"
    #include "drasig.h"
    #include "dsevent.h"
    #include "mappings.h"
    #include "fileno.h"
    #include "dsutil.h"

    #include <ntdsetup.h>
    #include <lmcons.h>
    #include <lmaccess.h>
    #define STRSAFE_NO_DEPRECATE
    #include <strsafe.h>


    //
    // Set when we're adding new objects as a part of installation to
    // bypass SAM loopbacks.
    extern BOOL gfDoSamChecks;

    // dsatools.h is too complicated to include
    VOID
    SetInstallStatusMessage (
        IN  DWORD  MessageId,
        IN  WCHAR *Insert1, OPTIONAL
        IN  WCHAR *Insert2, OPTIONAL
        IN  WCHAR *Insert3, OPTIONAL
        IN  WCHAR *Insert4, OPTIONAL
        IN  WCHAR *Insert5  OPTIONAL
        );

    VOID
    SetInstallErrorMessage (
        IN  DWORD  WinError,
        IN  DWORD  MessageId,
        IN  WCHAR *Insert1, OPTIONAL
        IN  WCHAR *Insert2, OPTIONAL
        IN  WCHAR *Insert3, OPTIONAL
        IN  WCHAR *Insert4  OPTIONAL
        );

    extern int ComputeCacheClassTransitiveClosure(BOOL fForce);
    extern int SCUpdateSchema();

#define SET_INSTALL_ERROR_MESSAGE0( err, msgid ) \
    SetInstallErrorMessage( (err), (msgid), NULL, NULL, NULL, NULL )
    
#define SET_INSTALL_ERROR_MESSAGE1( err, msgid, a ) \
    SetInstallErrorMessage( (err), (msgid), (a), NULL, NULL, NULL )

#define SET_INSTALL_ERROR_MESSAGE2( err, msgid, a, b ) \
    SetInstallErrorMessage( (err), (msgid), (a), (b), NULL, NULL )
    

    DWORD
        DBInitialSetup(
                WCHAR *pDN
                );

    extern DSA_CALLBACK_CANCEL_TYPE gpfnInstallCancelOk;

    extern void
    RebuildAnchor(void * pv,
                  void ** ppvNext,
                  DWORD * pcSecsUntilNextIteration );


    extern SCHEMAPTR *CurrSchemaPtr;

    ULONG
    DrspGetCredentials(
        OUT PSEC_WINNT_AUTH_IDENTITY_W *ppCred
        );

    VOID
    DrspFreeCredentials(
        PSEC_WINNT_AUTH_IDENTITY_W pCred
        );

}

BOOL gInstallHasDoneSchemaMove = FALSE;

//
// Prepare this file for the ds DPRINT subsystem use
//
#define DEBSUB "INSTALL:"

#define FILENO FILENO_INSTALL

//
// found in addobj.cxx
//
extern NTSTATUS
AddOneObjectEx(NODE* NewNode,
               WCHAR* DN,
               UUID * pObjectGuid,
               BOOL fVerbose = TRUE );

//
// Exported APIS
//

extern "C"
{
    BOOL     isDitFromGC(IN  PDS_INSTALL_PARAM   InstallInParams,
                         OUT PDS_INSTALL_RESULT  InstallOutParams);
    DWORD    SetDittoGC();
    NTSTATUS InstallBaseNTDS(IN  PDS_INSTALL_PARAM   InstallInParams,
                             OUT PDS_INSTALL_RESULT  InstallOutParams);
}

struct
{
    
    PTCHAR NTDSIniFile;

    PWCHAR RootDomainDNName;
    
    PWCHAR SrcRootDomainSrv;

    PWCHAR ConfigNCDNName;

    PWCHAR SrcConfigNCSrv;

    PWCHAR RemoteMachineDNName;

    PWCHAR DsaDNName;

    PWCHAR SchemaDNName;

    PWCHAR SourceDsaDnsDomainName;

    PTCHAR IniDefaultConfigNCDit;
    
    PTCHAR IniDefaultRootDomainDit;
    
    PTCHAR IniDefaultSchemaNCDit;

    PTCHAR IniDefaultLocalConnection;

    PTCHAR IniDefaultRemoteConnection;
    
    PWCHAR LocalConnectionDNName;
    
    PWCHAR RemoteConnectionDNName;

    PTCHAR IniDefaultNewDomainCrossRef;
    
    PWCHAR NewDomainCrossRefDNName;

    PTCHAR IniDefaultMachine;

}   gNames = {0};

//
// Forward definitions
//
NTSTATUS
DirReplicaErrorToNtStatus(
    IN ULONG DirReplicaError
    );

NTSTATUS
CreateNtdsDsaObject
(
    WCHAR* DsaDNName,
    WCHAR* RootConfigNCDNName,
    WCHAR* ConfigNCDNName,
    WCHAR* SchemaContainer
);


DWORD
ConvertMachineAccount(
    IN  PDS_INSTALL_PARAM   InstallInParams,
    OUT PDS_INSTALL_RESULT  InstallOutParams
    );

VOID
ZapTempRegKeys(
    VOID
    );

NTSTATUS
CreateSchemaNCObject(WCHAR* SchemaNCDNName);

NTSTATUS
CreateDefaultSchemaNCDIT(WCHAR* SchemaNCDNName);

NTSTATUS
CreateConfigNCObject(WCHAR* ConfigNCDNName);

NTSTATUS
CreateDefaultConfigNCDIT(WCHAR* ConfigNCDNName);

NTSTATUS
CreateRootDomainObject(WCHAR* RootConfigNCDNName,
                       GUID *pGuid,
                       IN OUT CROSS_REF *pCR);

NTSTATUS
CreateDefaultRootDomainDIT(WCHAR* RootConfigNCDNName);

DWORD
CreateChildDomainCrossRef(
    OUT PDS_INSTALL_RESULT  InstallOutParams,
    IN GUID * pGuid,
    IN CROSS_REF *pCR,
    OUT GUID* ntdsaGuid
    );

NTSTATUS
CreateConnectionObjects();

DWORD 
CheckForDuplicateDomainSid();



NTSTATUS
CreateDummyNtdsDsaObject();

DWORD
DeleteDummyNtdsDsaObject();

NTSTATUS
CopyDsaAttributes(
    IN  PDS_INSTALL_PARAM   InstallInParams,
    IN PDSNAME pCurrentDSA,
    IN PDSNAME pNewDSA,
    IN BOOL fDoFinalUpdates
    );

NTSTATUS
WriteMultiValuedAtt(
    IN  DSNAME * Object,
    IN  ATTRTYP  attrTyp,
    IN  DWORD    Count,
    IN  ATTRVAL  *pAVal,
    IN  BOOL     RunAsDRA
    );

NTSTATUS
UpdateReplicationEpochAndHiddenDSA(
    IN DSNAME *pDSADN,
    IN DWORD  ReplicationEpoch,
    IN BOOL   fUpdateHiddenTable
    );

DWORD
CreateRemoteNtdsDsaObject(
    OUT GUID* NtdsDsaGuid OPTIONAL
    );

DWORD
ForceChangeToDomainCrossRef(
    IN DSNAME* pdnCrossRefObj,
    IN WCHAR*  wszDomainDn,
    IN GUID*   pDomainGuid
    );

NTSTATUS
InitializeNTDSSetup();

NTSTATUS 
HandleKeys(
    IN  IFM_SYSTEM_INFO * pIfmSystemInfo,
    PVOID BootKey OPTIONAL,
    DWORD cbBootKey OPTIONAL
    );
    
NTSTATUS
CheckReplicationEpoch(
    IN DWORD ReplicationEpoch
    );

NTSTATUS
CheckTombstone();

NTSTATUS
ClearNonReplicatedAttributes();

NTSTATUS
RenameAdditionalMachineAccountsIfAny(
    OUT PBOOL fNoMessage
    );

VOID
InstallFreeGlobals( VOID );

NTSTATUS
InitializeNTDSSetup()
{
    THSTATE *pTHS = pTHStls;
    ULONG err=0;
    char fp[MAX_PATH];
    DWORD dwType;
    HKEY  hk;

    struct
    {
        VOID*  Key;
        VOID** ValueBuffer;
        ULONG  Size;
        BOOLEAN fUnicode;

    } ActionArray [] =
    {
        { NTDSINIFILE,                        (VOID**)&gNames.NTDSIniFile,                   0, FALSE  },
        { INIDEFAULTROOTDOMAINDIT,            (VOID**)&gNames.IniDefaultRootDomainDit,       0, FALSE  },
        { MAKE_WIDE(ROOTDOMAINDNNAME),        (VOID**)&gNames.RootDomainDNName,              0, TRUE   },
        { INIDEFAULTCONFIGNCDIT,              (VOID**)&gNames.IniDefaultConfigNCDit,         0, FALSE  },
        { INIDEFAULTSCHEMANCDIT,              (VOID**)&gNames.IniDefaultSchemaNCDit,         0, FALSE  },
        { MAKE_WIDE(CONFIGNCDNNAME),          (VOID**)&gNames.ConfigNCDNName,                0, TRUE   },
        { MAKE_WIDE(SRCROOTDOMAINSRV),        (VOID**)&gNames.SrcRootDomainSrv,              0, TRUE   },
        { MAKE_WIDE(SRCCONFIGNCSRV),          (VOID**)&gNames.SrcConfigNCSrv,                0, TRUE   },
        { MAKE_WIDE(REMOTEMACHINEDNNAME),     (VOID**)&gNames.RemoteMachineDNName,           0, TRUE   }, // This is the Sources NTDSA DN
        { MAKE_WIDE(MACHINEDNNAME),           (VOID**)&gNames.DsaDNName,                     0, TRUE   },
        { INIDEFAULTLOCALCONNECTION,          (VOID**)&gNames.IniDefaultLocalConnection,     0, FALSE  },
        { INIDEFAULTREMOTECONNECTION,         (VOID**)&gNames.IniDefaultRemoteConnection,    0, FALSE  },
        { MAKE_WIDE(LOCALCONNECTIONDNNAME),   (VOID**)&gNames.LocalConnectionDNName,         0, TRUE   },
        { MAKE_WIDE(REMOTECONNECTIONDNNAME),  (VOID**)&gNames.RemoteConnectionDNName,        0, TRUE   },
        { INIDEFAULTNEWDOMAINCROSSREF,        (VOID**)&gNames.IniDefaultNewDomainCrossRef,   0, FALSE  },
        { MAKE_WIDE(NEWDOMAINCROSSREFDNNAME), (VOID**)&gNames.NewDomainCrossRefDNName,       0, TRUE   },
        { MAKE_WIDE(SCHEMADNNAME),            (VOID**)&gNames.SchemaDNName,                  0, TRUE   },
        { INIDEFAULTMACHINE,                  (VOID**)&gNames.IniDefaultMachine,             0, FALSE  },
        { MAKE_WIDE(SOURCEDSADNSDOMAINNAME),  (VOID**)&gNames.SourceDsaDnsDomainName,        0, TRUE   }
    };

    ULONG Index, Count = sizeof(ActionArray) / sizeof(ActionArray[0]);
    
    if ((err = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk))) {
        DPRINT1(0, "RegOpenKey failed with %d line %d\n", err);
        return err;
    }

    for ( Index = 0; Index < Count; Index++ )
    {

        if ( ActionArray[Index].fUnicode )
        {
            err = RegQueryValueExW(hk, 
                                   (WCHAR *)ActionArray[Index].Key,
                                   NULL, 
                                   &dwType,
                                   (LPBYTE) NULL,
                                   &ActionArray[Index].Size);
            if (!err) {
                *ActionArray[Index].ValueBuffer = XCalloc(1, ActionArray[Index].Size);
                err = RegQueryValueExW(hk,
                                       (WCHAR *)ActionArray[Index].Key,
                                       NULL,
                                       &dwType,
                                       (LPBYTE) *ActionArray[Index].ValueBuffer,
                                       &ActionArray[Index].Size);
            } else {
                DPRINT2(0, "RegQueryValueExW failed with err = %d for key %S\n", err, ActionArray[Index].Key);
            }

        }
        else
        {
            err = RegQueryValueEx(hk, 
                                  (CHAR *)ActionArray[Index].Key,
                                  NULL, 
                                  &dwType,
                                  (LPBYTE) NULL,
                                  &ActionArray[Index].Size);
            if (!err) {
                *ActionArray[Index].ValueBuffer = XCalloc(1, ActionArray[Index].Size);
                err = RegQueryValueEx(hk,
                                      (CHAR *)ActionArray[Index].Key,
                                      NULL,
                                      &dwType,
                                      (LPBYTE) *ActionArray[Index].ValueBuffer,
                                      &ActionArray[Index].Size);
            } else {
                DPRINT2(0, "RegQueryValueEx failed with err = %d for key %s\n", err, ActionArray[Index].Key);
            }
        }


        if ( err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND )
        {
            RegCloseKey(hk);
            DPRINT(0, "Error reading registry values.  returning early\n");
            return STATUS_UNSUCCESSFUL;
        }
    }

    RegCloseKey(hk);
    
    if (!SetIniGlobalInfo(gNames.NTDSIniFile))
    {
        unsigned long error = GetLastError();
        DPRINT2(0,"NTDS:%ws:Invalid Inifile, error %d\n",fp, error);
        return STATUS_UNSUCCESSFUL;
    }
    
    //
    // We no longer need gNames.NTDSIniFile
    //
    XFree(gNames.NTDSIniFile); 
    gNames.NTDSIniFile = NULL;

    // Set Phase to indicate install

    DsaSetIsInstalling();


    // Set the invocation id for this setup in the Core so that the objects
    // are properly stamped;
    // FALSE => There is no old invocation ID to be retired.

    //In the install From media case we had our InvocationID create
    //by HandleRestore()
    if (!DsaIsInstallingFromMedia()) {
        InitInvocationId(pTHS, FALSE, FALSE, NULL);
    }

    return STATUS_SUCCESS;

}

NTSTATUS
CreateSchemaNCObject(WCHAR* SchemaNCDNName)
{
    NTSTATUS NtStatus;
    ULONG len;
    ULONG size;
    DSNAME *pSchemaDN;

    NODE Node(gNames.IniDefaultSchemaNCDit);

    if ( !Node.Initialize() )
    {
        // Go right to the debugger for this one
        KdPrint(("NTDS: schema.ini file is corrupt\n"));
        return STATUS_UNSUCCESSFUL;
    }

    NtStatus = AddOneObjectEx(&Node,SchemaNCDNName,NULL);

    if (NtStatus) {
            return NtStatus;
    }

    len = wcslen(SchemaNCDNName);
    size = DSNameSizeFromLen(len);
    pSchemaDN = (PDSNAME) XCalloc( 1, size );

    BuildDefDSName( pSchemaDN,
                    SchemaNCDNName,
                    NULL
                  );

    RegisterActiveContainer(pSchemaDN,
                            ACTIVE_CONTAINER_SCHEMA);


    XFree(pSchemaDN);
    return NtStatus;

}

//-----------------------------------------------------------------------
//
// Function Name:            CreateConfigNCObject
//
// Routine Description:
//
//    Creates the Config NC Object
//
// Author: RajNath
//
// Arguments:
//
//
//
// Return Value:
//
//    ULONG                Zero On Succeess
//
//-----------------------------------------------------------------------

NTSTATUS
CreateConfigNCObject(WCHAR* ConfigNCDNName)
{
    NTSTATUS NtStatus;


    NODE Node(gNames.IniDefaultConfigNCDit);

    if ( !Node.Initialize() )
    {
        // Go right to the debugger for this one
        KdPrint(("NTDS: schema.ini file is corrupt\n"));
        return STATUS_UNSUCCESSFUL;
    }

    NtStatus = AddOneObjectEx(&Node,ConfigNCDNName,NULL);

    return NtStatus;
}



//-----------------------------------------------------------------------
//
// Function Name:            CreateRootDomainObject
//
// Routine Description:
//
//    Creates The root domain object
//
// Author: RajNath
//
// Arguments:
//
//    TCHAR* RootDomainDNName             Name of the object
//
// Return Value:
//
//    ULONG                Zero On Succeess
//
//-----------------------------------------------------------------------

typedef struct ClassMapping {
    ATTRTYP     type;
    char        *objectClass;
} ClassMapping;

ClassMapping rDomainMappings[] = {
    { ATT_LOCALITY_NAME,            "domainLocality" },
    { ATT_ORGANIZATION_NAME,        "domainOrganization" },
    { ATT_ORGANIZATIONAL_UNIT_NAME, "domainOrganizationalUnit" },
    { ATT_COUNTRY_NAME,             "domainCountry" },
    { ATT_DOMAIN_COMPONENT,         "domainDNS" }
};

DWORD cDomainMappings = sizeof(rDomainMappings) / sizeof(rDomainMappings[0]);

NTSTATUS
CreateRootDomainObject(WCHAR* RootDomainDNName,
                       GUID *pDomainGuid,
                       CROSS_REF *pCR
                       )
{
    NTSTATUS    NtStatus;
    ULONG       err=0;
    WCHAR       *tag;
    WCHAR       *equalSign;
    ATTRTYP     type;
    CHAR        *objectClass = NULL;   
    unsigned    cChar;
    WCHAR       *wTag;

    DSNAME*     domainobj = NULL;
    MODIFYARG   modarg;
    MODIFYRES   *modres = NULL;
    ATTRVAL     AttrVal;
    PPOLICY_DNS_DOMAIN_INFO  DnsDomainInfo = NULL;
    ULONG       Size, Length;

    NODE Node(gNames.IniDefaultRootDomainDit);


    if ( !Node.Initialize() )
    {
        return STATUS_UNSUCCESSFUL;
    }

    // Schema.ini sets DEFAULTROOTDOMAIN's Object-Class to
    // domainDNS.  This is only correct for a DC= type
    // root domain.  So assign the right Object-Class
    // based on the first tag in the DN.

    if ( (NULL == (equalSign = wcschr(RootDomainDNName, '='))) ||
         (RootDomainDNName == equalSign) )
    {
        return(STATUS_OBJECT_NAME_INVALID);
    }

    // Strip leading/trailing spaces if there are any.
    tag = RootDomainDNName;
    while ( ' ' == *tag ) tag++;
    equalSign--;
    while ( ' ' == *equalSign ) equalSign--;
    cChar = (UINT) (equalSign - tag + 1);

    // Map tag to ATTRTYPE.
    wTag = tag;
    type = KeyToAttrType(pTHStls, wTag, cChar);

    // Map ATTRTYPE to Object-Class.
    for ( DWORD i = 0; i < cDomainMappings; i++ )
    {
        if ( type == rDomainMappings[i].type )
        {
            objectClass = rDomainMappings[i].objectClass;
            break;
        }
    }

    // Bail if we couldn't map it.
    if ( i == cDomainMappings )
        return(STATUS_UNSUCCESSFUL);

    //
    // The GUID for the NC head must match the GUID for the Nc-Name on
    // the cross ref. There are 3 possiblities
    // 
    //   1. This is the creation of first domain in the enterprise. In this
    //      the cross ref is not created ( routine is simply called with a NULL
    //      for the cross ref parameter. ). We invent a new GUID or use the
    //      the user guid above.
    //
    //   2. This is the creation of a child. ie the cross ref has been created on
    //      a remote machine, and the NC name property points to a phantom with a 
    //      guid. In this case use the guid from the cross ref
    //
    //   3. This is the creation of a new tree cross-ref created or pre-created on
    //      a Win2k Domain Naming FSMO.  Windows Server.Net and later will always
    //      set the GUID on a new tree case.
    //
    // When we no longer require Win2k compatibility, we'll be able to remove this 
    // 3rd case from the comments.  However, we'll still need this conditional to
    // catch case 1 of course.
    //
    
    if (pCR && !fNullUuid(&(pCR->pNC->Guid))) {
        // This is case 2 above,use the guid in the cross ref
        *pDomainGuid = pCR->pNC->Guid;
    }
    else {
        // Case 3. or 1. above
        DsUuidCreate(pDomainGuid);

        if (pCR)
        {
            // case 3. above, set the GUID in the cross ref
            memcpy(&pCR->pNC->Guid,pDomainGuid,sizeof(GUID));
        }
        
    }

    Node.ReplaceKeyValuePair("objectClass", objectClass);
    NtStatus = AddOneObjectEx(&Node, RootDomainDNName, pDomainGuid ); 
    if ( !NT_SUCCESS( NtStatus ) ) {
        return NtStatus;
    }

    //
    // Whack the sid on the object so the meta data will
    // be bumped.  This is so the sid will properly replicate off the machine
    //
    memset( &modarg, 0, sizeof(modarg) );
    memset( &AttrVal, 0, sizeof(AttrVal) );

    NtStatus = LsaIQueryInformationPolicyTrusted(PolicyDnsDomainInformation,
                    (PLSAPR_POLICY_INFORMATION*) &DnsDomainInfo );

    if ( !NT_SUCCESS( NtStatus ) ) {
        return NtStatus;
    }

    Length = wcslen( RootDomainDNName );
    Size = DSNameSizeFromLen( Length );
    domainobj = (DSNAME*) XCalloc( 1, Size );
    domainobj->structLen = Size;
    domainobj->NameLen = Length;
    wcscpy( domainobj->StringName, RootDomainDNName );

    modarg.pObject = domainobj;
    modarg.count = 1;
    modarg.FirstMod.pNextMod = NULL;
    modarg.FirstMod.choice = AT_CHOICE_ADD_ATT;
    modarg.FirstMod.AttrInf.attrTyp = ATT_OBJECT_SID;
    modarg.FirstMod.AttrInf.AttrVal.valCount = 1;
    modarg.FirstMod.AttrInf.AttrVal.pAVal = &AttrVal;
    AttrVal.valLen  = RtlLengthSid( DnsDomainInfo->Sid );
    AttrVal.pVal = (BYTE*) DnsDomainInfo->Sid;
    InitCommarg(&modarg.CommArg);

    err = DirModifyEntry( &modarg, &modres );

    if ( err )
    {
        if ( modres )
        {
            NtStatus = DirErrorToNtStatus( err, &modres->CommRes );
        }
        else
        {
            NtStatus = STATUS_NO_MEMORY;
        }
    }

    if ( DnsDomainInfo )
    {
        LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION) DnsDomainInfo );
    }

    XFree(domainobj);
    
    return NtStatus;
}



//-----------------------------------------------------------------------
 //
// Function Name:            CreateNtdsDsaObject
//
// Routine Description:
//
//    Creates The NTDS-DSA Object
//
// Author: RajNath
//
// Arguments:
//
//    DsaDNName,                   Name of the Machine object
//    RootDomainDNName             Name of the Root Domain
//    ConfigNCDNName               Nameof the Config NC
//    SchemaContainer              Location of the schema container
//
//
//
// Return Value:
//
//    int              Zero On Success
//
//-----------------------------------------------------------------------
NTSTATUS
CreateNtdsDsaObject
(
    WCHAR* DsaDNName,
    WCHAR* RootDomainDNName,
    WCHAR* ConfigNCDNName,
    WCHAR* SchemaContainer
)
{
    // Historically, this routine created strictly an MSFT-DSA object.
    // For beta 2, we are moving to a full server-centric Sites container
    // model and thus have one generic Server container under which live
    // instances of classes inheriting from Application-Settings.  In the
    // DS case, NTDS-DSA inherits from Application-Settings, and setup
    // should insure that each NTDS-DSA instance is called "NTDS Settings".

    THSTATE *   pTHS = pTHStls;
    NTSTATUS    NtStatus;
    ULONG       err;
    NODE        NodeServer("DEFAULTANYSERVER");
    NODE        NodeServers("Servers");
    NODE        NodeDSA(gNames.IniDefaultMachine);
    WCHAR        *buf1 = NULL, *buf2 = NULL;
    DSNAME      *pDSName1, *pDSName2;
    DWORD       cBytes;
    PDSNAME     pdsa=NULL;
    
    // First see if we need to create the Server object.  Note that it
    // may already exist if this was a non-DC which had DS-enabled services
    // that needed to be registered in the DS, thus the Server object
    // was created as well.  By definition, the Server is the immediate
    // parent of the NTDS-DSA object, thus we can derive its name by
    // trimming the NTDS-DSA object name by 1.

    // Use do/while so we can break instead of goto.

    do
    {
        if ( !NodeServers.Initialize() )
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        _try
        {
            //
            // Creates the "Servers" object if it doesn't exist
            //
            cBytes = (DWORD)DSNameSizeFromLen(wcslen(DsaDNName));
            buf1 = (WCHAR *) XCalloc(1,cBytes);
            buf2 = (WCHAR *) XCalloc(1,cBytes);
            pDSName1 = (DSNAME *) buf1;
            pDSName2 = (DSNAME *) buf2;
            pDSName1->structLen = cBytes;
            pDSName1->NameLen = wcslen(DsaDNName);
            wcscpy( pDSName1->StringName, DsaDNName );

            TrimDSNameBy(pDSName1, 2, pDSName2);

            NtStatus = AddOneObjectEx(&NodeServers,  pDSName2->StringName,  NULL);

            //
            // Ignore the ignore the error; if there was a real problem it
            // will be cause when we try to create the ntdsa object
            //
            XFree(buf1); buf1 = NULL;
            XFree(buf2); buf2 = NULL;

            NtStatus = STATUS_SUCCESS;

        }
        _except(HandleAllExceptions(err = GetExceptionCode()))
        {
            if (INVALIDINIFILE == err) {
                NtStatus = STATUS_UNSUCCESSFUL;
            } else if (err == OUTOFMEMORY) {
                NtStatus = STATUS_NO_MEMORY;
            } else {
                // The error space of this error is unknown
                NtStatus = STATUS_UNSUCCESSFUL;
            }

            if (buf1) {
                XFree(buf1); buf1 = NULL;
            }
            if (buf2) {                
                XFree(buf2); buf2 = NULL;
            }
            break;
        }

        if ( !NodeServer.Initialize() )
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        _try
        {



            //
            // This creates the server object, if it doesn't exist
            //
            cBytes = (DWORD)DSNameSizeFromLen(wcslen(DsaDNName));
            buf1 = (WCHAR *) XCalloc(1,cBytes);
            buf2 = (WCHAR *) XCalloc(1,cBytes);
            pDSName1 = (DSNAME *) buf1;
            pDSName2 = (DSNAME *) buf2;
            pDSName1->structLen = cBytes;
            pDSName1->NameLen = wcslen(DsaDNName);
            wcscpy( pDSName1->StringName, DsaDNName );

            TrimDSNameBy(pDSName1, 1, pDSName2);

            NtStatus = AddOneObjectEx(&NodeServer,  pDSName2->StringName,  NULL);

            //
            // Ignore the ignore the error; if there was a real problem it
            // will be cause when we try to create the ntdsa object
            //
            XFree(buf1); buf1 = NULL;
            XFree(buf2); buf2 = NULL;
            NtStatus = STATUS_SUCCESS;

        }
        _except(HandleAllExceptions(err = GetExceptionCode()))
        {
            if (INVALIDINIFILE == err) {
                NtStatus = STATUS_UNSUCCESSFUL;
            } else if (err == OUTOFMEMORY) {
                NtStatus = STATUS_NO_MEMORY;
            } else {
                // The error space of this error is unknown
                NtStatus = STATUS_UNSUCCESSFUL;
            }

            if (buf1) {
                XFree(buf1); buf1 = NULL;
            }
            if (buf2) {                
                XFree(buf2); buf2 = NULL;
            }
            break;
        }

        //
        // Create the NTDS-DSA object.
        //

        if ( !NodeDSA.Initialize() )
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        _try
        {
            NtStatus = AddOneObjectEx(&NodeDSA,
                                      DsaDNName,
                                      &pTHS->InvocationID
                                     );

            if ( !NT_SUCCESS(NtStatus) )
            {
                break;
            }
        }
        _except(HandleAllExceptions(err = GetExceptionCode()))
        {
            if (INVALIDINIFILE == err) {
                NtStatus = STATUS_UNSUCCESSFUL;
            } else if (err == OUTOFMEMORY) {
                NtStatus = STATUS_NO_MEMORY;
            } else {
                // The error space of this error is unknown
                NtStatus = STATUS_UNSUCCESSFUL;
            }

            break;
        }

        //
        // Set The State On the Hidden Record
        //

        cBytes = (DWORD)DSNameSizeFromLen(wcslen(DsaDNName));
        pdsa = (PDSNAME) XCalloc( 1, cBytes );
        BuildDefDSName(pdsa, DsaDNName, &pTHS->InvocationID);

        err=DBReplaceHiddenDSA(pdsa);
        ASSERT(err == 0);
        if (err) {
            NtStatus = STATUS_UNSUCCESSFUL;
            XFree(pdsa); pdsa = NULL;
            break;
        }

        XFree(pdsa); pdsa = NULL;
    }
    while ( FALSE );

    if ( !NT_SUCCESS(NtStatus) )
    {
        DPRINT1(0,"NTDS:AddOneObjectEx(MACHINEOBJECT). Error 0x%x\n",NtStatus);
    }

    return NtStatus;
}

NTSTATUS
CreateConnectionObjects()
//
// Create NTDS-Connection objects representing bi-directional
// replication between the remote server and the local server.
//
{
    NTSTATUS NtStatus;

    ULONG   err = 0;
    NODE    nodeLocalConnection(  gNames.IniDefaultLocalConnection  );
    NODE    nodeRemoteConnection( gNames.IniDefaultRemoteConnection );

    if (    !nodeLocalConnection.Initialize()
         || !nodeRemoteConnection.Initialize()
       )
    {
        NtStatus = STATUS_UNSUCCESSFUL;
    }
    else
    {
        _try
        {
            NtStatus = AddOneObjectEx( &nodeLocalConnection, gNames.LocalConnectionDNName, NULL );

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = AddOneObjectEx( &nodeRemoteConnection, gNames.RemoteConnectionDNName, NULL );
            }
        }
        _except( HandleAllExceptions(err = GetExceptionCode()) )
        {

            if (INVALIDINIFILE == err) {
                NtStatus = STATUS_UNSUCCESSFUL;
            } else if (err == OUTOFMEMORY) {
                NtStatus = STATUS_NO_MEMORY;
            } else {
                NtStatus = STATUS_UNSUCCESSFUL;
            }

            DPRINT1( 0, "Exception 0x%x adding connection objects.\n", err );
        }
    }

    return NtStatus;
}

NTSTATUS
CreateDefaultSchemaNCDIT(WCHAR* SchemaNCDNName)
{
    NTSTATUS NtStatus;
    NODE*  Node=NULL;
    ULONG  err=0;
    TCHAR  entdit[MAX_PATH];
    TCHAR  schemafile[MAX_PATH];

    _try
    {
        _try
        {
            Node = new NODE(gNames.IniDefaultSchemaNCDit);

            if (Node==NULL || !(Node->Initialize()))
            {
                NtStatus = STATUS_UNSUCCESSFUL;
                _leave;
            }

            NtStatus = WalkTree(Node,SchemaNCDNName,FALSE);

        }
        _except(HandleAllExceptions(err = GetExceptionCode()))
        {

            if (INVALIDINIFILE == err) {
                NtStatus = STATUS_UNSUCCESSFUL;
            } else if (err == OUTOFMEMORY) {
                NtStatus = STATUS_NO_MEMORY;
            } else {
                NtStatus = STATUS_UNSUCCESSFUL;
            }
            DPRINT1(0,"NTDS:WalkTree Generated Exception %x\n",err);
        }

    }
    _finally
    {
        if (Node!=NULL)
        {
            delete Node;
        }
    }

    return NtStatus;

}

//-----------------------------------------------------------------------
//
// Function Name:            CreateDefaultRootDomainDIT
//
// Routine Description:
//
//    Creates The Root Domain Tree on a fresh install
//
// Author: RajNath
//
// Arguments:
//
//    TCHAR* RootDomainName,               Name of the Root Domain
//
// Return Value:
//
//    ULONG                Zero On Succeess
//
//-----------------------------------------------------------------------

NTSTATUS
CreateDefaultRootDomainDIT(WCHAR* RootDomainDNName)
{
    NTSTATUS NtStatus;

    NODE*  Node=NULL;
    ULONG  err=0;
    TCHAR  entdit[MAX_PATH];
    TCHAR  schemafile[MAX_PATH];

    _try
    {

        _try
        {
            Node = new NODE(gNames.IniDefaultRootDomainDit);

            if (Node==NULL || !(Node->Initialize()))
            {
                NtStatus = STATUS_UNSUCCESSFUL;
                _leave;
            }

            NtStatus = WalkTree(Node,RootDomainDNName);

        }
        _except(HandleAllExceptions(err = GetExceptionCode()))
        {

            if (INVALIDINIFILE == err) {
                NtStatus = STATUS_UNSUCCESSFUL;
            } else if (err == OUTOFMEMORY) {
                NtStatus = STATUS_NO_MEMORY;
            } else {
                NtStatus = STATUS_UNSUCCESSFUL;
            }
            DPRINT1(0,"NTDS:WalkTree Generated Exception %x\n",err);
        }

    }
    _finally
    {
        if (Node!=NULL)
        {
            delete Node;
        }
    }

    return NtStatus;

}

NTSTATUS
CreateDefaultConfigNCDIT(WCHAR* ConfigNCDNName)
{
    NTSTATUS NtStatus;
    NODE*  Node=NULL;
    ULONG  err=0;
    TCHAR  entdit[MAX_PATH];
    TCHAR  schemafile[MAX_PATH];

    _try
    {

        _try
        {
            Node = new NODE(gNames.IniDefaultConfigNCDit);

            if (Node==NULL || !(Node->Initialize()))
            {
                NtStatus = STATUS_UNSUCCESSFUL;
                _leave;
            }

            NtStatus = WalkTree(Node,ConfigNCDNName);

        }
        _except((HandleAllExceptions(err = GetExceptionCode())))
        {

            if (INVALIDINIFILE == err) {
                NtStatus = STATUS_UNSUCCESSFUL;
            } else if (err == OUTOFMEMORY) {
                NtStatus = STATUS_NO_MEMORY;
            } else {
                NtStatus = STATUS_UNSUCCESSFUL;
            }
            DPRINT1(0,"NTDS:WalkTree Generated Exception %x\n",err);
        }

    }
    _finally
    {
        if (Node!=NULL)
        {
            delete Node;
        }
    }

    return NtStatus;
}

extern void DestroyInstallHeap(void);
extern void CleanupIniCache();

// Following two routines required because THSave/THRestore are no-ops during
// install because SAM is in registry mode at that time.  So define our own
// variants for use during install.

PVOID
InstallTHSave( void )
{
    PVOID pv = TlsGetValue(dwTSindex);
    TlsSetValue(dwTSindex, 0);
#ifndef MACROTHSTATE
    pTHStls = NULL;
#endif
    return(pv);
}

VOID
InstallTHRestore(
    PVOID pv)
{
    Assert(NULL == pTHStls);
    TlsSetValue(dwTSindex, pv);
#ifndef MACROTHSTATE
    pTHStls = (THSTATE *) pv;
#endif
}

DWORD
FillSourceDsaGuid(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pdnNtdsaDn
    )
/*++

Routine Description:

    We want a true DSNAME structure with string and GUID filled in, because
    this is primarly what the replication API uses.

Parameters:

    pTHS (IN)

    pdnNtdsaDn (OUT) - On Successful the GUID is filled in for this object,
        which is assumed to be the ntdsa object.    

Return Values:

    0 or Win32 error.

--*/
{
    ULONG           err;

    if (pdnNtdsaDn == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }

    ZeroMemory((PVOID)&(pdnNtdsaDn->Guid), sizeof(GUID));
    
    err = GetConfigParam(SOURCEDSAOBJECTGUID,
                         (PVOID)&(pdnNtdsaDn->Guid),
                         sizeof(GUID));
#if DBG
    if(ERROR_SUCCESS != err) {
        DPRINT1(0, "Failed get %ws from registry.\n",TEXT(SOURCEDSAOBJECTGUID));
    }
#endif

    return(err);

}

DWORD
GetSourceDsaGuidBasedDnsName(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  LPWSTR      SrcRootDomainSrv,
    OUT GUID *      puuidSourceDsaObjGuid,
    OUT LPWSTR *    ppszSourceDsaGuidBasedDnsName
    )
/*++

Routine Description:

    Retrieve the repsFrom for the given NC and derive the GUID-based DNS name
    of the source DSA.

Parameters:

    pTHS (IN)
    
    pNC (IN) - NC from which to read repsFrom.
    
    pszSourceDsaDnsDomainName (IN) - The Dns name of source DSA, used to find the
        correct Guid info.
    
    puuidSourceDsaObjGuid (OUT) - On successful return, holds the objectGuid of
        the source's ntdsDsa object.
        
    ppszSourceDsaGuidBasedDnsName (OUT) - On successful return, holds the GUID-
        based DNS name of the source DSA. 

Return Values:

    0 or Win32 error.

--*/
{

    ULONG           err;
    DSNAME          DN = {0};
    GUID            ServerGuid;

    ZeroMemory((PVOID)&ServerGuid,sizeof(GUID));
    
    err = GetConfigParam(SOURCEDSAOBJECTGUID,
                         (PVOID)&ServerGuid,
                         sizeof(GUID));
    if(ERROR_SUCCESS != err) {
        DPRINT1(0, "Failed get %ws from registry.\n",TEXT(SOURCEDSAOBJECTGUID));
        goto cleanup;
    }

    DN.structLen = DSNameSizeFromLen(0);
    DN.Guid = ServerGuid;

    *ppszSourceDsaGuidBasedDnsName = DSaddrFromName(pTHS, &DN);
    if (NULL == *ppszSourceDsaGuidBasedDnsName) {
        DPRINT(0, "Failed to derive source DSA's GUID-based DNS name!\n");
        err = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    *puuidSourceDsaObjGuid = ServerGuid;

    cleanup:
    return err;
}

BOOL
IsForestWhistlerCreated()
/*++

Routine Description:

    Check to see if the forest was created by the whistler code base.  This is
    done by verifing the existence of a ForestUpdates operations guid existing only
    in Whistler enterprises.

Parameters:

    None.

Return Values:

    TRUE if Whistler created enterprise, FALSE otherwise.

--*/
{
    #define FOREST_UPDATE_OPERATIONS_DN L",CN=Operations,CN=ForestUpdates,"   
    DWORD err = ERROR_SUCCESS;
    LPWSTR pszWhistlerForestObj = NULL;
    LPWSTR pszWhistlerForestGuid = NULL;
    DSNAME * pWhistlerForestObj = NULL;
    THSTATE *pTHS = pTHStls;
    DWORD cchWhistlerForestObj = 0;
    
    DsUuidToStringW((GUID *)&GUID_WHISTLER_CREATED_ENTERPRISE, &pszWhistlerForestGuid);
    if (pszWhistlerForestGuid==NULL) {
	err = ERROR_INTERNAL_ERROR;
    }
    
    if (err==ERROR_SUCCESS) {
	Assert(gNames.ConfigNCDNName);
	cchWhistlerForestObj = wcslen(gNames.ConfigNCDNName) + wcslen(FOREST_UPDATE_OPERATIONS_DN) + SZGUIDLEN + 6;
	
	pszWhistlerForestObj = (LPWSTR) THAllocEx(pTHS, sizeof(WCHAR)*(cchWhistlerForestObj+1));  // GUID + CN= + , + NULL
	wcscpy(pszWhistlerForestObj, L"CN=");
	wcscat(pszWhistlerForestObj, pszWhistlerForestGuid);
	wcscat(pszWhistlerForestObj, FOREST_UPDATE_OPERATIONS_DN);
	wcscat(pszWhistlerForestObj, gNames.ConfigNCDNName); 
    
	pWhistlerForestObj = DSNameFromStringW(pTHS, pszWhistlerForestObj);
	if (pWhistlerForestObj==NULL) {
	    err = ERROR_OUTOFMEMORY;
	}
    }

    if (err==ERROR_SUCCESS) {
	DBOpen2(TRUE, &(pTHS->pDB));
	__try {

	    err = DBFindDSName(pTHS->pDB, pWhistlerForestObj);

	}
	__finally {
	    DBClose(pTHS->pDB, TRUE);
	}
    }

    if (pszWhistlerForestGuid) {
	RpcStringFreeW(&pszWhistlerForestGuid);
    }
    if (pszWhistlerForestObj) {
	THFreeEx(pTHS, pszWhistlerForestObj);
    }
    if (pWhistlerForestObj) {
	THFreeEx(pTHS, pWhistlerForestObj);
    }
    return (err==ERROR_SUCCESS);
}

BOOL
SetDraReplConsisInstallRegKey()
/*++

Routine Description:

    Set Replication registry keys which need to be set during installation.

Parameters:

    None.

Return Values:

    TRUE if successful.

--*/
{
    DWORD err = ERROR_SUCCESS;
    // currrently there is only 1 reg key to set.  Set it if the forest was created using the 
    // Whistler code base.
    if (IsForestWhistlerCreated()) {
	// set registry key
	DWORD dwValue = 1;
	DPRINT(1,"Whistler Forest:  Setting strict replication consistency.\n");
	err = SetConfigParam(DRA_STRICT_REPLICATION_CONSISTENCY, REG_DWORD, &dwValue, sizeof(DWORD));
    } else {
	DPRINT(1,"Non-Whistler Forest:  Leaving replication consistency as-is.\n");
    }

    return (err==ERROR_SUCCESS);
}

NTSTATUS
InstallBaseNTDS(IN  PDS_INSTALL_PARAM   InstallInParams,
                OUT PDS_INSTALL_RESULT  InstallOutParams)
/*++

Routine Description:

    This routine is the workhorse for the directory service installation. It is
    called in two process contexts:

    1) from within the lsass.exe as part of a running system.  Under this
    scenario the dit is assumed to be in such a state so that a new schema can
    be added and domain objects can be added

    2) from mkdit.exe.

Parameters:

    None.

Return Values:

    STATUS_SUCCESS; appropriate nt status mapped from Dir* or DirReplica* call

--*/
{

    NTSTATUS NtStatus;
    ULONG    DirError, DirReplicaErr, WinError;
    ULONG    err=0;
    VOID     *pOutBuf = NULL;
    DWORD    errHeap;
    LPWSTR   pszGuidBasedDnsName = NULL;
    DSNAME   *pDsa = NULL;
    DSNAME   OldDSADN;
    DSNAME   *pNC = NULL; 
    ULONG    size;
    BOOL     fNoMessage = FALSE;

    // The call chain of DirReplicaAdd==>DoOpDRS==>DispatchPao==>InitDraThread
    // calls InitTHSTATE unilaterally - even if you have a thread state active.
    // This is the correct design for the DRA subsystem - InstallBaseNTDS is
    // the anomaly in that it may have a thread state when it makes the call.
    // In order to avoid duplicate InitTHSTATE on a single thread, we will
    // save the thread state prior to calling DirReplicaAdd, let DirReplicaAdd
    // create its own thread state, nuke that thread state on DirReplicaAdd
    // return, and then restore our saved thread state.  Ergo, we must declare:
    VOID *pSaveTHS;

    BOOL fReplicaInstall = FALSE;

    // This is the guid of the ntdsa object when created remotely. We need this
    // so we can set the ntdsa object in the hidden record. (We need it in the
    // hidden record so at boot we can find our ntdsa object)
    GUID ntdsaGuid;

    ASSERT(InstallInParams);
    ASSERT(InstallOutParams);

    gfDoSamChecks = FALSE;
    gUpdatesEnabled = TRUE;

    RtlZeroMemory( &gNames, sizeof( gNames ) );
    RtlZeroMemory( &ntdsaGuid, sizeof(ntdsaGuid) );
    RtlZeroMemory( &OldDSADN, sizeof(OldDSADN) );

    //
    // Tell our caller that we can be cancelled now; also if a cancel has
    // happened in the meantime, then cancel now
    //
    Assert( gpfnInstallCancelOk || !gfRunningInsideLsa );
    if ( gpfnInstallCancelOk )
    {
        WinError = gpfnInstallCancelOk( TRUE );
        if ( ERROR_SUCCESS != WinError )
        {
            SET_INSTALL_ERROR_MESSAGE0( ERROR_CANCELLED,
                                       DIRMSG_INSTALL_DS_CORE_INSTALL_FAILED );
            return STATUS_CANCELLED;
        }
    }
    if ( DsaIsInstallingFromMedia() ) {
        NtStatus = ClearNonReplicatedAttributes();
        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }

        NtStatus = CheckTombstone();
        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        } 

        NtStatus = CheckReplicationEpoch(InstallInParams->ReplicationEpoch);
        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }
    
        NtStatus = HandleKeys(  (IFM_SYSTEM_INFO * )InstallInParams->pIfmSystemInfo,
                                InstallInParams->BootKey, 
                                InstallInParams->cbBootKey);

        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }

        //save the guid of the current DSA 
        OldDSADN.structLen = DSNameSizeFromLen( 0 );
        RtlCopyMemory( &OldDSADN.Guid, &gAnchor.pDSADN->Guid, sizeof(GUID) );
        
    }

    // Initialize the root domain DNS name in the Anchor
    // The RPC SPN code and DsAddrFromName use it
    gAnchor.pwszRootDomainDnsName
        = (LPWSTR) malloc(MAX_PATH * sizeof(WCHAR));
    if (NULL == gAnchor.pwszRootDomainDnsName) {
        SET_INSTALL_ERROR_MESSAGE0(ERROR_OUTOFMEMORY, DIRMSG_INSTALL_FAILED_GENERAL);
        return STATUS_NO_MEMORY;
    }

    WinError = GetConfigParamW(MAKE_WIDE(ROOTDOMAINDNSNAME),
                               gAnchor.pwszRootDomainDnsName,
                               MAX_PATH);
    if (WinError) {
        SET_INSTALL_ERROR_MESSAGE0(WinError, DIRLOG_INSTALL_FAILED_REGISTRY);
        return STATUS_REGISTRY_IO_FAILED;
    }

    _try
    {
        //
        // Read values in from the registry and set the values
        // in variable global to this module (boot.lib)
        //
        NtStatus = InitializeNTDSSetup();

        if (!NT_SUCCESS(NtStatus)) {
            DPRINT1(0,"InitializeNTDSSetup failed with 0x%x\n", NtStatus);
            _leave;
        }

        if ( gNames.SrcRootDomainSrv && L'\0' != gNames.SrcRootDomainSrv[ 0 ] )
        {
            fReplicaInstall = TRUE;
        }

        if ( !gNames.SrcConfigNCSrv || L'\0' == gNames.SrcConfigNCSrv[ 0 ] )
        {
            GUID UnusedGuid;
            CROSS_REF *pUnusedCR;
            // First DS in the enterprise - i.e. not a replicated install.
            // Need to create NC objects root to leaf so that AddCatalogInfo()
            // succeeds when it tries to modify the parent NC's ATT_SUB_REFS
            // property.

            // Make sure the gInstallHasDoneSchemaMove is false (setting once
            // globally causes problems if dcpromo fails after schema rename
            // and is restarted without reboot. The flag then stays on as true
            // causing phantoms of schema objects to be created during 
            // object-category value adds, causing a jet exception later
            // when the boot schema object is being renamed to the same name
            // as this phantom)

            gInstallHasDoneSchemaMove = FALSE;

            NtStatus = CreateRootDomainObject(gNames.RootDomainDNName,
                                              &UnusedGuid,
                                              NULL);

            if (!NT_SUCCESS(NtStatus))
            {
                DPRINT2(0,"CreateRootDomainObject(%ws). Error 0x%x\n",
                gNames.RootDomainDNName,NtStatus);

                SET_INSTALL_ERROR_MESSAGE1( RtlNtStatusToDosError( NtStatus ),
                                            DIRMSG_INSTALL_FAILED_TO_CREATE_OBJECT,
                                            gNames.RootDomainDNName );

                fNoMessage = TRUE;
                _leave;
            }

            NtStatus = CreateConfigNCObject(gNames.ConfigNCDNName);

            if (!NT_SUCCESS(NtStatus))
            {
                DPRINT2(0,"CreateConfigNCObject(%s). Error 0x%x\n",
                gNames.ConfigNCDNName, NtStatus);

                SET_INSTALL_ERROR_MESSAGE1( RtlNtStatusToDosError( NtStatus ),
                                            DIRMSG_INSTALL_FAILED_TO_CREATE_OBJECT,
                                            gNames.ConfigNCDNName );

                fNoMessage = TRUE;
                _leave;
            }

            NtStatus = CreateSchemaNCObject(gNames.SchemaDNName);

            if (!NT_SUCCESS(NtStatus))
            {
                DPRINT2(0,"CreateSchemaNCObject(%s). Error 0x%x\n",
                gNames.SchemaDNName, NtStatus);

                SET_INSTALL_ERROR_MESSAGE1( RtlNtStatusToDosError( NtStatus ),
                                            DIRMSG_INSTALL_FAILED_TO_CREATE_OBJECT,
                                            gNames.SchemaDNName );

                fNoMessage = TRUE;
                _leave;
            }

            UpdateCreateNCInstallMessage(gNames.SchemaDNName,
                                         UPDATE_SCHEMA_NC_INDEX );
            
            if(DBInitialSetup(gNames.SchemaDNName)) {
                DPRINT2(0,"Move initial schema (%S). Error 0x%x\n",
                        gNames.SchemaDNName, NtStatus);

                NtStatus = STATUS_UNSUCCESSFUL;
                SET_INSTALL_ERROR_MESSAGE1(RtlNtStatusToDosError( NtStatus ),
                                           DIRMSG_INSTALL_FAILED_TO_MOVE_BOOT_SCHEMA,
                                           gNames.SchemaDNName );

                fNoMessage = TRUE;
                _leave;
            }
            
            gInstallHasDoneSchemaMove = TRUE;

            UpdateCreateNCInstallMessage( gNames.ConfigNCDNName, 
                                          UPDATE_CONFIG_NC_INDEX );

            NtStatus  =  CreateDefaultConfigNCDIT(gNames.ConfigNCDNName);

            if (!NT_SUCCESS(NtStatus))
            {
                DPRINT2(0,"CreateConfigNCDIT(%s). Error 0x%x\n",
                gNames.ConfigNCDNName, NtStatus);

                SET_INSTALL_ERROR_MESSAGE1( RtlNtStatusToDosError( NtStatus ),
                                            DIRMSG_INSTALL_FAILED_NC_CREATE,
                                            gNames.ConfigNCDNName );

                fNoMessage = TRUE;
                _leave;
            }

            UpdateCreateNCInstallMessage( gNames.RootDomainDNName, 
                                          UPDATE_DOMAIN_NC_INDEX );

            NtStatus  =  CreateDefaultRootDomainDIT(gNames.RootDomainDNName);

            if (!NT_SUCCESS(NtStatus))
            {
                DPRINT2(0,"CreateDefaultRootDomainDIT(%s). Error 0x%x\n",
                gNames.RootDomainDNName, NtStatus);

                SET_INSTALL_ERROR_MESSAGE1( RtlNtStatusToDosError( NtStatus ),
                                            DIRMSG_INSTALL_FAILED_NC_CREATE,
                                            gNames.RootDomainDNName );

                fNoMessage = TRUE;
                _leave;
            }

            // Create machine object.

            SetInstallStatusMessage( DIRMSG_INSTALL_CREATING_LOCAL_DS,
                                    NULL, NULL, NULL, NULL, NULL );

            NtStatus = CreateNtdsDsaObject(gNames.DsaDNName,
                                           gNames.RootDomainDNName,
                                           gNames.ConfigNCDNName,
                                           gNames.SchemaDNName);

            if (!NT_SUCCESS(NtStatus))
            {
                DPRINT1(0,"CreateNtdsDsaObject failed. Error 0x%x\n", NtStatus);

                SET_INSTALL_ERROR_MESSAGE1( RtlNtStatusToDosError( NtStatus ),
                                            DIRMSG_INSTALL_FAILED_TO_CREATE_NTDSA_OBJECT,
                                            gNames.DsaDNName );

               fNoMessage = TRUE;
                _leave;
            }

	    // set replication consistency registry key.
	    if ( NT_SUCCESS( NtStatus ) ) {
		if (!SetDraReplConsisInstallRegKey()) {
		    Assert(!"Unable to set Repl Consistency Regsitry Key");
		    // not fatal, log that we had problems setting the key.
		    LogEvent(DS_EVENT_CAT_REPLICATION,
			     DS_EVENT_SEV_ALWAYS,
			     DIRLOG_REPL_SET_STRICT_CONSIS_FAILURE,
			     DSA_CONFIG_SECTION, DRA_STRICT_REPLICATION_CONSISTENCY, NULL);
		} 
	    }

        }
        else
        {
            // Replicated install case.  Schema and Configuration NC always come
            // from the same machine.  Domain info may come from another machine
            // or be created locally if this is the first instance of a child
            // domain.
            // We always use compression initially because we don't yet know
            // what the network connection to the other server is like yet.
            // If it's a fast link we'll have wasted a few CPU cycles (and the
            // KCC will later remove the compression flag from the replica
            // flags), but if it's a slow link then usign compression will have
            // saved 90% of the network bandwidth that would have been required

            ULONG     ulOptions =  DRS_WRIT_REP
                                 | DRS_INIT_SYNC
                                 | DRS_PER_SYNC
                                 | DRS_USE_COMPRESSION;
            REPLTIMES repltimes;
            WCHAR *   RemoteServer;
            ULONG     Length;
            LPWSTR    pszSourceDsaGuidBasedDnsName = NULL;
            UUID      uuidSourceDsaObjGuid = {0};
            LPWSTR    pszSourceDsaDnsDomainName = NULL;
            
            for (int i=0;i< 84;i++)
            {
               repltimes.rgTimes[i] = 0xff;        // Every 15 minutes
            }

            if (gNames.SourceDsaDnsDomainName && *gNames.SourceDsaDnsDomainName) {
                // We were given the source's DNS domain name -- this allows us
                // to perform mutual auth.
                pszSourceDsaDnsDomainName = gNames.SourceDsaDnsDomainName;
            }

            // Make sure the gInstallHasDoneSchemaMove is false (setting once
            // globally causes problems if dcpromo fails after schema rename
            // and is restarted without reboot. The flag then stays on as true
            // causing phantoms of schema objects to be created during 
            // object-category value adds, causing a jet exception later
            // when the boot schema object is being renamed to the same name
            // as this phantom)

            gInstallHasDoneSchemaMove = FALSE;
            // Delete the boot schema, we never needed it.
            if(!DsaIsInstallingFromMedia() && DBInitialSetup(NULL)) {
                NtStatus = STATUS_UNSUCCESSFUL;
                DPRINT1(0,"Delete initial schema. Error 0x%x\n", NtStatus);
                
                SET_INSTALL_ERROR_MESSAGE1(RtlNtStatusToDosError( NtStatus ),
                                           DIRMSG_INSTALL_FAILED_TO_MOVE_BOOT_SCHEMA,
                                           NULL );

                fNoMessage = TRUE;
                _leave;
            }
            gInstallHasDoneSchemaMove = TRUE;

            // Initialize the DRA.
            if (WinError = InitDRA(pTHStls)) {
                // This should never happen -- currently always returns 0 if
                // DsaIsInstalling().  Therefore we don't make any special
                // effort to report a descriptive message.
                Assert(!"DRA Initialize failed!");
                LogUnhandledError(WinError);
                NtStatus = STATUS_UNSUCCESSFUL;
                SET_INSTALL_ERROR_MESSAGE0(NtStatus, DIRMSG_INSTALL_FAILED_GENERAL);
                fNoMessage = TRUE;
                _leave;
            }

            if (DsaIsInstallingFromMedia()) {
                //Update the pDSADN to a temp value
                NtStatus = CreateDummyNtdsDsaObject();
    
                if (!NT_SUCCESS(NtStatus))
                {
                    DPRINT1(0,"CreateNtdsDsaObject failed. Error 0x%x\n", NtStatus);
    
                    fNoMessage = TRUE;
                    _leave;
                }

                NtStatus = CopyDsaAttributes( InstallInParams, &OldDSADN, gAnchor.pDSADN, FALSE);
                if (!NT_SUCCESS(NtStatus)) {
                    fNoMessage = TRUE;
                    _leave;
                }

                //save the guid of the current DSA 
                ZeroMemory(&OldDSADN,OldDSADN.structLen);
                OldDSADN.structLen = DSNameSizeFromLen( 0 );
                RtlCopyMemory( &OldDSADN.Guid, &gAnchor.pDSADN->Guid, sizeof(GUID) );

            }

            //If the replicationEpoch is not zero, then it is nessary to 
            //update the value to equal that of the server that the NtdsDsa
            //object will be created on.  The remote call will fail with
            //Mismatched replication epochs if this is not done.
           
            NtStatus = UpdateReplicationEpochAndHiddenDSA(gAnchor.pDSADN,
                                                          InstallInParams->ReplicationEpoch,
                                                          FALSE);
    
            if (!NT_SUCCESS(NtStatus))
            {
                DPRINT1(0,"UpdateReplicationEpochAndHiddenDSA failed. Error 0x%x\n", NtStatus);

                fNoMessage = TRUE;
                _leave;
            } 
            
            if ( fReplicaInstall )
            {
                //
                //  Try to add the server remotely
                //
                SetInstallStatusMessage( DIRMSG_CREATING_REMOTE_NTDSA,
                                         gNames.SrcConfigNCSrv, NULL, NULL,
                                         NULL, NULL );

                WinError = CreateRemoteNtdsDsaObject( &ntdsaGuid );
                if ( ERROR_DS_DRA_NOT_SUPPORTED == WinError )
                {
                    // Fine - we'll add the object locally
                    WinError = ERROR_SUCCESS;
                }

                else if ( ERROR_SUCCESS != WinError )
                {
                    // This is fatal
                    SET_INSTALL_ERROR_MESSAGE2( WinError,
                                                DIRMSG_FAILED_TO_CREATE_REMOTE_NTDSA,
                                                gNames.DsaDNName,
                                                gNames.SrcConfigNCSrv );
    
                    NtStatus = STATUS_UNSUCCESSFUL;
                    fNoMessage = TRUE;
                    _leave;
                } else  {

                    //
                    // Note that the server object has been created
                    // so that it can be removed if a failure occurs later
                    // on
                    //
                    Assert( ERROR_SUCCESS == WinError );
                    InstallOutParams->InstallOperationsDone |= NTDS_INSTALL_SERVER_CREATED;
                    
                }

            }

            SetInstallStatusMessage( DIRMSG_INSTALL_REPLICATING_SCHEMA,
                                    NULL, NULL, NULL, NULL, NULL );

            size = (ULONG)DSNameSizeFromLen(wcslen(gNames.SchemaDNName));
            pNC = (PDSNAME) XCalloc( 1, size );
            BuildDefDSName(pNC,gNames.SchemaDNName,NULL);
            
            pSaveTHS = InstallTHSave();
            DirReplicaErr = DirReplicaAdd(pNC,
                                          NULL,
                                          NULL,
                                          gNames.SrcConfigNCSrv,
                                          pszSourceDsaDnsDomainName,
                                          &repltimes,
                                          ulOptions);
            
            XFree(pNC); pNC = NULL;
            THDestroy();
            InstallTHRestore(pSaveTHS);

            if (DirReplicaErr != DRAERR_Success)
            {
                DPRINT3(0, "DirReplicaAdd(%ls,%ls) Failed. Error %d\n",
                        gNames.SchemaDNName, gNames.SrcConfigNCSrv,
                        DirReplicaErr);

                //
                // Set the error message with the win32 value, too
                // (DirReplicaErr is a winerror)
                //
                SET_INSTALL_ERROR_MESSAGE2( DirReplicaErr,
                                            DIRMSG_INSTALL_FAILED_REPLICATION,
                                            gNames.SchemaDNName,
                                            gNames.SrcConfigNCSrv );

                NtStatus = DirReplicaErrorToNtStatus(DirReplicaErr);
                fNoMessage = TRUE;
                _leave;
            }
            else
            {
                PDSNAME pDMDSave;

                DPRINT2(0, "DirReplicaAdd(%ls,%ls) Succeeded\n",
                        gNames.SchemaDNName, gNames.SrcConfigNCSrv);

                SetInstallStatusMessage(DISMSG_INSTALL_SCHEMA_COMPELETE,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL);
                // While replicating the schemaNC, the in-memory schema
                // cache was updated without re-reading the contents of
                // the DIT (See AddObjCaching). This protocol has been
                // left in place even though it doesn't quite work
                // with the new schema defunct, reuse, and delete code.
                // Still, it should be okay because the schemaNC must
                // be replicatable w/the shipped schema and not depend
                // on changes in the parent. If replicating the schemaNC
                // depends on changes from the parent then, since
                // replication order is not guaranteed, the wrong schema
                // objects may replicate in at the wrong time and
                // replication fails.
                //
                // But defuncted and colliding schema objects must be
                // properly encached before replicating other NCs.
                // So reload the schema cache from the newly replicated
                // schemaNC in the DIT.
                //
                // There should be enough infrastructure in place to
                // successfully reload the schema cache because the
                // cache was successfully loaded earlier by Install().
                //
                // Be careful to maintain current state like the other code
                // in this function.
                //

                // name of the newly-replicated schemaNC
                size = (ULONG)DSNameSizeFromLen(wcslen(gNames.SchemaDNName));
                pNC = (PDSNAME) XCalloc( 1, size );
                BuildDefDSName(pNC,gNames.SchemaDNName,NULL);

                // Save current thread state
                pSaveTHS = InstallTHSave();

                // Set schemaNC name to the newly replicated schemaNC.
                pDMDSave = gAnchor.pDMD;
                gAnchor.pDMD = pNC;

                // reload the schema (allocates and frees thread state)
                DirReplicaErr = SCUpdateSchema();

                // just to be safe, reset schemaNC's name and forest version
                gAnchor.pDMD = pDMDSave;

                // restore thread state
                XFree(pNC); pNC = NULL;
                InstallTHRestore(pSaveTHS);

                // Did it work?
                if (DirReplicaErr != DRAERR_Success) {
                    DPRINT3(0, "ReloadSchemaCache(%ls,%ls) Failed. Error %d\n",
                            gNames.SchemaDNName, gNames.SrcConfigNCSrv,
                            DirReplicaErr);
                    //
                    // Set the error message with the win32 value, too
                    // (DirReplicaErr is a winerror)
                    //
                    SET_INSTALL_ERROR_MESSAGE2( DirReplicaErr,
                                                DIRMSG_INSTALL_FAILED_SCHEMA_RELOAD,
                                                gNames.SchemaDNName,
                                                gNames.SrcConfigNCSrv );

                    NtStatus = DirReplicaErrorToNtStatus(DirReplicaErr);
                    fNoMessage = TRUE;
                    _leave;
                } else {
                    DPRINT2(0, "ReloadSchemaCache(%ls,%ls) Succeeded\n",
                            gNames.SchemaDNName, gNames.SrcConfigNCSrv);

                    SetInstallStatusMessage(DISMSG_RELOAD_SCHEMA_COMPELETE,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL);
                }
            }

            // Now the configuration container.

            SetInstallStatusMessage( DIRMSG_INSTALL_REPLICATING_CONFIG,
                                    NULL, NULL, NULL, NULL, NULL );

            size = (ULONG)DSNameSizeFromLen(wcslen(gNames.ConfigNCDNName));
            pNC = (PDSNAME) XCalloc( 1, size );
            BuildDefDSName(pNC,gNames.ConfigNCDNName,NULL);

            pSaveTHS = InstallTHSave();
            DirReplicaErr = DirReplicaAdd(pNC,
                                          NULL,
                                          NULL,
                                          gNames.SrcConfigNCSrv,
                                          pszSourceDsaDnsDomainName,
                                          &repltimes,
                                          ulOptions);

            XFree(pNC); pNC = NULL;
            THDestroy();
            InstallTHRestore(pSaveTHS);

            if (DirReplicaErr)
            {
                DPRINT3(0, "DirReplicaAdd(%ls,%ls) Failed. Error %d\n",
                        gNames.ConfigNCDNName, gNames.SrcConfigNCSrv,
                        DirReplicaErr);

                //
                // Set the error message with the win32 value, too
                // (DirReplicaErr is a winerror)
                //
                SET_INSTALL_ERROR_MESSAGE2( DirReplicaErr,
                                            DIRMSG_INSTALL_FAILED_REPLICATION,
                                            gNames.ConfigNCDNName,
                                            gNames.SrcConfigNCSrv );

                NtStatus = DirReplicaErrorToNtStatus(DirReplicaErr);
                fNoMessage = TRUE;
                _leave;
            }
            else
            {
                SetInstallStatusMessage(DISMSG_INSTALL_CONFIGURATION_COMPELETE,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL);

                DPRINT2(0, "DirReplicaAdd(%ls,%ls) Succeeded\n",
                        gNames.ConfigNCDNName, gNames.SrcConfigNCSrv);
            } 

            // Now the domain NC.

            if ( !gNames.SrcRootDomainSrv || '\0' == gNames.SrcRootDomainSrv[ 0 ] )
            {
                GUID DomainGuid = {0, 0, 0, 0};
                CROSS_REF *pCR;
                COMMARG CommArg;

                // First DC in the child domain.  Just create the domain
                // object and let dsupgrad populate the domain later.
                // Note that "gNames.RootDomainDNName" is misleading - this
                // is really the name of the child domain.
        
                //
                // See if we we have a cross ref locally
                //
                InitCommarg(&CommArg);
                CommArg.Svccntl.dontUseCopy = FALSE;
        
                size = (ULONG)DSNameSizeFromLen(wcslen(gNames.RootDomainDNName));
                pNC = (PDSNAME) XCalloc( 1, size );
                BuildDefDSName(pNC,
                               gNames.RootDomainDNName,
                               NULL     // No Guid
                              );
        
                pCR = FindExactCrossRef(pNC,
                                        &CommArg);

                if (pCR && !fNullUuid(&(pCR->pNC->Guid))) {
                    // This NC is known, and it already has a GUID.  Use it.
                    DomainGuid = pCR->pNC->Guid;
                }

                //
                //  N.B. We need to create the cross ref first so that we
                //  can use whateven guid is generated on the NC subref/phantom
                //  to create the real NC head locally
                //

                // Create corresponding Cross-Ref object in the partitions
                // container.

                err = CreateChildDomainCrossRef(InstallOutParams,
                                                NULL,
                                                pCR,
                                                &ntdsaGuid);


                if (err != ERROR_SUCCESS)
                {
                    DPRINT1(0,"CreateChildDomainCrossRef(). Error 0x%x\n",err);

                    SET_INSTALL_ERROR_MESSAGE1( err,
                                                DIRMSG_INSTALL_FAILED_TO_CREATE_DOMAIN_OBJECT,
                                                gNames.RootDomainDNName );

                    NtStatus = DirReplicaErrorToNtStatus(err);
                    fNoMessage = TRUE;
                    _leave;
                }

                //
                // At this point, we have an update version version of domains
                // are in the enterprise.  Check to make sure the sid we are
                // about to add, doesn't already exist
                //
                err = CheckForDuplicateDomainSid();
                if ( err ) {

                    DPRINT( 0, "This domain sid is already in use!\n" );

                    SET_INSTALL_ERROR_MESSAGE0( err,
                                                DIRMSG_DOMAIN_SID_EXISTS );

                    NtStatus = STATUS_UNSUCCESSFUL;
                    fNoMessage = TRUE;
                    _leave;
                }

                // We should now have the cross ref object locally if the function
                // above succeeded
                pCR = FindExactCrossRef(pNC, &CommArg);
                Assert( pCR );

                XFree(pNC); pNC = NULL;

                UpdateCreateNCInstallMessage( gNames.RootDomainDNName, 
                                              UPDATE_DOMAIN_NC_INDEX );

                NtStatus = CreateRootDomainObject(gNames.RootDomainDNName,
                                                  &DomainGuid,
                                                  pCR);

                if (!NT_SUCCESS(NtStatus))
                {
                    DPRINT2(0,"CreateRootDomainObject(%s). Error 0x%x\n",
                    gNames.RootDomainDNName,NtStatus);

                    //
                    // Set the error message with the win32 value, too
                    // (DirReplicaErr is a winerror)
                    //
                    SET_INSTALL_ERROR_MESSAGE1( RtlNtStatusToDosError( NtStatus ),
                                                DIRMSG_INSTALL_FAILED_TO_CREATE_DOMAIN_OBJECT,
                                                gNames.RootDomainDNName );

                    fNoMessage = TRUE;
                    _leave;
                }

                NtStatus  =  CreateDefaultRootDomainDIT(gNames.RootDomainDNName);
                if (!NT_SUCCESS(NtStatus))
                {
                    DPRINT2(0,"CreateDefaultRootDomainDIT(%s). Error 0x%x\n",
                    gNames.RootDomainDNName,NtStatus);

                    SET_INSTALL_ERROR_MESSAGE1( RtlNtStatusToDosError( NtStatus ),
                                                DIRMSG_INSTALL_FAILED_NC_CREATE,
                                                gNames.RootDomainDNName );
                    fNoMessage = TRUE;
                    _leave;
                }

                //
                // Force a change to the cross ref so it replicates out
                // 
                WinError  =  ForceChangeToDomainCrossRef( pCR->pObj,
                                                          gNames.RootDomainDNName,
                                                          &DomainGuid );
                if ( ERROR_SUCCESS != WinError )
                {
                    DPRINT2(0,"ForceChangeToDomainCrossRef(%s). Error %d\n",
                    gNames.RootDomainDNName,WinError);

                    SET_INSTALL_ERROR_MESSAGE1( WinError,
                                                DIRMSG_INSTALL_FAILED_NC_CREATE,
                                                gNames.RootDomainDNName );
                    NtStatus = STATUS_UNSUCCESSFUL;
                    fNoMessage = TRUE;
                    _leave;
                }

                // Since this is a new child/tree in a existing forest
                // the NtdsDsa object was created in CreateChildDomainCrossRef()
                // The NtdsDsa will have it's replicationEpoch updated at this point
                // The Hidden table will be updated at this time to point to newly
                // replicated Ntds settings object.
                size = DSNameSizeFromLen( 0 );

                pDsa = (DSNAME*) XCalloc( 1, size );
                pDsa->structLen = size;
                RtlCopyMemory( &pDsa->Guid, &ntdsaGuid, sizeof(GUID) );

                NtStatus = UpdateReplicationEpochAndHiddenDSA(pDsa,
                                                              InstallInParams->ReplicationEpoch,
                                                              TRUE);
        
                if (!NT_SUCCESS(NtStatus))
                {
                    DPRINT1(0,"UpdateReplicationEpochAndHiddenDSA failed. Error 0x%x\n", NtStatus);
    
                    fNoMessage = TRUE;
                    _leave;

                }
                XFree(pDsa); pDsa = NULL;

            }
            else
            {
                // Replicate the domain NC.

                //At this point the Ntds Settings object has been replicated
                //from the helper server. The ReplicationEpoch must be updated 
                //to have the same value as the helper server so that the newly 
                //created server can replicate with the other DCs in the enterprise.
                //The Hiddle Table will be update to point to the new Dsa

                size = DSNameSizeFromLen( 0 );

                pDsa = (DSNAME*) XCalloc( 1, size );
                pDsa->structLen = size;
                RtlCopyMemory( &pDsa->Guid, &ntdsaGuid, sizeof(GUID) );

                if (DsaIsInstallingFromMedia()) {

                    NtStatus = CopyDsaAttributes( InstallInParams, &OldDSADN, pDsa, TRUE);
                    if (!NT_SUCCESS(NtStatus)) {
                        XFree(pDsa); pDsa = NULL;
                        fNoMessage = TRUE;
                        _leave;
                    }

                    //Remove the temp NTDS Setting Object
                    //No longer need since the ntds has been replicated down
                    //with the configNC
                    err = DeleteDummyNtdsDsaObject();
                    Assert(err == 0);
                    if (err)
                    {
                        // This shouldn't happen because
                        // We create this object
                        WinError = err;
                        _leave;
                    }

                }

                NtStatus = UpdateReplicationEpochAndHiddenDSA(pDsa,
                                                              InstallInParams->ReplicationEpoch,
                                                              TRUE);
        
                if (!NT_SUCCESS(NtStatus))
                {
                    DPRINT1(0,"UpdateReplicationEpochAndHiddenDSA failed. Error 0x%x\n", NtStatus);
    
                    fNoMessage = TRUE;
                    _leave;

                }

                XFree(pDsa); pDsa = NULL;

                //
                // Convert the machine account to a domain controller machine
                // account so that it will be replicated down during the
                // critical replication.
                //
                err = ConvertMachineAccount(InstallInParams,
                                            InstallOutParams);
                if (err) {
                    //
                    // Fatal error; global error has already been set
                    //
                    NtStatus = STATUS_UNSUCCESSFUL;
                    fNoMessage = TRUE;
                    _leave;

                }

                SetInstallStatusMessage( DIRMSG_INSTALL_REPLICATING_DOMAIN,
                                        NULL, NULL, NULL, NULL, NULL );

                size = (ULONG)DSNameSizeFromLen(wcslen(gNames.RootDomainDNName));
                pNC = (PDSNAME) XCalloc( 1, size );
                BuildDefDSName(pNC,gNames.RootDomainDNName,NULL);

                ulOptions |= DRS_CRITICAL_ONLY;
                DPRINT(0,"Replicating only critical objects from Domain NC.\n" );
                pSaveTHS = InstallTHSave();
                DirReplicaErr = DirReplicaAdd(pNC,
                                              NULL,
                                              NULL,
                                              gNames.SrcRootDomainSrv,
                                              pszSourceDsaDnsDomainName,
                                              &repltimes,
                                              ulOptions);
                
                XFree(pNC); pNC = NULL;
                THDestroy();
                InstallTHRestore(pSaveTHS);

                if (DirReplicaErr)
                {
                    DPRINT3(0, "DirReplicaAdd(%ls,%ls) Failed. Error %d\n",
                            gNames.RootDomainDNName, gNames.SrcRootDomainSrv,
                            DirReplicaErr);


                    SET_INSTALL_ERROR_MESSAGE2( DirReplicaErr,
                                                DIRMSG_INSTALL_FAILED_REPLICATION,
                                                gNames.RootDomainDNName,
                                                gNames.SrcRootDomainSrv );

                    NtStatus = DirReplicaErrorToNtStatus(DirReplicaErr);
                    fNoMessage = TRUE;
                    _leave;

                }
                else
                {
                    SetInstallStatusMessage(DISMSG_INSTALL_CRITICAL_COMPELETE,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL);

                    DPRINT2(0, "DirReplicaAdd(%ls,%s) Succeeded\n",
                            gNames.RootDomainDNName, gNames.SrcRootDomainSrv);

                    //
                    // Now that we have successfully replicated in critial domain objects
                    // We need to ensure that there aren't any machine accounts in the 
                    // restored dit that have the same samaccountname as the local machine
                    // if there are then we will rename them.

                    if (DsaIsInstallingFromMedia()) {
                        NtStatus = RenameAdditionalMachineAccountsIfAny(&fNoMessage);
                        if (!NT_SUCCESS(NtStatus)) {
                            _leave;
                        }
                    }
                }
            }

	    // set replication consistency registry key.
	    if ( NT_SUCCESS( NtStatus ) ) {
		if (!SetDraReplConsisInstallRegKey()) {
		    Assert(!"Unable to set Repl Consistency Regsitry Key");
		    // not fatal, log that we had problems setting the key.
		    LogEvent(DS_EVENT_CAT_REPLICATION,
			     DS_EVENT_SEV_ALWAYS,
			     DIRLOG_REPL_SET_STRICT_CONSIS_FAILURE,
			     DSA_CONFIG_SECTION, DRA_STRICT_REPLICATION_CONSISTENCY, NULL);
		} 
	    }

	    Assert(!fNullUuid(&ntdsaGuid));
                
            // Derive our GUID-based DNS name.
            {
                DSNAME DN = {0};

                DN.Guid = ntdsaGuid;
                DN.structLen = DSNameSizeFromLen(0);

                pszGuidBasedDnsName = DSaddrFromName(pTHStls, &DN);
                if (NULL == pszGuidBasedDnsName) {
                    SET_INSTALL_ERROR_MESSAGE0(ERROR_OUTOFMEMORY,
                                               DIRLOG_INSTALL_FAILED_GENERAL);
                    NtStatus = STATUS_NO_MEMORY;
                    fNoMessage = TRUE;
                    _leave;
                }
            }
            
            if (0 == WinError) {
                Assert(!pNC);
                // Add repsTo for schema NC on the source DSA to enable change
                // notifications.
                size = (ULONG)DSNameSizeFromLen(wcslen(gNames.SchemaDNName));
                pNC = (PDSNAME) XCalloc( 1, size );
                BuildDefDSName(pNC, gNames.SchemaDNName, NULL);
    
                WinError = I_DRSUpdateRefs(pTHStls,
                                           gNames.SrcConfigNCSrv,
                                           pNC,
                                           pszGuidBasedDnsName,
                                           &ntdsaGuid,
                                           DRS_WRIT_REP
                                             | DRS_ADD_REF
                                             | DRS_DEL_REF);
                
                // Derive source DSA's GUID-based DNS name.
                if (0 == WinError) {
                    WinError = GetSourceDsaGuidBasedDnsName(pTHStls,
                                                            pNC,
                                                            gNames.SrcRootDomainSrv,
                                                            &uuidSourceDsaObjGuid,
                                                            &pszSourceDsaGuidBasedDnsName);
                }

                // Update repsFrom with source's GUID-based DNS name.
                if (0 == WinError) {
                    WinError = DirReplicaModify(pNC,
                                                &uuidSourceDsaObjGuid,
                                                NULL,
                                                pszSourceDsaGuidBasedDnsName,
                                                NULL,
                                                0,
                                                DRS_UPDATE_ADDRESS,
                                                0);
                }
            }

            if (0 == WinError) {
                XFree(pNC); pNC = NULL;
                // Add repsTo for config NC.
                size = (ULONG)DSNameSizeFromLen(wcslen(gNames.ConfigNCDNName));
                pNC = (PDSNAME) XCalloc( 1, size );
                BuildDefDSName(pNC, gNames.ConfigNCDNName, NULL);

                WinError = I_DRSUpdateRefs(pTHStls,
                                           gNames.SrcConfigNCSrv,
                                           pNC,
                                           pszGuidBasedDnsName,
                                           &ntdsaGuid,
                                           DRS_WRIT_REP
                                             | DRS_ADD_REF
                                             | DRS_DEL_REF);
                
                // Update repsFrom with source's GUID-based DNS name.
                if (0 == WinError) {
                    WinError = DirReplicaModify(pNC,
                                                &uuidSourceDsaObjGuid,
                                                NULL,
                                                pszSourceDsaGuidBasedDnsName,
                                                NULL,
                                                0,
                                                DRS_UPDATE_ADDRESS,
                                                0);
                }
            }

            if ((0 == WinError)
                && (L'\0' != gNames.SrcRootDomainSrv[0])) {
                XFree(pNC); pNC = NULL;
                // Add repsTo for domain NC, if needed.
                size = (ULONG)DSNameSizeFromLen(wcslen(gNames.RootDomainDNName));
                pNC = (PDSNAME) XCalloc( 1, size );
                BuildDefDSName(pNC, gNames.RootDomainDNName, NULL);

                WinError = I_DRSUpdateRefs(pTHStls,
                                           gNames.SrcRootDomainSrv,
                                           pNC,
                                           pszGuidBasedDnsName,
                                           &ntdsaGuid,
                                           DRS_WRIT_REP
                                             | DRS_ADD_REF
                                             | DRS_DEL_REF);
                
                // Update repsFrom with source's GUID-based DNS name.
                if (0 == WinError) {
                    WinError = DirReplicaModify(pNC,
                                                &uuidSourceDsaObjGuid,
                                                NULL,
                                                pszSourceDsaGuidBasedDnsName,
                                                NULL,
                                                0,
                                                DRS_UPDATE_ADDRESS,
                                                0);
                }
            }

            if (0 != WinError) {
                // Failed to add repsTo / update repsFrom.
                SET_INSTALL_ERROR_MESSAGE2(WinError,
                                           DIRMSG_INSTALL_FAILED_REPLICATION,
                                           pNC->StringName,
                                           gNames.SrcConfigNCSrv);
                XFree(pNC); pNC = NULL;
                NtStatus = DirReplicaErrorToNtStatus(WinError);
                fNoMessage = TRUE;
                _leave;

            }
            XFree(pNC); pNC = NULL;

        }
 
    }
    _finally
    {
        gfDoSamChecks = TRUE;

        if (pNC) {
            XFree(pNC); pNC = NULL;
        }
        if (pDsa) {
            XFree(pDsa); pDsa = NULL;
        }
        
        InstallFreeGlobals();

        if (!NT_SUCCESS(NtStatus))
        {
            DPRINT1(0,"NTDS:InstallNTDS(). Error Code=0x%x\n", NtStatus );
        }

        CleanupIniCache();
        DestroyInstallHeap();

        //
        // Remove unused reg keys
        //

        ZapTempRegKeys( );

        //
        // Tell our caller don't cancel at this point
        //
        Assert( gpfnInstallCancelOk || !gfRunningInsideLsa );
        if ( gpfnInstallCancelOk )
        {
            WinError = gpfnInstallCancelOk( FALSE );  // FALSE -> don't shutdown
            if ( ERROR_SUCCESS != WinError )
            {
                SET_INSTALL_ERROR_MESSAGE0( ERROR_CANCELLED,
                                           DIRMSG_INSTALL_DS_CORE_INSTALL_FAILED );
                NtStatus =  STATUS_CANCELLED;
            }
        }
    }

    if ( !NT_SUCCESS( NtStatus ) && !fNoMessage )
    {
        //
        // Set a catch all error message
        //
        SET_INSTALL_ERROR_MESSAGE0( ERROR_DS_NOT_INSTALLED,
                                    DIRMSG_INSTALL_DS_CORE_INSTALL_FAILED );

    }

    return NtStatus;
}


VOID
ZapTempRegKeys(
    VOID
    )
{
    struct {
        TCHAR*  Key;

    } actionArray[] = {
        TEXT(INIDEFAULTSCHEMANCDIT),
        TEXT(INIDEFAULTCONFIGNCDIT),
        TEXT(INIDEFAULTROOTDOMAINDIT),
        TEXT(INIDEFAULTNEWDOMAINCROSSREF),
        TEXT(INIDEFAULTMACHINE),
        TEXT(INIDEFAULTLOCALCONNECTION),
        TEXT(INSTALLSITEDN),
        TEXT(ROOTDOMAINSID),
        TEXT(GPO_DOMAIN_FILE_PATH),
        TEXT(GPO_DOMAIN_LINK),
        TEXT(GPO_DC_FILE_PATH),
        TEXT(GPO_DC_LINK),
        TEXT(GPO_USER_NAME),
        TEXT(INIDEFAULTREMOTECONNECTION),
        TEXT(TRUSTEDCROSSREF),
        TEXT(NTDSINIFILE),
        TEXT(LOCALMACHINEACCOUNTDN),
        TEXT(SCHEMADNNAME),
        TEXT(FORESTBEHAVIORVERSION),
        TEXT(DNSROOT),
        TEXT(INSTALLSITENAME),
        TEXT(LOCALCONNECTIONDNNAME),
        TEXT(NETBIOSNAME),
        TEXT(NEWDOMAINCROSSREFDNNAME),
        TEXT(REMOTECONNECTIONDNNAME),
        TEXT(REMOTEMACHINEDNNAME),
        TEXT(ROOTDOMAINDNSNAME),
        TEXT(SOURCEDSADNSDOMAINNAME),
        TEXT(SRCCONFIGNCSRV)
    };

    DWORD count = sizeof(actionArray) / sizeof(actionArray[0]);
    DWORD i;
    DWORD err;
    HKEY  keyHandle;

    //
    // Open the parent key
    //

    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      TEXT(DSA_CONFIG_SECTION),
                      0,
                      KEY_ALL_ACCESS,
                      &keyHandle);

    if (err != ERROR_SUCCESS) {
        return;
    }

    for (i = 0; i < count; i++) {
        err = RegDeleteValue(keyHandle, actionArray[i].Key);
    }

    RegCloseKey(keyHandle);

    return;

} // ZapTempRegKeys
        
DWORD
FillAnchorsConfigAndSchemaDNs(
    THSTATE *    pTHS,
    LPWSTR       szConfigNC,
    LPWSTR       szSchemaNC
)
/*++

Routine Description:

    This takes the string DNs of the config and schema NCs, and looks int
    the database to fill thier GUIDs, and finally malloc()s the strings
    and sets them in the Anchor.  This is required for some replication
    APIs to work correctly.

Arguments:

    pTHS - Valid thread state.
    szConfigNC - String DN of the configuration NC.
    szSchemaNC - String DN of the schema NC.

Return value:

    Win32 Error

--*/
{
    DWORD        dwErr;
    DWORD        cwcTemp, cbTemp, cbUsed;
    DSNAME *     pdnConfigNC = NULL;
    DSNAME *     pdnSchemaNC = NULL;
    DWORD        dwException = 0;
    PVOID        dwExceptionAddress = NULL;
    ULONG        dwDSID = 0;

    Assert(pTHS->pDB == NULL);

    __try {
        DBOpen2(TRUE, &pTHS->pDB);
        __try {

            //
            // Get Config NC
            //
            cwcTemp = wcslen(szConfigNC);
            cbTemp = DSNameSizeFromLen(cwcTemp);
            pdnConfigNC = (DSNAME *) malloc(cbTemp);
            if (pdnConfigNC == NULL) {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                __leave;
            }
            memset(pdnConfigNC, 0, cbTemp);
            pdnConfigNC->structLen = cbTemp;
            pdnConfigNC->NameLen = cwcTemp;
            memcpy(pdnConfigNC->StringName, szConfigNC, cwcTemp * sizeof(WCHAR));
            dwErr = DBFindDSName(pTHS->pDB, pdnConfigNC);
            if (dwErr) {
                __leave;
            }
            dwErr = DBGetAttVal(pTHS->pDB,
                                1,                       // get one value
                                ATT_OBJ_DIST_NAME,
                                DBGETATTVAL_fCONSTANT,   // providing our own buffer
                                pdnConfigNC->structLen,  // buffer size
                                &cbUsed,                 // buffer used
                                (UCHAR **) &pdnConfigNC);
            if (dwErr) {
                __leave;
            }
            Assert(cbUsed == pdnConfigNC->structLen);

            // Schema NC
            cwcTemp = wcslen(szSchemaNC);
            cbTemp = DSNameSizeFromLen(cwcTemp);
            pdnSchemaNC = (DSNAME *) malloc(cbTemp);
            if (pdnSchemaNC == NULL) {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                __leave;
            }
            memset(pdnSchemaNC, 0, cbTemp);
            pdnSchemaNC->structLen = cbTemp;
            pdnSchemaNC->NameLen = cwcTemp;
            memcpy(pdnSchemaNC->StringName, szSchemaNC, cwcTemp * sizeof(WCHAR));
            dwErr = DBFindDSName(pTHS->pDB, pdnSchemaNC);
            if (dwErr) {
                __leave;
            }
            dwErr = DBGetAttVal(pTHS->pDB,
                                1,                       // get one value
                                ATT_OBJ_DIST_NAME,
                                DBGETATTVAL_fCONSTANT,   // providing our own buffer
                                pdnSchemaNC->structLen,  // buffer size
                                &cbUsed,                 // buffer used
                                (UCHAR **) &pdnSchemaNC);
            if (dwErr) {
                __leave;
            }
            Assert(cbUsed == pdnSchemaNC->structLen);
        
        } __finally {
            DBClose(pTHS->pDB, TRUE);
        }

    } __except(GetExceptionData(GetExceptionInformation(),
                          &dwException,
                          &dwExceptionAddress,
                          &dwErr,
                          &dwDSID)) {
        HandleDirExceptions(dwException, dwErr, dwDSID);
        dwErr = DB_ERR_EXCEPTION;
    }

    if (dwErr) {

        // Failure, cleanup and return error.
        if (pdnConfigNC) {
            free(pdnConfigNC);
        }
        if (pdnSchemaNC) {
            free(pdnSchemaNC);
        }
        return(dwErr);

    } else {

        // Success, actually update the Anchor.
        gAnchor.pConfigDN = pdnConfigNC;
        gAnchor.pDMD = pdnSchemaNC;
    }

    return(dwErr);
}


DWORD
CreateChildDomainCrossRef(
    OUT PDS_INSTALL_RESULT  InstallOutParams,
    GUID *pDomainGuid,
    CROSS_REF *pCR,
    OUT GUID *ntdsaGuid
    )
//
// Create Cross-Ref object corresponding to the domain we're now adding to the
// pre-existing DS enterprise.
//
{
    ULONG   err = 0;
    NODE    nodeNewDomainCrossRef( gNames.IniDefaultNewDomainCrossRef );
    NODE    nodeNewNtdsa( gNames.IniDefaultMachine );
    ADDENTRY_REPLY_INFO *infoList  = NULL;
    PPOLICY_DNS_DOMAIN_INFO  DnsDomainInfo = NULL;
    BOOL    fCrossRefAlreadyExisted = FALSE;
    DSNAME  *pNewCR    = NULL;
    DSNAME  *pNewNtdsa = NULL;
    THSTATE *pTHS = pTHStls;

    if ( !nodeNewDomainCrossRef.Initialize() )
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    if ( !nodeNewNtdsa.Initialize() )
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    _try
    {
        //
        // Build the attr block necessary to build the ntdsa and cross ref
        // object and put it all in an entinflist struct.
        //
        ATTR       attarray[50];
        ATTR       attarray2[50];
        YAHANDLE yh, yh2;
        ATTCACHE* pAC;
        char* strval;
        ULONG count=0, i, size;
        ATTRBLOCK ab;
        DSNAME * pdnCrossRefSourceDsa = NULL;
        LPWSTR   pszCrossRefSourceAddress = NULL;
        ENTINFLIST CrossRefEntInfList;
        ENTINFLIST NtdsaEntInfList;
        DSNAME *   ppdnReplList[2];

        ZeroMemory(attarray,sizeof(attarray));
        ZeroMemory(attarray2,sizeof(attarray2));
        ZeroMemory(&CrossRefEntInfList, sizeof(CrossRefEntInfList));
        ZeroMemory(&NtdsaEntInfList, sizeof(NtdsaEntInfList));

        //
        // Get the domain sid as we need to set it on the ncName attribute
        // of the cross ref
        //
        {
            NTSTATUS NtStatus;
            NtStatus = LsaIQueryInformationPolicyTrusted(PolicyDnsDomainInformation,
                                                         (PLSAPR_POLICY_INFORMATION*) &DnsDomainInfo );
            if ( !NT_SUCCESS( NtStatus ) ) {
                err = RtlNtStatusToDosError( NtStatus );
                _leave;
            }
        }

        // Set the list and defaults correctly
        CrossRefEntInfList.pNextEntInf = &NtdsaEntInfList;
        NtdsaEntInfList.pNextEntInf = NULL;
        CrossRefEntInfList.Entinf.ulFlags = 0;  // not used
        NtdsaEntInfList.Entinf.ulFlags = 0;  // not used

        // Build the cross ref info
        size = (ULONG)DSNameSizeFromLen(wcslen(gNames.NewDomainCrossRefDNName));
        pNewCR = (PDSNAME) THAllocEx(pTHS, size);
        BuildDefDSName(pNewCR,
                       gNames.NewDomainCrossRefDNName,
                       NULL
                      );

        while (pAC = nodeNewDomainCrossRef.GetNextAttribute(yh,&strval)) {
            CreateAttr(attarray,count,pAC,strval);
        }
        
        CrossRefEntInfList.Entinf.pName = pNewCR;
        CrossRefEntInfList.Entinf.AttrBlock.attrCount = count;
        CrossRefEntInfList.Entinf.AttrBlock.pAttr = attarray;


#if 0
        //
        //  N.B. Specifing the guid and sid remotely makes recovery from
        //  failure very difficult and can easily lead to duplicate (domain) 
        //  sids.
        //
        //  By ship time, this code can be removed. colinbr 10/13/98.
        //

        // whack the guid of the nc head
        for (i=0; i<count; i++) {
            if (attarray[i].attrTyp == ATT_NC_NAME) {
                NTSTATUS IgnoreStatus;

                Assert(attarray[i].AttrVal.valCount == 1);
                ((DSNAME*)(attarray[i].AttrVal.pAVal[0].pVal))->Guid =
                  *pDomainGuid;

                IgnoreStatus = RtlCopySid(  sizeof(NT4SID),
                                           &((DSNAME*)(attarray[i].AttrVal.pAVal[0].pVal))->Sid,
                                            DnsDomainInfo->Sid );
                Assert( NT_SUCCESS( IgnoreStatus ) );
                ((DSNAME*)(attarray[i].AttrVal.pAVal[0].pVal))->SidLen = RtlLengthSid( DnsDomainInfo->Sid );

            }
        }

#endif

        // build the ntdsa info
        count = 0;
        size = (ULONG)DSNameSizeFromLen(wcslen(gNames.DsaDNName));
        pNewNtdsa = (PDSNAME) THAllocEx(pTHS, size);
        BuildDefDSName(pNewNtdsa,
                       gNames.DsaDNName,
                       NULL
                      );

        while (pAC = nodeNewNtdsa.GetNextAttribute(yh2,&strval)) {
            CreateAttr(attarray2,count,pAC,strval);
        }
        
        NtdsaEntInfList.Entinf.pName = pNewNtdsa;
        NtdsaEntInfList.Entinf.AttrBlock.attrCount = count;
        NtdsaEntInfList.Entinf.AttrBlock.pAttr = attarray2;

        if (pCR) {
            // A Cross-Ref already exists for this NC, we're just
            // converting it from its disabled state.  We can do this
            // at any server in the enterprise, so we might as well
            // do it at the one we're already bound to

            // Must create the server's NTDSA Obj DN so we use the 
            // proper form of ReplicateObjectsFromSingleNc() below.
            Assert(gNames.RemoteMachineDNName);
            pdnCrossRefSourceDsa = DSNameFromStringW(pTHS, gNames.RemoteMachineDNName);
            Assert(pdnCrossRefSourceDsa);
            err = FillSourceDsaGuid(pTHS, pdnCrossRefSourceDsa);
            if (err) {
                __leave;
            }
            pszCrossRefSourceAddress = gNames.SrcConfigNCSrv;
            fCrossRefAlreadyExisted = TRUE;
        }
        else {
            // No Cross-Ref object exists yet, which means that we
            // need to create it de novo, which can only be done at
            // the DSA which holds the partition master role.  We get
            // that by taking the name of the new CR object, computing
            // its parent's name, reading the FSMO-Role-Owner attribute
            // from the parent (yielding the DN of the role-owning DSA).
            // This can then be turned into a GUID DNS address, however
            // to use this type of DNS address we'll need to setup the 
            // config/schema DNs on the gAnchor.
            DSNAME *pContainer = (DSNAME*)THAllocEx(pTHS, pNewCR->structLen);
            TrimDSNameBy(pNewCR, 1, pContainer);

            // The code previously here was packaged up in this function 
            // for code reuse purposes.
            err = GetFsmoNtdsa(pTHS, pContainer, &pdnCrossRefSourceDsa, NULL); 
            if(err){
                DPRINT1(1,"GetFsmoNtdsa (which means DirRead()) returned %u\n", err);
                __leave;
            }

            Assert(gAnchor.pwszRootDomainDnsName);
            pszCrossRefSourceAddress = GuidBasedDNSNameFromDSName(pdnCrossRefSourceDsa);
            if (pszCrossRefSourceAddress == NULL ) { 
                err = ERROR_NOT_ENOUGH_MEMORY; 
                __leave;
            }

            DPRINT1(1, "DNS addr of role owner is '%S'\n",
                    pszCrossRefSourceAddress);

        }

        Assert(pdnCrossRefSourceDsa);
        Assert(pszCrossRefSourceAddress);
        
        err = FillAnchorsConfigAndSchemaDNs(pTHS, gNames.ConfigNCDNName, gNames.SchemaDNName);
        if (err) {
            __leave;
        }

        //
        // Remotely add the cross-ref and the ntdsa object.
        //

        Assert(gAnchor.pConfigDN);
        Assert(gAnchor.pDMD);
        err = RemoteAddOneObjectSimply(pszCrossRefSourceAddress,
                                       NULL, // No client creds needed
                                       &CrossRefEntInfList,
                                       &infoList);

        DPRINT5(0, "RemoteAdd(%ws), errCode %d, extErr %d, extData %d, dsid %08x\n",
                CrossRefEntInfList.Entinf.pName->StringName,
                pTHS->errCode,
                Win32ErrorFromPTHS(pTHS),
                GetTHErrorExtData(pTHS),
                GetTHErrorDSID(pTHS)
                );
        LogRemoteAdd(TRUE, // always a remote add in this case.
                     pszCrossRefSourceAddress,
                     CrossRefEntInfList.Entinf.pName,
                     pTHS, // For error state only
                     (infoList) ? &(infoList[0].objGuid) : NULL,
                     DSID(FILENO, __LINE__));

        if(pTHS->errCode){
            // RemoteAddOneObjectSimply() sets the thread state error and
            // returns pTHS->errCode.  So crack out the real Win32 error
            // out of the thread error state, clear the errors and continue

            Assert(err == pTHS->errCode);
            err = Win32ErrorFromPTHS(pTHS);
            if(err == ERROR_DS_REMOTE_CROSSREF_OP_FAILED){
                // Note: Usually you can just use Win32ErrorFromPTHS(), but
                // if the remote side of the RemoteAddObject routine 
                // got a typical thread error state set, then this function
                // sets that this was a remote crossRef creation that failed in
                // the regular extendedErr and moves the error that caused the 
                // remote add op to fail in the extendedData field.
                err = GetTHErrorExtData(pTHS);
            }
            Assert(err);
            THClearErrors();
        }
        if (err || infoList == NULL) {
            Assert(err);
            err = err ? err : ERROR_DS_CODE_INCONSISTENCY;
            __leave;
        } else {
            // Success, we should have the ntdsaGUID now.
            Assert(gAnchor.pDSADN);

            memset(gAnchor.pDSADN, 0, gAnchor.pDSADN->structLen);
            gAnchor.pDSADN->structLen = DSNameSizeFromLen(0);
            gAnchor.pDSADN->Guid = infoList[1].objGuid;
        }
        // Both the domain and the server object have been created
        InstallOutParams->InstallOperationsDone |= NTDS_INSTALL_SERVER_CREATED;
        if ( !fCrossRefAlreadyExisted ) {
            InstallOutParams->InstallOperationsDone |= NTDS_INSTALL_DOMAIN_CREATED;
        }
        
        // 
        // Now replicate the cross-ref back.
        //

        Assert(gAnchor.pDSADN && !fNullUuid(&(gAnchor.pDSADN->Guid)));
        Assert(gAnchor.pConfigDN);
        Assert(gAnchor.pDMD);
        ppdnReplList[0] = pNewCR;
        ppdnReplList[1] = pNewNtdsa;
        err = ReplicateObjectsFromSingleNc(pdnCrossRefSourceDsa,
                                           2,
                                           ppdnReplList,
                                           gAnchor.pConfigDN);
        DPRINT1(0,
                "Remotely sync'ed Cross-Ref with status %u\n",
                err);
        if ( 0 == err ) {
            // We have succeeded!
            if ( ntdsaGuid ) {
                *ntdsaGuid = infoList[1].objGuid;
            }
        }

        if(err){
            __leave;
        }

    }
    _except( HandleAllExceptions(err = GetExceptionCode()) )
    {
        if (INVALIDINIFILE == err) {
            err = ERROR_GEN_FAILURE;
        } else if (err == OUTOFMEMORY) {
            err = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            err = ERROR_GEN_FAILURE;
        }
        DPRINT1(
            0,
            "Exception %x adding new domain cross-ref object.\n",
            err
            );
    }

Cleanup:

    if (ERROR_SUCCESS != err) {
        SET_INSTALL_ERROR_MESSAGE1(err,
                                   DIRMSG_INSTALL_FAILED_TO_CREATE_OBJECT,
                                   gNames.NewDomainCrossRefDNName);

    }

    if ( DnsDomainInfo )
    {
        LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION) DnsDomainInfo );
    }
    if (pNewCR) {    
        THFree(pNewCR);
    }
    if (pNewNtdsa) {    
        THFree(pNewNtdsa);
    }

    return err;
}

NTSTATUS
DirReplicaErrorToNtStatus(
    IN ULONG DirReplicaError
    )
/*++

Description:

    This routine roughly translates all DirReplicaErr errors to thier
    approximate nt status codes.

Parameters:

    DirReplicaError : a drs error code as defined in ds\inc\drserr.h

Return Values:

    See function definition

--*/
{
    switch (DirReplicaError) {

        case DRAERR_Success:
            return STATUS_SUCCESS;

        case DRAERR_Generic:
            return STATUS_UNSUCCESSFUL;

        case DRAERR_InvalidParameter:
            return STATUS_INVALID_PARAMETER;

        case DRAERR_Busy:
            return STATUS_DS_BUSY;

        case DRAERR_DNExists:
            return  STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS;

        case DRAERR_BadDN:
            return STATUS_OBJECT_NAME_INVALID;

        // [wlees May 26, 1998] Here is my guess at the likely connection
        // related errors.  Since the I_DRSxxx interface now returns Win32
        // errors, we cannot completely predict all the errors that could
        // be returned.  Can we consider converting this framework to win32??
        case RPC_S_SERVER_UNAVAILABLE:
        case RPC_S_INVALID_BINDING:
        case RPC_S_PROTSEQ_NOT_SUPPORTED:
        case RPC_S_INVALID_NET_ADDR:
        case RPC_S_NO_ENDPOINT_FOUND:
        case RPC_S_NO_PROTSEQS_REGISTERED:
        case RPC_S_NOT_LISTENING:
        case RPC_S_NO_BINDINGS:
        case RPC_S_NO_PROTSEQS:
        case RPC_S_OUT_OF_RESOURCES:
        case RPC_S_SERVER_TOO_BUSY:
        case RPC_S_CALL_FAILED:
        case RPC_S_CALL_FAILED_DNE:
        case RPC_S_PROTOCOL_ERROR:
        case RPC_S_INVALID_TAG:
        case RPC_S_UNKNOWN_AUTHN_TYPE:
        case RPC_S_PROCNUM_OUT_OF_RANGE:
        case RPC_S_BINDING_HAS_NO_AUTH:
        case RPC_S_UNKNOWN_AUTHN_SERVICE:
        case RPC_S_UNKNOWN_AUTHN_LEVEL:
        case RPC_S_INVALID_AUTH_IDENTITY:
        case RPC_S_UNKNOWN_AUTHZ_SERVICE:
        case RPC_S_INTERFACE_NOT_FOUND:
        case RPC_S_NO_CONTEXT_AVAILABLE:
        case RPC_S_INTERNAL_ERROR:
        case RPC_X_NULL_REF_POINTER:
        case ERROR_NO_SUCH_PACKAGE:
        case RPC_S_SEC_PKG_ERROR:
            return STATUS_CONNECTION_REFUSED;

        case DRAERR_OutOfMem:
        case ERROR_NOT_ENOUGH_MEMORY:
            return STATUS_NO_MEMORY;

        case DRAERR_AccessDenied:
        case ERROR_ACCESS_DENIED:
            return STATUS_ACCESS_DENIED;

        case DRAERR_NameCollision:
            return STATUS_OBJECT_NAME_COLLISION;

        case DRAERR_Shutdown:
            return STATUS_DLL_INIT_FAILED_LOGOFF;

        case DRAERR_BadNC:
        case DRAERR_InternalError:
        case DRAERR_InconsistentDIT:
        case DRAERR_BadInstanceType:
        case DRAERR_MailProblem:
        case DRAERR_RefAlreadyExists:
        case DRAERR_RefNotFound:
        case DRAERR_ObjIsRepSource:
        case DRAERR_DBError:
        case DRAERR_NoReplica:
        case DRAERR_SchemaMismatch:
        case DRAERR_RPCCancelled:
        case DRAERR_SourceDisabled:
        case DRAERR_SinkDisabled:
        case DRAERR_SourceReinstalled:
            return STATUS_UNSUCCESSFUL;

        default:
//            ASSERT(FALSE);
            DPRINT1( 0, "install.cxx::DirReplicaErrortoNtStatus encountered an error which it did not recognize %d\n", DirReplicaError );
            return STATUS_UNSUCCESSFUL;
    }

    ASSERT(FALSE);
    return STATUS_UNSUCCESSFUL;

}

DWORD
CreateRemoteNtdsDsaObject(
    OUT GUID* NtdsDsaGuid OPTIONAL
    )
//
// This routine attempts to remotely add an ntds object on the
// source server
{
    DWORD err = ERROR_SUCCESS;
    NODE  nodeNewNtdsaObject( gNames.IniDefaultMachine );

    // First the ntdsa object
    if ( !nodeNewNtdsaObject.Initialize() )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    err = RemoteAddOneObject(  gNames.SrcConfigNCSrv,
                               &nodeNewNtdsaObject,
                               gNames.DsaDNName,
                               NtdsDsaGuid,
                               NULL );

    return err;
}

DWORD
ForceChangeToCrossRef( 
    IN DSNAME *  pdnCrossRefObj,
    IN WCHAR *   wszNcDn,
    IN GUID *    pDomainGuid,
    IN ULONG     cbSid,      OPTIONAL
    IN PSID      pSid        OPTIONAL
    )
/*++

Routine Description:

    This routine writes the full dsname (string name, sid and guid) out to the
    cross ref object so it will replicate out.  The algorithm is as follows:
    
    1) create a Infrastructure object in the configuration container with the
       attribute DN-Reference-Update that points to the full dsname of the
       the new nc head
       
    2) this object is deleted
       
    The magic comes in when this information is replicated out.
    
    When a source DC (X) tries to add the configuration container hosted on this
    DC (Y), the tombstone of the infrastructure object will replicate out.  On
    server X, the value of DN-Reference-Update will force the phantom created 
    by the string-name only ncname value on X to be updated with the guid
    and the sid of the new ncname
    
    Furthermore, server X will catch this update and update the in memory cross
    ref list.    

    NOTE: This will ruin your DB currency!
    
Parameters:

    pdnCrossRefObj - the dsname of the cross ref
    
    wszNcDn  - the string name of the NC.
    
    pDomainGuid  - the guid of the NC.
    
    cbSid  - the length of the Sid pointed to by pSid, could be 0.
    
    pSid  - the Sid of the domain, if just an NC, then will be NULL.

Return Values:

    Returns a DirError, and more error info is in the THSTATE pTHStls.

--*/
{
    ULONG            DirError = 0;
    THSTATE *        pTHS = pTHStls;

    ADDARG           addarg;
    REMOVEARG        remarg;
    COMMRES          CommRes;

    CLASSCACHE *     pCC;

    DSNAME *         pdnNc = NULL;
    ULONG            ccLen;
    ULONG            cbSize;

    ATTRBLOCK        AttrBlock;
    ATTR *           pAttr = 0;

    WCHAR *          wszConfigDn = NULL;

#define ATTR_COUNT 3
    ATTRVAL          AttrVal[ATTR_COUNT];

    DSNAME *         pdnDelDsName = NULL;
    LPWSTR           wszDelDn = NULL;
    DSNAME *         pdnParent = NULL;
    DWORD            objClass = CLASS_INFRASTRUCTURE_UPDATE;

    LPWSTR           wszDelRdn = L"CN=CRUpdate,CN=LostAndFoundConfig,";

    // parameter check
    Assert( pdnCrossRefObj );
    Assert( wszNcDn );
    Assert( pDomainGuid );
    Assert( (!cbSid && !pSid) || (cbSid && pSid) );
    Assert( !pSid || RtlValidSid( pSid ) );
    Assert( pTHS && VALID_THSTATE(pTHS) );
    Assert( !pTHS->errCode );


    //
    // Do the prep work, there's lots to do.
    //
    // -----------------------------------------------------------

    //
    // Prepare the full nCName of the new domain
    //

    // Alloca DSNAME
    ccLen = wcslen( wszNcDn );
    cbSize  = DSNameSizeFromLen( ccLen );
    pdnNc = (DSNAME*) THAllocEx(pTHS, cbSize );
    RtlZeroMemory( pdnNc, cbSize );
    // Set Size
    pdnNc->structLen = cbSize;
    // Set GUID
    memcpy( &pdnNc->Guid, pDomainGuid, sizeof(GUID) );
    // Set DN String name
    pdnNc->NameLen = ccLen;
    wcscpy( pdnNc->StringName, wszNcDn );
    // Set SID if present.
    if(pSid){
        cbSize = RtlLengthSid( pSid );
        pdnNc->SidLen = cbSize;
        RtlCopySid( cbSize, (PSID)&pdnNc->Sid, (PSID)pSid);
    } else {
        pdnNc->SidLen = 0;
    }

    //
    // Create the temporary dn
    //

    // Find the DN for the Configuration NC.
    if(DsaIsInstalling()){
        wszConfigDn = gNames.ConfigNCDNName;
    } else {
        Assert(gAnchor.pConfigDN);
        wszConfigDn = gAnchor.pConfigDN->StringName;
    }
    Assert(wszConfigDn);

    // Concatinate to DelRDN.
    ccLen = wcslen( wszDelRdn ) + wcslen( wszConfigDn ) + 1;
    wszDelDn = (WCHAR*) THAllocEx(pTHS, ccLen * sizeof(WCHAR) );
    wcscpy( wszDelDn, wszDelRdn );
    wcscat( wszDelDn, wszConfigDn );

    // Make a DSNAME out of the wchar str for the delete DN.
    cbSize = DSNameSizeFromLen(ccLen);
    pdnDelDsName = (PDSNAME) THAllocEx(pTHS, cbSize );
    memset(pdnDelDsName, 0, cbSize);

    BuildDefDSName( pdnDelDsName,
                    wszDelDn,
                    NULL
                   );


    //
    // Make the add args
    //
    memset( &AttrBlock, 0, sizeof(AttrBlock) );
    memset( AttrVal, 0, sizeof(AttrVal) );

    // ISSUE-2000/08/03-BrettSh Must THAlloc ATTRs, 
    // This is because core assumes that it can do a THReAlloc.  This is the 
    // second place where I've seen this behavior, and I am wondering how many
    // instances we need before we fix the core to not make the assumption 
    // that it's THAlloc'd.  Note that this is never freed.  The advantage of
    // the current method, is if there is room for an inplace THReAlloc, then
    // it is more efficient, because most operations require a ReAlloc in
    // mdupdate.c:CheckAddSecurity() for the Security Descriptor attribute.  
    // A similar BUGBUG exists in draserv.c:AddNewDomainCrossRef()  The
    // advantage of changing this, would be clearer and more maintainable
    // code.
    pAttr = (ATTR*) THAllocEx(pTHS, sizeof(ATTR) * ATTR_COUNT);
    AttrBlock.attrCount = ATTR_COUNT;
    AttrBlock.pAttr = pAttr;

    pAttr[0].attrTyp = ATT_OBJECT_CLASS;
    pAttr[0].AttrVal.valCount = 1;
    pAttr[0].AttrVal.pAVal = &AttrVal[0];
    AttrVal[0].valLen = sizeof(DWORD);
    AttrVal[0].pVal = (BYTE*) &objClass;

    pAttr[1].attrTyp = ATT_DN_REFERENCE_UPDATE;
    pAttr[1].AttrVal.valCount = 1;
    pAttr[1].AttrVal.pAVal = &AttrVal[1];
    AttrVal[1].valLen = pdnNc->structLen;
    AttrVal[1].pVal = (BYTE*) pdnNc;

    // Note: the object category returned is wrt O=Boot; however
    // it doesn't really matter as this object is going to be deleted
    // and this attribute is stripped.
    if (!(pCC = SCGetClassById(pTHStls, CLASS_INFRASTRUCTURE_UPDATE))) {
        SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION, 
                    ERROR_DS_OBJ_CLASS_NOT_DEFINED);
        Assert(pTHS->errCode);
        goto Cleanup;
    }

    pAttr[2].attrTyp = ATT_OBJECT_CATEGORY;
    pAttr[2].AttrVal.valCount = 1;
    pAttr[2].AttrVal.pAVal = &AttrVal[2];
    AttrVal[2].valLen = pCC->pDefaultObjCategory->structLen;
    AttrVal[2].pVal = (BYTE*) pCC->pDefaultObjCategory;

    //
    // Add the entry
    //
    // -----------------------------------------------------------

    // Create addarg
    memset( &addarg, 0, sizeof(addarg) );
    memset( &CommRes, 0, sizeof(CommRes) );
    addarg.pObject = pdnDelDsName;
    memcpy( &addarg.AttrBlock, &AttrBlock, sizeof( addarg.AttrBlock ) );
    InitCommarg( &addarg.CommArg );
    addarg.CommArg.Svccntl.dontUseCopy = TRUE;

    // Do name resolution
    pdnParent = (DSNAME *) THAllocEx(pTHS, addarg.pObject->structLen);
    TrimDSNameBy(addarg.pObject, 1, pdnParent);
    DirError = DoNameRes(pTHS,
                         0,
                         pdnParent,
                         &addarg.CommArg,
                         &CommRes,
                         &addarg.pResParent);
    if (DirError) {
        Assert(!"This should never be the case, if we failed to add the parent of this object, then all of dcpromo should've failed.");
        Assert(pTHS->errCode);
        goto Cleanup;
    }

    // Do actual add
    LocalAdd(pTHS, &addarg, FALSE);
    if ( 0 != pTHS->errCode )  {
        // The LocalAdd failed.
        goto Cleanup;
    }

    //
    // Ok, now delete the object
    //
    // -----------------------------------------------------------

    // Create remarg
    memset( &remarg, 0, sizeof(remarg) );
    memset( &CommRes, 0, sizeof(CommRes) );
    remarg.pObject = pdnDelDsName;
    InitCommarg( &remarg.CommArg );

    // Do name resolution.
    DirError = DoNameRes(pTHS,
                         NAME_RES_IMPROVE_STRING_NAME,
                         remarg.pObject,
                         &remarg.CommArg,
                         &CommRes,
                         &remarg.pResObj);
    if(DirError){
        Assert(!"I am kind of curious how this could happen, since we just successfully added the object we're trying to resolve.");
        Assert(pTHS->errCode);
        goto Cleanup;
    }

    // Do actual delete/remove
    LocalRemove(pTHS, &remarg);

    // Process error
    if ( 0 != pTHS->errCode ) {
        goto Cleanup;
    }

    DPRINT1(1, "Added (and Removed) an infrastructureUpdate to fix GUID on a crossRef for %ws\n",
            wszNcDn);

    //
    // That's it
    //

Cleanup:

    if(pdnNc) { THFreeEx(pTHS, pdnNc); }
    if(pdnDelDsName) { THFreeEx(pTHS, pdnDelDsName); }
    if(wszDelDn) { THFreeEx(pTHS, wszDelDn); }

    return(pTHS->errCode);

}


DWORD
ForceChangeToDomainCrossRef(
    IN DSNAME*   pdnCrossRefObj,
    IN WCHAR*    wszDomainDn,
    IN GUID*     pDomainGuid
    )
/*++

Routine Description:

    This function encapsulates the function ForceChangeToCrossRef() into
    a single transaction.  This function also queries LSA for the domain
    SID to be passed into ForceChangeToCrossRef(). 
    
Parameters:

    pdnCrossRefObj - the dsname of the cross ref
    
    wszNcDn  - the string name of the NC.
    
    pDomainGuid  - the guid of the NC.
    
Return Values:

    A value from winerror.h; only a resource error
    
--*/
{
    DWORD        WinError = ERROR_SUCCESS;
    NTSTATUS     NtStatus = STATUS_SUCCESS;
    ULONG        DirError = 0;

    PPOLICY_DNS_DOMAIN_INFO  DnsDomainInfo = NULL;
    
    ULONG        cbSid = 0;
    PSID         pSid = NULL;
    BOOL         fTrans = FALSE;
    ULONG        dwException, ulErrorCode, dsid;
    PVOID        dwEA;
    COMMRES      CommRes;
   
    // parameter check
    Assert( pdnCrossRefObj );
    Assert( wszDomainDn );
    Assert( pDomainGuid );

    if(!SDP_EnterAddAsReader()) {
        // The only valid reason to fail to enter as reader is if we are
        // shutting down.
        Assert(eServiceShutdown);
        return  ErrorOnShutdown();
    }
    __try{
        __try{

            //
            // Get the domain sid as we need to set it on the ncName attribute
            // of the cross ref
            //
            NtStatus = LsaIQueryInformationPolicyTrusted(PolicyDnsDomainInformation,
                            (PLSAPR_POLICY_INFORMATION*) &DnsDomainInfo );

            if ( !NT_SUCCESS( NtStatus ) ) {
                WinError = RtlNtStatusToDosError( NtStatus );
                __leave;
            }
            Assert( DnsDomainInfo && RtlValidSid( DnsDomainInfo->Sid ) );

            // Start transaction.
            SYNC_TRANS_WRITE();
            fTrans = TRUE;

            // Do actual change to CrossRef.
            DirError = ForceChangeToCrossRef(pdnCrossRefObj, wszDomainDn, pDomainGuid,
                                             RtlLengthSid(DnsDomainInfo->Sid), 
                                             DnsDomainInfo->Sid);
            memset(&CommRes, 0, sizeof(CommRes));
            CommRes.errCode = pTHStls->errCode;
            CommRes.pErrInfo = pTHStls->pErrInfo;
            WinError = DirErrorToWinError( DirError, &CommRes);

        } __finally {

            // End transaction.
            if(fTrans){
                CLEAN_BEFORE_RETURN(pTHStls->errCode);
                if(0 == pTHStls->errCode){
                    DPRINT1(0, "Commited nCName attribute infrastructureUpdate for crossRef of %ws\n",
                            wszDomainDn);
                }
            }

            if ( DnsDomainInfo ) {
                LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION) DnsDomainInfo );
            }



        }
    } __except(GetExceptionData(GetExceptionInformation(), &dwException,
                                &dwEA, &ulErrorCode, &dsid)) {
              
          HandleDirExceptions(dwException, ulErrorCode, dsid);

    }
    SDP_LeaveAddAsReader();

    return WinError;


}

DWORD
CheckForDuplicateDomainSid(
    VOID
    )
/*++

Routine Description:

    This routine determines if the domain sid that is about to used is already
    in use in the enterprise. It does this by walking the cross ref list and
    comparing domain sids with the domain sid we are about to use.

Parameters:

Return Values:

    A value from winerror.h; only a resource error

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DWORD err = 0;
    PPOLICY_DNS_DOMAIN_INFO  DnsDomainInfo = NULL;
    DSNAME *DomainDsName = NULL;
    ULONG Size, Length;
    BOOLEAN fExists = FALSE;

    NtStatus = LsaIQueryInformationPolicyTrusted(PolicyDnsDomainInformation,
                    (PLSAPR_POLICY_INFORMATION*) &DnsDomainInfo );

    if ( !NT_SUCCESS( NtStatus ) ) {
        err = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }
    Assert( RtlValidSid( DnsDomainInfo->Sid ) );

    //
    // Prepare a sid only dsname
    //
    Size  = DSNameSizeFromLen( 0 );
    DomainDsName = (DSNAME*) XCalloc( 1, Size );
    RtlZeroMemory( DomainDsName, Size );
    DomainDsName->structLen = Size;
    Length = RtlLengthSid( DnsDomainInfo->Sid );
    DomainDsName->SidLen = Length;
    RtlCopySid( Length, (PSID)&DomainDsName->Sid, (PSID)DnsDomainInfo->Sid);

    fExists = SampDoesDomainExist( DomainDsName );
    if (fExists) {
        NtStatus = STATUS_DOMAIN_EXISTS;
    }

    err = RtlNtStatusToDosError( NtStatus );

Cleanup:


    if ( DnsDomainInfo ) {

        LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION) DnsDomainInfo );

    }
    if (DomainDsName) {
        XFree(DomainDsName);
    }

    return err;
}

NTSTATUS
CheckReplicationEpoch(
    DWORD ReplicationEpoch
    )
/*++

Routine Description:

    This routine will compare the replication Epoch of the current dit with
    the Value that is passed in.  If the Values match return STATUS_SUCCESS else
    STATUS_UNSUCCESSFUL

Parameters:

    ReplicationEpoch - The Value to compare the dit's ReplicationEpoch to.

Return Values:

    A value from winerror.h; only a resource error

--*/
{
    THSTATE         *pTHS = pTHStls;
    DWORD           dbErr = ERROR_SUCCESS;
    DWORD           WinErr = ERROR_SUCCESS;
    ULONG           ulDitReplicationEpoch = 0;
    ULONG           ulValue = 0;
    BOOL            fCommit = TRUE;
    ATTCACHE*       ac;

    DWORD dwException = 0;
    PVOID dwExceptionAddress = NULL;
    ULONG ulErrorCode  = 0;
    ULONG dsid = 0;

    __try {
        //retrieve the replicationEpoch from the DS
        DBOpen2(TRUE, &pTHS->pDB);
         __try {
           
            ASSERT( gAnchor.pDSADN != NULL );
            // seek to local dsa object
            dbErr = DBFindDSName( pTHS->pDB, gAnchor.pDSADN );
    
            if ( 0 == dbErr )
            {
                
                dbErr = DBGetSingleValue(
                            pTHS->pDB,
                            ATT_MS_DS_REPLICATIONEPOCH,
                            &ulValue,
                            sizeof( DWORD ),
                            NULL
                            );
                switch (dbErr) {
                     case DB_ERR_NO_VALUE:
                        //If there was no value found then use the value we already have
                        dbErr = 0;
                        ulDitReplicationEpoch = 0;
                        break;
                     case 0:
                        // success! we got the value in ulValue use the smaller of the two
                        ulDitReplicationEpoch = ulValue;
                        break;
                     default:
                        // Some other error!
                        __leave;
                 } /* switch */
            }
        }
        __finally {
    
            DBClose(pTHS->pDB,fCommit);
    
        }
    }
    __except(GetExceptionData(GetExceptionInformation(),
                          &dwException,
                          &dwExceptionAddress,
                          &ulErrorCode,
                          &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
        dbErr = DB_ERR_EXCEPTION;
    }

    if (dbErr != 0) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //if the replicationEpoch don't match then fail.
    if (ReplicationEpoch != ulDitReplicationEpoch) {
        WCHAR wszReplicationEpoch[12];
        WCHAR wszDitReplicationEpoch[12];

        swprintf(wszReplicationEpoch,L"%d",ReplicationEpoch);
        swprintf(wszDitReplicationEpoch,L"%d",ulDitReplicationEpoch);

        SET_INSTALL_ERROR_MESSAGE2(ERROR_DS_LOCAL_ERROR,
                                   DIRMSG_REPLICATION_EPOCH_NOT_MATCHED,
                                   wszDitReplicationEpoch,
                                   wszReplicationEpoch);
        return STATUS_UNSUCCESSFUL;
        
    }
    return STATUS_SUCCESS;

}

NTSTATUS
RenameAdditionalMachineAccountsIfAny(
    OUT PBOOL fNoMessage)
/*++

Routine Description:

    This routine will rename any machine account from the restored
    dit that has a sam account name that is the same as ours.
    We should only have one machine account with our sam account name.
    
    The most common why to get multiple machine account is to have
    taken a backup with the machine account in.  Delete the machine account
    Then use this backup for an IFM install.  There will be one machine created
    for the install and one from the backup.

Parameters:

    none.

Return Values:

    A value from ntstatus.h

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    SEARCHARG       SearchArg;
    SEARCHRES       *SearchRes = NULL;
    ENTINFSEL       EntInfSel;
    ENTINFLIST      *MachineAccount = NULL;
    ULONG           RetCode = 0;
    FILTER          DsFilter;
    COMMARG         *pCommArg;
    ATTR            Attr;
    
    MODIFYARG       ModifyArg;
    MODIFYRES       *ModifyRes = NULL; 
    ATTRVAL         SamAccountName;

    WCHAR wsSamAccountName[MAX_COMPUTERNAME_LENGTH+2];  // +2 for NULL and $
    DWORD cchSamAccountName = MAX_COMPUTERNAME_LENGTH+1;
   
#define RENAME_MACHINEACCOUNT_PREFIX L"$DUPLICATE-%x"

    if( !GetComputerNameExW(ComputerNameNetBIOS,
                            wsSamAccountName,
                            &cchSamAccountName) )
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    ASSERT( cchSamAccountName <= (MAX_COMPUTERNAME_LENGTH+1) );

    wcscat(wsSamAccountName, L"$");

    //
    // build DS Filter
    //
    RtlZeroMemory(&DsFilter, sizeof(FILTER));

    DsFilter.choice = FILTER_CHOICE_ITEM;
    DsFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    DsFilter.FilterTypes.Item.FilTypes.ava.type = ATT_SAM_ACCOUNT_NAME;
    DsFilter.FilterTypes.Item.FilTypes.ava.Value.valLen 
        = (wcslen(wsSamAccountName))*sizeof(WCHAR);
    DsFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (PUCHAR)wsSamAccountName;

     //
    // Build the SearchArg Structure
    //

    memset(&SearchArg, 0, sizeof(SEARCHARG));
    SearchArg.pObject       = gAnchor.pDomainDN;
    SearchArg.choice        = SE_CHOICE_WHOLE_SUBTREE;
    SearchArg.pFilter       = &DsFilter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection    = &EntInfSel;
    SearchArg.bOneNC        = TRUE;

    //
    // Fill the ENTINF Structure
    //

    Attr.attrTyp          = ATT_OBJ_DIST_NAME;
    Attr.AttrVal.valCount = 0;
    Attr.AttrVal.pAVal    = NULL;

    EntInfSel.AttrTypBlock.attrCount = 1;
    EntInfSel.AttrTypBlock.pAttr     = &Attr;
    EntInfSel.attSel                 = EN_ATTSET_LIST;
    EntInfSel.infoTypes              = EN_INFOTYPES_TYPES_VALS;
    
    //
    // Build the CommArg Structure
    // Build the Commarg structure
    // Get the address of the service control structure
    //

    pCommArg = &(SearchArg.CommArg);
    InitCommarg(pCommArg);
    pCommArg->SortAttr = ATT_WHEN_CREATED;
    pCommArg->SortType = SORT_MANDATORY;
    pCommArg->fForwardSeek = FALSE;
    
    RetCode = DirSearch(&SearchArg, &SearchRes);

    if (NULL==SearchRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    else
    {
        NtStatus = DirErrorToNtStatus(RetCode,&SearchRes->CommRes);
        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }
    }

    //
    //No accounts found to change goto cleanup
    if ( SearchRes->count < 2 )
    {
        goto Cleanup;
    }

    //
    // We will skip over the first result since this
    // is the correct one.  We will rename all other
    // hits.
    //
    for (MachineAccount = SearchRes->FirstEntInf.pNextEntInf;
         MachineAccount;
         MachineAccount = MachineAccount->pNextEntInf) {

                                                             //+20 for the rid +1 for the NULL
#define NEWSAMACCOUNTBUFFER sizeof(RENAME_MACHINEACCOUNT_PREFIX)/sizeof(WCHAR)+21

        WCHAR   NewSamAccountName[NEWSAMACCOUNTBUFFER];
        WCHAR   *wsNewSamAccountName = NewSamAccountName;
        DWORD   dwRid;
        PSID    pSid = NULL;
        HRESULT hr = S_OK;

        pSid = &MachineAccount->Entinf.pName->Sid;

        //make sure that there is a value for the Sid
        ASSERT(pSid);
        
        dwRid = *(GetSidSubAuthority(pSid,
                                     ((DWORD) (*GetSidSubAuthorityCount(pSid))) - 1));

        //make sure that we have a value for the rid
        ASSERT(dwRid);

        hr = StringCchPrintfW(wsNewSamAccountName,
                              NEWSAMACCOUNTBUFFER,
                              RENAME_MACHINEACCOUNT_PREFIX,
                              dwRid);
        if (FAILED(hr)) {

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;

        }
                                                            
        //
        // Now rename the object that was found
    
        SamAccountName.valLen = sizeof(WCHAR)*(wcslen(wsNewSamAccountName));
        SamAccountName.pVal = (BYTE*)wsNewSamAccountName;
        
        memset( &ModifyArg, 0, sizeof(MODIFYARG) );
        ModifyArg.pObject = MachineAccount->Entinf.pName;
        ModifyArg.count = 1;
        ModifyArg.FirstMod.pNextMod = NULL;
        ModifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
        ModifyArg.FirstMod.AttrInf.attrTyp = ATT_SAM_ACCOUNT_NAME;
        ModifyArg.FirstMod.AttrInf.AttrVal.valCount = 1;
        ModifyArg.FirstMod.AttrInf.AttrVal.pAVal = &SamAccountName;
    
        pCommArg = &(ModifyArg.CommArg);
        InitCommarg(pCommArg);
    
        RetCode = DirModifyEntry (&ModifyArg, &ModifyRes);
    
        if (NULL==ModifyRes)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        else
        {
            NtStatus = DirErrorToNtStatus(RetCode,&ModifyRes->CommRes);
            if (!NT_SUCCESS(NtStatus)) {
                SET_INSTALL_ERROR_MESSAGE2( RtlNtStatusToDosError(NtStatus),
                                            DIRMSG_RENAME_SAMACCOUNTNAME_FAILED,
                                            wsSamAccountName,
                                            MachineAccount->Entinf.pName->StringName);
                *fNoMessage = TRUE;
                goto Cleanup;
            }
        }

    }


Cleanup:

    return NtStatus;


}

NTSTATUS
ClearNonReplicatedAttributes()
/*++

Routine Description:

    This routine will Delete all non-replicated attributes from the restored
    Database during an IFM install.  There are a few attributes that should not
    be deleted.  A list of such attributes is mantained in the function.  Additional
    attributes should be added as needed.

Parameters:

    

Return Values:

    A value from ntstatus.h; only a resource error

--*/
{
    THSTATE         *pTHS = pTHStls;
    DWORD           dbErr = ERROR_SUCCESS;
    NTSTATUS        Status = STATUS_SUCCESS;
    ATTCACHE        **pACBuf = NULL;
    unsigned        cAtts = 0;
    ULONG           i = 0;
    ULONG           j = 0;
    BOOLEAN         shouldDelete = TRUE;

    ULONG AttrsNotToDelete[] = {
        ATT_DS_CORE_PROPAGATION_DATA,
        ATT_OBJ_DIST_NAME, 
        ATT_MS_DS_REPLICATIONEPOCH,
        ATT_OBJECT_GUID, 
        ATT_PARTIAL_ATTRIBUTE_DELETION_LIST, 
        ATT_PARTIAL_ATTRIBUTE_SET, 
        ATT_PREFIX_MAP, 
        ATT_REPL_PROPERTY_META_DATA, 
        ATT_REPL_UPTODATE_VECTOR, 
        ATT_SUB_REFS, 
        ATT_USN_CHANGED, 
        ATT_USN_CREATED, 
        ATT_WHEN_CHANGED,
        ATT_PEK_LIST,
        ATT_BRIDGEHEAD_SERVER_LIST_BL,
        ATT_FRS_COMPUTER_REFERENCE_BL, 
        ATT_FRS_MEMBER_REFERENCE_BL,
        ATT_MS_EXCH_OWNER_BL,
        ATT_NETBOOT_SCP_BL,
        ATT_NON_SECURITY_MEMBER_BL,
        ATT_QUERY_POLICY_BL,
        ATT_SERVER_REFERENCE_BL,
        ATT_SITE_OBJECT_BL
        };

    //get the list of attribute
    dbErr = SCEnumNamedAtts(&cAtts,
                            &pACBuf);
    if (dbErr) {
        DPRINT1(0,"scGetAttributeTypes: SCEnumNamedAtts failed: %x\n",dbErr);
        goto Cleanup;
    }


    
    for (i = 0;i < cAtts;i++) {
        shouldDelete = TRUE;
        //check to see if the attribute is not replicated
        if ( pACBuf[i]->bIsNotReplicated ) {
            j = 0;
            while ( j < (sizeof(AttrsNotToDelete)/sizeof(AttrsNotToDelete[0])) ) {
                //check to see if we should not delete this attribute
                if ( pACBuf[i]->id == AttrsNotToDelete[j] ) {
                    shouldDelete = FALSE;
                    break;
                }
                j++;
            }
        } else {
            shouldDelete = FALSE;
        }

        if (shouldDelete) {
            dbErr = DBDeleteCol (pACBuf[i]->id,
                                 pACBuf[i]->syntax);
            if ( JET_errSuccess != dbErr ) {
                if ( ( JET_errColumnNotFound == dbErr ) || ( JET_errColumnInUse == dbErr ) ) {
                    dbErr = JET_errSuccess;
                    //keep going
                } else {
                    //Log the error
                    LogEvent8(DS_EVENT_CAT_SCHEMA,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_SCHEMA_DELETE_COLUMN_FAIL,
                              szInsertUL(pACBuf[i]->jColid), 
                              szInsertUL(pACBuf[i]->id), 
                              szInsertInt(dbErr),
                              szInsertJetErrMsg(dbErr),
                              NULL, NULL, NULL, NULL);
                    goto Cleanup;
                    // Fail
                }
            } else {
                dbErr = DBAddCol (pACBuf[i]);
                if ( JET_errSuccess != dbErr ) {
                    // failed to add the colum fail
                    goto Cleanup;
                }
            }
        }
    }
    

    Cleanup:
    if (pACBuf) {
        THFreeEx(pTHS,pACBuf);
    }

    if ( 0 != dbErr ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;   
}


NTSTATUS                    
CheckTombstone()
//This function will read the tombstone and determine if the database
//is recent.  Otherwise it will fail the promotion.
{
    THSTATE         *pTHS = pTHStls;
    DWORD           dbErr = ERROR_SUCCESS;
    DWORD           WinErr = ERROR_SUCCESS;
    ULONG           ulTombstoneLifetimeDays;
    DSTIME          Lastchange;
    DSTIME          Time = DBTime();
    ULONG           ulValue;
    BOOL            fCommit = FALSE;
    ATTCACHE*       ac;

    DWORD dwException = 0;
    PVOID dwExceptionAddress = NULL;
    ULONG ulErrorCode  = 0;
    ULONG dsid = 0;

    //Get the value of the tombstone from the Replcia Server
    WinErr = GetConfigParam(TEXT(TOMB_STONE_LIFE_TIME),
                           (PVOID)&ulTombstoneLifetimeDays,
                           sizeof(DWORD));
    if (WinErr != ERROR_SUCCESS) {
        LogAndAlertUnhandledError(1);
        DPRINT1( 0, "Couldn't read the tombstone lifetime of domain for the registry: %d", dbErr);
        return dbErr;
    }
   
    __try {
        //retrive the Tombstone lifetime that is stored in the restored dit
        DBOpen2(TRUE, &pTHS->pDB);
         __try {
           
            if (gAnchor.pDsSvcConfigDN) {
                // seek to enterprise-wide DS config object
                dbErr = DBFindDSName( pTHS->pDB, gAnchor.pDsSvcConfigDN );
            }
            else {
                dbErr = DIRERR_OBJ_NOT_FOUND;
            }
    
            if ( 0 == dbErr )
            {
                // Read the garbage collection period and tombstone lifetime from
                // the config object. If either is absent, use defaults.
    
                dbErr = DBGetSingleValue(
                            pTHS->pDB,
                            ATT_TOMBSTONE_LIFETIME,
                            &ulValue,
                            sizeof( DWORD ),
                            NULL
                            );
                switch (dbErr) {
                     case DB_ERR_NO_VALUE:
                        //If there was no value found then use the value we already have
                        DPRINT(1, "Lifetime not found in local DS: using value from replica or default");
                        dbErr = 0;
                        break;
                     case 0:
                        // success! we got the value in ulValue use the smaller of the two
                        if(ulTombstoneLifetimeDays>ulValue)
                            ulTombstoneLifetimeDays=ulValue;
                        break;
                     default:
                        // Some other error!
                        __leave;
                 } /* switch */
            }
        }
        __finally {
            DBClose(pTHS->pDB,fCommit);
        }
    
    
        //check the time of the last USN change
        DBOpen2(TRUE, &pTHS->pDB);
        __try {
           
            ac = SCGetAttById(pTHS, ATT_USN_CHANGED);
            if (ac==NULL) {
                // messed up schema
                DPRINT(0, "Couldn't find ATT_USN_CHANGED\n");
                dbErr = ERROR_DS_MISSING_EXPECTED_ATT;
                __leave;
            }
    
            dbErr = DBSetCurrentIndex(pTHS->pDB,
                                      (eIndexId)0,
                                      ac,
                                      FALSE
                                      );
            if (0 != dbErr) {
                _leave;
            }
    
            dbErr = DBMove(pTHS->pDB,
                           FALSE,
                           DB_MoveLast
                           );
            if (0 != dbErr) {
                _leave;
            }
    
            dbErr = DBGetSingleValue(pTHS->pDB,
                                   ATT_WHEN_CHANGED,
                                   &Lastchange,
                                   sizeof(DSTIME),
                                   NULL);
            if (0 != dbErr) {
                _leave;
            }
        }
        __finally {
            if (0 == dbErr) {
                fCommit = FALSE;
            }
            DBClose(pTHS->pDB,fCommit);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(),
                          &dwException,
                          &dwExceptionAddress,
                          &ulErrorCode,
                          &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //Get the time that has passed since the last time that we had changed
    //the value in the DS
    if (dbErr == 0){
        Time -= Lastchange;
        Time /= DAYS_IN_SECS;
    } else {
        LogAndAlertUnhandledError(1);
        return(STATUS_INTERNAL_ERROR);
    }


    //if more days have gone by than the tombstone will fail the promote
    if (Time>ulTombstoneLifetimeDays) {
        WCHAR TimeSincebackup[6];
        WCHAR Tombstonelife[6];

        swprintf(TimeSincebackup,L"%I64d",Time);
        swprintf(Tombstonelife,L"%d",ulTombstoneLifetimeDays);

        SET_INSTALL_ERROR_MESSAGE2(ERROR_DS_LOCAL_ERROR,
                                   DIRLOG_DS_TOO_OLD,
                                   TimeSincebackup,
                                   Tombstonelife);
        return STATUS_UNSUCCESSFUL;
        
    }
    return STATUS_SUCCESS;
}


NTSTATUS
HandleKeys(
    IN  IFM_SYSTEM_INFO * pIfmSystemInfo,
    PVOID Bootkey OPTIONAL, 
    DWORD cbBootKey
    )
//This function is for the install from media case.  It will get the syskey
//from the restored information.  It will use this key to decrypt the old
//PEK.  Then it will reincrypt the PEK with the local syskey. 
{
    DWORD   err=ERROR_SUCCESS;
    DWORD   Status=STATUS_SUCCESS;
    DWORD   State=0;
    BYTE    SysKey[SYSKEY_SIZE];
    ULONG   cbSysKey=sizeof(SysKey)/sizeof(SysKey[0]);
    BOOLEAN fWasEnabled;
    BOOLEAN ErrorNotSet=TRUE;
    
    State = pIfmSystemInfo->dwState;

    //
    // Get the original IFM system's syskey
    //
    if ( (State&DSROLE_KEY_STORED)==DSROLE_KEY_STORED ) {

        if (pIfmSystemInfo->pvSysKey) {
            Assert(cbSysKey == SYSKEY_SIZE && pIfmSystemInfo->cbSysKey == SYSKEY_SIZE);
            CopyMemory(SysKey, pIfmSystemInfo->pvSysKey, cbSysKey);
        } else {
            Status = pIfmSystemInfo->dwSysKeyStatus;
            DPRINT1(0, "WxReadSysKeyEx failed with %d", Status);
            goto cleanup;
        }

    } else if ( (State&DSROLE_KEY_DISK)==DSROLE_KEY_DISK ) {
        Status = WxLoadSysKeyFromDisk(SysKey,
                                      &cbSysKey);
        if (!NT_SUCCESS(Status)) {
            SET_INSTALL_ERROR_MESSAGE0(RtlNtStatusToDosError(Status),
                                       DIRMSG_FAILED_BOOT_OPTION_SETUP_DISK);
            ErrorNotSet=FALSE;
            DPRINT1(0, "WxLoadSysKeyFromDisk failed with %d", Status);
            goto cleanup;
        }
    } else if ( (State&DSROLE_KEY_PROMPT)==DSROLE_KEY_PROMPT ) {
        if (Bootkey) {
            Assert(cbSysKey == SYSKEY_SIZE && cbBootKey == SYSKEY_SIZE);
            CopyMemory(SysKey,Bootkey,SYSKEY_SIZE);
        } else {
            DPRINT(0, "No BootKey was entered\n");
            goto cleanup;    
        }

    }

    
    Status = PEKInitialize(gAnchor.pDomainDN,
                           DS_PEK_READ_KEYSET,
                           (PVOID)SysKey,
                           cbSysKey
                           );
    if (!NT_SUCCESS(Status)) {
        DPRINT1(0, "PEKInitialize failed with %d", Status);
        goto cleanup;
    }

    Status = WxReadSysKey(
            &cbSysKey,
            (PVOID)SysKey
            );
    if (!NT_SUCCESS(Status)) {
        DPRINT1(0, "WxReadSysKey failed with %d", Status);
        goto cleanup;
    }
    
    Status = PEKChangeBootOption(WxStored,
                                 0,
                                 (PVOID)SysKey,
                                 cbSysKey);
    if (!NT_SUCCESS(Status)) {
        DPRINT1(0, "PEKChangeBootOption failed with %d", Status);
        goto cleanup;
    }

    Status = PEKAddKey((PVOID)SysKey,
                       cbSysKey);

    if (!NT_SUCCESS(Status)) {
        DPRINT1(0, "PEKAddKey failed with %d", Status);
        goto cleanup;
    }
                               
   cleanup:


    if(Status!=STATUS_SUCCESS){
        if(ErrorNotSet) {
            SET_INSTALL_ERROR_MESSAGE0( RtlNtStatusToDosError(Status), 
                                        DIRMSG_FAILED_BOOT_OPTION_SETUP);
        }
        return Status;
    }

    if(err!=ERROR_SUCCESS){
        if(ErrorNotSet) {
            SET_INSTALL_ERROR_MESSAGE0( err, 
                                        DIRMSG_FAILED_BOOT_OPTION_SETUP);
        }
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

DWORD
SetDittoGC()
/*++

Routine Description:

    This function will add the GC option to the 
    options field on the pDSADN.    
    
    
Return Values:

    A value from winerror.h

--*/
{
    THSTATE         *pTHS = pTHStls;
    DWORD           dbErr = ERROR_SUCCESS;
    DWORD           res =ERROR_SUCCESS;
    ULONG           err = 0;
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    ULONG           ulValue=0;
    BOOL            fCommit = FALSE;

    DWORD dwException = 0;
    PVOID dwExceptionAddress = NULL;
    ULONG ulErrorCode  = 0;
    ULONG dsid = 0;

    MODIFYARG   modifyArg;
    MODIFYRES   *modres = NULL;
    ATTRVAL     Val;

    __try {
        DBOpen2(TRUE, &pTHS->pDB);
         __try {
    
            ASSERT( gAnchor.pDSADN != NULL );
            
            dbErr = DBFindDSName( pTHS->pDB, gAnchor.pDSADN );
            DPRINT1( 2, "DBFindDSName : %d \n",dbErr);
    
            if ( 0 == dbErr )
            {
                //get the option attribute and add the GC option to it
                res = DBGetSingleValue(
                            pTHS->pDB,
                            ATT_OPTIONS,
                            (PVOID)&ulValue,
                            sizeof( DWORD ),
                            NULL
                            );
                DPRINT1( 2, "DBGetSingleValue : %d \n",dbErr);
    
                switch (res) {
                    case 0:
                        // success! we got the value in ulValue
                        ulValue |= NTDSDSA_OPT_IS_GC;
                        break;
                    case DB_ERR_ATTRIBUTE_DOESNT_EXIST:
                    case DB_ERR_NO_VALUE:
                        ulValue = NTDSDSA_OPT_IS_GC;
                        break;
                    default:
                        dbErr = res;
                        // Some other error!
                        __leave;
                 } /* switch */
            
            }
        }
        __finally {
            if (dbErr == 0) {
                fCommit=TRUE;    
            } 
    
            DBClose(pTHS->pDB,fCommit);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(),
                          &dwException,
                          &dwExceptionAddress,
                          &ulErrorCode,
                          &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
        dbErr = DB_ERR_EXCEPTION;
    }

    if (dbErr != 0) {
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    // set up the MODIFYARG
    memset(&modifyArg, 0, sizeof(modifyArg));
    InitCommarg(&modifyArg.CommArg);
    modifyArg.pObject = gAnchor.pDSADN;
    modifyArg.count   = 1;

    Val.valLen = sizeof(ulValue);
    Val.pVal   = (UCHAR*)&ulValue;

    modifyArg.FirstMod.choice = AT_CHOICE_ADD_VALUES;
    modifyArg.FirstMod.AttrInf.attrTyp = ATT_OPTIONS;
    modifyArg.FirstMod.AttrInf.AttrVal.valCount = 1;
    modifyArg.FirstMod.AttrInf.AttrVal.pAVal = &Val;
    modifyArg.CommArg.Svccntl.fPermissiveModify = 1;

    err = DirModifyEntry( &modifyArg, &modres );

    if ( err )
    {
        if ( modres )
        {
            NtStatus = DirErrorToNtStatus( err, &modres->CommRes );
        }
        else
        {
            NtStatus =  STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (!NT_SUCCESS(NtStatus)) {

        return RtlNtStatusToDosError(NtStatus);

    }

    return ERROR_SUCCESS;

}

DWORD
CheckGCness(PBOOL isGC)
/*++

Routine Description:

    This function will read the dit to see if it says its a GC    
    
    
Return Values:

    A value from winerror.h

--*/
{
    THSTATE         *pTHS = pTHStls;
    DWORD           dbErr = ERROR_SUCCESS;
    ULONG           ulValue=0;
    BOOL            fCommit = FALSE;
    
    DWORD dwException = 0;
    PVOID dwExceptionAddress = NULL;
    ULONG ulErrorCode  = 0;
    ULONG dsid = 0;

    *isGC = FALSE;

    __try {
        DBOpen2(TRUE, &pTHS->pDB);
         __try {
           
            ASSERT( gAnchor.pDSADN != NULL );
            // seek to enterprise-wide DS config object
            dbErr = DBFindDSName( pTHS->pDB, gAnchor.pDSADN );
    
            if ( 0 == dbErr )
            {
                
                dbErr = DBGetSingleValue(
                            pTHS->pDB,
                            ATT_OPTIONS,
                            (PVOID)&ulValue,
                            sizeof( DWORD ),
                            NULL
                            );
                switch (dbErr) {
                     case 0:
                        // success! we got the value in ulValue use the smaller of the two
                        if(NTDSDSA_OPT_IS_GC==(ulValue&NTDSDSA_OPT_IS_GC)){
                            *isGC=TRUE;
                        }
                        break;
                     default:
                        // Some other error!
                        __leave;
                 } /* switch */
            
            }
        }
        __finally {
            DBClose(pTHS->pDB,fCommit);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(),
                          &dwException,
                          &dwExceptionAddress,
                          &ulErrorCode,
                          &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
        dbErr = DB_ERR_EXCEPTION;
    }

    if (dbErr != 0) {
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    return ERROR_SUCCESS;

}


BOOL
isDitFromGC(IN  PDS_INSTALL_PARAM   InstallInParams,
            OUT PDS_INSTALL_RESULT  InstallOutParams)
/*++

Routine Description:

    This funtion will determine if a Dit can be made a GC and if the user wanted one.

Arguments:

    GCRequested - did the user want a GC


Return Values:

    ERROR_SUCCESS - Success

--*/{
    BOOLEAN RegIsGC=FALSE;
    DWORD   Win32Err=ERROR_SUCCESS;
    BOOL    AmGC=FALSE;
        
    ASSERT(InstallInParams && InstallInParams->pIfmSystemInfo);
    ASSERT(InstallOutParams);

    if ( ( (((IFM_SYSTEM_INFO *)InstallInParams->pIfmSystemInfo)->dwState) &DSROLE_DC_IS_GC) == DSROLE_DC_IS_GC) {
        RegIsGC = TRUE;
    }

    ASSERT((!RegIsGC && !InstallInParams->fPreferGcInstall) || RegIsGC);

    Win32Err = CheckGCness(&AmGC);
    if(Win32Err != ERROR_SUCCESS){
        DPRINT1( 0, "Unable to determine if GC from Database: %ul\n", Win32Err);
        return FALSE;
    }
    
    if (InstallInParams->fPreferGcInstall && !AmGC) {
        InstallOutParams->ResultFlags = DSINSTALL_IFM_GC_REQUEST_CANNOT_BE_SERVICED;
        DPRINT( 0, "Can not create GC as requested\n");
    }
    
    return AmGC && RegIsGC && InstallInParams->fPreferGcInstall;
}


VOID
InstallFreeGlobals(
     VOID
    )
/*++

Routine Description:

    This routine free's the memory associated with global variables needed for setup.
    In particular the gNames struct.
    
Arguments:

    None.

Return Values:

    None.
    
--*/
{
    //
    // Free all the members of the gNames struct and then NULL all the pointers.
    //
    if (gNames.NTDSIniFile) {
        XFree(gNames.NTDSIniFile);
    }
    if (gNames.RootDomainDNName) {
        XFree(gNames.RootDomainDNName);
    }   
    if (gNames.SrcRootDomainSrv) {
        XFree(gNames.SrcRootDomainSrv);
    }
    if (gNames.ConfigNCDNName) {
        XFree(gNames.ConfigNCDNName);
    }
    if (gNames.SrcConfigNCSrv) {
        XFree(gNames.SrcConfigNCSrv);
    }
    if (gNames.RemoteMachineDNName) {
        XFree(gNames.RemoteMachineDNName);
    }
    if (gNames.DsaDNName) {
        XFree(gNames.DsaDNName);
    }
    if (gNames.SchemaDNName) {
        XFree(gNames.SchemaDNName);
    }
    if (gNames.SourceDsaDnsDomainName) {
        XFree(gNames.SourceDsaDnsDomainName);
    }
    if (gNames.IniDefaultConfigNCDit) {
        XFree(gNames.IniDefaultConfigNCDit);
    }
    if (gNames.IniDefaultRootDomainDit) {
        XFree(gNames.IniDefaultRootDomainDit);
    }
    if (gNames.IniDefaultSchemaNCDit) {
        XFree(gNames.IniDefaultSchemaNCDit);
    }
    if (gNames.IniDefaultLocalConnection) {
        XFree(gNames.IniDefaultLocalConnection);
    }
    if (gNames.IniDefaultRemoteConnection) {
        XFree(gNames.IniDefaultRemoteConnection);
    }
    if (gNames.LocalConnectionDNName) {
        XFree(gNames.LocalConnectionDNName);
    }
    if (gNames.RemoteConnectionDNName) {
        XFree(gNames.RemoteConnectionDNName);
    }
    if (gNames.IniDefaultNewDomainCrossRef) {
        XFree(gNames.IniDefaultNewDomainCrossRef);
    }
    if (gNames.NewDomainCrossRefDNName) {
        XFree(gNames.NewDomainCrossRefDNName);
    }
    if (gNames.IniDefaultMachine) {
        XFree(gNames.IniDefaultMachine);
    }
    memset(&gNames, 0, sizeof(gNames));

    return;
}

NTSTATUS
UpdateReplicationEpochAndHiddenDSA(
    IN DSNAME *pDSADN,
    IN DWORD  ReplicationEpoch,
    IN BOOL   fUpdateHiddenTable
    )
/*++

Routine Description:

    This routine will update the Replication Epoch on the Ntds Setting object.
    This routine will update the Hidden table if the fUpdateHiddenTable is Set.
    
Arguments:

    ReplicationEpoch - The value to set the replication Epoch to.  If zero nothing
                       to set
    
    pDSADN - This is a DSNAME of the Ntds Setting Object the hidden Table will
             be updated to point to it and the replicationEpoch will be upated
             on it.
             
    fUpdateHiddenTable - Indicates if the hidden table should be update to point
                         to the ntds settings object that was passed in.
             

Return Values:

    STATUS_SUCCESS.
    
--*/
{
    THSTATE         *pTHS = pTHStls;
    DWORD           dbErr = ERROR_SUCCESS;
    DWORD           err = ERROR_SUCCESS;
    DWORD           res = ERROR_SUCCESS;
    ULONG           ulValue=0;
    BOOL            fCommit = FALSE;

    DWORD dwException = 0;
    PVOID dwExceptionAddress = NULL;
    ULONG ulErrorCode  = 0;
    ULONG dsid = 0;

    if (fUpdateHiddenTable) {
        err = DBReplaceHiddenDSA( pDSADN );
        Assert(err == 0);
        if (err)
        {
            // This shouldn't happen
            return STATUS_NO_MEMORY;
        }
    }
    
    if (ReplicationEpoch == 0) {
        // Nothing needs to be done.
        return STATUS_SUCCESS;
    }

    __try {
        DBOpen2(TRUE, &pTHS->pDB);
         __try {                             
    
            ASSERT( pDSADN != NULL );
            
            dbErr = DBFindDSName( pTHS->pDB, pDSADN );
            DPRINT1( 2, "DBFindDSName : %d \n",dbErr);
    
            if ( 0 == dbErr )
            {
                res = DBGetSingleValue(
                            pTHS->pDB,
                            ATT_MS_DS_REPLICATIONEPOCH,
                            (PVOID)&ulValue,
                            sizeof( DWORD ),
                            NULL
                            );
                DPRINT1( 2, "DBGetSingleValue : %d \n",dbErr);
    
                dbErr = dbInitRec(pTHS->pDB);
                DPRINT1( 2, "dbInitRec : %d \n",dbErr);
                if(dbErr != 0){
                    DPRINT( 0, "The transaction could not be started.\n");
                    _leave;
                }
    
                switch (res) {
                    case 0:
                        // success! we got the value in ulValue
                        ulValue = ReplicationEpoch;
                        dbErr = DBReplaceAttVal(pTHS->pDB,
                                                1,
                                                ATT_MS_DS_REPLICATIONEPOCH,
                                                sizeof( DWORD ),
                                                (PVOID)&ulValue);
                        DPRINT1( 2, "DBReplaceAttVal : %d \n",dbErr);
                        if(dbErr != 0){
                            DPRINT( 0, "The ReplicationEpoch value couldn't be changed on the pDSADN\n");
                            _leave;
                        }
                        break;
                    case DB_ERR_ATTRIBUTE_DOESNT_EXIST:
                        //The attribute was not found so we will add it
                        dbErr = DBAddAtt(pTHS->pDB,
                                         ATT_MS_DS_REPLICATIONEPOCH,
                                         SYNTAX_OBJECT_ID_TYPE);
                        DPRINT1( 2, "DBAddAtt : %d \n",dbErr);
                        if(dbErr != 0){
                            DPRINT( 0, "The ReplicationEpoch couldn't be added to the pDSADN\n");
                            _leave;
                        }
                    case DB_ERR_NO_VALUE:
                        ulValue = ReplicationEpoch;
                        dbErr =  DBAddAttVal(pTHS->pDB,
                                    ATT_MS_DS_REPLICATIONEPOCH,
                                    sizeof( DWORD ),
                                    (PVOID)&ulValue
                                    );
                        DPRINT1( 2, "DBAddAttVal : %d \n",dbErr);
                        if (dbErr != 0) {
                            _leave;
                        }
                        
                        break;
                    default:
                        dbErr = res;
                        // Some other error!
                        __leave;
                 } /* switch */
    
                 //
                 // Update the record
                 //
        
                 dbErr = DBUpdateRec(pTHS->pDB);
                 DPRINT1( 2, "DBUpdateRec : %d \n",dbErr);
                 if (0!=dbErr)
                 {
                     __leave;
                 }
    
            }
        }
        __finally {
            if (dbErr == 0) {
                fCommit=TRUE;    
            } else {
                DBCancelRec(pTHS->pDB);
            }
    
            DBClose(pTHS->pDB,fCommit);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(),
                          &dwException,
                          &dwExceptionAddress,
                          &ulErrorCode,
                          &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
        dbErr = DB_ERR_EXCEPTION;
    }

    if (0 != dbErr) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    if (!dbErr) {
        gAnchor.pLocalDRSExtensions->dwReplEpoch = ReplicationEpoch;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FindAnySite(
    LPWSTR pwszSitesContainer,
    LPWSTR *ppSite
    )
/*++

Routine Description:

    This routine will create a tempory Ntds Setting object on the
    local machine so that it can replicate the schema and configuration
    containers this object will later be deleted by DeleteDummyNtdsDsaObject().
    the ntds Setting will be placed into the first site that is found in the
    restored database files.
    
Arguments:

    pszSitesContainer - The site container will be pass in here
    
    ppSite - Will return the first site found.

Return Values:

    None.
    
Comments:

    None.

*/
{
    NTSTATUS      status = STATUS_SUCCESS;
    ULONG         DirError = 0;
    SEARCHARG     SearchArg;
    SEARCHRES     *SearchRes = NULL;
    ENTINFSEL     EntryInfoSelection;
    ATTR          Attr[1];
    FILTER        Filter;
    ULONG         Size;
    ULONG         NameLen;
    DSNAME       *pSitesContainer = NULL;
    ATTRTYP       FilterVal = CLASS_SITE;

    THSTATE      *pTHS = pTHStls;

    ASSERT(pwszSitesContainer);
    ASSERT(ppSite);

    Size=(ULONG)DSNameSizeFromLen(wcslen( pwszSitesContainer ) );
    pSitesContainer = (DSNAME*)malloc(Size);
    if (!pSitesContainer) {
        status = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    
    ZeroMemory((PUCHAR)pSitesContainer,Size);
    BuildDefDSName(pSitesContainer,pwszSitesContainer,NULL);
    
    //
    // Setup the filter
    //
    RtlZeroMemory( &Filter, sizeof( Filter ) );

    Filter.choice = FILTER_CHOICE_ITEM;
    Filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    Filter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CLASS;
    Filter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(DWORD);
    Filter.FilterTypes.Item.FilTypes.ava.Value.pVal = (PUCHAR) &FilterVal;
    Filter.pNextFilter = NULL;

    //
    // Setup the attr's to return
    //
    RtlZeroMemory( &EntryInfoSelection, sizeof(EntryInfoSelection) );
    EntryInfoSelection.attSel = EN_ATTSET_LIST;
    EntryInfoSelection.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntryInfoSelection.AttrTypBlock.attrCount = 1;
    EntryInfoSelection.AttrTypBlock.pAttr = &(Attr[0]);

    RtlZeroMemory(Attr, sizeof(Attr));
    Attr[0].attrTyp = ATT_OBJ_DIST_NAME;

    RtlZeroMemory( &SearchArg, sizeof(SearchArg) );
    SearchArg.pObject = pSitesContainer;
    SearchArg.choice  = SE_CHOICE_IMMED_CHLDRN;
    SearchArg.bOneNC  = FALSE;
    SearchArg.pFilter = &Filter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = &EntryInfoSelection;
    SearchArg.pSelectionRange = NULL;
    InitCommarg( &SearchArg.CommArg );

    DirError = DirSearch( &SearchArg, &SearchRes );

    if ( SearchRes )
    {
        status = DirErrorToNtStatus( DirError, &SearchRes->CommRes );
        if (!NT_SUCCESS(status)) {
            goto Cleanup;
        }

        //we should find at least one site.
        if (SearchRes->count < 1) {
            status = STATUS_INTERNAL_DB_CORRUPTION;
            goto Cleanup;
        }

        NameLen = 
            ((DSNAME*)SearchRes->FirstEntInf.Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal)->NameLen;

        //+1 for the NULL char.
        *ppSite = (WCHAR*)malloc(
              (NameLen+1)
              *sizeof(WCHAR));
        if (!*ppSite) {
            status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        //Make the string is NULL terminated
        (*ppSite)[NameLen] = L'\0';
        
        memcpy(*ppSite,
               ((DSNAME*)SearchRes->FirstEntInf.Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal)->StringName,
               NameLen*sizeof(WCHAR));

    }
    else
    {
        status = STATUS_NO_MEMORY;
    }


Cleanup:

    if (pSitesContainer) {
        free(pSitesContainer);
    }
    if (SearchRes) {
        THFreeEx(pTHS,SearchRes); 
    }
    if (*ppSite && !NT_SUCCESS(status)) {
        free(*ppSite);
        *ppSite = NULL;
    }

    return status;

}

NTSTATUS
CreateDummyNtdsDsaObject()
/*++

Routine Description:

    This routine will create a tempory Ntds Setting object on the
    local machine so that it can replicate the schema and configuration
    containers this object will later be deleted by DeleteDummyNtdsDsaObject().
    
Arguments:

    None.

Return Values:

    None.
    
Comments:
    
    (dmitrydu) - 9/1/00
    We Will have a need to create this object only for Install from Media (IFM) 
    promotions.  After we restore the DS during the promotion our hidden 
    table points to the DSA of the machine the backup was taken from. We 
    can't change it to point to the new machines DSA because the DSA is 
    created on a remote server and we will not have this object until after 
    we replicate in the configuration NC.  If we attempt to replicate a NC from 
    the machine the backup was taken our gAnchor.pDSADN will equal that of the 
    machine we are trying to replicate from.  That machine will return the 
    error ERROR_DS_CLIENT_LOOP.  From this the promotion will fail. We can't 
    change manually can the gAnchor.pDSADN because the hidden table points to 
    the DNT of the old DSA.  Every time RebuildAchor is called it will reset 
    the gAnchor.pDSADN back to the old DSA (this does happen in-between 
    replicating NC's).  This is were the need for a temporary object comes in. 
    We need to create this object so that we can update the hidden table to 
    point to the DNT of this temp object.  Once the object is created and 
    the hidden table updated we should call RebuildAnchor to update the 
    gAnchor.pDSADNto point to the new object.  After will replicate in the 
    configuration NC there is no longer a need for the temporary object.  
    We should update the Hidden table to point to the DSA of the machine and 
    rebuild the anchor.  Then we should delete the temporary object since we 
    have no farther need for it.
    
--*/
{
    void   * pDummy = NULL;
    DWORD    dummyDelay = 0;
    NTSTATUS status = STATUS_SUCCESS;
    DWORD    WinErr = ERROR_SUCCESS;
    PWCHAR   TempDsaPrefix = NULL;
    PWCHAR   DsaDNName = NULL;
    PWCHAR   SiteName = NULL;
    DSNAME * DsaTempDSName = NULL;
    DSNAME * DsaTempDSName2 = NULL;
    UUID     DsaUUID;
    ULONG    DsnameSize=0;

    if(WinErr = UuidCreate(&DsaUUID)){
        status = STATUS_NO_MEMORY;
        goto cleanup;
    }
    if(WinErr = UuidToStringW(&DsaUUID,&TempDsaPrefix)){
        status = STATUS_NO_MEMORY;
        goto cleanup;
    }
    
    DsnameSize=(ULONG)DSNameSizeFromLen(wcslen( gNames.DsaDNName) );
    DsaTempDSName = (DSNAME*)malloc(DsnameSize);
    if (!DsaTempDSName) {
        status = STATUS_NO_MEMORY;
        goto cleanup;
    }

    DsaTempDSName2 = (DSNAME*)malloc(DsnameSize);
    if (!DsaTempDSName2) {
        status = STATUS_NO_MEMORY;
        goto cleanup;                      
    }
    ZeroMemory((PUCHAR)DsaTempDSName,DsnameSize);
    ZeroMemory((PUCHAR)DsaTempDSName2,DsnameSize);
    BuildDefDSName(DsaTempDSName,gNames.DsaDNName,NULL);
    
    TrimDSNameBy(DsaTempDSName, 4, DsaTempDSName2);

    //Find a existing site to place the tempory object into.
    status = FindAnySite(DsaTempDSName2->StringName,
                         &SiteName);
    if (!NT_SUCCESS(status)) {
        goto cleanup;                      
    }

    DsaDNName = (PWCHAR)malloc((wcslen(SiteName) 
                                + wcslen(L"CN=NTDS Settings,CN=,CN=Servers,") 
                                + wcslen(TempDsaPrefix) 
                                + 1) 
                               * sizeof(WCHAR));
    if (!DsaDNName) {
        status = STATUS_NO_MEMORY;
        goto cleanup;
    }
    //construct the temp name of the NTDS Setting object
    wcscpy(DsaDNName,L"CN=NTDS Settings,CN=");
    wcscat(DsaDNName,TempDsaPrefix);
    wcscat(DsaDNName,L",CN=Servers,");
    wcscat(DsaDNName,SiteName);

    status = CreateNtdsDsaObject(DsaDNName,
                                 gNames.RootDomainDNName,
                                 gNames.ConfigNCDNName,
                                 gNames.SchemaDNName);

    if (NT_SUCCESS(status)) {
        RebuildAnchor(NULL, &pDummy, &dummyDelay);
    }
    
    cleanup:

    if (!NT_SUCCESS(status)) {
        SET_INSTALL_ERROR_MESSAGE1( RtlNtStatusToDosError( status ),
                                    DIRMSG_INSTALL_FAILED_TO_CREATE_NTDSA_OBJECT,
                                    DsaDNName );
    }

    if (NULL != DsaDNName) {
        free(DsaDNName);
    }
    if (NULL != TempDsaPrefix) {
        RpcStringFreeW(&TempDsaPrefix);
    }
    if (NULL != DsaTempDSName) {
        free(DsaTempDSName);
    }
    if (NULL != DsaTempDSName2) {
        free(DsaTempDSName2);
    }
    if (NULL != SiteName) {
        free(SiteName);
    }

    return status;
}

DWORD
DeleteDummyNtdsDsaObjectHelper(DSNAME *objtodel)
/*++

Routine Description:

    This routine will delete the NTDS Setting object that was
    used by the IFM promotion as well as the parent of the object.
    
    This helper does the deletes.
    
Arguments:

    None.

Return Values:

    None.
    
--*/
{
    
    THSTATE *  pTHS = pTHStls;
    REMOVEARG  remarg;
    COMMRES    CommRes;
    ULONG      DirError = 0;
    BOOL       fCommit = FALSE;

    DWORD dwException = 0;
    PVOID dwExceptionAddress = NULL;
    ULONG ulErrorCode  = 0;
    ULONG dsid = 0;
    
    // Create remarg                                                                           
    memset( &remarg, 0, sizeof(remarg) );
    memset( &CommRes, 0, sizeof(CommRes) );
    remarg.pObject = objtodel;                                                                 
    InitCommarg( &remarg.CommArg );

    __try {
        DBOpen2(TRUE, &pTHS->pDB);
         __try {
                // Do name resolution.                                                                     
            DirError = DoNameRes(pTHS,                                                                     
                                 NAME_RES_IMPROVE_STRING_NAME,                                             
                                 remarg.pObject,                                                           
                                 &remarg.CommArg,                                                          
                                 &CommRes,                                                                 
                                 &remarg.pResObj);                                                         
            if(DirError){                                                                                  
                __leave;
            }
                                                                                                           
                                                                   
            // Do actual delete/remove                                                                     
            LocalRemove(pTHS, &remarg);                                                                    
        }
        __finally {
            if (0 == pTHS->errCode && 0 == DirError) {
                fCommit = TRUE;
            }
            DBClose(pTHS->pDB,fCommit);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(),
                          &dwException,
                          &dwExceptionAddress,
                          &ulErrorCode,
                          &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
        DirError = DB_ERR_EXCEPTION;
    }

    if (DB_ERR_EXCEPTION == DirError) {
        return ERROR_NO_SYSTEM_RESOURCES;
    }
                                                                                                   
    if (0 == pTHS->errCode && 0 == DirError) {
        return ERROR_SUCCESS;
    } else {
        return ERROR_DS_CANT_DELETE;
    }
}


DWORD
DeleteDummyNtdsDsaObject()
/*++

Routine Description:

    This routine will delete the NTDS Setting object that was
    used by the IFM promotion as well as the parent of the object.
    
Arguments:

    None.

Return Values:

    None.
    
--*/
{
    DSNAME  *  pDSADNParent = NULL;
    DWORD   WinError = ERROR_SUCCESS;

    pDSADNParent = (DSNAME*)malloc(gAnchor.pDSADN->structLen);
    if (!pDSADNParent) {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    TrimDSNameBy(gAnchor.pDSADN, 1, pDSADNParent);

    WinError = DeleteDummyNtdsDsaObjectHelper(gAnchor.pDSADN);
    if (ERROR_SUCCESS != WinError) {
        goto cleanup;
    }

    WinError = DeleteDummyNtdsDsaObjectHelper(pDSADNParent);
    if (ERROR_SUCCESS != WinError) {
        goto cleanup;
    }

    cleanup:

    if (NULL != pDSADNParent) {
        free(pDSADNParent);
    }
    
    return WinError;

}

NTSTATUS
WriteMultiValuedAtt(
    IN  DSNAME   *Object,
    IN  ATTRTYP  attrTyp,
    IN  DWORD    Count,
    IN  ATTRVAL  *pAVal,
    IN  BOOL     RunAsDRA
    )
/*++

Routine Description:

    This routine will place a list of values on a mutli-valued attribute.
    
Arguments:

    pTHS -- the thread state
    
    pAC --  the attribute to retrieve
    
    Count -- the number of values found
    
    pAVal -- the values to write on the attribute

Return Values:

    ERROR_SUCCESS
    
--*/
{
    THSTATE    *pTHS       = pTHStls;
    ULONG      err         = 0;
    NTSTATUS   NtStatus = STATUS_SUCCESS;

    MODIFYARG   modifyArg;
    MODIFYRES   *modres = NULL;
    BOOL        currentfDRA = pTHS->fDRA;

    // set up the MODIFYARG
    memset(&modifyArg, 0, sizeof(modifyArg));
    InitCommarg(&modifyArg.CommArg);
    modifyArg.pObject = Object;
    modifyArg.count   = 1;

    // We use replace semantics because no other values may exist on the new object
    modifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
    modifyArg.FirstMod.AttrInf.attrTyp = attrTyp;
    modifyArg.FirstMod.AttrInf.AttrVal.valCount = Count;
    modifyArg.FirstMod.AttrInf.AttrVal.pAVal = pAVal;
    modifyArg.CommArg.Svccntl.fPermissiveModify = 1;

    // There are certain attributes such as msDS-HasMasterNCs, hasMasterNCs, etc that 
    // need to  be updated during an IFM install that can only be modified by the DRA.  
    // If we are modifing such an attribute then say that we are the DRA.
    if (RunAsDRA) {
        pTHS->fDRA = TRUE;
    }
    
    err = DirModifyEntry( &modifyArg, &modres );

    if (RunAsDRA) {
        pTHS->fDRA = currentfDRA;
    }

    if ( err )
    {
        if ( modres )
        {
            NtStatus = DirErrorToNtStatus( err, &modres->CommRes );
        }
        else
        {
            NtStatus =  STATUS_INSUFFICIENT_RESOURCES;
        }
        DPRINT3( 0, "WriteMultiValuedAtt failed, dn=%ws, attrtyp=%d, err=%d\n",
                 Object->StringName, attrTyp, err );
        DbgPrintErrorInfo();
    }

    return NtStatus;

}
     
NTSTATUS
CopyDsaAttributes(
    IN  PDS_INSTALL_PARAM   InstallInParams,
    IN PDSNAME pCurrentDSA,
    IN PDSNAME pNewDSA,
    IN BOOL fDoFinalUpdates
    )
/*++

Routine Description:

    This routine will set the Instatiated, partial and master NC on the
    new DSA to have the same values as the Current DSA.
    
Arguments:
    
    InstallInParams - Installation input parameters

    pCurrentDSA --  a pointer to the dsname of the current DSA
    
    pNewDSA -- a pointer to the dsname of the new DSA

    fDoFinalUpdates - whether we are updating the real DSA or not

Return Values:

    STATUS_SUCCESS
    
--*/
{
    NTSTATUS        Status      = STATUS_SUCCESS;
    DWORD           i           = 0;
    ULONG           err         = 0;
    NTSTATUS        NtStatus    = STATUS_SUCCESS;
    
    THSTATE    *pTHS       = pTHStls;
    DWORD dwException = 0;
    PVOID dwExceptionAddress = NULL;
    ULONG ulErrorCode  = 0;
    ULONG dsid = 0;

    ENTINFSEL     entInfSel;
    READARG       readArg;
    READRES       *pReadRes;
    ATTR          attr[5];

    // set up the ENTINFSEL for the DirRead
    attr[0].attrTyp = ATT_HAS_MASTER_NCS; // deprecated "old" hasMasterNCs
    attr[0].AttrVal.valCount = 0;
    attr[0].AttrVal.pAVal    = NULL;

    attr[1].attrTyp = ATT_HAS_PARTIAL_REPLICA_NCS;
    attr[1].AttrVal.valCount = 0;
    attr[1].AttrVal.pAVal    = NULL;

    attr[2].attrTyp = ATT_MS_DS_HAS_INSTANTIATED_NCS;
    attr[2].AttrVal.valCount = 0;
    attr[2].AttrVal.pAVal    = NULL;


    attr[3].attrTyp = ATT_RETIRED_REPL_DSA_SIGNATURES;
    attr[3].AttrVal.valCount = 0;
    attr[3].AttrVal.pAVal    = NULL;

    attr[4].attrTyp = ATT_MS_DS_HAS_MASTER_NCS; // "new" hasMasterNCs
    attr[4].AttrVal.valCount = 0;
    attr[4].AttrVal.pAVal    = NULL;

    memset(&entInfSel, 0, sizeof(ENTINFSEL));
    entInfSel.attSel    = EN_ATTSET_LIST;
    entInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

    entInfSel.AttrTypBlock.attrCount = 5;
    entInfSel.AttrTypBlock.pAttr     = attr;

    // set up the READARG
    memset(&readArg, 0, sizeof(readArg));
    InitCommarg(&readArg.CommArg);
    readArg.pObject   = pCurrentDSA;
    readArg.pSel      = &entInfSel;

    //
    // Read the value that the server actually used so that
    // it can be returned to the client
    //
    err = DirRead(&readArg, &pReadRes);

    if ( err )
    {
        if ( pReadRes )
        {
            NtStatus = DirErrorToNtStatus( err, &pReadRes->CommRes );
        }
        else
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    

    for (i = 0; i < pReadRes->entry.AttrBlock.attrCount;i++) {
        Status = WriteMultiValuedAtt(pNewDSA,
                                     pReadRes->entry.AttrBlock.pAttr[i].attrTyp,
                                     pReadRes->entry.AttrBlock.pAttr[i].AttrVal.valCount,
                                     pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal,
                                     TRUE
                                     );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

    }
    
    // Do final updates
    // Retire old signature on new DSA object
    // Modify old signature list which was copied from old DSA
    if (fDoFinalUpdates) {
        CHAR szUuid1[SZUUID_LEN];
        ATTRVAL AVal;

        Assert( !fNullUuid( &(InstallInParams->InvocationIdOld) ) );

        // Find the returned signature, if any
        memset( &AVal, 0, sizeof( AVal ) );
        for (i = 0; i < pReadRes->entry.AttrBlock.attrCount;i++) {
            if (pReadRes->entry.AttrBlock.pAttr[i].attrTyp == ATT_RETIRED_REPL_DSA_SIGNATURES) {
                AVal = pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0];
                break;
            }
        }

        // Add previous identity to list
        DraGrowRetiredDsaSignatureVector(
            pTHS,
            &(InstallInParams->InvocationIdOld),
            &(InstallInParams->UsnAtBackup),
            (REPL_DSA_SIGNATURE_VECTOR **) &(AVal.pVal),
            &(AVal.valLen) );

        DPRINT2( 0, "Retiring DSA signature: invocation ID %s @ USN %I64d\n",
                 DsUuidToStructuredString(&(InstallInParams->InvocationIdOld), szUuid1),
                 InstallInParams->UsnAtBackup );

        Status = WriteMultiValuedAtt(pNewDSA,
                                     ATT_RETIRED_REPL_DSA_SIGNATURES,
                                     1,
                                     &AVal,
                                     TRUE
                                     );
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

    }

    Cleanup:

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    return STATUS_SUCCESS;
}


DWORD
ConvertMachineAccount(
    IN  PDS_INSTALL_PARAM   InstallInParams,
    OUT PDS_INSTALL_RESULT  InstallOutParams
    )
/*++

Routine Description:

    This routine changes the User Account Control setting on the
    local machine's machine account in the domain.  Note that this
    must be done prior to replicating in the critical objects so that
    the machine account is brought down.  (Make the machine account object
    a DC, makes the object "critical").

Arguments:
    
    InstallInParams --  caller supplied information
    
    InstallOutParams -- updated to indicate whether the machine account
                        was morphed.

Return Values:

    ERROR_SUCCESS, a fatal winerror otherwise.          
    
--*/
{
    DWORD WinError = NULL;
    PSEC_WINNT_AUTH_IDENTITY_W pCreds = NULL;
    LPWSTR AccountDn = NULL;
    HMODULE hMod = NULL;
    NTDSETUP_NtdsSetReplicaMachineAccount  pfnSetMachineAccount = NULL;

    //
    // Get the NTDSETUP dll
    //
    hMod = LoadLibrary("ntdsetup");
    if (hMod) {
        pfnSetMachineAccount = (NTDSETUP_NtdsSetReplicaMachineAccount)
                                GetProcAddress(hMod,
                                               NTDSETUP_SET_MACHINE_ACCOUNT_FN);
    }
    if (NULL == pfnSetMachineAccount) {
        WinError = GetLastError();
        goto Exit;
    }

    //
    // Pull the credentials in
    //
    WinError = DrspGetCredentials(&pCreds);
    if (ERROR_SUCCESS != WinError) {
        goto Exit;
    }

    //
    // Call out to setup the machine account
    //

    WinError =  (*pfnSetMachineAccount)(pCreds,
                                        InstallInParams->ClientToken,
                                        gNames.SrcRootDomainSrv,
                                        InstallInParams->AccountName,
                                        UF_SERVER_TRUST_ACCOUNT,
                                        &AccountDn);

    if (WinError == ERROR_SUCCESS) {

        //
        // Indicate this operation was done so that it can be undone
        // if necessary.
        //
        InstallOutParams->InstallOperationsDone |= NTDS_INSTALL_SERVER_MORPHED;

    }

Exit:

    if (AccountDn) {

        RtlFreeHeap(RtlProcessHeap(), 0, AccountDn);
    }

    if (pCreds) {
        DrspFreeCredentials(pCreds);
        pCreds = NULL;
    }

    if (hMod) {
        FreeLibrary(hMod);
    }

    if (ERROR_SUCCESS != WinError) {

        SET_INSTALL_ERROR_MESSAGE1( WinError,
                                    DIRMSG_SETUP_MACHINE_ACCOUNT_NOT_MORPHED,
                                    InstallInParams->AccountName );

    }

    return WinError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dblayer\dbcache.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1989 - 1999
//
//  File:       dbcache.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:


DETAILS:

CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <mdlocal.h>
#include <dsatools.h>

#include <mdcodes.h>
#include <dsevent.h>
#include <dstaskq.h>
#include <dsexcept.h>
#include <filtypes.h>
#include "objids.h" /* Contains hard-coded Att-ids and Class-ids */
#include <sync.h>
#include "debug.h"  /* standard debugging header */
#define DEBSUB "DBCACHE:" /* define the subsystem for debugging */

#include "dbintrnl.h"
#include "anchor.h"
#include <ntdsctr.h>

#include <fileno.h>
#define  FILENO FILENO_DBCACHE

#if DBG
// Debug only routine to aggressively check the dnread cache.  Only way to turn
// it on is to use a debugger to set the following BOOL to TRUE
BOOL gfExhaustivelyValidateDNReadCache = FALSE;
VOID
dbExhaustivelyValidateDNReadCache(
        THSTATE *pTHS
        );
#endif

CRITICAL_SECTION csDNReadLevel1List;
CRITICAL_SECTION csDNReadLevel2List;

#if DBG
ULONG ulDNRFindByDNT=0;
ULONG ulDNRFindByPDNTRdn=0;
ULONG ulDNRFindByGuid=0;
ULONG ulDNRCacheCheck=0;
ULONG ulDNRCacheKeepHold=0;
ULONG ulDNRCacheThrowHold=0;

// NOTE, we use ++ instead of interlocked or critsec because these are simple,
// debug only, internal perfcounters.  They are only visible with a debugger.
// The perf teams tells us that in cases where the occasional increment can
// afford to be lost, ++ instead of interlocked can make a measurable
// performance boost.
#define INC_FIND_BY_DNT      ulDNRFindByDNT++
#define INC_FIND_BY_PDNT_RDN ulDNRFindByPDNTRdn++
#define INC_FIND_BY_GUID     ulDNRFindByGuid++
#define INC_CACHE_CHECK      ulDNRCacheCheck++
#define INC_CACHE_KEEP_HOLD  ulDNRCacheKeepHold++
#define INC_CACHE_THROW_HOLD ulDNRCacheThrowHold++

#else

#define INC_FIND_BY_DNT
#define INC_FIND_BY_PDNT_RDN
#define INC_FIND_BY_GUID
#define INC_CACHE_CHECK
#define INC_CACHE_KEEP_HOLD
#define INC_CACHE_THROW_HOLD

#endif

d_memname *
dnCreateMemname(
        IN DBPOS * pDB,
        IN JET_TABLEID tblid
        );


typedef struct _DNT_COUNT {
    DWORD DNT;
    DWORD count;
} DNT_COUNT_STRUCT;

typedef struct _DNT_HOT_LIST {
    struct _DNT_HOT_LIST *pNext;
    DWORD                 cData;
    DNT_COUNT_STRUCT     *pData;
} DNT_HOT_LIST;

// MAX_LEVEL_1_HOT_DNTS is the maximum number of DNTs in a level 1 Hot list
#define MAX_GLOBAL_DNTS             128
#define MAX_LEVEL_1_HOT_DNTS         32
#define MAX_LEVEL_1_HOT_LIST_LENGTH 128
#define MAX_LEVEL_2_HOT_DNTS         64
#define MAX_LEVEL_2_HOT_LIST_LENGTH 128
// This is 1 minute, expressed in ticks.
#define DNREADREBUILDDELAYMIN (1000 * 60 * 1)
// This is 5 minutes, expressed in ticks.
#define DNREADREBUILDDELAYMAX (1000 * 60 * 5)

DNT_HOT_LIST *Level1HotList=NULL;
DWORD         Level1HotListCount = 0;
DNT_HOT_LIST *Level2HotList=NULL;
DWORD         Level2HotListCount = 0;
BOOL          bImmediatelyAggregateLevel1List = TRUE;
BOOL          bImmediatelyAggregateLevel2List = TRUE;
DWORD         gLastDNReadDNTUpdate = 0;
DWORD         gtickLastRebuild = 0;



// The following critical section safeguards the following data structures.
CRITICAL_SECTION csDNReadGlobalCache;
DWORD           *pGlobalDNReadCacheDNTs = NULL;
DWORD            cGlobalDNTReadCacheDNTs = 0;


// The following binary lock safeguards the following data structures.
SYNC_BINARY_LOCK blDNReadInvalidateData;
// Start sequence at 1 and inc by 2 so that 0 and 2 are invalid sequence numbers.
const DWORD      DNReadOriginSequenceUninit = 0;
const DWORD      DNReadOriginSequenceInvalid = 2;
volatile DWORD   gDNReadLastInvalidateSequence = 1;


BOOL
dnAggregateInfo(
        DNT_HOT_LIST *pList,
        DWORD         maxOutSize,
        DNT_HOT_LIST **ppResult
        )
/*++

  This routine is called by dnRegisterHotList, below.

  This routine takes in a linked list of DNT_HOT_LIST structures and aggregates
  the data hanging off each structure.  That data contains DNT and count pairs.
  After aggregating all the data into a single structure (summing the counts),
  the single aggregate structure is trimmed to include no more than maxOutSize
  DNTs, dropping DNTs associated with lower counts.  The aggregate data is
  returned as a single DNT_HOT_LIST structure.  The data and DNT_HOT_LIST
  structure are allocated here, using malloc.  The returned data is sorted by
  DNT. The input list is freed.

  If anything goes wrong in this routine (primarily, failure to allocate
  memory), no data is returned and the input list is still freed.

  returns TRUE if all went well, FALSE otherwise.  If TRUE, the ppResult points
  to a pointer to the aggregated data.

--*/
{
    THSTATE *pTHS = pTHStls;
    DWORD Size;
    DWORD i,j;
    DNT_HOT_LIST *pTemp;
    DNT_COUNT_STRUCT *pData=NULL;
    BOOL bFound;
    DWORD  begin, end, middle;


    (*ppResult) =  malloc(sizeof(DNT_HOT_LIST));
    if(!(*ppResult)) {
        // This shouldn't happen.  Since it did, just free up the level 1 list
        // and return. Yes, we are losing information.
        while(pList) {
            pTemp = pList->pNext;
            free(pList->pData);
            free(pList);
            pList = pTemp;
        }
        return FALSE;
    }

    (*ppResult)->pNext = NULL;
    (*ppResult)->pData = NULL;
    (*ppResult)->cData = 0;

    // First, find the max size we'll need.
    Size=0;
    pTemp = pList;
    while(pTemp) {
        Size += pTemp->cData;
        pTemp = pTemp->pNext;
    }

    pData = malloc(Size * sizeof(DNT_COUNT_STRUCT));
    if(!pData) {
        // This shouldn't happen.  Since it did, just free up the level 1 list
        // and return. Yes, we are losing information.
        while(pList) {
            pTemp = pList->pNext;
            free(pList->pData);
            free(pList);
            pList = pTemp;
        }
        free(*ppResult);
        *ppResult = NULL;
        return FALSE;
    }

    // preload the first element with a 0 count.  This makes the binary search
    // below easier to code.
    pData[0].DNT = pList->pData[0].DNT;
    pData[0].count = 0;

    // OK, aggregate the info.
    // Note that we keep pData sorted by DNT, since we're sure it's big enough
    // to hold all the objects.

    Size = 1;
    pTemp = pList;
    j=0;
    while(pList) {
        pTemp = pList->pNext;
        j++;
        for(i=0;i<pList->cData;i++) {
            // Look up the correct node in the pData array. Since pData is
            // sorted by DNT, use a binary search.
            begin = 0;
            end = Size;
            middle = (begin + end) / 2;
            bFound = TRUE;
            while(bFound && (pData[middle].DNT != pList->pData[i].DNT)) {
                if(pData[middle].DNT > pList->pData[i].DNT) {
                    end = middle;
                }
                else {
                    begin = middle;
                }
                if(middle == (begin + end) / 2) {
                    bFound = FALSE;
                    if(pData[middle].DNT < pList->pData[i].DNT) {
                        middle++;
                    }
                }
                else {
                    middle = (begin + end)/2;
                }
            }
            if(!bFound) {
                if(middle < Size) {
                    memmove(&pData[middle + 1],
                            &pData[middle],
                            (Size - middle) * sizeof(DNT_COUNT_STRUCT));
                }
                Size++;
                pData[middle] = pList->pData[i];
            }
            else {
                // Update the count.
                pData[middle].count += pList->pData[i].count;
            }
        }
        free(pList->pData);
        free(pList);
        pList = pTemp;
    }

    // OK, we now have aggregated the data.  Next, trim the data down to only
    // the N hottest.
    if(Size > maxOutSize) {
        // Too much data, trim out the maxOutSize - Size coldest objects.
        DWORD *Counts=NULL;
        DWORD  countSize = 0;
        DWORD  spillCount = 0;
        DWORD  leastCountVal = 0;

        // allocate 1 greater than the max out size because after we have filled
        // up maxCountSize elements, the insertion algorithm just shifts
        // everything down by one from the insertion point, so let's make sure
        // we have some "scratch" space after the end of the array.
        //
        Counts = THAlloc((1 + maxOutSize) * sizeof(DWORD));
        if(Counts) {
            // preload the array.
            Counts[0] = pData[0].count;
            countSize = 1;
            leastCountVal = Counts[0];

            for(i=1;i<Size;i++) {
                j=0;
                // Insert pData[i].count into the list.
                while(j < countSize && Counts[j] >= pData[i].count)
                    j++;

                if(j == countSize) {
                    // insert at end
                    if(countSize != maxOutSize) {
                        leastCountVal = pData[i].count;
                        Counts[countSize] = pData[i].count;
                        countSize++;
                    }
                    else {
                        // OK, we don't actually have room for this one, but, if
                        // it equal to leastcountval, we have to inc the
                        // spillcount, since we are spilling it.
                        if(leastCountVal == pData[i].count) {
                            spillCount++;
                        }
                    }
                }
                else if(j < countSize) {
                    // Yep, the current count is greater than some count in the
                    // count list.  Keep it.
                    if(countSize == maxOutSize) {
                        // We're spilling.
                        // NOTE: this algorithm only works for maxOutSize > 1
                        if(Counts[maxOutSize - 2 ] == leastCountVal) {
                            spillCount++;
                        }
                        else {
                            leastCountVal = Counts[maxOutSize - 2];
                            spillCount = 0;
                        }

                        // This is the place where we just move everything down
                        // one element.  Note that if we hadn't allocated an
                        // extra space for scratch, this memmove would shift the
                        // last element in the Counts array to one past the last
                        // element.
                        //
                        // Yes, there are other ways to do this, but
                        // this is tested.  If you really want to change this,
                        // feel free.  The change would be to not overallocate,
                        // and to memmove only countSize - j - 1 elements here.
                        // If you do that, rearrange the code in the else block
                        // to do the countSize++ first, then you can change that
                        // memmove to be countSize - j - 1 also, and so you can
                        // put the memmove and the assign onto a common code
                        // path, out of the if and the else.
                        memmove(&Counts[j+1], &Counts[j],
                                (countSize - j) * sizeof(DWORD));
                        Counts[j] = pData[i].count;
                    }
                    else {
                        // We're not spilling.
                        memmove(&Counts[j+1], &Counts[j],
                                (countSize - j) * sizeof(DWORD));
                        Counts[j] = pData[i].count;

                        countSize++;
                    }
                }
            }

            // OK, now tighten up the pData, keeping anything with a count
            // greater than leastCountVal, and throw away spillCount objects
            // with value leastCountVal

            for(i=0,j=0;i<Size;i++) {
                if(pData[i].count > leastCountVal) {
                    // Keep this value.
                    pData[j] = pData[i];
                    j++;
                }
                else if(pData[i].count == leastCountVal) {
                    if(spillCount) {
                        spillCount--;
                    }
                    else {
                        // Keep this value.
                        pData[j] = pData[i];
                        j++;
                    }
                }
            }

            Size = j;
            THFreeEx(pTHS,Counts);

        }
        else {
            // We couldn't allocate the structure we need to find the maxOutSize
            // hottest objects, so we are arbitrarily keeping the first portion
            // of the data, not the hottest.
            Size = maxOutSize;
        }

    }

    (*ppResult)->pNext = NULL;
    (*ppResult)->cData = Size;
    (*ppResult)->pData  = realloc(pData, Size * sizeof(DNT_COUNT_STRUCT));

    if(!((*ppResult)->pData)) {
        free(pData);
        free(*ppResult);
        *ppResult = NULL;
        return FALSE;
    }


    return TRUE;
}


VOID
dnRegisterHotList (
        DWORD localCount,
        DNT_COUNT_STRUCT *DNTs
        )
/*++

  This routine is called by dnReadProcessTransactionalData, below.

  It is passed in an array of DNTs + counts, and a size specify the number of
  objects in the array.

  This routine takes the data and copies it into malloced memory.  This data is
  hung on a DNT_HOT_LIST structure (a linked list node, basically), and the data
  is added to the level 1 hot list.

  If the level 1 hot list is not yet full, the call returns.

  If the level 1 hot list is full, the routine takes the hot list from it's
  global pointer and calls dnAggregateInfo to condense all the DNT-counts in the
  level 1 hot list.  The resulting coallesced/condensed data is added to the
  level 2 hot list, which uses the same format as the level 1 hot list.

  If the level 2 hot list is not yet full, the call returns.

  If the level 2 hot list is full, the routine aggregates the info in that list
  and then puts the resulting list of DNTs in place as the global list of DNTs
  that should be in the global portion of the dnread cache.  If aggregating the
  info from the level 2 list results in fewer DNTs than we are willing to cache,
  DNTs from the global DNT cache list are added to the newly created one.  Since
  the lists are kept ordered by DNTs, lower DNTs are more likely to be
  transferred from the old list to the new than higher DNTs are.

  After the new list is put in place (a global pointer), a task queue event is
  placed to ask for a recalculation of the global portion of the dnread cache.

  Note also, that the lists are aggregated if this is the first time through
  this routine, or if it has been more than  DNREADREBUILDDELAYMAX ticks since
  the lists have been aggregated.

  In general, if anything goes wrong during this routine (primarily memory
  allocation), then data is simply dropped, no errors are returned.  This could
  lead to empty global dnread caches, or lists of DNTs that are cold.  Neither
  condition is fatal, and should be cleaned up by simply waiting (unless
  something is seriously wrong with the machine, in which case other threads
  will be reporting errors.)


--*/
{
    DWORD *pNewDNReadCacheDNTs=NULL;
    DWORD i, Size, StaleCount=0;
    DNT_HOT_LIST *pThisElement, *pTemp;
    ULONG dtickRebuild,cRegisterHotListSkip;
    DWORD *pDNTs = NULL;
    size_t iProc;

    Assert(DsaIsRunning());

    if(!localCount || eServiceShutdown) {
        // Caller didn't really have a hot list, or we're about to exit
        return;
    }

    // Build a malloced element for the level 1 hot list.
    pThisElement = malloc(sizeof(DNT_HOT_LIST));
    if(!pThisElement) {
        return;
    }

    pThisElement->pNext = NULL;
    pThisElement->pData = malloc(localCount * sizeof(DNT_COUNT_STRUCT));
    if(!pThisElement->pData) {
        free(pThisElement);
        return;
    }

    memcpy(pThisElement->pData, DNTs, localCount * sizeof(DNT_COUNT_STRUCT));
    pThisElement->cData = localCount;

    // Now, add it to the level 1 list.
    EnterCriticalSection(&csDNReadLevel1List);
    __try {
        pThisElement->pNext = Level1HotList;

#if DBG
        {
            // Someone is mangling the pointer in the hotlist by incing or
            // decing it.  Let's try to catch them early.
            DNT_HOT_LIST *pTempDbg = Level1HotList;

            while(pTempDbg) {
                Assert(!(((DWORD_PTR)pTempDbg) & 3));
                pTempDbg = pTempDbg->pNext;
            }
        }
#endif

        // See how long it's been since we have signalled for a rebuild.  If
        // it's been long enough, set the flags. To force aggregation of both
        // lists now.
        if((GetTickCount() - gLastDNReadDNTUpdate) > DNREADREBUILDDELAYMAX) {
            // reset the global tick count here, so that anyone coming through
            // here between now and when we actually get to signal doesn't also
            // aggregate the lists (which, if this thread is succesful, should
            // be empty).
            gLastDNReadDNTUpdate = GetTickCount();

            // Setting these flags to FALSE forces aggregation of the lists and
            // recalculation of the dnread dnt list.
            bImmediatelyAggregateLevel1List = TRUE;
            bImmediatelyAggregateLevel2List = TRUE;
        }

        // bImmediatelyAggregateLevel1List starts out globally TRUE so that the
        // first time someone comes through here, it lets the first
        // hot list blow right through here to get made into a global list of
        // DNTs to cache, since we don't have one already.
        if(bImmediatelyAggregateLevel1List ||
           (Level1HotListCount == MAX_LEVEL_1_HOT_LIST_LENGTH)) {

            bImmediatelyAggregateLevel1List = FALSE;
            Level1HotListCount = 0;
            Level1HotList = NULL;
        }
        else {
            Level1HotList = pThisElement;
            pThisElement = NULL;
            Level1HotListCount++;
        }
    }
    __finally {
        LeaveCriticalSection(&csDNReadLevel1List);
    }

    if(!pThisElement) {
        return;
    }


    DPRINT2(4,"Level 1 aggregate, 1- %d, 2- %d\n", Level1HotListCount,
            Level2HotListCount);

    // If pThisElement is non-null, we have been elected to aggregate the info
    // in a level 1 hot list and put it into a level 2 hot list.

    if(!dnAggregateInfo( pThisElement, MAX_LEVEL_2_HOT_DNTS, &pTemp)) {
        // Something failed in the aggregation.  Bail.  dnAggregate freed the
        // list we passed in.
        return;
    }

    pThisElement = pTemp;
    // Finally, add to the level 2 hot list.
    EnterCriticalSection(&csDNReadLevel2List);
    __try {
        pThisElement->pNext = Level2HotList;
#if DBG
        {
            // Someone is mangling the pointer in the hotlist by incing or
            // decing it.  Let's try to catch them early.
            DNT_HOT_LIST *pTempDbg = Level2HotList;

            while(pTempDbg) {
                Assert(!(((DWORD_PTR)pTempDbg) & 3));
                pTempDbg = pTempDbg->pNext;
            }
        }
#endif

        // bImmediatelyAggregateLevel2List starts out globally TRUE so that the
        // first time someone comes through here, it lets the first
        // hot list blow right through here to get made into a global list of
        // DNTs to cache, since we don't have one already.
        if(bImmediatelyAggregateLevel2List ||
           (Level2HotListCount == MAX_LEVEL_2_HOT_LIST_LENGTH)) {

            bImmediatelyAggregateLevel2List = FALSE;
            Level2HotListCount = 0;
            Level2HotList = NULL;
        }
        else {
            Level2HotList = pThisElement;
            pThisElement = NULL;
            Level2HotListCount++;
        }
    }
    __finally {
        LeaveCriticalSection(&csDNReadLevel2List);
    }


    if(!pThisElement) {
        return;
    }

    // Boy, are we lucky.  Aggregate the level 2 hot list and replace the global
    // dnt list.
    // First, find the max size we'll need.

    DPRINT2(4,"Level 2 aggregate, 1- %d, 2- %d\n", Level1HotListCount,
            Level2HotListCount);

    // If pThisElement is non-null, we have been elected to aggregate the info
    // in a level 1 hot list and put it into a level 2 hot list.
    pTemp = NULL;
#if DBG
    {
        // Someone is mangling the pointer in the hotlist by incing or
        // decing it.  Let's try to catch them early.
        DNT_HOT_LIST *pTempDbg = pThisElement;

        while(pTempDbg) {
            Assert(!(((DWORD_PTR)pTempDbg) & 3));
            pTempDbg = pTempDbg->pNext;
        }
    }
#endif
    if(!dnAggregateInfo( pThisElement, MAX_GLOBAL_DNTS, &pTemp)) {
        // Something failed in the aggregation.  Bail.  dnAggregate freed the
        // list we passed in.
        return;
    }

    pThisElement = pTemp;
    Size = pThisElement->cData;

    // OK, we now have aggregated the data.  It's sorted by DNT.
    // Prepare a new global DNT list.
    // NOTE!!! the global DNT list MUST remain sorted by DNT.
    pNewDNReadCacheDNTs = malloc(MAX_GLOBAL_DNTS * sizeof(DWORD));
    if(!pNewDNReadCacheDNTs) {
        free(pTemp->pData);
        pTemp->pData = NULL;
        free(pTemp);
        pTemp = NULL;
        //
        return;
    }

    for(i=0;i<Size;i++) {
        pNewDNReadCacheDNTs[i] = pThisElement->pData[i].DNT;
    }

    free(pThisElement->pData);
    free(pThisElement);

    // Next, if we don't have enought DNTs in the list, get enough from the
    // current list to get to MAX_GLOBAL_DNTS.
    if(Size < MAX_GLOBAL_DNTS) {
        // Yep, we don't have enough.  Steal some from the current global DNT
        // list.  Remember that that list is protected by a critical section.
        EnterCriticalSection(&csDNReadGlobalCache);
        __try {
            DWORD begin, end, middle;
            BOOL bFound;

            i=0;
            while((i<cGlobalDNTReadCacheDNTs) && (Size < MAX_GLOBAL_DNTS)) {
                begin = 0;
                end = Size;
                middle = (begin + end) / 2;
                bFound = TRUE;
                while(bFound && (pNewDNReadCacheDNTs[middle] !=
                                 pGlobalDNReadCacheDNTs[i])) {
                    if(pNewDNReadCacheDNTs[middle] >
                       pGlobalDNReadCacheDNTs[i]) {
                        end = middle;
                    }
                    else {
                        begin = middle;
                    }
                    if(middle == (begin + end) / 2) {
                        bFound = FALSE;
                        if(pNewDNReadCacheDNTs[middle] <
                           pGlobalDNReadCacheDNTs[i]) {
                            middle++;
                        }
                    }
                    else {
                        middle = (begin + end)/2;
                    }
                }
                if(!bFound) {
                    // Insert this.
                    if(middle < Size) {
                        memmove(&pNewDNReadCacheDNTs[middle + 1],
                                &pNewDNReadCacheDNTs[middle],
                                (Size - middle) * sizeof(DWORD));
                    }
                    StaleCount++;
                    Size++;
                    pNewDNReadCacheDNTs[middle] = pGlobalDNReadCacheDNTs[i];
                }
                i++;
            }
        }
        __finally {
            LeaveCriticalSection(&csDNReadGlobalCache);
        }

        pDNTs = realloc(pNewDNReadCacheDNTs, Size * sizeof(DWORD));
        if (!pDNTs) {
            free(pNewDNReadCacheDNTs);
            return;
        }
        pNewDNReadCacheDNTs = pDNTs;
    }

    DPRINT2(4,"New cache list has %d hot items, %d stale items.\n",
            Size - StaleCount, StaleCount);


    EnterCriticalSection(&csDNReadGlobalCache);
    __try {

        cGlobalDNTReadCacheDNTs = Size;
        if(pGlobalDNReadCacheDNTs) {
            free(pGlobalDNReadCacheDNTs);
        }

        pGlobalDNReadCacheDNTs = pNewDNReadCacheDNTs;
    }
    __finally {
        LeaveCriticalSection(&csDNReadGlobalCache);
    }

    // compute the register skip count based on the rate at which hot lists are
    // being registered and the current skip count
    dtickRebuild            = GetTickCount() - gtickLastRebuild;
    dtickRebuild            = dtickRebuild ? dtickRebuild : 1;

    cRegisterHotListSkip    = (GetPLS()->cRegisterHotListSkip + 1) *
                              DNREADREBUILDDELAYMIN / dtickRebuild;
    cRegisterHotListSkip    = cRegisterHotListSkip ? cRegisterHotListSkip - 1 : 0;

    for ( iProc = 0; iProc < GetProcessorCount(); iProc++ ) {
        PLS* ppls;
        ppls = GetSpecificPLS( iProc );
        if (ppls->cRegisterHotListSkip != cRegisterHotListSkip ) {
            ppls->cRegisterHotListSkip = cRegisterHotListSkip;
        }
    }

    // reset our rebuild time to the current time.  we keep two separate times
    // because we immediately update gLastDNReadDNTUpdate to prevent multiple
    // threads from trying to aggregate the lists
    gtickLastRebuild = gLastDNReadDNTUpdate = GetTickCount();

    // Mark to reload the dnread cache.
    InsertInTaskQueue(TQ_ReloadDNReadCache, NULL, 0);
}

VOID
dbResetLocalDNReadCache (
        THSTATE *pTHS,
        BOOL fForceClear
        )
/*++
  This routine clears the local dnread cache if it is suspect.  Also, if told to
  do so, it clears it no matter what.
--*/
{
    DWORD i, j;
    DWORD SequenceNumber;

    if(fForceClear) {
        // They want the cache cleared no matter what.  Use the invalid sequence
        // number.
        SequenceNumber = DNReadOriginSequenceInvalid;
    }
    else {
        if (!SyncTryEnterBinaryLockAsGroup1(&blDNReadInvalidateData)) {
            // Some one is currently trying to commit an invalidating
            // transaction.
            SequenceNumber = DNReadOriginSequenceInvalid;
        }
        else {
            // OK, noone is trying to commit a transaction, so find out what
            // the current sequence is.
            SequenceNumber = gDNReadLastInvalidateSequence;
            SyncLeaveBinaryLockAsGroup1(&blDNReadInvalidateData);
        }
    }
    
    // We now have the sequence number that should be on the local dnread
    // cache.  If the sequence number already on it equals the one we just
    // calculated, then no one has made any attempt to commit a transaction that
    // invalidated the dnread cache since this local dnread cache was created.
    // The one exception to that is if we calculated that this dnread cache
    // should have a invalid sequence number (indicating we don't really know it's
    // relation to transactions in other threads), then we're going to clear out
    // the cache.

    if(SequenceNumber != DNReadOriginSequenceInvalid &&
       pTHS->DNReadOriginSequence == SequenceNumber) {
        // Yep, the local cache is still good.
        return;
    }

    // If the cache's current sequence number is uninit then we know that the
    // cache is already empty because it has never been used

    if (pTHS->DNReadOriginSequence == DNReadOriginSequenceUninit) {
#ifdef DBG
        DWORD dwCount;
        for(dwCount=0;dwCount<LOCALDNREADCACHE_BUCKET_NUM;dwCount++) {
            Assert(pTHS->LocalDNReadCache.bucket[dwCount].rgDNT[0] == 0);
        }
#endif

    // Free all the name structures pointed to in the local dnread cache.

    } else {
        for(i=0;i<LOCALDNREADCACHE_BUCKET_NUM;i++) {
            for(j=0;pTHS->LocalDNReadCache.bucket[i].rgDNT[j] != 0 && j<LOCALDNREADCACHE_SLOT_NUM;j++) {
                THFreeOrg(pTHS, pTHS->LocalDNReadCache.bucket[i].slot[j].pName);
                pTHS->LocalDNReadCache.bucket[i].rgDNT[j] = 0;
            }
        }
    }

    // Set the new sequence number for the cache

    pTHS->DNReadOriginSequence = SequenceNumber;
}


VOID
dbReleaseDNReadCache(
        GLOBALDNREADCACHE *pCache
        )
/*++
  Description:
      Given a globaldnread cache structure, drop the refcount by one.  If the
      refcount drops to 0, free the structure.
--*/
{
    DWORD i, retval;
    GLOBALDNREADCACHESLOT *pData;

    if(!pCache) {
        return;
    }

    // Trying to track someone who is mangling a refcount.  Assume
    // no more than 1000 concurrent users of a DNReadCache.
    // This will trigger if we are inc'ing a value that is really a
    // pointer, which is the bug we're looking for.
    // Also, we shouldn't be releasing when the count is already at 0
    Assert(pCache->refCount);
    Assert(pCache->refCount < 1000);
    retval = InterlockedDecrement(&pCache->refCount);

    // If the interlocked decrement dropped this to 0, we must be the last ones
    // holding this globaldnread cache.  Free it.
    if(!retval) {
        Assert(!(pCache->refCount));
        // Since this is the last step to freeing this, it had better not be the
        // one still on the anchor.
        Assert(pCache != gAnchor.MainGlobal_DNReadCache);
        DPRINT1(3, "Freeing dnread cache 0x%X\n",pCache);
        if(pCache->pData) {
            pData = pCache->pData;
            for(i=0;i<pCache->count;i++) {
                free(pData[i].name.pAncestors);
                free(pData[i].name.tag.pRdn);
            }
            free(pData);
        }
        if (pCache->pSDHashTable) {
            PSDCACHE_ENTRY pTmp;
            for (i = 0; i < pCache->sdHashTableSize; i++) {
                while (pTmp = pCache->pSDHashTable[i]) {
                    pCache->pSDHashTable[i] = pTmp->pNext;
                    free(pTmp);
                }
            }
            free(pCache->pSDHashTable);
        }
        free(pCache);
    }

    return;
}

void
dbResetGlobalDNReadCache (
        THSTATE *pTHS
        )
/*++
  Description:
      Called from DBTransIn, and DBTransIn ONLY!!!
      Callers should already have acquired rwlGlobalDNReadCache as a reader.
      See the description in DBTransIn and dbReplaceCacheInAnchor for why this
      is the case.


      Get a new dnread cache (or validate that the one we have is still the most
      current).

--*/
{
    GLOBALDNREADCACHE *pCache = NULL;

    // Get the new global dnread cache

    if(pTHS->Global_DNReadCache != gAnchor.MainGlobal_DNReadCache) {
        // We need to get this new cache.  Remember the cache we already
        // have so we can release it (i.e. drop the refcount, maybe free it,
        // etc.)
        pCache = pTHS->Global_DNReadCache;

        // Grab the new cache.
        pTHS->Global_DNReadCache = gAnchor.MainGlobal_DNReadCache;

        if(pTHS->Global_DNReadCache) {
            // OK, we have a new global dnread cache.  Increment the
            // refcount before we leave the critical section to avoid having
            // it disappear beneath us.


            // DEBUG: Trying to track someone who is mangling a refcount.
            // Assume no more than 1000 concurrent users of a
            // Global_DNReadCache.
            // This will trigger if we are inc'ing a value that is
            // really a  pointer, which is the bug we're looking for.
            Assert(pTHS->Global_DNReadCache->refCount);
            Assert(pTHS->Global_DNReadCache->refCount < 1000);

            // Interlock the increment since the interlocked decrement is
            // not done inside the gAnchor.CSUpdate critical section.
            InterlockedIncrement(&pTHS->Global_DNReadCache->refCount);
        }
    }

    // Now, free the old cache.
    if(pCache) {
        dbReleaseDNReadCache(pCache);
    }

    // Free any old cache support structures.
    if(pTHS->pGlobalCacheHits) {
        THFreeOrg(pTHS, pTHS->pGlobalCacheHits);
        pTHS->cGlobalCacheHits = 0;
        pTHS->pGlobalCacheHits = NULL;
    }

    if(!pTHS->Global_DNReadCache) {
        return;
    }

    // Build new cache support structures.
    if(pTHS->Global_DNReadCache->count) {
        // Create the parallel count structure.
        pTHS->cGlobalCacheHits = pTHS->Global_DNReadCache->count;
        pTHS->pGlobalCacheHits =
            THAllocOrg(pTHS, pTHS->cGlobalCacheHits * sizeof(DWORD));
        if ( pTHS->pGlobalCacheHits == NULL ) {
            pTHS->cGlobalCacheHits = 0;
        }
    }

    return;
}


VOID
dbReplaceCacheInAnchor(
        GLOBALDNREADCACHE *pCache
        )
/*
   Description:
       Replace the dnread cache in the anchor.  To do this, we must take the
       critical section guarding updating the anchor.

       Also, if we are putting a new cache (i.e. pCache != NULL) into the
       anchor, we must grab the GlobalDNReadCache resource in an exclusive
       fashion.  This avoids a problem where someone can begin a transaction and
       then have the global dnread cache in the anchor change.  If they then
       grab the new dnread cache, they could run into cache coherency problems
       where the new cache has data that doesn't agree with the jet transacted
       view. (see DBTransIn for more discussion of this, and the other use of
       the global dnread cache resource).

       This routine should be called with a non-NULL pCache only from the task
       queue thread that has built a new global dnread cache.  It can also be
       called from a normal worker thread that is committing a change that has
       caused a cache invalidation when it notices that the global dnread cache
       it is using is not the one currently on the anchor.

  Parameters:
      pCache - pointer to the new cache to put into the anchor.  If non-NULL,
          should already have a refcount of 1, representing the anchors use of
          the cache.

  Return values:
      None.
--*/
{
    size_t iProc;
    GLOBALDNREADCACHE *pOldCache;

    for (iProc = 0; iProc < GetProcessorCount(); iProc++) {
        SyncEnterRWLockAsWriter(&GetSpecificPLS(iProc)->rwlGlobalDNReadCache);
    }
    __try { // finally to release resource.
        pOldCache = gAnchor.MainGlobal_DNReadCache;
        gAnchor.MainGlobal_DNReadCache = pCache;
        Assert(!pCache || pCache->refCount == 1);
    }
    __finally {
        for (iProc = 0; iProc < GetProcessorCount(); iProc++) {
            SyncLeaveRWLockAsWriter(&GetSpecificPLS(iProc)->rwlGlobalDNReadCache);
        }
    }

    // NOTE: it is important to remove the cache from the anchor
    // before releasing it.  Once a cache has been removed from the
    // anchor, it's ref count will never increase.  Therefore,
    // whenever the count reaches 0, it will be safe to delete the
    // cache.
    if(pOldCache) {
        Assert(pOldCache->refCount);
        dbReleaseDNReadCache(pOldCache);
    }

}

void
dbReleaseGlobalDNReadCache (
        THSTATE *pTHS
        )
{
    GLOBALDNREADCACHE *pOldCache;

    pOldCache = pTHS->Global_DNReadCache;
    if(pTHS->pGlobalCacheHits) {
        THFreeOrg(pTHS, pTHS->pGlobalCacheHits);
    }
    pTHS->cGlobalCacheHits = 0;
    pTHS->pGlobalCacheHits = NULL;
    pTHS->Global_DNReadCache = NULL;

    if(pOldCache) {
        dbReleaseDNReadCache(pOldCache);
    }

    return;
}
void
dnReadLeaveInvalidators (
        )
/*++
  Description:
     Bookkeeping for a thread leaving the list of active invalidators.
--*/
{
    // Bump invalidate sequence by 2 so that we never see 0 again
    InterlockedExchangeAdd(&gDNReadLastInvalidateSequence, 2);

    // Leave the invalidator group
    SyncLeaveBinaryLockAsGroup2(&blDNReadInvalidateData);
}
void
dnReadEnterInvalidators (
        )
/*++
  Description:
     Bookkeeping for a thread entering the list of active invalidators.
     --*/
{
    // Enter the invalidator group
    SyncEnterBinaryLockAsGroup2(&blDNReadInvalidateData);

    // Bump invalidate sequence by 2 so that we never see 0 again
    InterlockedExchangeAdd(&gDNReadLastInvalidateSequence, 2);
}

void
dnReadPostProcessTransactionalData (
        THSTATE *pTHS,
        BOOL fCommit,
        BOOL fCommitted
        )
/*++

  This routine is called by dbtransout.

  If we drop to transaction level 0, this routine sweeps through the local and
  global dn read cache and produces a list of the hottest DNTs (i.e. the highest
  hit count associated with them in the dnread cache).  No more than
  MAX_LEVEL_1_HOT_DNTS are kept.  This list is then passed off to
  dnRegisterHotDNTs.

--*/
{
    Assert(VALID_THSTATE(pTHS));

    if(!fCommitted) {
        // We're aborting.  The local cache is suspect, so clear it out.
        dbResetLocalDNReadCache(pTHS, TRUE);

        // NOTE: we're keeping our global dnread cache, not picking up a new
        // copy.
        if(pTHS->cGlobalCacheHits) {
            memset(pTHS->pGlobalCacheHits, 0,
                   pTHS->cGlobalCacheHits * sizeof(DWORD));
        }
    }
    else if (pTHS->transactionlevel == 0 ) {
        // only register a hot list if we are in the run state and even then
        // only if we are not exceeding the maximum registration rate
        PLS* ppls;
        Assert(fCommitted);
        ppls = GetPLS();
        if(DsaIsRunning() &&
           ppls->cRegisterHotListSkipped++ >= ppls->cRegisterHotListSkip) {
            DWORD               i,j,k;
            DNT_COUNT_STRUCT    DNTs[MAX_LEVEL_1_HOT_DNTS] = { 0 };
            DWORD               localCount = 0;

            // reset our skip count
            ppls->cRegisterHotListSkipped = 0;

            // OK, we're committing to transaction level 0.  Go through the
            // local dnread cache and add them to the list of objects we would
            // like added to the global dn read cache.

            // NOTE: the global dnread cache is built using the task queue.  If
            // we are not DSAIsRunning(), then the task queue isn't even here,
            // so don't bother doing any of this.
            for(i=0; i<LOCALDNREADCACHE_BUCKET_NUM;i++) {
                for(j=0;pTHS->LocalDNReadCache.bucket[i].rgDNT[j] != 0 && j<LOCALDNREADCACHE_SLOT_NUM;j++) {
                    if(pTHS->LocalDNReadCache.bucket[i].rgDNT[j] != INVALIDDNT) {
                        k=0;
                        while(k < MAX_LEVEL_1_HOT_DNTS &&
                              DNTs[k].count > pTHS->LocalDNReadCache.bucket[i].slot[j].hitCount) {
                            k++;
                        }
                        if(k<MAX_LEVEL_1_HOT_DNTS) {
                            if(!DNTs[MAX_LEVEL_1_HOT_DNTS - 1].DNT) {
                                // We are not going to be dropping a DNT off
                                // the end of the list, so up the count by
                                // 1. I.E. we are adding a DNT to the list,
                                // not replacing one.
                                localCount++;
                            }
                            memmove(&DNTs[k + 1], &DNTs[k],
                                    ((MAX_LEVEL_1_HOT_DNTS - k - 1 ) *
                                     sizeof(DNT_COUNT_STRUCT)));
                            DNTs[k].DNT = pTHS->LocalDNReadCache.bucket[i].rgDNT[j];
                            DNTs[k].count = pTHS->LocalDNReadCache.bucket[i].slot[j].hitCount;
                            pTHS->LocalDNReadCache.bucket[i].slot[j].hitCount = 1;
                        }
                    }
                }
            }

            // finally, scan through the hit count of the global structure to
            // see how hot they were.
            for(i=0;i<pTHS->cGlobalCacheHits;i++) {
                if(pTHS->pGlobalCacheHits[i] >
                   DNTs[MAX_LEVEL_1_HOT_DNTS - 1].count) {

                    // Yep, this is a hot one.
                    k = MAX_LEVEL_1_HOT_DNTS - 1;

                    while(k &&
                          DNTs[k].count <
                          pTHS->pGlobalCacheHits[i])
                        k--;

                    if(!DNTs[MAX_LEVEL_1_HOT_DNTS - 1].DNT) {
                        // We are not going to be dropping a DNT off the end
                        // of the list, so up the count by 1.  I.E. we are
                        // adding a DNT to the list, not replacing one.
                        localCount++;
                    }
                    memmove(&DNTs[k + 1], &DNTs[k],
                            ((MAX_LEVEL_1_HOT_DNTS - k - 1 ) *
                             sizeof(DNT_COUNT_STRUCT)));

                    DNTs[k].count = pTHS->pGlobalCacheHits[i];
                    DNTs[k].DNT = pTHS->Global_DNReadCache->pData[i].name.DNT;
                }
            }

            dnRegisterHotList(localCount,DNTs);
        }

        // NOTE: we're keeping our global dnread cache, not picking up a new
        // copy. We are also keeping our local dnread cache.
        if(pTHS->cGlobalCacheHits) {
            memset(pTHS->pGlobalCacheHits, 0,
                   pTHS->cGlobalCacheHits * sizeof(DWORD));
        }

        if(pTHS->fDidInvalidate) {
            // In preprocessing, we should have verified that the global dnread
            // cache this thread is using is the same as the one on the anchor,
            // or we should have nulled the one on the anchor.  Further, if we
            // nulled it, then the gDNReadLastInvalidateSequence and
            // gDNReadNumCurrentInvalidators should have kept us from getting a
            // new global dnread cache in the anchor.  Assert this.
            // Note, we are looking at gAnchor.MainGlobal_DNReadCache outside
            // the csUpdate critsec.  Thus, it is conceivable that inbetween the
            // two clauses of the OR in the assert, it's value could change,
            // doing weird things to the assert. Not bloody likely, it it?
            Assert(!gAnchor.MainGlobal_DNReadCache ||
                   (pTHS->Global_DNReadCache==gAnchor.MainGlobal_DNReadCache));


            // Write to the global variables that holds the sequence info of the
            // last commit that was on a thread that invalidated the cache. The
            // global dnread cache manager uses this information to help
            // consistency. The critical section is used to keep the
            // last invalidate time in sync with the last invalidate sequence.
            dnReadLeaveInvalidators();

            // Reset the flag
            pTHS->fDidInvalidate = FALSE;
        }
    }

    return;
}
BOOL
dnReadPreProcessTransactionalData (
        BOOL fCommit
        )
/*++

  This routine is called by dbtransout.

  If we drop to transaction level 0, and we are going to commit, check to see if
  we made a change that invalidates the dnread cache.  If so, mark that so the
  world knows about it.
--*/
{
    THSTATE       *pTHS = pTHStls;

    Assert(VALID_THSTATE(pTHS));
    Assert(pTHS->transactionlevel);

    if(fCommit && pTHS->transactionlevel <= 1 ) {
        Assert(pTHS->transactionlevel == 1);
        // OK, we're committing to transaction level 0.

#if DBG
        if(gfExhaustivelyValidateDNReadCache) {
            dbExhaustivelyValidateDNReadCache(pTHS);
        }
#endif

        if(pTHS->fDidInvalidate) {
            // Write to the global variable that holds the time of the
            // last commit that was on a thread that invalidated the cache. The
            // global dnread cache manager uses this information to help
            // consistency.
            dnReadEnterInvalidators();

            // Since we just inc'ed the invalidate sequence and the
            // currentinvalidators count, we can be assured that no new global
            // dnread cache will be created until after we have post processed
            // the dnread cache stuff and dropped the invalidator count back to
            // 0. However, someone may have already built a new global dnread
            // cache while we had our transaction open.  Therefore, the thing we
            // invalidated in this threads global dnread cache isn't invalidated
            // in that other global dnread cache.  So, we're going to throw away
            // any new global dnread cache.  Any thread that already has a
            // handle to this new dnread cache is OK since it's transaction is
            // already open.  What we need to do is prevent transactions that
            // open after the one we are in picking up that potentially invalid
            // dnread cache.  Note that that other cache may have invalidations
            // that we don't have, so the only safe thing to do is to throw away
            // both (i.e. decouple both from the gAnchor and let the refounts
            // clear them up).

            if(pTHS->Global_DNReadCache != gAnchor.MainGlobal_DNReadCache) {
                DPRINT(3, "Hey, we invalidated and got a new dnread cache\n");

                // Switch the universe to use the NO global cache
                dbReplaceCacheInAnchor(NULL);
            }
        }
    }

    return TRUE;
}

/* dbFlushDNReadCache
 *
 * Purges a specific item from the DNRead cache, and from the global cache,
 * if necessary.
 *
 * INPUT:
 *   DNT - the DNT of the item to be flushed from the cache
 */
void
dbFlushDNReadCache (
        IN DBPOS *pDB,
        IN ULONG tag
        )
{
    THSTATE *pTHS = pTHStls;
    GLOBALDNREADCACHESLOT *pData;
    DWORD i;
    DWORD j;

    // Remember that we attempted to invalidate something.
    //
    // Except when a new object is created. From 383459...
    // Entries in the DNread cache are invalidated whenever certain
    // attributes on the objects are modified.  It looks like what's
    // happening is that setting those attributes on an object
    // currently being adding causes the object  to be marked as
    // invalidated.  When invalidations occur while the global cache
    // is being rebuilt, the newly built cache is suspect and has to
    // be abandoned.  We need to avoid triggering the invalidation logic
    // for objects being added.  This is safe because those objects are
    // not yet globally visible and hence could not have appeared in any
    // cache other than the current thread's, and hence do not need to be
    // invalidated.
    //
    // The fix is to remember the last, newly created row's DNT and
    // avoid triggering the invalidation logic by not setting
    // fDidInvalidate.
    if (pDB->NewlyCreatedDNT != tag) {
        pTHS->fDidInvalidate = TRUE;
    }

    // Look for the object in the local cache
    i = tag % LOCALDNREADCACHE_BUCKET_NUM;
    for(j=0;pTHS->LocalDNReadCache.bucket[i].rgDNT[j] != 0 && j<LOCALDNREADCACHE_SLOT_NUM;j++) {
        if(pTHS->LocalDNReadCache.bucket[i].rgDNT[j] == tag) {

            // Set the DNT to a bad but non-zero DNT.  We use this info to
            // help short circuit scans through the slots (i.e. if we hit a
            // slot with DNT==0, then there are no more full slots after
            // it). Since there might be a full slot after this, we can't
            // leave it marked as 0.
            pTHS->LocalDNReadCache.bucket[i].rgDNT[j] = INVALIDDNT;

            break;
        }
    }

    // Even if it was in the local cache, we need to look in the Global (there
    // are a few weird cases where we can end up with an object in both the
    // local and global dnread caches).
    // PERFORMANCE: Could do a binary search here.
    if(pTHS->Global_DNReadCache && pTHS->Global_DNReadCache->pData) {
        pData = pTHS->Global_DNReadCache->pData;
        for(i=0;i<pTHS->Global_DNReadCache->count;i++) {
            if(pData[i].name.DNT == tag) {
                // found it
                pData[i].valid = FALSE;

                // Newly created row should not be in the global dnread cache
                Assert(pDB->NewlyCreatedDNT != tag
                       && "Newly created row should not be in the global dnread cache");

                break;
            }
        }
    }
}

BOOL
dnGetCacheByDNT(
        DBPOS *pDB,
        DWORD tag,
        d_memname **ppname
        )
/*++

  Look in the dnread cache for the specified tag (DNT).  Both the global and
  local dnread cachre are searched.  If the DNT is found, a pointer to the
  memname structure for that DNT is returned, along with a return value of TRUE.
  If it is not found, FALSE is returned.
  If it is found, a count associated with the DNT is incremented.

--*/
{
    GLOBALDNREADCACHESLOT *pData;
    DWORD i, j;
    BOOL  bFound;
    DWORD begin, end, middle;
    THSTATE *pTHS = pDB->pTHS;

    Assert(pTHS->transactionlevel);
    INC_FIND_BY_DNT;

    Assert(ppname);
    (*ppname)=NULL;

    if(!tag) {
        return FALSE;
    }

    PERFINC(pcNameCacheTry);
    // First, look in the global cache.

    if(pTHS->Global_DNReadCache && pTHS->Global_DNReadCache->pData) {
        pData = pTHS->Global_DNReadCache->pData;

        // Look up the correct node in the pData array. Since pData is
        // sorted by DNT, use a binary search.
        begin = 0;
        end = pTHS->Global_DNReadCache->count;
        middle = (begin + end) / 2;
        bFound = TRUE;
        while(bFound && (pData[middle].name.DNT != tag)) {
            if(pData[middle].name.DNT > tag) {
                end = middle;
            }
            else {
                begin = middle;
            }
            if(middle == (begin + end) / 2) {
                bFound = FALSE;
            }
            else  {
                middle = (begin + end) / 2;
            }

        }
        if(bFound) {
            // found it
            if(pData[middle].valid) {
                *ppname = &pData[middle].name;
                PERFINC(pcNameCacheHit);
                if(pTHS->cGlobalCacheHits > middle) {
                    pTHS->pGlobalCacheHits[middle] += 1;
                }
                return TRUE;
            }
        }
    }

    // Didn't find it in the global cache (or it was invalid).


    // This loop stops after either looking at all the slots or finding a slot
    // with no DNT.  We prefill all slots with a 0 DNT, and if we invalidate a
    // slot, we fill the DNT with INVALIDDNT, so if we hit a slot with DNT ==
    // 0, then we know there are no more values after it.
    i = tag % LOCALDNREADCACHE_BUCKET_NUM;
    for(j=0;pTHS->LocalDNReadCache.bucket[i].rgDNT[j] != 0 && j<LOCALDNREADCACHE_SLOT_NUM;j++) {
        if(pTHS->LocalDNReadCache.bucket[i].rgDNT[j] == tag) {

            PERFINC(pcNameCacheHit);
            *ppname = pTHS->LocalDNReadCache.bucket[i].slot[j].pName;
            pTHS->LocalDNReadCache.bucket[i].slot[j].hitCount++;

            // if we just touched the next replacement victim then
            // change the replacement pointer to skip that slot.  this
            // will hopefully result in the next slot pointing to a
            // cold entry in the cache
            if (pTHS->LocalDNReadCache.nextSlot[i] == j) {
                pTHS->LocalDNReadCache.nextSlot[i] = (j + 1) % LOCALDNREADCACHE_SLOT_NUM;
            }
            
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
dnGetCacheByPDNTRdn (
        DBPOS *pDB,
        DWORD parenttag,
        DWORD cbRDN,
        WCHAR *pRDN,
        ATTRTYP rdnType,
        d_memname **ppname)
/*++

  Look in the dnread cache for the specified combination of parenttag, RDN, and
  rdn length.  Both the global and local dnread cachre are searched.  If the
  object is found, a pointer to the memname structure for that object is
  returned, along with a return value of TRUE.  If it is not found, FALSE is
  returned.  If it is found, a count associated with the object is incremented.

  NOTE:
  The local and global dn read caches are optimized for looking up DNTs.  This
  routine does a linear scan through the caches to find the objects.

--*/
{
    DWORD i, j;
    GLOBALDNREADCACHESLOT *pData;
    THSTATE *pTHS = pDB->pTHS;
    DWORD dwHashRDN;

    INC_FIND_BY_PDNT_RDN;

    Assert(pTHS->transactionlevel);

    PERFINC(pcNameCacheTry);
    Assert(ppname);
    (*ppname)=NULL;

    if(!parenttag) {
        return FALSE;
    }

    dwHashRDN = DSStrToHashKey (pDB->pTHS, pRDN, cbRDN / sizeof (WCHAR));

    // First, look in the global cache.
    if(pTHS->Global_DNReadCache && pTHS->Global_DNReadCache->pData) {
        pData = pTHS->Global_DNReadCache->pData;
        for(i=0;i<pTHS->Global_DNReadCache->count;i++) {
            if((pData[i].dwHashKey == dwHashRDN) &&
               (pData[i].name.tag.PDNT == parenttag) &&
               (pData[i].name.tag.rdnType == rdnType) &&
               (gDBSyntax[SYNTAX_UNICODE_TYPE].Eval(
                       pDB,
                       FI_CHOICE_EQUALITY,
                       cbRDN,
                       (PUCHAR)pRDN,
                       pData[i].name.tag.cbRdn,
                       (PUCHAR)pData[i].name.tag.pRdn))) {

                // found it
                if(pData[i].valid) {
                    PERFINC(pcNameCacheHit);
                    *ppname = &pData[i].name;
                    if(pTHS->cGlobalCacheHits > i) {
                        pTHS->pGlobalCacheHits[i] += 1;
                    }
                    return TRUE;
                }
                // It's invalid.  Break out of the while loop, since it still
                // might in the local.
                break;
            }
        }
    }
    // Didn't find it in the global cache.

    // This loop stops after either looking at all the slots or finding a slot
    // with no DNT.  We prefill all slots with a 0 DNT, and if we invalidate a
    // slot, we fill the DNT with INVALIDDNT, so if we hit a slot with DNT ==
    // 0, then we know there are no more values after it.
    for(i=0; i<LOCALDNREADCACHE_BUCKET_NUM;i++) {
        for(j=0;pTHS->LocalDNReadCache.bucket[i].rgDNT[j] != 0 && j<LOCALDNREADCACHE_SLOT_NUM;j++) {
            if(pTHS->LocalDNReadCache.bucket[i].rgdwHashKey[j] == dwHashRDN &&
                pTHS->LocalDNReadCache.bucket[i].rgDNT[j] != INVALIDDNT &&
                pTHS->LocalDNReadCache.bucket[i].slot[j].pName->tag.PDNT == parenttag &&
                pTHS->LocalDNReadCache.bucket[i].slot[j].pName->tag.rdnType == rdnType &&
                gDBSyntax[SYNTAX_UNICODE_TYPE].Eval(
                    pDB,
                    FI_CHOICE_EQUALITY,
                    cbRDN,
                    (PUCHAR)pRDN,
                    pTHS->LocalDNReadCache.bucket[i].slot[j].pName->tag.cbRdn,
                    (PUCHAR)pTHS->LocalDNReadCache.bucket[i].slot[j].pName->tag.pRdn)) {

                PERFINC(pcNameCacheHit);
                *ppname = pTHS->LocalDNReadCache.bucket[i].slot[j].pName;
                pTHS->LocalDNReadCache.bucket[i].slot[j].hitCount++;

                // if we just touched the next replacement victim then
                // change the replacement pointer to skip that slot.  this
                // will hopefully result in the next slot pointing to a
                // cold entry in the cache
                if (pTHS->LocalDNReadCache.nextSlot[i] == j) {
                    pTHS->LocalDNReadCache.nextSlot[i] = (j + 1) % LOCALDNREADCACHE_SLOT_NUM;
                }
                
                return TRUE;
            }
        }
    }

    return FALSE;
}


BOOL
dnGetCacheByGuid (
        DBPOS *pDB,
        GUID *pGuid,
        d_memname **ppname)
/*++

  Look in the dnread cache for an object with the specified guid.  Both the
  global and local dnread cachre are searched.  If the
  object is found, a pointer to the memname structure for that object is
  returned, along with a return value of TRUE.  If it is not found, FALSE is
  returned.  If it is found, a count associated with the object is incremented.


  NOTE:
  The local and global dn read caches are optimized for looking up DNTs.  This
  routine does a linear scan through the caches to find the objects.

--*/
{
    DWORD i, j;
    GLOBALDNREADCACHESLOT *pData;
    THSTATE *pTHS = pDB->pTHS;
    INC_FIND_BY_GUID;

    Assert(pTHS->transactionlevel);

    PERFINC(pcNameCacheTry);
    Assert(ppname);
    (*ppname)=NULL;

    if(!pGuid) {
        return FALSE;
    }

    // First, look in the global cache.
    if(pTHS->Global_DNReadCache && pTHS->Global_DNReadCache->pData) {
        pData = pTHS->Global_DNReadCache->pData;
        for(i=0;i<pTHS->Global_DNReadCache->count;i++) {
            if(!(memcmp(pGuid, &pData[i].name.Guid, sizeof(GUID)))) {

                // found it
                if(pData[i].valid) {
                    *ppname = &pData[i].name;
                    PERFINC(pcNameCacheHit);
                    if(pTHS->cGlobalCacheHits > i) {
                        pTHS->pGlobalCacheHits[i] += 1;
                    }
                    return TRUE;
                }
                // It's invalid.  Break out of the while loop, since it still
                // might in the local.
                break;
            }
        }
    }

    // This loop stops after either looking at all the slots or finding a slot
    // with no DNT.  We prefill all slots with a 0 DNT, and if we invalidate a
    // slot, we fill the DNT with INVALIDDNT, so if we hit a slot with DNT ==
    // 0, then we know there are no more values after it.
    for(i=0; i<LOCALDNREADCACHE_BUCKET_NUM;i++) {
        for(j=0;pTHS->LocalDNReadCache.bucket[i].rgDNT[j] != 0 && j<LOCALDNREADCACHE_SLOT_NUM;j++) {
            if(pTHS->LocalDNReadCache.bucket[i].rgDNT[j] != INVALIDDNT &&
               !memcmp(&(pTHS->LocalDNReadCache.bucket[i].slot[j].pName->Guid), pGuid,sizeof(GUID))) {

                PERFINC(pcNameCacheHit);
                *ppname = pTHS->LocalDNReadCache.bucket[i].slot[j].pName;
                pTHS->LocalDNReadCache.bucket[i].slot[j].hitCount++;

                // if we just touched the next replacement victim then
                // change the replacement pointer to skip that slot.  this
                // will hopefully result in the next slot pointing to a
                // cold entry in the cache
                if (pTHS->LocalDNReadCache.nextSlot[i] == j) {
                    pTHS->LocalDNReadCache.nextSlot[i] = (j + 1) % LOCALDNREADCACHE_SLOT_NUM;
                }
                
                return TRUE;
            }
        }
    }

    return FALSE;
}

JET_RETRIEVECOLUMN dnreadColumnInfoTemplate[] = {
    { 0, 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 0, 0, 0, 0, 0, 1, 0, 0}
    };

d_memname *
dnCreateMemname(
        IN DBPOS * pDB,
        IN JET_TABLEID tblid
        )
/*++

Routine Description:

    Create a memname for the record with currency in the given
    tableid.


Arguments:

    pDB (IN)
    tblid (IN) - cursor for the record to be added to the cache.

Return Values:

   NULL if something went wrong, a pointer to the full memname otherwise.  The
       memory is allocated using THAllocOrg, so remember that when you free it.

--*/
{
    THSTATE *          pTHS = pDB->pTHS;
    JET_RETRIEVECOLUMN columnInfo[11];
    JET_ERR            err;
    d_memname         *pname;
    ATTCACHE          *pAC;
    DWORD              cbRDN, cbAncestors;
    size_t             ibRdn;

    Assert(VALID_DBPOS(pDB));

    // build a memname from the thread heap.  Alloc a single buffer big enough
    // to hold the memname, a 16 level ancestry chain, and a 40 char RDN
#if DBG
    cbAncestors = 6 * sizeof(DWORD);
    cbRDN       = 8 * sizeof(WCHAR);
#else  //  !DBG
    cbAncestors = 16 * sizeof(DWORD);
    cbRDN       = 40 * sizeof(WCHAR);
#endif  //  DBG
    pname = THAllocOrgEx(pTHS,sizeof(d_memname) + cbAncestors + cbRDN);
    // Set the pointer to the start of the ancestors buffer.
    pname->pAncestors = (DWORD*)&pname[1];
    // Set the pointer to the start of the RDN buffer.
    pname->tag.pRdn = (WCHAR *)((BYTE*)&pname[1] + cbAncestors);

    // Populate the new read cache entry.
    memcpy(columnInfo,dnreadColumnInfoTemplate,
           sizeof(dnreadColumnInfoTemplate));

    columnInfo[0].pvData = &pname->DNT;
    columnInfo[1].pvData = &pname->tag.PDNT;
    columnInfo[2].pvData = &pname->objflag;
    columnInfo[3].pvData = &pname->tag.rdnType;
    columnInfo[4].pvData = &pname->NCDNT;
    columnInfo[5].pvData = &pname->Guid;
    columnInfo[6].pvData = &pname->Sid;
    columnInfo[7].pvData = pname->tag.pRdn;
    columnInfo[7].cbData = cbRDN;
    columnInfo[8].pvData = &pname->dwObjectClass;
    columnInfo[9].pvData = &pname->sdId;
    columnInfo[10].pvData = pname->pAncestors;
    columnInfo[10].cbData = cbAncestors;

    err = JetRetrieveColumnsWarnings(pDB->JetSessID, tblid, columnInfo, 11);

    if ((err != JET_errSuccess) && (err != JET_wrnColumnNull) && (err != JET_wrnBufferTruncated)) {
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
    }

    if (0 == columnInfo[5].cbActual) {
        // No GUID on this record.
        memset(&pname->Guid, 0, sizeof(pname->Guid));
    }

    pname->SidLen = columnInfo[6].cbActual;
    if (pname->SidLen) {
        // Convert the SID from internal to external format.
        InPlaceSwapSid(&(pname->Sid));
    }

    // process RDN
    switch(columnInfo[7].err) {
    case JET_errSuccess:
        // OK, we got the RDN
        break;
        
    case JET_wrnBufferTruncated:
        // Failed to read, not enough memory.  Realloc it larger.
        pname = THReAllocOrgEx(pTHS, pname, sizeof(d_memname) + columnInfo[10].cbActual + columnInfo[7].cbActual);
        // Set the pointer to the start of the ancestors buffer.
        pname->pAncestors = (DWORD*)&pname[1];
        // Set the pointer to the start of the RDN buffer.
        pname->tag.pRdn = (WCHAR *)((BYTE*)&pname[1] + columnInfo[10].cbActual);

        if(err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                           tblid,
                                           rdnid,
                                           pname->tag.pRdn,
                                           columnInfo[7].cbActual,
                                           &columnInfo[7].cbActual, 0, NULL)) {
            // Failed again.
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
        }
        break;

    default:
        // Failed badly.
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
        break;
    }
    pname->tag.cbRdn = columnInfo[7].cbActual;
    // No 0 byte RDNs, please.
    Assert(pname->tag.cbRdn);

    // figure out what we got for the SD id
    switch (columnInfo[9].err) {
    case JET_errSuccess:
        // normal case;
        break;

    case JET_wrnColumnNull:
        pname->sdId = (SDID)0;
        break;

    case JET_wrnBufferTruncated:
        // must be an old-style SD (longer than 8 bytes)
        // we don't really want to read it into the cache...
        pname->sdId = (SDID)-1;
        break;

    default:
        // some other error... we should not be here
        Assert(!"error reading SD id");
        DsaExcept(DSA_DB_EXCEPTION, columnInfo[9].err, 0);
    }

    // process Ancestors
    switch (columnInfo[10].err) {
    case JET_errSuccess:
        // OK, we got the ancestors.
        break;

    case JET_wrnBufferTruncated:
        // Remember where the RDN is before we realloc.
        ibRdn = (BYTE*)pname->tag.pRdn - (BYTE*)pname;
        // Failed to read, not enough memory.  Realloc it larger.
        pname = THReAllocOrgEx(pTHS, pname, sizeof(d_memname) + columnInfo[10].cbActual + columnInfo[7].cbActual);
        // Set the pointer to the start of the ancestors buffer.
        pname->pAncestors = (DWORD*)&pname[1];
        // Set the pointer to the start of the RDN buffer.
        pname->tag.pRdn = (WCHAR *)((BYTE*)&pname[1] + columnInfo[10].cbActual);
        // Move the RDN out of the way of the ancestors.
        memmove(pname->tag.pRdn, (BYTE*)pname + ibRdn, pname->tag.cbRdn);

        if(err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                           tblid,
                                           ancestorsid,
                                           pname->pAncestors,
                                           columnInfo[10].cbActual,
                                           &columnInfo[10].cbActual, 0, NULL)) {
            // Failed again.
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
        }
        break;

    default:
        // Failed badly.
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
        break;
    }
    pname->cAncestors = columnInfo[10].cbActual / sizeof(DWORD);

    return pname;
}


d_memname *
DNcache(
        IN  DBPOS *     pDB,
        IN  JET_TABLEID tblid,
        IN  BOOL        bCheckForExisting
        )
/*++

  This routine adds an entry for the current object in the table specified to
  the local dn read cache.

--*/
{
    THSTATE    *pTHS = pDB->pTHS;
    DWORD       i, j;
    d_memname  *pname;
    d_memname  *pTemp;

    Assert(pDB == pDBhidden || pTHS->transactionlevel);

    // First, create a memname to be cached.
    pname = dnCreateMemname(pDB, tblid);
    if(pDB == pDBhidden || !pname->tag.PDNT || !pname->DNT) {
        // Hey, don't bother putting this in the cache, we're in a dangerous
        // place.
        return pname;
    }

    if(bCheckForExisting &&
       // The caller didn't already check the cache for this entry.  We need to
       // see if it is already there, and only add this to the cache if it isn't
       dnGetCacheByDNT(pDB, pname->DNT, &pTemp)
       // This is  already in the cache, don't add it.
                                             ) {
        return pname;
    }

#if DBG
    // Make sure no pre-existing cache entry has the same tag, GUID, or
    // PDNT & RDN type & RDN.
    {

        INC_CACHE_CHECK;

        Assert(!dnGetCacheByDNT(pDB,pname->DNT,&pTemp));
        DEC(pcNameCacheTry);

        Assert(!dnGetCacheByPDNTRdn(pDB,
                                    pname->tag.PDNT,
                                    pname->tag.cbRdn,
                                    pname->tag.pRdn,
                                    pname->tag.rdnType,
                                    &pTemp));
        DEC(pcNameCacheTry);

        Assert(fNullUuid(&pname->Guid) ||
               !dnGetCacheByGuid(pDB,
                                 &pname->Guid,
                                 &pTemp));

        DEC(pcNameCacheTry);

    }
#endif

    Assert(pTHS->DNReadOriginSequence != DNReadOriginSequenceUninit);

    // Now, add it to the cache.

    // First, find the correct spot.
    i = pname->DNT % LOCALDNREADCACHE_BUCKET_NUM;

    if (pTHS->LocalDNReadCache.bucket[i].rgDNT[0] == 0) {
        pTHS->LocalDNReadCache.nextSlot[i] = 0;
    }
    
    j = pTHS->LocalDNReadCache.nextSlot[i];

    // Evict the prior resident of this slot.
    if (pTHS->LocalDNReadCache.bucket[i].rgDNT[j] != 0 &&
        pTHS->LocalDNReadCache.bucket[i].rgDNT[j] != INVALIDDNT) {
        THFreeOrg(pTHS, pTHS->LocalDNReadCache.bucket[i].slot[j].pName);
    }

    // Fill the empty slot with the new info.
    pTHS->LocalDNReadCache.bucket[i].rgDNT[j]          = pname->DNT;
    pTHS->LocalDNReadCache.bucket[i].rgdwHashKey[j]    = DSStrToHashKey (
                                                            pTHS,
                                                            pname->tag.pRdn,
                                                            pname->tag.cbRdn / sizeof (WCHAR));
    pTHS->LocalDNReadCache.bucket[i].slot[j].pName     = pname;
    pTHS->LocalDNReadCache.bucket[i].slot[j].hitCount  = 1;

    // Finally, consume the slot.
    pTHS->LocalDNReadCache.nextSlot[i] = (j + 1) % LOCALDNREADCACHE_SLOT_NUM;


    DPRINT5(3, "Cached tag = 0x%x, ptag = 0x%x, RDN = '%*.*ls'\n",
            pname->DNT, pname->tag.PDNT,
            pname->tag.cbRdn/2, pname->tag.cbRdn/2,
            pname->tag.pRdn);

    return pname;
}


#ifdef DBG
DWORD sdCacheHits = 0;
DWORD sdCacheMisses = 0;
#endif

// try to find an SD cache entry in the sd cache
PSDCACHE_ENTRY dbFindSDCacheEntry(GLOBALDNREADCACHE* pCache, SDID sdID) {
    DWORD index;
    PSDCACHE_ENTRY pEntry;
    if (pCache != NULL && pCache->sdHashTableSize > 0) {
#ifdef DBG
        // print SD cache stats
        if ((sdCacheHits + sdCacheMisses) % 1000 == 0) {
            DPRINT2(1, "SD cache stats: %d hits, %d misses\n", sdCacheHits, sdCacheMisses);
        }
#endif
        // compute the hash value
        index = (DWORD)(sdID % pCache->sdHashTableSize);
        // walk the chain
        for (pEntry = pCache->pSDHashTable[index]; pEntry != NULL; pEntry = pEntry->pNext) {
            if (pEntry->sdID == sdID) {
                // found it!
#ifdef DBG  
                InterlockedIncrement(&sdCacheHits);
#endif
                return pEntry;
            }
        }
    }
    // did not find anything...
#ifdef DBG  
    InterlockedIncrement(&sdCacheMisses);
#endif
    return NULL;
}

// add an SDCACHE_ENTRY to the sd hash table
VOID dbAddSDCacheEntry(GLOBALDNREADCACHE* pCache, PSDCACHE_ENTRY pEntry) {
    DWORD index;
    Assert(pCache && pCache->sdHashTableSize > 0);
    index = (DWORD)(pEntry->sdID % pCache->sdHashTableSize);
    pEntry->pNext = pCache->pSDHashTable[index];
    pCache->pSDHashTable[index] = pEntry;
}

int _cdecl compareSDIDs(const void* p1, const void* p2) {
    return memcmp(p1, p2, sizeof(SDID));
}

// compute the required SDCACHE_ENTRY size from the sd size
#define SDCACHE_ENTRY_SIZE(cbSD) (offsetof(SDCACHE_ENTRY, SD) + cbSD)


/* ReloadDNReadCache
 *
 * This routine (invoked off of the task queue) resets the global DNread
 * cache to something sensible.  We do this by clearing our thread's cache,
 * seeking some interesting DNTS, and directly creating cache items for
 * them.
 *
 * INPUT:
 *   A bunch of junk that we don't use, to match the task queue prototype
 */
void
ReloadDNReadCache(
    IN  void *  buffer,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    )
{
    THSTATE * pTHS = pTHStls;
    DWORD i,j;
    GLOBALDNREADCACHE *pNewCache=NULL;
    DWORD index;
    GLOBALDNREADCACHESLOT *pData;
    void * * pFreeBuf;
    DWORD localCount;
    DWORD *localDNTList;
    BOOL  fDoingRebuild = TRUE;
    DWORD LastInvalidateSequenceOrig;
    BOOL bDefunct;
    SDID* sdIDs = NULL;
    PSDCACHE_ENTRY pEntry;
    DBPOS* pDB;
    JET_ERR err;
    PSECURITY_DESCRIPTOR pSD;
    DWORD cbSD;

    if(!SyncTryEnterBinaryLockAsGroup1(&blDNReadInvalidateData)) {
        // Someone is actively, right now, working on committing a
        // transaction that caused a cache invalidation.  We won't rebuild
        // the global cache right now.
        fDoingRebuild = FALSE;
    }
    else {
        // OK, no one is currently closing a transaction that puts the
        // DNRead cache in jeopardy. However, we need to know what the
        // current sequence number for invalidations is.  After we build a
        // new global cache, we're going to recheck this, and if it's
        // different, throw away the cache we build here because we can't
        // vouch for its correctness.
        LastInvalidateSequenceOrig = gDNReadLastInvalidateSequence;
        SyncLeaveBinaryLockAsGroup1(&blDNReadInvalidateData);
    }

    if(!fDoingRebuild) {
        return;
    }

    Assert(!pTHS->pDB);

    DBOpen(&pTHS->pDB);
    __try {
        /* make the cache permanent */
        DPRINT(3,"Processing Cache Rebuild request\n");

        pDB = pTHS->pDB;
        // Grab the list
        EnterCriticalSection(&csDNReadGlobalCache);
        __try {
            if(localDNTList = pGlobalDNReadCacheDNTs) {
                // Take complete possesion of the list so no one else frees it
                // out from under us.
                pGlobalDNReadCacheDNTs = NULL;
                localCount = cGlobalDNTReadCacheDNTs;
                cGlobalDNTReadCacheDNTs = 0;
            }
            else {
                fDoingRebuild = FALSE;
            }
        }
        __finally {
            LeaveCriticalSection(&csDNReadGlobalCache);
        }

        if(!fDoingRebuild) {
            // Someone else is rebuilding, bail.
            __leave;
        }

        __try { // Make sure we have a finally to reset the global dnt list


            // Allocate a new global cache structure
            pNewCache = malloc(sizeof(GLOBALDNREADCACHE));
            if(!pNewCache) {
                fDoingRebuild = FALSE;
                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_MINIMAL,
                         DIRLOG_READ_CACHE_SKIPPED, NULL,NULL,NULL);
                __leave;
            }
            memset(pNewCache, 0, sizeof(GLOBALDNREADCACHE));

            index = 0;
            pData = malloc(localCount * sizeof(GLOBALDNREADCACHESLOT));
            if(!pData) {
                free(pNewCache);
                pNewCache = NULL;
                fDoingRebuild = FALSE;
                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_MINIMAL,
                         DIRLOG_READ_CACHE_SKIPPED, NULL,NULL,NULL);
                __leave;
            }
            memset(pData, 0, localCount * sizeof(GLOBALDNREADCACHESLOT));

            // alloc the array for sdIDs that we will need to load
            sdIDs = THAllocEx(pTHS, localCount * sizeof(SDID));
            if(!sdIDs) {
                free(pNewCache);
                free(pData);
                pNewCache = NULL;
                pData = NULL;
                fDoingRebuild = FALSE;
                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_MINIMAL,
                         DIRLOG_READ_CACHE_SKIPPED, NULL,NULL,NULL);
                __leave;
            }
            memset(sdIDs, 0, localCount * sizeof(SDID));

            // create the hash table for SDs
            // Compute the size of the hash. Let's just use localCount.
            pNewCache->sdHashTableSize = localCount;
            pNewCache->pSDHashTable = malloc(pNewCache->sdHashTableSize * sizeof(PSDCACHE_ENTRY));
            if(!pNewCache->pSDHashTable) {
                free(pNewCache);
                free(pData);
                THFreeEx(pTHS, sdIDs);
                pNewCache = NULL;
                pData = NULL;
                sdIDs = NULL;
                fDoingRebuild = FALSE;
                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_MINIMAL,
                         DIRLOG_READ_CACHE_SKIPPED, NULL,NULL,NULL);
                __leave;
            }
            memset(pNewCache->pSDHashTable, 0, pNewCache->sdHashTableSize * sizeof(PSDCACHE_ENTRY));

            // Now, cache the DNTs in the global list
            for(i=0;i<localCount;i++) {
                if(localDNTList[i]) {
                    if(!DBTryToFindDNT(pDB, localDNTList[i])) {
                        d_memname  *pname=NULL;
                        // First, create a memname to be cached.
                        pname =dnCreateMemname(pDB, pDB->JetObjTbl);
                        if(pname) {
                            memcpy(&pData[index].name,
                                   pname,
                                   sizeof(d_memname));

                            pData[index].dwHashKey = DSStrToHashKey (pTHS,
                                                                     pname->tag.pRdn,
                                                                     pname->tag.cbRdn / sizeof (WCHAR));

                            pData[index].name.tag.pRdn =
                                malloc(pData[index].name.tag.cbRdn);
                            if(pData[index].name.tag.pRdn) {
                                pData[index].name.pAncestors =
                                    malloc(pData[index].name.cAncestors *
                                           sizeof(DWORD));
                                if(pData[index].name.pAncestors) {
                                    memcpy(pData[index].name.tag.pRdn,
                                           pname->tag.pRdn,
                                           pname->tag.cbRdn);
                                    memcpy(pData[index].name.pAncestors,
                                           pname->pAncestors,
                                           pname->cAncestors * sizeof(DWORD));
                                    pData[index].valid = TRUE;
                                    index++;
                                }
                                else {
                                    free(pData[index].name.tag.pRdn);
                                }
                            }
                            
                            if (pname->sdId != (SDID)0 && pname->sdId != (SDID)-1) {
                                // We got a non-null, new-format SDID. Add it to the list.
                                sdIDs[i] = pname->sdId;
                            }

                            THFreeOrg(pTHS, pname);
                        }
                    }
                    else {
                        DPRINT1(4,"Failed to cache DNT %d\n",localDNTList[i]);
                    }
                }
                else {
                    DPRINT(4,"Caching Skipping 0\n");
                }

            }
            pNewCache->pData = pData;
            pNewCache->count = index;
            DPRINT1(3,"New cache, %d elements\n", index);

            // now load the SDs
            // sort the SDID array to be able to skip dups
            qsort(sdIDs, localCount, sizeof(SDID), compareSDIDs);
            for (i = 0; i < localCount; i++) {
                if (sdIDs[i] == 0 || (i > 0 && sdIDs[i] == sdIDs[i-1])) {
                    // skip this one
                    continue;
                }
                // IntExtSecDesc does exactly what we need here: load an SD by its SDID.
                // It first checks if it is present in the cache, and, if not, then loads it.
                err = IntExtSecDesc(pDB, DBSYN_INQ, sizeof(SDID), (PUCHAR)&sdIDs[i],
                                    &cbSD, (PUCHAR*)&pSD, 0, 0, 0);
                if (err) {
                    // something bad happened, bail
                    break;
                }
                
                pEntry = malloc(SDCACHE_ENTRY_SIZE(cbSD));
                if (!pEntry) {
                    // no luck here, bail
                    break;
                }
                pEntry->sdID = sdIDs[i];
                pEntry->cbSD = cbSD;
                memcpy(&pEntry->SD, pSD, cbSD);
                
                // ok, got the entry, cache it now.
                dbAddSDCacheEntry(pNewCache, pEntry);
            }

            /* Discard my existing cache */
            dbReleaseGlobalDNReadCache(pTHS);
        }
        __finally {
            EnterCriticalSection(&csDNReadGlobalCache);
            __try {
                if(!pGlobalDNReadCacheDNTs) {
                    pGlobalDNReadCacheDNTs = localDNTList;
                    localDNTList = NULL;
                    cGlobalDNTReadCacheDNTs = localCount;
                }
                //ELSE  Someone replaced the global list while we were using
                //      this one.  Free the one we have.
            }
            __finally {
                LeaveCriticalSection(&csDNReadGlobalCache);
            }
        }
    }
    __finally {
        if (sdIDs) {
            THFreeEx(pTHS, sdIDs);
        }
        DBClose(pDB, TRUE);
    }

    if(localDNTList) {
        free(localDNTList);
    }

    if(!fDoingRebuild) {
        return;
    }

    Assert(pNewCache);

    if (!SyncTryEnterBinaryLockAsGroup1(&blDNReadInvalidateData)) {
        // Someone is committing a change that invalidated the dnread cache
        // since we started rebuilding the cache (or is in the process of
        // doing so).  Therefore, don't use the cache we just built.
        fDoingRebuild = FALSE;
    }
    else {
        if (LastInvalidateSequenceOrig != gDNReadLastInvalidateSequence) {
            // Someone has committed a change that invalidated the dnread cache
            // since we started rebuilding the cache (or is in the process of
            // doing so).  Therefore, don't use the cache we just built.
            fDoingRebuild = FALSE;
        }
        else {
            // Switch the universe to use the new cache.  Note we do this inside
            // the csDNReadInalidateData crit sec to avoid someone deciding to
            // invalidate in between our last check of the sequence and actually
            // replacing the global pointer.  This way, if we check the sequence
            // and it's OK, we are guaranteed of making the pointer change.
            // Then, someone else who enters a new sequence and then checks the
            // pointer is guaranteed to find the new pointer, and take
            // appropriate action.

            // The new cache starts with a refcount of 1 for being in the
            // anchor. Everytime someone grabs a use of it from the anchor, the
            // refcount increases.  Everytime they release the use of it, the
            // refcount decreases.  The refcount drops by one when it is removed
            // from the anchor.
            pNewCache->refCount = 1;
            DPRINT1(3,"Using dnreadcache 0x%X\n",pNewCache);
            dbReplaceCacheInAnchor(pNewCache);
            Assert(fDoingRebuild);
            pNewCache = NULL;
        }
        SyncLeaveBinaryLockAsGroup1(&blDNReadInvalidateData);
    }

    if(!fDoingRebuild) {
        // We have built a cache, but decided not to use it.  Throw it away.
        if(pNewCache->pData) {
            for(i=0;i<pNewCache->count;i++) {
                free(pNewCache->pData[i].name.pAncestors);
                free(pNewCache->pData[i].name.tag.pRdn);
            }
            free(pNewCache->pData);
        }
        if (pNewCache->pSDHashTable) {
            for (i = 0; i < pNewCache->sdHashTableSize; i++) {
                while (pEntry = pNewCache->pSDHashTable[i]) {
                    pNewCache->pSDHashTable[i] = pEntry->pNext;
                    free(pEntry);
                }
            }
            free(pNewCache->pSDHashTable);
        }
        free(pNewCache);
        return;
    }
}


#if DBG
VOID
DbgCompareMemnames (
        d_memname *p1,
        d_memname *p2,
        DWORD      DNT
        )
/* This is just a separate routine to get the pointers on the stack. */
{
    Assert(p2);
    Assert(p2->DNT == DNT);
    Assert(p1->DNT == p2->DNT);
    Assert(p1->NCDNT == p2->NCDNT);
    Assert(!memcmp(&p1->Guid,
                   &p2->Guid,
                   sizeof(GUID)));
    Assert(p1->SidLen == p2->SidLen);
    Assert(!p1->SidLen || !memcmp(&p1->Sid,
                                     &p2->Sid,
                                     p1->SidLen));
    Assert(p1->objflag == p2->objflag);
    Assert(p1->cAncestors == p2->cAncestors);
    Assert(!memcmp(p1->pAncestors,
                   p2->pAncestors,
                   p1->cAncestors * sizeof(DWORD)));

    Assert(p1->tag.PDNT == p2->tag.PDNT);
    Assert(p1->tag.rdnType == p2->tag.rdnType);
    Assert(p1->tag.cbRdn == p2->tag.cbRdn);
    Assert(!memcmp(p1->tag.pRdn,
                   p2->tag.pRdn,
                   p2->tag.cbRdn));
    return;
}

VOID
dbExhaustivelyValidateDNReadCache (
        THSTATE *pTHS
        )
/*++
  Description:
      A debug only routine used to validate that the dnread cache is coherent.
      Walk the local DNRead cache and validate all objects in it.

--*/
{
    DWORD i,j;
    d_memname *pname=NULL;
    DBPOS *pDBTemp=NULL;
    GLOBALDNREADCACHESLOT *pData;

    DBOpen2(TRUE, &pDBTemp);
    __try {

        for(i=0; i<LOCALDNREADCACHE_BUCKET_NUM;i++) {
            for(j=0;pTHS->LocalDNReadCache.bucket[i].rgDNT[j] != 0 && j<LOCALDNREADCACHE_SLOT_NUM;j++) {
                if(pTHS->LocalDNReadCache.bucket[i].rgDNT[j] != INVALIDDNT) {
                    // This slot has something in it.  Verify that the contents
                    // are still valid (i.e. that we didn't forget to
                    // dbFlushDNReadCache when we needed to.)
                    DBFindDNT(pDBTemp, pTHS->LocalDNReadCache.bucket[i].rgDNT[j]);
                    
                    // Now, create a memname by reading the object.
                    pname = dnCreateMemname(pDBTemp, pDBTemp->JetObjTbl);

                    // Finally, check the value in the memname.
                    DbgCompareMemnames(
                        pname,
                        pTHS->LocalDNReadCache.bucket[i].slot[j].pName,
                        pTHS->LocalDNReadCache.bucket[i].rgDNT[j]);
                    THFreeOrg(pTHS, pname);
                    pname = NULL;
                }
            }
        }

        // Now, validate the global DN cache.
        if(pTHS->Global_DNReadCache && pTHS->Global_DNReadCache->pData) {
            pData = pTHS->Global_DNReadCache->pData;
            for(i=0;i<pTHS->Global_DNReadCache->count;i++) {
                if(pData[i].valid) {
                    // Only validate things that are marked as valid.
                    DBFindDNT(pDBTemp, pData[i].name.DNT);
                    // Now, create a memname by reading the object.
                    pname = dnCreateMemname(pDBTemp, pDBTemp->JetObjTbl);
                    // Finally, check the value in the memname.

                    DbgCompareMemnames(pname,
                                       &pData[i].name,
                                       pData[i].name.DNT);
                    THFreeOrg(pTHS, pname);
                    pname = NULL;
                }
            }
        }
    }
    __finally {
        DBClose(pDBTemp, TRUE);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\boot\parseini.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1989 - 1999
//
//  File:       ParseIni.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Parses Schema Initialization File

Author:

    Rajivendra Nath (RajNath) 18-Aug-1989

Revision History:

--*/

#include <ntdspchX.h>


#include "SchGen.HXX"

#define DEBSUB "PARSEINI:"

#include <fileno.h>
#define FILENO FILENO_BOOT_PARSEINI 

#define CONFIGURATIONNODE "DIT CONFIGURATION INFO"
#define SCHEMACONTAINER   "SCHEMA_CONTAINER"
#define MACHINENODE       "MACHINE_OBJECT"

extern char gDsaname[64];
extern char gSchemaname[64];

BOOL YAHANDLE::Initialize(INISECT* is,char* Key)
{
    m_ini=is;
    m_ndx=0;
    m_IsInitialized=TRUE;
    m_stk=0;

    if (Key)
    {
        if (m_str)
        {
            XFree(m_str);
            m_str=NULL;
        }

        m_str=XStrdup(Key);
    }

    return TRUE;
};

BOOL YAHANDLE::Initialize2(INISECT* is,char* Key,DWORD Ndx)
{
    BOOL ret;
    ret=Initialize(is,Key);
    m_ndx=Ndx;
    return ret;
}
////////////////////////////////////////////////
// Iterator for the INISECT Class's Keys
////////////////////////////////////////////////
char*
INISECT::GetNextKey(YAHANDLE& Handle,char* Key,char** RetKey)
{
    char* retchr=NULL;

    if (Handle.m_IsInitialized == 0 || (Handle.m_str==NULL && Key!=NULL))
    {
        Handle.Initialize(this,Key);
    }

    if (Handle.m_str==NULL)
    {
        if (Handle.m_ndx<m_KeyCount)
        {
            retchr=m_ValArray[Handle.m_ndx];
            if (RetKey!=NULL)
            {
                *RetKey=m_KeyArray[Handle.m_ndx];
            }
            Handle.m_ndx++;
        }
    }
    else
    {
        for (DWORD i=Handle.m_ndx;i<m_KeyCount;i++)
        {
            if (_strcmpi(Handle.m_str,m_KeyArray[i])==0)
            {
                retchr=m_ValArray[i];

                if (RetKey!=NULL)
                {
                    *RetKey=m_KeyArray[Handle.m_ndx];
                }

                break;

            }
        }

        Handle.m_ndx=i+1;
    }


    return retchr;
}



////////////////////////////////////////////////
// INISECT Class Implementation
////////////////////////////////////////////////
char    gIniFile[MAX_PATH];

BOOL
SetIniGlobalInfo(char* IniFileName)
{
    strcpy(gIniFile,IniFileName);
        
    strcpy(gSchemaname,"Schema");
    strcpy(gDsaname,   "BootMachine");
    
    return TRUE;
}

extern DWORD GetPrivateProfileSectionEx(
    CHAR    *sectionName,   // IN
    CHAR    **ppBuffer,     // OUT
    CHAR    *iniFile);      // IN


INISECT::INISECT(char* SectionName):
    m_cIniFile(gIniFile)
{
    DWORD ssize=128;

    DWORD SectionSize=ssize-2;
    BOOL  Done=FALSE;

    m_Buffer = NULL;
    m_KeyCount=0;
    m_KeyArray=NULL;
    m_ValArray=NULL;

    m_cSectName = _strdup(SectionName);

    if (m_cSectName==NULL)
    {

        XOUTOFMEMORY(); //Exception...
    }

    SectionSize = GetPrivateProfileSectionEx(
                                m_cSectName,
                                &m_Buffer,
                                m_cIniFile);
    if (SectionSize == 0)
    {
        XFree(m_Buffer);
        m_Buffer = NULL;
        DPRINT1(0, "INISECT::INISECT(%s) Failed. Error NoSuchSection\n", SectionName);
        return;
    }
    else
    {
        m_BuffSize=SectionSize;

        for (char* ptr=m_Buffer;*ptr!='\0';ptr+=strlen(ptr)+1)
        {
            char* eql=strchr(ptr,'=');
            if (eql==NULL)
            {
                DPRINT2(0, "INISECT::INISECT(%s). Bad Line %s in IniFile Ignoring\n", SectionName,m_Buffer);
                return;
            }
            m_KeyCount++;
            *eql='\0';
            ptr+=strlen(ptr)+1;
        }
    }

    m_ValArray=(char**)XCalloc(m_KeyCount,sizeof(char*));
    m_KeyArray=(char**)XCalloc(m_KeyCount,sizeof(char*));

    char* tptr=m_Buffer;

    for (DWORD i=0;i<m_KeyCount;i++)
    {
        m_KeyArray[i]=tptr;
        tptr+=strlen(tptr)+1;
        m_ValArray[i]=tptr;
        tptr+=strlen(tptr)+1;
    }
}

void 
INISECT::ReplaceKeyValuePair(
    char* KeyName, 
    char* KeyValue
    )
{
    // This routine replaces a Key/Value pair.  
    // It exists solely for the benefit of
    // CreateRootDomainObject() which needs to set
    // the Object-Class based on the tag of the 
    // domain name being installed.

    // Should only be called on an initialized instance.
    Assert(IsInitialized());
    // schema.ini key/value pairs should have been read.
    Assert(m_KeyCount > 0);

    // Look for existing key.

    for ( DWORD i = 0; i < m_KeyCount; i++ )
    {
        if ( 0 == _stricmp(KeyName, m_KeyArray[i]) )
        {
            break;
        }
    }

    if ( i == m_KeyCount )
    {
        // Key not found.  Subsequent AddOneObject()
        // where Object-Class doesn't match the 
        // RDN-Att-ID will fail.

        return;
    }

    m_ValArray[i] = KeyValue;
}

char*
INISECT::GetOneKey(char* KeyName)
{
    YAHANDLE handle;

    return GetNextKey(handle,KeyName);
}

char*
INISECT::XGetOneKey(char* KeyName)
{
    char* ret=GetOneKey(KeyName);
    if (ret==NULL)
    {
        DPRINT1(0, "INISECT::XGetOneKey(%s) Failed. Error NoSuchKey\n", KeyName);
        XINVALIDINIFILE();
    }

    return ret;
}

char*
INISECT::XGetNextKey(YAHANDLE& Handle,char* Key,char** RetKey)
{
    char* ret=GetNextKey(Handle,Key,RetKey);
    if (ret==NULL)
    {
        DPRINT1(0, "INISECT::XGetNextKey(%s) Failed. Error NoSuchKey\n", Key);
        XINVALIDINIFILE();
    }

    return ret;
}



INISECT::~INISECT()
{
    if (m_Buffer!=NULL)
    {
        XFree(m_Buffer);
    }

    if (m_KeyArray!=NULL)
    {
        XFree(m_KeyArray);
    }

    if (m_ValArray!=NULL)
    {
        XFree(m_ValArray);
    }
    // PREFIX: Allocated with _strdup so free w/free().
    if (m_cSectName)
    {
        free(m_cSectName);
        m_cSectName = NULL;
    }
}


///////////////////////////////////////////////////
// NODE Class Implementation
///////////////////////////////////////////////////
NODE::NODE( char* startnode):
    INISECT(startnode),
    m_ChildrenCount(0),
    m_Children(NULL),
    m_Parent(NULL),
    m_Cached(FALSE)
{
    m_NodeName = m_cSectName;
}

NODE::~NODE()
{

    for (DWORD i=0;i<m_ChildrenCount;i++)
    {
        if (m_Children[i]->m_Cached!=TRUE)
        {
            delete m_Children[i];
        }

    }

    if (m_Children!=NULL)
    {
        XFree(m_Children);
    }
}

NODE*
NODE::InitChildList()
{
    NODE* node;
    //
    // Initialize if not
    //
    if (m_Children == NULL)
    {
        char* child;
        YAHANDLE handle;

        for (;(child=GetNextKey(handle,CHILDKEY))!=NULL;m_ChildrenCount++);

        m_Children=(NODE**)XCalloc(m_ChildrenCount,sizeof(NODE*));

        handle.Reset();

        for(int i=0;(child=GetNextKey(handle,CHILDKEY))!=NULL;i++)
        {
            m_Children[i]= new NODE(child);
            CHECKVALIDNODE(m_Children[i]);
            m_Children[i]->m_Parent=this;
        }
    }

    return m_Children[0];
}

#define INITALLOCCOUNT 128

NODE*
NODE::GetNextChild(YAHANDLE& handle)
{
    NODE* node=NULL;

//    if (m_Children==NULL)
//    {
//        InitChildList();
//    }

    if (!handle.m_IsInitialized)
    {
        handle.Initialize(this);
    }

    if (m_Children==NULL)
    {
        m_Children=(NODE**)XCalloc(INITALLOCCOUNT,sizeof(NODE*));
        m_ChildrenBuffSize=INITALLOCCOUNT;
    }

    if (m_Children[handle.m_ndx]==NULL)
    {
        YAHANDLE ah;
        char* child;
        ah.Initialize2(handle.m_ini,CHILDKEY,handle.m_stk);

        child=GetNextKey(ah,CHILDKEY);

        handle.m_stk=ah.m_ndx;

        if (child==NULL)
        {
            return NULL;
        }

        node = new NODE(child);

        if (!node->Initialize())
        {
            XINVALIDINIFILE();
        }

        m_Children[handle.m_ndx++]=node;

        if (handle.m_ndx==m_ChildrenBuffSize)
        {
            m_ChildrenBuffSize+=INITALLOCCOUNT;
            m_Children=(NODE**)XRealloc(m_Children,m_ChildrenBuffSize*sizeof(NODE*));

            ZeroMemory(&m_Children[m_ChildrenBuffSize-INITALLOCCOUNT],INITALLOCCOUNT*sizeof(NODE*));
        }

    }
    else
    {
        node = m_Children[handle.m_ndx++];
    }


    return node;
}

BOOL
NODE::Initialize()
{

    if (!(INISECT::IsInitialized()))
    {
        return FALSE;
    }

    return TRUE;
}


ATTCACHE *
NODE::GetNextAttribute(YAHANDLE& Handle,char** Attrib)
{
    char     *attrname;
    ATTCACHE *pAC=NULL;
    
    while(*Attrib = GetNextKey(Handle,NULL,&attrname)) {
        if( strcmp(attrname,CHILDKEY)==0 ) {
            // This determines the DIT struct and is not an attrib.
            continue;
        }
        if ( strcmp(attrname,RDNOFOBJECTKEY)==0) {
            // this is not a real att, but a key to specify what
            // the object name should be if different from the 
            // section name
            continue;
        }
        pAC = SCGetAttByName(pTHStls, strlen(attrname), (PUCHAR) attrname);

        if(!pAC) {
            DPRINT1(0,
                    "NODE::GetNextAttribute(%s) Failed to find ATTCACHE*\n",
                    attrname);
            
            XINVALIDINIFILE();
        }
        break;
    }
    
    return pAC;
}

CLASSCACHE*
NODE::GetClass()
{
    char       *classname=GetOneKey(CLASSKEY);
    CLASSCACHE *pCC=NULL;

    if(!classname) {
        classname = GetOneKey(DASHEDCLASSKEY);
    }

    if(!classname) {
        DPRINT1(0,
                "NODE::GetClass(node-name %s) Failed to find CLASSCACHE*\n",
                m_NodeName);
        
        XINVALIDINIFILE();
    }
        
    pCC = SCGetClassByName(pTHStls, strlen(classname), (PUCHAR) classname);
    
    if(!pCC) {
        DPRINT1(0,
                "NODE::GetClass(%s) Failed to find CLASSCACHE*\n",
                classname);
        
        XINVALIDINIFILE();
    }

    return pCC;
}


CHAR*
NODE::GetRDNOfObject()
{
    // GetOneKey returns NULL if not found
    return GetOneKey(RDNOFOBJECTKEY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dblayer\dbconstr.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dbconstr.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <dsatools.h>                   // For pTHStls
#include <mdlocal.h>                    // IsRoot
#include <ntseapi.h>
#include <lmaccess.h>                   // For useraccountcontrol flags

// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>
#include "ntdsctr.h"

// Headers for Sam call to get reverse membership
#include <samrpc.h>
#include <ntlsa.h>
#include <samisrv.h>
#include "mappings.h"

// Assorted DSA headers
#include "dsevent.h"
#include "objids.h"        /* needed for ATT_MEMBER and ATT_IS_MEMBER_OFDL */
#include <dsexcept.h>
#include <filtypes.h>      /* Def of FI_CHOICE_???                  */
#include <anchor.h>
#include <permit.h>
#include <quota.h>
#include <cracknam.h>  // for CrackedNAmes
#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DBCONSTR:" /* define the subsystem for debugging */

// DBLayer includes
#include "dbintrnl.h"

// draLayer includes
#include "draconstr.h"

#include "drameta.h" // for metadata manipulation in dbGetMsDsKeyVersionNumber()

// replIncludes
#include "ReplStructInfo.hxx"

#include <fileno.h>
#define  FILENO FILENO_DBCONSTR

// Flag values for reverse membership computations
#define FLAG_NO_GC_ACCEPTABLE      0
#define FLAG_NO_GC_NOT_ACCEPTABLE  1
#define FLAG_GLOBAL_AND_UNIVERSAL  2

// These #defines are used in creating attributeType strings and objectClasses
// strings.
#define NAME_TAG                  L" NAME '"
#define NAME_TAG_SIZE             (sizeof(NAME_TAG) - sizeof(WCHAR))
#define SYNTAX_TAG                L"' SYNTAX '"
#define SYNTAX_TAG_SIZE           (sizeof(SYNTAX_TAG) - sizeof(WCHAR))
#define SINGLE_TAG                L" SINGLE-VALUE"
#define SINGLE_TAG_SIZE           (sizeof(SINGLE_TAG) - sizeof(WCHAR))
#define NO_MOD_TAG                L" NO-USER-MODIFICATION"
#define NO_MOD_TAG_SIZE           (sizeof(NO_MOD_TAG) - sizeof(WCHAR))
#define MAY_TAG                   L" MAY ("
#define MAY_TAG_SIZE              (sizeof(MAY_TAG) - sizeof(WCHAR))
#define ABSTRACT_CLASS_TAG        L" ABSTRACT"
#define ABSTRACT_CLASS_TAG_SIZE   (sizeof(ABSTRACT_CLASS_TAG) - sizeof(WCHAR))
#define AUXILIARY_CLASS_TAG       L" AUXILIARY"
#define AUXILIARY_CLASS_TAG_SIZE  (sizeof(AUXILIARY_CLASS_TAG) - sizeof(WCHAR))
#define STRUCTURAL_CLASS_TAG      L" STRUCTURAL"
#define STRUCTURAL_CLASS_TAG_SIZE (sizeof(STRUCTURAL_CLASS_TAG) - sizeof(WCHAR))
#define MUST_TAG                  L" MUST ("
#define MUST_TAG_SIZE             (sizeof(MUST_TAG) - sizeof(WCHAR))
#define SUP_TAG                   L"' SUP "
#define SUP_TAG_SIZE              (sizeof(SUP_TAG) - sizeof(WCHAR))
#define AUX_TAG                   L" AUX ( "
#define AUX_TAG_SIZE              (sizeof(AUX_TAG) - sizeof(WCHAR))
#define INDEXED_TAG               L" INDEXED"
#define INDEXED_TAG_SIZE          (sizeof(INDEXED_TAG) - sizeof(WCHAR))
#define SYSTEM_ONLY_TAG           L" SYSTEM-ONLY "
#define SYSTEM_ONLY_TAG_SIZE      (sizeof(SYSTEM_ONLY_TAG) - sizeof(WCHAR))
#define RANGE_LOWER_TAG           L"' RANGE-LOWER '"
#define RANGE_LOWER_TAG_SIZE      (sizeof(RANGE_LOWER_TAG) - sizeof(WCHAR))
#define RANGE_UPPER_TAG           L"' RANGE-UPPER '"
#define RANGE_UPPER_TAG_SIZE      (sizeof(RANGE_UPPER_TAG) - sizeof(WCHAR))
#define CLASS_GUID_TAG            L"' CLASS-GUID '"
#define CLASS_GUID_TAG_SIZE       (sizeof(CLASS_GUID_TAG) - sizeof(WCHAR))
#define PROP_GUID_TAG             L"' PROPERTY-GUID '"
#define PROP_GUID_TAG_SIZE        (sizeof(PROP_GUID_TAG) - sizeof(WCHAR))
#define PROP_SET_GUID_TAG         L"' PROPERTY-SET-GUID '"
#define PROP_SET_GUID_TAG_SIZE    (sizeof(PROP_SET_GUID_TAG) - sizeof(WCHAR))
#define END_TAG                   L" )"
#define END_TAG_SIZE              (sizeof(END_TAG) - sizeof(WCHAR))

typedef struct wchar_syntax {
    ULONG    length;
    WCHAR    *value;
} wchar_syntax;

typedef struct SyntaxVal {
    wchar_syntax   name;
    wchar_syntax   oid;
} SyntaxVal;

#define DEFINE_WCHAR_STRING(x) {(sizeof(x)-sizeof(WCHAR)),(WCHAR *)x}

// These are used as the string to use when describing attribute syntaxes in the
// schema.
SyntaxVal SyntaxStrings[] = {
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"Boolean"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.7") },
    { DEFINE_WCHAR_STRING(L"INTEGER"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.27") },
    { DEFINE_WCHAR_STRING(L"BitString"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.6") },
    { DEFINE_WCHAR_STRING(L"OctetString"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.40") },
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"OID"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.38") },
    { DEFINE_WCHAR_STRING(L"CaseIgnoreString"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.905") },
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"Integer"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.27") },
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"NumericString"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.36") },
    { DEFINE_WCHAR_STRING(L"PrintableString"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.44") },
    { DEFINE_WCHAR_STRING(L"CaseIgnoreString"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.905") },
    { DEFINE_WCHAR_STRING(L"CaseIgnoreString"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.905") },
    { DEFINE_WCHAR_STRING(L"IA5String"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.26") },
    { DEFINE_WCHAR_STRING(L"UTCTime"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.53") },
    { DEFINE_WCHAR_STRING(L"GeneralizedTime"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.24") },
    { DEFINE_WCHAR_STRING(L"CaseIgnoreString"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.905") },
    { DEFINE_WCHAR_STRING(L"CaseIgnoreString"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.905") },
    { DEFINE_WCHAR_STRING(L"CaseExactString"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1362") }
};

SyntaxVal SyntaxDN =
                { DEFINE_WCHAR_STRING(L"DN"),
                  DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.12") };
SyntaxVal SyntaxORName =
                { DEFINE_WCHAR_STRING(L"ORName"),
                  DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1221") };
SyntaxVal SyntaxDNBlob =
                { DEFINE_WCHAR_STRING(L"DNWithOctetString"),
                  DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.903") };
SyntaxVal SyntaxDNString =
                { DEFINE_WCHAR_STRING(L"DNWithString"),
                  DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.904") };
SyntaxVal SyntaxPresentationAddress =
                { DEFINE_WCHAR_STRING(L"PresentationAddress"),
                  DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.43") };
SyntaxVal SyntaxAccessPoint =
                { DEFINE_WCHAR_STRING(L"AccessPointDN"),
                  DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.2") };
SyntaxVal SyntaxDirectoryString =
                { DEFINE_WCHAR_STRING(L"DirectoryString"),
                  DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.15") };
SyntaxVal SyntaxInteger8 =
                { DEFINE_WCHAR_STRING(L"INTEGER8"),
                  DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.906") };
SyntaxVal SyntaxObjectSD =
                { DEFINE_WCHAR_STRING(L"ObjectSecurityDescriptor"),
                  DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.907") };

OID_IMPORT(MH_C_OR_NAME);
OID_IMPORT(DS_C_ACCESS_POINT);


// Forward declaration of internal functions

DWORD dbGetEntryTTL(DBPOS *pDB, ATTR *pAttr);
DWORD dbGetSubschemaAtt(THSTATE *pTHS, ATTCACHE *pAC, ATTR *pAttr);
DWORD dbGetSubSchemaSubEntry(THSTATE *pTHS, ATTR *pAttr, BOOL fExternal);
DWORD dbGetCanonicalName(THSTATE *pTHS, DSNAME *pDSName, ATTR *pAttr);
DWORD dbGetAllowedChildClasses(THSTATE *pTHS,
                               DSNAME *pDSName,
                               ATTR *pAttr,
                               DWORD flag);
DWORD dbGetAllowedAttributes(THSTATE *pTHS,
                             DSNAME *pDSName,
                             ATTR *pAttr,
                             BOOL fSecurity);
DWORD dbGetFromEntry(DBPOS *pDB, ATTR *pAttr);
DWORD dbGetCreateTimeStamp(DBPOS *pDB, ATTR *pAttr);
DWORD dbGetModifyTimeStamp(DBPOS *pDB, ATTR *pAttr);
DWORD dbGetReverseMemberships(THSTATE *pTHS, DSNAME *pObj, ATTR *pAttr, ULONG Flag);
DWORD dbGetObjectClasses(THSTATE *pTHS, ATTR *pAttr, BOOL bExtendedFormat);
DWORD dbGetAttributeTypes(THSTATE *pTHS, ATTR *pAttr, BOOL bExtendedFormat);
DWORD dbGetDitContentRules(THSTATE *pTHS, ATTR *pAttr, BOOL bExtendedFormat);
DWORD dbGetSubSchemaModifyTimeStamp(THSTATE *pTHS, ATTR *pAttr);
DWORD dbClassCacheToObjectClassDescription(THSTATE *pTHS,
                                           CLASSCACHE *pCCs,
                                           BOOL bExtendedFormat,
                                           ATTRVAL *pAVal);
DWORD dbAttCacheToAttributeTypeDescription(THSTATE *pTHS,
                                           ATTCACHE *pCC,
                                           BOOL bExtendedFormat,
                                           ATTRVAL *pAVal);
DWORD dbClassCacheToDitContentRules(THSTATE *pTHS,
                                    CLASSCACHE *pCC,
                                    BOOL bExtendedFormat,
                                    CLASSCACHE **pAuxCC,
                                    DWORD        auxCount,
                                    ATTRVAL *pAVal);
DWORD dbAuxClassCacheToDitContentRules(THSTATE *pTHS,
                                       CLASSCACHE *pCC,
                                       CLASSCACHE **pAuxCC,
                                       DWORD        auxCount,
                                       PWCHAR  *pAuxBuff,
                                       DWORD   *pcAuxBuff);
DWORD dbGetGroupRid(THSTATE *pTHS, DSNAME *pDSName, ATTR *pAttr);
DWORD dbGetObjectStructuralClass(THSTATE *pTHS, DSNAME *pDSName,ATTR *pAttr);
DWORD dbGetObjectAuxiliaryClass(THSTATE *pTHS, DSNAME *pDSName,ATTR *pAttr);
DWORD dbGetMsDsKeyVersionNumber(THSTATE * pTHS,DSNAME *pObjDSName, ATTR *pAttr);

DWORD dbGetMsDsQuotaEffective(
	DBPOS * const	pDB,
	PSID			pOwnerSid,
	ATTR * const	pAttr );
DWORD dbGetMsDsQuotaUsed(
	DBPOS * const	pDB,
	PSID			pOwnerSid,
	ATTR * const	pAttr );
DWORD dbGetMsDsTopQuotaUsage(
	DBPOS * const	pDB,
	ATTR * const	pAttr,
	const DWORD		dwBaseIndex,
	DWORD * const	pdwNumRequested,
	const BOOL		fUsingDefaultRange );

DWORD
dbGetSDRightsEffective (
        THSTATE *pTHS,
        DBPOS   *pDB,
        DSNAME *pDSName,
        ATTR   *pAttr
        );
DWORD
dbGetUserAccountControlComputed(
        THSTATE *pTHS,
        DSNAME  * pObjDSName,
        ATTR    *pAttr);
DWORD
dbGetApproxSubordinates(THSTATE * pTHS,
                        DSNAME  * pObjDSName,
                        ATTR    * pAttr);
/* End of forward declarations */

DWORD
dbGetConstructedAtt(
    DBPOS **ppDB,
    ATTCACHE *pAC,
    ATTR *pAttr,
    DWORD dwBaseIndex,
    PDWORD pdwNumRequested,
    const BOOL fUsingDefaultRange,
    PSID psidQuotaTrustee,
    const BOOL fExternal
)

/*+++

  Routine Description:
     Compute the value of the constructed att pointed to by the attcache pAC

  Arguments:
     ppDB - pointer to DBPOS positioned on current object
     pAC - attcache for the constructed att
     pAttr - Pointer to ATTR to fill up with the value(s). The ATTR
             structure must be pre-allocated, The routines will allocate
             (THAllocEx) space for values as necessary
     fExternal - If the internal or external form of the value is wanted
                 This is relevant only for the constructed att
                 subschemasubentry which has a DS-DN syntax; for all
                 else the internal and external forms are the same and
                 the flag is ignored
  Return Value:
     0 on success, DB_ERR_NO_VALUE on success with no values to return,
     a DB ERROR on error

---*/

{
    DBPOS    *pDB = (*ppDB);
    THSTATE  *pTHS;
    ULONG     len;
    DWORD     err = 0;
    DSNAME   *pObjDSName;

    pTHS = pDB->pTHS;

    // Get the DSNAME
    err = DBGetAttVal(pDB, 1, ATT_OBJ_DIST_NAME,
                      DBGETATTVAL_fREALLOC,
                      0,
                      &len,
                      (UCHAR **) &pObjDSName);
    if (err) {
         DPRINT1(0,"dbGetConstructedAtt: Error getting obj-dist-name %x\n",
                 err);
         return err;
    }

    // see if it is the subschemasubentry. If so, go to
    // routine to get subschemasubentry atts

    if(pDB->DNT == gAnchor.ulDntLdapDmd) {
        err = dbGetSubschemaAtt(pTHS, pAC, pAttr);
        return err;
    }

    // ok it is a normal object
    // Check what attribute is wanted and call apprrpriate
    // routine
    DPRINT2(1, "{BASE=%ws}{ATTRID=%x}\n", pObjDSName->StringName, pAC->id);
    switch (pAC->id) {
    case ATT_SUBSCHEMASUBENTRY:
        err = dbGetSubSchemaSubEntry(pTHS, pAttr, fExternal);
        break;
    case ATT_CANONICAL_NAME:
        err = dbGetCanonicalName(pTHS, pObjDSName, pAttr);
        break;
    case ATT_ALLOWED_CHILD_CLASSES:
        err = dbGetAllowedChildClasses(pTHS, pObjDSName, pAttr, 0);
        break;
    case ATT_SD_RIGHTS_EFFECTIVE:
        err = dbGetSDRightsEffective(pTHS,
                                     pDB,
                                     pObjDSName,
                                     pAttr);
        break;
    case ATT_ALLOWED_CHILD_CLASSES_EFFECTIVE:
        err = dbGetAllowedChildClasses(pTHS,
                                       pObjDSName,
                                       pAttr,
                                       SC_CHILDREN_USE_SECURITY);
        break;
    case ATT_ALLOWED_ATTRIBUTES:
        err = dbGetAllowedAttributes(pTHS, pObjDSName, pAttr, FALSE);
        break;
    case ATT_ALLOWED_ATTRIBUTES_EFFECTIVE:
        err = dbGetAllowedAttributes(pTHS, pObjDSName, pAttr, TRUE);
        break;

    case ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS_BINARY:
    case ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS_BINARY:
    case ATT_MS_DS_NC_REPL_CURSORS_BINARY:
    case ATT_MS_DS_REPL_ATTRIBUTE_META_DATA_BINARY:
    case ATT_MS_DS_REPL_VALUE_META_DATA_BINARY:
        DPRINT (1, "Getting BINARY repl attrs\n");
        DPRINT3(1, "dbGetConstructedAtt = %x %d-%d\n", pAC->id, dwBaseIndex, *pdwNumRequested);
        err = draGetLdapReplInfo(pTHS,
                                 pAC->aliasID,
                                 pObjDSName,
                                 dwBaseIndex,
                                 pdwNumRequested,
                                 FALSE,
                                 pAttr);
        if (pAttr) {
            pAttr->attrTyp = pAC->id;
        }

        break;

    case ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS:
    case ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS:
    case ATT_MS_DS_NC_REPL_CURSORS:
    case ATT_MS_DS_REPL_ATTRIBUTE_META_DATA:
    case ATT_MS_DS_REPL_VALUE_META_DATA:
        DPRINT (1, "Getting XML repl attrs\n");
        DPRINT3(1, "dbGetConstructedAtt = %x %d-%d\n", pAC->id, dwBaseIndex, *pdwNumRequested);
        err = draGetLdapReplInfo(pTHS,
                                 pAC->id,
                                 pObjDSName,
                                 dwBaseIndex,
                                 pdwNumRequested,
                                 TRUE,
                                 pAttr);
// ISSUE-2002/02/27-andygo:  unexplained difference in retr of DRA constructed attrs
// REVIEW:  why isn't this code block from the above case here as well?
//      if (pAttr) {
//          pAttr->attrTyp = pAC->id;
//      }
        break;
    case ATT_POSSIBLE_INFERIORS:
        err = dbGetAllowedChildClasses(pTHS,
            pObjDSName,
            pAttr,
            SC_CHILDREN_USE_GOVERNS_ID);
        break;
    case ATT_FROM_ENTRY:
        err = dbGetFromEntry(pDB, pAttr);
        break;
    case ATT_CREATE_TIME_STAMP:
        err = dbGetCreateTimeStamp(pDB, pAttr);
        break;
    case ATT_MODIFY_TIME_STAMP:
        err = dbGetModifyTimeStamp(pDB, pAttr);
        break;
    case ATT_TOKEN_GROUPS:
        err = dbGetReverseMemberships(pTHS, pObjDSName, pAttr,
                                      FLAG_NO_GC_NOT_ACCEPTABLE);
        break;
    case ATT_TOKEN_GROUPS_GLOBAL_AND_UNIVERSAL:
        // return global/universal sids as if this DC were in native mode
        err = dbGetReverseMemberships(pTHS, pObjDSName, pAttr,
                                        FLAG_NO_GC_NOT_ACCEPTABLE
                                      | FLAG_GLOBAL_AND_UNIVERSAL);
        break;
    case ATT_TOKEN_GROUPS_NO_GC_ACCEPTABLE:
        err = dbGetReverseMemberships(pTHS, pObjDSName, pAttr,
                                      FLAG_NO_GC_ACCEPTABLE);
        break;
    case ATT_PRIMARY_GROUP_TOKEN:
        err = dbGetGroupRid(pTHS, pObjDSName, pAttr);
        break;

    case ATT_STRUCTURAL_OBJECT_CLASS:
        err = dbGetObjectStructuralClass(pTHS, pObjDSName, pAttr);
        break;

    case ATT_MS_DS_AUXILIARY_CLASSES:
        err = dbGetObjectAuxiliaryClass(pTHS, pObjDSName, pAttr);
        break;

    case  ATT_MS_DS_USER_ACCOUNT_CONTROL_COMPUTED:
        err = dbGetUserAccountControlComputed( pTHS, pObjDSName, pAttr);
        break;

    case ATT_MS_DS_APPROX_IMMED_SUBORDINATES:
        err = dbGetApproxSubordinates(pTHS, pObjDSName, pAttr);
        break;
    case ATT_MS_DS_KEYVERSIONNUMBER:
        err = dbGetMsDsKeyVersionNumber(pTHS,pObjDSName,pAttr);
        break;

    case ATT_MS_DS_QUOTA_EFFECTIVE:
        err = dbGetMsDsQuotaEffective( pDB, psidQuotaTrustee, pAttr );
        break;
    case ATT_MS_DS_QUOTA_USED:
        err = dbGetMsDsQuotaUsed( pDB, psidQuotaTrustee, pAttr );
        break;
    case ATT_MS_DS_TOP_QUOTA_USAGE:
        err = dbGetMsDsTopQuotaUsage( pDB, pAttr, dwBaseIndex, pdwNumRequested, fUsingDefaultRange );
        break;

    default:
        // Check for EntryTTL. The Attid for EntryTTL may vary DC to DC
        // because its prefix is not one of the predefined prefixes
        // that were defined before shipping W2K (see prefix.h).
        // The attid for EntryTTL is set in the SCHEMAPTR when the
        // schema is loaded.
        if (pAC->id == ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->EntryTTLId) {
            err = dbGetEntryTTL(pDB, pAttr);
        } else {
            err = DB_ERR_NO_VALUE;
        }
    }
    if (err && err != DB_ERR_NO_VALUE) {
        DPRINT2(0,"Error finding constructed att %x: %x\n", pAC->id, err);
    }

    return err;
}

DWORD
dbGetSubschemaAtt(
    THSTATE *pTHS,
    ATTCACHE *pAC,
    ATTR *pAttr
)

/*+++

  Routine Description:
    Gets a constructed att for the subschemasubentry

  Arguments:
    pAC - AttCache of the constructed att
    pAttr - ATTR structure to fill up with the value(s)

  Return Value:
    0 on success, DB_ERR_NO_VALUE on succes with no values to return,
    a DB ERROR on failure

---*/

{
    ULONG err = 0;

   switch (pAC->id) {
     case ATT_OBJECT_CLASSES:
       err = dbGetObjectClasses(pTHS, pAttr, FALSE);
       break;
     case ATT_EXTENDED_CLASS_INFO:
       err = dbGetObjectClasses(pTHS, pAttr, TRUE);
       break;
     case ATT_ATTRIBUTE_TYPES:
       err = dbGetAttributeTypes(pTHS, pAttr, FALSE);
       break;
     case ATT_EXTENDED_ATTRIBUTE_INFO:
       err = dbGetAttributeTypes(pTHS, pAttr, TRUE);
       break;
     case ATT_DIT_CONTENT_RULES:
       err = dbGetDitContentRules(pTHS, pAttr, TRUE);
       break;
     case ATT_MODIFY_TIME_STAMP:
       err = dbGetSubSchemaModifyTimeStamp(pTHS, pAttr);
       break;
     default:
       err = DB_ERR_NO_VALUE;
   }

   return err;
}



/*+++

   The Routines below each compute a particular constructed att.

   They all return 0  on success, a DB ERROR on failure

---*/


DWORD
dbGetSubSchemaSubEntry(
    THSTATE *pTHS,
    ATTR *pAttr,
    BOOL fExternal
)

/*+++

   Compute the subschemasubentry attribute

---*/

{
    ULONG DNT = 0, len = gAnchor.pLDAPDMD->structLen;

    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, sizeof(ATTRVAL));
    if ( !fExternal ) {
       // they just want the DNT

       DBPOS *pDB;
       int err = 0;

       DBOpen2(FALSE, &pDB);
       __try {
           if( err = DBFindDSName(pDB, gAnchor.pLDAPDMD) ) {
               DPRINT(0, "Cannot find LDAP DMD in dit\n");
              __leave;
           }
           else {
             DNT = pDB->DNT;
           }
       }
       __finally {
           DBClose(pDB, FALSE);
       }
       if (err) {
          return err;  // this is already a DB ERROR
       }
       // no error, so we got a dnt.
       Assert(DNT);

       pAttr->AttrVal.pAVal[0].valLen = sizeof(ULONG);
       pAttr->AttrVal.pAVal[0].pVal = (PUCHAR) THAllocEx(pTHS, sizeof(ULONG));
       memcpy(pAttr->AttrVal.pAVal[0].pVal, &DNT, sizeof(ULONG));
    }
    else {
       // Send bak the DSNAME
       pAttr->AttrVal.pAVal[0].valLen = len;
       pAttr->AttrVal.pAVal[0].pVal = (PUCHAR) THAllocEx(pTHS, len);
       memcpy(pAttr->AttrVal.pAVal[0].pVal, gAnchor.pLDAPDMD, len);
    }

    return 0;
}

DWORD
dbGetCanonicalName(
    THSTATE *pTHS,
    DSNAME *pDSName,
    ATTR *pAttr
)

/*+++

   Compute the canonical name

---*/

{
    WCHAR       *pNameString[1];
    WCHAR       *pName;
    PDS_NAME_RESULTW pResults = NULL;
    DWORD       err = 0, NameSize;

    // turn the DS name into a canonical name

    pNameString[0] = (WCHAR *)&(pDSName->StringName);

    err = DsCrackNamesW( (HANDLE) -1,
                         (DS_NAME_FLAG_PRIVATE_PURE_SYNTACTIC |
                             DS_NAME_FLAG_SYNTACTICAL_ONLY),
                         DS_FQDN_1779_NAME,
                         DS_CANONICAL_NAME,
                         1,
                         pNameString,
                         &pResults);

    if ( err                                // error from the call
          || !(pResults->cItems)            // no items returned
          || (pResults->rItems[0].status)   // DS_NAME_ERROR returned
          || !(pResults->rItems[0].pName)   // No name returned
       ) {

        DPRINT(0,"dbGetCanonicalName: error cracking name\n");
        if (pResults) {
           DsFreeNameResultW(pResults);
        }
        return DB_ERR_UNKNOWN_ERROR;
    }

    pName = pResults->rItems[0].pName;
    NameSize = sizeof(WCHAR) * wcslen(pName);

    // Ok, put it in the ATTR structure.
    // Allocate memory from thread heap and copy

    pAttr->AttrVal.valCount = 1;

    // Do the following in try-finally so that we can free pResults
    // even if THAllocEx excepts

    __try {
       pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, sizeof(ATTRVAL));
       pAttr->AttrVal.pAVal[0].valLen = NameSize;
       pAttr->AttrVal.pAVal[0].pVal = (PUCHAR) THAllocEx(pTHS, NameSize);
       memcpy(pAttr->AttrVal.pAVal[0].pVal, pName, NameSize);
    }
    __finally {
       DsFreeNameResultW(pResults);
       pResults = NULL;
    }


    return 0;
}



// NTRAID#NTRAID-550529-2002/02/21-andygo:  SECURITY:  retrieving sDRightsEffective can reveal hidden information via inconsistent error codes
// REVIEW:  shouldn't we return DB_ERR_NOVALUE here on any error?  otherwise, we could reveal that
// REVIEW:  the attr exists but we don't have privileges to read it?
DWORD
dbGetSDRightsEffective (
        THSTATE *pTHS,
        DBPOS   *pDB,
        DSNAME *pDSName,
        ATTR   *pAttr
        )
/*+++

  Compute the allowed access to the SD on this object.

---*/

{
    PSECURITY_DESCRIPTOR pNTSD = NULL;
    DWORD                cbAllocated, cbUsed;
    OBJECT_TYPE_LIST     objList[1];
    DWORD                dwResults[1];
    ATTRTYP              classId;
    CLASSCACHE          *pCC;
    ULONG                error;
    ULONG                SecurityInformation = 0;

    // Get the SD from the current object.
    error = DBGetAttVal(pDB, 1, ATT_NT_SECURITY_DESCRIPTOR, 0, 0, &cbUsed, (UCHAR**) &pNTSD);
    if (error) {
        // Some error we don't handle.  Raise the same exception
        // JetRetrieveColumnSuccess raises.
        // NTRAID#NTRAID-550529-2002/02/21-andygo:  SECURITY:  retrieving sDRightsEffective can reveal hidden information via inconsistent error codes
        // REVIEW:  we used to throw this on severe error/NULL column when we called JRC directly
        // REVIEW:  now we throw it on any error retrieving the SD.  this seems inconsistent.  shouldn't
        // REVIEW:  we fail identically to below?  otherwise, we reveal that someone has recently
        // REVIEW:  changed the SD because the SDProp is working on it...
        RaiseDsaExcept(DSA_DB_EXCEPTION,
                       error,
                       0,
                       DSID(FILENO,__LINE__),
                       DS_EVENT_SEV_MINIMAL);
    }

    cbUsed = 0;
    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl,objclassid,
                             &classId, sizeof(classId), &cbUsed, 0, NULL);

    pCC = SCGetClassById(pTHS, classId);
    if (!pCC) {
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, classId);
    }

    // Now, create the list
    objList[0].Level = ACCESS_OBJECT_GUID;
    objList[0].Sbz = 0;
    objList[0].ObjectType = &(pCC->propGuid);

    // Check access in this Security descriptor. If an error occurs during
    // the process of checking permission access is denied.

    dwResults[0] = 0;
    error = CheckPermissionsAnyClient(
            pNTSD,                      // security descriptor
            pDSName,                    // DSNAME of the object
            pCC,                        // object class
            WRITE_DAC,
            objList,                    // Object Type List
            1,
            NULL,
            dwResults,
            CHECK_PERMISSIONS_WITHOUT_AUDITING,
            NULL,                       // authz client context (grab from THSTATE)
            NULL,                       // additional info
            NULL                        // additional guid
            );

    if(error) {
        THFreeEx(pTHS,pNTSD);
        DPRINT2(1,
                "CheckPermissions returned %d. Access = %#08x denied.\n",
                error,
                WRITE_DAC);

        LogEvent(DS_EVENT_CAT_SECURITY,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_SECURITY_CHECKING_ERROR,
                 szInsertUL(error),
                 szInsertWin32Msg(error),
                 NULL);


        return ERROR_DS_SECURITY_CHECKING_ERROR;         // All Access Denied
    }
    if(dwResults[0] == 0) {
        SecurityInformation |= DACL_SECURITY_INFORMATION;
    }

    dwResults[0] = 0;
    error = CheckPermissionsAnyClient(
            pNTSD,                      // security descriptor
            pDSName,                    // DSNAME of the object
            pCC,                        // object class
            WRITE_OWNER,
            objList,                    // Object Type List
            1,
            NULL,
            dwResults,
            CHECK_PERMISSIONS_WITHOUT_AUDITING,
            NULL,                       // authz client context (grab from THSTATE)
            NULL,                       // additional info
            NULL                        // additional guid
            );

    if(error) {
        THFreeEx(pTHS,pNTSD);
        DPRINT2(1,
                "CheckPermissions returned %d. Access = %#08x denied.\n",
                error,
                WRITE_OWNER);

        LogEvent(DS_EVENT_CAT_SECURITY,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_SECURITY_CHECKING_ERROR,
                 szInsertUL(error),
                 szInsertWin32Msg(error),
                 NULL);


        return ERROR_DS_SECURITY_CHECKING_ERROR;         // All Access Denied
    }
    if(dwResults[0] == 0) {
        SecurityInformation |= (OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION  );
    }

    dwResults[0] = 0;
    error = CheckPermissionsAnyClient(
            pNTSD,                      // security descriptor
            pDSName,                    // DSNAME of the object
            pCC,                        // object class
            ACCESS_SYSTEM_SECURITY,
            objList,                    // Object Type List
            1,
            NULL,
            dwResults,
            CHECK_PERMISSIONS_WITHOUT_AUDITING,
            NULL,                       // authz client context (grab from THSTATE)
            NULL,                       // additional info
            NULL                        // additional guid
            );

    THFreeEx(pTHS,pNTSD);
    if(error) {
        DPRINT2(1,
                "CheckPermissions returned %d. Access = %#08x denied.\n",
                error,
                ACCESS_SYSTEM_SECURITY);

        LogEvent(DS_EVENT_CAT_SECURITY,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_SECURITY_CHECKING_ERROR,
                 szInsertUL(error),
                 szInsertWin32Msg(error),
                 NULL);


        return ERROR_DS_SECURITY_CHECKING_ERROR;         // All Access Denied
    }
    if(dwResults[0] == 0) {
        SecurityInformation |= SACL_SECURITY_INFORMATION;
    }

    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, sizeof(ATTRVAL));
    pAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
    pAttr->AttrVal.pAVal->pVal = (PUCHAR) THAllocEx(pTHS, sizeof(ULONG));
    *((PULONG)(pAttr->AttrVal.pAVal->pVal)) = SecurityInformation;

    return 0;
}


DWORD
dbGetGroupRid(
    THSTATE *pTHS,
    DSNAME *pDSName,
    ATTR *pAttr
)

/*+++

   Return the Rid of the group

   Return Values:

   0 on success,  DB_ERR_NO_VALUE on succes with no values to return,
   a DB_ERR on failure.

---*/
{

   DBPOS *pDB = pTHS->pDB;
   ULONG i, err = 0, objClass, objRid, cbSid = 0;
   NT4SID domSid, *pSid = NULL;
   CLASSCACHE *pCC;
   BOOL fGroup = FALSE;

   // check if this is indeed a group
   err = DBGetSingleValue(pDB,
                          ATT_OBJECT_CLASS,
                          &objClass,
                          sizeof(objClass),
                          NULL);

   if (err) {
       DPRINT1(0,"dbGetGroupRid: Error retrieving object class %d \n", err);
       return err;
   }

   if (objClass != CLASS_GROUP) {

       // not a Group directly, Check if it inherits from group
       pCC = SCGetClassById(pTHS, objClass);
       if (!pCC) {
           // Unable to get class schema!
           DPRINT1(0,"dbGetGroupRid: Unable to retrieve class cache for class %d", objClass);
           LogUnhandledError(ERROR_DS_OBJECT_CLASS_REQUIRED);
           return DB_ERR_UNKNOWN_ERROR;
       }

       // check if any of the subClassOf values is CLASS_GROUP
       for (i=0; i<pCC->SubClassCount; i++) {
          if ( (pCC->pSubClassOf)[i] == CLASS_GROUP ) {
             fGroup = TRUE;
             break;
          }
       }
   }
   else {
       fGroup = TRUE;
   }

   if (!fGroup) {
      // can query only on a group
      return DB_ERR_NO_VALUE;
   }

   // ok, it is a group. Get the object sid

   err = DBGetAttVal(
                pTHS->pDB,
                1,
                ATT_OBJECT_SID,
                DBGETATTVAL_fREALLOC,
                0,
                &cbSid,
                (PUCHAR *) &pSid);

   if (err) {
       DPRINT1(0,"dbGetGroupRid: Error retrieving object sid %d \n", err);
       return err;
   }

   SampSplitNT4SID(pSid, &domSid, &objRid);

   pAttr->AttrVal.valCount = 1;
   pAttr->AttrVal.pAVal = (ATTRVAL *)THAllocEx(pTHS, sizeof(ATTRVAL));
   pAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
   pAttr->AttrVal.pAVal->pVal = (PUCHAR)THAllocEx(pTHS, sizeof(ULONG));
   memcpy(pAttr->AttrVal.pAVal->pVal, &objRid, sizeof(ULONG));

   return 0;
}

DWORD
dbGetObjectStructuralClass(
    THSTATE *pTHS,
    DSNAME *pDSName,
    ATTR *pAttr)
/*++

   return the structuralObjectClass for the object

   Return Values:

   0 on success,  DB_ERR_NO_VALUE on success with no values to return,
   a DB_ERR on failure.

---*/
{
    DWORD err;
    CLASSCACHE *pCC;
    DWORD  classId;
    DWORD cntClasses, i;

    if ( (err = DBGetSingleValue (pTHS->pDB, ATT_OBJECT_CLASS, &classId, sizeof (classId), NULL)) ||
         !(pCC = SCGetClassById(pTHS, classId)) ) {

        return SetSvcError(SV_PROBLEM_DIR_ERROR,
                           ERROR_DS_MISSING_EXPECTED_ATT);
    }

    pAttr->AttrVal.valCount = cntClasses = pCC->SubClassCount+1;
    pAttr->AttrVal.pAVal = (ATTRVAL *)THAllocEx(pTHS, cntClasses * sizeof(ATTRVAL));

    pAttr->AttrVal.pAVal[0].valLen = sizeof (classId);
    pAttr->AttrVal.pAVal[0].pVal = THAllocEx (pTHS, sizeof (classId));
    *((DWORD *)pAttr->AttrVal.pAVal[0].pVal) = classId;

    for (i=0; i<pCC->SubClassCount; i++) {
        pAttr->AttrVal.pAVal[i+1].valLen = sizeof (classId);
        pAttr->AttrVal.pAVal[i+1].pVal = THAllocEx (pTHS, sizeof (classId));
        *((DWORD *)pAttr->AttrVal.pAVal[i+1].pVal) = pCC->pSubClassOf[i];
    }

    return 0;
}

DWORD
dbGetObjectAuxiliaryClass(
    THSTATE *pTHS,
    DSNAME *pDSName,
    ATTR *pAttr)
/*++

   return the auxiliaryClasses for the object

   Return Values:

   0 on success,  DB_ERR_NO_VALUE on success with no values to return,
   a DB_ERR on failure.

---*/

{
    DWORD          err;
    CLASSCACHE    *pCC;
    DWORD          classId;
    DWORD          cntClasses, i, k;
    ATTCACHE      *pObjclassAC = NULL;
    ATTRTYP       *pObjClasses = NULL;
    DWORD          cObjClasses, cObjClasses_alloced;


    // get the needed information for the objectClass on this object
    if (! (pObjclassAC = SCGetAttById(pTHS, ATT_OBJECT_CLASS)) ) {
        return SetSvcError(SV_PROBLEM_DIR_ERROR,
                           DIRERR_MISSING_EXPECTED_ATT);
        // Bad error, couldn't get objectClass .
    }

    cObjClasses_alloced = 0;

    if (ReadClassInfoAttribute (pTHS->pDB,
                                pObjclassAC,
                                &pObjClasses,
                                &cObjClasses_alloced,
                                &cObjClasses,
                                NULL) ) {
        return pTHS->errCode;
    }

    if (!cObjClasses) {
        return SetSvcError(SV_PROBLEM_DIR_ERROR,
                           DIRERR_MISSING_EXPECTED_ATT);
        // Bad error, couldn't get class data.
    }

    classId = pObjClasses[0];
    if (! (pCC = SCGetClassById(pTHS, classId)) ) {
        return SetSvcError(SV_PROBLEM_DIR_ERROR,
                           DIRERR_MISSING_EXPECTED_ATT);
        // Bad error, couldn't get objectClass .
    }

    // no auxClasses
    if ((pCC->SubClassCount+1) == cObjClasses) {
        return DB_ERR_NO_VALUE;
    }

    // ok, construct a valid response
    pAttr->AttrVal.valCount = cntClasses = cObjClasses-pCC->SubClassCount-1;
    pAttr->AttrVal.pAVal = (ATTRVAL *)THAllocEx(pTHS, cntClasses * sizeof(ATTRVAL));

    for (k=0, i=pCC->SubClassCount; i<(cObjClasses-1); i++, k++) {
        pAttr->AttrVal.pAVal[k].valLen = sizeof (classId);
        pAttr->AttrVal.pAVal[k].pVal = THAllocEx (pTHS, sizeof (classId));
        *((DWORD *)pAttr->AttrVal.pAVal[k].pVal) = pObjClasses[i];
    }

    return 0;
}

DWORD
dbGetAllowedChildClasses(
    THSTATE *pTHS,
    DSNAME *pDSName,
    ATTR *pAttr,
    DWORD flag
)

/*+++

   Compute allowedChildClasses, allowedChildClassesEffective, and
   possibleInferiors. Which one is computed depends on the value of
   flag passed in

   Return Values:

     0                  - success
     DB_ERR_NO_VALUE    - success but no values to return.

     Anything else is an error.

---*/

{
    ULONG        count=0, err = 0, i;
    CLASSCACHE   **pCCs;

    // make the call to get legal children
    err = SCLegalChildrenOfName(
                    pDSName,
                    flag,
                    &count,
                    &pCCs);

    if (err) {
       DPRINT1(0,"dbGetAllowedChildClasses: Error from SCLegalChildrenOfName %x\n", err);

       // If we are searching for possibleInferiors, which is defined only
       // on class-schema objects, return as if no value. Anything else
       // is an unknown error (exactly what we do in ldap head now)

       if (flag & SC_CHILDREN_USE_GOVERNS_ID) {
         // set count to 0 and do nothing
         count = 0;
       }
       else {
         return DB_ERR_UNKNOWN_ERROR;
       }
    }

    if (count) {
       // fill up the ATTR structure with the values
       // This is an OID-valued attribute, so just put in the class id

       pAttr->AttrVal.valCount = count;
       pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, count*sizeof(ATTRVAL));
       for (i=0; i<count; i++) {
          pAttr->AttrVal.pAVal[i].valLen = sizeof(ULONG);
          pAttr->AttrVal.pAVal[i].pVal = (PUCHAR) THAllocEx(pTHS, sizeof(ULONG));
          memcpy(pAttr->AttrVal.pAVal[i].pVal, &((*pCCs)->ClassId), sizeof(ULONG));
          pCCs++;
       }
    }
    else {
         // no values
        return DB_ERR_NO_VALUE;
    }
    return 0;
}



DWORD
dbGetAllowedAttributes(
    THSTATE *pTHS,
    DSNAME *pDSName,
    ATTR *pAttr,
    BOOL fSecurity
)

/*+++

   Compute allowedAttributes and allowedAttributesEffective
   Which one is computed depends on the value of fSecurity passed in

   Return Values:

     0                  - success
     DB_ERR_NO_VALUE    - success but no values to return.

     Anything else is an error.

---*/

{
    ULONG      count=0, err = 0, i;
    ATTCACHE   **pACs;

    // make the call to get legal children
    err = SCLegalAttrsOfName(
                    pDSName,
                    fSecurity,
                    &count,
                    &pACs);

    if (err) {
       DPRINT1(0,"dbGetAllowedAttributes: Error from SCLegalAttrsOfName %x\n", err);
       return DB_ERR_UNKNOWN_ERROR;
    }

    if (count) {
       // Fill up the ATTR structure with the values
       // This is an OID-valued attribute, so just return the att id

       pAttr->AttrVal.valCount = count;
       pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, count*sizeof(ATTRVAL));
       for (i=0; i<count; i++) {
          pAttr->AttrVal.pAVal[i].valLen = sizeof(ULONG);
          pAttr->AttrVal.pAVal[i].pVal = (PUCHAR) THAllocEx(pTHS, sizeof(ULONG));
          memcpy(pAttr->AttrVal.pAVal[i].pVal, &((*pACs)->id), sizeof(ULONG));
          pACs++;
       }
    }
    else {
        // no values
        return DB_ERR_NO_VALUE;
    }
    return 0;
}


DWORD
dbGetFromEntry(
    DBPOS *pDB,
    ATTR *pAttr
)

/*+++

  Compute fromEntry

---*/

{
    THSTATE  *pTHS=pDB->pTHS;
    ULONG iType, err=0;
    BOOL fromEntry;

    err = DBGetSingleValue(pDB,
                        ATT_INSTANCE_TYPE,
                        &iType,
                        sizeof(iType),
                        NULL);
    if (err) {
        DPRINT(0, "Can't retrieve instance type\n");
        return err;
    }
    if(iType & IT_WRITE) {
      fromEntry = TRUE;
    }
    else {
      fromEntry = FALSE;
    }

    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, sizeof(ATTRVAL));
    pAttr->AttrVal.pAVal[0].valLen = sizeof(BOOL);
    pAttr->AttrVal.pAVal[0].pVal = THAllocEx(pTHS, sizeof(BOOL));
    memcpy(pAttr->AttrVal.pAVal[0].pVal, &fromEntry, sizeof(BOOL));

    return 0;
}

DWORD
dbGetCreateTimeStamp(
    DBPOS *pDB,
    ATTR *pAttr
)

/*+++

  Compute createTimeStamp (the value of ATT_WHEN_CREATED)

---*/
{
    THSTATE  *pTHS=pDB->pTHS;
    DSTIME createTime;
    ULONG err=0;

    err = DBGetSingleValue(pDB,
                        ATT_WHEN_CREATED,
                        &createTime,
                        sizeof(createTime),
                        NULL);
    if (err) {
        // WHEN_CREATED must be there
        DPRINT(0, "Can't retrieve when_created\n");
        return err;
    }

    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = (ATTRVAL *)THAllocEx(pTHS, sizeof(ATTRVAL ));
    pAttr->AttrVal.pAVal->valLen = sizeof(DSTIME);
    pAttr->AttrVal.pAVal->pVal = (PUCHAR)THAllocEx(pTHS, sizeof(DSTIME));
    memcpy(pAttr->AttrVal.pAVal->pVal, &createTime, sizeof(DSTIME));

    return 0;
}

DWORD
dbGetEntryTTL(
    DBPOS *pDB,
    ATTR *pAttr
)

/*+++

  Compute EntryTTL (the value of ATT_MS_DS_ENTRY_TIME_TO_DIE)

---*/
{
    THSTATE *pTHS=pDB->pTHS;
    DSTIME  TimeToDie;
    LONG    Secs;
    ULONG   err=0;

    err = DBGetSingleValue(pDB,
                           ATT_MS_DS_ENTRY_TIME_TO_DIE,
                           &TimeToDie,
                           sizeof(TimeToDie),
                           NULL);
    if (err) {
        // ATT_MS_DS_ENTRY_TIME_TO_DIE not present
        return err;
    }

    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = (ATTRVAL *)THAllocEx(pTHS, sizeof(ATTRVAL ));
    pAttr->AttrVal.pAVal->valLen = sizeof(LONG);
    pAttr->AttrVal.pAVal->pVal = (PUCHAR)THAllocEx(pTHS, sizeof(DSTIME));
    TimeToDie -= DBTime();
    if (TimeToDie < 0) {
        // object expired some time ago
        Secs = 0;
    } else if (TimeToDie > MAXLONG) {
        // object will expire in the far distant future
        Secs = MAXLONG;
    } else {
        // object will expire later
        Secs = (LONG)TimeToDie;
    }
    memcpy(pAttr->AttrVal.pAVal->pVal, &Secs, sizeof(LONG));

    return 0;
}


DWORD
dbGetModifyTimeStamp(
    DBPOS *pDB,
    ATTR *pAttr
)

/*+++

  Compute modifyTimeStamp (the value of ATT_WHEN_CHANGED)

---*/
{

    THSTATE  *pTHS=pDB->pTHS;
    DSTIME changeTime;
    ULONG err=0;

    err = DBGetSingleValue(pDB,
                        ATT_WHEN_CHANGED,
                        &changeTime,
                        sizeof(changeTime),
                        NULL);
    if (err) {
        // WHEN_CHANGED must be there
        DPRINT(0, "Can't retrieve when_changed\n");
        return err;
    }

    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = (ATTRVAL *)THAllocEx(pTHS, sizeof(ATTRVAL));
    pAttr->AttrVal.pAVal->valLen = sizeof(DSTIME);
    pAttr->AttrVal.pAVal->pVal = (PUCHAR)THAllocEx(pTHS, sizeof(DSTIME));
    memcpy(pAttr->AttrVal.pAVal->pVal, &changeTime, sizeof(DSTIME));

    return 0;
}

DWORD
dbGetReverseMemberships(
    THSTATE *pTHS,
    DSNAME *pObj,
    ATTR *pAttr,
    ULONG Flag
)

/*+++

  Compute the transitive reverse membership of an user object

    Return Values:

    0                - success
    DB_ERR_NO_VALUE  - success but no values to return

    DB_ERR_*         - failure

---*/
{
    ULONG err, cSid, len, sidLen, i;
    ULONG dntSave;
    PSID *pSid = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG SamFlags;
    BOOLEAN MixedDomain;

    ULONG iClass;

    CLASSCACHE *pCC;
    ATTRTYP attrType;
    DBPOS      *pDB = pTHS->pDB;

    // Make the sam call to get the reverse memberships

    // This is never called from SAM. If it ever changes, the assert
    // below may be hit, in which case we should save and restore
    // the correct values

    Assert(!pTHS->fSAM && !pTHS->fDSA);
    Assert(!pTHS->fSamDoCommit);


    // Check to see if this is referenced by SAM.
    // if it is not, return before closing/starting a transaction

    if ( 0 == DBGetSingleValue(
                    pTHS->pDB,
                    ATT_OBJECT_CLASS,
                    &attrType,
                    sizeof(attrType),
                    NULL) )
    {
        if ( !(pCC = SCGetClassById(pTHS, attrType)) )
        {
            // Failed to get the class cache pointer.
            LogUnhandledError(DIRERR_OBJECT_CLASS_REQUIRED);

            return DB_ERR_UNKNOWN_ERROR;
        }
    }
    else {
        // Failed to get the object class
        LogUnhandledError(DIRERR_OBJECT_CLASS_REQUIRED);

        return DB_ERR_UNKNOWN_ERROR;
    }


    if (!SampSamClassReferenced (pCC, &iClass)) {
        return DB_ERR_NO_VALUE;
    }


    // Note that we allow this attribute only on base searches.
    // Also, all non-constructed atts are already evaluated
    // (constructed atts are evalauted last), so the currency may be
    // needed after we come back for other constructed atts only

    dntSave = pTHS->pDB->DNT;

    Assert(pTHS->transType == SYNC_READ_ONLY);
    Assert(!pTHS->errCode);
    
    SamFlags = SAM_PRESERVE_DBPOS;

    // Return global/universal sids as if this DC were in native mode
    if (!(Flag & FLAG_GLOBAL_AND_UNIVERSAL)) {
        // When in mixed mode, return the sids as if this were an NT4 DC
        status = SamIMixedDomain2(&gAnchor.pDomainDN->Sid,
                                  &MixedDomain);
        if (NT_SUCCESS(status)) {
            if (MixedDomain) {
                SamFlags |= SAM_GET_MEMBERSHIPS_TWO_PHASE | SAM_GET_MEMBERSHIPS_MIXED_DOMAIN;
            } else {
                SamFlags |= SAM_GET_MEMBERSHIPS_TWO_PHASE;
            }
        }
    }
    if (NT_SUCCESS(status)) {
        status = SampGetGroupsForToken(pObj,
                                       SamFlags,
                                      &cSid,
                                      &pSid);
    }

    Assert(pTHS->pDB && (pTHS->pDB == pDB));

    if (NT_SUCCESS(status)) {
       Assert(pTHS->pDB && (pTHS->transType == SYNC_READ_ONLY));
       if (status == STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY) {
          // cannot go to a gc to evaluate universal group
          // memberships, but otherwise succeeded.
          // Return error based on what the user asked for
          if (Flag & FLAG_NO_GC_NOT_ACCEPTABLE) {
             // not acceptable, return error
             return DB_ERR_UNKNOWN_ERROR;
          }
       }
    }
    else {
        return DB_ERR_UNKNOWN_ERROR;
    }

    // restore currency
    DBFindDNT(pTHS->pDB, dntSave);

    // Send the values back
    pAttr->AttrVal.valCount = cSid;
    pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, cSid*sizeof(ATTRVAL));
    for (i=0; i< cSid; i++) {
        sidLen = RtlLengthSid(pSid[i]);
        pAttr->AttrVal.pAVal[i].valLen = sidLen;
        pAttr->AttrVal.pAVal[i].pVal = (PUCHAR) THAllocEx(pTHS, sidLen);
        memcpy(pAttr->AttrVal.pAVal[i].pVal, pSid[i], sidLen);
    }

    // free the sam-allocated sid array. The individual sids are
    // THAlloc'ed, so no need to free them explicitly
    if (cSid) {
        // at least one sid returned, so something allocated
        Assert(pSid);
        THFreeEx(pTHS, pSid);
    } else {
        return DB_ERR_NO_VALUE;
    }

    return 0;
}



DWORD
dbGetObjectClasses(
    THSTATE *pTHS,
    ATTR *pAttr,
    BOOL bExtendedFormat
)

/*+++

  Compute the objectClasses and extendedClassInfo attributes
  of subschemasubentry

---*/

{
   ULONG err = 0, count = 0, i;
   CLASSCACHE           **pCCs, *pCC;

   err = SCEnumNamedClasses(&count,&pCCs);
   if (err) {
      DPRINT1(0,"scGetObjectClasses: SCEnumNamedClasses failed: %x\n",err);
      return DB_ERR_UNKNOWN_ERROR;
   }

   pAttr->AttrVal.valCount = count;
   pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, count*sizeof(ATTRVAL));

   for(i=0; i<count; i++) {
       // for each class cache, convert to the appropriate
       // unicode string value

       err = dbClassCacheToObjectClassDescription (
                        pTHS,
                        *pCCs,
                        bExtendedFormat,
                        &(pAttr->AttrVal.pAVal[i]));
       if (err) {
          DPRINT1(0,"dbGetObjectClasses: Failed to convert class caches: %x\n", err);
          return DB_ERR_UNKNOWN_ERROR;
       }
       pCCs++;
    }

    return 0;
}



DWORD
dbGetAttributeTypes(
    THSTATE *pTHS,
    ATTR *pAttr,
    BOOL bExtendedFormat
)

/*+++

  Compute the attributeTypes and extendedattributeInfo attributes
  of subschemasubentry

---*/

{
   ULONG err = 0, count = 0, i;
   ATTCACHE             **pACs;

   err = SCEnumNamedAtts(&count,&pACs);
   if (err) {
      DPRINT1(0,"scGetAttributeTypes: SCEnumNamedAtts failed: %x\n",err);
      return DB_ERR_UNKNOWN_ERROR;
   }

   pAttr->AttrVal.valCount = count;
   pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, count*sizeof(ATTRVAL));

   for(i=0; i<count; i++) {
       // for each attcache, convert to appropriate
       // unicode string value

       err = dbAttCacheToAttributeTypeDescription (
                        pTHS,
                        *pACs,
                        bExtendedFormat,
                        &(pAttr->AttrVal.pAVal[i]));
       if (err) {
          DPRINT1(0,"dbGetAttributeTypes: Failed to convert att caches: %x\n",
err);
          return DB_ERR_UNKNOWN_ERROR;
       }
       pACs++;
    }

    return 0;
}



DWORD
dbGetDitContentRules(
    THSTATE *pTHS,
    ATTR *pAttr,
    BOOL bExtendedFormat
)

/*+++

  Compute the ditContentRule attributes of subschemasubentry

---*/

{
   ULONG        err = 0, count = 0, valCount = 0, i, auxCount;
   CLASSCACHE  **pCCs, *pCC, **pAuxCCs;
   PWCHAR       pAuxBuff = NULL;
   DWORD        cAuxBuff = 0;
   SCHEMAPTR   *pSchemaPtr;

   pSchemaPtr = (SCHEMAPTR*)(pTHS->CurrSchemaPtr);

   if (!pSchemaPtr->pDitContentRules) {
       EnterCriticalSection(&csDitContentRulesUpdate);
       __try {
           if (!pSchemaPtr->pDitContentRules) {

               DPRINT (1, "Calculating ditContentRules\n");

               err = SCEnumNamedClasses(&count,&pCCs);
               if (err) {
                  DPRINT1(0,"scGetDitContentRules: SCEnumNamedClasses failed: %x\n",err);
                  err = DB_ERR_UNKNOWN_ERROR;
                  __leave;
               }

               err = SCEnumNamedAuxClasses(&auxCount, &pAuxCCs);
               if (err) {
                  DPRINT1(0,"scGetDitContentRules: SCEnumNamedAuxClasses failed: %x\n",err);
                  err = DB_ERR_UNKNOWN_ERROR;
                  __leave;
               }


               if (count) {
                   // allocate memory for max
                   pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, count*sizeof(ATTRVAL));

                  // Ok, we have at least one value to return.
                  // We may not have something to return for all remaining classes,
                  // so count may not be the actual no.of values returned. We will
                  // allocate memory for max though.


                  for(i=0; i<count; i++) {

                      err = dbClassCacheToDitContentRules(
                                       pTHS,
                                       *pCCs,
                                       bExtendedFormat,
                                       pAuxCCs,
                                       auxCount,
                                       &(pAttr->AttrVal.pAVal[valCount]));

                      if (err) {
                         DPRINT1(0,"dbGetDitContentRules: Failed to convert class caches: %x\n", err);
                         err = DB_ERR_UNKNOWN_ERROR;
                         __leave;
                      }

                      valCount++;
                      pCCs++;
                  }

                  pAttr->AttrVal.valCount = valCount;
                }
                else {
                  // no values to return

                  pAttr->AttrVal.valCount = 0;
                  pAttr->AttrVal.pAVal = NULL;
                }

                if (SCCallocWrn(&pSchemaPtr->pDitContentRules, 1, sizeof (ATTRVALBLOCK))) {
                    err = DB_ERR_UNKNOWN_ERROR;
                    __leave;
                }

                pSchemaPtr->pDitContentRules->valCount = pAttr->AttrVal.valCount;

                if (pAttr->AttrVal.valCount) {
                    if (SCCallocWrn(&pSchemaPtr->pDitContentRules->pAVal,
                        pAttr->AttrVal.valCount, sizeof(ATTRVAL))) {
                        SCFree(&pSchemaPtr->pDitContentRules);
                        err = DB_ERR_UNKNOWN_ERROR;
                        __leave;
                    }

                    for (i=0; i<pAttr->AttrVal.valCount; i++) {
                        if (SCCallocWrn(&pSchemaPtr->pDitContentRules->pAVal[i].pVal,
                                     1, pAttr->AttrVal.pAVal[i].valLen)) {
                            for (i=0; i<pAttr->AttrVal.valCount; i++) {
                                SCFree(&pSchemaPtr->pDitContentRules->pAVal[i].pVal);
                            }
                            SCFree(&pSchemaPtr->pDitContentRules->pAVal);
                            SCFree(&pSchemaPtr->pDitContentRules);
                            err = DB_ERR_UNKNOWN_ERROR;
                            __leave;
                        }
                        pSchemaPtr->pDitContentRules->pAVal[i].valLen =
                            pAttr->AttrVal.pAVal[i].valLen;
                        memcpy(pSchemaPtr->pDitContentRules->pAVal[i].pVal,
                               pAttr->AttrVal.pAVal[i].pVal,
                               pAttr->AttrVal.pAVal[i].valLen);
                    }
                }
           }

       }
       __finally {
          LeaveCriticalSection(&csDitContentRulesUpdate);
       }
   }

   if (!err && pSchemaPtr->pDitContentRules) {
       DPRINT (1, "Using cached ditContentRules\n");

       if (pSchemaPtr->pDitContentRules->valCount) {
           pAttr->AttrVal.pAVal =
               THAllocEx(pTHS,
                         pSchemaPtr->pDitContentRules->valCount * sizeof(ATTRVAL));

           pAttr->AttrVal.valCount = pSchemaPtr->pDitContentRules->valCount;

           for (i=0; i<pAttr->AttrVal.valCount; i++) {
               pAttr->AttrVal.pAVal[i].pVal =
                   THAllocEx(pTHS, pSchemaPtr->pDitContentRules->pAVal[i].valLen);
               pAttr->AttrVal.pAVal[i].valLen =
                   pSchemaPtr->pDitContentRules->pAVal[i].valLen;
               memcpy (pAttr->AttrVal.pAVal[i].pVal,
                       pSchemaPtr->pDitContentRules->pAVal[i].pVal,
                       pAttr->AttrVal.pAVal[i].valLen);
           }
       }
       else {
           pAttr->AttrVal.valCount = 0;
           pAttr->AttrVal.pAVal = NULL;
       }
   }
   else {
       err = DB_ERR_UNKNOWN_ERROR;
   }

   return err;
}



DWORD
dbGetSubSchemaModifyTimeStamp(
    THSTATE *pTHS,
    ATTR *pAttr
)

/*+++

  Compute the modifyTimeStamp attribute of subschemasubentry

---*/

{
    DSTIME  timestamp;

    timestamp = SCGetSchemaTimeStamp();
    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = (ATTRVAL *)THAllocEx(pTHS, sizeof(ATTRVAL));
    pAttr->AttrVal.pAVal->valLen = sizeof(DSTIME);
    pAttr->AttrVal.pAVal->pVal = (PUCHAR)THAllocEx(pTHS, sizeof(DSTIME));
    memcpy(pAttr->AttrVal.pAVal->pVal, &timestamp, sizeof(DSTIME));

    return 0;
}



#define BuffCheck(cb)                                                       \
    if((cb) >= BuffSize) {                                                  \
        BuffSize = max(2 * BuffSize, (cb));                                 \
        Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);                  \
    }


DWORD
dbClassCacheToObjectClassDescription(
    THSTATE *pTHS,
    CLASSCACHE *pCC,
    BOOL bExtendedFormat,
    ATTRVAL *pAVal
)

/*+++

   Take a classcache and return the unicode string for the
   class description format for subschemasubentry

---*/
{
    WCHAR      *Buff;
    PUCHAR     pString;
    WCHAR      wBuff[512];
    unsigned   len=0, size = 0, stringLen, i;
    int        oidlen;
    ULONG      BuffSize = 512, *pul;
    CLASSCACHE *pCCSuper;
    ATTCACHE   *pAC=NULL;

    Buff = (WCHAR *)THAllocEx(pTHS, BuffSize);

    BuffCheck((len + 2) * sizeof(WCHAR));
    Buff[len++] = L'(';
    Buff[len++] = L' ';

    oidlen = AttrTypToString (pTHS, pCC->ClassId, wBuff, 512);
    if(oidlen < 0) {
        DPRINT1(0,"dbClassCacheToObjectClassDescription: Failed to convert ClassId %x\n", pCC->ClassId);
        return DB_ERR_UNKNOWN_ERROR;
    } else {

        // copy the OID, start from 4 to avoid the OID. in front
        BuffCheck((len + oidlen - 4) * sizeof(WCHAR));
        memcpy(&Buff[len], &wBuff[4], (oidlen-4)*sizeof(WCHAR));
        len += oidlen - 4;
    }

    BuffCheck(len * sizeof(WCHAR) + NAME_TAG_SIZE);
    memcpy(&Buff[len],NAME_TAG,NAME_TAG_SIZE);
    len += NAME_TAG_SIZE / sizeof(WCHAR);

    // convert the name to wide-char
    BuffCheck((len + pCC->nameLen) * sizeof(WCHAR));
    mbstowcs(&Buff[len],pCC->name,pCC->nameLen);
    len += pCC->nameLen;

    if(!bExtendedFormat) {
        // This is the base format defined in the specs
        if(pCC->ClassId != CLASS_TOP) {

            // Skip superclass iff TOP
            BuffCheck(len * sizeof(WCHAR) + SUP_TAG_SIZE);
            memcpy(&Buff[len],SUP_TAG,SUP_TAG_SIZE);
            len += SUP_TAG_SIZE / sizeof(WCHAR);

            // Get the classes superclass;
            if(!(pCCSuper = SCGetClassById(pTHS, pCC->pSubClassOf[0]))) {
                DPRINT1(0,"dbClassCacheToObjectClassDescription: SCGetClassById failed for class %x\n", pCC->pSubClassOf[0]);

                return DB_ERR_UNKNOWN_ERROR;
            }

            BuffCheck((len + pCCSuper->nameLen + 1) * sizeof(WCHAR));
            mbstowcs(&Buff[len],pCCSuper->name,pCCSuper->nameLen);
            len += pCCSuper->nameLen;
        }
        else {
            // Still need to put in a space
            BuffCheck((len + 2) * sizeof(WCHAR));
            Buff[len++] = L'\'';
            Buff[len++] = L' ';
        }

        switch(pCC->ClassCategory) {
        case DS_88_CLASS:
        case DS_STRUCTURAL_CLASS:
            BuffCheck(len * sizeof(WCHAR) + STRUCTURAL_CLASS_TAG_SIZE);
            memcpy(&Buff[len],STRUCTURAL_CLASS_TAG,STRUCTURAL_CLASS_TAG_SIZE);
            len += STRUCTURAL_CLASS_TAG_SIZE / sizeof(WCHAR);
            break;
        case DS_AUXILIARY_CLASS:
            BuffCheck(len * sizeof(WCHAR) + AUXILIARY_CLASS_TAG_SIZE);
            memcpy(&Buff[len],AUXILIARY_CLASS_TAG,AUXILIARY_CLASS_TAG_SIZE);
            len += AUXILIARY_CLASS_TAG_SIZE / sizeof(WCHAR);
            break;
        case DS_ABSTRACT_CLASS:
            BuffCheck(len * sizeof(WCHAR) + ABSTRACT_CLASS_TAG_SIZE);
            memcpy(&Buff[len],ABSTRACT_CLASS_TAG,ABSTRACT_CLASS_TAG_SIZE);
            len += ABSTRACT_CLASS_TAG_SIZE / sizeof(WCHAR);
            break;
        }

        if(pCC->MyMustCount) {
            // Has must haves.
            BuffCheck(len * sizeof(WCHAR) + MUST_TAG_SIZE);
            memcpy(&Buff[len],MUST_TAG,MUST_TAG_SIZE);
            len += MUST_TAG_SIZE / sizeof(WCHAR);

            // Deal with the list here.
            pul = pCC->pMyMustAtts;
            // Deal with first object, which is slightly different
            if(!(pAC = SCGetAttById(pTHS, *pul))) {
                DPRINT1(0,"dbClassCacheToObjectClassDescription: SCGetAttById failed for  attribute %x\n", *pul);
                return DB_ERR_UNKNOWN_ERROR;
            }
            BuffCheck((len + pAC->nameLen + 1) * sizeof(WCHAR));
            mbstowcs(&Buff[len],pAC->name,pAC->nameLen);
            len += pAC->nameLen;
            Buff[len++] = L' ';

            // Now, the rest
            for(i=1;i<pCC->MyMustCount;i++) {
                pul++;
                if(!(pAC = SCGetAttById(pTHS, *pul))) {
                    DPRINT1(0,"dbClassCacheToObjectClassDescription: SCGetAttById failed for  attribute %x\n", *pul);
                    return DB_ERR_UNKNOWN_ERROR;
                }
                BuffCheck((len + pAC->nameLen + 3) * sizeof(WCHAR));
                Buff[len++] = L'$';
                Buff[len++] = L' ';
                mbstowcs(&Buff[len],pAC->name,pAC->nameLen);
                len += pAC->nameLen;
                Buff[len++] = L' ';
            }
            BuffCheck((len + 1) * sizeof(WCHAR));
            Buff[len++] = L')';
        }

        if(pCC->MyMayCount) {
            // Has may haves.
            BuffCheck(len * sizeof(WCHAR) + MAY_TAG_SIZE);
            memcpy(&Buff[len],MAY_TAG,MAY_TAG_SIZE);
            len += MAY_TAG_SIZE / sizeof(WCHAR);
            // Deal with the list here.
            pul = pCC->pMyMayAtts;

            // Deal with first object, which is slightly different
            if(!(pAC = SCGetAttById(pTHS, *pul))) {
                DPRINT1(0,"dbClassCacheToObjectClassDescription: SCGetAttById failed for  attribute %x\n", *pul);
                return DB_ERR_UNKNOWN_ERROR;
            }
            BuffCheck((len + pAC->nameLen + 1) * sizeof(WCHAR));
            mbstowcs(&Buff[len],pAC->name,pAC->nameLen);
            len += pAC->nameLen;
            Buff[len++] = L' ';

            // Now, the rest
            for(i=1;i<pCC->MyMayCount;i++) {
                pul++;
                if(!(pAC = SCGetAttById(pTHS, *pul))) {
                    DPRINT1(0,"dbClassCacheToObjectClassDescription: SCGetAttById failed for  attribute %x\n", *pul);
                    return DB_ERR_UNKNOWN_ERROR;
                }
                BuffCheck((len + pAC->nameLen + 3) * sizeof(WCHAR));
                Buff[len++] = L'$';
                Buff[len++] = L' ';
                mbstowcs(&Buff[len],pAC->name,pAC->nameLen);
                len += pAC->nameLen;
                Buff[len++] = L' ';
            }
            BuffCheck((len + 1) * sizeof(WCHAR));
            Buff[len++] = L')';
        }
    }
    else {
        // This is the Extended Format defined so I can hand back property
        // page identifiers and anything else I think of
        BYTE      *pByte;
        CHAR      acTemp[256];
        CHAR      acTempLen = 1;

        // Now, the class guid

        pByte = (BYTE *)&(pCC->propGuid);
        for(i=0;i<sizeof(GUID);i++) {
            sprintf(&acTemp[i*2],"%02X",pByte[i]);
        }
        acTempLen=2*sizeof(GUID);
        BuffCheck((len + acTempLen + 1) * sizeof(WCHAR) + CLASS_GUID_TAG_SIZE);
        memcpy(&Buff[len],CLASS_GUID_TAG,CLASS_GUID_TAG_SIZE);
        len += CLASS_GUID_TAG_SIZE / sizeof(WCHAR);
        mbstowcs(&Buff[len], acTemp, acTempLen);
        len += acTempLen;
        Buff[len] = L'\'';
        len++;
    }

    BuffCheck(len * sizeof(WCHAR) + END_TAG_SIZE);
    memcpy(&Buff[len],END_TAG,END_TAG_SIZE);
    len += END_TAG_SIZE / sizeof(WCHAR);

    Assert(len < BuffSize);
    Assert(Buff[len] == 0);

    pAVal->pVal = (PUCHAR) Buff;

    pAVal->valLen = len*sizeof(WCHAR);

    return 0;
}



DWORD
dbAttCacheToAttributeTypeDescription(
    THSTATE *pTHS,
    ATTCACHE *pAC,
    BOOL bExtendedFormat,
    ATTRVAL *pAVal
)

/*+++

   Take a attcache and return the unicode string for the
   attribute description format for subschemasubentry

---*/

{
    WCHAR    *Buff;
    WCHAR    *pString;
    WCHAR    wBuff[512];
    unsigned len=0, size = 0, stringLen, i;
    int      oidlen;
    ULONG    BuffSize = 512, *pul;

    Buff = (WCHAR *)THAllocEx(pTHS, BuffSize);

    BuffCheck((len + 2) * sizeof(WCHAR));
    Buff[len++] = L'(';
    Buff[len++] = L' ';

    oidlen = AttrTypToString(pTHS, pAC->Extid, wBuff, 512);
    if(oidlen < 0) {
        DPRINT1(0,"dbAttCacheToObjectClassDescription: Failed to convert Id %x\n", pAC->id);
        return DB_ERR_UNKNOWN_ERROR;
    } else {

        // copy the OID, start from 4 to avoid the OID. in front
        BuffCheck((len + oidlen - 4) * sizeof(WCHAR));
        memcpy(&Buff[len], &wBuff[4], (oidlen-4)*sizeof(WCHAR));
        len += oidlen - 4;
    }

    BuffCheck(len * sizeof(WCHAR) + NAME_TAG_SIZE);
    memcpy(&Buff[len],NAME_TAG,NAME_TAG_SIZE);
    len += NAME_TAG_SIZE / sizeof(WCHAR);

    // convert the name to wide-char
    BuffCheck((len + pAC->nameLen) * sizeof(WCHAR));
    mbstowcs(&Buff[len],pAC->name,pAC->nameLen);
    len += pAC->nameLen;

    if(!bExtendedFormat) {
        // This is the normal format, defined in the standards
        BuffCheck(len * sizeof(WCHAR) + SYNTAX_TAG_SIZE);
        memcpy(&Buff[len],SYNTAX_TAG,SYNTAX_TAG_SIZE);
        len += SYNTAX_TAG_SIZE / sizeof(WCHAR);

        if(pAC->OMsyntax == 127) {
            switch(pAC->syntax) {
            case SYNTAX_DISTNAME_TYPE:
                // DS_C_DS_DN
                pString = SyntaxDN.oid.value;
                stringLen = SyntaxDN.oid.length;
                break;

            case SYNTAX_DISTNAME_BINARY_TYPE:
                if(OIDcmp(&pAC->OMObjClass, &MH_C_OR_NAME)) {
                    // MH_C_OR_NAME
                    pString = SyntaxORName.oid.value;
                    stringLen = SyntaxORName.oid.length;
                }
                else {
                    pString = SyntaxDNBlob.oid.value;
                    stringLen = SyntaxDNBlob.oid.length;
                }
                break;

            case SYNTAX_ADDRESS_TYPE:
                // DS_C_PRESENTATION_ADDRESS
                pString = SyntaxPresentationAddress.oid.value;
                stringLen = SyntaxPresentationAddress.oid.length;
                break;

            case SYNTAX_DISTNAME_STRING_TYPE:
                if(OIDcmp(&pAC->OMObjClass, &DS_C_ACCESS_POINT)) {
                    // DS_C_ACCESS_POINT
                    pString = SyntaxAccessPoint.oid.value;
                    stringLen = SyntaxAccessPoint.oid.length;
                }
                else {
                    pString = SyntaxDNString.oid.value;
                    stringLen = SyntaxDNString.oid.length;
                }
                break;

            case SYNTAX_OCTET_STRING_TYPE:
                // This had better be a replica-link valued object, since that
                // is all we support.
                pString = SyntaxStrings[OM_S_OCTET_STRING].name.value;
                stringLen = SyntaxStrings[OM_S_OCTET_STRING].name.length;
                break;
            default:
                pString = SyntaxStrings[OM_S_NO_MORE_SYNTAXES].name.value;
                stringLen = SyntaxStrings[OM_S_NO_MORE_SYNTAXES].name.length;
                break;
            }
        }
        else if(pAC->OMsyntax == 64) {
            pString = SyntaxDirectoryString.oid.value;
            stringLen = SyntaxDirectoryString.oid.length;
        }
        else if(pAC->OMsyntax == 65) {
            pString = SyntaxInteger8.oid.value;
            stringLen = SyntaxInteger8.oid.length;
        }
        else if(pAC->OMsyntax == 66) {
            pString = SyntaxObjectSD.oid.value;
            stringLen = SyntaxObjectSD.oid.length;
        }
        else if(pAC->OMsyntax > 27) {
            pString = SyntaxStrings[OM_S_NO_MORE_SYNTAXES].oid.value;
            stringLen = SyntaxStrings[OM_S_NO_MORE_SYNTAXES].oid.length;
        }
        else {
            pString = SyntaxStrings[pAC->OMsyntax].oid.value;
            stringLen= SyntaxStrings[pAC->OMsyntax].oid.length;
        }

        BuffCheck((len + 1) * sizeof(WCHAR) + stringLen);
        memcpy(&Buff[len], pString, stringLen);
        len += stringLen / sizeof(WCHAR);
        Buff[len++] = L'\'';

        if(pAC->isSingleValued) {
            BuffCheck(len * sizeof(WCHAR) + SINGLE_TAG_SIZE);
            memcpy(&Buff[len],SINGLE_TAG,SINGLE_TAG_SIZE);
            len += SINGLE_TAG_SIZE / sizeof(WCHAR);
        }

        if(pAC->bSystemOnly) {
            BuffCheck(len * sizeof(WCHAR) + NO_MOD_TAG_SIZE);
            memcpy(&Buff[len],
                   NO_MOD_TAG,
                   NO_MOD_TAG_SIZE);
            len += NO_MOD_TAG_SIZE / sizeof(WCHAR);
        }
    }
    else {
        // This is the Extended Format defined so I can hand back index
        // information, range information, and anything else I think of

        BYTE      *pByte;
        WCHAR     acTemp[256];
        int       acTempLen = 0, acTempSize = 0;

        if(pAC->rangeLowerPresent) {
            // First, make a string with the range lower
            swprintf((WCHAR *)acTemp, L"%d", pAC->rangeLower);
            acTempLen = wcslen(acTemp);
            acTempSize = acTempLen * sizeof(WCHAR);

            BuffCheck(len * sizeof(WCHAR) + RANGE_LOWER_TAG_SIZE + acTempSize);
            memcpy(&Buff[len],RANGE_LOWER_TAG,RANGE_LOWER_TAG_SIZE);
            len += RANGE_LOWER_TAG_SIZE / sizeof(WCHAR);
            memcpy(&Buff[len],acTemp,acTempSize);
            len += acTempLen;
        }

        if(pAC->rangeUpperPresent) {
            // First, make a string with the range upper
            swprintf((WCHAR *)acTemp, L"%d", pAC->rangeUpper);
            acTempLen = wcslen(acTemp);
            acTempSize = acTempLen * sizeof(WCHAR);

            BuffCheck(len * sizeof(WCHAR) + RANGE_UPPER_TAG_SIZE + acTempSize);
            memcpy(&Buff[len],RANGE_UPPER_TAG,RANGE_UPPER_TAG_SIZE);
            len += RANGE_UPPER_TAG_SIZE / sizeof(WCHAR);
            memcpy(&Buff[len],acTemp,acTempSize);
            len += acTempLen;
        }

        // Now the property GUID

        pByte = (BYTE *)&(pAC->propGuid);
        for(i=0;i<sizeof(GUID);i++) {
            swprintf(&acTemp[i*2],L"%02X",pByte[i]);
        }
        acTempLen=2*sizeof(GUID);
        BuffCheck((len + acTempLen) * sizeof(WCHAR) + PROP_GUID_TAG_SIZE);
        memcpy(&Buff[len],PROP_GUID_TAG,PROP_GUID_TAG_SIZE);
        len += PROP_GUID_TAG_SIZE / sizeof(WCHAR);
        memcpy(&Buff[len], acTemp, acTempLen*sizeof(WCHAR));
        len += acTempLen;

        // Now the property set GUID

        pByte = (BYTE *)&(pAC->propSetGuid);
        for(i=0;i<sizeof(GUID);i++) {
            swprintf(&acTemp[i*2],L"%02X",pByte[i]);
        }
        acTempLen=2*sizeof(GUID);
        BuffCheck((len + acTempLen + 1) * sizeof(WCHAR) + PROP_SET_GUID_TAG_SIZE);
        memcpy(&Buff[len],PROP_SET_GUID_TAG,PROP_SET_GUID_TAG_SIZE);
        len+= PROP_SET_GUID_TAG_SIZE / sizeof(WCHAR);
        memcpy(&Buff[len], acTemp, acTempLen*sizeof(WCHAR));
        len += acTempLen;
        Buff[len++] = L'\'';


        if(pAC->fSearchFlags & fATTINDEX) {
            BuffCheck(len * sizeof(WCHAR) + INDEXED_TAG_SIZE);
            memcpy(&Buff[len],INDEXED_TAG,INDEXED_TAG_SIZE);
            len += INDEXED_TAG_SIZE / sizeof(WCHAR);
        }

        if(pAC->bSystemOnly) {
            BuffCheck(len * sizeof(WCHAR) + SYSTEM_ONLY_TAG_SIZE);
            memcpy(&Buff[len],SYSTEM_ONLY_TAG,SYSTEM_ONLY_TAG_SIZE);
            len += SYSTEM_ONLY_TAG_SIZE / sizeof(WCHAR);
        }

    }

    BuffCheck(len * sizeof(WCHAR) + END_TAG_SIZE);
    memcpy(&Buff[len],END_TAG,END_TAG_SIZE);
    len += END_TAG_SIZE / sizeof(WCHAR);

    Assert(len < BuffSize);
    Assert(Buff[len] == 0);

    // Return the value

    pAVal->pVal = (PUCHAR) Buff;

    pAVal->valLen = len*sizeof(WCHAR);

    return 0;
}


DWORD
dbClassCacheToDitContentRules(
    THSTATE *pTHS,
    CLASSCACHE *pCC,
    BOOL bExtendedFormat,
    CLASSCACHE **pAuxCC,
    DWORD        auxCount,
    ATTRVAL *pAVal
)

/*+++

   Take a classcache and return the unicode string for the
   dit content rule description format for subschemasubentry.

   RFC2252 specifies:

      DITContentRuleDescription = "("
          numericoid   ; Structural ObjectClass identifier
          [ "NAME" qdescrs ]
          [ "DESC" qdstring ]
          [ "OBSOLETE" ]
          [ "AUX" oids ]    ; Auxiliary ObjectClasses
          [ "MUST" oids ]   ; AttributeType identifiers
          [ "MAY" oids ]    ; AttributeType identifiers
          [ "NOT" oids ]    ; AttributeType identifiers
         ")"

   We use se the passed in pAuxBuf to generate the AUX specific part of the rule
   cAuxBuff is the number of characters of pAuxBuff buffer.

---*/

{
    WCHAR *Buff;
    WCHAR wBuff[512];
    unsigned len=0, i, k;
    int  oidlen;
    ULONG BuffSize = 512;
    CLASSCACHE *pCCAux, *pCCparent;
    ATTCACHE   *pAC;
    ATTRTYP *pMustHave = NULL, *pMayHave = NULL, *pAttr;
    DWORD    cMustHave=0, cMayHave=0;
    DWORD   err;
    PWCHAR  pAuxBuff = NULL;
    DWORD   cAuxBuff;

    // we want to find the mustHave attributes that are added
    // on this class (pCC) by the various static auxClasses
    // that have been added to this class somewhere in the hierarchy
    //
    // what we have todo inorder to find these attributes, is for
    // each class in the hierarchy, find the specific must have for
    // this particular class, and remove them from the union of all.
    // this way we will end up with only the attributes that were
    // added as an effect of the addition of the auxClass.
    // attributes that are also present in the auxClass, will
    // not be reported
    //
    if (pCC->MustCount) {
        cMustHave = pCC->MustCount;
        pMustHave = THAllocEx (pTHS, cMustHave * sizeof (ATTRTYP));
        memcpy(pMustHave, pCC->pMustAtts, cMustHave * sizeof (ATTRTYP));

        // start by using the current class
        //
        pCCparent=pCC;
        while (pCCparent) {
            for (i=0; i<pCCparent->MyMustCount; i++) {
                for (k=0; k<cMustHave; k++) {

                    // remove the entry if it already there
                    if (pMustHave[k]==pCCparent->pMyMustAtts[i]) {

                        // if the last entry, just adjust the counter
                        if (k==(cMustHave-1)) {
                            cMustHave--;
                        }
                        // otherwise move the rest of the entries
                        else {
                            memmove(&pMustHave[k],
                                    &pMustHave[k+1],
                                    (cMustHave - k - 1)*sizeof(ATTRTYP));
                            cMustHave--;
                        }
                    }
                }
            }

            // get the parent class, if availbale
            if (pCCparent->SubClassCount) {
                if(!(pCCparent = SCGetClassById(pTHS, pCCparent->pSubClassOf[0]))) {
                   DPRINT1(0,"dbClassCacheToDitContentRules: SCGetClassById failed for class %x\n",
                           pCCparent->pSubClassOf[0]);
                   return DB_ERR_UNKNOWN_ERROR;
                }
            }
            else {
                break;
            }
        }

        qsort(pMustHave, cMustHave, sizeof(ATTRTYP), CompareAttrtyp);
    }

    // same as before, but for MAY have attributes
    if (pCC->MayCount) {
        cMayHave = pCC->MayCount;
        pMayHave = THAllocEx (pTHS, cMayHave * sizeof (ATTRTYP));
        memcpy(pMayHave, pCC->pMayAtts, cMayHave * sizeof (ATTRTYP));

        pCCparent=pCC;

        while (pCCparent) {
            for (i=0; i<pCCparent->MyMayCount; i++) {
                for (k=0; k<cMayHave; k++) {
                    if (pMayHave[k]==pCCparent->pMyMayAtts[i]) {
                        if (k==(cMayHave-1)) {
                            cMayHave--;
                        }
                        else {
                            memmove(&pMayHave[k],
                                    &pMayHave[k+1],
                                    (cMayHave - k - 1)*sizeof(ATTRTYP));
                            cMayHave--;
                        }
                    }
                }
            }

            if (pCCparent->SubClassCount) {
                if(!(pCCparent = SCGetClassById(pTHS, pCCparent->pSubClassOf[0]))) {
                   DPRINT1(0,"dbClassCacheToDitContentRules: SCGetClassById failed for class %x\n", pCCparent->pSubClassOf[0]);
                   return DB_ERR_UNKNOWN_ERROR;
                }
            }
            else {
                break;
            }
        }

        qsort(pMayHave, cMayHave, sizeof(ATTRTYP), CompareAttrtyp);
    }

    // now start converting to text

    Buff = (WCHAR *)THAllocEx(pTHS, BuffSize);

    BuffCheck((len + 2) * sizeof(WCHAR));
    Buff[len++] = L'(';
    Buff[len++] = L' ';

    oidlen = AttrTypToString(pTHS, pCC->ClassId, wBuff, 512);

    if(oidlen < 0) {
        DPRINT1(0,"dbClassCacheToDitContentRules: Failed to convert ClassId %x\n", pCC->ClassId);
        return DB_ERR_UNKNOWN_ERROR;
    } else {

        // copy the OID, start from 4 to avoid the OID. in front

        BuffCheck((len + oidlen - 4) * sizeof(WCHAR));
        memcpy(&Buff[len], &wBuff[4], (oidlen-4)*sizeof(WCHAR));
        len += oidlen - 4;
    }

    BuffCheck(len * sizeof(WCHAR) + NAME_TAG_SIZE);
    memcpy(&Buff[len],NAME_TAG,NAME_TAG_SIZE);
    len += NAME_TAG_SIZE / sizeof(WCHAR);

    // convert the name to wide-char
    BuffCheck((len + pCC->nameLen + 1) * sizeof(WCHAR));
    mbstowcs(&Buff[len],pCC->name,pCC->nameLen);
    len += pCC->nameLen;
    Buff[len++]='\'';


    // Now, the aux class which was passed in
    if ((pCC->ClassCategory == DS_STRUCTURAL_CLASS ||
         pCC->ClassCategory == DS_88_CLASS)) {

        if (err = dbAuxClassCacheToDitContentRules(pTHS,
                                                   pCC,
                                                   pAuxCC,
                                                   auxCount,
                                                   &pAuxBuff,
                                                   &cAuxBuff) ) {

            DPRINT1(0,"dbAuxClassCacheToDitContentRules: Failed to convert class caches: %x\n", err);
            return DB_ERR_UNKNOWN_ERROR;
        }

        if (cAuxBuff) {
            BuffCheck((len + cAuxBuff) * sizeof(WCHAR));
            memcpy(&Buff[len],pAuxBuff,cAuxBuff*sizeof(WCHAR));
            len += cAuxBuff;
        }

        if (pAuxBuff) {
            THFreeEx (pTHS, pAuxBuff);
            pAuxBuff = NULL;
        }
    }


    if (cMustHave) {
        // Now, the MUST have.
        BuffCheck(len * sizeof(WCHAR) + MUST_TAG_SIZE);
        memcpy(&Buff[len],MUST_TAG,MUST_TAG_SIZE);
        len += MUST_TAG_SIZE / sizeof(WCHAR);


        // Deal with first object, which is slightly different
        pAttr = pMustHave;

        if(!(pAC = SCGetAttById(pTHS, *pAttr))) {
            DPRINT1(0,"dbClassCacheToDitContentRules: SCGetAttById for class %x\n", (*pAttr));
            return DB_ERR_UNKNOWN_ERROR;
        }
        BuffCheck((len + pAC->nameLen + 1) * sizeof(WCHAR));
        mbstowcs(&Buff[len], pAC->name, pAC->nameLen);
        len += pAC->nameLen;
        Buff[len++] = L' ';

        // Now, the rest
        for(i=1;i<cMustHave;i++) {
            pAttr++;
            if(!(pAC = SCGetAttById(pTHS, *pAttr))) {
               DPRINT1(0,"dbClassCacheToDitContentRules: SCGetAttById failed for class %x\n", *pAttr);
               return DB_ERR_UNKNOWN_ERROR;
            }
            BuffCheck((len + pAC->nameLen + 3) * sizeof(WCHAR));
            Buff[len++] = L'$';
            Buff[len++] = L' ';
            mbstowcs(&Buff[len], pAC->name, pAC->nameLen);
            len += pAC->nameLen;
            Buff[len++] = L' ';
        }
        BuffCheck((len + 1) * sizeof(WCHAR));
        Buff[len++] = L')';
    }



    if (cMayHave) {
        // Now, the MAY have.
        BuffCheck(len * sizeof(WCHAR) + MAY_TAG_SIZE);
        memcpy(&Buff[len],MAY_TAG,MAY_TAG_SIZE);
        len += MAY_TAG_SIZE / sizeof(WCHAR);


        // Deal with first object, which is slightly different
        pAttr = pMayHave;

        if(!(pAC = SCGetAttById(pTHS, *pAttr))) {
            DPRINT1(0,"dbClassCacheToDitContentRules: SCGetAttById for class %x\n", (*pAttr));
            return DB_ERR_UNKNOWN_ERROR;
        }
        BuffCheck((len + pAC->nameLen + 1) * sizeof(WCHAR));
        mbstowcs(&Buff[len], pAC->name, pAC->nameLen);
        len += pAC->nameLen;
        Buff[len++] = L' ';

        // Now, the rest
        for(i=1;i<cMayHave;i++) {
            pAttr++;
            if(!(pAC = SCGetAttById(pTHS, *pAttr))) {
               DPRINT1(0,"dbClassCacheToDitContentRules: SCGetAttById failed for class %x\n", *pAttr);
               return DB_ERR_UNKNOWN_ERROR;
            }
            BuffCheck((len + pAC->nameLen + 3) * sizeof(WCHAR));
            Buff[len++] = L'$';
            Buff[len++] = L' ';
            mbstowcs(&Buff[len], pAC->name, pAC->nameLen);
            len += pAC->nameLen;
            Buff[len++] = L' ';
        }
        BuffCheck((len + 1) * sizeof(WCHAR));
        Buff[len++] = L')';
    }


    BuffCheck((len + 1) * sizeof(WCHAR));
    Buff[len++] = L')';

    Assert(len < BuffSize);
    Assert(Buff[len] == 0);


    if (pMustHave) {
        THFreeEx (pTHS, pMustHave);
    }

    if (pMayHave) {
        THFreeEx (pTHS, pMayHave);
    }

    // Return the value

    pAVal->pVal = (PUCHAR) Buff;

    pAVal->valLen = len*sizeof(WCHAR);

    return 0;
}


DWORD
dbAuxClassCacheToDitContentRules(
    THSTATE *pTHS,
    CLASSCACHE *pCC,
    CLASSCACHE **pAuxCC,
    DWORD        auxCount,
    PWCHAR  *pAuxBuff,
    DWORD   *pcAuxBuff
)

/*+++

    Return the AUX class string to be used in generating the ditContentRules
    for each class in dbClassCacheToDitContentRules.

    This string contains all the classes in the pAuxCC excpet pCC

    Takes is an array of all the available auxClasses (pAuxCC)
    returns a buffer of the string generated (pAuxBuff) as well the
    number of chars in this buffer (pcAuxBuff)

---*/

{
    WCHAR *Buff;
    unsigned len=0, i;
    ULONG BuffSize = 512;
    CLASSCACHE *pCCAux;

    Buff = (WCHAR *)THAllocEx(pTHS, BuffSize);

    if (auxCount) {
        // Now, the aux class.
        BuffCheck(len * sizeof(WCHAR) + AUX_TAG_SIZE);
        memcpy(&Buff[len],AUX_TAG,AUX_TAG_SIZE);
        len += AUX_TAG_SIZE / sizeof(WCHAR);


        // Deal with first object, which is slightly different
        i=0;
        if (pCC == pAuxCC[0]) {
            i = 1;
        }

        if (i == auxCount) {
            THFreeEx (pTHS, Buff);
            *pAuxBuff = NULL;
            *pcAuxBuff = 0;
            return 0;
        }

        pCCAux = pAuxCC[i];

        BuffCheck((len + pCCAux->nameLen + 1) * sizeof(WCHAR));
        mbstowcs(&Buff[len], pCCAux->name, pCCAux->nameLen);
        len += pCCAux->nameLen;
        Buff[len++] = L' ';

        i++;

        // Now, the rest
        for(; i<auxCount; i++) {

            pCCAux = pAuxCC[i];

            if (pCCAux == pCC) {
                continue;
            }

            BuffCheck((len + pCCAux->nameLen + 3) * sizeof(WCHAR));
            Buff[len++] = L'$';
            Buff[len++] = L' ';
            mbstowcs(&Buff[len], pCCAux->name, pCCAux->nameLen);
            len += pCCAux->nameLen;
            Buff[len++] = L' ';
        }

        BuffCheck((len + 1) * sizeof(WCHAR));
        Buff[len++] = L')';
    }

    Assert(len < BuffSize);
    Assert(Buff[len] == 0);


    // Return the value
    *pAuxBuff = Buff;
    *pcAuxBuff = len;

    return 0;
}

DWORD
dbGetUserAccountControlComputed(
    THSTATE *pTHS,
    DSNAME  *pObjDSName,
    ATTR    *pAttr
)
/*++

    Get the "userAccountControlComputed" attribute on the user object
    This requires  getting the bit of information if the user is locked
    out or if the user's password is expired

    Return Values:

    0                - success
    DB_ERR_NO_VALUE  - success but no value to return

    DB_ERR_*         - failure

--*/
{

    LARGE_INTEGER LockoutTime, PasswordLastSet,
                  LockoutDuration, MaxPasswordAge,
                  CurrentTime;
    NTSTATUS      NtStatus;
    ULONG         UserAccountControl;
    ULONG         *pUserAccountControlComputed =NULL;
    ULONG         err=0;

    //
    // Get the current time
    //

    NtStatus = NtQuerySystemTime(&CurrentTime);
    if (!NT_SUCCESS(NtStatus)){

        err = DB_ERR_UNKNOWN_ERROR;
        goto Error;
    }

    LockoutTime.QuadPart = 0;
    PasswordLastSet.QuadPart = 0;

    //
    // We are currently positioned on the user object, read the Lockout
    // time and Password last set attributes, Also read user account control
    //

    err = DBGetSingleValue(pTHS->pDB,
                        ATT_LOCKOUT_TIME,
                        &LockoutTime,
                        sizeof(LockoutTime),
                        NULL);
    if (DB_ERR_NO_VALUE == err) {
        //
        // It is O.K to not have a lockout time set on the user object,
        // it simply means that the user is not locked out.
        //

        err=0;

    } else if (err) {

        goto Error;
    }

     err = DBGetSingleValue(pTHS->pDB,
                        ATT_PWD_LAST_SET,
                        &PasswordLastSet,
                        sizeof(PasswordLastSet),
                        NULL);

    if (DB_ERR_NO_VALUE==err) {

        //
        // It is O.K to not have password last set on the user object,
        // it simply means that no password was ever set --> the initial
        // blank password is considered expired.
        //

        err = 0;

    } else if (err) {

        goto Error;
    }

    err = DBGetSingleValue(pTHS->pDB,
                        ATT_USER_ACCOUNT_CONTROL,
                        &UserAccountControl,
                        sizeof(UserAccountControl),
                        NULL);
    if (err) {

        goto Error;
    }


    //
    // Check to see if the given user is
    // in the domain hosted by us. Note that the
    // pObjDSName will have the string name filled in
    // and also have no issues with client supplied DSNames
    // such as spaces etc as it is freshly retrieved from
    // disk by the caller of this routine.
    //

    if (pTHS->pDB->NCDNT !=gAnchor.ulDNTDomain)
    {
        err = DB_ERR_NO_VALUE;
        goto Error;
    }

    MaxPasswordAge = gAnchor.MaxPasswordAge;
    LockoutDuration = gAnchor.LockoutDuration;

    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS,sizeof(ATTRVAL));
    pAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
    pAttr->AttrVal.pAVal->pVal = (PUCHAR)THAllocEx(pTHS, sizeof(ULONG));
    pUserAccountControlComputed = (PULONG)pAttr->AttrVal.pAVal->pVal;
    *pUserAccountControlComputed = 0;

    //
    // Compute the Password Expired bit
    // MaxPasswordAge is stored as a negative
    // delta offset

    if ((!(UserAccountControl & UF_DONT_EXPIRE_PASSWD)) &&
                                                // password on account never expires
        (!(UserAccountControl & UF_SMARTCARD_REQUIRED)) &&
                                                // don't expire password if smartcard
                                                // required -- passwords make no sense
                                                // in that case
        (!(UserAccountControl & UF_MACHINE_ACCOUNT_MASK)))
                                                // passwords don't expire for machines
                                                // reliability issues otherwise
                                                // machines are programmed to change
                                                // passwords periodically
    {
        if ( (0 == PasswordLastSet.QuadPart) ||
             ((0 != MaxPasswordAge.QuadPart) && // zero means no password aging
              (CurrentTime.QuadPart >PasswordLastSet.QuadPart - MaxPasswordAge.QuadPart))
           )
        {
            *pUserAccountControlComputed |= UF_PASSWORD_EXPIRED;
        }
    }

    //
    // Compute the account lockout out bit
    // Again lockout duration is a negative delta time
    //

     if (((LockoutTime.QuadPart - CurrentTime.QuadPart) >
                 LockoutDuration.QuadPart )  &&
          (0!=LockoutTime.QuadPart) && // zero means no lockout
          (!(UserAccountControl & UF_MACHINE_ACCOUNT_MASK)))
                                    // machine accounts do not get locked out
                                    // denial of service implications otherwise,
                                    // password cracking hard as 128 bit random
                                    // passwords chosen.
    {
        *pUserAccountControlComputed |= UF_LOCKOUT;
    }

Error:


    return(err);

}

DWORD
dbGetApproxSubordinates(THSTATE * pTHS,
                        DSNAME  * pObjDSName,
                        ATTR    * pAttr)
{
    ULONG * pNumSubords;
    ULONG oldRootDnt;
    KEY_INDEX *pKeyIndex;

    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS,sizeof(ATTRVAL));
    pAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
    pAttr->AttrVal.pAVal->pVal = (PUCHAR)THAllocEx(pTHS, sizeof(ULONG));
    pNumSubords = (PULONG)pAttr->AttrVal.pAVal->pVal;


    if (!IsAccessGrantedSimple(RIGHT_DS_LIST_CONTENTS, FALSE)) {
        *pNumSubords = 0;
        return 0;
    }

    oldRootDnt = pTHS->pDB->Key.ulSearchRootDnt;
    pTHS->pDB->Key.ulSearchRootDnt = pTHS->pDB->DNT;

    pKeyIndex = dbMakeKeyIndex(pTHS->pDB,
                               FI_CHOICE_SUBSTRING,
                               TRUE,    // bIsSIngleValued
                               dbmkfir_PDNT,
                               SZPDNTINDEX,
                               &idxPdnt,
                               (DB_MKI_USE_SEARCH_TABLE |
                                DB_MKI_GET_NUM_RECS |
                                DB_MKI_SET_CURR_INDEX),
                               0,       // cIndexRanges
                               NULL);

    pTHS->pDB->Key.ulSearchRootDnt = oldRootDnt;
    *pNumSubords = pKeyIndex->ulEstimatedRecsInRange;

    dbFreeKeyIndex(pTHS, pKeyIndex);

    return 0;
}

DWORD
dbGetMsDsKeyVersionNumber(THSTATE * pTHS,
                      DSNAME  * pObjDSName,
                      ATTR    * pAttr)
{
    PLONG pKeyVersionNumber;
    DWORD error;
    PROPERTY_META_DATA_VECTOR *pMetaDataVec = NULL;
    PROPERTY_META_DATA *pMetaData;
    DWORD cb;

    __try {
        error = DBGetAttVal(pTHS->pDB, 
                            1, 
                            ATT_REPL_PROPERTY_META_DATA,
                            0,
                            0,
                            &cb,
                            (UCHAR**)&pMetaDataVec);
        if (error) {
            __leave;
        }
        pMetaData = ReplLookupMetaData(ATT_UNICODE_PWD,
                                       pMetaDataVec,
                                       NULL);
        if (pMetaData == NULL) {
            // no metadata for password? There must be no password then.
            error = DB_ERR_NO_VALUE;
            __leave;
        }

        pAttr->AttrVal.valCount = 1;
        pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS,sizeof(ATTRVAL));
        pAttr->AttrVal.pAVal->valLen = sizeof(LONG);
        pAttr->AttrVal.pAVal->pVal = (PUCHAR)THAllocEx(pTHS, sizeof(LONG));
        pKeyVersionNumber = (PLONG)pAttr->AttrVal.pAVal->pVal;

        *pKeyVersionNumber = (LONG)pMetaData->dwVersion; 
        if (*pKeyVersionNumber<1) {
            *pKeyVersionNumber = 1;
        }
    }
    __finally {
        if (pMetaDataVec) {
            THFreeEx(pTHS, pMetaDataVec);
        }
    }

    return error;
}


//	verifies the current object is truly a Quotas container object
//
DWORD dbCheckMsDsQuotaContainer( DBPOS * const pDB )
	{
	DWORD	err;
	DWORD	dwObjectClass;
	BOOL	fIsCritical;

	err = DBGetSingleValue(
				pDB,
				ATT_OBJECT_CLASS,
				&dwObjectClass, 
				sizeof(dwObjectClass),
				NULL);
	if ( ERROR_SUCCESS == err )
		{
		if ( CLASS_MS_DS_QUOTA_CONTAINER == dwObjectClass )
			{
			//	this is a Quotas container object, but need to
			//	verify that it's the TRUE system Quotas container,
			//	and not some user-created one
			//
			err = DBGetSingleValue(
						pDB,
						ATT_IS_CRITICAL_SYSTEM_OBJECT,
						&fIsCritical,
						sizeof(fIsCritical),
						NULL );
			if ( ERROR_SUCCESS == err && !fIsCritical )
				{
				//	this is a user-created Quotas container object
				//
				err = DB_ERR_NO_VALUE;
				}
			}
		else
			{
			//	this is not a Quotas container object
			//
			err = DB_ERR_NO_VALUE;
			}
		}

	return err;
	}

//	computes effective-quota contructed attribute
//
DWORD dbGetMsDsQuotaEffective(
	DBPOS * const		pDB,
	PSID				pOwnerSid,
	ATTR * const		pAttr )
	{
	DWORD				err					= dbCheckMsDsQuotaContainer( pDB );

	if ( ERROR_SUCCESS == err )
		{
		THSTATE * const	pTHS				= pDB->pTHS;
		ULONG * const	pulEffectiveQuota	= (ULONG *)THAllocEx( pTHS, sizeof(ULONG) );

		pAttr->AttrVal.valCount = 1;
		pAttr->AttrVal.pAVal = (ATTRVAL *)THAllocEx( pTHS, sizeof(ATTRVAL) );

		pAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
		pAttr->AttrVal.pAVal->pVal = (UCHAR *)pulEffectiveQuota;

		err = ErrQuotaQueryEffectiveQuota(
						pDB,
						pDB->NCDNT,
						pOwnerSid,
						pulEffectiveQuota );
		}

	return err;
	}

//	computes quota-used contructed attribute
//
DWORD dbGetMsDsQuotaUsed(
	DBPOS * const		pDB,
	PSID				pOwnerSid,
	ATTR * const		pAttr )
	{
	DWORD				err				= dbCheckMsDsQuotaContainer( pDB );

	if ( ERROR_SUCCESS == err )
		{
		THSTATE * const	pTHS			= pDB->pTHS;
		ULONG * const	pulQuotaUsed	= (ULONG *)THAllocEx( pTHS, sizeof(ULONG) );

		pAttr->AttrVal.valCount = 1;
		pAttr->AttrVal.pAVal = (ATTRVAL *)THAllocEx( pTHS, sizeof(ATTRVAL) );

		pAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
		pAttr->AttrVal.pAVal->pVal = (UCHAR *)pulQuotaUsed;

		err = ErrQuotaQueryUsedQuota(
						pDB,
						pDB->NCDNT,
						pOwnerSid,
						pulQuotaUsed );
		}

	return err;
	}

//	computes top-quota-usage contructed attribute
//
DWORD dbGetMsDsTopQuotaUsage(
	DBPOS * const	pDB,
	ATTR * const	pAttr,
	const DWORD		dwBaseIndex,
	DWORD * const	pdwNumRequested,
	const BOOL		fUsingDefaultRange )
	{
	DWORD			err				= dbCheckMsDsQuotaContainer( pDB );

	if ( ERROR_SUCCESS == err )
		{
		if ( fUsingDefaultRange )
			{
			// special-case: if no range specified, use default
			// top-quota-usage limit
			//
			Assert( 0 == dwBaseIndex );
			*pdwNumRequested = g_ulQuotaTopUsageQueryDefaultEntries;
			}

		err = ErrQuotaQueryTopQuotaUsage(
						pDB,
						pDB->NCDNT,
						dwBaseIndex,
						pdwNumRequested,
						pAttr );

		//  if no values, don't return the attribute
		//
		if ( ERROR_SUCCESS == err
	    	&& 0 == pAttr->AttrVal.valCount )
		    {
			err = DB_ERR_NO_VALUE;
			}
		}

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dblayer\dbescrow.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dbescrow.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file implements escrowed update semantics for the NT5 DS.  Jet
    escrowed updates can only be performed at certain times.  Escrowed updates
    for a given record may only occur outside the scope of a JetPrepareUpdate
    for the same record - even those of outer level transactions.  

    Caution - Jet asserts on such errors in the checked build, but
    does not return an error in either the checked or free build.
    So escrowed update errors can only be detected when using a 
    checked ese.dll or by running the refcount unit test.

    The approach is to cache knowledge of what escrowed updates are desired
    within a begin/end transaction scope, and then apply them just before
    the commit of the outermost transaction.

Author:

    DaveStr     03-Jul-97

Environment:

    User Mode - Win32

Revision History:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>                      

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <mdlocal.h>
#include <dsatools.h>                   // For pTHS
#include "ntdsctr.h"

// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>

// Assorted DSA headers
#include <hiertab.h>
#include "anchor.h"
#include <dsevent.h>
#include <filtypes.h>                   // Def of FI_CHOICE_???
#include "objids.h"                     // Hard-coded Att-ids and Class-ids
#include "usn.h"
#include "drameta.h"
#include "debug.h"                      // standard debugging header
#define DEBSUB "DBESCROW:"              // define the subsystem for debugging

// DBLayer includes
#include "dbintrnl.h"

#include <fileno.h>
#define  FILENO FILENO_DBESCROW

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Miscellaneous defines and typedefs                                   //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#if DBG
#define DNT_INCREMENT           2
#else
#define DNT_INCREMENT           32
#endif

// Initially the DNTs are stored unsorted.  At some future point in time we
// may sort them, but even then linear search is better for small data sets.
// So we define a cutoff above which the DNTs are sorted.

#define LINEAR_SEARCH_CUTOFF    0xffffffff


extern HANDLE hevSDPropagationEvent;

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Function implementations                                             //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
dbEscrowReserveSpace(
    THSTATE     *pTHS,
    ESCROWINFO  *pInfo,
    DWORD       cDNT)

/*++

Routine Description:

    Reserves space for the requested number of DNTs in an ESCROWINFO.
    Uses dbAlloc which is expected to be an exception throwing allocator.
    Thus raises DSA_MEM_EXCEPTION if the space can not be reserved.

Arguments:

    pInfo - Address of ESCROWINFO in which to reserve space.

    cDNT - Count of DNTs to reserve space for.

Return Value:

    None.  Raises DSA_MEM_EXCEPTION on error.

--*/

{
    DWORD   cBytes;
    VOID    *pv;
    DWORD   increment;

    // Test against requested space required, but allocate max of 
    // request and DNT_INCREMENT.

    increment = (DNT_INCREMENT > cDNT) ? DNT_INCREMENT : cDNT;

    if ( NULL == pInfo->rItems )
    {
        Assert((0 == pInfo->cItems) && (0 == pInfo->cItemsMax));

        cBytes = increment * sizeof(ESCROWITEM);
        pInfo->rItems = (ESCROWITEM *) dbAlloc(cBytes);
        pInfo->cItemsMax = increment;
    }
    else if ( (pInfo->cItemsMax - pInfo->cItems) < cDNT )
    {
        cBytes = (pInfo->cItemsMax + increment) * sizeof(ESCROWITEM);
        pv = dbReAlloc(pInfo->rItems, cBytes);
        pInfo->rItems = (ESCROWITEM *) pv;
        pInfo->cItemsMax += increment;
    }

    DPRINT1(2, "Reserved space for %d ESCROWITEMs\n", increment);
}



ESCROWITEM * 
dbEscrowFindDNT(
    THSTATE     *pTHS,
    ESCROWINFO  *pInfo,
    DWORD       DNT,
    BOOL        fAllocateNewIfRequired)

/*++

Routine Description:

    Finds the requested ESCROWITEM in a THSTATE's escrow information.
    Optionally allocates room for an ESCROWITEM if desired/required.

Arguments:

    pInfo - Address of ESCROWINFO in which to find the DNT.

    DNT - DNT to find.

    fAllocateNewIfRequired - Allocation desired flag.

Return Value:

    Address of desired ESCROWITEM or NULL.

--*/

{
    DWORD   i;

    // Search for the DNT - linear search is more efficient for small tables.

    if ( pInfo->cItems <= LINEAR_SEARCH_CUTOFF )
    {
        for ( i = 0; i < pInfo->cItems; i++ )
        {
            if ( DNT == pInfo->rItems[i].DNT )
            {
                DPRINT1(2, "ESCROWITEM for DNT(%d) found\n", DNT);

                return(&pInfo->rItems[i]);
            }
        }
    }
    else
    {
        Assert(!"Sorted ESCROWINFO not implemented.");
    }

    // DNT not found.  

    if ( !fAllocateNewIfRequired )
    {
        return(NULL);
    }

    // Insert new DNT.

    dbEscrowReserveSpace(pTHS, pInfo, 1);

    i = pInfo->cItems;
    pInfo->rItems[i].DNT = DNT;
    pInfo->rItems[i].delta = 0;
    pInfo->rItems[i].ABRefdelta = 0;
    pInfo->cItems += 1;

    DPRINT1(2, "ESCROWITEM for DNT(%d) added\n", DNT);

    return(&pInfo->rItems[i]);
}

BOOL
dbEscrowPreProcessTransactionalData(
    DBPOS   *pDB,
    BOOL    fCommit)

/*++

Routine Description:

    Pre-processes a (nested) transaction's escrowed updates.  The !commit
    case is a no-op as everything gets thrown away during post processing.
    In the case of a nested transaction, we reserve space in the outer
    level transaction so that this level's escrowed updates can be merged
    up w/o allocation during post processing.  In the case of a level 0 
    transaction, the escrowed updates are actually applied to the database.

Arguments:

    pDB - Pointer to DBPOS for which the transaction is being ended.

    fCommit - Flag indicating whether to commit or not.

Return Value:

    True on success, FALSE or exception otherwise.

--*/

{
    THSTATE     *pTHS = pDB->pTHS;
    NESTED_TRANSACTIONAL_DATA *pData;
    ESCROWITEM  *pItem;
    DWORD       i;
    DWORD       err;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pDB));
    Assert(pTHS->JetCache.dataPtr);
    Assert(pTHS->transactionlevel > 0);

    pData = pTHS->JetCache.dataPtr;

    if ( !fCommit )
    {
        // Nothing to do - post processing will discard this level's DNTs.

        NULL;
    }
    else if ( pTHS->transactionlevel > 1 )
    {
        // Committing, to non-zero level.  Reserve space in outer level
        // transaction for this level's DNTs.

        dbEscrowReserveSpace(pTHS,
                             &(pData->pOuter->escrowInfo),
                             pData->escrowInfo.cItems);
    }
    else
    {
        // Committing, level 0 transaction.  Apply escrowed updates now.

        for ( i = 0; i < pData->escrowInfo.cItems; i++ )
        {

            if ((0 != pData->escrowInfo.rItems[i].delta ) ||
                (0 != pData->escrowInfo.rItems[i].ABRefdelta ))
            {
                // Can't use DBFindDNT as that does a DBCancelRec which 
                // does a JetPrepareUpdateEx - exactly what we need 
                // to avoid.

                DBSetCurrentIndex(pDB, Idx_Dnt, NULL, FALSE);
    
                JetMakeKeyEx(pDB->JetSessID, 
                             pDB->JetObjTbl, 
                             &pData->escrowInfo.rItems[i].DNT, 
                             sizeof(pData->escrowInfo.rItems[i].DNT), 
                             JET_bitNewKey);

                err = JetSeekEx(pDB->JetSessID,
                                pDB->JetObjTbl, 
                                JET_bitSeekEQ);

                if ( err )
                {
                    DsaExcept(DSA_DB_EXCEPTION,
                              err,
                              pData->escrowInfo.rItems[i].DNT);
                }

                if(pData->escrowInfo.rItems[i].delta) {
                    Assert(pData->escrowInfo.rItems[i].DNT != NOTOBJECTTAG);
                    JetEscrowUpdateEx(pDB->JetSessID,
                                      pDB->JetObjTbl,
                                      cntid,
                                      &pData->escrowInfo.rItems[i].delta,
                                      sizeof(pData->escrowInfo.rItems[i].delta),
                                      NULL,     // pvOld
                                      0,        // cbOldMax
                                      NULL,     // pcbOldActual
                                      0);       // grbit
                }
                

                
                if(pData->escrowInfo.rItems[i].ABRefdelta) {
                    Assert(gfDoingABRef);
                    if(gfDoingABRef) {
                        JetEscrowUpdateEx(pDB->JetSessID,
                                          pDB->JetObjTbl,
                                          abcntid,
                                          &pData->escrowInfo.rItems[i].ABRefdelta,
                                          sizeof(pData->escrowInfo.rItems[i].ABRefdelta),
                                          NULL,     // pvOld
                                          0,        // cbOldMax
                                          NULL,     // pcbOldActual
                                          0);       // grbit
                    }
                }
                
                DPRINT3(2, 
                        "Applied escrow update of delta(%d), ABRefdelta(%d) for DNT(%d)\n",
                        pData->escrowInfo.rItems[i].delta,
                        pData->escrowInfo.rItems[i].ABRefdelta,
                        pData->escrowInfo.rItems[i].DNT);
            }
        }
    }

    return TRUE;
}

VOID
dbEscrowPostProcessTransactionalData(
    DBPOS   *pDB,
    BOOL    fCommit,
    BOOL    fCommitted)

/*++

Routine Description:

    Post-processes a (nested) transaction's escrowed updates.  In the case 
    of !fCommit they are thrown away.  In the case of a nested transaction
    they are merged into the next outer level transaction's updates w/o 
    doing any exception throwing allocations.  In the case of an level 0 
    transaction, the escrowed updates were already applied to the database
    during pre-processing, so there is nothing to do.  This level's
    ESCROWINFO is cleaned up in all cases.

Arguments:

    fCommit - Flag indicating whether the transaction intended to commit.

    fCommitted - Flag indicating whether the transaction did commit.

Return Value:

    None.

--*/

{
    NESTED_TRANSACTIONAL_DATA *pData;
    ESCROWITEM  *pItem;
    DWORD       i;
    DWORD       err;
    DWORD       cMaxBeforeFind;
    THSTATE     *pTHS = pDB->pTHS;

    Assert(VALID_THSTATE(pTHS));
    Assert(pTHS->JetCache.dataPtr);

    pData = pTHS->JetCache.dataPtr;

    __try
    {
        if ( !fCommitted )
        {
            // Aborted transaction - throw away all the escrowed updates of
            // this (possibly nested) transaction.  But don't do it here
            // since discard of current transaction's ESCROWINFO is common
            // to all paths in this routine.

            NULL;
        }
        else if ( pTHS->transactionlevel > 0 )
        {
            // Committing, to non-zero level.  Propagate the escrowed
            // updates to the outer transaction.

            for ( i = 0; i < pData->escrowInfo.cItems; i++ )
            {
                cMaxBeforeFind = pData->pOuter->escrowInfo.cItemsMax;
                pItem = dbEscrowFindDNT(pTHS,
                                        &(pData->pOuter->escrowInfo), 
                                        pData->escrowInfo.rItems[i].DNT, 
                                        TRUE);

                // Due to reservation during pre-processing, the outer level's
                // ESCROWINFO should not need to have grown for this insertion.

                Assert(cMaxBeforeFind == pData->pOuter->escrowInfo.cItemsMax);
                Assert(    pItem 
                        && (pData->escrowInfo.rItems[i].DNT == pItem->DNT));

                pItem->delta += pData->escrowInfo.rItems[i].delta;
                pItem->ABRefdelta += pData->escrowInfo.rItems[i].ABRefdelta;
            }

        }
        else
        {
            // Committing, level 0 transaction.  Escrowed updates were
            // applied during pre-processing.

            // check for SD events and fireup SD propagator
            if(pDB->SDEvents) {
                if(!pTHS->fSDP) {
                    // We are committing any changes made to the SD Prop table,
                    // and we're not the SD propagator, so we need to signal
                    // the SD propagator that a change may have taken place
                    SetEvent(hevSDPropagationEvent);
                }
                IADJUST(pcSDEvents, pDB->SDEvents);
                // reset pDB->SDEvents in case the pDB is reused
                pDB->SDEvents = 0;
            }

        }
    }
    __finally
    {
        // Strip this transaction's ESCROWINFO out of the linked list.

        if ( NULL != pData->escrowInfo.rItems ) {
            dbFree(pData->escrowInfo.rItems);
        }
    }
}

VOID
dbEscrowPromote(
    DWORD   phantomDNT,
    DWORD   objectDNT)

/*++

Routine Description:

    For use when promoting a phantom to a real object.  Transfers the 
    deltas for the objectDNT to the phantomDNT.  Assumes both phantomDNT
    and objectDNT deltas were applied within the same transaction.

Arguments:

    phantomDNT - DNT of phantom being promoted.

    objectDNT - DNT of object whose delta is to be applied to the phantom.

Return Value:

    None.

--*/

{
    THSTATE     *pTHS = pTHStls;
    ESCROWITEM  *pPhantomItem;
    ESCROWITEM  *pObjectItem;
    ESCROWINFO  *pInfo;
    DWORD       i;

    Assert(VALID_THSTATE(pTHS));
    Assert(pTHS->JetCache.dataPtr);

    pInfo = &(pTHS->JetCache.dataPtr->escrowInfo);

    pObjectItem = dbEscrowFindDNT(pTHS, pInfo, objectDNT, FALSE);

    if ( NULL == pObjectItem )
    {
        DPRINT1(2, 
                "dbEscrowPromote - object DNT(%d) not found\n",
                objectDNT);
        return;
    }

    if (( 0 == pObjectItem->delta ) &&
        ( 0 == pObjectItem->ABRefdelta ))
    {
        DPRINT1(2, 
                "dbEscrowPromote - no deltas for object DNT(%d)\n",
                objectDNT);
        return;
    }

    DPRINT4(2,
            "dbEscrowPromote - moving delta(%d) abdelta(%d) from DNT(%d) to DNT(%d)\n",
            pObjectItem->delta,
            pObjectItem->ABRefdelta,
            objectDNT,
            phantomDNT);

    pPhantomItem = dbEscrowFindDNT(pTHS, pInfo, phantomDNT, TRUE);

    // dbEscrowFindDNT should either find/allocate an ESCROWITEM for us
    // or throw an exception - in which case we wouldn't be here.

    // Since the previous dbEscrowFindDNT call may have realloc'ed the array of
    // escrow items, the pObjectItem pointer we got before may be bad now.  Get
    // it again, just to be safe.
    pObjectItem = dbEscrowFindDNT(pTHS, pInfo, objectDNT, FALSE);    
    if ( NULL == pObjectItem )
    {
        DPRINT1(2, 
                "dbEscrowPromote - object DNT(%d) not found\n",
                objectDNT);
        return;
    }
    Assert(pObjectItem->delta || pObjectItem->ABRefdelta);
    
    Assert(pPhantomItem);
    Assert(phantomDNT == pPhantomItem->DNT);

    pPhantomItem->delta += pObjectItem->delta;
    pPhantomItem->ABRefdelta += pObjectItem->ABRefdelta;

    // Remove objectDNT from the cache.

    i = (DWORD)(pObjectItem - &pInfo->rItems[0]);

    Assert(i < pInfo->cItems);

    if ( 0 == i )
    {
        Assert(1 == pInfo->cItems);
        pInfo->cItems = 0;
    }
    else if ( i == (pInfo->cItems - 1) )
    {
        pInfo->cItems -= 1;
    }
    else
    {
        // Move last item into i-th slot.

        pInfo->cItems -= 1;
        pInfo->rItems[i] = pInfo->rItems[pInfo->cItems];

        // Resort if required.

        if ( pInfo->cItems > LINEAR_SEARCH_CUTOFF )
        {
            Assert(!"Sorted ESCROWINFO not implemented.");
        }
    }
}

VOID
DBAdjustRefCount(
        DBPOS       *pDB,        
        DWORD       DNT,
        long        delta
        )

/*++

Routine Description:

    Updates the transaction-relative escrow cache with the desired delta.

Arguments:

    DNT - DNT to update.

    delta - Delta by which to advance the reference count.

Return Value:

    None.

--*/

{
    THSTATE     *pTHS = pDB->pTHS;
    ESCROWITEM  *pItem;
    DWORD       i;

    Assert(VALID_THSTATE(pTHS));
    Assert(pTHS->JetCache.dataPtr);

    pItem = dbEscrowFindDNT(pTHS,
                            &(pTHS->JetCache.dataPtr->escrowInfo), 
                            DNT, 
                            TRUE);

    // dbEscrowFindDNT should either find/allocate an ESCROWITEM for us
    // or throw an exception - in which case we wouldn't be here.

    Assert(pItem);
    Assert(DNT == pItem->DNT);

    DPRINT4(2, "DNT %d pending refcount adjustment: %d + %d = %d\n",
            DNT, pItem->delta, delta, pItem->delta + delta);

    pItem->delta += delta;
}

VOID
DBAdjustABRefCount (
        DBPOS       *pDB,
        DWORD       DNT,
        long        delta
        )
     
/*++

Routine Description:

    Updates the transaction-relative escrow cache with the desired delta for a
    ABRefcount.

Arguments:

    DNT - DNT to update.

    delta - Delta by which to advance the reference count.

Return Value:

    None.
    Raises exception on error

--*/

{
    THSTATE     *pTHS = pDB->pTHS;
    ESCROWITEM  *pItem, *pWholeCount;
    DWORD       i;

    Assert(VALID_THSTATE(pTHS));
    Assert(pTHS->JetCache.dataPtr);
    Assert(DNT != INVALIDDNT);
    Assert(DNT != NOTOBJECTTAG);
    
    
    if(!gfDoingABRef) {
        return;
    }
    pItem = dbEscrowFindDNT(pTHS,
                            &(pTHS->JetCache.dataPtr->escrowInfo), 
                            DNT, 
                            TRUE);

    // dbEscrowFindDNT may realloc the escrow list, so before doing the
    // dbEscrowFindDNT for the NOTOBJECTTAG, deal with the pointer we just got.
    Assert(pItem);
    Assert(DNT == pItem->DNT);
    pItem->ABRefdelta += delta;

    pWholeCount = dbEscrowFindDNT(pTHS,
                                  &(pTHS->JetCache.dataPtr->escrowInfo), 
                                  NOTOBJECTTAG,
                                  TRUE);
    

    // dbEscrowFindDNT should either find/allocate an ESCROWITEM for us
    // or throw an exception - in which case we wouldn't be here.
    
    Assert(pWholeCount);
    Assert(NOTOBJECTTAG == pWholeCount->DNT);

    pWholeCount->ABRefdelta += delta;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dblayer\dbintrnl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbintrnl.h
//
//--------------------------------------------------------------------------

/*
==========================================================================
**
**  DB layer definitions required only within the DB layer, not to be
**  exported to outside of the DB Layer.
**
==========================================================================
*/

#ifndef _dbintrnl_h_
#define _dbintrnl_h_

/* external variables */
extern  DBPOS *pDBhidden;

extern  char        szUser[];
extern  char        szPassword[];
extern  char        szJetFilePath[];
extern  char        szJetDirectoryPath[];
extern  int     lastattr;
extern  JET_COLUMNID    insttypeid;
extern  JET_COLUMNID    objclassid;
extern  JET_COLUMNID    ntdefsecdescid;
extern  JET_COLUMNID    ntsecdescid;
extern  JET_COLUMNID    dntid;
extern  JET_COLUMNID    pdntid;
extern  JET_COLUMNID    ancestorsid;
extern  JET_COLUMNID    ncdntid;
extern  JET_COLUMNID    objid;
extern  JET_COLUMNID    rdnid;
extern  JET_COLUMNID    rdntypid;
extern  JET_COLUMNID    dscorepropinfoid;
extern  JET_COLUMNID    abcntid;
extern  JET_COLUMNID    cntid;
extern  JET_COLUMNID    deltimeid;
extern  JET_COLUMNID    usnid;
extern  JET_COLUMNID    usnchangedid;
extern  JET_COLUMNID    dsaid;
extern  JET_COLUMNID    isdeletedid;
extern  JET_COLUMNID    IsVisibleInABid;
extern  JET_COLUMNID    iscriticalid;
extern  JET_COLUMNID    cleanid;
// Link table
extern  JET_COLUMNID    linkdntid;
extern  JET_COLUMNID    backlinkdntid;
extern  JET_COLUMNID    linkbaseid;
extern  JET_COLUMNID    linkdataid;
extern  JET_COLUMNID    linkndescid;
// Link value replication
extern  JET_COLUMNID    linkdeltimeid;
extern  JET_COLUMNID    linkusnchangedid;
extern  JET_COLUMNID    linkncdntid;
extern  JET_COLUMNID    linkmetadataid;
// SD propagator
extern  JET_COLUMNID    orderid;
extern  JET_COLUMNID    begindntid;
extern  JET_COLUMNID    trimmableid;
extern  JET_COLUMNID    clientidid;
extern  JET_COLUMNID    sdpropflagsid;
extern  JET_COLUMNID    sdpropcheckpointid;

extern  JET_INSTANCE    jetInstance;
extern  JET_COLUMNID    guidid;
extern  JET_COLUMNID    distnameid;
extern  JET_COLUMNID    sidid;
extern  JET_COLUMNID    ShowInid;
extern  JET_COLUMNID    mapidnid;

// SD table
extern  JET_COLUMNID    sdidid;
extern  JET_COLUMNID    sdhashid;
extern  JET_COLUMNID    sdvalueid;
extern  JET_COLUMNID    sdrefcountid;

// Hidden table columns
extern  JET_COLUMNID dsstateid;
extern  JET_COLUMNID dsflagsid;
extern  JET_COLUMNID jcidBackupUSN;
extern  JET_COLUMNID jcidBackupExpiration;

//	Quota table
//
extern JET_COLUMNID		g_columnidQuotaNcdnt;
extern JET_COLUMNID		g_columnidQuotaSid;
extern JET_COLUMNID		g_columnidQuotaTombstoned;
extern JET_COLUMNID		g_columnidQuotaTotal;

//	Quota Rebuild Progress table
//
extern JET_COLUMNID		g_columnidQuotaRebuildDNTLast;
extern JET_COLUMNID		g_columnidQuotaRebuildDNTMax;
extern JET_COLUMNID		g_columnidQuotaRebuildDone;

//	Quota Audit table
//
extern JET_COLUMNID		g_columnidQuotaAuditNcdnt;
extern JET_COLUMNID		g_columnidQuotaAuditSid;
extern JET_COLUMNID		g_columnidQuotaAuditDnt;
extern JET_COLUMNID		g_columnidQuotaAuditOperation;

// indexes
extern  JET_INDEXID     idxPdnt;
extern  JET_INDEXID     idxRdn;
extern  JET_INDEXID     idxNcAccTypeName;
extern  JET_INDEXID     idxNcAccTypeSid;
extern  JET_INDEXID     idxAncestors;
extern  JET_INDEXID     idxDnt;
extern  JET_INDEXID     idxDel;
extern  JET_INDEXID     idxGuid;
extern  JET_INDEXID     idxSid;
extern  JET_INDEXID     idxProxy;
extern  JET_INDEXID     idxMapiDN;
extern  JET_INDEXID     idxDraUsn;
extern  JET_INDEXID     idxDraUsnCritical;
extern  JET_INDEXID     idxDsaUsn;
extern  JET_INDEXID     idxPhantom;
extern  JET_INDEXID     idxIsDel;
extern  JET_INDEXID     idxClean;
extern  JET_INDEXID     idxInvocationId;

// Link value replication
extern  JET_INDEXID     idxLink;
extern  JET_INDEXID     idxBackLink;
extern  JET_INDEXID     idxBackLinkAll;
extern  JET_INDEXID     idxLinkDel;
extern  JET_INDEXID     idxLinkDraUsn;
extern  JET_INDEXID     idxLinkLegacy;
extern  JET_INDEXID     idxLinkAttrUsn;
// Link value replication

// SD table
extern  JET_INDEXID     idxSDId;
extern  JET_INDEXID     idxSDHash;

// Lingering Object Removal
extern  JET_INDEXID     idxNcGuid;


// bit to use for JetPrepareUpdate(replace)
#define DS_JET_PREPARE_FOR_REPLACE  JET_prepReplaceNoLock

/* string constants for JET */

// Link table
#define SZLINKTABLE "link_table"     /* table for links and backlinks */
#define SZLINKDNT   "link_DNT"   /* DNT of link */
#define SZBACKLINKDNT   "backlink_DNT"   /* DNT of backlink */
#define SZLINKBASE      "link_base"  /* unique ID  of link/backlink pair */
#define SZLINKDATA  "link_data"  /* more data for link/backlink */
#define SZLINKNDESC "link_ndesc"     /* # of descriptors in more data */
// Link Value Replication
#define SZLINKDELTIME "link_deltime"     // Deletion time
#define SZLINKUSNCHANGED "link_usnchanged" // Link USN changed
#define SZLINKNCDNT "link_ncdnt" // Link NC DNT
#define SZLINKMETADATA "link_metadata"     // Link metadata
// Link Value Replication

// Lingering Object Removall
#define SZNCGUIDINDEX "nc_guid_Index" /* nc + guid index */

// SD table
#define SZSDTABLE       "sd_table"      /* table for SDs */
#define SZSDID          "sd_id"         /* SD hash value */
#define SZSDHASH        "sd_hash"       /* SD hash value */
#define SZSDREFCOUNT    "sd_refcount"   /* SD refcount */
#define SZSDVALUE       "sd_value"      /* actual SD data */

//	Quota table
//
#define g_szQuotaTable					"quota_table"		//	table for object owner quotas
#define g_szQuotaColumnNcdnt			"quota_NCDNT"		//	NCDNT of owning object
#define g_szQuotaColumnSid				"quota_SID"			//	SID of owning object
#define g_szQuotaColumnTombstoned		"quota_tombstoned"	//	count of tombstoned objects owned
#define g_szQuotaColumnTotal			"quota_total"		//	count of total objects owned

//	Quota Rebuild Progress table
//
#define g_szQuotaRebuildProgressTable	"quota_rebuild_progress_table"	//	temporary table to track progress of quota rebuild
#define g_szQuotaRebuildColumnDNTLast	"quota_rebuild_DNT_Last"		//	last DNT successfully processed
#define g_szQuotaRebuildColumnDNTMax	"quota_rebuild_DNT_Max"			//	max DNT to process
#define g_szQuotaRebuildColumnDone		"quota_rebuild_fDone"			//	set to TRUE when Quota table completely rebuilt

//	Quota Audit table
//
#define g_szQuotaAuditTable				"quota_audit_table"			//	table for auditing of quota operations
#define g_szQuotaAuditColumnNcdnt		"quota_audit_NCDNT"			//	NCDNT of target object of the operation
#define g_szQuotaAuditColumnSid			"quota_audit_SID"			//	SID of target object of the operation
#define g_szQuotaAuditColumnDnt			"quota_audit_DNT"			//	DNT of target object of the operation
#define g_szQuotaAuditColumnOperation	"quota_audit_operation"		//	quota operation performed for target object

#define SZDATATABLE "datatable"  /* name of JET data table */
#define SZPROPTABLE     "sdproptable"    /* Security Descriptor propagations */
#define SZANCESTORS     "Ancestors_col"  /* name of ancestors blob column */
#define SZDNT       "DNT_col"    /* name of DNT column */
#define SZPDNT      "PDNT_col"   /* name of PDNT column */
#define SZDISPTYPE  "DispTYpeT_col"  /* name of DispType column */
#define SZOBJ       "OBJ_col"    /* name of OBJ column */
#define SZRDNTYP    "RDNtyp_col"     /* name of RDN type column */
#define SZCACHE     "cache_col"  /* name of cache header column */
#define SZCNT       "cnt_col"    /* name of cache header column */
#define SZABCNT     "ab_cnt_col"     /* name of cache header column */
#define SZDELTIME   "time_col"   /* name of delete time column */
#define SZNCDNT     "NCDNT_col"  /* name of NCDNT column */
#define SZCLEAN    "clean_col" /*name of clean column */
#define SZMAPIDN        "ATTe590479"     /* name of legacy mapi dn att */
#define SZ_NC_ACCTYPE_NAME_INDEX "NC_Acc_Type_Name"
#define SZ_NC_ACCTYPE_SID_INDEX "NC_Acc_Type_Sid"
#define SZANCESTORSINDEX "Ancestors_index"
#define SZDNTINDEX  "DNT_index"  /* name of DNT index */
#define SZPDNTINDEX "PDNT_index"     /* name of PDNT index */
#define SZRDNINDEX  "INDEX_00090001" /* name of RDN index */
#define SZDELINDEX      "del_index"      /* OBSOLETE name of time index */
#define SZDELTIMEINDEX  "deltime_index"  /* name of time index */
#define SZOBJCLASS      "ATTc0"          /* name of Object Class col */
#define SZCOMMONNAME    "ATTm3"          /* name of ATT_COMMON_NAME col */
#define SZDISPNAME      "ATTm131085"     /* name of Display Name col */
#define SZDRAUSNNAME    "ATTq131192"     /* name of DRAUSN att */
#define SZDRATIMENAME   "ATTl131075"     /* name of when changed att */
#define SZMETADATA      "ATTk589827"     /* name of meta data att */
#define SZOBJECTVERSION "ATTj131148"     /* name of object version att */
#define SZDSASIGNAME    "ATTk131146"     /* name of DSA signature att */
#define SZSRCUSNNAME    "ATTq131446"     /* name of source usn att */
#define SZINVOCIDNAME   "ATTk131187"     /* name of invocation id att */
#define SZINVOCIDINDEX  "INDEX_00020073" /* name of invocation id index */
#define SZPROXY     "ATTe131282"     /* name of Proxy-Address att */
#define SZPROXYINDEX    "INDEX_000200D2" /* name of Proxy-Address index */
#define SZINSTTYPE  "ATTj131073"     /* name of Instance-Type att */
#define SZNTSECDESC     "ATTp131353"     /* name  NT-Security-Descriptor att */
#define SZDEFNTSECDESC  "ATTk590048"     /* name  NT-Security-Descriptor att */
#define SZSHOWINCONT    "ATTb590468"     /* name of the SHOW-IN att */
#define SZISDELETED "ATTi131120"     /* name of Is-Deleted att */
#define SZLINKID        "ATTj131122"     /* name of ATT_LINK_ID column */
#define SZDMDLOCATION "ATTb131108"       /* name of DMD-Location att */
#define SZHIDDENTABLE   "hiddentable"    /* name of JET hidden table */
#define SZDSA       "dsa_col"    /* name of DSA name column */
#define SZUSN       "usn_col"    /* name of USN column */
#define SZBACKUPUSN       "backupusn_col"  /* name of backup USN column */
#define SZBACKUPEXPIRATION   "backupexpiration_col"   /* name of backup expires column (used for tombstone) */
#define SZDSSTATE   "state_col"  /* Contains the state of the DS = UnInstalled Installed Running Backedup*/
#define SZDSFLAGS   "flags_col"  /* Contains additional Flags used for keeping track of state */

#define SZDRAUSNINDEX   "DRA_USN_index"  /* index for DRA USN */
#define SZDSAUSNINDEX   "INDEX_0002004A" /* index for DSA USN */
#define SZISVISIBLEINAB "IsVisibleInAB"  /* For restricting via index */
// Link indexes
// New programmatic names with ALL are given to the old non-conditional
// indexes. They have must retain their old Jet names.  link_index is the
// primary index and cannot be changed.
// The default indexes, with program names SZLINKINDEX and SZBACKLINKINDEX,
// are redefined to point to the new conditional indexes.
#define SZLINKALLINDEX "link_index"     /* name of link index */
#define SZLINKINDEX "link_present_index"     /* name of link present index */
#define SZBACKLINKALLINDEX "backlink_index" /* name of backlink index */
#define SZBACKLINKINDEX "backlink_present_index" /* name of backlink index */
// Link Value Replication
#define SZLINKDELINDEX "link_del_index"     /* name of link del time index */
#define SZLINKDRAUSNINDEX   "link_DRA_USN_index"  /* index for DRA USN */
#define SZLINKLEGACYINDEX "link_legacy_index"     /* name of link legacy index */
#define SZLINKATTRUSNINDEX   "link_attr_USN_index"  /* index for attr USN */

// SD table indexes
#define SZSDIDINDEX     "sd_id_index"    /* index on SD id values */
#define SZSDHASHINDEX   "sd_hash_index"  /* index on SD hash values */

//	Quota table indexes
//
#define g_szQuotaIndexNcdntSid		"quota_NCDNT_SID_index"		//	index on NCDNT+SID (primary index)

#define SZGUID          "ATTk589826"     /* name of GUID att */
#define SZGUIDINDEX     "INDEX_00090002" /* name of GUID index */
#define SZRDNATT        "ATTm589825"     /* name of RDN att */
#define SZSID           "ATTr589970"     /* name of SID att */
#define SZSIDINDEX      "INDEX_00090092" /* name of SID index */
#define SZACCTYPE       "ATTj590126"     /* name of account type att */
#define SZACCNAME       "ATTm590045"     /* name of account name att */
#define SZDISTNAME      "ATTb49"

#define SZORDER         "order_col"      /* Order column in SD prop table */
#define SZBEGINDNT      "begindnt_col"   /* Begin DNT column in SD prop table */
#define SZTRIMMABLE     "trimmable_col"  /* Trimmable column in SD prop table */
#define SZCLIENTID      "clientid_col"   /* Client id column in SD prop table */
#define SZSDPROPFLAGS   "flags_col"      /* flags column in SD prop table */
#define SZSDPROPCHECKPOINT "checkpoint_col"      /* checkpoint column in SD prop table */

#define SZORDERINDEX    "order_index"    /* Order index in SD prop table */
#define SZTRIMINDEX     "trim_index"     /* Trimmable index, SD prop table */
#define SZCLIENTIDINDEX "clientid_index" /* Client ID index, SD prop table */
#define SZPROXIEDINDEX  "INDEX_000904E1" /* ATT_PROXIED_OBJECT_NAME index */
#define SZSAMACCTINDEX  "INDEX_000900DD" /* ATT_SAM_ACCOUNT_NAME index */
#define SZDISPLAYINDEX  "INDEX_0002000D" /* ATT_DISPLAY_NAME index */
#define SZALTSECIDINDEX "INDEX_00090363" /* ATT_ALT_SECURITY_IDENTITIES index */
#define SZUPNINDEX      "INDEX_00090290" /* ATT_USER_PRINCIPAL_NAME index */
#define SZSPNINDEX      "INDEX_00090303" /* ATT_SERVICE_PRINCIPAL_NAME index */
#define SZMAPIDNINDEX   "INDEX_0009028F" // ATT_LEGACY_EXCHANGE_DN
#define SZSIDHISTINDEX  "INDEX_00090261" /* ATT_SID_HISTORY index */
#define SZPRIMARYGROUPIDINDEX "INDEX_00090062"  /* ATT_PRIMARY_GROUP_ID index */
#define SZDSCOREPROPINFO "ATTl591181"    /* ATT_DS_CORE_PROPAGATION_INFO */
#define SZPHANTOMINDEX  "PhantomIndex"          // Index to find ref phantoms
#define SZDNTDELINDEX   "DNT_IsDeleted_Index"   // OBSOLETE name of the DNT+IsDeleted index
#define SZISDELINDEX    "INDEX_00020030"        // name of the IsDeleted index
#define SZDNTCLEANINDEX "DNT_clean_Index"       // OBSOLETE name of the DNT+clean index
#define SZCLEANINDEX    "clean_index"           // name of the clean index

#define SZTUPLEINDEXPREFIX "INDEX_T_"

#define SZLCLINDEXPREFIX "LCL_"
/* These indices are localized in dbinit.c.  They MUST begin with
 * the prefix defined in SZLCLINDEXPREFIX, so that we can reclaim
 * unnecessary localized indices.
 */

/* name of ABView index */
#define SZABVIEWINDEX                 "LCL_ABVIEW_index"

// SZDRAUSNINDEX above
#define SZDRAUSNCRITICALINDEX  "DRA_USN_CRITICAL_index"
// SZNCDNT above
#define SZUSNCHANGED           "ATTq131192"
#define SZUSNCREATED           "ATTq131091"
#define SZISCRITICAL           "ATTi590692"


/* configuration parameters */
#define DISPNAMEINDXDENSITY     80  /* density of Display Name index */
#define GENERIC_INDEX_DENSITY   90

#define DB_INITIAL_BUF_SIZE 4096

// Attribute search state
#define ATTRSEARCHSTATEUNDEFINED        0
#define ATTRSEARCHSTATELINKS            1
#define ATTRSEARCHSTATEBACKLINKS        2


// values for ulIndexType
#define IndexTypeNone         0 /* index can not be defined on this field   */
#define IndexTypeSingleColumn 1 /* index to be defined on this column alone */



/* structure to map DSA syntax types to JET column types and sizes.
   A colsize of zero indicates a fixed length column (size is inherent).
*/
typedef struct
{
    UCHAR       syntax;
    JET_COLTYP  coltype;
    USHORT      colsize;
    USHORT      cp;
    ULONG       ulIndexType;
} SYNTAX_JET;


extern SYNTAX_JET syntax_jet[];

#define ENDSYNTAX   0xff    /* end of table indicactor */


extern NT4SID *pgdbBuiltinDomain;

// Maximum number of Jet sessions
extern ULONG gcMaxJetSessions;

// Array of uncommitted usns
extern USN * UncUsn;

// Critical section to guard uncommitted usn array
extern CRITICAL_SECTION csUncUsn;

// The following is used by DNRead to do a JetRetrieveColumns call. However,
// dbinit.c needs to touch this object to stuff in column IDs.
extern JET_RETRIEVECOLUMN dnreadColumnInfoTemplate[];

// The following are used by dbAddSDPropTime, but dbinit.c needs to touch them
// to stuff in column IDs.
extern JET_RETRIEVECOLUMN dbAddSDPropTimeReadTemplate[];
extern JET_SETCOLUMN dbAddSDPropTimeWriteTemplate[];

// This is a macro to encapsulate when we should track value metadata
// fLinkedValueReplication is a thread-wide (machine-wide) state that controls
// whether we are recording link metadata.  fScopeLegacyLinks is only
// significant when fLVR is true. It is needed when we have promoted to fLVR
// mode, but are applying a legacy value change that was originated in the old
// mode.  fScopeLegacyLinks is only DBPOS-wide because on a replicated
// write, it is necessary for the incoming values to be applied with legacy
// semantics, but "cascaded originating writes" (ie those triggered locally
// during the application of the replicated write) in separate DBPOS must be
// applied with LVR semantics. Whew!
#define TRACKING_VALUE_METADATA( pDB ) \
( (pDB->pTHS->fLinkedValueReplication) && (!(pDB->fScopeLegacyLinks)) )
#define LEGACY_UPDATE_IN_LVR_MODE( pDB ) \
( (pDB->pTHS->fLinkedValueReplication) && (pDB->fScopeLegacyLinks) )

// Typedef for struct for an array of functions to translate to and from
// internal format and to do comparisons
typedef struct {
    // Internal-to-External format translation function
    // Internal is the DB format (i.e. DNs are represented as DNTs)
    // External is the code/user format (i.e. DNs are represented as DSNAME structs)
    //
    // extTableOp can be either DBSYN_INQ (inquire) or DBSYN_REM (remove value):
    // DBSYN_INQ does the actual translation.
    //
    // DBSYN_REM is called so that extra work can be done for attributes that
    //           reference other data (such as DNs and SDs) and you need to
    //           decrement the refcount.
    //
    // NOTE: DBSYN_REM is not used anywhere (except for one place in dbsetup.c)
    //       A similar functionality is usually achieved by invoking
    //       dbAdjustRefCountByAttVal. So, if you implement a refcounted value
    //       (such as SD or DN), you have to provide the functionality in both
    //       places. One exception with dbAdjustRefCountByAttVal is that it is
    //       not expected to create new rows. This is always achieved by
    //       a ExtIntXXXX(DBSYN_ADD) call.
    //
    // ulUpdateDnt is a hack for backlinks.  The replicator needs to be able to
    // remove backlinks from objects directly, but the ref count for link pairs
    // goes from teh link to the backlink, not the other way around.  This means
    // that the ref count needs to be adjusted on an object other than the object
    // being referenced (specifically, the object which the value is being removed
    // from).  It only has meaning on DSNAME syntaxes, and then is only used for
    // backlinks.
    //
    // jTbl parameter seems to be unused...
    //
    // flags might have some meaning only for certain syntaxes.
    int (*IntExt) (DBPOS FAR *pDB,
                   USHORT extTableOp,
                   ULONG intLen,
                   UCHAR *pIntVal,
                   ULONG *pExtLen,
                   UCHAR **pExtVal,
                   ULONG ulUpdateDnt,
                   JET_TABLEID jTbl,
                   ULONG flags);

    // External-to-Internal format translation function
    //
    // extTableOp can be either DBSYN_INQ (inquire) or DBSYN_ADD (add value):
    // DBSYN_INQ does the actual translation. If the value is refcounted, then
    //           it is also expected to check if the internal value exists in
    //           the table. If not, the function should return DIRERR_OBJ_NOT_FOUND
    //           (this is used in DBReplaceAtt_AC).
    //
    // DBSYN_ADD is called so that extra work can be done for attributes that
    //           reference other data (such as DNs and SDs) and you need to
    //           increment the refcount or create a new row.
    int (*ExtInt) (DBPOS FAR *pDB,
                   USHORT extTableOp,
                   ULONG extLen,
                   UCHAR *pExtVal,
                   ULONG *pIntLen,
                   UCHAR **pIntVal,
                   ULONG ulUpdateDnt,
                   JET_TABLEID jTbl,
                   ULONG flags);

    // value comparison function
    // the comparison is always done on values in internal format
    // Oper can be one of FI_CHOICE_* (see filtypes.h)

    // NOTE: we always compare the second value against the first.
    // so if you are doing a comparison for FI_CHOICE_LESS
    // and you are looking for A < B
    // you should pass A as the second argument and B as the first

    int  (*Eval)  (DBPOS FAR *pDB,
                   UCHAR Oper,
                   ULONG IntLen1,
                   UCHAR *pIntVal1,
                   ULONG IntLen2,
                   UCHAR *pIntVal2);
} DBSyntaxStruct;

// TableOps for gDBSyntax[] conversions.
#define DBSYN_INQ       0
#define DBSYN_ADD       1
#define DBSYN_REM       2

// flags for ExtInt calls
#define EXTINT_NEW_OBJ_NAME 0x1
#define EXTINT_SECRETDATA   0x2
#define EXTINT_UPDATE_PHANTOM 0x4
#define EXTINT_REJECT_TOMBSTONES 0x8

// flags for IntExt calls
// The first 4 bits are reserved for security descriptor flags.
#define INTEXT_BACKLINK     0x10
#define INTEXT_SHORTNAME    0x20
#define INTEXT_MAPINAME     0x40
#define INTEXT_SECRETDATA   0x80
#define INTEXT_WELLKNOWNOBJ 0x100

#define INTEXT_VALID_FLAGS  0x1FF

extern const DBSyntaxStruct gDBSyntax[];


VOID
dbTrackModifiedDNTsForTransaction (
        PDBPOS pDB,
        DWORD NCDNT,
        ULONG cAncestors,
        DWORD *pdwAncestors,
        BOOL  fNotifyWaiters,
        DWORD fChangeType
        );

extern TRIBOOL
dbEvalInt (
        DBPOS FAR *pDB,
        BOOL  fUseObjTbl,
        UCHAR Operation,
        ATTRTYP type,
        ULONG valLenFilter,
        UCHAR *pValFilter,
        BOOL  *pbSkip
        );


extern DWORD
dbInitRec(
    DBPOS FAR *pDB
    );

extern VOID
dbInitIndicesToKeep(void);

extern DWORD
dbInitpDB (
        DBPOS FAR *pDB
        );

ULONG dbGetHiddenFlags(CHAR *pFlags, DWORD flagslen);

ULONG dbSetHiddenFlags(CHAR *pFlags, DWORD flagslen);


DWORD
dbUnMarshallRestart (
        DBPOS FAR *pDB,
        PRESTART pArgRestart,
        BYTE *pDBKeyBMCurrent,
        DWORD SearchFlags,
        DWORD *cbDBKeyCurrent,
        DWORD *cbDBBMCurrent,
        DWORD *StartDNT
        );

extern void
dbCheckJet (
        JET_SESID sesid
        );

DWORD
dbGetNthNextLinkVal(
        DBPOS * pDB,
        ULONG sequence,
        ATTCACHE **ppAC,
        DWORD Flags,
        ULONG InBuffSize,
        PUCHAR *ppVal,
        ULONG *pul
        );

extern DB_ERR
dbCloseTempTables (DBPOS *pDB);

extern void
dbFreeKeyIndex(
        THSTATE *pTHS,
        KEY_INDEX *pIndex
        );


extern DB_ERR
dbGetSingleValueInternal (
        DBPOS *pDB,
        JET_COLUMNID colId,
        void * pvData,
        DWORD cbData,
        DWORD *pSizeRead,
        DWORD grbit
        );

extern DWORD
dbGetMultipleColumns (
        DBPOS *pDB,
        JET_RETRIEVECOLUMN **ppOutputCols,
        ULONG *pcOutputCols,
        JET_RETRIEVECOLUMN *pInputCols,
        ULONG cInputCols,
        BOOL fGetValues,
        BOOL fOriginal
        );

extern BOOL
dbGetFilePath (
        UCHAR *pFilePath,
        DWORD dwSize
        );


extern BOOL
dbEvalFilterSecurity (
        DBPOS FAR *pDB,
        CLASSCACHE *pCC,
        PSECURITY_DESCRIPTOR pSD,
        PDSNAME pDN
        );

extern void
dbFlushUncUsns (
        void
        );

extern void
dbUnlockDNs (
        DBPOS *pDB
        );

void
dbReleaseGlobalDNReadCache (
        THSTATE *pTHS
        );

void
dbFlushDNReadCache (
        IN DBPOS *pDB,
        IN DWORD DNT
        );

void
dbResetGlobalDNReadCache (
        THSTATE *pTHS
        );

VOID
dbResetLocalDNReadCache (
        THSTATE *pTHS,
        BOOL fForceClear
        );

VOID
dbAdjustRefCountByAttVal(
        DBPOS    *pDB,
        ATTCACHE *pAC,
        PUCHAR   pVal,
        ULONG    valLen,
        int      adjust);

DWORD
dbGetNextAtt (
        DBPOS *pDB,
        ATTCACHE **ppAC,
        ULONG *pSearchState
        );

BOOL
dbFindIntLinkVal(
    DBPOS FAR *pDB,
    ATTCACHE *pAC,
    ULONG intLen,
    void *pIntVal,
    OUT BOOL *pfPresent
    );

void
dbGetLinkTableData (
        PDBPOS           pDB,
        BOOL             bIsBackLink,
        BOOL             bWarnings,
        DWORD           *pulObjectDnt,
        DWORD           *pulValueDnt,
        DWORD           *pulRecLinkBase
        );

DWORD APIENTRY
dbGetLinkVal(
        DBPOS * pDB,
        ULONG sequence,
        ATTCACHE **ppAC,
        DWORD Flags,
        ULONG InBuffSize,
        PUCHAR *ppVal,
        ULONG *pul);

DWORD
dbAddIntLinkVal (
        DBPOS FAR *pDB,
        ATTCACHE *pAC,
        ULONG intLen,
        void *pIntVal,
        IN VALUE_META_DATA *pMetaDataRemote OPTIONAL
        );

void
dbSetLinkValuePresent(
    IN DBPOS *pDB,
    IN DWORD dwEventCode,
    IN ATTCACHE *pAC,
    IN BOOL fResetDelTime,
    IN VALUE_META_DATA *pMetaDataRemote OPTIONAL
    );

void
dbSetLinkValueAbsent(
    IN DBPOS *pDB,
    IN DWORD dwEventCode,
    IN ATTCACHE *pAC,
    IN PUCHAR pVal,
    IN VALUE_META_DATA *pMetaDataRemote OPTIONAL
    );

DWORD
dbRemIntLinkVal (
        DBPOS FAR *pDB,
        ATTCACHE *pAC,
        ULONG intLen,
        void *pIntVal,
        IN VALUE_META_DATA *pMetaDataRemote OPTIONAL
        );

VOID
dbDecodeInternalDistnameSyntax(
    IN ATTCACHE *pAC,
    IN VOID *pIntVal,
    IN DWORD intLen,
    OUT DWORD *pulBacklinkDnt,
    OUT DWORD *pulLinkBase,
    OUT PVOID *ppvData,
    OUT DWORD *pcbData
    );

UCHAR *
dbGetExtDnForLinkVal(
    IN DBPOS * pDB
    );

#define dbAlloc(size)           THAllocOrgEx(pTHS, size)
#define dbReAlloc(ptr, size)    THReAllocOrgEx(pTHS, ptr, size)
#define dbFree(ptr)             THFreeOrg(pTHS, ptr)

// Subject Table routines.
extern BOOL
dbFIsAnAncestor (
        DBPOS FAR *pDB,
        ULONG ulAncestor
        );

#define SBTGETTAG_fMakeCurrent      (1)
#define SBTGETTAG_fUseObjTbl        (2)
#define SBTGETTAG_fSearchByGuidOnly (4)
#define SBTGETTAG_fAnyRDNType       (8)
extern DWORD
sbTableGetTagFromDSName(
        DBPOS FAR *pDB,
        DSNAME *pName,
        ULONG ulFlags,
        ULONG *pTag,
        struct _d_memname **ppname
        );

extern DWORD
sbTableGetDSName(
        DBPOS FAR *pDB,
        ULONG tag,
        DSNAME **ppName,
        DWORD fFlag
        );

extern DWORD
sbTableAddRef (
        DBPOS FAR *pDB,
        DWORD dwFlags,
        DSNAME *pName,
        ULONG *pTag
        );

void
InPlaceSwapSid(PSID pSid);

// Debug only routines
#if DBG
extern void
dbAddDBPOS (
        DBPOS *pDB,
        JET_SESID sesid
        );

extern void
dbEndDBPOS (
        DBPOS *pDB
        );
#endif

// Replication meta data routines.
void
dbCacheMetaDataVector(
    IN  DBPOS * pDB
    );

void
dbFlushMetaDataVector(
    IN  DBPOS *                     pDB,
    IN  USN                         usn,
    IN  PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote OPTIONAL,
    IN  DWORD                       dwMetaDataFlags
    );

void
dbFreeMetaDataVector(
    IN  DBPOS * pDB
    );


void
dbSetLinkValueMetaData(
    IN  DBPOS *pDB,
    IN  DWORD dwEventCode,
    IN  ATTCACHE *pAC,
    IN  VALUE_META_DATA *pMetaDataLocal,
    IN  VALUE_META_DATA *pMetaDataRemote OPTIONAL,
    IN  DSTIME *ptimeCurrent OPTIONAL
    );

void
dbTouchLinkMetaData(
    IN DBPOS *pDB,
    IN VALUE_META_DATA * pMetaData
    );

BOOL
dbHasAttributeMetaData(
    IN  DBPOS *     pDB,
    IN  ATTCACHE *  pAC
    );

//
// Wrapper routines that call Jet APIs and raise exceptions on all unexpected
// errors

//
// function prototypes
//

JET_ERR
JetInitException (
        JET_INSTANCE *pinstance,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetTermException (
        JET_INSTANCE instance,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetSetSystemParameterException (
        JET_INSTANCE  *pinstance,
        JET_SESID sesid,
        unsigned long paramid,
        unsigned long lParam,
        const char  *sz,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetBeginSessionException (
        JET_INSTANCE instance,
        JET_SESID  *psesid,
        const char  *szUserName,
        const char  *szPassword,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetDupSessionException (
        JET_SESID sesid,
        JET_SESID  *psesid,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetEndSessionException (
        JET_SESID sesid,
        JET_GRBIT grbit,
        USHORT usFileNo,
        int nLine
        );

JET_ERR JetEndSessionWithErr_(
	JET_SESID		sesid,
	JET_ERR			err,
	const BOOL		fHandleException,
	const USHORT	usFile,
	const INT		lLine );

JET_ERR
JetCreateDatabaseException (
        JET_SESID sesid,
        const char  *szFilename,
        const char  *szConnect,
    JET_DBID  *pdbid,
        JET_GRBIT grbit,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetAttachDatabaseException (
        JET_SESID sesid,
        const char  *szFilename,
        JET_GRBIT grbit ,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetDetachDatabaseException (
        JET_SESID sesid,
        const char  *szFilename,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetCreateTableException (
        JET_SESID sesid,
        JET_DBID dbid,
        const char  *szTableName,
    unsigned long lPages,
        unsigned long lDensity,
        JET_TABLEID  *ptableid,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetCreateTableException (
        JET_SESID sesid,
        JET_DBID dbid,
    const char  *szTableName,
        unsigned long lPages,
        unsigned long lDensity,
    JET_TABLEID  *ptableid,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetGetTableColumnInfoException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    const char  *szColumnName,
        void  *pvResult,
        unsigned long cbMax,
    unsigned long InfoLevel,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetGetColumnInfoException (
        JET_SESID sesid,
        JET_DBID dbid,
    const char  *szTableName,
        const char  *szColumnName,
    void  *pvResult,
        unsigned long cbMax,
        unsigned long InfoLevel,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetAddColumnException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    const char  *szColumn,
        const JET_COLUMNDEF  *pcolumndef,
    const void  *pvDefault,
        unsigned long cbDefault,
    JET_COLUMNID  *pcolumnid,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetDeleteColumnException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    const char  *szColumn,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetGetTableIndexInfoException (
        JET_SESID sesid,
        JET_TABLEID tableid,
        const char  *szIndexName,
        void  *pvResult,
        unsigned long cbResult,
        unsigned long InfoLevel,
        DWORD dsid
        );

JET_ERR
JetCreateIndexException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    const char  *szIndexName,
        JET_GRBIT grbit,
    const char  *szKey,
        unsigned long cbKey,
        unsigned long lDensity,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetDeleteIndexException (
        JET_SESID sesid,
        JET_TABLEID tableid,
        const char  *szIndexName,
        DWORD dsid
        );

JET_ERR
JetBeginTransactionException (
        JET_SESID sesid,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetCommitTransactionException (
        JET_SESID sesid,
        JET_GRBIT grbit,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetRollbackException (
        JET_SESID sesid,
        JET_GRBIT grbit,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetCloseDatabaseException (
        JET_SESID sesid,
        JET_DBID dbid,
        JET_GRBIT grbit,
        USHORT usFileNo,
        int nLine
        );

JET_ERR JetCloseDatabaseWithErr_(
	JET_SESID		sesid,
	JET_DBID		dbid,
	JET_ERR			err,
	const BOOL		fHandleException,
	const USHORT	usFile,
	const INT		lLine );

JET_ERR
JetCloseTableException (
        JET_SESID sesid,
        JET_TABLEID tableid,
        USHORT usFileNo,
        int nLine
        );

JET_ERR JetCloseTableWithErr_(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_ERR			err,
	const BOOL		fHandleException,
	const USHORT	usFile,
	const INT		lLine );

JET_ERR
JetOpenDatabaseException (
        JET_SESID sesid,
        const char  *szFilename,
    const char  *szConnect,
        JET_DBID  *pdbid,
        JET_GRBIT grbit,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetOpenTableException (
        JET_SESID sesid,
        JET_DBID dbid,
    const char  *szTableName,
        const void  *pvParameters,
    unsigned long cbParameters,
        JET_GRBIT grbit,
        JET_TABLEID  *ptableid,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetSetTableSequentialException (
        JET_SESID sesid,
        JET_TABLEID tableid,
        JET_GRBIT grbit,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetResetTableSequentialException (
        JET_SESID sesid,
        JET_TABLEID tableid,
        JET_GRBIT grbit,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetDeleteException (
        JET_SESID sesid,
        JET_TABLEID tableid,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetUpdateException (
        JET_SESID sesid,
        JET_TABLEID tableid,
        void  *pvBookmark,
        unsigned long cbBookmark,
        unsigned long  *pcbActual,
        JET_GRBIT grbit,
        DWORD dsid
        );

JET_ERR
JetEscrowUpdateException (
        JET_SESID sesid,
        JET_TABLEID tableid,
        JET_COLUMNID columnid,
        void *pvDelta,
        unsigned long cbDeltaMax,
        void *pvOld,
        unsigned long cbOldMax,
        unsigned long *pcbOldActual,
        JET_GRBIT grbit,
        DWORD dsid
        );

JET_ERR
JetRetrieveColumnException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    JET_COLUMNID columnid,
        void  *pvData,
        unsigned long cbData,
    unsigned long  *pcbActual,
        JET_GRBIT grbit,
        JET_RETINFO  *pretinfo,
    BOOL fExceptOnWarning,
        DWORD dsid
        );

JET_ERR
JetRetrieveColumnsException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    JET_RETRIEVECOLUMN *pretrievecolumn,
        unsigned long cretrievecolumn,
    BOOL fExceptOnWarning ,
        DWORD dsid
        );

JET_ERR
JetEnumerateColumnsException(
    JET_SESID           sesid,
    JET_TABLEID         tableid,
    ULONG               cEnumColumnId,
    JET_ENUMCOLUMNID*   rgEnumColumnId,
    ULONG*              pcEnumColumn,
    JET_ENUMCOLUMN**    prgEnumColumn,
    JET_PFNREALLOC      pfnRealloc,
    void*               pvReallocContext,
    ULONG               cbDataMost,
    JET_GRBIT           grbit,
    DWORD               dsid );

JET_ERR
JetSetColumnException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    JET_COLUMNID columnid,
        const void  *pvData,
        unsigned long cbData,
    JET_GRBIT grbit,
        JET_SETINFO  *psetinfo,
        BOOL fExceptOnWarning,
        DWORD dsid
        );

JET_ERR
JetSetColumnsException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    JET_SETCOLUMN *psetcolumn,
        unsigned long csetcolumn ,
        DWORD dsid
        );

JET_ERR
JetPrepareUpdateException (
        JET_SESID sesid,
        JET_TABLEID tableid,
        unsigned long prep,
        DWORD dsid
        );

JET_ERR
JetGetRecordPositionException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    JET_RECPOS  *precpos,
        unsigned long cbRecpos,
        DWORD dsid
        );

JET_ERR
JetGotoPositionException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    JET_RECPOS *precpos ,
        DWORD dsid
        );

JET_ERR
JetDupCursorException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    JET_TABLEID  *ptableid,
        JET_GRBIT grbit,
        DWORD dsid
        );

JET_ERR
JetGetCurrentIndexException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    char  *szIndexName,
        unsigned long cchIndexName,
        DWORD dsid
        );

JET_ERR
JetSetCurrentIndex2Exception (
        JET_SESID sesid,
        JET_TABLEID tableid,
    const char  *szIndexName,
        JET_GRBIT grbit,
        BOOL fReturnErrors,
        DWORD dsid
        );

JET_ERR
JetSetCurrentIndex4Exception (
        JET_SESID sesid,
        JET_TABLEID tableid,
        const char  *szIndexName,
        struct tagJET_INDEXID *pidx,
        JET_GRBIT grbit,
        BOOL fReturnErrors,
        DWORD dsid
        );

JET_ERR
JetMoveException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    long cRow,
        JET_GRBIT grbit,
        DWORD dsid
        );

JET_ERR
JetMakeKeyException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    const void  *pvData,
        unsigned long cbData,
        JET_GRBIT grbit,
        DWORD dsid
        );

JET_ERR
JetSeekException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    JET_GRBIT grbit,
        DWORD dsid
        );

JET_ERR
JetGetBookmarkException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    void  *pvBookmark,
    unsigned long cbMax,
        unsigned long  *pcbActual,
        DWORD dsid
        );

JET_ERR
JetGotoBookmarkException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    void  *pvBookmark,
        unsigned long cbBookmark,
        DWORD dsid
        );

JET_ERR JetGetSecondaryIndexBookmarkException(
    JET_SESID       sesid,
    JET_TABLEID     tableid,
    VOID *          pvSecondaryKey,
    const ULONG     cbSecondaryKeyMax,
    ULONG *         pcbSecondaryKeyActual,
    VOID *          pvPrimaryBookmark,
    const ULONG     cbPrimaryBookmarkMax,
    ULONG *         pcbPrimaryBookmarkActual,
    const DWORD     dsid );

JET_ERR JetGotoSecondaryIndexBookmarkException(
    JET_SESID       sesid,
    JET_TABLEID     tableid,
    VOID *          pvSecondaryKey,
    const ULONG     cbSecondaryKey,
    VOID *          pvPrimaryBookmark,
    const ULONG     cbPrimaryBookmark,
    const JET_GRBIT grbit,
    const DWORD     dsid );

JET_ERR
JetComputeStatsException (
        JET_SESID sesid,
        JET_TABLEID tableid,
        DWORD dsid
        );

JET_ERR
JetOpenTempTableException (
        JET_SESID sesid,
        const JET_COLUMNDEF  *prgcolumndef,
    unsigned long ccolumn,
    JET_GRBIT grbit,
        JET_TABLEID  *ptableid,
    JET_COLUMNID  *prgcolumnid,
        DWORD dsid
        );

JET_ERR
JetIntersectIndexesException(
    JET_SESID sesid,
        JET_INDEXRANGE * rgindexrange,
    unsigned long cindexrange,
        JET_RECORDLIST * precordlist,
    JET_GRBIT grbit,
    DWORD dsid
    );


JET_ERR
JetSetIndexRangeException (
        JET_SESID sesid,
        JET_TABLEID tableidSrc,
        JET_GRBIT grbit,
        DWORD dsid
        );

JET_ERR
JetIndexRecordCountException (
        JET_SESID sesid,
    JET_TABLEID tableid,
        unsigned long  *pcrec,
        unsigned long crecMax ,
        DWORD dsid
        );

JET_ERR
JetRetrieveKeyException (
        JET_SESID sesid,
        JET_TABLEID tableid,
        void  *pvData,
    unsigned long cbMax,
        unsigned long  *pcbActual,
        JET_GRBIT grbit ,
    BOOL fExceptOnWarning,
        DWORD dsid
        );

JET_ERR
JetGetLockException(
    JET_SESID       sesid,
    JET_TABLEID     tableid,
    JET_GRBIT       grbit,
    DWORD           dsid
    );

//
// Macros to drop the line number into the Jet wrappers above.
//

#define JetInitEx(pinstance) JetInitException(pinstance, FILENO, __LINE__)
#define JetTermEx(instance) JetTermException(instance, FILENO, __LINE__)
#define JetSetSystemParameterEx(pinstance, sesid, paramid, lParam, sz)         \
        JetSetSystemParameterException(pinstance, sesid, paramid, lParam, sz,  \
                                       FILENO, __LINE__)
#define JetBeginSessionEx(instance, psesid, szUserName, szPassword)            \
        JetBeginSessionException(instance, psesid, szUserName, szPassword,     \
                                 FILENO, __LINE__)
#define JetDupSessionEx(sesid, psesid)                                         \
        JetDupSessionException(sesid, psesid, FILENO, __LINE__)
#define JetEndSessionEx(sesid, grbit)                                          \
        JetEndSessionException(sesid, grbit, FILENO, __LINE__)
#define JetEndSessionWithErr( sesid, err )                                     \
        JetEndSessionWithErr_( sesid, err, TRUE, FILENO, __LINE__ )
#define JetEndSessionWithErrUnhandled( sesid, err )                            \
        JetEndSessionWithErr_( sesid, err, FALSE, FILENO, __LINE__ )
#define JetGetVersionEx(sesid, pwVersion)                                      \
        JetGetVersionException(sesid, pwVersion, FILENO, __LINE__)
#define JetCreateDatabaseEx(sesid, szFilename, szConnect, pdbid, grbit)        \
        JetCreateDatabaseException(sesid, szFilename, szConnect, pdbid, grbit, \
                                   FILENO, __LINE__)
#define JetAttachDatabaseEx(sesid, szFilename, grbit )                         \
        JetAttachDatabaseException(sesid, szFilename, grbit , FILENO, __LINE__)
#define JetDetachDatabaseEx(sesid, szFilename)                                 \
        JetDetachDatabaseException(sesid, szFilename, FILENO, __LINE__)
#define JetCreateTableEx(sesid, dbid, szTableName, lPages, lDensity, ptableid) \
        JetCreateTableException(sesid, dbid, szTableName, lPages, lDensity,    \
                                ptableid, FILENO, __LINE__)
#define JetCreateTableEx(sesid, dbid, szTableName, lPages, lDensity,ptableid)  \
        JetCreateTableException(sesid, dbid, szTableName, lPages, lDensity,    \
                                ptableid, FILENO, __LINE__)
#define JetGetTableColumnInfoEx(sesid, tableid, szColumnName, pvResult, cbMax, \
                                InfoLevel)                                     \
        JetGetTableColumnInfoException(sesid, tableid, szColumnName, pvResult, \
                                       cbMax, InfoLevel, FILENO, __LINE__)
#define JetGetColumnInfoEx(sesid, dbid, szTableName, szColumnName, pvResult,   \
                           cbMax, InfoLevel)                                   \
        JetGetColumnInfoException(sesid, dbid, szTableName, szColumnName,      \
                                  pvResult, cbMax, InfoLevel, FILENO, __LINE__)
#define JetAddColumnEx(sesid, tableid, szColumn, pcolumndef, pvDefault,        \
                       cbDefault, pcolumnid)                                   \
        JetAddColumnException(sesid, tableid, szColumn, pcolumndef, pvDefault, \
                              cbDefault, pcolumnid, FILENO, __LINE__)
#define JetDeleteColumnEx(sesid, tableid, szColumn)                            \
        JetDeleteColumnException(sesid, tableid, szColumn, FILENO, __LINE__)
#define JetGetTableIndexInfoEx(sesid, tableid,         szIndexName, pvResult,  \
                               cbResult, InfoLevel)                            \
        JetGetTableIndexInfoException(sesid, tableid, szIndexName, pvResult,   \
                                      cbResult, InfoLevel, DSID(FILENO, __LINE__))
#define JetCreateIndexEx(sesid, tableid, szIndexName, grbit, szKey, cbKey,     \
                         lDensity)                                             \
        JetCreateIndexException(sesid, tableid, szIndexName, grbit, szKey,     \
                                cbKey, lDensity, FILENO, __LINE__)
#define JetDeleteIndexEx(sesid, tableid, szIndexName)                          \
        JetDeleteIndexException(sesid, tableid, szIndexName, DSID(FILENO, __LINE__))
#define JetBeginTransactionEx(sesid)                                           \
        JetBeginTransactionException(sesid, FILENO, __LINE__)
#define JetCommitTransactionEx(sesid, grbit)                                   \
        JetCommitTransactionException(sesid, grbit, FILENO, __LINE__)
#define JetRollbackEx(sesid, grbit)                                            \
        JetRollbackException(sesid, grbit, FILENO, __LINE__)
#define JetCloseDatabaseEx(sesid, dbid, grbit)                                 \
        JetCloseDatabaseException(sesid, dbid, grbit, FILENO, __LINE__)
#define JetCloseDatabaseWithErr( sesid, dbid, err )                            \
        JetCloseDatabaseWithErr_(sesid, dbid, err, TRUE, FILENO, __LINE__ )
#define JetCloseDatabaseWithErrUnhandled( sesid, dbid, err )                   \
        JetCloseDatabaseWithErr_(sesid, dbid, err, FALSE, FILENO, __LINE__ )
#define JetCloseTableEx(sesid, tableid)                                        \
        JetCloseTableException(sesid, tableid, FILENO, __LINE__)
#define JetCloseTableWithErr( sesid, tableid, err )                            \
        JetCloseTableWithErr_(sesid, tableid, err, TRUE, FILENO, __LINE__ )
#define JetCloseTableWithErrUnhandled( sesid, tableid, err )                   \
        JetCloseTableWithErr_(sesid, tableid, err, FALSE, FILENO, __LINE__ )
#define JetOpenDatabaseEx(sesid, szFilename, szConnect, pdbid, grbit)          \
        JetOpenDatabaseException(sesid, szFilename, szConnect, pdbid, grbit,   \
                                 FILENO, __LINE__)
#define JetOpenTableEx(sesid, dbid, szTableName, pvParameters, cbParameters,   \
                       grbit, ptableid)                                        \
        JetOpenTableException(sesid, dbid, szTableName, pvParameters,          \
                              cbParameters, grbit, ptableid, FILENO, __LINE__)
#define JetSetTableSequentialEx(sesid, tableid, grbit)                                        \
        JetSetTableSequentialException(sesid, tableid, grbit, FILENO, __LINE__)
#define JetResetTableSequentialEx(sesid, tableid, grbit)                                        \
        JetResetTableSequentialException(sesid, tableid, grbit, FILENO, __LINE__)
#define        JetDeleteEx(sesid, tableid)                                     \
        JetDeleteException(sesid, tableid, FILENO, __LINE__)
#define JetUpdateEx(sesid, tableid, pvBookmark, cbBookmark, pcbActual)         \
        JetUpdateException(sesid, tableid, pvBookmark, cbBookmark, pcbActual,  \
                           NO_GRBIT, DSID(FILENO, __LINE__))
#define JetUpdate2Ex(sesid, tableid, pvBookmark, cbBookmark, pcbActual, grbit) \
        JetUpdateException(sesid, tableid, pvBookmark, cbBookmark, pcbActual,  \
                           grbit, DSID(FILENO, __LINE__))
#define JetEscrowUpdateEx(sesid, tableid, columnid, pvDelta, cbDeltaMax,      \
                          pvOld, cbOldMax, pcbOldActual, grbit)               \
        JetEscrowUpdateException(sesid, tableid, columnid, pvDelta,cbDeltaMax,\
                                 pvOld, cbOldMax, pcbOldActual, grbit,        \
                                 DSID(FILENO, __LINE__))
#define JetSetColumnEx(sesid,tableid,columnid,pvData, cbData, grbit, psetinfo)\
        JetSetColumnException(sesid, tableid, columnid, pvData, cbData, grbit,\
                              psetinfo, FALSE, DSID(FILENO, __LINE__))
#define JetSetColumnsEx(sesid, tableid, psetcolumn, csetcolumn )              \
        JetSetColumnsException(sesid, tableid, psetcolumn, csetcolumn,        \
                               DSID(FILENO,__LINE__))
#define JetPrepareUpdateEx(sesid, tableid, prep)                              \
        JetPrepareUpdateException(sesid, tableid, prep, DSID(FILENO, __LINE__))
#define JetGetRecordPositionEx(sesid, tableid, precpos, cbRecpos)             \
        JetGetRecordPositionException(sesid, tableid, precpos, cbRecpos,      \
                                      DSID(FILENO, __LINE__))
#define        JetGotoPositionEx(sesid, tableid, precpos )                    \
        JetGotoPositionException(sesid, tableid, precpos,                     \
                                 DSID(FILENO, __LINE__))
#define JetDupCursorEx(sesid, tableid, ptableid, grbit)                       \
        JetDupCursorException(sesid, tableid, ptableid, grbit,                \
                              DSID(FILENO, __LINE__))
#define JetGetCurrentIndexEx(sesid, tableid, szIndexName, cchIndexName)       \
        JetGetCurrentIndexException(sesid, tableid, szIndexName, cchIndexName,\
                                    DSID(FILENO, __LINE__))
#define JetMoveEx(sesid, tableid, cRow, grbit)                                \
        JetMoveException(sesid, tableid, cRow, grbit, DSID(FILENO, __LINE__))
#define JetMakeKeyEx(sesid, tableid, pvData, cbData, grbit)                   \
        JetMakeKeyException(sesid, tableid, pvData, cbData, grbit,            \
                            DSID(FILENO,__LINE__))
#define JetSeekEx(sesid, tableid, grbit)                                      \
        JetSeekException(sesid, tableid, grbit, DSID(FILENO, __LINE__))
#define JetGetBookmarkEx(sesid, tableid, pvBookmark, cbMax, pcbActual)        \
        JetGetBookmarkException(sesid, tableid, pvBookmark, cbMax, pcbActual, \
                                DSID(FILENO, __LINE__))
#define JetGotoBookmarkEx(sesid, tableid, pvBookmark, cbBookmark)             \
        JetGotoBookmarkException(sesid, tableid, pvBookmark, cbBookmark,      \
                                 DSID(FILENO, __LINE__))
#define JetGetSecondaryIndexBookmarkEx(sesid, tableid,                        \
                                       pvSecondaryKey, cbSecondaryKeyMax,     \
                                       pcbSecondaryKeyActual,                 \
                                       pvPrimaryBookmark,                     \
                                       cbPrimaryBookmarkMax,                  \
                                       pcbPrimaryBookmarkActual)              \
        JetGetSecondaryIndexBookmarkException(sesid, tableid,                 \
                                              pvSecondaryKey,                 \
                                              cbSecondaryKeyMax,              \
                                              pcbSecondaryKeyActual,          \
                                              pvPrimaryBookmark,              \
                                              cbPrimaryBookmarkMax,           \
                                              pcbPrimaryBookmarkActual,       \
                                              DSID(FILENO, __LINE__))
#define JetGotoSecondaryIndexBookmarkEx(sesid, tableid,                       \
                                        pvSecondaryKey, cbSecondaryKey,       \
                                        pvPrimaryBookmark, cbPrimaryBookmark, \
                                        grbit)                                \
        JetGotoSecondaryIndexBookmarkException(sesid, tableid,                \
                                               pvSecondaryKey,                \
                                               cbSecondaryKey,                \
                                               pvPrimaryBookmark,             \
                                               cbPrimaryBookmark,             \
                                               grbit,                         \
                                               DSID(FILENO, __LINE__))
#define JetComputeStatsEx(sesid, tableid)                                     \
        JetComputeStatsException(sesid, tableid, DSID(FILENO, __LINE__))
#define JetOpenTempTableEx(sesid, prgcolumndef, ccolumn, grbit, ptableid,     \
                           prgcolumnid)                                       \
        JetOpenTempTableException(sesid, prgcolumndef, ccolumn, grbit,        \
                                  ptableid, prgcolumnid, DSID(FILENO,__LINE__))
#define JetSetIndexRangeEx(sesid, tableidSrc, grbit)                          \
        JetSetIndexRangeException(sesid, tableidSrc, grbit,                   \
                                  DSID(FILENO, __LINE__))
#define JetIntersectIndexesEx(sesid, rgindexrange, cindexrange, precordlist, grbit)\
        JetIntersectIndexesException(sesid, rgindexrange, cindexrange, precordlist, grbit, \
                                  DSID(FILENO, __LINE__))
#define JetIndexRecordCountEx(sesid, tableid, pcrec, crecMax )                \
        JetIndexRecordCountException(sesid, tableid, pcrec, crecMax ,         \
                                     DSID(FILENO, __LINE__))

#define JetRetrieveKeyEx(sesid, tableid, pvData, cbMax, pcbActual, grbit )    \
        JetRetrieveKeyException(sesid, tableid, pvData, cbMax, pcbActual,     \
                        grbit, TRUE, DSID(FILENO, __LINE__))

// Some wrappers to only allow succes or certain warnings.

#define JetRetrieveKeyWarnings(sesid, tableid, pvData, cbMax,                 \
                               pcbActual, grbit )                             \
        JetRetrieveKeyException(sesid, tableid, pvData, cbMax, pcbActual,     \
                                grbit, FALSE, DSID(FILENO, __LINE__))

#define JetRetrieveKeySuccess(sesid, tableid, pvData, cbMax,                  \
                               pcbActual, grbit )                             \
        JetRetrieveKeyException(sesid, tableid, pvData, cbMax, pcbActual,     \
                                grbit, TRUE, DSID(FILENO, __LINE__))

#define JetSetColumnWarnings(sesid,tableid,columnid,pvData, cbData,       \
              grbit, psetinfo)                                                \
        JetSetColumnException(sesid, tableid, columnid, pvData, cbData, grbit,\
                              psetinfo, FALSE, DSID(FILENO, __LINE__))

#define JetSetColumnSuccess(sesid,tableid,columnid,pvData, cbData,       \
              grbit, psetinfo)                                                \
        JetSetColumnException(sesid, tableid, columnid, pvData, cbData, grbit,\
                              psetinfo, TRUE, DSID(FILENO, __LINE__))

// A JetRetrieveColumn call that returns only success
#define JetRetrieveColumnSuccess(sesid, tableid, columnid, pvData, cbData,    \
                pcbActual, grbit, pretinfo)                                   \
                JetRetrieveColumnException(sesid, tableid, columnid, pvData,  \
                                           cbData, pcbActual, grbit, pretinfo,\
                                           TRUE, DSID(FILENO, __LINE__))

// A JetRetrieveColumn call that returns success, or NULL, or buffer truncated
#define JetRetrieveColumnWarnings(sesid, tableid, columnid, pvData, cbData,   \
                                  pcbActual, grbit, pretinfo)                 \
        JetRetrieveColumnException(sesid, tableid, columnid, pvData, cbData,  \
                                   pcbActual, grbit, pretinfo, FALSE,         \
                                   DSID(FILENO,__LINE__))


// A JetRetrieveColumns call that returns only success
#define JetRetrieveColumnsSuccess(sesid, tableid, pretrievecolumn,            \
                cretrievecolumn)                                              \
        JetRetrieveColumnsException(sesid, tableid, pretrievecolumn,          \
                                    cretrievecolumn, TRUE,                    \
                                    DSID(FILENO, __LINE__))

// A JetRetrieveColumns call that returns success, or NULL, or buffer truncated
#define JetRetrieveColumnsWarnings(sesid, tableid, pretrievecolumn,           \
                cretrievecolumn)                                              \
        JetRetrieveColumnsException(sesid, tableid, pretrievecolumn,          \
                       cretrievecolumn, FALSE, DSID(FILENO, __LINE__))

#define JetEnumerateColumnsEx(sesid, tableid, cEnumColumnId, rgEnumColumnId,  \
                            pcEnumColumn, prgEnumColumn, pfnRealloc,          \
                            pvReallocContext, cbDataMost, grbit)              \
        JetEnumerateColumnsException(sesid, tableid, cEnumColumnId,           \
                            rgEnumColumnId, pcEnumColumn, prgEnumColumn,      \
                            pfnRealloc, pvReallocContext, cbDataMost, grbit,   \
                            DSID(FILENO, __LINE__))

// A JetSetCurrentIndex call that either succeeds or excepts
#define JetSetCurrentIndexSuccess(sesid, tableid, szIndexName)                \
        JetSetCurrentIndex2Exception(sesid, tableid, szIndexName,             \
                   JET_bitMoveFirst, FALSE, DSID(FILENO, __LINE__))

// A JetSetCurrentIndex call that also returns expected errors (index doesn't
// exist)
#define JetSetCurrentIndexWarnings(sesid, tableid, szIndexName)               \
        JetSetCurrentIndex2Exception(sesid, tableid, szIndexName,             \
                    JET_bitMoveFirst, TRUE, DSID(FILENO, __LINE__))

// A JetSetCurrentIndex call that either succeeds or excepts
#define JetSetCurrentIndex2Success(sesid, tableid, szIndexName, grbit)        \
        JetSetCurrentIndex2Exception(sesid, tableid, szIndexName, grbit,      \
                                     FALSE, DSID(FILENO, __LINE__))

// A JetSetCurrentIndex call that also returns expected errors (index doesn't
// exist)
#define JetSetCurrentIndex2Warnings(sesid, tableid, szIndexName,grbit)        \
    JetSetCurrentIndex2Exception(sesid, tableid, szIndexName, grbit,      \
                                     TRUE, DSID(FILENO, __LINE__))

// A JetSetCurrentIndex call that either succeeds or excepts
#define JetSetCurrentIndex4Success(sesid, tableid, szIndexName, pidx, grbit)  \
        JetSetCurrentIndex4Exception(sesid, tableid, szIndexName, pidx, grbit,\
                                     FALSE, DSID(FILENO, __LINE__))

// A JetSetCurrentIndex call that also returns expected errors (index doesn't
// exist)
#define JetSetCurrentIndex4Warnings(sesid, tableid, szIndexName, pidx,grbit)  \
        JetSetCurrentIndex4Exception(sesid, tableid, szIndexName, pidx, grbit,\
                                     TRUE, DSID(FILENO, __LINE__))

#define JetGetLockEx(sesid, tableid, grbit) \
        JetGetLockException(sesid, tableid, grbit, DSID(FILENO, __LINE__))

extern
BOOL
dnReadPreProcessTransactionalData (
        BOOL fCommit
        );
extern
VOID
dnReadPostProcessTransactionalData (
        THSTATE *pTHS,
        BOOL fCommit,
        BOOL fCommitted
        );

extern
VOID
dbEscrowPromote(
    DWORD   phantomDNT,
    DWORD   objectDNT);

extern
BOOL
dbEscrowPreProcessTransactionalData(
    DBPOS   *pDB,
    BOOL    fCommit);

extern
VOID
dbEscrowPostProcessTransactionalData(
    DBPOS   *pDB,
    BOOL    fCommit,
    BOOL    fCommitted);

DWORD
dbMakeCurrent(
    DBPOS *pDB,
    struct _d_memname *pname);

BOOL
dnGetCacheByDNT(
        DBPOS *pDB,
        DWORD tag,
        d_memname **ppname
        );

BOOL
dnGetCacheByPDNTRdn (
        DBPOS *pDB,
        DWORD parenttag,
        DWORD cbRDN,
        WCHAR *pRDN,
        ATTRTYP rdnType,
        d_memname **ppname);

BOOL
dnGetCacheByGuid (
        DBPOS *pDB,
        GUID *pGuid,
        d_memname **ppname);

d_memname *
DNcache(
        IN  DBPOS *     pDB,
        IN  JET_TABLEID tblid,
        IN  BOOL        bCheckForExisting
        );

BOOL
dbIsModifiedInMetaData (
        DBPOS *pDB,
        ATTRTYP att
        );

DWORD
dbMapiTypeFromObjClass (
        ATTRTYP objClass,
        wchar_t *pTemp
        );



// These data structures are used to marshall and unmarshal restart args.  They
// are used in dbtools.  If these structures change, then the code in
// DBCreateRestart, DBCreateRestartForSAM, and DBUnmarshallRestart must all
// change in sync.
// A packed restart arg has a single PACKED_KEY_HEADER, followed by N
// PACKED_KEY_INDEXes (where N is NumIndices in the PACKED_KEY_HEADER), followed
// by M DNTs (where M is NumDNTs in the PACKED_KEY_HEADER).  Note then, that the
// whole restart arg has 2 variable sized arrays in it, which is why we use this
// weird hand marshalling.

typedef struct _PACKED_KEY_HEADER {
    DWORD NumIndices;
    DWORD NumDNTs;
    DWORD StartDNT;
    DWORD cbCurrentKey;
    DWORD  cbCurrentBM;
    DWORD ulSearchType;
    RESOBJ BaseResObj;
    GUID  BaseGuid;
    DWORD ulSorted;
    DWORD indexType;
    DWORD bOnCandidate;
    DWORD fChangeDirection;
    DWORD dupDetectionType;
    BOOL  bOneNC;
    DWORD SearchEntriesVisited;
    DWORD SearchEntriesReturned;
    BOOL  fVLVSearch:1;
    BOOL  bUsingMAPIContainer:1;
    ULONG ulVLVContentCount;
    ULONG ulVLVTargetPosition;
    DWORD cbVLVCurrPositionKey;
    DWORD MAPIContainerDNT;
    DWORD asqMode;
    ULONG ulASQLastUpperBound;
} PACKED_KEY_HEADER;

typedef struct _PACKED_KEY_INDEX {
    DWORD   bPDNT;
    DWORD   bIsSingleValued;
    DWORD   bIsEqualityBased;
    DWORD   bIsForSort;
    ATTRTYP type;
    DWORD   cbIndexName;
    DWORD   cbDBKeyLower;
    DWORD   cbDBKeyUpper;
} PACKED_KEY_INDEX;

typedef struct _INDEX_RANGE     {
    DWORD   cbValLower;
    PVOID   pvValLower;
    DWORD   cbValUpper;
    PVOID   pvValUpper;
} INDEX_RANGE;


#define dbmkfir_PDNT    1
#define dbmkfir_NCDNT   2
#define dbmkfir_LINK    3

#define DB_MKI_USE_SEARCH_TABLE     1
#define DB_MKI_GET_NUM_RECS         2
#define DB_MKI_SET_CURR_INDEX       4
KEY_INDEX *
dbMakeKeyIndex(
        DBPOS *pDB,
        DWORD dwSearchType,
        BOOL  bIsSingleValued,
        DWORD Option,
        char * szIndex,
        JET_INDEXID * pindexid,
        DWORD Flags,
        DWORD cIndexRanges,
        INDEX_RANGE * rgIndexRange
        );

void
dbFreeKeyIndex(
        THSTATE *pTHS,
        KEY_INDEX *pIndex
        );

DWORD dbFreeFilter(
        DBPOS *pDB,
        FILTER *pFil);

BOOL
dbFObjectInCorrectDITLocation (
        DBPOS *pDB,
        JET_TABLEID tblId
        );


BOOL
dbFObjectInCorrectNC (
        DBPOS *pDB,
        ULONG DNT,
        JET_TABLEID tblId
        );

BOOL
dbMatchSearchCriteriaForSortedTable (
        DBPOS *pDB,
        BOOL  *pCanRead
        );

VOID
dbSearchDuplicateCreateHashTable(
    IN      struct _LHT**   pplht
    );

BOOL __inline
dbNeedToFlushDNCacheOnUpdate(ATTRTYP at)
/*++
    do we need to flush the dn read cache when this attribute is updated?
--*/
{
    switch(at) {
    case ATT_OBJECT_GUID:
    case ATT_OBJECT_SID:
    case ATT_RDN:
    case ATT_OBJECT_CLASS:
    case ATT_NT_SECURITY_DESCRIPTOR:
        // Changing these attributes changes the record's identity, so we'll
        // need to flush this DNT from the read cache after we've updated the
        // record.
        return TRUE;
    default:
        return FALSE;
    }
}


#define SORTED_INDEX(x) ( ((x)==TEMP_TABLE_INDEX_TYPE) || ((x)==TEMP_TABLE_MEMORY_ARRAY_TYPE) )

// allocate that much memory for SD by default (will increase if needed)
#define DEFAULT_SD_SIZE 4096

ULONG
CountAncestorsIndexSizeHelper (
    DBPOS *pDB,
    DWORD  cAncestors,
    DWORD *pAncestors
    );

PSDCACHE_ENTRY
dbFindSDCacheEntry(GLOBALDNREADCACHE* pCache, SDID sdID);

int
IntExtSecDesc(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG intLen,   UCHAR *pIntVal,
              ULONG *pExtLen, UCHAR **ppExtVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG SecurityInformation);

extern JET_TABLEID HiddenTblid;
DBPOS * dbGrabHiddenDBPOS(THSTATE *pTHS);
void dbReleaseHiddenDBPOS(DBPOS *pDB);


// How close to ends do we get before doing our own positioning
#define EPSILON     100

#define NormalizeIndexPosition(BeginNum, EndNum) ( (EndNum) < (BeginNum) ? 0 : (EndNum) - (BeginNum) + 1 )


#endif  /* _dbintrnl_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dblayer\dbeval.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbeval.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <mdlocal.h>
#include <dsatools.h>                   // For pTHStls
#include <attids.h>

#include <permit.h>

// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>

// Assorted DSA headers
#include <filtypes.h>      /* Def of FI_CHOICE_???                  */
#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DBEV:" /* define the subsystem for debugging           */

// DBLayer includes
#include "dbintrnl.h"

#include <fileno.h>
#define  FILENO FILENO_DBEVAL



/* Some shorthand datastructure defines*/

#define PITEM     pFil->FilterTypes.Item
#define FAVA      FilTypes.ava
#define FSB       FilTypes.pSubstring
#define FPR       FilTypes.present
#define FSKIP     FilTypes.pbSkip

BOOL
dbEvalFilterSecurity (
        DBPOS *pDB,
        CLASSCACHE *pCC,
        PSECURITY_DESCRIPTOR pSD,
        PDSNAME pDN
        )
{
    THSTATE *pTHS = pDB->pTHS;
    Assert(VALID_DBPOS(pDB));

    if(pTHS->fDSA || pTHS->fDRA) {
        // DO not evaluate security
        return TRUE;
    }


    if(!pDB->Key.FilterSecuritySize) {
        // No Security to evaluate.
        return TRUE;
    }

    if(!pSD || !pCC || !pDN) {
        // Missing required attributes, this security check can't be performed.
        Assert(FALSE);
        return FALSE;
    }

    pDB->Key.pFilterSecurity[0].ObjectType = &pCC->propGuid;

    if(CheckPermissionsAnyClient(
            pSD,                        // security descriptor
            pDN,                        // DN of the object
            pCC,                        // object class
            RIGHT_DS_READ_PROPERTY,     // access mask
            pDB->Key.pFilterSecurity,   // Object Type List
            pDB->Key.FilterSecuritySize, // Number of objects in list
            NULL,
            pDB->Key.pFilterResults,                 // access status array
            0,
            NULL,                       // authz client context (grab from THSTATE)
            NULL,                       // additional info
            NULL                        // additional guid
            )){
        return FALSE;
    }

    // OK, we're done
    return TRUE;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Apply the supplied filter test to the current object.  Returns TRUE or
   FALSE.  The actual evaluation test is performed by the DBEval function.
*/


TRIBOOL
DBEvalFilter (
        DBPOS FAR *pDB,
        BOOL    fUseSearchTbl,
        FILTER *pFil
        )
{

   USHORT count;
   TRIBOOL retval;
   BOOL    undefinedPresent;

   DPRINT(2, "DBEvalFilter entered, apply filter test\n");

   Assert(VALID_DBPOS(pDB));

   if(pFil == NULL){    /* a NULL filter is automatically true */
      DPRINT(2,"No filter..return\n");
      return eTRUE;
   }

   DPRINT1(5,"Switch on filter choice <%u>\n", (USHORT)(pFil->choice));

   switch (pFil->choice){
     /* count number of filters are anded together.  If any are false
        the AND is false.
     */
     case FILTER_CHOICE_AND:
        DPRINT(5,"AND test\n");
        undefinedPresent = FALSE;
        count = pFil->FilterTypes.And.count;
        for (pFil = pFil->FilterTypes.And.pFirstFilter;
                                      count--;
                                     pFil = pFil->pNextFilter){

            retval = DBEvalFilter(pDB, fUseSearchTbl, pFil);

            Assert (VALID_TRIBOOL(retval));

            // if the AND has at least one false, it is false
            if (retval == eFALSE){
                DPRINT(5,"AND returns FALSE\n");
                return eFALSE;
            }
            // if the AND has at least one undefined, it is undefined
            else if (retval == eUNDEFINED){
                undefinedPresent = TRUE;
            }

        } /*for*/

        // the AND had one undefined, so it is undefined
        if (undefinedPresent) {
            DPRINT(5,"AND returns UNDEFINED\n");
            return eUNDEFINED;
        }

        DPRINT(5,"AND returns TRUE\n");
        return eTRUE;
        break;

     /* count number of filters are ORed together.  If any are true
        the OR is true.
     */
     case FILTER_CHOICE_OR:
        DPRINT(5,"OR test\n");
        undefinedPresent = FALSE;
        count = pFil->FilterTypes.Or.count;
        for (pFil = pFil->FilterTypes.Or.pFirstFilter;
                                      count--;
                                     pFil = pFil->pNextFilter){
           retval = DBEvalFilter(pDB, fUseSearchTbl, pFil);

           Assert (VALID_TRIBOOL(retval));

           if (retval == eTRUE) {
               DPRINT(5,"OR returns TRUE\n");
               return eTRUE;
           }
           else if (retval == eUNDEFINED) {
               undefinedPresent = TRUE;
           }
        } /*for*/

        // the OR had one undefined, so it is undefined
        if (undefinedPresent) {
            DPRINT(5,"OR returns UNDEFINED\n");
            return eUNDEFINED;
        }
        else {
            DPRINT(5,"OR returns FALSE\n");
            return eFALSE;
        }
        break;

     case FILTER_CHOICE_NOT:
        retval = DBEvalFilter(pDB, fUseSearchTbl, pFil->FilterTypes.pNot);

        Assert (VALID_TRIBOOL(retval));

        if (retval == eFALSE) {
          DPRINT(5,"NOT return TRUE\n");
          return eTRUE;
        }
        else if (retval == eTRUE) {
          DPRINT(5,"NOT return FALSE\n");
          return eFALSE;
        }
        else {
            DPRINT(5,"NOT return UNDEFINED\n");
            return eUNDEFINED;
        }
        break;

     /*  Apply the chosen test to the database attribute on the current
         object.
     */
     case FILTER_CHOICE_ITEM:
         DPRINT(5,"ITEM test\n");

        switch (pFil->FilterTypes.Item.choice){
        case FI_CHOICE_TRUE:
            DPRINT(5,"TRUE test\n");
            return eTRUE;
            break;

        case FI_CHOICE_FALSE:
            DPRINT(5,"FALSE test\n");
            return eFALSE;
            break;

        case FI_CHOICE_UNDEFINED:
            DPRINT(5,"UNDEFINED test\n");
            return eUNDEFINED;
            break;

        case FI_CHOICE_SUBSTRING:
            return
                dbEvalInt(pDB, fUseSearchTbl,
                          FI_CHOICE_SUBSTRING, PITEM.FSB->type
                          , 0   /*NA for substrings*/
                          , (UCHAR *) PITEM.FSB
                          , PITEM.FSKIP);
            break;

        case FI_CHOICE_EQUALITY:
        case FI_CHOICE_NOT_EQUAL:
        case FI_CHOICE_GREATER_OR_EQ:
        case FI_CHOICE_GREATER:
        case FI_CHOICE_LESS_OR_EQ:
        case FI_CHOICE_LESS:
        case FI_CHOICE_BIT_AND:
        case FI_CHOICE_BIT_OR:
            return
                dbEvalInt(pDB,
                          fUseSearchTbl,
                          pFil->FilterTypes.Item.choice,
                          PITEM.FAVA.type,
                          PITEM.FAVA.Value.valLen,
                          PITEM.FAVA.Value.pVal,
                          PITEM.FSKIP
                          );
            break;

        case FI_CHOICE_PRESENT:
            return
                dbEvalInt(pDB,
                          fUseSearchTbl,
                          FI_CHOICE_PRESENT, PITEM.FPR  /*just test for existance*/
                          , 0
                          , NULL
                          , PITEM.FSKIP);
            break;

        default:
            DPRINT(1, "Bad Filter Item..return \n"); /*set error*/
            return eFALSE;
            break;
        } /*FILITEM switch*/

    default:
        DPRINT(1, "Bad Filter choice..return \n"); /*set error*/
        return eFALSE;
        break;
   }  /*switch FILTER*/


}/* DBEvalFilter*/


// dbEvalLinkAtt optimizes the evaluation of a filter term on a linked attr by
// directly seeking on the link table using known information (the current DNT
// in the object/search table, the link ID, and information from the filter).
// this dramatically speeds up the process of evaluating a filter term against
// a linked attribute with many values for a given object.

TRIBOOL
dbEvalLinkAtt(
    DBPOS*      pDB,
    BOOL        fUseSearchTbl,
    UCHAR       Operation,
    ATTCACHE*   pAC,
    ULONG       valLenFilter,
    UCHAR*      pValFilter
    )
{
    JET_ERR             err;
    ULONG               DNT;
    ULONG               ulLinkBase;
    JET_COLUMNID        colidDNT;
    JET_RETRIEVECOLUMN  rgretcol[2];
    ULONG               DNTFound = INVALIDDNT;
    ULONG               ulLinkBaseFound = 0;

    // this has better be a linked attribute

    Assert(pAC->ulLinkID);

    // we do not support distname-binary or distname-string

    Assert(pAC->syntax == SYNTAX_DISTNAME_TYPE);
    
    // it is assumed that these are the only valid operations that we will see
    // on a linked attribute
    
    Assert(     Operation == FI_CHOICE_EQUALITY ||
                Operation == FI_CHOICE_NOT_EQUAL ||
                Operation == FI_CHOICE_PRESENT );

    // get the current DNT and link base

    if (fUseSearchTbl) {
        DNT = pDB->SDNT;
    } else {
        DNT = pDB->DNT;
    }

    ulLinkBase = MakeLinkBase(pAC->ulLinkID);

    // set the appropriate index

    if (FIsBacklink(pAC->ulLinkID)) {
        JetSetCurrentIndex4Success(pDB->JetSessID,
                                    pDB->JetLinkTbl,
                                    SZBACKLINKINDEX,
                                    &idxBackLink,
                                    0);
    } else {
        JetSetCurrentIndex4Success(pDB->JetSessID,
                                    pDB->JetLinkTbl,
                                    SZLINKINDEX,
                                    &idxLink,
                                    0);
    }

    if (Operation == FI_CHOICE_PRESENT) {

        // seek GE on the current DNT and link base looking for any value

        JetMakeKeyEx(pDB->JetSessID,
                        pDB->JetLinkTbl,
                        &DNT,
                        sizeof(DNT),
                        JET_bitNewKey);
        JetMakeKeyEx(pDB->JetSessID,
                        pDB->JetLinkTbl,
                        &ulLinkBase,
                        sizeof(ulLinkBase),
                        0);
        err = JetSeekEx(pDB->JetSessID,
                        pDB->JetLinkTbl,
                        JET_bitSeekGE);
        if (err == JET_errRecordNotFound) {
            return eFALSE;
        }

        // check to see if we landed on the current DNT and link base

        if (FIsBacklink(pAC->ulLinkID)) {
            colidDNT = backlinkdntid;
        } else {
            colidDNT = linkdntid;
        }

        rgretcol[0].columnid        = colidDNT;
        rgretcol[0].pvData          = &DNTFound;
        rgretcol[0].cbData          = sizeof(DNTFound);
        rgretcol[0].grbit           = JET_bitRetrieveFromIndex;
        rgretcol[0].itagSequence    = 1;
        
        rgretcol[1].columnid        = linkbaseid;
        rgretcol[1].pvData          = &ulLinkBaseFound;
        rgretcol[1].cbData          = sizeof(ulLinkBaseFound);
        rgretcol[1].grbit           = JET_bitRetrieveFromIndex;
        rgretcol[1].itagSequence    = 1;

        JetRetrieveColumnsSuccess(pDB->JetSessID,
                                    pDB->JetLinkTbl,
                                    rgretcol,
                                    2);
        if (DNTFound == DNT && ulLinkBaseFound == ulLinkBase) {
            return eTRUE;
        } else {
            return eFALSE;
        }

    } else {

        // seek on the current DNT, link base, and value DNT
        
        JetMakeKeyEx(pDB->JetSessID,
                        pDB->JetLinkTbl,
                        &DNT,
                        sizeof(DNT),
                        JET_bitNewKey);
        JetMakeKeyEx(pDB->JetSessID,
                        pDB->JetLinkTbl,
                        &ulLinkBase,
                        sizeof(ulLinkBase),
                        0);
        JetMakeKeyEx(pDB->JetSessID,
                        pDB->JetLinkTbl,
                        pValFilter,
                        valLenFilter,
                        0);
        if (!FIsBacklink(pAC->ulLinkID)) {
            JetMakeKeyEx(pDB->JetSessID,
                            pDB->JetLinkTbl,
                            NULL,
                            0,
                            0);
        }
        err = JetSeekEx(pDB->JetSessID,
                        pDB->JetLinkTbl,
                        JET_bitSeekEQ);
        if (Operation == FI_CHOICE_EQUALITY && err == JET_errSuccess) {
            return eTRUE;
        } else if (Operation == FI_CHOICE_NOT_EQUAL && err == JET_errRecordNotFound) {
            return eTRUE;
        } else {
            return eFALSE;
        }
    
    }
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* The function applies the specified boolean operation on a given attribute
   type.  The supplied attribute value is compared against the attribute on
   the current database object.  Note that for multi-valued attributes, a
   TRUE result is returned if the operation is true for any of the attribute
   values.  For example, an equality test for a member JOE in a group of
   names is true if JOE is any value of the group.

   First the attribute is located in the object.  If the entire attribute
   is missing the evaluation is FALSE.  Otherwise, the client value is
   converted to internal form and is tested against each value in the
   attribute.  gDBSyntax performs the test according to the attribute syntax.
*/


TRIBOOL
dbEvalInt (
        DBPOS FAR *pDB,
        BOOL fUseSearchTbl,
        UCHAR Operation,
        ATTRTYP type,
            ULONG valLenFilter,
        UCHAR *pValFilter,
        BOOL *pbSkip
        )
{

    UCHAR   syntax;
    ULONG   attLenRec;
    UCHAR   *pAttValRec;
    BOOL    fDoneOne = FALSE;
    ULONG   NthValIndex;
    ATTCACHE *pAC;
    ULONG   bufSize;
    DWORD   flags;
    DWORD   err;

    Assert(VALID_DBPOS(pDB));

    if(Operation == FI_CHOICE_TRUE) {
        return eTRUE;
    }
    else if(Operation == FI_CHOICE_FALSE) {
        return eFALSE;
    }
    else if(Operation == FI_CHOICE_UNDEFINED) {
        return eUNDEFINED;
    }

    DPRINT3(2, "dbEvalInt entered, apply filter test operation <%u>"
            "att type <%lu>, val <%s>\n",
            Operation, type, asciiz(pValFilter,(USHORT)valLenFilter));

    // perform the access check for this att.  if the skip value exists and is
    // TRUE then we must evaluate the filter as if no value was set for this
    // att
    
    if(pbSkip && *pbSkip) {
        DPRINT(5,"An att value failed the access check..return FALSE\n");
        if (Operation == FI_CHOICE_NOT_EQUAL) {
            return eTRUE;
        }
        return eFALSE;
    }

    // if this was an exact match on a qualifying exact match filter then we
    // can skip the actual evaluation and return eTRUE because we already have
    // evaluated the filter on this object during filter optimization

    if (IsExactMatch(pDB)) {
        DPRINT(5,"An att value passed the compare test by exact match..return TRUE\n");
        Assert(Operation != FI_CHOICE_NOT_EQUAL);
        return eTRUE;
    }

    pAC = SCGetAttById(pDB->pTHS, type);
    Assert(pAC != NULL);
    // although we guarantee that this is ok, better check
    if (!pAC) {
        // NTRAID#NTRAID-550491-2002/02/21-andygo:  SECURITY:  a failure during DBEval or DBEvalFilter returns a distinct error from a non-match
        // REVIEW:  if someone causes an error in Eval() then they could figure it out due to the
        // REVIEW:  different error code returned in this case
        return eUNDEFINED;
    }
    bufSize = 0;
    flags = DBGETATTVAL_fINTERNAL | DBGETATTVAL_fREALLOC;

    if(fUseSearchTbl) {
        flags |= DBGETATTVAL_fUSESEARCHTABLE;
    }

    // if this is a dn-valued linked attribute then we can optimize the evaluation

    if (pAC->ulLinkID && pAC->syntax == SYNTAX_DISTNAME_TYPE) {
        return dbEvalLinkAtt(pDB, fUseSearchTbl, Operation, pAC, valLenFilter, pValFilter);
    }

    // Get the first value to consider.
    NthValIndex = 1;
    if (pAC->ulLinkID) {
        err = DBGetNextLinkVal_AC (pDB, TRUE, pAC, flags, bufSize, &attLenRec,
                                   &pAttValRec);
    }
    else {
        err = DBGetAttVal_AC(pDB, NthValIndex, pAC, flags, bufSize, &attLenRec,
                             &pAttValRec);
    }

    while(!err) {
            DPRINT(5,"Applying test to next attribute value\n");

        bufSize = max(bufSize, attLenRec);

        fDoneOne = TRUE;

        switch(gDBSyntax[pAC->syntax].Eval(pDB, Operation, valLenFilter,
                                               pValFilter, attLenRec, pAttValRec)) {
            case TRUE:
                DPRINT(5,"An att value passed the compare test..return TRUE\n");
                THFree(pAttValRec);
                return eTRUE;

            case FALSE:
                DPRINT(5,"This att value failed test continue testing\n");
                break;

            default:
                DPRINT(5, "Eval syntax  compare failed ..return FALSE\n");
                THFree(pAttValRec);
                // NTRAID#NTRAID-550491-2002/02/21-andygo:  SECURITY:  a failure during DBEval or DBEvalFilter returns a distinct error from a non-match
                // REVIEW:  if someone causes an error in Eval() then they could figure it out due to the
                // REVIEW:  different error code returned in this case
                return eUNDEFINED;  /*return error stuff here*/
        }/*switch*/


        // Get the next value to consider.
        NthValIndex++;
        if(pAC->ulLinkID) {
            err = dbGetNthNextLinkVal (pDB, 1, &pAC, flags, bufSize, &pAttValRec,
                                       &attLenRec);
        }
        else {
            if (pAC->isSingleValued) {
                err = DB_ERR_NO_VALUE;
            }
            else {
                err = DBGetAttVal_AC(pDB, NthValIndex, pAC, flags, bufSize,
                                     &attLenRec, &pAttValRec);
            }
        }
    } /*while*/

    if(bufSize)
        THFree(pAttValRec);

    DPRINT(2,"All attribute values failed the test..return FALSE\n");

    if(fDoneOne) {
        // We looked at at least one value, and it failed the test;
        // so, return FALSE;
        return eFALSE;
    }

    // We didn't look at any values.  If the comparison was !=, we passed;
    // otherwise, we failed.

    if (Operation == FI_CHOICE_NOT_EQUAL) {
        return eTRUE;
    }

    return eFALSE;
}  /* dbEvalInt*/



TRIBOOL
DBEval (
        DBPOS FAR *pDB,
        UCHAR Operation,
        ATTCACHE *pAC,
            ULONG valLenFilter,
        UCHAR *pValFilter
        )
{
    ULONG len;
    PUCHAR pVal;
    ULONG  ulFlags=0;


    Assert(VALID_DBPOS(pDB));

    if (DBIsSecretData(pAC->id))
       ulFlags|=EXTINT_SECRETDATA;

    if (gDBSyntax[pAC->syntax].ExtInt(pDB,
                                      DBSYN_INQ,
                                      valLenFilter,
                                      pValFilter,
                                      &len,
                                      &pVal,
                                      0,
                                      0,
                                      ulFlags)) {
        DPRINT(5,"An att value failed conversion..return FALSE\n");
        if (Operation == FI_CHOICE_NOT_EQUAL) {
            return eTRUE;
        }
        return eFALSE;
    }

    return dbEvalInt(pDB, FALSE, Operation, pAC->id, len, pVal,NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dblayer\dbinit.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbinit.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <errno.h>
#include <dsjet.h>
#include <dsconfig.h>

#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <dbopen.h>
#include <mdglobal.h>
#include <mdlocal.h>
#include <dsatools.h>

#include <mdcodes.h>
#include <dsevent.h>

#include <dsexcept.h>
#include "anchor.h"
#include "objids.h"     /* Contains hard-coded Att-ids and Class-ids */
#include "usn.h"

#include "debug.h"      /* standard debugging header */
#define DEBSUB     "DBINIT:"   /* define the subsystem for debugging */

#include <ntdsctr.h>
#include <dstaskq.h>
#include <crypto\md5.h>
#include "dbintrnl.h"
#include <quota.h>

#include <fileno.h>
#define  FILENO FILENO_DBINIT


/* Prototypes for internal functions. */

int APIENTRY DBAddSess(JET_SESID sess, JET_DBID dbid);
int APIENTRY DBEndSess(JET_SESID sess);
void DBEnd(void);
VOID PASCAL FAR DBEndSig(USHORT sig, USHORT signo);
CRITICAL_SECTION csHiddenDBPOS;
DWORD dbCheckLocalizedIndices (JET_SESID sesid,JET_TABLEID tblid);
JET_ERR dbCreateHiddenDBPOS (void);
USHORT dbCloseHiddenDBPOS (void);



/*
 * External variables from dbopen.c
 */
extern DWORD gcOpenDatabases;
extern BOOL  gFirstTimeThrough;
extern BOOL  gfNeedJetShutdown;

/*
 * External variables from dbtools.c
 */
extern BOOL gfEnableReadOnlyCopy;

/*
 * External variables from dbobj.c
 */
extern DWORD gMaxTransactionTime;

//  external variables from dsamain.c
//
extern HANDLE   hevIndexRebuildUI;


/*
 * Global variables
 */
CRITICAL_SECTION csSessions;
CRITICAL_SECTION csAddList;
DSA_ANCHOR gAnchor;
NT4SID *pgdbBuiltinDomain=NULL;
HANDLE hevDBLayerClear;

JET_INSTANCE    jetInstance = 0;

JET_COLUMNID dsstateid;
JET_COLUMNID dsflagsid;
JET_COLUMNID jcidBackupUSN;
JET_COLUMNID jcidBackupExpiration;

//
// Setting Flags stored in the database
//
CHAR gdbFlags[200];

// These used to be declared static.  Consider this if there is a problem with these.
JET_TABLEID     HiddenTblid;
DBPOS   FAR     *pDBhidden=NULL;


// This semaphore limits our usage of JET sessions
HANDLE hsemDBLayerSessions;


// This array keeps track of opened JET sessions.

typedef struct {
        JET_SESID       sesid;
        JET_DBID        dbid;
} OPENSESS;

extern OPENSESS *opensess;

typedef struct {
        JET_SESID sesid;
        DBPOS *pDB;
        DWORD tid;
        DSTIME atime;
}JET_SES_DATA;


#if DBG
// This array is used by the debug version to keep track of allocated
// DBPOS structures.
#define MAXDBPOS 1000
extern JET_SES_DATA    opendbpos[];
extern int DBPOScount;
extern CRITICAL_SECTION csDBPOS;
#endif // DBG





OPENSESS *opensess;

#if DBG

// This array is used by the debug version to keep track of allocated
// DBPOS structures.

JET_SES_DATA    opendbpos[MAXDBPOS];
int DBPOScount = 0;
CRITICAL_SECTION csDBPOS;


// These 3 routines are used to consistency check our transactions and
// DBPOS handling.

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
// This function checks that jet session has no pdbs

void APIENTRY dbCheckJet (JET_SESID sesid){
    int i;
    EnterCriticalSection(&csDBPOS);
    __try
    {
        for (i=0;i < MAXDBPOS; i++){
            if (opendbpos[i].sesid == sesid){
                DPRINT(0,"Warning, closed session with open transactions\n");

                // Clean up so we don't get repeat warning of the same problem.

                opendbpos[i].pDB = 0;
                opendbpos[i].sesid = 0;
                opendbpos[i].tid = 0;
            }
        }
    }
    __finally
    {
        LeaveCriticalSection(&csDBPOS);
    }
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function registers pDBs
*/

extern void APIENTRY dbAddDBPOS(DBPOS *pDB, JET_SESID sesid){

    int i;
    BOOL fFound = FALSE;

    EnterCriticalSection(&csDBPOS);
    __try
    {
        for (i=0; i < MAXDBPOS; i++)
        {
            if (opendbpos[i].pDB == 0)
            {
                opendbpos[i].pDB = pDB;
                opendbpos[i].sesid = sesid;
                opendbpos[i].tid = GetCurrentThreadId();
                opendbpos[i].atime = DBTime();
                DBPOScount++;
                if (pTHStls) {
                    DPRINT3(3,"DBAddpos dbpos count is %x, sess %lx, pDB %x\n",pTHStls->opendbcount, sesid, pDB);
                }

                fFound = TRUE;
                break;
            }
        }

        // if we have run out of slots, it is probably a bug.
        Assert(fFound);
    }
    __finally
    {
        LeaveCriticalSection(&csDBPOS);
    }

    return;
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function deletes freed pDBs
*/

extern void APIENTRY dbEndDBPOS(DBPOS *pDB){

    int i;
    BOOL fFound = FALSE;

    EnterCriticalSection(&csDBPOS);
    __try
    {
        for (i=0; i < MAXDBPOS; i++)
        {
            if (opendbpos[i].pDB == pDB)
            {
                DBPOScount--;
                if (pTHStls) {
                    DPRINT3(3,"DBEndpos dbpos count is %x, sess %lx, pDB %x\n",pTHStls->opendbcount, opendbpos[i].sesid, pDB);
                }
                opendbpos[i].pDB = 0;
                opendbpos[i].sesid = 0;
                opendbpos[i].tid = 0;

                fFound = TRUE;
                break;
            }
        }

        // At this point if we couldn't find the DBPOS to remove it, assert.
        Assert(fFound);
    }
    __finally
    {
        LeaveCriticalSection(&csDBPOS);
    }
    return;
}

#endif  // DEBUG

// Define the parameters for new database columns

/*
Design note on the implementation of the present indicator for link rows.
Jliem writes:
First thing to note is that it sounds like you don't even need the column
in the index.  Create the index with your indicator column specified as a
conditional column.  We will automatically filter out records from the index
when the column is NULL.
The JET_INDEXCREATE structure you pass to JetCreateIndex() has a
JET_CONDITIONALCOLUMN member.  Fill that out.  Unfortunately, ESENT only supports
one conditional column per index, so set the cConditionalColumns member to 1
(ESE98 supports up to 12).  Also, you need to set the grbit member of in the
JET_CONDITIONALCOLUMN structure to JET_bitIndexColumnMustBeNonNull
(or JET_bitIndexColumnMustBeNull if you want the record in the index only if
the column is NULL).
*/

// This is the structure that defines a new column in an existing table
typedef struct {
    char *pszColumnName;
    JET_COLUMNID *pColumnId;
    JET_COLTYP ColumnType;
    JET_GRBIT  grbit;
    unsigned long cbMax;
    PVOID pvDefault;
    unsigned long cbDefault;
} CREATE_COLUMN_PARAMS, *PCREATE_COLUMN_PARAMS;

// New columns in the link table
CREATE_COLUMN_PARAMS rgCreateLinkColumns[] = {
    // create link deletion time id
    { SZLINKDELTIME, &linkdeltimeid, JET_coltypCurrency, JET_bitColumnFixed, 0, NULL, 0 },
    // create link usn changed id
    { SZLINKUSNCHANGED, &linkusnchangedid, JET_coltypCurrency, JET_bitColumnFixed, 0, NULL, 0 },
    // create link nc dnt id
    { SZLINKNCDNT, &linkncdntid, JET_coltypLong, JET_bitColumnFixed, 0, NULL, 0 },
    // create link metadata id
    { SZLINKMETADATA, &linkmetadataid, JET_coltypBinary, 0, 255, NULL, 0 },
    0
};


DWORD	g_dwRefCountDefaultValue		= 1;	//	for DeleteOnZero columns
DWORD	g_dwEscrowDefaultValue			= 0;	//	for non-DeleteOnZero columns


// new columns in the SD table
CREATE_COLUMN_PARAMS rgCreateSDColumns[] = {
    // id
    { SZSDID, &sdidid, JET_coltypCurrency, JET_bitColumnFixed | JET_bitColumnAutoincrement, 0, NULL, 0 },
    // hash value
    { SZSDHASH, &sdhashid, JET_coltypBinary, JET_bitColumnFixed, MD5DIGESTLEN, NULL, 0 },
    // refcount
    { SZSDREFCOUNT, &sdrefcountid, JET_coltypLong,
      JET_bitColumnFixed | JET_bitColumnEscrowUpdate | JET_bitColumnDeleteOnZero,
      0, &g_dwRefCountDefaultValue, sizeof(g_dwRefCountDefaultValue)
    },
    // actual SD value (create as tagged since can not estimate upper bound for a variable length column)
    { SZSDVALUE, &sdvalueid, JET_coltypLongBinary, JET_bitColumnTagged, 0, NULL, 0 },
    0
};

// new columns in the SD prop table
CREATE_COLUMN_PARAMS rgCreateSDPropColumns[] = {
    // SD prop flags
    { SZSDPROPFLAGS, &sdpropflagsid, JET_coltypLong, JET_bitColumnFixed, 0, NULL, 0 },
    // SD prop checkpoint
    { SZSDPROPCHECKPOINT, &sdpropcheckpointid, JET_coltypLongBinary, JET_bitColumnTagged, 0, NULL, 0 },
    0
};


JET_COLUMNCREATE	g_rgcolumncreateQuotaTable[]	=
	{
		{
		sizeof(JET_COLUMNCREATE),
		g_szQuotaColumnNcdnt,		//	NCDNT of owner
		JET_coltypLong,
		0,							//	cbMax
		JET_bitColumnNotNULL,
		NULL,						//	pvDefault
		0,							//	cbDefault
		0,							//	cp
		JET_columnidNil,
		JET_errSuccess
		},

		{
		sizeof(JET_COLUMNCREATE),
		g_szQuotaColumnSid,			//	SID of owner
		JET_coltypBinary,
		0,							//	cbMax
		JET_bitColumnNotNULL,
		NULL,						//	pvDefault
		0,							//	cbDefault
		0,							//	cp
		JET_columnidNil,
		JET_errSuccess
		},

		{
		sizeof(JET_COLUMNCREATE),
		g_szQuotaColumnTombstoned,	//	escrowed count of tombstoned objects owned
		JET_coltypLong,
		0,							//	cbMax
		JET_bitColumnEscrowUpdate,
		&g_dwEscrowDefaultValue,
		sizeof( g_dwEscrowDefaultValue ),
		0,							//	cp
		JET_columnidNil,
		JET_errSuccess
		},

		//	NOTE: we store "tombstoned" and "total" instead
		//	of the more intuitive "tombstoned" and "live"
		//	so that the record may be finalized
		//
		{
		sizeof(JET_COLUMNCREATE),
		g_szQuotaColumnTotal,		//	escrowed count of total objects owned (live == total - tombstoned)
		JET_coltypLong,
		0,							//	cbMax
		JET_bitColumnEscrowUpdate|JET_bitColumnDeleteOnZero,
		&g_dwRefCountDefaultValue,
		sizeof( g_dwRefCountDefaultValue ),
		0,							//	cp
		JET_columnidNil,
		JET_errSuccess
		}
	};

CHAR g_rgchQuotaIndexKey[]	= "+" g_szQuotaColumnNcdnt "\0+" g_szQuotaColumnSid "\0";

JET_INDEXCREATE		g_rgindexcreateQuotaTable[]		=
	{
		{
		sizeof(JET_INDEXCREATE),
		g_szQuotaIndexNcdntSid,
		g_rgchQuotaIndexKey,
		sizeof(g_rgchQuotaIndexKey),
		JET_bitIndexPrimary | JET_bitIndexUnique | JET_bitIndexDisallowNull,
		GENERIC_INDEX_DENSITY,
		0,			//	lcid
		0,			//	cbVarSegMac
		NULL,		//	rgConditionalColumn
		0,			//	cConditionalColumn
		JET_errSuccess
		}
	};

JET_TABLECREATE		g_tablecreateQuotaTable		=
	{
	sizeof(JET_TABLECREATE),
	g_szQuotaTable,
	NULL,					//	template table name
	1,						//	initial pages
	GENERIC_INDEX_DENSITY,
	g_rgcolumncreateQuotaTable,
	sizeof( g_rgcolumncreateQuotaTable ) / sizeof( g_rgcolumncreateQuotaTable[0] ),
	g_rgindexcreateQuotaTable,
	sizeof( g_rgindexcreateQuotaTable ) / sizeof( g_rgindexcreateQuotaTable[0] ),
	JET_bitTableCreateFixedDDL,
	JET_tableidNil,
	0						//	returned count of created objects
	};


JET_COLUMNCREATE	g_rgcolumncreateQuotaRebuildProgressTable[]	=
	{
		{
		sizeof(JET_COLUMNCREATE),
		g_szQuotaRebuildColumnDNTLast,		//	progress of quota rebuild
		JET_coltypLong,
		0,									//	cbMax
		JET_bitColumnNotNULL,
		NULL,								//	pvDefault
		0,									//	cbDefault
		0,									//	cp
		JET_columnidNil,
		JET_errSuccess
		},

		{
		sizeof(JET_COLUMNCREATE),
		g_szQuotaRebuildColumnDNTMax,		//	max DNT that quota rebuild task needs to process
		JET_coltypLong,
		0,									//	cbMax
		JET_bitColumnNotNULL,
		NULL,								//	pvDefault
		0,									//	cbDefault
		0,									//	cp
		JET_columnidNil,
		JET_errSuccess
		},

		{
		sizeof(JET_COLUMNCREATE),
		g_szQuotaRebuildColumnDone,			//	if TRUE, then Quota table was successfully and completely rebuilt
		JET_coltypBit,
		0,									//	cbMax
		NO_GRBIT,
		NULL,								//	pvDefault
		0,									//	cbDefault
		0,									//	cp
		JET_columnidNil,
		JET_errSuccess
		}
	};

JET_TABLECREATE		g_tablecreateQuotaRebuildProgressTable		=
	{
	sizeof(JET_TABLECREATE),
	g_szQuotaRebuildProgressTable,
	NULL,					//	template table name
	1,						//	initial pages
	GENERIC_INDEX_DENSITY,
	g_rgcolumncreateQuotaRebuildProgressTable,
	sizeof( g_rgcolumncreateQuotaRebuildProgressTable ) / sizeof( g_rgcolumncreateQuotaRebuildProgressTable[0] ),
	NULL,					//	rgindexcreate
	0,						//	cIndexes
	JET_bitTableCreateFixedDDL,
	JET_tableidNil,
	0						//	returned count of created objects
	};


#ifdef AUDIT_QUOTA_OPERATIONS

JET_COLUMNCREATE	g_rgcolumncreateQuotaAuditTable[]	=
	{
		{
		sizeof(JET_COLUMNCREATE),
		g_szQuotaAuditColumnNcdnt,	//	NCDNT of object
		JET_coltypLong,
		0,							//	cbMax
		JET_bitColumnNotNULL,
		NULL,						//	pvDefault
		0,							//	cbDefault
		0,							//	cp
		JET_columnidNil,
		JET_errSuccess
		},

		{
		sizeof(JET_COLUMNCREATE),
		g_szQuotaAuditColumnSid,	//	SID of object
		JET_coltypBinary,
		0,							//	cbMax
		JET_bitColumnNotNULL,
		NULL,						//	pvDefault
		0,							//	cbDefault
		0,							//	cp
		JET_columnidNil,
		JET_errSuccess
		},

		{
		sizeof(JET_COLUMNCREATE),
		g_szQuotaAuditColumnDnt,	//	DNT of object
		JET_coltypLong,
		0,							//	cbMax
		JET_bitColumnNotNULL,
		NULL,						//	pvDefault
		0,							//	cbDefault
		0,							//	cp
		JET_columnidNil,
		JET_errSuccess
		},

		{
		sizeof(JET_COLUMNCREATE),
		g_szQuotaAuditColumnOperation,	//	quota operation performed for object
		JET_coltypText,
		0,								//	cbMax
		JET_bitColumnNotNULL,
		NULL,							//	pvDefault
		0,								//	cbDefault
		0,								//	cp
		JET_columnidNil,
		JET_errSuccess
		}
	};

JET_TABLECREATE		g_tablecreateQuotaAuditTable	=
	{
	sizeof(JET_TABLECREATE),
	g_szQuotaAuditTable,
	NULL,					//	template table name
	1,						//	initial pages
	100,					//	ulDensity
	g_rgcolumncreateQuotaAuditTable,
	sizeof( g_rgcolumncreateQuotaAuditTable ) / sizeof( g_rgcolumncreateQuotaAuditTable[0] ),
	NULL,					//	rgindexcreate
	0,						//	cIndexes
	JET_bitTableCreateFixedDDL,
	JET_tableidNil,
	0						//	returned count of created objects
	};

#endif	//	AUDIT_QUOTA_OPERATIONS



// This structure is shared by the RecreateFixedIndices routine.
// This is the structure that defines a new index
typedef struct
{
    char        *szIndexName;
    char        *szIndexKeys;
    ULONG       cbIndexKeys;
    ULONG       ulFlags;
    ULONG       ulDensity;
    JET_INDEXID *pidx;
    JET_CONDITIONALCOLUMN *pConditionalColumn;
}   CreateIndexParams;

// Index keys for the link table
char rgchLinkDelIndexKeys[] = "+" SZLINKDELTIME "\0+" SZLINKDNT "\0+" SZBACKLINKDNT "\0";
char rgchLinkDraUsnIndexKeys[] = "+" SZLINKNCDNT "\0+" SZLINKUSNCHANGED "\0+" SZLINKDNT "\0";
char rgchLinkIndexKeys[] = "+" SZLINKDNT "\0+" SZLINKBASE "\0+" SZBACKLINKDNT "\0+" SZLINKDATA "\0";
char rgchBackLinkIndexKeys[] = "+" SZBACKLINKDNT "\0+" SZLINKBASE "\0+" SZLINKDNT "\0";
// Note the third segment of this key is descending. This is intended.
char rgchLinkAttrUsnIndexKeys[] = "+" SZLINKDNT "\0+" SZLINKBASE "\0-" SZLINKUSNCHANGED "\0";

// Conditional column definition
// When LINKDELTIME is non-NULL (row absent), filter the row out of the index.
JET_CONDITIONALCOLUMN CondColumnLinkDelTimeNull = {
    sizeof( JET_CONDITIONALCOLUMN ),
    SZLINKDELTIME,
    JET_bitIndexColumnMustBeNull
};
// When LINKUSNCHANGED is non-NULL (row has metadata), filter the row out of the index.
JET_CONDITIONALCOLUMN CondColumnLinkUsnChangedNull = {
    sizeof( JET_CONDITIONALCOLUMN ),
    SZLINKUSNCHANGED,
    JET_bitIndexColumnMustBeNull
};

// Indexes to be created
// This is for indexes that did not exist in the Product 1 DIT
// Note that it is NOT necessary to also put these definitions in mkdit.ini.
// The reason is that when mkdit.exe is run, dbinit will be run, and this
// very code will upgrade the dit before it is saved to disk.

// The old SZLINKINDEX is now known by SZLINKALLINDEX
// The old SZBACKLINKINDEX is now know by SZBACKLINKALLINDEX

CreateIndexParams rgCreateLinkIndexes[] = {
    // Create new link present index
    { SZLINKINDEX,
      rgchLinkIndexKeys, sizeof( rgchLinkIndexKeys ),
      JET_bitIndexUnique, 90, &idxLink, &CondColumnLinkDelTimeNull },

    // Create new backlink present index
    { SZBACKLINKINDEX,
      rgchBackLinkIndexKeys, sizeof( rgchBackLinkIndexKeys ),
      0, 90, &idxBackLink, &CondColumnLinkDelTimeNull },

    // Create link del time index
    { SZLINKDELINDEX,
      rgchLinkDelIndexKeys, sizeof( rgchLinkDelIndexKeys ),
      JET_bitIndexIgnoreNull | JET_bitIndexIgnoreAnyNull,
      98, &idxLinkDel, NULL },

    // Create link dra usn index (has metadata)
    { SZLINKDRAUSNINDEX,
      rgchLinkDraUsnIndexKeys, sizeof( rgchLinkDraUsnIndexKeys ),
      JET_bitIndexUnique | JET_bitIndexIgnoreNull | JET_bitIndexIgnoreAnyNull,
      100, &idxLinkDraUsn, NULL },

    // Create new link legacy index (does not have metadata)
    { SZLINKLEGACYINDEX,
      rgchLinkIndexKeys, sizeof( rgchLinkIndexKeys ),
      JET_bitIndexUnique, 90, &idxLinkLegacy, &CondColumnLinkUsnChangedNull },

    // Create link attr usn index (has metadata)
    { SZLINKATTRUSNINDEX,
      rgchLinkAttrUsnIndexKeys, sizeof( rgchLinkAttrUsnIndexKeys ),
      JET_bitIndexUnique | JET_bitIndexIgnoreNull | JET_bitIndexIgnoreAnyNull,
      100, &idxLinkAttrUsn, NULL },

    0
};
DWORD cNewLinkIndexes = ((sizeof(rgCreateLinkIndexes) / sizeof(CreateIndexParams)) - 1);

// Index keys for the SD table
char rgchSDIdIndexKeys[] = "+" SZSDID "\0";
char rgchSDHashIndexKeys[] = "+" SZSDHASH "\0";

// SD Indexes to be created
CreateIndexParams rgCreateSDIndexes[] = {
    // SD id index
    { SZSDIDINDEX,
      rgchSDIdIndexKeys, sizeof( rgchSDIdIndexKeys ),
      JET_bitIndexUnique | JET_bitIndexPrimary,
      100, &idxSDId, NULL },

    // SD hash index
    { SZSDHASHINDEX,
      rgchSDHashIndexKeys, sizeof( rgchSDHashIndexKeys ),
      0,
      90, &idxSDHash, NULL },

    0
};
DWORD cNewSDIndexes = ((sizeof(rgCreateSDIndexes) / sizeof(CreateIndexParams)) - 1);


//	convert SZSDREFCOUNT column from
//	JET_bitColumnFinalize to JET_bitColumnDeleteOnZero
//
JET_ERR dbConvertSDRefCount(
	JET_SESID				sesid,
	JET_DBID				dbid,
	JET_COLUMNDEF *			pcoldef )
	{
	JET_ERR					err;
	JET_DDLCHANGECOLUMN		changecolumn;

	pcoldef->grbit &= ~JET_bitColumnFinalize;
	pcoldef->grbit |= JET_bitColumnDeleteOnZero;

	changecolumn.szTable = SZSDTABLE;
	changecolumn.szColumn = SZSDREFCOUNT;
	changecolumn.coltypNew = pcoldef->coltyp;
	changecolumn.grbitNew = pcoldef->grbit;

	//	[jliem - 06/23/02]
	//	WARNING! WARNING!  This call will update the catalog,
	//	buf not the cached schema.  In order for the cached
	//	schema to be updated, we would need to detach the
	//	the database and re-attach.  However, we're relying
	//	on the fact that currently, Jet maps Finalize and
	//	DeleteOnZero to the same functionality (namely,
	//	DeleteOnZero).  We're explicitly changing the
	//	column from Finalize to DeleteOnZero now in case
	//	Jet modifies the semantic in the future to truly
	//	support Finalize (which would have to happen if the
	//	ESE and ESENT code bases were to merge)
	//
	Call( JetConvertDDL(
				sesid,
				dbid,
				opDDLConvChangeColumn,
				&changecolumn,
				sizeof(changecolumn) ) );

HandleError:
	return err;
	}

JET_ERR
dbCreateNewColumns(
    JET_SESID initsesid,
    JET_DBID dbid,
    JET_TABLEID tblid,
    PCREATE_COLUMN_PARAMS pCreateColumns
    )

/*++

Routine Description:

    Query Jet for the Column and Index ID's of the named items. If the item
    does not exist, create it.

Arguments:

    initsesid - Jet session
    tblid - Jet table
    pCreateColumns - array of column defintions to query/create

Return Value:

    JET_ERR - Jet error code

--*/

	{
	JET_ERR					err		= JET_errSuccess;
	JET_COLUMNDEF			coldef;
	PCREATE_COLUMN_PARAMS	pColumn;

	//
	// Lookup or Create new columns
	//

	for ( pColumn = pCreateColumns;
		pColumn->pszColumnName != NULL;
		pColumn++ ) {

		err = JetGetTableColumnInfo(
						initsesid,
						tblid,
						pColumn->pszColumnName,
						&coldef,
						sizeof(coldef),
						JET_ColInfo );
		if ( JET_errColumnNotFound == err )
			{
			// If column not present, add it

			ZeroMemory( &coldef, sizeof(coldef) );
			coldef.cbStruct = sizeof( JET_COLUMNDEF );
			coldef.coltyp = pColumn->ColumnType;
			coldef.grbit = pColumn->grbit;
			coldef.cbMax = pColumn->cbMax;

			Call( JetAddColumn(
						initsesid,
						tblid,
						pColumn->pszColumnName,
						&coldef,
						pColumn->pvDefault,
						pColumn->cbDefault,
						&coldef.columnid ) );

			DPRINT1( 0, "Added new column %s.\n", pColumn->pszColumnName );
			}
		else
			{
			CheckErr( err );

			//	convert Finalize columns to a DeleteOnZero column
			//	(currently, the only Finalize column the DS uses
			//	should be SZSDREFCOUNT)
			//
			Assert( !( coldef.grbit & JET_bitColumnFinalize )
				|| 0 == strcmp( pColumn->pszColumnName, SZSDREFCOUNT ) );
			if ( ( coldef.grbit & JET_bitColumnFinalize )
				&& 0 == strcmp( pColumn->pszColumnName, SZSDREFCOUNT ) )
				{
				Call( dbConvertSDRefCount( initsesid, dbid, &coldef ) );
				}
		    }

	    *(pColumn->pColumnId) = coldef.columnid;
		}

HandleError:
	return err;
	} /* createNewColumns */



// Max no of retries for creating an index
#define MAX_INDEX_CREATE_RETRY_COUNT 3


JET_ERR
dbCreateIndexBatch(
    JET_SESID sesid,
    JET_TABLEID tblid,
    DWORD cIndexCreate,
    JET_INDEXCREATE *pIndexCreate
    )

/*++

Routine Description:

Create multiple indexes together in a batch. Retries with smaller
batch sizes if necessary.

The caller has already determined that the indexes do not exist.

This helper routine is used by createNewIndexes and dbRecreateFixedIndexes

Arguments:

    initsesid - database session
    tblid - table cursor
    cIndexCreate - Number of indexes to actually create
    pIndexCreate - Array of jet index create structures

Return Value:

    JET_ERR -

--*/

{
    JET_ERR     err                     = 0;
    ULONG       last                    = 0;
    ULONG       remaining               = cIndexCreate;
    ULONG       maxNoOfIndicesInBatch   = cIndexCreate;
    ULONG       retryCount              = 0;
    ULONG_PTR   ulCacheSizeSave         = 0;

    //  shouldn't call this function if there's nothing to do
    //
    Assert( remaining > 0 );

    LogEvent(
        DS_EVENT_CAT_INTERNAL_PROCESSING,
        DS_EVENT_SEV_ALWAYS,
        DIRLOG_BATCH_INDEX_BUILD_STARTED,
        szInsertInt( cIndexCreate ),
        NULL,
        NULL );

    //  the DS is the only thing running at this point,
    //  so hog as much memory as possible (only do so
    //  if we're going to use Jet's batch mode, that
    //  is, if there is more than one index to build)
    //
    Call( JetGetSystemParameter(
                0,
                0,
                JET_paramCacheSizeMax,
                &ulCacheSizeSave,
                NULL,
                sizeof(ulCacheSizeSave) ) );

    if ( 0 != ulCacheSizeSave )
        {
        Call( JetSetSystemParameter(
                    0,
                    0,
                    JET_paramCacheSizeMax,
                    0x7fffffff,     //  set arbitrarily large, Jet will cap it at physical RAM as necessary
                    NULL ) );
        }

    while (remaining > 0) {
        const ULONG noToCreate  = ( remaining > maxNoOfIndicesInBatch ?
                                            maxNoOfIndicesInBatch :
                                            remaining );

        err = JetCreateIndex2(sesid,
                              tblid,
                              &(pIndexCreate[last]),
                              noToCreate);

        switch(err) {
            case JET_errSuccess:
                DPRINT1(0, "%d index batch successfully created\n", noToCreate );
                // reset retryCount
                retryCount = 0;
                break;

            case JET_errDiskFull:
            case JET_errLogDiskFull:
                DPRINT1(1, "Ran out of disk space, trying again with a reduced batch size (retryCount is %d)\n", retryCount);
                retryCount++;

                //  halve the batch size, unless this is going to be our last retry
                //
                if ( maxNoOfIndicesInBatch > 1 ) {
                    switch ( retryCount ) {
                        case 1:
                            maxNoOfIndicesInBatch = min( 16, maxNoOfIndicesInBatch / 2 );
                            break;
                        case 2:
                            maxNoOfIndicesInBatch = min( 4, maxNoOfIndicesInBatch / 2 );
                            break;
                        default:
                            maxNoOfIndicesInBatch = 1;
                    }
                }
                break;

            case JET_errKeyDuplicate:
                //  we can assume that this is the PDNT/RDN index because it is
                //  the only unique Unicode index that could have been affected
                //  by the change to our LCMapString flags.  there are cases
                //  where keys that once were unique are now not.  those keys
                //  are long enough to be truncated and have - or ' early on in
                //  the column data and were just barely different before.  we
                //  hope, hope, hope that this is rare!
                DPRINT(0, "Duplicate key encountered when rebuilding the PDNT/RDN index!\n");
                // reset retryCount
                retryCount = 0;
                LogEvent(
                    DS_EVENT_CAT_INTERNAL_PROCESSING,
                    DS_EVENT_SEV_ALWAYS,
                    DIRLOG_PDNT_INDEX_CORRUPT,
                    NULL,
                    NULL,
                    NULL );
                break;

            default:
                // Huh?
                DPRINT1(0, "JetCreateIndex failed. Error = %d\n", err);
                // reset retryCount, we do not retry on these errors
                retryCount = 0;
                break;
        }

        if (retryCount && (retryCount <= MAX_INDEX_CREATE_RETRY_COUNT)) {
            // continue with smaller batch size set
            err = 0;
            LogEvent(
                DS_EVENT_CAT_INTERNAL_PROCESSING,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_BATCH_INDEX_BUILD_RETRY,
                szInsertInt( noToCreate ),
                szInsertInt( maxNoOfIndicesInBatch ),
                NULL );
            continue;
        }

        CheckErr( err );

        // success, so adjust for next batch
        last += noToCreate;
        remaining -= noToCreate;
    }

HandleError:
    if ( JET_errSuccess == err )
        {
        LogEvent(
            DS_EVENT_CAT_INTERNAL_PROCESSING,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_BATCH_INDEX_BUILD_SUCCEEDED,
            szInsertInt( cIndexCreate ),
            NULL,
            NULL );
        }
    else
        {
        LogEvent(
            DS_EVENT_CAT_INTERNAL_PROCESSING,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_BATCH_INDEX_BUILD_FAILED,
            szInsertInt( cIndexCreate ),
            szInsertJetErrCode( err ),
            szInsertJetErrMsg( err ) );
        }

    //  restore original cache size
    //
    if ( 0 != ulCacheSizeSave )
        {
        const JET_ERR   errT    = JetSetSystemParameter(
                                            0,
                                            0,
                                            JET_paramCacheSizeMax,
                                            ulCacheSizeSave,
                                            NULL );

        //  only report the error from this call to JetSetSystemParameter
        //  if everything else in this function succeeded
        //
        if ( err >= JET_errSuccess && errT < JET_errSuccess )
            {
            err = errT;
            }
        }

    return err;

} /* createIndexBatch */


JET_ERR
dbCreateNewIndexesBatch(
    JET_SESID initsesid,
    JET_TABLEID tblid,
    DWORD cIndexCreate,
    CreateIndexParams *pCreateIndexes
    )

/*++

Routine Description:

    Create missing indexes
    BUGBUG WLEES 03/02/00
    This function dbCreateNewIndexesBatch, doesn't seem to work
    reliably with conditional columns. This is with ESE97/NT. Try again with ESE98.


Arguments:

    initsesid - database session
    tblid - table cursor
    cIndexCreate - Number of indexes to check
    pCreateIndexes - index attributes

Return Value:

    JET_ERR -

--*/

{
    THSTATE *pTHS = pTHStls;
    JET_ERR err = 0;
    CreateIndexParams *pIndex;
    JET_INDEXCREATE *pIndexCreate, *pNewIndex;
    DWORD cIndexNeeded = 0;

    // Allocate maximal size
    pIndexCreate = THAllocEx( pTHS, cIndexCreate * sizeof( JET_INDEXCREATE ) );

    //
    // Initialize the list of indexes to be created
    //

    pNewIndex = pIndexCreate;
    for( pIndex = pCreateIndexes;
         pIndex->szIndexName != NULL;
         pIndex++ ) {

        err = JetGetTableIndexInfo(initsesid,
                                   tblid,
                                   pIndex->szIndexName,
                                   pIndex->pidx,
                                   sizeof(JET_INDEXID),
                                   JET_IdxInfoIndexId);
        if ( JET_errIndexNotFound == err ) {
            DPRINT2(0,"Need an index '%s' (%d)\n", pIndex->szIndexName, err);
            memset( pNewIndex, 0, sizeof( JET_INDEXCREATE ) );

            pNewIndex->cbStruct = sizeof( JET_INDEXCREATE );
            pNewIndex->szIndexName = pIndex->szIndexName;
            pNewIndex->szKey = pIndex->szIndexKeys;
            pNewIndex->cbKey = pIndex->cbIndexKeys;
            pNewIndex->grbit = pIndex->ulFlags;
            pNewIndex->ulDensity = pIndex->ulDensity;
            if (pIndex->pConditionalColumn) {
                pNewIndex->rgconditionalcolumn = pIndex->pConditionalColumn;
                pNewIndex->cConditionalColumn = 1;
            }

            //  can't create primary index in batch
            //
            if ( pNewIndex->grbit & JET_bitIndexPrimary ) {
                DPRINT1(0,"Primary index '%s' is being built separately\n", pIndex->szIndexName);
                err = dbCreateIndexBatch( initsesid, tblid, 1, pNewIndex );
                if ( JET_errSuccess != err ) {
                    goto HandleError;
                }
            }
            else {
                pNewIndex++;
                cIndexNeeded++;
            }
        }
        else {
            CheckErr( err );
        }
    }

    //
    // Create the batch
    //

    if ( cIndexNeeded > 0 ) {
        err = dbCreateIndexBatch( initsesid, tblid, cIndexNeeded, pIndexCreate );
        if (err) {
            goto HandleError;
        }

        // Gather index hint for fixed indices
        for( pIndex = pCreateIndexes;
             pIndex->szIndexName != NULL;
             pIndex++ ) {
            Call( JetGetTableIndexInfo(initsesid,
                                       tblid,
                                       pIndex->szIndexName,
                                       pIndex->pidx,
                                       sizeof(JET_INDEXID),
                                       JET_IdxInfoIndexId ) );
        }
    }

HandleError:
    THFreeEx(pTHS, pIndexCreate);

    return err;
} /* createNewIndexes */



//	open sd_table (create if missing), create missing
//	columns/indexes, and cache column/index info
//
JET_ERR dbInitSDTable( JET_SESID sesid, JET_DBID dbid, BOOL *pfSDConversionRequired )
	{
	JET_ERR			err;
	JET_TABLEID		tableidSD	= JET_tableidNil;

	//	Open sd_table (do so exclusively in case columns/indexes
	//	need to be updated
	//
	err = JetOpenTable(
				sesid,
				dbid,
				SZSDTABLE,
				NULL,
				0,
				JET_bitTableDenyRead,
				&tableidSD );

	if ( JET_errObjectNotFound == err )
		{
		DPRINT( 0, "SD table not found. Must be an old DIT. Creating SD table\n" );

		// old-style DIT. Need to create SD table
		//
		Call( JetCreateTable( sesid, dbid, SZSDTABLE, 2, GENERIC_INDEX_DENSITY, &tableidSD ) );
		}
	else
		{
		CheckErr( err );
		}

	Assert( JET_tableidNil != tableidSD );

	//	grab columns (or create if needed)
	//
	Call( dbCreateNewColumns( sesid, dbid, tableidSD, rgCreateSDColumns ) );

	//	grab index (or create if needed)
	//
	Call( dbCreateNewIndexesBatch( sesid, tableidSD, cNewSDIndexes, rgCreateSDIndexes ) );

	//	check for empty SD table
	//
	err = JetMove( sesid, tableidSD, JET_MoveFirst, NO_GRBIT );
	if ( JET_errNoCurrentRecord == err )
		{
		//	SD table is empty -- must be upgrading an existing old-style DIT
		//	set the global flag so that DsaDelayedStartupHandler can schedule
		//	the global SD rewrite
		//
		DPRINT(0, "SD table is empty. SD Conversion is required.\n");
		*pfSDConversionRequired = TRUE;
		err = JET_errSuccess;
		}
	else
		{
		CheckErr( err );
		}

HandleError:
	if ( JET_tableidNil != tableidSD )
		{
		err = JetCloseTableWithErrUnhandled( sesid, tableidSD, err );
		}

	return err;
	}


//	determine the highest DNT currently in use in the objects table
//
JET_ERR dbGetHighestDNT(
	JET_SESID			sesid,
	JET_DBID			dbid,
	DWORD *				pdntMax )
	{
	JET_ERR				err;
	JET_TABLEID			tableidObj		= JET_tableidNil;

	Call( JetOpenTable(
				sesid,
				dbid,
				SZDATATABLE,
				NULL,
				0,
				NO_GRBIT,
				&tableidObj ) );
	Assert( JET_tableidNil != tableidObj );

	Call( JetMove( sesid, tableidObj, JET_MoveLast, NO_GRBIT ) );

	Call( JetRetrieveColumn(
				sesid,
				tableidObj,
				dntid,
				pdntMax,
				sizeof( *pdntMax ),
				NULL,			//	&cbActual
				NO_GRBIT,
				NULL ) );		//	&retinfo

HandleError:
	if ( JET_tableidNil != tableidObj )
		{
		err = JetCloseTableWithErrUnhandled( sesid, tableidObj, err );
		}

	return err;
	}


//	open quota_table (create if missing) and cache column info
//
JET_ERR dbInitQuotaTable(
	JET_SESID		sesid,
	JET_DBID		dbid )
	{
	JET_ERR			err;
	JET_TABLEID		tableidQuota				= JET_tableidNil;
	JET_TABLEID		tableidQuotaRebuildProgress	= JET_tableidNil;
	BOOL			fCreateTables				= FALSE;
	CHAR			fDone;
	JET_COLUMNDEF	columndef;
#ifdef AUDIT_QUOTA_OPERATIONS
	JET_TABLEID		tableidQuotaAudit			= JET_tableidNil;
#endif

	//	not tracking quota during DCPromo (quota table
	//	is rebuilt on first startup after DCPromo),
	//	so shouldn't be calling this routine
	//
	Assert( !DsaIsInstalling() || DsaIsInstallingFromMedia() );

	//	Open quota_table
	//
    err = JetOpenTable(
    			sesid,
    			dbid,
    			g_szQuotaTable,
    			NULL,		//	pvParameters
    			0,			//	cbParameters
    			JET_bitTableDenyRead,
    			&tableidQuota );

	if ( JET_errObjectNotFound == err )
		{
		DPRINT( 0, "Quota table not found. Must be an old DIT. Quota table will be rebuilt.\n" );
		Assert( JET_tableidNil == tableidQuota );
		fCreateTables = TRUE;
		}
	else
		{
		CheckErr( err );
		Assert( JET_tableidNil != tableidQuota );
		}

	//	open quota_rebuild_progress_table
	//
	err = JetOpenTable(
				sesid,
				dbid,
				g_szQuotaRebuildProgressTable,
				NULL,		//	pvParameters
				0,			//	cbParameters
				JET_bitTableDenyRead,
				&tableidQuotaRebuildProgress );
	if ( JET_errObjectNotFound == err )
		{
		if ( JET_tableidNil != tableidQuota )
			{
			//	Quota table present, but Quota Rebuild Progress table isn't, so
			//	there's something amiss, so to be safe, wipe current Quota table
			//	and start from scratch
			//
			Assert( !fCreateTables );
			DPRINT( 0, "Quota table not properly built.  Quota table will be rebuilt.\n" );

			Call( JetCloseTable( sesid, tableidQuota ) );
			tableidQuota = JET_tableidNil;

			Call( JetDeleteTable( sesid, dbid, g_szQuotaTable ) );
			}
		else
			{
			//	no Quota table and no Quota Rebuild Progress table, so
			//	we're going to start from scratch
			//
			Assert( fCreateTables );
			}

		fCreateTables = TRUE;
		}
	else
		{
		CheckErr( err );
		Assert( JET_tableidNil != tableidQuotaRebuildProgress );

		if ( JET_tableidNil != tableidQuota )
			{
			//	check to ensure Quota table was fully built
			//
			Assert( !fCreateTables );
			}
		else
			{
			//	Quota table not present, but Quota Rebuild Progress table is, so
			//	something is really amiss, so to be safe, start from scratch
			//
			Assert( fCreateTables );
			DPRINT( 0, "Quota table not properly built.  Quota table will be rebuilt.\n" );

			Call( JetCloseTable( sesid, tableidQuotaRebuildProgress ) );
			tableidQuotaRebuildProgress = JET_tableidNil;

			Call( JetDeleteTable( sesid, dbid, g_szQuotaRebuildProgressTable ) );
			fCreateTables = TRUE;
			}
		}

	//	re-create tables if necessary
	//
	if ( fCreateTables )
		{
		Assert( JET_tableidNil == tableidQuota );
		Call( JetCreateTableColumnIndex( sesid, dbid, &g_tablecreateQuotaTable ) );
		tableidQuota = g_tablecreateQuotaTable.tableid;

		Assert( JET_tableidNil == tableidQuotaRebuildProgress );
		Call( JetCreateTableColumnIndex( sesid, dbid, &g_tablecreateQuotaRebuildProgressTable ) );
		tableidQuotaRebuildProgress = g_tablecreateQuotaRebuildProgressTable.tableid;
		}

	Assert( JET_tableidNil != tableidQuota );
	Assert( JET_tableidNil != tableidQuotaRebuildProgress );

	//	cache columnid info
	//
	Call( JetGetTableColumnInfo(
				sesid,
				tableidQuota,
				g_szQuotaColumnNcdnt,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	g_columnidQuotaNcdnt = columndef.columnid;

	Call( JetGetTableColumnInfo(
				sesid,
				tableidQuota,
				g_szQuotaColumnSid,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	g_columnidQuotaSid = columndef.columnid;

	Call( JetGetTableColumnInfo(
				sesid,
				tableidQuota,
				g_szQuotaColumnTombstoned,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	g_columnidQuotaTombstoned = columndef.columnid;

	Call( JetGetTableColumnInfo(
				sesid,
				tableidQuota,
				g_szQuotaColumnTotal,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	g_columnidQuotaTotal = columndef.columnid;

	Call( JetGetTableColumnInfo(
				sesid,
				tableidQuotaRebuildProgress,
				g_szQuotaRebuildColumnDNTLast,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	g_columnidQuotaRebuildDNTLast = columndef.columnid;

	Call( JetGetTableColumnInfo(
				sesid,
				tableidQuotaRebuildProgress,
				g_szQuotaRebuildColumnDNTMax,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	g_columnidQuotaRebuildDNTMax = columndef.columnid;

	Call( JetGetTableColumnInfo(
				sesid,
				tableidQuotaRebuildProgress,
				g_szQuotaRebuildColumnDone,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	g_columnidQuotaRebuildDone = columndef.columnid;

#ifdef AUDIT_QUOTA_OPERATIONS
	err = JetOpenTable(
				sesid,
				dbid,
				g_szQuotaAuditTable,
				NULL,		//	pvParameters
				0,			//	cbParameters
				JET_bitTableDenyRead,
				&tableidQuotaAudit );
	if ( JET_errObjectNotFound == err )
		{
		//	quota audit table will be rebuilt
		//
		Assert( JET_tableidNil == tableidQuotaAudit );
		}
	else
		{
		CheckErr( err );

		if ( fCreateTables )
			{
			//	quota audit table present, but other tables are going
			//	to be rebuilt, so need to rebuild quota audit table as well
			//
			Call( JetCloseTable( sesid, tableidQuotaAudit ) );
			tableidQuotaAudit = JET_tableidNil;

			Call( JetDeleteTable( sesid, dbid, g_szQuotaAuditTable ) );
			}
		else
			{
			Assert( JET_tableidNil != tableidQuotaAudit );
			}
		}

	if ( JET_tableidNil == tableidQuotaAudit )
		{
		//	must rebuild audit table
		//
		Assert( JET_tableidNil == tableidQuotaAudit )
		Call( JetCreateTableColumnIndex( sesid, dbid, &g_tablecreateQuotaAuditTable ) );
		tableidQuotaAudit = g_tablecreateQuotaAuditTable.tableid;
		Assert( JET_tableidNil != tableidQuotaAudit );
		}

	//	cache columnid info
	//
	Call( JetGetTableColumnInfo(
				sesid,
				tableidQuotaAudit,
				g_szQuotaAuditColumnNcdnt,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	g_columnidQuotaAuditNcdnt = columndef.columnid;

	Call( JetGetTableColumnInfo(
				sesid,
				tableidQuotaAudit,
				g_szQuotaAuditColumnSid,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	g_columnidQuotaAuditSid = columndef.columnid;

	Call( JetGetTableColumnInfo(
				sesid,
				tableidQuotaAudit,
				g_szQuotaAuditColumnDnt,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	g_columnidQuotaAuditDnt = columndef.columnid;

	Call( JetGetTableColumnInfo(
				sesid,
				tableidQuotaAudit,
				g_szQuotaAuditColumnOperation,
				&columndef,
				sizeof(columndef),
				JET_ColInfo ) );
	g_columnidQuotaAuditOperation = columndef.columnid;

	//	insert dummy record to demarcate boot
	//
		{
		DWORD	dwZero	= 0;
		CHAR *	szBoot	= ( fCreateTables ? "BUILD" : "REBOOT" );

		Call( JetPrepareUpdate( sesid, tableidQuotaAudit, JET_prepInsert ) );
		Call( JetSetColumn(
					sesid,
					tableidQuotaAudit,
					g_columnidQuotaAuditNcdnt,
					&dwZero,
					sizeof(dwZero),
					NO_GRBIT,
					NULL ) );
		Call( JetSetColumn(
					sesid,
					tableidQuotaAudit,
					g_columnidQuotaAuditSid,
					szBoot,
					strlen( szBoot ),
					NO_GRBIT,
					NULL ) );
		Call( JetSetColumn(
					sesid,
					tableidQuotaAudit,
					g_columnidQuotaAuditDnt,
					&dwZero,
					sizeof(dwZero),
					NO_GRBIT,
					NULL ) );
		Call( JetSetColumn(
					sesid,
					tableidQuotaAudit,
					g_columnidQuotaAuditOperation,
					szBoot,
					strlen( szBoot ),
					NO_GRBIT,
					NULL ) );
		Call( JetUpdate( sesid, tableidQuotaAudit, NULL, 0, NULL ) );
		}

#endif	//	AUDIT_QUOTA_OPERATIONS

	if ( fCreateTables )
		{
		DWORD	dntStart	= ROOTTAG;
		DWORD	dntMax;

		//	determine the highest DNT currently in the objects table
		//
		Call( dbGetHighestDNT( sesid, dbid, &dntMax ) );

		//	insert the lone record that will only ever be in
		//	the Quota Rebuild Progress table
		//
		//	initialise starting DNT with ROOTTAG, cause we'll only be
		//	considering objects with greater DNT's
		//
		Call( JetPrepareUpdate(
					sesid,
					tableidQuotaRebuildProgress,
					JET_prepInsert ) );
		Call( JetSetColumn(
					sesid,
					tableidQuotaRebuildProgress,
					g_columnidQuotaRebuildDNTLast,
					&dntStart,
					sizeof(dntStart),
					NO_GRBIT,
					NULL ) );	//	&setinfo
		Call( JetSetColumn(
					sesid,
					tableidQuotaRebuildProgress,
					g_columnidQuotaRebuildDNTMax,
					&dntMax,
					sizeof(dntMax),
					NO_GRBIT,
					NULL ) );	//	&setinfo
		Call( JetUpdate(
					sesid,
					tableidQuotaRebuildProgress,
					NULL,		//	pvBookmark
					0,			//	cbBookmark
					NULL ) );	//	&cbActual

		}

	//	see if the Quota table is completely rebuilt
	//
	err = JetRetrieveColumn(
				sesid,
				tableidQuotaRebuildProgress,
				g_columnidQuotaRebuildDone,
				&fDone,
				sizeof(fDone),
				NULL,		//	&cbActual
				NO_GRBIT,
				NULL );		//	&retinfo
	if ( JET_wrnColumnNull == err )
		{
		//	Quota table not yet built (it may be
		//	partially built), so set up anchor
		//	to indicate that we need to schedule
		//	a Quota rebuild task
		//
		gAnchor.fQuotaTableReady = FALSE;
		Call( JetRetrieveColumn(
					sesid,
					tableidQuotaRebuildProgress,
					g_columnidQuotaRebuildDNTLast,
					&gAnchor.ulQuotaRebuildDNTLast,
					sizeof(gAnchor.ulQuotaRebuildDNTLast),
					NULL,		//	&cbActual
					NO_GRBIT,
					NULL ) );		//	&retinfo
		Call( JetRetrieveColumn(
					sesid,
					tableidQuotaRebuildProgress,
					g_columnidQuotaRebuildDNTMax,
					&gAnchor.ulQuotaRebuildDNTMax,
					sizeof(gAnchor.ulQuotaRebuildDNTMax),
					NULL,		//	&cbActual
					NO_GRBIT,
					NULL ) );		//	&retinfo

		//	generate an event indicating that the Quota table
		//	will be asynchronously rebuilt
		//
	    LogEvent(
			DS_EVENT_CAT_INTERNAL_PROCESSING,
			DS_EVENT_SEV_ALWAYS,
			DIRLOG_ASYNC_QUOTA_REBUILD_SCHEDULED,
			NULL,
			NULL,
			NULL );
		}
	else
		{
		CheckErr( err );

		//	if we had to create the Quota table,
		//	it should not be done yet
		//
		Assert( !fCreateTables );

		//	this column should only ever be TRUE or NULL
		//
		Assert( fDone );

		//	set flag in anchor to indicate that Quota table
		//	is ready for use
		//
		gAnchor.fQuotaTableReady = TRUE;
		}

HandleError:
#ifdef AUDIT_QUOTA_OPERATIONS
	if ( JET_tableidNil != tableidQuotaAudit )
		{
		err = JetCloseTableWithErrUnhandled( sesid, tableidQuotaAudit, err );
		}
#endif

	if ( JET_tableidNil != tableidQuotaRebuildProgress )
		{
		err = JetCloseTableWithErrUnhandled( sesid, tableidQuotaRebuildProgress, err );
		}

	if ( JET_tableidNil != tableidQuota )
		{
		err = JetCloseTableWithErrUnhandled( sesid, tableidQuota, err );
		}

	return err;
	}

DWORD DBInitQuotaTable()
	{
	DBPOS *	const	pDB		= dbGrabHiddenDBPOS( pTHStls );
	const JET_ERR	err		= dbInitQuotaTable( pDB->JetSessID, pDB->JetDBID );

	dbReleaseHiddenDBPOS( pDB );
	return err;
	}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function initializes JET, creates the base SESID, and finds
   all the attribute columns in the JET data table. Each DBOpen must
   create a unique JET sesid, dbid and tableid for each DBPOS structure.
*/

int APIENTRY DBInit(void){

    unsigned i;
    JET_ERR     err;
    JET_DBID    dbid;
    JET_TABLEID dattblid;
    JET_TABLEID linktblid;
    JET_TABLEID proptblid;
    JET_COLUMNDEF coldef;
    ULONG ulErrorCode, dwException, dsid;
    PVOID dwEA;
    JET_SESID     initsesid;
    SID_IDENTIFIER_AUTHORITY NtAuthority =  SECURITY_NT_AUTHORITY;
    BOOL        fSDConversionRequired = FALSE;
    BOOL        fWriteHiddenFlags = FALSE;

#if DBG

    // Initialize the DBPOS array

    for (i=0; i < MAXDBPOS; i++){
        opendbpos[i].pDB = 0;
        opendbpos[i].sesid = 0;
    }
#endif


    if (!gFirstTimeThrough)
        return 0;

    gFirstTimeThrough = FALSE;


    // control use of JET_prepReadOnlyCopy for testing

    if (!GetConfigParam(DB_CACHE_RECORDS, &gfEnableReadOnlyCopy, sizeof(gfEnableReadOnlyCopy))) {
        gfEnableReadOnlyCopy = !!gfEnableReadOnlyCopy;
    } else {
        gfEnableReadOnlyCopy = FALSE;  // default
    }


    // if a transaction lasts longer than gMaxTransactionTime,
    // an event will be logged when DBClose.

    if (!GetConfigParam(DB_MAX_TRANSACTION_TIME, &gMaxTransactionTime, sizeof(gMaxTransactionTime))) {
        // NTRAID#NTRAID-572862-2002/03/11-andygo:  SECURITY:  need to validate registry data used by DBInit
        // REVIEW:  we should check for sane value and prevent overflow on this parameter
        gMaxTransactionTime *= 1000;                               //second to tick
    }
    else {
        gMaxTransactionTime = MAX_TRANSACTION_TIME;                //default
    }

    dbInitIndicesToKeep();

    // Create a copy of the builtin domain sid.  The dnread cache needs this.
    if (RtlAllocateAndInitializeSid(
            &NtAuthority,
            1,
            SECURITY_BUILTIN_DOMAIN_RID,
            0,0, 0, 0, 0, 0, 0,
            &pgdbBuiltinDomain
            ) != STATUS_SUCCESS) {
        DsaExcept(DSA_MEM_EXCEPTION, 0, 0);
    }

    // create the semaphore used to limit our usage of JET sessions
    if (!(hsemDBLayerSessions = CreateSemaphoreW(NULL,
                                                 gcMaxJetSessions,
                                                 gcMaxJetSessions,
                                                 NULL))) {
        DsaExcept(DSA_MEM_EXCEPTION, 0, 0);
    }

    opensess = calloc(gcMaxJetSessions, sizeof(OPENSESS));
    UncUsn = malloc(gcMaxJetSessions * sizeof(UncUsn[0]));
    if (!opensess || !UncUsn) {
        MemoryPanic(gcMaxJetSessions * (sizeof(OPENSESS) + sizeof(UncUsn[0])));
        return ENOMEM;
    }

    // Initialize uncommitted usns array

    for (i=0;i < gcMaxJetSessions;i++) {
        UncUsn[i] = USN_MAX;
    }

    __try {
        InitializeCriticalSection(&csAddList);

#if DBG
        InitializeCriticalSection(&csDBPOS);
#endif
        err = 0;
    }
    __except (GetExceptionData(GetExceptionInformation(), &dwException,
                               &dwEA, &ulErrorCode, &dsid)) {
        err = dwException;
    }

    if (err) {
        DsaExcept(DSA_MEM_EXCEPTION, 0, 0);
    }

    //
    // Do JetInit, BeginSession, Attach/OpenDatabase
    //

    err = DBInitializeJetDatabase( &jetInstance, &initsesid, &dbid, NULL, TRUE );
    if (err != JET_errSuccess) {
        return err;
    }

    /* Most indices are created by the schema cache, but certain
     * ones must be present in order for us to even read the schema.
     * Create those now.
     */
    err = DBRecreateRequiredIndices(initsesid, dbid);
    if (err) {
        DPRINT1(0, "Error %d recreating fixed indices\n", err);
        LogUnhandledError(err);
        return err;
    }

    /* Open data table */

    if ((err = JetOpenTable(initsesid, dbid, SZDATATABLE, NULL, 0, 0,
                            &dattblid)) != JET_errSuccess) {
        DPRINT1(1, "JetOpenTable error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetOpenTable complete\n");

    // verify localized indices were properly created
    // by DBRecreateRequiredIndices
    if (err = dbCheckLocalizedIndices(initsesid, dattblid))
        {
            DPRINT(0,"Localized index creation failed\n");
            LogUnhandledError(err);
            return err;
        }

    /* Get DNT column ID */
    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZDNT, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (DNT) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (DNT) complete\n");
    dntid = coldef.columnid;
    // fill in the template used in the DNRead function.
    dnreadColumnInfoTemplate[0].columnid = dntid;
    dnreadColumnInfoTemplate[0].cbData = sizeof(ULONG);

    /* Get PDNT column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZPDNT, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (PDNT) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (PDNT) complete\n");
    pdntid = coldef.columnid;
    // fill in the template used in the DNRead function.
    dnreadColumnInfoTemplate[1].columnid = pdntid;
    dnreadColumnInfoTemplate[1].cbData = sizeof(ULONG);

    /* Get Ancestors column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZANCESTORS, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (ANCESTORS) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (ANCESTORS) complete\n");
    ancestorsid = coldef.columnid;
    dnreadColumnInfoTemplate[10].columnid = ancestorsid;

    /* Get object flag */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZOBJ, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (OBJ) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (OBJ) complete\n");
    objid = coldef.columnid;
    // fill in the template used in the DNRead function.
    dnreadColumnInfoTemplate[2].columnid = objid;
    dnreadColumnInfoTemplate[2].cbData = sizeof(char);

    /* Get RDN column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZRDNATT, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (RDN) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (RDN) complete\n");
    rdnid = coldef.columnid;
    // fill in the template used by the DNRead function
    dnreadColumnInfoTemplate[7].columnid = rdnid;
    dnreadColumnInfoTemplate[7].cbData=MAX_RDN_SIZE * sizeof(WCHAR);

    /* Get RDN Type column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZRDNTYP, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (RDNTYP) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (RDNTYP) complete\n");
    rdntypid = coldef.columnid;
    // fill in the template used in the DNRead function.
    dnreadColumnInfoTemplate[3].columnid = rdntypid;
    dnreadColumnInfoTemplate[3].cbData = sizeof(ATTRTYP);

    /* Get count column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZCNT, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (Cnt) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (Cnt) complete\n");
    cntid = coldef.columnid;

    /* Get abref count column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZABCNT, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (ABCnt) error: %d\n", err);
        // On upgrade paths, this is not necessarily here in all DBs.  Ignore
        // this failure.
        abcntid = 0;
        gfDoingABRef = FALSE;
    }
    else {
        DPRINT(5,"JetGetTableColumnInfo (ABCnt) complete\n");
        abcntid = coldef.columnid;
        gfDoingABRef = (coldef.grbit & JET_bitColumnEscrowUpdate);
        // IF the column exists and is marked as escrowable, then we are
        // keeping track of show ins for MAPI support.
    }

    /* Get delete time column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZDELTIME,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (Time) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (Time) complete\n");
    deltimeid = coldef.columnid;

    /* Get NCDNT column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZNCDNT, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (NCDNT) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (NCDNT) complete\n");
    ncdntid = coldef.columnid;
    dnreadColumnInfoTemplate[4].columnid = ncdntid;
    dnreadColumnInfoTemplate[4].cbData = sizeof(ULONG);

    /* Get IsVisibleInAB column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZISVISIBLEINAB,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (IsVisibleInABT) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (IsVisibleInAB) complete\n");
    IsVisibleInABid = coldef.columnid;

    /* Get ShowIn column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZSHOWINCONT,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (ShowIn) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (ShowIn) complete\n");
    ShowInid = coldef.columnid;

    /* Get MAPIDN column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZMAPIDN,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (MAPIDN) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (MAPIDN) complete\n");
    mapidnid = coldef.columnid;

    /* Get IsDeleted column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZISDELETED,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (isdeleted) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (isdeleted) complete\n");
    isdeletedid = coldef.columnid;

    /* Get dscorepropagationdata column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZDSCOREPROPINFO,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (DSCorePropInfo) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (dscorepropinfoid) complete\n");
    dscorepropinfoid = coldef.columnid;
    dbAddSDPropTimeReadTemplate[0].columnid = coldef.columnid;
    dbAddSDPropTimeReadTemplate[1].columnid = coldef.columnid;
    dbAddSDPropTimeReadTemplate[2].columnid = coldef.columnid;
    dbAddSDPropTimeWriteTemplate[0].columnid= coldef.columnid;
    dbAddSDPropTimeWriteTemplate[1].columnid= coldef.columnid;
    dbAddSDPropTimeWriteTemplate[2].columnid= coldef.columnid;

    /* Get Object Class column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZOBJCLASS,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (DNT) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (objectClass) complete\n");
    objclassid = coldef.columnid;
    dnreadColumnInfoTemplate[8].columnid = objclassid;
    dnreadColumnInfoTemplate[8].cbData = sizeof(DWORD);

    /* Get SecurityDescriptor column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZNTSECDESC,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (DNT) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (NT-Sec-Disc) complete\n");
    ntsecdescid = coldef.columnid;
    dnreadColumnInfoTemplate[9].columnid = ntsecdescid;
    dnreadColumnInfoTemplate[9].cbData = sizeof(SDID);

    /* Get instancetype column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZINSTTYPE,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (DNT) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (instance type) complete\n");
    insttypeid = coldef.columnid;

    /* Get USNChanged column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZUSNCHANGED,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (USNCHANGED) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (USNCHANGED) complete\n");
    usnchangedid = coldef.columnid;

    /* Get GUID column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZGUID,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (GUID) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (GUID) complete\n");
    guidid = coldef.columnid;
    // fill in the template used in the DNRead function.
    dnreadColumnInfoTemplate[5].columnid = guidid;
    dnreadColumnInfoTemplate[5].cbData = sizeof(GUID);

    /* Get OBJDISTNAME column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZDISTNAME,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (DISTNAME) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (DISTNAME) complete\n");
    distnameid = coldef.columnid;

    /* Get SID column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZSID,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (SID) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (SID) complete\n");
    sidid = coldef.columnid;
    // fill in the template used in the DNRead function.
    dnreadColumnInfoTemplate[6].columnid = sidid;
    dnreadColumnInfoTemplate[6].cbData = sizeof(NT4SID);

    /* Get IsCritical column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZISCRITICAL,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (iscritical) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (iscritical) complete\n");
    iscriticalid = coldef.columnid;

    // cleanid is populated through the dbCreateNewColumns call


    /* Open link table */
    // Open table exclusively in case indexes need to be updated
    if ((err = JetOpenTable(initsesid, dbid, SZLINKTABLE,
                            NULL, 0,
                            JET_bitTableDenyRead, &linktblid)) != JET_errSuccess)
        {
            DPRINT1(0, "JetOpenTable (link table) error: %d.\n", err);
            LogUnhandledError(err);
            return err;
        }

    /* get linkDNT column id */

    if ((err = JetGetTableColumnInfo(initsesid, linktblid, SZLINKDNT, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess)
        {
            DPRINT1(1, "JetGetTableColumnInfo (link DNT) error: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
    linkdntid = coldef.columnid;

    /* get linkDNT column id */

    if ((err = JetGetTableColumnInfo(initsesid, linktblid, SZBACKLINKDNT,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess)
        {
            DPRINT1(1, "JetGetTableColumnInfo (backlink DNT) error: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
    backlinkdntid = coldef.columnid;

    /* get link base column id */

    if ((err = JetGetTableColumnInfo(initsesid, linktblid, SZLINKBASE, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess)
        {
            DPRINT1(1, "JetGetTableColumnInfo (link base) error: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
    linkbaseid = coldef.columnid;

    /* get link data column id */

    if ((err = JetGetTableColumnInfo(initsesid, linktblid, SZLINKDATA, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess)
        {
            DPRINT1(1, "JetGetTableColumnInfo (link data) error: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
    linkdataid = coldef.columnid;

    /* get link ndesc column id */

    if ((err = JetGetTableColumnInfo(initsesid, linktblid, SZLINKNDESC, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess)
        {
            DPRINT1(1, "JetGetTableColumnInfo (link ndesc) error: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
    linkndescid = coldef.columnid;

    // Expand link table at runtime if necessary

    if (err = dbCreateNewColumns( initsesid,
                                dbid,
                                linktblid,
                                rgCreateLinkColumns )) {
        // Error already logged
        return err;
    }

    if (err = dbCreateNewIndexesBatch( initsesid,
                                       linktblid,
                                       cNewLinkIndexes,
                                       rgCreateLinkIndexes)) {
        // Error already logged
        return err;
    }

    /* Open SD prop table */
    if ((err = JetOpenTable(initsesid, dbid, SZPROPTABLE,
                            NULL, 0, 0, &proptblid)) != JET_errSuccess)
        {
            DPRINT1(0, "JetOpenTable (link table) error: %d.\n", err);
            LogUnhandledError(err);
            return err;
        }

    /* get order column id */

    if ((err = JetGetTableColumnInfo(initsesid, proptblid, SZORDER,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess)
        {
            DPRINT1(1, "JetGetTableColumnInfo (backlink DNT) error: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
    orderid = coldef.columnid;

    /* get begindnt column id */

    if ((err = JetGetTableColumnInfo(initsesid, proptblid, SZBEGINDNT, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess)
        {
            DPRINT1(1, "JetGetTableColumnInfo (link base) error: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
    begindntid = coldef.columnid;

    /* get trimmable column id */

    if ((err = JetGetTableColumnInfo(initsesid, proptblid, SZTRIMMABLE, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess)
        {
            DPRINT1(1, "JetGetTableColumnInfo (link data) error: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
    trimmableid = coldef.columnid;

    /* get clientid column id */

    if ((err = JetGetTableColumnInfo(initsesid, proptblid, SZCLIENTID, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess)
        {
            DPRINT1(1, "JetGetTableColumnInfo (link data) error: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
    clientidid = coldef.columnid;

    // grab new columns (or create if needed)
    if (err = dbCreateNewColumns(initsesid, dbid, proptblid, rgCreateSDPropColumns)) {
        // error already logged
        return err;
    }

	err = dbInitSDTable( initsesid, dbid, &fSDConversionRequired );
	if ( err )
		{
		DPRINT1( 0, "Initialisation of sd_table failed with error: %d.\n", err );
		return err;
		}

	//	not tracking quota during DCPromo (quota table
	//	is rebuilt after futzing with the install dit)
	//
	if ( !DsaIsInstalling() || DsaIsInstallingFromMedia() )
		{
		err = dbInitQuotaTable( initsesid, dbid );
		if ( err )
			{
			DPRINT2( 0, "Initialisation of Quota table failed with error %d (0x%x).\n", err, err );
			return err;
			}


#ifdef CHECK_QUOTA_TABLE_ON_INIT
		//	QUOTA_UNDONE: this verification code is only here
		//	for preliminary debugging to validate the integrity
		//	of the Quota table while the code is in development
		//
		if ( gAnchor.fQuotaTableReady )
			{
			ULONG	cCorruptions;

			err = ErrQuotaIntegrityCheck( initsesid, dbid, &cCorruptions );
			if ( err )
				{
				//	corruption detected, so force async rebuild so that we can continue
				//
				DPRINT2( 0, "Integrity-check of Quota table failed with error %d (0x%x).\n", err, err );
				return err;
				}

			else if ( cCorruptions > 0 )
				{
				DPRINT1( 0, "Corruption (%d problems) was detected in the Quota table. A rebuild will be forced.\n", cCorruptions );
				Assert( !"Quota table was corrupt. A rebuild will be forced.\n" );

				//	async rebuild is forced by first deleting the quota table, then
				//	calling init routine again
				//
				if ( ( err = JetDeleteTable( initsesid, dbid, g_szQuotaTable ) )
					|| ( err = dbInitQuotaTable( initsesid, dbid ) ) )
					{
					DPRINT2( 0, "Forced rebuild failed with error %d (0x%x).\n", err, err );
					Assert( !"Forced rebuild of Quota table failed.\n" );
					return err;
					}
				}

			else
				{
				DPRINT( 0, "Integrity-check of Quota table completed successfully. No errors were detected.\n" );
		    	}
			}
#endif  //  CHECK_QUOTA_TABLE_ON_INIT
		}

    /* Get Index ids */
	memset(&idxDraUsn, 0, sizeof(idxDraUsn));
	memset(&idxDraUsnCritical, 0, sizeof(idxDraUsnCritical));
	memset(&idxNcAccTypeName, 0, sizeof(idxNcAccTypeName));
	memset(&idxPdnt, 0, sizeof(idxPdnt));
	memset(&idxRdn, 0, sizeof(idxRdn));
	memset(&idxIsDel, 0, sizeof(idxIsDel));
	memset(&idxClean, 0, sizeof(idxClean));

    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZDELTIMEINDEX,
                               &idxDel,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        LogUnhandledError(err);
        return err;
    }
    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZDNTINDEX,
                               &idxDnt,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        LogUnhandledError(err);
        return err;
    }
    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZDRAUSNINDEX,
                               &idxDraUsn,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        LogUnhandledError(err);
        return err;
    }

    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZGUIDINDEX,
                               &idxGuid,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        LogUnhandledError(err);
        return err;
    }
    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZMAPIDNINDEX,
                               &idxMapiDN,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        memset(&idxMapiDN, 0, sizeof(JET_INDEXID));
    }
    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZ_NC_ACCTYPE_SID_INDEX,
                               &idxNcAccTypeSid,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        LogUnhandledError(err);
        return err;
    }
    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZPHANTOMINDEX,
                               &idxPhantom,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        memset(&idxPhantom, 0, sizeof(JET_INDEXID));
    }
    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZPROXYINDEX,
                               &idxProxy,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        memset(&idxProxy, 0, sizeof(JET_INDEXID));
    }
    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZSIDINDEX,
                               &idxSid,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        LogUnhandledError(err);
        return err;
    }

    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZANCESTORSINDEX,
                               &idxAncestors,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        LogUnhandledError(err);
        return err;
    }

    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZINVOCIDINDEX,
                               &idxInvocationId,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        LogUnhandledError(err);
        return err;
    }

    /* We're done.  Close JET session */

    if ((err = JetCloseDatabase(initsesid, dbid, 0))  != JET_errSuccess)
        {
            DPRINT1(1, "JetCloseDatabase error: %d\n", err);
            LogUnhandledError(err);
        }

    InterlockedDecrement(&gcOpenDatabases);
    DPRINT3(2,"DBInit - JetCloseDatabase. Session = %d. Dbid = %d.\n"
            "Open database count: %d\n",
            initsesid, dbid,  gcOpenDatabases);

    if ((err = JetEndSession(initsesid, JET_bitForceSessionClosed))
        != JET_errSuccess) {
        DPRINT1(1, "JetEndSession error: %d\n", err);
    }
    DBEndSess(initsesid);

    //  all expensive index rebuilds are done, so set the event
    //
    if ( NULL != hevIndexRebuildUI )
        {
        SetEvent( hevIndexRebuildUI );
        CloseHandle( hevIndexRebuildUI );
        }

    /* Initialize a DBPOS for hidden record accesses */

    if (err = dbCreateHiddenDBPOS())
        return err;

    // read the setting flags
    ZeroMemory (&gdbFlags, sizeof (gdbFlags));
    err = dbGetHiddenFlags ((CHAR *)&gdbFlags, sizeof (gdbFlags));
    if (err == JET_wrnColumnNull) {
        // for > whistler beta2, start with 1
        gdbFlags[DBFLAGS_AUXCLASS] = '1';
        gdbFlags[DBFLAGS_SD_CONVERSION_REQUIRED] = '0';
        gdbFlags[DBFLAGS_ROOT_GUID_UPDATED] = '0';
        fWriteHiddenFlags = TRUE;
    } else if (err) {
        DPRINT1 (0, "Error Retrieving Flags: %d\n", err);
        LogUnhandledError(err);
        return err;
    }

    if (fSDConversionRequired) {
        gdbFlags[DBFLAGS_SD_CONVERSION_REQUIRED] = '1';
        fWriteHiddenFlags = TRUE;
    }

    if (fWriteHiddenFlags) {
        if (err = DBUpdateHiddenFlags()) {
            DPRINT1 (0, "Error Setting Flags: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
    }

    return 0;

}  /*DBInit*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function registers open JET sessions.
 * We do this because JET insists that all sessions be closed before we
 * can call JetTerm so we keep track of open sessions so that we can
 * close them in DBEnd.
*/

extern int APIENTRY DBAddSess(JET_SESID sess, JET_DBID dbid){

    unsigned i;
    int ret = 1;

    DPRINT(2,"DBAddSess\n");
    EnterCriticalSection(&csSessions);
    __try {
        for (i=0; ret && (i < gcMaxJetSessions); i++)
        {
            if (opensess[i].sesid == 0)
            {
                opensess[i].sesid = sess;
                opensess[i].dbid = dbid;
                ret = 0;
            }
        }
    }
    __finally {
        LeaveCriticalSection(&csSessions);
    }

    return ret;
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function deletes closed JET sessions
*/

extern int APIENTRY DBEndSess(JET_SESID sess){

    unsigned i;
    int ret = 1;

    DPRINT(2,"DBEndSess\n");

    EnterCriticalSection(&csSessions);
    __try {
        for (i=0; ret && (i < gcMaxJetSessions); i++)
        {
            if (opensess[i].sesid == sess)
            {
                opensess[i].sesid = 0;
                opensess[i].dbid = 0;
                ret = 0;
            }
        }
    }
    __finally {
        LeaveCriticalSection(&csSessions);
    }

    return ret;
}

/*++ DBPrepareEnd
 *
  * This routine prepares the DBLayer for shutdown by initiating background
  * cleanup that can be used to accelerate shutdown of the database.
 */
void DBPrepareEnd( void )
{
    DBPOS *pDB = NULL;

    // Request OLD to stop
    DBOpen(&pDB);
    __try {
        DBDefrag(pDB, 0);
    } __finally {
        DBClose(pDB, TRUE);
    }

    // Set a very small checkpoint depth to cause the database cache to start
    // flushing all important dirty pages to the database.  note that we do not
    // set the depth to zero because that would make any remaining updates
    // that need to be done very slow
    JetSetSystemParameter(
        NULL,
        0,
        JET_paramCheckpointDepthMax,
        16384,
        NULL );
}

/*++ DBQuiesce
 *
  * This routine prepares the DBLayer for shutdown by quiescing usage of the
  * database.
 */
void DBQuiesce( void )
{
    // Lock out new users
    if (InterlockedCompareExchange(&gcOpenDatabases, 0x80000000, 0) == 0) {
        SetEvent(hevDBLayerClear);
    }

    // Quiesce existing users
    JetStopServiceInstance(jetInstance);
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function closes all open JET sessions and calls JetTerm
*/

void DBEnd(void){

    JET_ERR     err;
    unsigned    i;

    if (!gfNeedJetShutdown) {
        return;
    }

    __try {
        DPRINT(0, "DBEnd\n");

        // Close the hidden DB session.
        // We'll change this if time permits to only open the hidden
        // session as needed and the close it.

        dbCloseHiddenDBPOS();

        // Close all sessions
        EnterCriticalSection(&csSessions);
        __try {
            for (i=0; opensess && i < gcMaxJetSessions; i++) {
                if (opensess[i].sesid != 0) {
#if DBG
                    dbCheckJet(opensess[i].sesid);
#endif
                    if(opensess[i].dbid)
                      // JET_bitDbForceClose not supported in Jet600.
                      if ((err = JetCloseDatabase(opensess[i].sesid,
                                                  opensess[i].dbid,
                                                  0)) !=
                          JET_errSuccess) {
                          DPRINT1(1,"JetCloseDatabase error: %d\n", err);
                      }

                    InterlockedDecrement(&gcOpenDatabases);
                    DPRINT3(2,
                            "DBEnd - JetCloseDatabase. Session = %d. "
                            "Dbid = %d.\nOpen database count: %d\n",
                            opensess[i].sesid,
                            opensess[i].dbid,
                            gcOpenDatabases);

                    if ((err = JetEndSession(opensess[i].sesid,
                                             JET_bitForceSessionClosed))
                        != JET_errSuccess) {
                      DPRINT1(1, "JetEndSession error: %d\n", err);
                    }
                    opensess[i].sesid = 0;
                    opensess[i].dbid = 0;
                }
            }
        }
        __finally {
            LeaveCriticalSection(&csSessions);
        }
        JetTerm(jetInstance);
        jetInstance = 0;
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        // do nothing
    }
    gfNeedJetShutdown = FALSE;
}

/*++ RecycleSession
 *
 * This routine cleans out a session for reuse.
 *
 * INPUT:
 *   pTHS  - pointer to current thread state
 * OUTPUT:
 *   none
 * RETURN VALUE:
 *   none
 */
void RecycleSession(THSTATE *pTHS)
{
    DBPOS *pDB = pTHS->pDB;
    if (!pTHS->JetCache.sessionInUse) {
        /* nothing to do */
        return;
    }

    Assert(pTHS->JetCache.sesid);

    Assert(!pTHS->JetCache.dataPtr);

    // Should never retire a session which is not at transaction
    // level 0.  Else next thread to get this session will not
    // have clean view of the database.
    Assert(0 == pTHS->transactionlevel);


    // For free builds, handle the case where the above Assert is false
    if(pDB && (pDB->transincount>0)) {

#ifdef DBG
        if (IsDebuggerPresent()) {
            OutputDebugString("DS: Thread freed with open transaction,"
                              " please contact anyone on dsteam\n");
            OutputDebugString("DS: Or at least mail a stack trace to dsteam"
                              " and then hit <g> to continue\n");
            DebugBreak();
        }
#endif

        // If we still have a transaction open, abort it, because it's
        // too late to do anything useful

        while (pDB->transincount) {
            // DBTransOut will decrement pDB->cTransactions.
            DBTransOut(pDB, FALSE, FALSE);
        }
    }

    // Jet seems to think that we've been re-using sessions with
    // open transactions.  Verify that Jet thinks this session is
    // safe as well.
    do {
        DWORD err = JetRollback(pTHS->JetCache.sesid, 0);
        if (err == JET_errSuccess) {
            Assert(!"JET transaction leaked");
        }
        else {
            break;
        }
    } while(TRUE);

    if (InterlockedDecrement(&gcOpenDatabases) == 0 && eServiceShutdown) {
        if (InterlockedCompareExchange(&gcOpenDatabases, 0x80000000, 0) == 0) {
            SetEvent(hevDBLayerClear);
        }
    }
    pTHS->JetCache.sessionInUse = FALSE;
}

/*++ GrabSession
 *
 * This routine grabs a session for use, if one exists.  If no cached session
 * is available then a new one is created.
 *
 * INPUT:
 *   none
 * OUTPUT:
 *   none
 * RETURN VALUE:
 *   error code
 */
DWORD GrabSession(void)
{
    DWORD err = 0;
    THSTATE* pTHS = pTHStls;

    BOOL fMayBeginSession = FALSE;
    ULONG ulErrorCode, dwException, dsid;
    PVOID dwEA;

    if (InterlockedIncrement(&gcOpenDatabases) > 0x80000000) {
        // We are shutting down

        err = DB_ERR_SHUTTING_DOWN;
    }

    else if (!pTHS->JetCache.sesid) {
        // Cache was empty, so let's create a new one.

        __try {
            pTHS->JetCache.sesid = pTHS->JetCache.dbid = 0;

            // limit our usage of ordinary JET sessions to gcMaxJetSessions
            fMayBeginSession = WaitForSingleObject(hsemDBLayerSessions, 0) == WAIT_OBJECT_0;
            if (!fMayBeginSession) {
                DsaExcept(DSA_DB_EXCEPTION, JET_errOutOfSessions, 0);
            }

            JetBeginSessionEx(jetInstance,
                              &pTHS->JetCache.sesid,
                              szUser,
                              szPassword);

            JetOpenDatabaseEx(pTHS->JetCache.sesid,
                              szJetFilePath,
                              "",
                              &pTHS->JetCache.dbid,
                              NO_GRBIT);

            // Open data table
            JetOpenTableEx(pTHS->JetCache.sesid,
                           pTHS->JetCache.dbid,
                           SZDATATABLE,
                           NULL,
                           0,
                           NO_GRBIT,
                           &pTHS->JetCache.objtbl);

            /* Create subject search cursor */
            JetDupCursorEx(pTHS->JetCache.sesid,
                           pTHS->JetCache.objtbl,
                           &pTHS->JetCache.searchtbl,
                           NO_GRBIT);

            /* Open the Link Table */
            JetOpenTableEx(pTHS->JetCache.sesid,
                           pTHS->JetCache.dbid,
                           SZLINKTABLE,
                           NULL,
                           0,
                           NO_GRBIT,
                           &pTHS->JetCache.linktbl);

            JetOpenTableEx(pTHS->JetCache.sesid,
                           pTHS->JetCache.dbid,
                           SZPROPTABLE,
                           NULL,
                           0,
                           NO_GRBIT,
                           &pTHS->JetCache.sdproptbl);

            JetOpenTableEx(pTHS->JetCache.sesid,
                           pTHS->JetCache.dbid,
                           SZSDTABLE,
                           NULL,
                           0,
                           NO_GRBIT,
                           &pTHS->JetCache.sdtbl);

            // NOTE: primary index is set by default on opened cursors

            pTHS->JetCache.tablesInUse = FALSE;
            pTHS->JetCache.sessionInUse = FALSE;

            DBAddSess(pTHS->JetCache.sesid, pTHS->JetCache.dbid);

        }
        __except (GetExceptionData(GetExceptionInformation(), &dwException,
                               &dwEA, &ulErrorCode, &dsid)) {

            if (pTHS->JetCache.dbid) {
                JetCloseDatabase (pTHS->JetCache.sesid, pTHS->JetCache.dbid, 0);
                pTHS->JetCache.dbid = 0;
            }

            if (pTHS->JetCache.sesid) {
                JetEndSession (pTHS->JetCache.sesid, JET_bitForceSessionClosed);
                pTHS->JetCache.sesid = 0;
            }

            if (fMayBeginSession) {
                ReleaseSemaphore(hsemDBLayerSessions, 1, NULL);
            }

            err = DB_ERR_UNKNOWN_ERROR;
        }
    }

    if (!err) {
        Assert(!pTHS->JetCache.sessionInUse);
        pTHS->JetCache.sessionInUse = TRUE;
    } else {
        if (InterlockedDecrement(&gcOpenDatabases) == 0 && eServiceShutdown) {
            if (InterlockedCompareExchange(&gcOpenDatabases, 0x80000000, 0) == 0) {
                SetEvent(hevDBLayerClear);
            }
        }
    }

    return err;
}



/*
DBInitThread

Make sure this thread has initialized the DB layer.
The DB layer must be initialized once for each thread id.

Also open a DBPOS for this thread.

Returns zero for success, non zero for failure.

*/

DWORD DBInitThread( THSTATE *pTHS )
{
    DWORD err = 0;

    if (!pTHS->JetCache.sessionInUse) {
        if (eServiceShutdown) {
            err = DB_ERR_SHUTTING_DOWN;
        } else {
            err = GrabSession();
        }
    }

    return err;
}

DWORD APIENTRY DBCloseThread( THSTATE *pTHS)
{
    // Thread should always be at transaction level 0 when exiting.
    Assert(0 == pTHS->transactionlevel);

    dbReleaseGlobalDNReadCache(pTHS);

    RecycleSession(pTHS);

    // Ensure that this session holds no uncommitted usns. Normally they
    // should be cleared at this point, but if they're not the system
    // will eventually assert.

    dbFlushUncUsns();


    dbResetLocalDNReadCache (pTHS, TRUE);

    return 0;
}

/*++ DBDestroyThread
 *
 * This routine closes everything associated with a session cache in a THSTATE.
 */
void DBDestroyThread( THSTATE *pTHS )
{
    if (pTHS->JetCache.sesid) {
        JetCloseTable(pTHS->JetCache.sesid, pTHS->JetCache.objtbl);
        JetCloseTable(pTHS->JetCache.sesid, pTHS->JetCache.searchtbl);
        JetCloseTable(pTHS->JetCache.sesid, pTHS->JetCache.linktbl);
        JetCloseTable(pTHS->JetCache.sesid, pTHS->JetCache.sdproptbl);
        JetCloseTable(pTHS->JetCache.sesid, pTHS->JetCache.sdtbl);

        JetCloseDatabase(pTHS->JetCache.sesid, pTHS->JetCache.dbid, 0);
#if DBG
        dbCheckJet(pTHS->JetCache.sesid);
#endif
        JetEndSession(pTHS->JetCache.sesid, JET_bitForceSessionClosed);
        ReleaseSemaphore(hsemDBLayerSessions, 1, NULL);
        DBEndSess(pTHS->JetCache.sesid);

        memset(&pTHS->JetCache, 0, sizeof(SESSIONCACHE));
    }
}


char rgchABViewIndex[] = "+" SZSHOWINCONT "\0+" SZDISPNAME "\0";

/*++ dbCheckLocalizedIndices
 *
 * This is one of the three routines in the DS that can create indices.
 * General purpose indices over single columns in the datatable are created
 * and destroyed by the schema cache by means of DB{Add|Del}ColIndex.
 * A localized index over a small fixed set of columns and a variable set
 * of languages, for use in tabling support for NSPI clients, is handled
 * in dbCheckLocalizedIndices.  Lastly, a small fixed set of indices that
 * should always be present are guaranteed by DBRecreateRequiredIndices.
 */
DWORD
dbCheckLocalizedIndices (
        JET_SESID sesid,
        JET_TABLEID tblid
        )
/*++
  Description:
      Create the localized indices used for the MAPI NSPI support.  We create
      one index per language in a registry key.

  Return Values:
      We only return an error on such conditions as memory allocation failures.
      If we can't create any localized indices, we log, but we just go on,
      since we don't want this to cause a boot failure.
--*/
{
    DWORD dwType;
    HKEY  hk;
    ULONG i;
    JET_ERR err;
    BOOL fStop = FALSE;
    BOOL fIndexExists;
    BOOL fHaveDefaultLanguage = FALSE;
    char szSuffix[9] = "";
    char szIndexName[256];
    char szValueName[256];
    DWORD dwValueNameSize;
    DWORD dwLanguage = 0;
    DWORD dwLanguageSize;

    // Start by assuming we have no default language, and we don't support any
    // langauges.
    gAnchor.ulDefaultLanguage = 0;

    gAnchor.ulNumLangs = 0;
    gAnchor.pulLangs = malloc(20 * sizeof(DWORD));
    if (!gAnchor.pulLangs) {
        MemoryPanic(20 * sizeof(DWORD));
        return ENOMEM;
    }

    gAnchor.pulLangs[0] = 20;


    // open the language regkey
    if (err = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_LOCALE_SECTION, &hk)) {
        DPRINT1(0, "%s section not found in registry. Localized MAPI indices"
                " will not be created ", DSA_LOCALE_SECTION);
        // Return no error, we still want to boot.
        return 0;
    }

    for (i = 0; !fStop; i++) {
        //  WARNING: these params are IN/OUT,
        //  so must initialise accordingly
        //  on each loop iteration
        //
        dwValueNameSize = sizeof(szValueName);
        dwLanguageSize = sizeof(dwLanguage);

        // NTRAID#NTRAID-572862-2002/03/11-andygo:  SECURITY:  need to validate registry data used by DBInit
        // REVIEW:  we need to validate the type of this value to be REG_DWORD.
        // REVIEW:  if the value name is invalid then just silently skip this entry instead
        // REVIEW:  of bailing on the rest of the list.  we should consider logging the
        // REVIEW:  fact that the entry was skipped
        if (RegEnumValue(hk,
                         i,
                         szValueName,
                         &dwValueNameSize,
                         NULL,
                         &dwType,
                         (LPBYTE) &dwLanguage,
                         &dwLanguageSize)) {
            fStop = TRUE;
            continue;
        }
        else {
            sprintf(szSuffix,"%08X", dwLanguage);
        }

        if (!IsValidLocale(MAKELCID(dwLanguage, SORT_DEFAULT),LCID_INSTALLED)) {
            LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_BAD_LANGUAGE,
                     szInsertHex(dwLanguage),
                     szInsertSz(DSA_LOCALE_SECTION),
                     NULL);
        }
        else {
            JET_INDEXID     indexidT;

            // Valid locale.  See if the index is there.
            fIndexExists = FALSE;

            strcpy(szIndexName, SZABVIEWINDEX);
            strcat(szIndexName, szSuffix);

            if (err = JetGetTableIndexInfo(sesid,
                                   tblid,
                                   szIndexName,
                                   &indexidT,
                                   sizeof(indexidT),
                                   JET_IdxInfoIndexId)) {
                // Didn't find the index or some other error.
                // Something really bad is going on because
                // DBRecreateRequiredIndexes should have
                // created it for us already.
                LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_LOCALIZED_CREATE_INDEX_FAILED,
                          szInsertUL(ATT_DISPLAY_NAME),
                          szInsertSz("ABVIEW"),
                          szInsertInt(dwLanguage),
                          szInsertInt(err),
                          szInsertJetErrMsg(err),
                          NULL, NULL, NULL);
                LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                         DS_EVENT_SEV_MINIMAL,
                         DIRLOG_NO_LOCALIZED_INDEX_CREATED_FOR_LANGUAGE,
                         szInsertHex(dwLanguage),
                         NULL,
                         NULL);
                // Don't fail the call, that would fail booting.  Keep
                // going, trying other locales.
            }
            else {
                DPRINT1(2, "Index '%s' verified\n", szIndexName);

                // OK, we support this locale.  Add the local to the sized
                // buffer of locales we support
                gAnchor.ulNumLangs++;
                if(gAnchor.ulNumLangs == gAnchor.pulLangs[0]) {
                    //  oops, need a bigger buffer
                    //
                    const DWORD cDwords     = gAnchor.pulLangs[0] * 2;
                    ULONG *     pulLangs    = realloc(gAnchor.pulLangs, cDwords * sizeof(DWORD));

                    if (!pulLangs) {
                        //  buffer realloc failed, so free
                        //  original buffer and bail
                        //
                        // REVIEW:  registry handle leak on error return
                        free( gAnchor.pulLangs );
                        gAnchor.pulLangs = NULL;
                        MemoryPanic(cDwords * sizeof(DWORD));
                        return ENOMEM;
                    }

                    gAnchor.pulLangs = pulLangs;

                    gAnchor.pulLangs[0] = cDwords;
                }
                gAnchor.pulLangs[gAnchor.ulNumLangs] = dwLanguage;

                if(!fHaveDefaultLanguage) {
                    fHaveDefaultLanguage = TRUE;
                    gAnchor.ulDefaultLanguage = dwLanguage;
                }
            }
        }

    }

    if (hk)
        RegCloseKey(hk);

    if(!fHaveDefaultLanguage) {
        // No localized indices were created. This is bad, but only for the MAPI
        // interface, so complain, but don't fail.
        DPRINT(0, "Unable to create any indices to support MAPI interface.\n");
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_NO_LOCALIZED_INDICES_CREATED,
                 NULL,
                 NULL,
                 NULL);
    }
    else {
        DPRINT1 (1, "Default Language: 0x%x\n", gAnchor.ulDefaultLanguage);
    }

    return 0;
}


DWORD
DBSetBackupHiddenTableColIDs(
    DBPOS *         pDB
    )
/*++

    This gets and sets the global JET columnid variables for the
    backup APIs.  if this function is successful, these global
    JET Column IDs will be set:
        jcidBackupUSN
        jcidBackupExpiration


Arguments:

    The pDB of the hidden DBPOS.

Return Value:

    Possible JET Error.  Also throws exceptions.

--*/
{
    JET_ERR err;
    JET_COLUMNDEF   coldef;

    // Find the backup USN column in the hidden table.
    err = JetGetTableColumnInfoEx(pDB->JetSessID,
                                  HiddenTblid, // JET_TABLEID this is the cursor
                                  SZBACKUPUSN,
                                  &coldef,
                                  sizeof(coldef),
                                  JET_ColInfo);
    if (err) {
        if (err != JET_errColumnNotFound) {
            Assert(!"Did someone change the JetGetTableColumnInfoEx() function?");
            return(err);
        }

        memset(&coldef, 0, sizeof(coldef));

        coldef.cbStruct = sizeof(coldef);
        coldef.coltyp   = JET_coltypCurrency;
        coldef.grbit    = JET_bitColumnFixed;

        err = JetAddColumn(pDB->JetSessID,
                           HiddenTblid,
                           SZBACKUPUSN,
                           &coldef,
                           NULL,    //  pvDefault (NULL==no default value for this column)
                           0,       //  cbDefault (0==no default value for this column)
                           &jcidBackupUSN);
        if (err) {
            Assert(!"JetAddColumn failed!");
            return(err);
        }
    } else {
        jcidBackupUSN = coldef.columnid;
    }

    // Find the backup expriation column in the hidden table.
    err = JetGetTableColumnInfoEx(pDB->JetSessID,
                                  HiddenTblid, // JET_TABLEID this is the cursor
                                  SZBACKUPEXPIRATION,
                                  &coldef,
                                  sizeof(coldef),
                                  JET_ColInfo);
    if (err) {
        if (err != JET_errColumnNotFound) {
            Assert(!"Did someone change the JetGetTableColumnInfoEx() function?");
            return(err);
        }

        memset(&coldef, 0, sizeof(coldef));

        coldef.cbStruct = sizeof(coldef);
        coldef.coltyp   = JET_coltypCurrency;
        coldef.grbit    = JET_bitColumnFixed;

        err = JetAddColumn(pDB->JetSessID,
                           HiddenTblid,
                           SZBACKUPEXPIRATION,
                           &coldef,
                           NULL,    //  pvDefault (NULL==no default value for this column)
                           0,       //  cbDefault (0==no default value for this column)
                           &jcidBackupExpiration);
        if (err) {
            Assert(!"JetAddColumn failed!");
            return(err);
        }
    } else {
        jcidBackupExpiration = coldef.columnid;
    }

    return(0);
}



/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Obtain a DBPOS for use by the Get and Replace.  The DBPOS is used to
*  serialize access to the hidden record.
*/
// REVIEW:  dbCreateHiddenDBPOS leaks JET and other resources on failure but if
// REVIEW:  we fail here then we are going down anyway
extern JET_ERR APIENTRY
dbCreateHiddenDBPOS(void)
{
    JET_COLUMNDEF   coldef;
    JET_ERR         err;

    /* Create hidden DBPOS */

    DPRINT(2,"dbCreateHiddenDBPOS\n");

    pDBhidden = malloc(sizeof(DBPOS));
    if(!pDBhidden) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    memset(pDBhidden, 0, sizeof(DBPOS));   /*zero out the structure*/

    /* Initialize value work buffer */

    DPRINT(5, "ALLOC inBuf and valBuf\n");
    // NTRAID#NTRAID-587164-2002/03/27-andygo:  dbCreateHiddenDBPOS needs to check malloc result before assign buffer size (DSLAB)
    // REVIEW:  we are not checking this alloc
    pDBhidden->pValBuf = malloc(VALBUF_INITIAL);
    pDBhidden->valBufSize = VALBUF_INITIAL;
    pDBhidden->Key.pFilter = NULL;
    pDBhidden->fHidden = TRUE;

    /* Open JET session. */

    JetBeginSessionEx(jetInstance, &pDBhidden->JetSessID, szUser, szPassword);

    JetOpenDatabaseEx(pDBhidden->JetSessID, szJetFilePath, "",
                      &pDBhidden->JetDBID, 0);

    DBAddSess(pDBhidden->JetSessID, pDBhidden->JetDBID);

#if DBG
    dbAddDBPOS (pDBhidden, pDBhidden->JetSessID);
#endif

    /* Open hidden table */

    JetOpenTableEx(pDBhidden->JetSessID, pDBhidden->JetDBID,
        SZHIDDENTABLE, NULL, 0, 0, &HiddenTblid);

    /* Create subject search cursor */

    JetOpenTableEx(pDBhidden->JetSessID, pDBhidden->JetDBID,
                   SZDATATABLE, NULL, 0, 0, &pDBhidden->JetSearchTbl);

    /* Initialize new object */

    DBSetFilter(pDBhidden, NULL, NULL, NULL, 0, NULL);
    DBInitObj(pDBhidden);

    /* Get USN column ID */

    JetGetTableColumnInfoEx(pDBhidden->JetSessID,
                            HiddenTblid,
                            SZUSN,
                            &coldef,
                            sizeof(coldef),
                            JET_ColInfo);
    usnid = coldef.columnid;

    /* Get DSA name column ID */

    JetGetTableColumnInfoEx(pDBhidden->JetSessID,
                            HiddenTblid,
                            SZDSA,
                            &coldef,
                            sizeof(coldef),
                            JET_ColInfo);
    dsaid = coldef.columnid;

    /* Get DSA installation state column ID */

    JetGetTableColumnInfoEx(pDBhidden->JetSessID,
                            HiddenTblid,
                            SZDSSTATE,
                            &coldef,
                            sizeof(coldef),
                            JET_ColInfo);
    dsstateid = coldef.columnid;

    /* Get DSA additional state info column ID */

    err = JetGetTableColumnInfo(pDBhidden->JetSessID,
                            HiddenTblid,
                            SZDSFLAGS,
                            &coldef,
                            sizeof(coldef),
                            JET_ColInfo);

    if (err == JET_errColumnNotFound) {

        JET_COLUMNDEF  newcoldef;
        PCREATE_COLUMN_PARAMS pColumn;

        ZeroMemory( &newcoldef, sizeof(newcoldef) );
        newcoldef.cbStruct = sizeof( JET_COLUMNDEF );
        newcoldef.coltyp = JET_coltypBinary;
        newcoldef.grbit = JET_bitColumnFixed;
        newcoldef.cbMax = 200;

        err = JetAddColumn(
            pDBhidden->JetSessID,
            HiddenTblid,
            SZDSFLAGS,
            &newcoldef,
            NULL,
            0,
            &(coldef.columnid) );

        if (err) {
            DPRINT1 (0, "Error adding column to hidden table: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
        else {
            DPRINT (0, "Succesfully created new column\n");
        }
    }
    else if (err) {
        DPRINT1 (0, "Error %d reading column\n", err);
        LogUnhandledError(err);
        return err;
    }
    dsflagsid = coldef.columnid;

    err = DBSetBackupHiddenTableColIDs(pDBhidden);
    if (err) {
        return err;
    }

    DPRINT(2,"dbCreateHiddenDBPOS done\n");
    return 0;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Close the hidden record's DBPOS
*/
// REVIEW:  dbCloseHiddenDBPOS leaks JET and other resources on failure but we
// REVIEW:  are already terming anyway and these will be cleaned up elsewhere
extern USHORT APIENTRY
dbCloseHiddenDBPOS(void)
{
    JET_SESID sesid;
    JET_DBID  dbid;

    if(!pDBhidden)
        return 0;

    dbGrabHiddenDBPOS(pTHStls);

    DPRINT(2,"dbCloseHiddenDBPOS\n");
    DPRINT1(4,"Exit count closehidden %x\n",pDBhidden->transincount);
    sesid = pDBhidden->JetSessID;
    dbid = pDBhidden->JetDBID;

    /* normally, we do a DBFree(pDBhidden) to kill a pDB, but since
     * the hidden pDB is NOT allocated on the pTHStls heap, and is instead
     * allocated using malloc, we simply do a free(pDBhidden);
     */
    free(pDBhidden);

#if DBG
    dbEndDBPOS (pDBhidden);
    dbCheckJet(sesid);
#endif

    pDBhidden = NULL;
    dbReleaseHiddenDBPOS(NULL);

    // JET_bitDbForceClose not supported in Jet600.
    JetCloseDatabaseEx(sesid, dbid, 0);
    DPRINT2(2, "dbCloseHiddenDBPOS - JetCloseDatabase. Session = %d. Dbid = %d.\n",
            sesid, dbid);

    JetEndSessionEx(sesid, JET_bitForceSessionClosed);
    DBEndSess(sesid);

    return 0;
}

/*
 * Every other DBPOS in the system is managed by DBOpen, which sets and
 * clears the thread id appropriately.  For the hidden DBPOS, we must do
 * this manually at each use, hence these routines.
 */

DBPOS *
dbGrabHiddenDBPOS(THSTATE *pTHS)
{
    EnterCriticalSection(&csHiddenDBPOS);
    Assert(pDBhidden->pTHS == NULL);
    pDBhidden->pTHS = pTHS;
    return pDBhidden;
}

void
dbReleaseHiddenDBPOS(DBPOS *pDB)
{
    Assert(pDB == pDBhidden);
    Assert(!pDB || (pDB->pTHS == pTHStls));
    if(pDB) {
        pDB->pTHS = NULL;
    }
    LeaveCriticalSection(&csHiddenDBPOS);
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Replace the hidden record.  Use the pDBhidden handle
   read the record and update it.
*/
ULONG
DBReplaceHiddenDSA(DSNAME *pDSA)
{
    JET_ERR err = 0;
    long update;
    BOOL fCommit = FALSE;
    ULONG tag = 0;
    DBPOS *pDB = dbGrabHiddenDBPOS(pTHStls);

    __try {
        DBTransIn(pDB);
        __try
        {
            if (pDSA) {
                err = sbTableGetTagFromDSName(pDB, pDSA, 0, &tag, NULL);
                if (err) {
                    LogUnhandledError(err);
                    __leave;
                }
            }

            /* Move to first (only) record in table */
            update = DS_JET_PREPARE_FOR_REPLACE;

            if (err = JetMoveEx(pDB->JetSessID,
                                HiddenTblid,
                                JET_MoveFirst,
                                0)) {
                err = 0;
                update = JET_prepInsert;
            }

            JetPrepareUpdateEx(pDB->JetSessID, HiddenTblid, update);

            JetSetColumnEx(pDB->JetSessID, HiddenTblid, dsaid, &tag,
                           sizeof(tag), 0, NULL);

            JetUpdateEx(pDB->JetSessID, HiddenTblid, NULL, 0, NULL);
            fCommit = TRUE;
        }
        __finally
        {
            if (!fCommit) {
                JetPrepareUpdate(pDB->JetSessID, HiddenTblid, JET_prepCancel);
            }
            DBTransOut(pDB, fCommit, FALSE);
        }
    }
    __finally
    {
        dbReleaseHiddenDBPOS(pDB);
    }

    return err;

}  /*DBReplaceHiddenDSA*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Replace the hidden record.  Use the pDBhidden handle
   read the record and update it.

   This update must not be done lazily. If the thread state's fLazy flag
   is set we must save the flag, clear it, and restore it when we are done.
*/
ULONG
DBReplaceHiddenUSN(USN usnInit)
{
    JET_ERR err;
    long update;
    BOOL fCommit = FALSE, fTHSLazy = FALSE;
    THSTATE *pTHS = pTHStls;
    DBPOS *pDB = dbGrabHiddenDBPOS(pTHS);

    /* Durable transactions which are nested might in fact end up being lazy.
     * Since updating the USNs must not be done lazily, this transaction must
     * not be nested. */
    Assert( 0 == pDB->transincount );

    __try
    {
        /* Save the thread state's lazy flag and clear it */
        Assert( pDB->pTHS == pTHS );
        fTHSLazy = pTHS->fLazyCommit;
        pTHS->fLazyCommit = FALSE;

        DBTransIn(pDB);
        __try
        {
            /* Move to first (only) record in table */
            update = DS_JET_PREPARE_FOR_REPLACE;

            if (err = JetMoveEx(pDB->JetSessID, HiddenTblid, JET_MoveFirst, 0))
            {
                update = JET_prepInsert;
            }

            JetPrepareUpdateEx(pDB->JetSessID, HiddenTblid, update);

            JetSetColumnEx(pDB->JetSessID, HiddenTblid, usnid,
                           &usnInit, sizeof(usnInit), 0, NULL);

            JetUpdateEx(pDB->JetSessID, HiddenTblid, NULL, 0, NULL);
            fCommit = TRUE;
        }
        __finally
        {
            if (!fCommit) {
                JetPrepareUpdate(pDB->JetSessID, HiddenTblid, JET_prepCancel);
            }
            DBTransOut(pDB, fCommit, FALSE);
        }
    }
    __finally
    {
        dbReleaseHiddenDBPOS(pDB);

        /* Restore the thread state's lazy flag */
        pTHS->fLazyCommit = fTHSLazy;
    }

    return 0;

}  /*DBReplaceHiddenUSN*/


/*-------------------------------------------------------------------------*/
/* Set State Info  */
ULONG DBSetHiddenTableStateAlt(
    DBPOS *         pDBNonHidden,
    JET_COLUMNID    jcidStateType,
    void *          pvStateValue,
    DWORD           cbStateValue
    )
/*++

    Even though we've got the hidden DBPOS, we're want to use a regular DBPOS
    to update the hidden table, so we can make updates to the regular object
    table, and to the hidden table in the same transaction.  This way it either
    commits or roll backs.

    The reason we need an alternate function is JET_TABLEID variables are
    intimately linked to the respecitve JET_SESSION it was obtained under, so
    we can NOT use global "HiddenTblid", because it's linked in with the
    hidden DBPOS's ->JetSessID.  So we open up the table

    To ensure consistency, and a lack of write conflicts, this function ensures
    that you've grabbed the hidden DBPOS first (w/ dbGrabHiddenDBPOS()).

    Note: Current this is only to reset the DitState, but I've written it
    so any of the global hidden table JET column IDs can be used.

Arguments:

    pDBNonHidden - The regular hidden DBPOS you want to commit transactions to
        the hidden table with.
    jcidStateType - The JET_COLUMNID of the column you want to set.  There are
        globals for all the JET columns in hidden table, so use one.
    pvStateValue - Pointer to the data to write.
    cbStateValue - Size of the data to write.

Return Value:

    Win32 Error

--*/
{
    JET_TABLEID HiddenTblAlt;
    JET_ERR err;
    long update;
    BOOL fCommit = FALSE;
    DWORD cbShouldBeSize;

    Assert( 1 == pDBNonHidden->transincount );
    Assert( !pTHStls->fLazyCommit );

    // Note we DON'T want pTHS passed in, we use pTHStls, because it couldn't
    // be an old state, and won't lie about who it is.
    if (pTHStls != pDBhidden->pTHS ||
        pDBNonHidden == pDBhidden) {
        Assert(!"Badness, not allowed to call in here with having the hidden DBPOS, bailing ....");
        return(ERROR_INVALID_PARAMETER);
    }

    if (jcidStateType == dsstateid &&
        cbStateValue == sizeof(DWORD)) {
        ; // OK this is good.
        // Add future cases here.
    } else {
        Assert(!"Ummmm, size doesn't match size of this column, all columns in hidden table are fixed sizes");
        return(ERROR_INVALID_PARAMETER);
    }

    __try {

        __try {
            /* Move to first (only) record in table */
            err = JetOpenTableEx(pDBNonHidden->JetSessID,
                                 pDBNonHidden->JetDBID,
                                 SZHIDDENTABLE,
                                 NULL, 0, NO_GRBIT,
                                 &HiddenTblAlt);
            if (err) {
                Assert(!"JLiem says this can't happen");
                __leave;
            }

            if (err = JetMoveEx(pDBNonHidden->JetSessID, HiddenTblAlt, JET_MoveFirst, NO_GRBIT)) {
                Assert(err == JET_errNoCurrentRecord);
                __leave;
            }

            JetPrepareUpdateEx(pDBNonHidden->JetSessID, HiddenTblAlt, JET_prepReplace);

            JetSetColumnEx(pDBNonHidden->JetSessID, HiddenTblAlt,
                           jcidStateType, pvStateValue, cbStateValue,
                           NO_GRBIT, NULL);

            JetUpdateEx(pDBNonHidden->JetSessID, HiddenTblAlt, NULL, 0, NULL);

            //
            // Success
            //
            fCommit = TRUE;
            err = 0;
        }
        __finally {

            if (!fCommit) {
                JetPrepareUpdate(pDBNonHidden->JetSessID, HiddenTblAlt, JET_prepCancel);
                err = ERROR_INVALID_PARAMETER;
            }

            JetCloseTableEx(pDBNonHidden->JetSessID, HiddenTblAlt);

        }
    } __except (HandleMostExceptions(GetExceptionCode())) {
        /* Do nothing, but at least don't die */
        err = DB_ERR_EXCEPTION;
    }

    return err;
}

ULONG DBSetHiddenState(DITSTATE State)
{
    JET_ERR err;
    long update;
    BOOL fCommit = FALSE;
    DBPOS *pDB = dbGrabHiddenDBPOS(pTHStls);

    __try {

        __try {
            DBTransIn(pDB);
            __try {
                /* Move to first (only) record in table */
                update = DS_JET_PREPARE_FOR_REPLACE;

                if (err = JetMoveEx(pDB->JetSessID,
                                    HiddenTblid,
                                    JET_MoveFirst,
                                    0)) {
                    update = JET_prepInsert;
                }

                JetPrepareUpdateEx(pDB->JetSessID, HiddenTblid, update);

                JetSetColumnEx(pDB->JetSessID, HiddenTblid, dsstateid,
                               &State, sizeof(State), 0, NULL);

                JetUpdateEx(pDB->JetSessID, HiddenTblid, NULL, 0, NULL);
                fCommit = TRUE;
                err = 0;
            }
            __finally {
                if (!fCommit) {
                    JetPrepareUpdate(pDB->JetSessID, HiddenTblid, JET_prepCancel);
                }
                DBTransOut(pDB, fCommit, FALSE);
            }
        } __except (HandleMostExceptions(GetExceptionCode())) {
            /* Do nothing, but at least don't die */
            err = DB_ERR_EXCEPTION;
        }

    }
    __finally {
        dbReleaseHiddenDBPOS(pDB);
    }

    return err;

}

ULONG dbGetHiddenFlags(CHAR *pFlags, DWORD flagslen)
{
    JET_ERR             err = 0;
    ULONG               actuallen;
    BOOL                fCommit = FALSE;
    DBPOS *pDB = dbGrabHiddenDBPOS(pTHStls);

    __try {
        __try {
            DBTransIn(pDB);
            __try {
                *pFlags = '\0';          /* In case of error */

                /* Move to first (only) record in table */

                if ((err = JetMoveEx(pDB->JetSessID,
                                     HiddenTblid,
                                     JET_MoveFirst,
                                     0)) != JET_errSuccess) {
                    DsaExcept(DSA_DB_EXCEPTION, err, 0);
                }

                /* Retrieve state */

                err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                                HiddenTblid,
                                                dsflagsid,
                                                pFlags,
                                                flagslen,
                                                &actuallen,
                                                0,
                                                NULL);
                if (err != JET_errSuccess && err != JET_wrnColumnNull) {
                    DsaExcept(DSA_DB_EXCEPTION, err, 0);
                }

                fCommit = TRUE;
            }
            __finally {
                DBTransOut(pDB, fCommit, FALSE);
            }
        }
        __except (HandleMostExceptions(GetExceptionCode())) {
            if (0 == err)
              err = DB_ERR_EXCEPTION;
        }
    }
    __finally {
        dbReleaseHiddenDBPOS(pDB);
    }

    return err;
}

ULONG DBUpdateHiddenFlags() {
    return dbSetHiddenFlags((CHAR*)&gdbFlags, sizeof(gdbFlags));
}

ULONG dbSetHiddenFlags(CHAR *pFlags, DWORD flagslen)
{
    JET_ERR err;
    long update;
    BOOL fCommit = FALSE;
    DBPOS *pDB = dbGrabHiddenDBPOS(pTHStls);

    __try {
        __try {
            DBTransIn(pDB);
            __try {
                /* Move to first (only) record in table */
                update = DS_JET_PREPARE_FOR_REPLACE;

                if (err = JetMoveEx(pDB->JetSessID,
                                    HiddenTblid,
                                    JET_MoveFirst,
                                    0)) {
                    update = JET_prepInsert;
                }

                JetPrepareUpdateEx(pDB->JetSessID, HiddenTblid, update);

                JetSetColumnEx(pDB->JetSessID, HiddenTblid, dsflagsid,
                               pFlags, flagslen, 0, NULL);

                JetUpdateEx(pDB->JetSessID, HiddenTblid, NULL, 0, NULL);
                fCommit = TRUE;
                err = 0;
            }
            _finally {
                DBTransOut(pDB, fCommit, FALSE);
            }
        } __except (HandleMostExceptions(GetExceptionCode())) {
            /* Do nothing, but at least don't die */
            err = DB_ERR_EXCEPTION;
        }
    }
    _finally {
        dbReleaseHiddenDBPOS(pDB);
    }

    return err;
}

ULONG DBGetHiddenStateInt(DBPOS * pDB, DITSTATE* pState)
{

    JET_ERR             err = 0;
    ULONG               actuallen;
    BOOL                fCommit = FALSE;

    Assert(pState);
    *pState = eErrorDit;    /* In case of error */

    if (pTHStls != pDBhidden->pTHS) {
        Assert(!"Badness, not allowed to call in here with having the hidden DBPOS, bailing ....");
        return(ERROR_INVALID_PARAMETER);
    }

    __try {
        DBTransIn(pDB);
        __try {

            /* Move to first (only) record in table */

            if ((err = JetMoveEx(pDB->JetSessID,
                                 HiddenTblid,
                                 JET_MoveFirst,
                                 0)) != JET_errSuccess) {
                DsaExcept(DSA_DB_EXCEPTION, err, 0);
            }

            /* Retrieve state */

            JetRetrieveColumnSuccess(pDB->JetSessID,
                                     HiddenTblid,
                                     dsstateid,
                                     pState,
                                     sizeof(*pState),
                                     &actuallen,
                                     0,
                                     NULL);

            fCommit = TRUE;
        }
        __finally {
            DBTransOut(pDB, fCommit, FALSE);
        }
    }
    __except (HandleMostExceptions(GetExceptionCode())) {
        if (0 == err)
          err = DB_ERR_EXCEPTION;
    }

    return err;
}

ULONG DBGetHiddenState(DITSTATE* pState)
{

    JET_ERR             err = 0;
    ULONG               actuallen;
    BOOL                fCommit = FALSE;
    DBPOS *pDB = dbGrabHiddenDBPOS(pTHStls);

    Assert(pState);
    *pState = eErrorDit;    /* In case of error */
    __try {

        err = DBGetHiddenStateInt(pDB, pState);

    }
    __finally {
        dbReleaseHiddenDBPOS(pDB);
    }

    return err;
}




/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Retrieves the hidden DSA name.  Allocates memory for DSA name and
   sets user's pointer to it.
*/
extern USHORT APIENTRY DBGetHiddenRec(DSNAME **ppDSA, USN *pusnInit){

    JET_ERR             err;
    ULONG               actuallen;
    DSNAME              *pHR;
    BOOL                fCommit = FALSE;
    ULONG               tag;
    DBPOS *pDB = dbGrabHiddenDBPOS(pTHStls);

    *ppDSA = NULL;
    *pusnInit = 0;

    __try {
        DBTransIn(pDB);
        __try {
            /* Move to first (only) record in table */

            if ((err = JetMoveEx(pDB->JetSessID,
                                 HiddenTblid,
                                 JET_MoveFirst,
                                 0)) != JET_errSuccess) {
                DsaExcept(DSA_DB_EXCEPTION, err, 0);
            }

            /* Retrieve DSA name */

            JetRetrieveColumnSuccess(pDB->JetSessID, HiddenTblid, dsaid,
                                     &tag, sizeof(tag), &actuallen, 0, NULL);
            Assert(actuallen == sizeof(tag));

            err = sbTableGetDSName(pDB, tag, &pHR,0);
            // NOTICE-2002/04/22-andygo:  dead code
            // REVIEW:  this branch is dead code because sbTableGetDSName only
            // REVIEW:  fails by throwing an exception
            if (err) {
                // uh, oh
                LogUnhandledError(err);
            }

            /* Allocate space to hold the name-address on the permanent heap*/

            if (!(*ppDSA = malloc(pHR->structLen)))
            {
                DsaExcept(DSA_MEM_EXCEPTION, 0, 0);
            }
            memcpy(*ppDSA, pHR, pHR->structLen);
            THFree(pHR);

            /* Retrieve USN */

            JetRetrieveColumnSuccess(pDB->JetSessID, HiddenTblid, usnid,
                pusnInit, sizeof(*pusnInit), &actuallen, 0, NULL);

            fCommit = TRUE;
        }
        __finally
        {
            DBTransOut(pDB, fCommit, FALSE);
            if (!fCommit) {
                free(*ppDSA);
                *ppDSA = NULL;
            }
        }
    }
    __finally
    {
        dbReleaseHiddenDBPOS(pDB);
    }

    return 0;
}/*GetHiddenRec*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* DBForceDurableCommit
 * Force a durable commit of any completed lazy transactions which have not
 * yet been written to disk. Raises an exception on failure.
 *
 * Note: dbGrabHiddenDBPOS holds the csHiddenDBPOS critical section and
 * dbReleaseHiddenDBPOS releases it. Since JetCommitTransactionEx() might
 * take a long time, there are two potential problems here:
 *  - Critical section timeout during stress
 *  - Other threads which need to access the hidden DBPOS are blocked.
 * We don't really need to use the hidden DBPOS here. Any Jet session would
 * have been fine.
 */
VOID
DBForceDurableCommit( VOID )
{
    THSTATE *pTHS = pTHStls;
    DBPOS   *pDB = NULL;
    JET_ERR  err;

    __try {

        pDB = dbGrabHiddenDBPOS(pTHS);
        err = JetCommitTransactionEx(pDB->JetSessID, JET_bitWaitAllLevel0Commit);
        Assert( JET_errSuccess == err );

    } __finally {
        if( pDB ) {
            dbReleaseHiddenDBPOS(pDB);
            pDB = NULL;
        }
    }
}


/*++ DBRecreateRequiredIndices
 *
 * This is one of the three routines in the DS that can create indices.
 * Most general purpose indices over single columns in the datatable are created
 * and destroyed by the schema cache by means of DB{Add|Del}ColIndex.
 * Localized indices over a small fixed set of columns and a variable set
 * of languages, for use in tabling support for NSPI clients, are handled
 * in dbCheckLocalizedIndices.  Lastly, a small fixed set of indices that
 * should always be present are guaranteed by DBRecreateRequiredIndices.
 *
 * Why do we need code to maintain a fixed set of indices?
 * Since NT upgrades can change the definition of sort orders, they can
 * also invalidate existing JET indices, which are built on the premise
 * that the results of a comparison of two constant values will not change
 * over time.  Therefore JET responds to NT upgrades by deleting indices
 * at attach time that could have been corrupted by an NT upgrade since
 * the previous attach.  The schema cache will automatically recreate any
 * indices indicated in the schema, and other code will handle creating
 * localized indices, because we expect these sets of indices to change
 * over time.  However, we have some basic indices that the DSA uses to
 * hold the world together that we don't ever expect to go away.  This
 * routine is used to recreate all those indices, based from a hard-coded
 * list.
 *
 * So what indices should be listed here and what can be listed in
 * schema.ini?  The short answer is that the DNT index should stay in
 * schema.ini, and that any index involving any Unicode column *must*
 * be listed here.  Anything else is left to user discretion.
 */

// New columns in the data table
CREATE_COLUMN_PARAMS rgCreateDataColumns[] = {
    // Create object cleanup indicator column
    { SZCLEAN, &cleanid, JET_coltypUnsignedByte, JET_bitColumnTagged, 0, NULL, 0 },
    0
};

// A note on index design. There are two ways to accomplish conditional
// membership in an index.
// One is used when the trigger for filtering is an optional attribute
// being null. In that case, include the attribute in the index, and use
// the flag IgnoreAnyNull.  For example, see isABVisible and isCritical
// in below indexes for examples of indicator columns.
// The other is used when the trigger for filtering is an attribute being
// non-null. In that case, use a conditional column.  See the example of
// deltime as a indicator for the link indexes.  An additional note, I haven't
// had any luck using conditional columns for a tagged attribute, but
// maybe I was missing something.

char rgchRdnKey[] = "+" SZRDNATT "\0";
char rgchPdntKey[] = "+" SZPDNT "\0+" SZRDNATT "\0";
char rgchAccNameKey[] = "+" SZNCDNT "\0+" SZACCTYPE "\0+" SZACCNAME "\0";
char rgchIsDelKey[] = "+" SZISDELETED "\0";
char rgchCleanKey[] = "+" SZCLEAN "\0";
char rgchDraUsnCriticalKey[] = "+" SZNCDNT "\0+" SZUSNCHANGED "\0+" SZISCRITICAL "\0+" SZDNT "\0";
char rgchDraNcGuidKey[] = "+" SZNCDNT "\0+" SZGUID "\0";
char rgchDraUsnIndexKeys[] = "+" SZNCDNT "\0+" SZUSNCHANGED "\0";
char rgchDeltimeKey[] = "+" SZDELTIME "\0";


JET_UNICODEINDEX    idxunicodeDefault       = { DS_DEFAULT_LOCALE, DS_DEFAULT_LOCALE_COMPARE_FLAGS | LCMAP_SORTKEY };


CreateIndexParams   FixedIndices[]          = {

    // Create SZPDNTINDEX -- ** UNICODE **
    // UNDONE: this index should probably be using IgnoreAnyNull instead of IgnoreNull
    //
    { SZPDNTINDEX, rgchPdntKey, sizeof(rgchPdntKey),
      JET_bitIndexUnicode | JET_bitIndexUnique | JET_bitIndexIgnoreNull, GENERIC_INDEX_DENSITY, &idxPdnt, NULL},

    // Create SZ_NC_ACCTYPE_NAME_INDEX -- ** UNICODE **
    //
    { SZ_NC_ACCTYPE_NAME_INDEX, rgchAccNameKey, sizeof(rgchAccNameKey),
      JET_bitIndexUnicode | JET_bitIndexIgnoreNull | JET_bitIndexIgnoreAnyNull,
      GENERIC_INDEX_DENSITY, &idxNcAccTypeName, NULL},

    // Create new SZNCGUIDINDEX
    //
    { SZNCGUIDINDEX, rgchDraNcGuidKey, sizeof(rgchDraNcGuidKey),
      JET_bitIndexIgnoreAnyNull, GENERIC_INDEX_DENSITY, &idxNcGuid, NULL},

    // Create new SZDELTIMEINDEX
    //
    // NOTE: this index used to be called SZDELINDEX and it used
    // to have an unnecessary DNT tacked onto the end of the
    // index key
    //
    // NOTE: this index is different than SZISDELINDEX
    //
    { SZDELTIMEINDEX, rgchDeltimeKey, sizeof(rgchDeltimeKey),
      JET_bitIndexIgnoreAnyNull, 98, &idxDel, NULL },

    // Create new SZCLEANINDEX
    //
    // NOTE: this index used to be called SZDNTCLEANINDEX because there
    // used to be a DNT in the index key
    //
    { SZCLEANINDEX, rgchCleanKey, sizeof(rgchCleanKey),
      JET_bitIndexIgnoreAnyNull, GENERIC_INDEX_DENSITY, &idxClean, NULL},

    // Create new SZDRAUSNINDEX
    //
    { SZDRAUSNINDEX, rgchDraUsnIndexKeys, sizeof(rgchDraUsnIndexKeys),
      JET_bitIndexIgnoreNull, 100, &idxDraUsn, NULL },

    // Create new DRA USN CRITICAL index
    //
    { SZDRAUSNCRITICALINDEX, rgchDraUsnCriticalKey, sizeof( rgchDraUsnCriticalKey ),
      JET_bitIndexIgnoreNull | JET_bitIndexIgnoreAnyNull, 98, &idxDraUsnCritical, NULL},
};

DWORD cFixedIndices = sizeof(FixedIndices) / sizeof(FixedIndices[0]);


// Indexes to be modified
// This is for (non-primary) indexes that have changed since the Product 1 DIT
//
// If indexes in the dit are different from what is listed here, they will
// be recreated with the new attributes.
// Note that the index differencing code is pretty simple. Make sure
// the code can distinguish your type of change!

//
// Modified Data Table Indexes
//

// UNDONE: currently only support changing number of columns in the index
//
typedef struct
    {
    CHAR *  szIndexName;
    ULONG   cColumns;
    } MODIFY_INDEX;


MODIFY_INDEX rgModifyFixedIndices[] = {

    //  SZDELINDEX has been renamed to SZDELTIMEINDEX and
    //  the DNT column has been dropped from the index key
    //
    { SZDELINDEX, 0 },

    //  SZDNTDELINDEX has been converted to an attribute index on IsDeleted
    //  (setting cColumns to 0 will simply force this index to be deleted
    //  if it exists).
    //
    { SZDNTDELINDEX, 0 },

    //  SZDNTCLEANINDEX has been renamed to SZCLEANINDEX and the DNT
    //  has been dropped from the index key (setting cColumns to 0
    //  will simply force this index to be deleted if it exists)
    //
    { SZDNTCLEANINDEX, 0 },

    //  Modify SZDRAUSNINDEX to remove SZISCRITICAL
    //
    { SZDRAUSNINDEX, 2 },
};

const DWORD cModifyFixedIndices = sizeof(rgModifyFixedIndices) / sizeof(rgModifyFixedIndices[0]);

VOID DBAllocFixedIndexCreate(
    CreateIndexParams * pfixedindex,
    JET_INDEXCREATE *   pTempIC )
    {
    memset(pTempIC, 0, sizeof(JET_INDEXCREATE));
    pTempIC->cbStruct = sizeof(JET_INDEXCREATE);

    pTempIC->szIndexName = pfixedindex->szIndexName;
    pTempIC->szKey = pfixedindex->szIndexKeys;
    pTempIC->cbKey = pfixedindex->cbIndexKeys;
    pTempIC->ulDensity = pfixedindex->ulDensity;
    pTempIC->grbit = ( JET_bitIndexUnicode | pfixedindex->ulFlags );
    pTempIC->pidxunicode = &idxunicodeDefault;

    if ( NULL != pfixedindex->pConditionalColumn )
        {
        pTempIC->rgconditionalcolumn = pfixedindex->pConditionalColumn;
        pTempIC->cConditionalColumn = 1;
        }
    }

VOID DBAllocABViewIndexCreate(
    const CHAR *        szIndexName,
    const DWORD         dwLanguage,
    JET_INDEXCREATE *   pTempIC,
    JET_UNICODEINDEX *  pTempUID )
    {
    THSTATE *           pTHS        = pTHStls;
    JET_CONDITIONALCOLUMN *pCondCol;

    memset(pTempIC, 0, sizeof(JET_INDEXCREATE));
    pTempIC->cbStruct = sizeof(JET_INDEXCREATE);

    pTempIC->szIndexName = THAllocEx( pTHS, strlen(szIndexName) + 1 );
    pTempIC->rgconditionalcolumn = THAllocEx(pTHS, sizeof(JET_CONDITIONALCOLUMN));

    memcpy(pTempIC->szIndexName, szIndexName, strlen(szIndexName) + 1 );

    pTempIC->szKey = rgchABViewIndex;
    pTempIC->cbKey = sizeof(rgchABViewIndex);

    pTempIC->ulDensity = DISPNAMEINDXDENSITY;

    pTempIC->grbit = JET_bitIndexUnicode|JET_bitIndexIgnoreAnyNull;
    pTempIC->pidxunicode = pTempUID;

    pTempIC->cConditionalColumn = 1;
    pTempIC->rgconditionalcolumn->cbStruct     = sizeof(JET_CONDITIONALCOLUMN);
    pTempIC->rgconditionalcolumn->grbit        = JET_bitIndexColumnMustBeNonNull;
    pTempIC->rgconditionalcolumn->szColumnName = SZISVISIBLEINAB;

    memset(pTempUID, 0, sizeof(JET_UNICODEINDEX));
    pTempUID->lcid = dwLanguage;
    pTempUID->dwMapFlags = (NORM_IGNORECASE | NORM_IGNOREKANATYPE | NORM_IGNORENONSPACE | NORM_IGNOREWIDTH | LCMAP_SORTKEY);
    }

VOID DBAllocAttrIndexCreate(
    const INDEX_INFO *  pindexinfo,
    const CHAR *        szIndexName,
    BYTE *              rgbIndexDef,
    JET_INDEXCREATE *   pTempIC )
    {
    THSTATE *           pTHS        = pTHStls;

    memset( pTempIC, 0, sizeof(JET_INDEXCREATE) );
    pTempIC->cbStruct = sizeof(JET_INDEXCREATE);

    pTempIC->szIndexName = THAllocEx(pTHS, strlen(szIndexName) + 1 );
    memcpy( pTempIC->szIndexName, szIndexName, strlen(szIndexName) + 1 );

    sprintf(
        rgbIndexDef,
        "+" SZATTINDEXKEYPREFIX "%c%d",
        CHATTSYNTAXPREFIX + pindexinfo->syntax,
        pindexinfo->attrType );

    //  double-null-terminate the key
    //
    pTempIC->cbKey = strlen( rgbIndexDef ) + 1;
    rgbIndexDef[pTempIC->cbKey] = 0;
    pTempIC->cbKey++;

    pTempIC->szKey = THAllocEx( pTHS, pTempIC->cbKey );
    memcpy( pTempIC->szKey, rgbIndexDef, pTempIC->cbKey );

    pTempIC->ulDensity = GENERIC_INDEX_DENSITY;
    pTempIC->grbit = ( JET_bitIndexUnicode | JET_bitIndexIgnoreAnyNull );
    pTempIC->pidxunicode = &idxunicodeDefault;
    }

VOID DBAllocPDNTAttrIndexCreate(
    const INDEX_INFO *  pindexinfo,
    const CHAR *        szIndexName,
    BYTE *              rgbIndexDef,
    JET_INDEXCREATE *   pTempIC )
    {
    THSTATE *           pTHS        = pTHStls;
    BYTE *              pb;

    memset( pTempIC, 0, sizeof(JET_INDEXCREATE) );
    pTempIC->cbStruct = sizeof(JET_INDEXCREATE);

    pTempIC->szIndexName = THAllocEx(pTHS, strlen(szIndexName) + 1 );
    memcpy( pTempIC->szIndexName, szIndexName, strlen(szIndexName) + 1 );

    //  prepend PDNT column to the index key,
    //  making sure to null-terminate it
    //
    strcpy( rgbIndexDef, "+" SZPDNT );
    pTempIC->cbKey = strlen( rgbIndexDef ) + 1;
    pb = rgbIndexDef + pTempIC->cbKey;

    sprintf(
        pb,
        "+" SZATTINDEXKEYPREFIX "%c%d",
        CHATTSYNTAXPREFIX + pindexinfo->syntax,
        pindexinfo->attrType );

    //  double-null-terminate the key
    //
    pTempIC->cbKey += strlen( pb ) + 1;
    rgbIndexDef[pTempIC->cbKey] = 0;
    pTempIC->cbKey++;

    pTempIC->szKey = THAllocEx( pTHS, pTempIC->cbKey );
    memcpy( pTempIC->szKey, rgbIndexDef, pTempIC->cbKey );

    pTempIC->ulDensity = GENERIC_INDEX_DENSITY;
    pTempIC->grbit = ( JET_bitIndexUnicode | JET_bitIndexIgnoreAnyNull );
    pTempIC->pidxunicode = &idxunicodeDefault;
    }

VOID DBAllocTupleAttrIndexCreate(
    const INDEX_INFO *      pindexinfo,
    const CHAR *            szIndexName,
    BYTE *                  rgbIndexDef,
    JET_INDEXCREATE *       pTempIC )
    {
    THSTATE *               pTHS            = pTHStls;
    const ULONG             cbIndexName     = strlen(szIndexName) + 1;
    JET_CONDITIONALCOLUMN * pcondcolumn;

    memset( pTempIC, 0, sizeof(JET_INDEXCREATE) );
    pTempIC->cbStruct = sizeof(JET_INDEXCREATE);

    //  conditional column structure hangs off the end of the index name
    //
    pTempIC->szIndexName = THAllocEx(pTHS, cbIndexName + sizeof(JET_CONDITIONALCOLUMN) );
    pcondcolumn = (JET_CONDITIONALCOLUMN *)( pTempIC->szIndexName + cbIndexName );

    memcpy( pTempIC->szIndexName, szIndexName, cbIndexName );

    sprintf(
        rgbIndexDef,
        "+" SZATTINDEXKEYPREFIX "%c%d",
        CHATTSYNTAXPREFIX + pindexinfo->syntax,
        pindexinfo->attrType );

    //  double-null-terminate the key
    //
    pTempIC->cbKey = strlen( rgbIndexDef ) + 1;
    rgbIndexDef[pTempIC->cbKey] = 0;
    pTempIC->cbKey++;

    pTempIC->szKey = THAllocEx( pTHS, pTempIC->cbKey );
    memcpy( pTempIC->szKey, rgbIndexDef, pTempIC->cbKey );

    pTempIC->ulDensity = GENERIC_INDEX_DENSITY;
    pTempIC->grbit = ( JET_bitIndexUnicode | JET_bitIndexTuples | JET_bitIndexIgnoreAnyNull );
    pTempIC->pidxunicode = &idxunicodeDefault;

    pTempIC->rgconditionalcolumn = pcondcolumn;
    pTempIC->cConditionalColumn = 1;

    // only index substrings if this object isn't deleted
    //
    pcondcolumn->cbStruct = sizeof(JET_CONDITIONALCOLUMN);
    pcondcolumn->szColumnName = SZISDELETED;
    pcondcolumn->grbit = JET_bitIndexColumnMustBeNull;
    }


JET_ERR dbDeleteObsoleteFixedIndices(
    const JET_SESID     sesid,
    const JET_TABLEID   tableid )
    {
    JET_ERR             err;
    JET_INDEXLIST       idxlist;
    ULONG               cColumns;
    ULONG               iindex;
    BOOL                fRetrievedIdxList    = FALSE;

    for ( iindex = 0; iindex < cModifyFixedIndices; iindex++ )
        {
        //  extract info for this index
        //
        Assert( !fRetrievedIdxList );
        err = JetGetTableIndexInfo(
                        sesid,
                        tableid,
                        rgModifyFixedIndices[iindex].szIndexName,
                        &idxlist,
                        sizeof(idxlist),
                        JET_IdxInfo );
        if ( JET_errSuccess == err )
            {
            fRetrievedIdxList = TRUE;
            Call( JetMove( sesid, idxlist.tableid, JET_MoveFirst, NO_GRBIT ) );
            Call( JetRetrieveColumn(
                        sesid,
                        idxlist.tableid,
                        idxlist.columnidcColumn,
                        &cColumns,
                        sizeof(cColumns),
                        NULL,
                        NO_GRBIT,
                        NULL ) );

            //  see if the column count matches
            //
            Assert( 0 != cColumns );
            if ( rgModifyFixedIndices[iindex].cColumns != cColumns )
                {
                //  delete index (it will be recreated later)
                //
                DPRINT1( 0, "Deleting an obsolete fixed index '%s'...\n", rgModifyFixedIndices[iindex].szIndexName );
                Call( JetDeleteIndex( sesid, tableid, rgModifyFixedIndices[iindex].szIndexName ) );
                }

            Call( JetCloseTable( sesid, idxlist.tableid ) );
            fRetrievedIdxList = FALSE;
            }
        else if ( JET_errIndexNotFound != err )
            {
            //  assume IndexNotFound was because the index was previously deleted
            //  and we crashed before we had a chance to recreate it, or that we
            //  no longer need the index so it wasn't recreated
            //
            CheckErr( err );
            }
        }

	err = JET_errSuccess;

HandleError:
    if ( fRetrievedIdxList )
        {
        err = JetCloseTableWithErrUnhandled( sesid, idxlist.tableid, err );
        }

    return err;
    }

JET_ERR dbDeleteObsoleteAttrIndices(
    IN      JET_SESID           sesid,
    IN      JET_TABLEID         tableid,
    IN      JET_INDEXCREATE *   pIndexCreate,
    IN OUT  DWORD *             pcIndexCreate,
    const   DWORD               cIndexCreateMax )

/*++

Routine Description:

    This routine deletes all obsolete attribute indices in the DIT.  An attribute
    index is considered obsolete if it contains an extra key segment for the
    DNT.  This technique was used in the days of old to improve performance
    while seeking on indices with a large number of duplicates.  This trick
    became obsolete when JET began to automatically include the primary key
    in the secondary index key.  The trick remained in use for some time after
    that due to an oversight.  It is advantageous to remove this extra key
    segment because it bloats the key space in the index, prevents us from
    using JET_bitSeekEQ on these indices, and is otherwise useless.

    Any indices that are deleted will be replaced later on during DS init or by
    the schema manager.

    Due to the fact that the DS must still function if these indices are still
    present, this routine will merely try to delete as many of them as it can.
    If we fail to enumerate or delete all such indices then we will not cause
    DS init to fail.

Arguments:

    sesid           - Supplies the session to use to delete the indices
    dbid            - Supplies the database from which to delete the indices

Return Value:

    None

 --*/

    {
    JET_ERR         err;
    JET_INDEXLIST   idxlist;
    size_t          iRecord                 = 0;
    BYTE            rgbIndexDef[128];
    INDEX_INFO      indexinfo;
    BOOL            fRetrievedIdxList       = FALSE;
    BOOL            fPotentialAttrIndex     = FALSE;

    // get a list of all indices on the datatable
    //
    Call( JetGetTableIndexInfo( sesid, tableid, NULL, &idxlist, sizeof(idxlist), JET_IdxInfoList ) );
    fRetrievedIdxList = TRUE;

    // walk the list of all indices on the datatable, as long as we still have spare
    // JET_INDEXCREATE structures with which to rebuild indices

    for ( iRecord = 0; iRecord < idxlist.cRecord && (*pcIndexCreate) < cIndexCreateMax; iRecord++ )
        {
        // fetch the current index segment description

        size_t              iretcolName         = 0;
        size_t              iretcolCColumn      = 1;
        size_t              iretcolIColumn      = 2;
        size_t              iretcolColName      = 3;
        size_t              cretcol             = 4;
        JET_RETRIEVECOLUMN  rgretcol[4]         = { 0 };
        ULONG               cColumn             = 0;
        ULONG               iColumn             = 0;
        CHAR                szIndexName[JET_cbNameMost + 1]     = { 0 };
        CHAR                szColumnName[JET_cbNameMost + 1]    = { 0 };

        rgretcol[iretcolName].columnid          = idxlist.columnidindexname;
        rgretcol[iretcolName].pvData            = szIndexName;
        rgretcol[iretcolName].cbData            = JET_cbNameMost;
        rgretcol[iretcolName].itagSequence      = 1;

        rgretcol[iretcolCColumn].columnid       = idxlist.columnidcColumn;
        rgretcol[iretcolCColumn].pvData         = &cColumn;
        rgretcol[iretcolCColumn].cbData         = sizeof(cColumn);
        rgretcol[iretcolCColumn].itagSequence   = 1;

        rgretcol[iretcolIColumn].columnid       = idxlist.columnidiColumn;
        rgretcol[iretcolIColumn].pvData         = &iColumn;
        rgretcol[iretcolIColumn].cbData         = sizeof(iColumn);
        rgretcol[iretcolIColumn].itagSequence   = 1;

        rgretcol[iretcolColName].columnid       = idxlist.columnidcolumnname;
        rgretcol[iretcolColName].pvData         = szColumnName;
        rgretcol[iretcolColName].cbData         = JET_cbNameMost;
        rgretcol[iretcolColName].itagSequence   = 1;

        Call( JetRetrieveColumns(sesid, idxlist.tableid, rgretcol, cretcol) );

        szIndexName[rgretcol[iretcolName].cbActual] = 0;
        szColumnName[rgretcol[iretcolColName].cbActual] = 0;

        DPRINT3( 2, "Inspecting index \"%s\", key segment %d \"%s\"\n", szIndexName, iColumn, szColumnName );

        // if this is the last segment in an index and that index is an
        // attribute index and that segment is over the DNT column then
        // this index is obsolete and must be deleted

        if ( 0 == iColumn )
            {
            fPotentialAttrIndex = FALSE;

            if ( !_strnicmp( szIndexName, SZATTINDEXPREFIX, strlen(SZATTINDEXPREFIX) )
                && !_strnicmp( szColumnName, SZATTINDEXKEYPREFIX, strlen(SZATTINDEXKEYPREFIX) ) )
                {
                const CHAR *    szAttId     = szIndexName + strlen(SZATTINDEXPREFIX);

                //  make sure this is a plain attribute index (not a PDNT or tuple index)
                //
                if ( 1 == sscanf( szAttId, "%08X", &indexinfo.attrType ) )
                    {
                    //  extract attribute syntax from the attribute name
                    //
                    indexinfo.syntax = *( szColumnName + strlen(SZATTINDEXKEYPREFIX) ) - CHATTSYNTAXPREFIX;
                    indexinfo.indexType = fATTINDEX;
                    fPotentialAttrIndex = TRUE;
                    }
                }
            }

        else if ( fPotentialAttrIndex
            && iColumn == cColumn - 1
            && !_stricmp( szColumnName, SZDNT) )
            {
            Assert( !_strnicmp( szIndexName, SZATTINDEXPREFIX, strlen(SZATTINDEXPREFIX) ) );

            //  delete the index and add it to the list of indexes to rebuild
            //
            DPRINT1( 0, "Deleting an obsolete attribute index '%s'...\n", szIndexName );
            Call( JetDeleteIndex( sesid, tableid, szIndexName ) );
            DBAllocAttrIndexCreate(
                        &indexinfo,
                        szIndexName,
                        rgbIndexDef,
                        &pIndexCreate[(*pcIndexCreate)++] );
            Assert( *pcIndexCreate <= cIndexCreateMax );
            }

        // move on to the next index segment

        if ( iRecord + 1 < idxlist.cRecord )
            {
            Call( JetMove(sesid, idxlist.tableid, JET_MoveNext, NO_GRBIT ) );
            }
        }

	err = JET_errSuccess;

HandleError:
    if ( fRetrievedIdxList )
        {
        err = JetCloseTableWithErrUnhandled( sesid, idxlist.tableid, err );
        }

    return err;
    }

JET_ERR dbDeleteObsoleteABViewIndex(
    const   JET_SESID           sesid,
    const   JET_TABLEID         tableid,
    const   CHAR *              szIndexName,
    OUT     BOOL *              pfIndexMissing )
    {
    JET_ERR                     err;
    JET_INDEXLIST               idxlist;
    ULONG                       cColumns;
    DWORD                       dwFlags;
    BOOL                        fRetrievedIdxList       = FALSE;

    *pfIndexMissing = FALSE;

    //  get info for the specified index
    //
    err = JetGetTableIndexInfo( sesid, tableid, szIndexName, &idxlist, sizeof(idxlist), JET_IdxInfo );
    if ( JET_errIndexNotFound == err )
        {
        //  index is not even present, ask to have in built
        //
        *pfIndexMissing = TRUE;
        }
    else
        {
        CheckErr( err );

        fRetrievedIdxList = TRUE;

        Call( JetRetrieveColumn(
                    sesid,
                    idxlist.tableid,
                    idxlist.columnidcColumn,
                    &cColumns,
                    sizeof( cColumns ),
                    NULL,
                    NO_GRBIT,
                    NULL ) );
        Call( JetRetrieveColumn(
                    sesid,
                    idxlist.tableid,
                    idxlist.columnidLCMapFlags,
                    &dwFlags,
                    sizeof( dwFlags ),
                    NULL,
                    NO_GRBIT,
                    NULL ) );
        if (    2 != cColumns ||
                ( NORM_IGNORECASE | NORM_IGNOREKANATYPE | NORM_IGNORENONSPACE | NORM_IGNOREWIDTH | LCMAP_SORTKEY ) != dwFlags )
            {
            //  obsolete format, delete the index and ask for rebuild
            //
            DPRINT1( 0, "Deleting obsolete ABView index '%s'...\n", szIndexName );
            Call( JetDeleteIndex( sesid, tableid, szIndexName ) );
            *pfIndexMissing = TRUE;
            }
        }

    err = JET_errSuccess;

HandleError:
    if ( fRetrievedIdxList )
        {
        err = JetCloseTableWithErrUnhandled( sesid, idxlist.tableid, err );
        }

    return err;
    }

JET_ERR dbAddMissingAttrIndices(
    const   JET_SESID           sesid,
    const   JET_TABLEID         tableid,
    const   JET_TABLEID         tableidIdxRebuild,
    IN      JET_INDEXCREATE *   pIndexCreate,
    IN OUT  DWORD *             pcIndexCreate )
    {
    JET_ERR                     err;
    JET_COLUMNDEF               columndef;
    JET_COLUMNID                columnidIndexName;
    JET_COLUMNID                columnidAttrName;
    JET_COLUMNID                columnidType;

    const DWORD                 iretcolIndexName        = 0;
    const DWORD                 iretcolAttrName         = 1;
    const DWORD                 iretcolType             = 2;
    const DWORD                 cretcol                 = 3;
    JET_RETRIEVECOLUMN          rgretcol[3];
    CHAR                        szIndexName[JET_cbNameMost+1];
    CHAR                        szAttrName[JET_cbNameMost];
    CHAR                        chType;
    JET_INDEXID                 indexidT;
    BYTE                        rgbIndexDef[128];

    //  retrieve columnids for the columns in the AttributeIndexRebuild table
    //
    Call( JetGetTableColumnInfo(
                sesid,
                tableidIdxRebuild,
                g_szIdxRebuildColumnIndexName,
                &columndef,
                sizeof(columndef),
                JET_ColInfo ) );
    columnidIndexName = columndef.columnid;

    Call( JetGetTableColumnInfo(
                sesid,
                tableidIdxRebuild,
                g_szIdxRebuildColumnAttrName,
                &columndef,
                sizeof(columndef),
                JET_ColInfo ) );
    columnidAttrName = columndef.columnid;

    Call( JetGetTableColumnInfo(
                sesid,
                tableidIdxRebuild,
                g_szIdxRebuildColumnType,
                &columndef,
                sizeof(columndef),
                JET_ColInfo ) );
    columnidType = columndef.columnid;

    //  setup JET_RETRIEVECOLUMN structures
    //
    memset( rgretcol, 0, sizeof(rgretcol) );

    rgretcol[iretcolIndexName].columnid = columnidIndexName;
    rgretcol[iretcolIndexName].pvData = szIndexName;
    rgretcol[iretcolIndexName].cbData = JET_cbNameMost;
    rgretcol[iretcolIndexName].itagSequence = 1;

    rgretcol[iretcolAttrName].columnid = columnidAttrName;
    rgretcol[iretcolAttrName].pvData = szAttrName;
    rgretcol[iretcolAttrName].cbData = sizeof(szAttrName);
    rgretcol[iretcolAttrName].itagSequence = 1;

    rgretcol[iretcolType].columnid = columnidType;
    rgretcol[iretcolType].pvData = &chType;
    rgretcol[iretcolType].cbData = sizeof(chType);
    rgretcol[iretcolType].itagSequence = 1;

    //  scan AttributeIndexRebuild table and identify missing indexes
    //  that need to be recreated
    //
    err = JetMove( sesid, tableidIdxRebuild, JET_MoveFirst, NO_GRBIT );
    while ( JET_errNoCurrentRecord != err )
        {
        //  process error returned from JetMove
        //
        CheckErr( err );

        //  initialise type in case column is null
        //
        chType = 0;

        //  retrieve info for the current index
        //
        Call( JetRetrieveColumns( sesid, tableidIdxRebuild, rgretcol, cretcol ) );

        //  ensure index name is null-terminated
        //
        szIndexName[rgretcol[iretcolIndexName].cbActual] = 0;

        //  check index existence

        err = JetGetTableIndexInfo(
                        sesid,
                        tableid,
                        szIndexName,
                        &indexidT,
                        sizeof(indexidT),
                        JET_IdxInfoIndexId );
        if ( JET_errIndexNotFound == err )
            {
            //  the index is now missing, so recreate it
            //
            const CHAR *    szAttId     = szIndexName + strlen(SZATTINDEXPREFIX);
            INDEX_INFO      indexinfo;
            INDEX_INFO *    pindexinfoT;

            //  extract attribute syntax from the attribute name
            //
            indexinfo.syntax = *( szAttrName + strlen(SZATTINDEXKEYPREFIX) ) - CHATTSYNTAXPREFIX;

            switch ( chType )
                {
                case CHPDNTATTINDEX_PREFIX:
                    Assert( JET_errSuccess == rgretcol[iretcolType].err );
                    szAttId += 2;       //  adjust for PDNT prefix
                    sscanf( szAttId, "%08X", &indexinfo.attrType );

                    //  missing PDNT-attribute indices in IndicesToKeep
                    //  have already been scheduled to be rebuilt by
                    //  DBRecreateRequiredIndices()
                    //
                    pindexinfoT = PindexinfoAttInIndicesToKeep( indexinfo.attrType );
                    if ( NULL == pindexinfoT
                        || !( pindexinfoT->indexType & fPDNTATTINDEX ) )
                        {
                        DPRINT1( 0, "Need previously-existing PDNT-attribute index '%s'\n", szIndexName );

                        indexinfo.indexType = fPDNTATTINDEX;
                        DBAllocPDNTAttrIndexCreate(
                                &indexinfo,
                                szIndexName,
                                rgbIndexDef,
                                &pIndexCreate[(*pcIndexCreate)++] );
                        }
                    break;
                case CHTUPLEATTINDEX_PREFIX:
                    Assert( JET_errSuccess == rgretcol[iretcolType].err );
                    szAttId += 2;       //  adjust for tuple prefix
                    sscanf( szAttId, "%08X", &indexinfo.attrType );

                    //  IndicesToKeep doesn't enumerate tuple indexes
                    //  (even if it did, there's no code in
                    //  DBRecreateRequiredIndices() to rebuild
                    //  missing ones as there is attribute or PDNT-
                    //  attribute indices)
                    //
                    Assert( NULL == PindexinfoAttInIndicesToKeep( indexinfo.attrType )
                        || !( PindexinfoAttInIndicesToKeep( indexinfo.attrType )->indexType & fTUPLEINDEX ) );

                    DPRINT1( 0, "Need previously-existing tuple-attribute index '%s'\n", szIndexName );

                    indexinfo.indexType = fTUPLEINDEX;
                    DBAllocTupleAttrIndexCreate(
                            &indexinfo,
                            szIndexName,
                            rgbIndexDef,
                            &pIndexCreate[(*pcIndexCreate)++] );
                    break;
                default:
                    Assert( 0 == chType );
                    Assert( JET_wrnColumnNull == rgretcol[iretcolType].err );
                    sscanf( szAttId, "%08X", &indexinfo.attrType );

                    //  missing attribute indices in IndicesToKeep have
                    //  already been scheduled to be rebuilt by
                    //  DBRecreateRequiredIndices()
                    //
                    if ( !PindexinfoAttInIndicesToKeep( indexinfo.attrType ) )
                        {
                        DPRINT1( 0, "Need previously-existing attribute index '%s'\n", szIndexName );

                        indexinfo.indexType = fATTINDEX;
                        DBAllocAttrIndexCreate(
                                &indexinfo,
                                szIndexName,
                                rgbIndexDef,
                                &pIndexCreate[(*pcIndexCreate)++] );
                        }
                    break;
                }
            }
        else
            {
            CheckErr( err );
            }

        //  move to next index
        //
        err = JetMove( sesid, tableidIdxRebuild, JET_MoveNext, NO_GRBIT );
        }

    err = JET_errSuccess;

HandleError:
    return err;
    }

int DBRecreateRequiredIndices(JET_SESID sesid, JET_DBID dbid)
    {
    THSTATE *           pTHS                = pTHStls;
    JET_ERR             err                 = 0;
    ULONG               i                   = 0;
    ULONG               cIndexCreate        = 0;
    ULONG               cUnicodeIndexData   = 0;
    ULONG               cIndexCreateAlloc   = 0;
    JET_TABLEID         tblid               = JET_tableidNil;
    JET_INDEXCREATE *   pIndexCreate        = NULL;
    JET_UNICODEINDEX *  pUnicodeIndexData   = NULL;
    JET_TABLEID         tableidIdxRebuild   = JET_tableidNil;
    ULONG               cAttrIdxRebuild;
    JET_INDEXID         indexidT;

    char                szIndexName[MAX_INDEX_NAME];
    BYTE                rgbIndexDef[128];

    HKEY                hk                  = NULL;
    DWORD               cABViewIndices      = 0;
    char                szValueName[256];
    DWORD               dwLanguage          = 0;
    DWORD               dwValueNameSize     = sizeof(szValueName);
    DWORD               dwLanguageSize      = sizeof(dwLanguage);
    DWORD               dwType;

    Call( JetOpenTable( sesid, dbid, SZDATATABLE, NULL, 0, JET_bitTableDenyRead, &tblid ) );

    //  expand data table at runtime if necessary
    //
    err = dbCreateNewColumns( sesid, dbid, tblid, rgCreateDataColumns );
    if ( JET_errSuccess != err )
        {
        //  error already logged
        //
        goto HandleError;
        }

    //  delete existing datatable indexes at runtime if necessary
    //
    err = dbDeleteObsoleteFixedIndices( sesid, tblid );
    if ( JET_errSuccess != err )
        {
        //  error already logged
        //
        goto HandleError;
        }

    //  determine how many localised ABView indices we need
    //
    //  NOTE: it's possible that more ABView indices exist in the
    //  database than are actually enumerated in the registry, but
    //  such indices will be deleted by SCCacheSchema3().
    //
    // NTRAID#NTRAID-572862-2002/03/11-andygo:  SECURITY:  need to validate registry data used by DBInit
    // REVIEW:  we should limit the number of values retrieved to a sane value in case
    // REVIEW:  someone managed to create 1G values on this key
    if ( RegOpenKey( HKEY_LOCAL_MACHINE, DSA_LOCALE_SECTION, &hk )
        || RegQueryInfoKey( hk, NULL, NULL, NULL, NULL, NULL, NULL, &cABViewIndices, NULL, NULL, NULL, NULL ) )
        {
        DPRINT1(
            0,
            "%s section not found in registry. Localized MAPI indices will not be created ",
            DSA_LOCALE_SECTION );

        // Return no error, we still want to boot.
        }

    err = JetOpenTable( sesid, dbid, g_szIdxRebuildTable, NULL, 0, JET_bitTableDenyRead, &tableidIdxRebuild );
    if ( JET_errObjectNotFound == err )
        {
        //  this is the common case, because this table would only be present
        //  if attribute indexes might need to be rebuilt after an NT version upgrade
        //
        Assert( JET_tableidNil == tableidIdxRebuild );
        cAttrIdxRebuild = 0;
        }
    else
        {
        //  check for any other errors returned by the OpenTable
        //
        CheckErr( err );

        //  it's crucial to get an accurate count because we need it to
        //  properly size our array of JET_INDEXCREATE structures
        //
        Call( JetIndexRecordCount( sesid, tableidIdxRebuild, &cAttrIdxRebuild, 0 ) );
        }

    // Allocate space for JET_INDEXCREATE/JET_UNICODEINDEX structures
    // There can be at most two indices created per attribute in
    // IndicesToKeep Table, plus the fixed indices and the ABView indices
    // Only ABView indices may have variable Unicode settings - all other
    // indices use default settings

    cIndexCreateAlloc = cFixedIndices + cABViewIndices + cIndicesToKeep + cAttrIdxRebuild;
    pIndexCreate = THAllocEx( pTHS, cIndexCreateAlloc * sizeof(JET_INDEXCREATE) );
    pUnicodeIndexData = THAllocEx( pTHS, cABViewIndices * sizeof(JET_UNICODEINDEX) );


    // first fill up the structures for the FixedIndices

    for ( i = 0; i < cFixedIndices; i++ )
        {
        err = JetGetTableIndexInfo(
                        sesid,
                        tblid,
                        FixedIndices[i].szIndexName,
                        FixedIndices[i].pidx,
                        sizeof(JET_INDEXID),
                        JET_IdxInfoIndexId );
        if ( JET_errIndexNotFound == err )
            {
            DPRINT2( 0, "Need a fixed index '%s' (%d)\n", FixedIndices[i].szIndexName, err );
            DBAllocFixedIndexCreate(
                    FixedIndices + i,
                    &(pIndexCreate[cIndexCreate++]) );
            Assert( cIndexCreate <= cIndexCreateAlloc );
            }
        else
            {
            CheckErr( err );
            }
        }

    //  now do the ABView indexes
    //
    for ( i = 0; i < cABViewIndices; i++ )
        {
        //  WARNING: these params are IN/OUT,
        //  so must initialise accordingly
        //  on each loop iteration
        //
        dwValueNameSize = sizeof(szValueName);
        dwLanguageSize = sizeof(dwLanguage);

        // NTRAID#NTRAID-572862-2002/03/11-andygo:  SECURITY:  need to validate registry data used by DBInit
        // REVIEW:  we should validate that the type is REG_DWORD.  if it isn't then we should
        // REVIEW:  silently skip this language.  consider logging the fact that we skipped an
        // REVIEW:  entry
        if ( 0 != RegEnumValue(
                        hk,
                        i,
                        szValueName,
                        &dwValueNameSize,
                        NULL,
                        &dwType,
                        (LPBYTE)&dwLanguage,
                        &dwLanguageSize ) )
            {
            //  error encountered, silently skip this language
            //
            NULL;
            }
        else if ( !IsValidLocale( MAKELCID( dwLanguage, SORT_DEFAULT ),LCID_INSTALLED ) )
            {
            LogEvent(
                DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                DS_EVENT_SEV_MINIMAL,
                DIRLOG_BAD_LANGUAGE,
                szInsertHex(dwLanguage),
                szInsertSz(DSA_LOCALE_SECTION),
                NULL );
            }
        else
            {
            BOOL    fIndexMissing;

            sprintf( szIndexName, SZABVIEWINDEX"%08X", dwLanguage );

            err = dbDeleteObsoleteABViewIndex(
                            sesid,
                            tblid,
                            szIndexName,
                            &fIndexMissing );
            if ( JET_errSuccess != err )
                {
                //  error already logged
                //
                goto HandleError;
                }

            if ( fIndexMissing )
                {
                DPRINT1( 0, "Need ABView index '%s'\n", szIndexName );
                DBAllocABViewIndexCreate(
                       szIndexName,
                       dwLanguage,
                       &(pIndexCreate[cIndexCreate++]),
                       &(pUnicodeIndexData[cUnicodeIndexData++]) );
                Assert( cIndexCreate <= cIndexCreateAlloc );
                Assert( cUnicodeIndexData <= cABViewIndices );
                }
            }
        }

    // ok, now check for the indices in IndicesToKeep Table, and
    // create them if necessary. Do not check the last entry in the table,
    // it is just a sentinel for searches
    //
    for ( i = 0; i < cIndicesToKeep - 1; i++ )
        {
        if ( IndicesToKeep[i].indexType & fATTINDEX )
            {
            sprintf( szIndexName, SZATTINDEXPREFIX"%08X", IndicesToKeep[i].attrType );
            err = JetGetTableIndexInfo(
                            sesid,
                            tblid,
                            szIndexName,
                            &indexidT,
                            sizeof(indexidT),
                            JET_IdxInfoIndexId );
            if ( JET_errIndexNotFound == err )
                {
                DPRINT2( 0, "Need an attribute index '%s' (%d)\n", szIndexName, err );
                DBAllocAttrIndexCreate(
                        IndicesToKeep + i,
                        szIndexName,
                        rgbIndexDef,
                        &(pIndexCreate[cIndexCreate++]) );
                Assert( cIndexCreate <= cIndexCreateAlloc );
                }
            else
                {
                CheckErr( err );
                }
            }

        // Now the PDNT indexes, now a dummy since no att in IndicesToKeep
        // needs a PDNT index, but just in case someone adds some
        //
        // UNDONE: this is actually a dead code path because
        // there aren't any PDNT attribute indices in IndiciesToKeep
        //
        Assert( !( IndicesToKeep[i].indexType & fPDNTATTINDEX ) );
        if ( IndicesToKeep[i].indexType & fPDNTATTINDEX )
            {
            sprintf( szIndexName, SZATTINDEXPREFIX"%c_%08X", CHPDNTATTINDEX_PREFIX, IndicesToKeep[i].attrType );
            err = JetGetTableIndexInfo(
                            sesid,
                            tblid,
                            szIndexName,
                            &indexidT,
                            sizeof(indexidT),
                            JET_IdxInfoIndexId );
            if ( JET_errSuccess == err )
                {
                DPRINT2( 0, "Need a PDNT-attribute index '%s' (%d)\n", szIndexName, err );
                DBAllocPDNTAttrIndexCreate(
                        IndicesToKeep + i,
                        szIndexName,
                        rgbIndexDef,
                        &(pIndexCreate[cIndexCreate++]) );
                Assert( cIndexCreate <= cIndexCreateAlloc );
                }
            else
                {
                CheckErr( err );
                }
            }
        }


    //  now see if Jet deleted any attribute indices as
    //  part of NT upgrade, and if so, schedule the
    //  missing indices for re-creation
    //
    if ( cAttrIdxRebuild > 0 )
        {
        DPRINT1( 0, "Checking whether %d previously-existing attribute indices still exist...\n", cAttrIdxRebuild );
        Assert( JET_tableidNil != tableidIdxRebuild );
        err = dbAddMissingAttrIndices(
                        sesid,
                        tblid,
                        tableidIdxRebuild,
                        pIndexCreate,
                        &cIndexCreate );
        Assert( cIndexCreate <= cIndexCreateAlloc );
        if ( JET_errSuccess != err )
            {
            //  error already logged
            //
            goto HandleError;
            }
        }

    //  If we're going to rebuild indices anyways or if Jet deleted
    //  some indices at AttachDatabase time, then we'll also spend
    //  time spinning through all indices and delete any attribute
    //  indices that still use a trailing DNT key segment to increase
    //  key diversity as this is no longer necessary for good perf
    //  since ESENT automatically includes the primary key (also the
    //  DNT) into all secondary index keys for precisely this reason.
    //
    //  WARNING: must do this AFTER enumerating missing indices/
    //  If we were to do it before, the index would get counted
    //  as a missing index and scheduled for recreation twice
    //
    if ( cIndexCreate > 0 || cAttrIdxRebuild > 0 )
        {
        DPRINT( 0, "Checking for obsolete attribute indices...\n" );
        err = dbDeleteObsoleteAttrIndices(
                            sesid,
                            tblid,
                            pIndexCreate,
                            &cIndexCreate,
                            cIndexCreateAlloc );
        Assert( cIndexCreate <= cIndexCreateAlloc );
        if ( JET_errSuccess != err )
            {
            //  error already logged
            //
            goto HandleError;
            }
        }

    // Now actually create the indices.


    Assert( cIndexCreate <= cIndexCreateAlloc );
    if ( cIndexCreate > 0 )
        {
        DPRINT1( 0, "Starting batch rebuild of %d Datatable indices...\n", cIndexCreate );
        err = dbCreateIndexBatch( sesid, tblid, cIndexCreate, pIndexCreate );
        if ( JET_errSuccess != err )
            {
            goto HandleError;
            }
        }

    if ( JET_tableidNil != tableidIdxRebuild )
        {
        //  all indices have been successfully rebuilt after an NT version upgrade,
        //  so remove this table (must trap errors because if these fail, the
        //  continuing presence of this table may confuse subsequent inits)
        //
        Call( JetCloseTable( sesid, tableidIdxRebuild ) );
        tableidIdxRebuild = JET_tableidNil;

        Call( JetDeleteTable( sesid, dbid, g_szIdxRebuildTable ) );
        }

    // Gather index hint for fixed indices
    //
    for ( i = 0; i < cFixedIndices; i++ )
        {
        Call( JetGetTableIndexInfo(
                        sesid,
                        tblid,
                        FixedIndices[i].szIndexName,
                        FixedIndices[i].pidx,
                        sizeof(JET_INDEXID),
                        JET_IdxInfoIndexId ) );
        }

HandleError:
    if ( NULL != hk )
        {
        RegCloseKey( hk );
        }

    if ( JET_tableidNil != tableidIdxRebuild )
        {
		//	on success, this table should already be closed
		//
        Assert( JET_errSuccess != err );
        err = JetCloseTableWithErrUnhandled( sesid, tableidIdxRebuild, err );
        }

    if ( JET_tableidNil != tblid )
        {
        err = JetCloseTableWithErrUnhandled( sesid, tblid, err );
        }

    // free whatever we can without going into too much trouble

    THFreeEx( pTHS, pIndexCreate );
    THFreeEx( pTHS, pUnicodeIndexData );

    DPRINT1( 0, "Rebuild of necessary Datatable indices completed with error %d...\n", err );

    return err;
    }


// REVIEW:  jetInstance should be jInstance throughout DBSetDatabaseSystemParameters

// NTRAID#NTRAID-573032-2002/03/11-andygo:  DBSetDatabaseSystemParameters has no error checking
// REVIEW:  there is very little or no error checking on sys and JET calls in DBSetDatabaseSystemParameters
void
DBSetDatabaseSystemParameters(JET_INSTANCE *jInstance, unsigned fInitAdvice)
{
    ULONG cSystemThreads = 4;   // permanent server threads. Task queue etc.
    ULONG cServerThreads = 50;
    ULONG ulMaxSessionPerThread = 3;
    ULONG ulMaxBuffers = 0x7fffffff;  //  essentially, no limit
    ULONG ulMaxLogBuffers;
    ULONG ulLogFlushThreshold;
    ULONG ulMaxTables;
    ULONG ulSpareBuckets = 100; // bucket in addition to 2 per thread
    ULONG ulStartBufferThreshold;
    ULONG ulStopBufferThreshold;
    ULONG ulLogFlushPeriod;
    ULONG ulPageSize = JET_PAGE_SIZE;               // jet page size

    // AndyGo 12/5/01:need five max cursors per base table (one for the table,
    // one for associated LV tree, one for current secondary index, one for Jet
    // internal search/update operations, and one to be safe)

    ULONG ulMaxCursorsPerBaseTable = 5;
    ULONG ulMaxBaseTablePerDBPOS = 6;
    ULONG ulMaxCursorsPerTempTable = 1;
    ULONG ulMaxTempTablePerDBPOS = 1;
    ULONG ulNumDBPOSPerSession = 1;  // can be more than this sometimes
    ULONG ulMaxCursorsPerSession = ulNumDBPOSPerSession *
                                  (ulMaxCursorsPerBaseTable * ulMaxBaseTablePerDBPOS +
                                   ulMaxCursorsPerTempTable * ulMaxTempTablePerDBPOS);

    JET_ERR err = JET_errSuccess;
    JET_SESID sessid = (JET_SESID) 0;
    MEMORYSTATUSEX mstat = {sizeof(MEMORYSTATUSEX)};
    SYSTEM_INFO sysinfo;
    DWORD i;
    ULONGLONG ullTmp;

    const ULONG ulLogFileSize = JET_LOG_FILE_SIZE;  // Never, ever, change this.
    // As of now (1/18/99), Jet cannot handle a change in log file size
    // on an installed system.  That is, you could create an entirely new
    // database with any log file size you want, but if you ever change
    // it later then Jet will AV during initialization.  We used to let
    // people set the log file size via a registry key, but apparently no one
    // ever did, as when we finally tried it it blew up.  We've now chosen
    // a good default file size (10M), and we're stuck with it forever,
    // as no installed server can ever choose a different value, unless
    // JET changes logging mechanisms.

    GetSystemInfo(&sysinfo);
    GlobalMemoryStatusEx(&mstat);

    // set the following global JET params.  it is OK if they fail as long as
    // the other instance has set them to something that we can tolerate

    // We must have 8K pages.

    err = JetSetSystemParameter(&jetInstance,
                                sessid,
                                JET_paramDatabasePageSize,
                                ulPageSize,
                                NULL);
    if (err != JET_errSuccess) {
        ULONG_PTR ulPageSizeActual;
        err = JetGetSystemParameter(jetInstance,
                                    sessid,
                                    JET_paramDatabasePageSize,
                                    &ulPageSizeActual,
                                    NULL,
                                    0);
        if (err != JET_errSuccess || ulPageSizeActual != ulPageSize) {
            // REVIEW:  we don't handle this error but we know that because the DS
            // REVIEW:  uses a pre-created db, we will fail at attach time if this
            // REVIEW:  parameter is set incorrectly and log the reason then
            DPRINT(0, "FATAL ERROR:  Database page size mismatch between DSA and other JET instances in process");
        }
    }

    //
    // Do event log caching if the event log is not turned on
    // This enables the system to start if the event log has been
    // disabled. The value of the parameter is the size of the cache in bytes.
    #define JET_EVENTLOG_CACHE_SIZE  100000

    err = JetSetSystemParameter(&jetInstance,
                                sessid,
                                JET_paramEventLogCache,
                                JET_EVENTLOG_CACHE_SIZE,
                                NULL);
    if (err != JET_errSuccess) {
        // we can live with this
    }

    // create a new instance now that we have set the global parameters

    err = JetCreateInstance(&jetInstance, "NTDSA");
    if (err != JET_errSuccess) {
        // REVIEW:  we don't handle this error but we know that if we cannot
        // REVIEW:  create an instance then JetInit will fail later and log the
        // REVIEW:  reason then
        DPRINT(0, "FATAL ERROR:  new JET instance could not be created to host the DSA");
    } else {
        gfNeedJetShutdown = TRUE;
    }

    // Set required common database system parameters first
    //
    DBSetRequiredDatabaseSystemParameters (jInstance);

    // Have Jet log to the Directory Service log using a source value
    // defined by the DS.

    for ( i = 0; i < cEventSourceMappings; i++ )
    {
        if ( DIRNO_ISAM == rEventSourceMappings[i].dirNo )
        {
            JetSetSystemParameter(
                            &jetInstance,
                            sessid,
                            JET_paramEventSourceKey,
                            0,
                            rEventSourceMappings[i].pszEventSource);
            break;
        }
    }

    // Assert we found DIRNO_ISAM and registered it.
    Assert(i < cEventSourceMappings);



    // the setting of the following Jet Parameters is
    // done in DBSetRequiredDatabaseSystemParameters

    // 1. Set the default info for unicode indices
    // 2. Ask for 8K pages.
    // 3. Indicate that Jet may nuke old, incompatible log files
    //   if and only if there was a clean shut down.
    // 4. Tell Jet that it's ok for it to check for (and later delete) indices
    //   that have been corrupted by NT upgrades.
    // 5. Get relevant DSA registry parameters
    // 6. how to die
    // 7. event logging parameters
    // 8. log file size
    // 9. circular logging


    /* Set up global session limit, based on the number of threads */
    gcMaxJetSessions = ulMaxSessionPerThread *
      (
       ulMaxCalls                         // max RPC threads
       + cSystemThreads                   // internal worker threads
       + 4 * sysinfo.dwNumberOfProcessors // max LDAP threads
       );


    // Max Sessions (i.e., DBPOSes)
    JetSetSystemParameter(&jetInstance,
        sessid,
        JET_paramMaxSessions,
        gcMaxJetSessions,
        NULL);


    //  max buffers
    if (GetConfigParam(
            MAX_BUFFERS,
            &ulMaxBuffers,
            sizeof(ulMaxBuffers))) {
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_BASIC,
            DIRLOG_CANT_FIND_REG_PARM_DEFAULT,
            szInsertSz(MAX_BUFFERS),
            szInsertUL(ulMaxBuffers),
            NULL);
    } else {
        ulMaxBuffers = max(ulMaxBuffers, 100);
        ulMaxBuffers = min(ulMaxBuffers, 0x7fffffff);
    }

    JetSetSystemParameter(&jetInstance,
                          sessid,
                          JET_paramCacheSizeMax,
                          ulMaxBuffers,
                          NULL);

    //  max log buffers
    if (GetConfigParam(
            MAX_LOG_BUFFERS,
            &ulMaxLogBuffers,
            sizeof(ulMaxLogBuffers)))
    {
        // From AndyGo, 7/14/98: "Set to maximum desired log cache memory/512b
        // This number should be at least 256 on a large system.  This should
        // be set high engouh so that the performance counter .Database /
        // Log Record Stalls / sec. is almost always 0."
        // DS: we use the larger of 256 (== 128kb) or (0.1% of RAM * # procs),
        // on the theory that the more processors, the faster we can make
        // updates and hence burn through log files.
        ulMaxLogBuffers = max(256,
                              (sysinfo.dwNumberOfProcessors *
                               (ULONG)(mstat.ullTotalPhys / (512*1024))));
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_VERBOSE,
            DIRLOG_CANT_FIND_REG_PARM_DEFAULT,
            szInsertSz(MAX_LOG_BUFFERS),
            szInsertUL(ulMaxLogBuffers),
            NULL);
    }
    // Note that the log buffer size must be ten sectors less than the log
    // file size, with the added wart that size is in kb, and buffers is
    // in 512b sectors.
    ulMaxLogBuffers = min(ulMaxLogBuffers, ulLogFileSize*2 - 10);
    JetSetSystemParameter(&jetInstance,
                          sessid,
                          JET_paramLogBuffers,
                          ulMaxLogBuffers,
                          NULL);


    // Andygo 7/14/98: Set to max( min(256, ulMaxBuffers * 1%), 16), use
    // 10% for very high update rates such as defrag
    // DS: we use 10% for our initial install (dcpromo)
    if (GetConfigParam(
            BUFFER_FLUSH_START,
            &ulStartBufferThreshold,
            sizeof(ulStartBufferThreshold)))
    {
        ulStartBufferThreshold = max(min(256, fInitAdvice ? ulMaxBuffers / 10 : ulMaxBuffers / 100),  16);
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_VERBOSE,
            DIRLOG_CANT_FIND_REG_PARM_DEFAULT,
            szInsertSz(BUFFER_FLUSH_START),
            szInsertUL(ulStartBufferThreshold),
            NULL);
    }
    JetSetSystemParameter(&jetInstance,
                          sessid,
                          JET_paramStartFlushThreshold,
                          ulStartBufferThreshold,
                          NULL);


    // AndyGo 7/14/98: Set to max( min(512, ulMaxBuffers * 2%), 32), use
    // 20% for very high update rates such as defrag
    // DS: we use 20% for our initial install (dcpromo)
    if (GetConfigParam(
            BUFFER_FLUSH_STOP,
            &ulStopBufferThreshold,
            sizeof(ulStopBufferThreshold)))
    {
        ulStopBufferThreshold = max(min(512, fInitAdvice ? ulMaxBuffers / 5 : ulMaxBuffers / 50), 32);
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_VERBOSE,
            DIRLOG_CANT_FIND_REG_PARM_DEFAULT,
            szInsertSz(BUFFER_FLUSH_STOP),
            szInsertUL(ulStopBufferThreshold),
            NULL);
    }
    JetSetSystemParameter(&jetInstance,
                          sessid,
                          JET_paramStopFlushThreshold,
                          ulStopBufferThreshold,
                          NULL);

    // set both thresholds again in case there is another instance running and
    // our thresholds were clipped
    JetSetSystemParameter(&jetInstance,
                          sessid,
                          JET_paramStartFlushThreshold,
                          ulStartBufferThreshold,
                          NULL);
    JetSetSystemParameter(&jetInstance,
                          sessid,
                          JET_paramStopFlushThreshold,
                          ulStopBufferThreshold,
                          NULL);


    // max tables - Currently no reason to expose this
    // In Jet600, JET_paramMaxOpenTableIndexes is removed. It is merged with
    // JET_paramMaxOpenTables. So if you used to set JET_paramMaxOpenIndexes
    // to be 2000 and and JET_paramMaxOpenTables to be 1000, then for new Jet,
    // you need to set JET_paramMaxOpenTables to 3000.

    // AndyGo 7/14/98: You need one for each open table index, plus one for
    // each open table with no indexes, plus one for each table with long
    // column data, plus a few more.

    // NOTE: the number of maxTables is calculated in scache.c
    // and stored in the registry setting, only if it exceeds the default
    // number of 500

    if (GetConfigParam(
            DB_MAX_OPEN_TABLES,
            &ulMaxTables,
            sizeof(ulMaxTables)))
    {
        ulMaxTables = 500;

        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_VERBOSE,
            DIRLOG_CANT_FIND_REG_PARM_DEFAULT,
            szInsertSz(DB_MAX_OPEN_TABLES),
            szInsertUL(ulMaxTables),
            NULL);
    }

    if (ulMaxTables < 500) {
        DPRINT1 (1, "Found MaxTables: %d. Too low. Using Default of 500.\n", ulMaxTables);
        ulMaxTables = 500;
    }

    // NTRAID#NTRAID-572862-2002/03/11-andygo:  SECURITY:  need to validate registry data used by DBInit
    // REVIEW:  we should probably put a ceiling on DB_MAX_OPEN_TABLES to prevent
    // REVIEW:  insane VA consumption by JET

    JetSetSystemParameter(&jetInstance,
        sessid,
        JET_paramMaxOpenTables,
        ulMaxTables * 2,
        NULL);

    // open tables indexes - Currently no reason to expose this
    // See comment on JET_paramMaxOpenTables.

    // Max temporary tables
    // as soon as you do an index intersection, you need a peak of 17
    // (one for the result table and 16 for the input ranges) plus one
    // for every other AND optimized by an index intersection for a
    // given filter.  if we assume that we want to be able to support
    // one, two-way intersection per filter then we need at least
    // three TTs per session
    JetSetSystemParameter(&jetInstance,
        sessid,
        JET_paramMaxTemporaryTables,
        3 * gcMaxJetSessions,
        NULL);


    // Version buckets.  The units are 16k "buckets", and we get to set
    // two separate values.  The first is our preferred value, and is read
    // from the registry.  JET will try to maintain the pool of buckets at
    // around this level.  The second parameter is the absolute maximum
    // number of buckets which JET will never exceed.  We set that based on
    // the amount of physical memory in the machine (unless the preferred
    // setting was already higher than that!).  This very large value should
    // ensure that no transaction will ever fail because of version store
    // exhaustion.
    //
    // N.B. Jet will try to reserve jet_paramMaxVerPages in contiguous memory
    // causing out of memory problems.  We should only need a maximum of a
    // quarter of the available physical memory.
    //
    // N.B. Version pages are 16K each.
    //
    // N.B. ESE98 now processes version store cleanup tasks asynchronously,
    // so the version store cleanup thread should no longer get bogged
    // down. Moreover, Jet defaults preferred ver pages to 90% of the
    // max, so let's just stick with that and don't bother setting
    // JET_paramPreferredVerPages anymore [jliem - 10/10/01]

    // NTRAID#NTRAID-572862-2002/03/11-andygo:  SECURITY:  need to validate registry data used by DBInit
    // REVIEW:  we should probably put a ceiling on SPARE_BUCKETS to prevent
    // REVIEW:  insane VA consumption by JET
    if (GetConfigParam(SPARE_BUCKETS,
                       &ulSpareBuckets,
                       sizeof(ulSpareBuckets))) {
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                 DS_EVENT_SEV_VERBOSE,
                 DIRLOG_CANT_FIND_REG_PARM_DEFAULT,
                 szInsertSz(SPARE_BUCKETS),
                 szInsertUL((2 * gcMaxJetSessions) + ulSpareBuckets),
                 NULL);
    }

    ullTmp = mstat.ullTotalPhys;    // total memory in system
    ullTmp /= 4;                    // limit to 1/4 of total memory in system
    if ( ullTmp > 100 * 1024 * 1024 ) {
        // Limit version store to 100M since process address space is only 2G.
        ullTmp = 100 * 1024 * 1024;
    }
    // Convert to version store page count.
    ullTmp /= (16*1024);            // N.B. - ullTmp fits in a DWORD now.
    Assert(ullTmp <= 0xffffffff);

    if (ulSpareBuckets < (ULONG) ullTmp) {
        ulSpareBuckets = (ULONG) ullTmp;
    }

    JetSetSystemParameter(&jetInstance,
                          sessid,
                          JET_paramMaxVerPages,
                          ((2 * gcMaxJetSessions) + ulSpareBuckets) * sizeof(void*) / 4,
                          NULL);

    // From AndyGo 7/14/98: You need one cursor per concurrent B-Tree
    // navigation in the JET API.  Guessing high will only waste address space.
    JetSetSystemParameter(&jetInstance,
        sessid,
        JET_paramMaxCursors,
        (gcMaxJetSessions * ulMaxCursorsPerSession),
        NULL);

    // Set the tuple index parameters.  Have to do this since once an index is
    // created these parameters can't be changed for that index.  Thus changing
    // the minimum tuple length has the potential to cause failures in the future.
    JetSetSystemParameter(&jetInstance,
        sessid,
        JET_paramIndexTuplesLengthMin,
        DB_TUPLES_LEN_MIN,
        NULL);
    JetSetSystemParameter(&jetInstance,
        sessid,
        JET_paramIndexTuplesLengthMax,
        DB_TUPLES_LEN_MAX,
        NULL);
    JetSetSystemParameter(&jetInstance,
        sessid,
        JET_paramIndexTuplesToIndexMax,
        DB_TUPLES_TO_INDEX_MAX,
        NULL);

    // Disable versioned temp tables.  this makes TTs faster but disables the
    // ability to rollback an insert into a materialized TT
    JetSetSystemParameter(&jetInstance,
        sessid,
        JET_paramEnableTempTableVersioning,
        0,
        NULL );

    // Set the initial checkpoint depth to 20MB.  we must do this so that if we
    // fail during DCPromo and then try again then we do not suffer from the
    // really small checkpoint depth we set in DBPrepareEnd to accelerate the
    // shutdown of the server
    JetSetSystemParameter(&jetInstance,
        sessid,
        JET_paramCheckpointDepthMax,
        20 * 1024 * 1024,
        NULL );

}/* DBSetDatabaseSystemParameters */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dblayer\dbindex.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dbindex.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module DBLayer functions to deal with indices.  Functions include thos
    to set indices, seek in indeices, create index ranges, compare position of
    two object in an index, etc.

Author:

    Tim Williams (timwi) 25-Apr-1996

Revision History:

--*/
#include <NTDSpch.h>
#pragma  hdrstop

#include <limits.h>

#include <dsjet.h>

#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <dsatools.h>

#include <mdcodes.h>
#include <dsevent.h>

#include <dsexcept.h>
#include "objids.h"	/* Contains hard-coded Att-ids and Class-ids */
#include "debug.h"	/* standard debugging header */
#define DEBSUB     "DBINDEX:"   /* define the subsystem for debugging */

#include "dbintrnl.h"

#include <fileno.h>
#define  FILENO FILENO_DBINDEX


DB_ERR
DBMove (
       DBPOS * pDB,
       BOOL UseSortTable,
       LONG Distance
       )
/*++

Routine Description:

    Wrapper around DBMoveEx

Arguments:

Return Value:

--*/
{
    return
        DBMoveEx(
            pDB,
            (UseSortTable?pDB->JetSortTbl:pDB->JetObjTbl),
            Distance );
}


DB_ERR
DBMoveEx (
       DBPOS * pDB,
       JET_TABLEID Cursor,
       LONG Distance
       )
/*++

Routine Description:

    Moves in a data base table.  Currently, this is a very thin wrapper around
    JetMove.

Arguments:

    pDB - the DBLayer Postion block to move in.

    Cursor - which table to use

    Distance - the distance to move.  Special cases of 0x7fffffff (DB_MoveLast)
    and 0x00000000 (DB_MoveFirst) are used.

Return Value:

    0 if no error, an error code otherwise (currently the bare Jet error).

--*/
{
    DWORD cbActual;
    DB_ERR err;

    Assert(VALID_DBPOS(pDB));

    if(!Cursor) {
        return DB_ERR_NO_SORT_TABLE;
    }

    err = JetMoveEx(pDB->JetSessID,
                    Cursor,
                    Distance,
                    0);

    if ( (Cursor == pDB->JetObjTbl) && (err == JET_errSuccess) ) {
        // Get the DNT and PDNT.
        dbMakeCurrent(pDB, NULL);
    }

    return err;
}

DB_ERR
DBMovePartial (
       DBPOS * pDB,
       LONG Distance
       )
/*++

Routine Description:

    Moves in a data base table.  Currently, this is a very thin wrapper around
    JetMove. This version does not call dbMakeCurrent. Is mainly used from MAPI.

Arguments:

    pDB - the DBLayer Postion block to move in.

    Distance - the distance to move.  Special cases of 0x7fffffff (DB_MoveLast)
    and 0x00000000 (DB_MoveFirst) are used.

Return Value:

    0 if no error, an error code otherwise (currently the bare Jet error).

--*/
{
    DB_ERR err;

    Assert(VALID_DBPOS(pDB));

    err = JetMoveEx(pDB->JetSessID,
                    pDB->JetObjTbl,
                    Distance,
                    0);

    return err;
}

DB_ERR
DBOpenSortTable (
        DBPOS *pDB,
        ULONG SortLocale,
        DWORD flags,
        ATTCACHE *pAC
        )
/*++

Routine Description:

    Opens a temporary table to be used for sorting.  The sort order and
    data type to be sorted are specified in flags.

Arguments:

    pDB - The DBLayer Postion block to attach this sort table to.

    SortLocale - the Locale that the data is to be sorted in.

    flags - flags describing sort orders.  Legal flags are:
     DB_SORT_DESCENDING -> sort the data in descending order.
     DB_SORT_ASCENDING -> (DEFAULT) sort the data in ascending order.
     DB_SORT_FORWARDONLY -> request a forward only sort (faster)

    pAC - attcache of attribute to sort on. NULL if no sort is necessary

Return Value:

    FALSE if table creation failed, the table handle otherwise.

--*/
{
    JET_COLUMNDEF tempTableColumns[2];
    DB_ERR        err;
    JET_GRBIT     grbit;
    DWORD         index;

    Assert(VALID_DBPOS(pDB));

    if(pDB->JetSortTbl) {
        // We already have a sort table.  Bail.
        return !0;
    }

    if(pAC) {
        // This is a sort table, not just a list of DNTs
        tempTableColumns[0].cbStruct = sizeof(tempTableColumns[0]);
        tempTableColumns[0].columnid = 0;
        tempTableColumns[0].langid = LANGIDFROMLCID(SortLocale);
        tempTableColumns[0].cp = CP_WINUNICODE;
        tempTableColumns[0].cbMax = 0;
        tempTableColumns[0].grbit = JET_bitColumnFixed | JET_bitColumnTTKey;

        // OK, get the coltyp from the attcache
        switch(pAC->syntax) {
        case SYNTAX_CASE_STRING_TYPE:
        case SYNTAX_NOCASE_STRING_TYPE:
        case SYNTAX_PRINT_CASE_STRING_TYPE:
        case SYNTAX_NUMERIC_STRING_TYPE:
        case SYNTAX_BOOLEAN_TYPE:
        case SYNTAX_INTEGER_TYPE:
        case SYNTAX_OCTET_STRING_TYPE:
        case SYNTAX_TIME_TYPE:
        case SYNTAX_UNICODE_TYPE:
        case SYNTAX_ADDRESS_TYPE:
        case SYNTAX_I8_TYPE:
        case SYNTAX_SID_TYPE:
            // We support sorting over these types
            tempTableColumns[0].coltyp = syntax_jet[pAC->syntax].coltype;

            // Because DBInsertSortTable always truncates to 240 bytes and
            // because LV types force materialization and we may not want to
            // use a materialized sort, transform LV types into their non-LV
            // equivalents
            if (tempTableColumns[0].coltyp == JET_coltypLongBinary) {
                tempTableColumns[0].coltyp = JET_coltypBinary;
            }
            else if (tempTableColumns[0].coltyp == JET_coltypLongText) {
                tempTableColumns[0].coltyp = JET_coltypText;
            }
            // If we are using a variable length type then set its max size at
            // 240 bytes and set it to variable length so we don't overflow key
            // space and cause duplicate removal AND so that we don't eat gobs
            // of space unnecessarily
            if (    tempTableColumns[0].coltyp == JET_coltypBinary ||
                    tempTableColumns[0].coltyp == JET_coltypText ) {
                tempTableColumns[0].cbMax = 240;
                tempTableColumns[0].grbit = JET_bitColumnTTKey;
            }
            break;
        default:
            return !0;
        }

        if(flags & DB_SORT_DESCENDING) {
            tempTableColumns[0].grbit |= JET_bitColumnTTDescending;
        }

        index = 1;
    }
    else {
        index = 0;
    }

    tempTableColumns[index].cbStruct = sizeof(tempTableColumns[index]);
    tempTableColumns[index].columnid = 0;
    tempTableColumns[index].coltyp = JET_coltypLong;
    tempTableColumns[index].langid = LANGIDFROMLCID(SortLocale);
    tempTableColumns[index].cp = CP_WINUNICODE;
    tempTableColumns[index].cbMax = 0;
    tempTableColumns[index].grbit = JET_bitColumnFixed | JET_bitColumnTTKey;

    index++;

    grbit = JET_bitTTSortNullsHigh | JET_bitTTUnique;
    if (!(flags & DB_SORT_FORWARDONLY)) {
        grbit = grbit | JET_bitTTForceMaterialization | JET_bitTTIndexed;
    }

    if(err = JetOpenTempTable2(pDB->JetSessID,
                               tempTableColumns,
                               index,
                               LANGIDFROMLCID(SortLocale),
                               grbit,
                               &pDB->JetSortTbl,
                               pDB->SortColumns)) {

        // something went wrong.
        pDB->JetSortTbl = 0;
        pDB->SortColumns[0] = 0;
        pDB->SortColumns[1] = 0;
        pDB->SortColumns[2] = 0;
    }

    pDB->SortColumns[2] = 0;
    if(pAC) {
        // There is a sort column other than DNT.  Switch the values in
        // SortColumns so that pDB->SortColumns[0] is ALWAYS the columnid of the
        // DNT column and pDB->SortColumns[1] is ALWAYS 0 OR the columnid of the
        // data column, and pDB->SortColumns[2] is ALWAYS 0;
        index = pDB->SortColumns[0];
        pDB->SortColumns[0] = pDB->SortColumns[1];
        pDB->SortColumns[1] = index;
    }
    else {
        pDB->SortColumns[1] = 0;
    }

    #if DBG
        if (err == 0) {
            pDB->numTempTablesOpened++;
        }
    #endif

    return err;
}

DB_ERR
dbCloseTempTables (
        DBPOS *pDB
        )
{
    KEY_INDEX *pTemp, *pIndex;


    pIndex = pDB->Key.pIndex;

    while(pIndex) {
        pTemp = pIndex->pNext;

        if (pIndex->bIsIntersection) {
            Assert (pIndex->tblIntersection);
            JetCloseTable (pDB->JetSessID, pIndex->tblIntersection );

            pIndex->bIsIntersection = 0;
            pIndex->tblIntersection = 0;
            #if DBG
            pDB->numTempTablesOpened--;
            #endif
        }

        Assert (pIndex->tblIntersection == 0);

        pIndex = pTemp;
    }

    return 0;
}


DB_ERR
DBCloseSortTable (
        DBPOS *pDB
        )
/*++

Routine Description:

    Close a temporary table.  Tolerates a null table handle and returns success

Arguments:

    pDB - the DBLayer Position block which holds the sort table to close.

Return Values:
    0 if the table closed ok, an error otherwise (currently returns the bare
    Jet error code).

--*/
{
    DB_ERR err;

    Assert(VALID_DBPOS(pDB));

    if(pDB->JetSortTbl) {
        err = JetCloseTable(pDB->JetSessID, pDB->JetSortTbl);
        #if DBG
        Assert (err == 0);
        pDB->numTempTablesOpened--;
        #endif
    }
    else {
        err = 0;
    }

    pDB->JetSortTbl =  pDB->SortColumns[0] = pDB->SortColumns[1] =
        pDB->SortColumns[2] = 0;

    return err;
}

DB_ERR
DBInsertSortTable (
        DBPOS *pDB,
        CHAR * TextBuff,
        DWORD cb,
        DWORD DNT
        )
/*++

Routine Description:

    Insert a value into a temporary table.

Arguments:

    pDB - the DBLayer Postion block from which to get the sort table to insert
        into.

    TextBuff - the data to be inserted.

    cb - the count of bytes of data to be inserted.

    DNT - The DNT associated with this data.

Return Values:

    0 if the new new row is added to the table, an error otherwise (currently
    returns the bare Jet error code).

--*/
{
    DB_ERR      err;
    JET_SETINFO setinfo;

    Assert(VALID_DBPOS(pDB));

    setinfo.cbStruct = sizeof(setinfo);
    setinfo.ibLongValue = 0;
    setinfo.itagSequence = 0;

    if(!pDB->JetSortTbl) {
        // No one has opened a sort table.  Bail.
        return DB_ERR_NO_SORT_TABLE;
    }
    if(TextBuff && (pDB->SortColumns[1]==0)) {
        // They gave us some bytes to put in the sort column, but we don't
        // apparantly have a sort column.
        return DB_ERR_UNKNOWN_ERROR;
    }

    // Shove the DNT and display name into the sort table;
    err = JetPrepareUpdate(pDB->JetSessID,pDB->JetSortTbl,JET_prepInsert);
    if(err != DB_success) {
        return DBErrFromJetErr(err);
    }

    if(TextBuff) {
        // Use no more than 240 bytes of the first column.  This is so that
        // the DNT is used in the key to kill duplicates.  This is safe to
        // do since the first column is only used for sorting, never for
        // reading back, and jet already refuses to sort correctly when the key
        // (which is truncated to CB_MAK_KEY bytes) is too long (a limitation of
        // JET). We're just shortening the number of characters we correctly
        // sort by a little.

        err = JetSetColumn(pDB->JetSessID,
                           pDB->JetSortTbl,
                           pDB->SortColumns[1],
                           TextBuff,
                           min(cb,240),
                           0,
                           &setinfo);
        if(err != DB_success)   {
            JetPrepareUpdate(pDB->JetSessID,pDB->JetSortTbl,JET_prepCancel);
            return DBErrFromJetErr(err);
        }
    }

    err = JetSetColumn(pDB->JetSessID,
                       pDB->JetSortTbl,
                       pDB->SortColumns[0],
                       &DNT,
                       sizeof(DWORD),
                       0,
                       &setinfo);
    if(err != DB_success) {
        JetPrepareUpdate(pDB->JetSessID,pDB->JetSortTbl,JET_prepCancel);
        return DBErrFromJetErr(err);
    }

    err = JetUpdate(pDB->JetSessID,
                    pDB->JetSortTbl,
                    NULL,
                    0,
                    NULL);
    if(err != DB_success)  {
        JetPrepareUpdate(pDB->JetSessID,pDB->JetSortTbl,JET_prepCancel);
        return DBErrFromJetErr(err);
    }

    return DB_success;
}

DB_ERR
DBDeleteFromSortTable (
        DBPOS *pDB
        )
/*++

Routine Description:

    Deletes the current row from a temporary table.

Arguments:

    pDB - the DBLayer Postion block from which to get the sort table to delete
        from.

Return Values:

    0 if the row is deleted from the table, an error otherwise (currently
    returns the bare Jet error code).

--*/
{
    DB_ERR      err;
    Assert(VALID_DBPOS(pDB));

    if(!pDB->JetSortTbl) {
        // No one has opened a sort table.  Bail.
        return DB_ERR_NO_SORT_TABLE;
    }
    err = JetDelete(pDB->JetSessID, pDB->JetSortTbl);
    return err;
}

DB_ERR
DBSetFractionalPosition (
        DBPOS *pDB,
        DWORD Numerator,
        DWORD Denominator
        )
/*++

Routine Description:

    Sets the fractional position in a certain table in whatever the current
    index is.

Arguments:

    pDB - the DBLayer position block to move around in.

    Numerator - the Numerator of the fractional position.

    Denominator - the Denominator of the fractional position.

Return Values:
    0 if all went well, an error otherwise (currently returns the bare
    Jet error code).

--*/
{
    JET_RECPOS  RecPos;
    DWORD       err;

    Assert(VALID_DBPOS(pDB));

    RecPos.cbStruct = sizeof(JET_RECPOS );
    RecPos.centriesLT = Numerator;
    RecPos.centriesTotal = Denominator;
    RecPos.centriesInRange = 1;

    err = JetGotoPosition(pDB->JetSessID, pDB->JetObjTbl, &RecPos);

    // Reset DNT and PDNT.
    if(err == JET_errSuccess) {
        // Get the DNT and PDNT.  Get them from disk, since they are not likely
        // to be in the index.
        dbMakeCurrent(pDB, NULL);
    }

    return err;
}

void
DBGetFractionalPositionEx (
        DBPOS * pDB,
        JET_TABLEID Cursor,
        DWORD * Numerator,
        DWORD * Denominator
        )
/*++

Routine Description:

    Gets the fractional position in a certain table in whatever the current
    index is.  This routine may measure any table.

Arguments:

    pDB - The DBLayer positon block to use.

    Cursor - Which table to measure

    Numerator - the Numerator of the fractional position.

    Denominator - the Denominator of the fractional position.

Return Values:
    None.

--*/
{
    DB_ERR     err;
    JET_RECPOS RecPos;

    Assert(VALID_DBPOS(pDB));

    err = JetGetRecordPosition(pDB->JetSessID, Cursor, &RecPos,
                               sizeof(JET_RECPOS));
    switch(err) {
    case DB_success:
        *Numerator = RecPos.centriesLT;
        *Denominator = RecPos.centriesTotal;
        break;
    default:
        // Just ignore errors.
        *Numerator = 0;
        *Denominator = 1;
        break;
    }
    return;
}

void
DBGetFractionalPosition (
        DBPOS * pDB,
        DWORD * Numerator,
        DWORD * Denominator
        )
/*++

Routine Description:

    Gets the fractional position in a certain table in whatever the current
    index is.

    This routine implicitly uses the object table.

Arguments:

    pDB - The DBLayer positon block to use.

    Numerator - the Numerator of the fractional position.

    Denominator - the Denominator of the fractional position.

Return Values:
    None.

--*/
{
   DBGetFractionalPositionEx( pDB, pDB->JetObjTbl, Numerator, Denominator );
}


DB_ERR
DBSetCurrentIndex (
        DBPOS *pDB,
        eIndexId indexid,
        ATTCACHE * pAC,
        BOOL MaintainCurrency
        )
/*++

Routine Description:

    Sets the Object Table to the appropriate index.  The index is either
    specified as a string name, or an AttCache * pointing to the attribute we
    want indexed, but not both (which is an error condition).

Arguments:

    pDB - The DBLayer positon block to use.

    indexid - an enumerated constant for the index to set to.

    pAC - pointer to an attcache for the attribute we want and index on.

    MaintainCurrency - Do we want to maintain the current object as the current
        object after the index change?

Return Values:

    0 if all went well, an error code otherwise (currently returns the bare jet
    error code).

--*/
{
    DB_ERR err;
    char * pszIndexName = NULL;
    char szIndexName[MAX_INDEX_NAME];
    JET_INDEXID *pidx;
    JET_TABLEID cursor;

    Assert(VALID_DBPOS(pDB));

    Assert((!indexid && pAC) || (indexid && !pAC));

    cursor = pDB->JetObjTbl;

    if (pAC) {
        pszIndexName = pAC->pszIndex;
        pidx = pAC->pidxIndex;
    }
    else {
        switch (indexid) {
          case Idx_Proxy:
            pszIndexName = SZPROXYINDEX;
            pidx = &idxProxy;
            break;

          case Idx_MapiDN:
            pszIndexName = SZMAPIDNINDEX;
            pidx = &idxMapiDN;
            break;

          case Idx_Dnt:
            pszIndexName = SZDNTINDEX;
            pidx = &idxDnt;
            break;

          case Idx_Pdnt:
            pszIndexName = SZPDNTINDEX;
            pidx = &idxPdnt;
            break;

          case Idx_Rdn:
            pszIndexName = SZRDNINDEX;
            pidx = &idxRdn;
            break;

          case Idx_DraUsn:
            pszIndexName = SZDRAUSNINDEX;
            pidx = &idxDraUsn;
            break;

          case Idx_DsaUsn:
            pszIndexName = SZDSAUSNINDEX;
            pidx = &idxDsaUsn;
            break;

          case Idx_ABView:
            // in case of the ABView index, index hints
            // don't work since there might be several
            // active locales. we use the locale from the
            // thread state to construct the indexName
            sprintf(szIndexName,"%s%08X",SZABVIEWINDEX,
                      LANGIDFROMLCID(pDB->pTHS->dwLcid));
            pidx = NULL;
            pszIndexName = szIndexName;
            break;

          case Idx_Phantom:
            pszIndexName = SZPHANTOMINDEX;
            pidx = &idxPhantom;
            break;

          case Idx_Sid:
            pszIndexName = SZSIDINDEX;
            pidx = &idxSid;
            break;

          case Idx_Del:
            pszIndexName = SZDELTIMEINDEX;
            pidx = &idxDel;
            break;

          case Idx_NcAccTypeName:
            pszIndexName = SZ_NC_ACCTYPE_NAME_INDEX;
            pidx = &idxNcAccTypeName;
            break;

          case Idx_NcAccTypeSid:
            pszIndexName = SZ_NC_ACCTYPE_SID_INDEX;
            pidx = &idxNcAccTypeSid;
            break;

          case Idx_LinkDraUsn:
              pszIndexName = SZLINKDRAUSNINDEX;
              pidx = &idxLinkDraUsn;
              cursor = pDB->JetLinkTbl;
              break;

          case Idx_LinkDel:
              pszIndexName = SZLINKDELINDEX;
              pidx = &idxLinkDel;
              cursor = pDB->JetLinkTbl;
              break;

          case Idx_DraUsnCritical:
            pszIndexName = SZDRAUSNCRITICALINDEX;
            pidx = &idxDraUsnCritical;
            break;
 
          case Idx_LinkAttrUsn:
            pszIndexName = SZLINKATTRUSNINDEX;
            pidx = &idxLinkAttrUsn;
            cursor = pDB->JetLinkTbl;
            break;

          case Idx_Clean:
            pszIndexName = SZCLEANINDEX;
            pidx = &idxClean;
            break;

          case Idx_InvocationId:
            pszIndexName = SZINVOCIDINDEX;
            pidx = &idxInvocationId;
            break;

          case Idx_ObjectGuid:
            pszIndexName = SZGUIDINDEX;
            pidx = &idxGuid;
            break;

	  case Idx_NcGuid:
	    pszIndexName = SZNCGUIDINDEX;
	    pidx = &idxNcGuid;
	    break;

          default:
            Assert(FALSE);
            pidx = NULL;    //to avoid C4701
        }
    }

    if (!pszIndexName) {
        return DB_ERR_BAD_INDEX;
    }


    err = JetSetCurrentIndex4Warnings(pDB->JetSessID,
                                      cursor,
                                      pszIndexName,
                                      pidx,
                                      (MaintainCurrency?JET_bitNoMove:JET_bitMoveFirst));
    if ( (cursor == pDB->JetObjTbl) &&
         (!MaintainCurrency) &&
         (err == JET_errSuccess) ) {
        pDB->PDNT = pDB->DNT = 0;
    }

    return err;
}

#define MAX_DISPNAME   256
#define CBMAX_DISPNAME (MAX_DISPNAME * sizeof(WCHAR))


DB_ERR
DBSetLocalizedIndex(
        DBPOS *pDB,
        eIndexId IndexId,
        unsigned long ulLangId,
        INDEX_VALUE *pIV,
        BOOL MaintainCurrency)
/*++

Routine Description:

    Sets the Object Table to the appropriate index.  The index is either
    specified as a string name, or an AttCache * pointing to the attribute we
    want indexed, but not both (which is an error condition).

Arguments:

    pDB - The DBLayer positon block to use.

    indexid - an enumerated constant for the index to set to.

    ulLangId -  the locale of the language that we need to set the index to

    MaintainCurrency - Do we want to maintain the current object as the current
        object after the index change?

Return Values:

    0 if all went well,
    DB_ERR_BAD_INDEX - if passed in a bad index, or index does not exist
    JET error code - otherwise

--*/
{
    char  pszLocalizedIndex[128];
    BYTE  pbPrimaryBookmark[DB_CB_MAX_KEY];
    DWORD cbPrimaryBookmark;
    BYTE  pbSecondaryKey[DB_CB_MAX_KEY];
    DWORD cbSecondaryKey;
    BYTE  pbNotUsed[DB_CB_MAX_KEY];
    DWORD cbNotUsed;
    DWORD err;
    BYTE  DispNameBuff[CBMAX_DISPNAME];
    DWORD cbDispNameBuff;

    if (IndexId != Idx_ABView) {
        return DB_ERR_BAD_INDEX;
    }

    if (MaintainCurrency) {

        // Find out what entry we are positioned on currently so that we can
        // efficiently reposition on the new index.

        err = JetGetSecondaryIndexBookmarkEx(pDB->JetSessID,
                                             pDB->JetObjTbl,
                                             pbNotUsed,
                                             sizeof(pbNotUsed),
                                             &cbNotUsed,
                                             pbPrimaryBookmark,
                                             sizeof(pbPrimaryBookmark),
                                             &cbPrimaryBookmark);
        if (err == JET_errNoCurrentIndex) {
            // we must be on the primary index (rare), so just get the key for
            // our current position.  this key completely describes our current
            // position on this index because the primary index must be unique
            JetRetrieveKeyEx(pDB->JetSessID,
                             pDB->JetObjTbl,
                             pbPrimaryBookmark,
                             sizeof(pbPrimaryBookmark),
                             &cbPrimaryBookmark,
                             NO_GRBIT);
        } else {
            Assert( JET_errSuccess == err );
        }
    }

    //
    // Actually attempt to change to the required index.
    //
    sprintf(pszLocalizedIndex,
            "%s%08X",
            SZABVIEWINDEX,
            ulLangId);

    err = JetSetCurrentIndex2Warnings(pDB->JetSessID,
                                       pDB->JetObjTbl,
                                       pszLocalizedIndex,
                                       (MaintainCurrency?JET_bitNoMove:JET_bitMoveFirst));

    if (err == JET_errIndexNotFound) {
        return DB_ERR_BAD_INDEX;
    } else if (!MaintainCurrency) {
        return err;
    }

    //
    // Succeeded.  Now reposition if necessary.
    //

    // We might be in the wrong container.  See if the object exists in the
    // correct container.  Remember, we are on the correct object, so the
    // display name is correct.

    // Build a key.  We use the ContainerID passed in and the display name from
    // the key of the object we're sitting on.
    err = DBGetSingleValueFromIndex (pDB,
                               ATT_DISPLAY_NAME,
                               DispNameBuff,
                               sizeof(DispNameBuff),
                               &cbDispNameBuff);

    if (JET_errSuccess != err) {
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
    }

    //
    // Add the container ID portion of the key.
    //
    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetObjTbl,
                 pIV->pvData,
                 pIV->cbData,
                 JET_bitNewKey);

    //
    // And the displayName segment.
    //
    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetObjTbl,
                 DispNameBuff,
                 cbDispNameBuff,
                 NO_GRBIT);

    JetRetrieveKeyEx(pDB->JetSessID,
                     pDB->JetObjTbl,
                     pbSecondaryKey,
                     sizeof(pbSecondaryKey),
                     &cbSecondaryKey,
                     JET_bitRetrieveCopy);

    JetGotoSecondaryIndexBookmarkEx(pDB->JetSessID,
                                    pDB->JetObjTbl,
                                    pbSecondaryKey,
                                    cbSecondaryKey,
                                    pbPrimaryBookmark,
                                    cbPrimaryBookmark,
                                    NO_GRBIT);

    DBMakeCurrent(pDB);

    Assert( JET_errSuccess == err );
    return err;
}


DB_ERR
DBSeek (
       DBPOS *pDB,
       INDEX_VALUE *pIV,
       DWORD nVals,
       DWORD SeekType
      )
/*++

Routine Description:

    Wrapper around DBSeekEx

Arguments:

Return Values:

--*/
{
    return DBSeekEx( pDB, pDB->JetObjTbl, pIV, nVals, SeekType );
}


DB_ERR
DBSeekEx (
       DBPOS *pDB,
       JET_TABLEID Cursor,
       INDEX_VALUE *pIV,
       DWORD nVals,
       DWORD SeekType
      )
/*++

  !!!!!!!!! WARNING !!!!!!!!! WARNING !!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!

    This routine is unreliable for keys that exceed Jets maximum key length.
    If you are using a key that might be too long, remember that Jet truncates
    keys (currently to 255 bytes), and therefore two unicodes strings that
    differ after the 128th Character are considered to be equal!  Multipart
    keys are even worse, since it's the total of the normalized key that is
    limited,not each individual part.  YOU HAVE BEEN WARNED

  !!!!!!!!! WARNING !!!!!!!!! WARNING !!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!

Routine Description:

    Seeks in the object table to the data described in the key.  Accepts a
    flag, SeekType, which specifies the kind of seek to do.

Arguments:

    pDB - The DBLayer positon block to use.

    pIV - the values to search for.

    nVals - the number of values that we are to use.

    SeekType - >=, >, ==, <=, or <

Return Values:

    0 if all went well, an error code otherwise (currently returns the bare jet
    error code).

--*/
{
    DB_ERR      err;
    DWORD       i;
    ULONG       grbit = JET_bitNewKey;

    Assert(VALID_DBPOS(pDB));

    for (i=0; i<nVals; i++) {
        // Succeeds or excepts
        JetMakeKeyEx(pDB->JetSessID,
                     Cursor,
                     pIV[i].pvData,
                     pIV[i].cbData,
                     grbit);

        grbit &= ~JET_bitNewKey;
    }

    switch(SeekType) {
    case DB_SeekGT:
        grbit = JET_bitSeekGT;
        break;

    case DB_SeekGE:
        grbit = JET_bitSeekGE;
        break;

    case DB_SeekEQ:
        grbit = JET_bitSeekEQ;
        break;

    case DB_SeekLE:
        grbit = JET_bitSeekLE;
        break;

    case DB_SeekLT:
        grbit = JET_bitSeekLT;
        break;

    default:
        return !0;
    }


    err = JetSeekEx(pDB->JetSessID, Cursor, grbit);

    if(err == JET_wrnSeekNotEqual) {
        // exact search should never find a seeknotequal
        Assert((SeekType != DB_SeekEQ));
        err = DB_success;
    }

    if ( (Cursor == pDB->JetObjTbl) && (err == JET_errSuccess) ) {
        dbMakeCurrent(pDB, NULL);
    }
    return err;
}


DB_ERR
dbGetSingleValueInternal (
        DBPOS *pDB,
        JET_COLUMNID colID,
        void * pvData,
        DWORD cbData,
        DWORD *pSizeRead,
        DWORD  grbit
        )
/*++

Routine Description:

    Gets the first value of the given column from the current object in the
    database.

Arguments:

    pDB - The DBLayer positon block to use.

    colId - the Jet database column.

    pvData - buffer to place the data in.

    cbData - size of the buffer.

    pSizeRead - a pointer to a DWORD to return the size of the data actually
    read, or NULL if the caller doesn't care how much was read.

Return Values:

    0 if all went well, an error code otherwise

--*/
{
    DWORD        cbActual;
    JET_ERR      err;

    Assert(VALID_DBPOS(pDB));

    err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                    pDB->JetObjTbl,
                                    colID,
                                    pvData,
                                    cbData,
                                    &cbActual,
                                    grbit,
                                    NULL);

    if(pSizeRead)
        *pSizeRead = cbActual;

    switch(err) {
    case JET_errColumnNotFound:
    case JET_wrnColumnNull:
        return DB_ERR_NO_VALUE;
        break;

    case JET_wrnBufferTruncated:
        return DB_ERR_VALUE_TRUNCATED;
        break;

    case JET_errSuccess:
        return 0;

    default:
        return err;
    }


}
DB_ERR
DBGetSingleValue (
        DBPOS *pDB,
        ATTRTYP Att,
        void * pvData,
        DWORD cbData,
        DWORD *pSizeRead
        )
/*++

Routine Description:

    Gets the first value of the given column from the current object in the
    database.  Does this by looking up the appropriate column id and then
    calling dbGetSingleValueInternal

Arguments:

    pDB - The DBLayer positon block to use.

    Att - the attribute to look up.

    pvData - buffer to place the data in.

    cbData - size of the buffer.

    pSizeRead - a pointer to a DWORD to return the size of the data actually
    read, or NULL if the caller doesn't care how much was read.

Return Values:

    0 if all went well, an error code otherwise

--*/
{
    DWORD        cbActual;
    JET_ERR      err;
    ATTCACHE     *pAC;
    JET_COLUMNID colID;


    Assert(VALID_DBPOS(pDB));

    switch(Att) {
    case FIXED_ATT_ANCESTORS:
        colID = ancestorsid;
        break;
    case FIXED_ATT_DNT:
        colID = dntid;
        break;
    case FIXED_ATT_NCDNT:
        colID = ncdntid;
        break;
    case FIXED_ATT_OBJ:
        colID = objid;
        break;
    case FIXED_ATT_PDNT:
        colID = pdntid;
        break;
    case FIXED_ATT_REFCOUNT:
        colID = cntid;
        break;
    case FIXED_ATT_AB_REFCOUNT:
        colID = abcntid;
        break;
    case FIXED_ATT_RDN_TYPE:
        colID = rdntypid;
        break;
    case FIXED_ATT_NEEDS_CLEANING:
        colID = cleanid;
        break;
    default:
        if(!(pAC = SCGetAttById(pDB->pTHS, Att))) {
            if (pSizeRead) {
                *pSizeRead = 0;
            }
            return (DB_ERR_NO_VALUE);
        }
        colID = pAC->jColid;
        break;
    }

    return dbGetSingleValueInternal(pDB, colID, pvData, cbData, pSizeRead,
                                    pDB->JetRetrieveBits);
}

DB_ERR
DBGetSingleValueFromIndex (
        DBPOS *pDB,
        ATTRTYP Att,
        void * pvData,
        DWORD cbData,
        DWORD *pSizeRead
        )
/*++

Routine Description:

    Gets the first value of the given column from the current object in the
    database.  Does this by looking up the appropriate column id and then
    calling dbGetSingleValueInternal with the grbit JET_bitRetrieveFromIndex,

Arguments:

    pDB - The DBLayer positon block to use.

    Att - the attribute to look up.

    pvData - buffer to place the data in.

    cbData - size of the buffer.

    pSizeRead - a pointer to a DWORD to return the size of the data actually
    read, or NULL if the caller doesn't care how much was read.

Return Values:

    0 if all went well, an error code otherwise

--*/
{
    DWORD        cbActual;
    JET_ERR      err;
    ATTCACHE     *pAC;
    JET_COLUMNID colID;


    Assert(VALID_DBPOS(pDB));

    switch(Att) {
    case FIXED_ATT_ANCESTORS:
        colID = ancestorsid;
        break;
    case FIXED_ATT_DNT:
        colID = dntid;
        break;
    case FIXED_ATT_NCDNT:
        colID = ncdntid;
        break;
    case FIXED_ATT_OBJ:
        colID = objid;
        break;
    case FIXED_ATT_PDNT:
        colID = pdntid;
        break;
    case FIXED_ATT_REFCOUNT:
        colID = cntid;
        break;
    case FIXED_ATT_AB_REFCOUNT:
        colID = abcntid;
        break;
    case FIXED_ATT_RDN_TYPE:
        colID = rdntypid;
        break;
    case FIXED_ATT_NEEDS_CLEANING:
        colID = cleanid;
        break;
    default:
        if(!(pAC = SCGetAttById(pDB->pTHS, Att))) {
            return (DB_ERR_NO_VALUE);
        }
        colID = pAC->jColid;
        break;
    }

    return dbGetSingleValueInternal(pDB, colID, pvData, cbData, pSizeRead,
                                    JET_bitRetrieveFromIndex);
}
BOOL
DBHasValues_AC (
        DBPOS *pDB,
        ATTCACHE *pAC
        )
{
    DWORD        cbActual;
    DWORD        temp;
    JET_ERR      err;


    Assert(VALID_DBPOS(pDB));

    if(pAC->ulLinkID) {
        ULONG ulLinkBase= MakeLinkBase(pAC->ulLinkID);
        PUCHAR szIndex;
        JET_INDEXID * pindexid;
        ULONG ulObjectDnt, ulRecLinkBase, cb;
        JET_COLUMNID objectdntid;

        // First, are we looking at a link or backlink attribute?
        if (FIsBacklink(pAC->ulLinkID)) {
            szIndex = SZBACKLINKINDEX;
            pindexid = &idxBackLink;
            objectdntid = backlinkdntid;
        }
        else if ( pDB->fScopeLegacyLinks ) {
            szIndex = SZLINKLEGACYINDEX;
            pindexid = &idxLinkLegacy;
            objectdntid = linkdntid;
        }
        else {
            szIndex = SZLINKINDEX;
            pindexid = &idxLink;
            objectdntid = linkdntid;
        }

        // Set up the index and search for a match.
        JetSetCurrentIndex4Success(pDB->JetSessID,
                                  pDB->JetLinkTbl,
                                  szIndex,
                                  pindexid,
                                  JET_bitMoveFirst);

        JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                     &(pDB->DNT), sizeof(pDB->DNT), JET_bitNewKey);
        JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                     &ulLinkBase, sizeof(ulLinkBase), 0);

        // seek
        if (((err = JetSeekEx(pDB->JetSessID, pDB->JetLinkTbl, JET_bitSeekGE))
             !=  JET_errSuccess) &&
            (err != JET_wrnRecordFoundGreater)) {
            return FALSE;
        }

        // test to verify that we found a qualifying record
        JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl, objectdntid,
                                 &ulObjectDnt, sizeof(ulObjectDnt), &cb, 0,
                                  NULL);

        JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl, linkbaseid,
                                 &ulRecLinkBase, sizeof(ulRecLinkBase), &cb, 0,
                                  NULL);

        if ((ulObjectDnt != pDB->DNT) || (ulLinkBase != ulRecLinkBase)) {
            return FALSE;
        }

        // found a valid record
        return TRUE;

    }
    else {
        switch(JetRetrieveColumnWarnings(pDB->JetSessID,
                                         pDB->JetObjTbl,
                                         pAC->jColid,
                                         &temp,
                                         0,
                                         &cbActual,
                                         pDB->JetRetrieveBits,
                                         NULL)) {

        case JET_errColumnNotFound:
        case JET_wrnColumnNull:
            return FALSE;
            break;

        case JET_wrnBufferTruncated:
        case JET_errSuccess:
            return TRUE;
            break;
        default:
            return FALSE;
        }
    }

}
BOOL
DBHasValues (
        DBPOS *pDB,
        ATTRTYP Att
        )
{
    DWORD        cbActual;
    DWORD        temp;
    JET_ERR      err;
    ATTCACHE     *pAC;
    JET_COLUMNID colID;

    Assert(VALID_DBPOS(pDB));

    if(Att < FIRST_FIXED_ATT) {
        // Not a fixed column, so it better have an attcache.
        if(!(pAC = SCGetAttById(pDB->pTHS, Att))) {
            return FALSE;
        }
        return DBHasValues_AC(pDB, pAC);
    }

    switch (Att) {
    case FIXED_ATT_ANCESTORS:
        colID = ancestorsid;
        break;
    case FIXED_ATT_DNT:
        colID = dntid;
        break;
    case FIXED_ATT_NCDNT:
        colID = ncdntid;
        break;
    case FIXED_ATT_OBJ:
        colID = objid;
        break;
    case FIXED_ATT_PDNT:
        colID = pdntid;
        break;
    case FIXED_ATT_REFCOUNT:
        colID = cntid;
        break;
    case FIXED_ATT_AB_REFCOUNT:
        colID = abcntid;
        break;
    case FIXED_ATT_RDN_TYPE:
        colID = rdntypid;
        break;
    case FIXED_ATT_NEEDS_CLEANING:
        colID = cleanid;
        break;
    default:
        return FALSE;
    }


    switch(JetRetrieveColumnWarnings(pDB->JetSessID,
                                     pDB->JetObjTbl,
                                     colID,
                                     &temp,
                                     0,
                                     &cbActual,
                                     pDB->JetRetrieveBits,
                                     NULL)) {

    case JET_errColumnNotFound:
    case JET_wrnColumnNull:
        return FALSE;
        break;

    case JET_wrnBufferTruncated:
    case JET_errSuccess:
        return TRUE;
        break;
    default:
        return FALSE;
    }

}

DB_ERR
DBGetDNTSortTable (
        DBPOS *pDB,
        DWORD *pvData
        )
/*++

Routine Description:

    Gets the first value of the given column from the current object in the
    database.  If UseSortTable, then use the sort table, otherwise use the
    object table.

Arguments:

    pDB - The DBLayer positon block to use.

    pvData - buffer to place the data in.

Return Values:

    0 if all went well, an error code otherwise

--*/
{
    DWORD       cbActual, colID;
    JET_ERR     err;

    Assert(VALID_DBPOS(pDB));

    if(!pDB->JetSortTbl) {
        return DB_ERR_NO_SORT_TABLE;
    }

    err = JetRetrieveColumnWarnings(
            pDB->JetSessID,
            pDB->JetSortTbl,
            pDB->SortColumns[0],
            pvData,
            sizeof(DWORD),
            &cbActual,
            0,
            NULL);

    switch(err) {
    case JET_errColumnNotFound:
    case JET_wrnColumnNull:
        return DB_ERR_NO_VALUE;
        break;

    case JET_wrnBufferTruncated:
        return DB_ERR_VALUE_TRUNCATED;
        break;

    case JET_errSuccess:
        return 0;

    default:
        return err;
    }


}

DWORD
DBCompareABViewDNTs (
        DBPOS *pDB,
        DWORD lcid,
        DWORD DNT1,
        DWORD DNT2,
        LONG *pResult
        )
/*++

Routine Description:

    Compares the relative position of the two DNTs as if they were in an ABView
    index.  Returns < 0 if DNT1 < DNT2, 0 if DNT1==DNT2, and >0 if DNT1 > DNT2.

Arguments:

    pDB - The DBLayer positon block to use.

    lcid - the locale id of the ABView index in question.

    DNT1 - the first DNT.

    DNT2 - the second DNT.

    pResult - the result of the comparison

Return Values:

    0 if the comparison was done, an error code otherwise.

--*/
{
    ULONG   cb1, cb2;
    WCHAR    wchDispName1[MAX_DISPNAME], wchDispName2[MAX_DISPNAME];
    JET_ERR err;
    int     cmpResult;

    Assert(VALID_DBPOS(pDB));

    //
    // Get the displayName from the first DNT.
    //
    if(err = DBFindDNT(pDB, DNT1))
        return err;

    err = DBGetSingleValue(pDB,
                           ATT_DISPLAY_NAME,
                           wchDispName1,
                           sizeof(wchDispName1),
                           &cb1);

    if (err) {
        return err;
    }

    //
    // And second . . .
    //
    if(err = DBFindDNT(pDB, DNT2))
        return err;

    err = DBGetSingleValue(pDB,
                           ATT_DISPLAY_NAME,
                           wchDispName2,
                           sizeof(wchDispName2),
                           &cb2);

    if (err) {
        return err;
    }

    //
    // do the compare
    //
    cmpResult = CompareStringW(lcid,
                         LOCALE_SENSITIVE_COMPARE_FLAGS,
                         wchDispName1,
                         cb1/sizeof(WCHAR),
                         wchDispName2,
                         cb2/sizeof(WCHAR));


    if (0 == cmpResult) {
        return 1;
    }

    //
    // Translate the result and get outa here. . .
    //
    *pResult = (cmpResult - CSTR_EQUAL);

    return 0;
}

DWORD
DBSetIndexRangeEx (
        DBPOS *pDB,
        JET_TABLEID Cursor,
        INDEX_VALUE *pIV,
        DWORD nVals,
        BOOL fSubstring
        )
/*++

Routine Description:

    Sets an index range on the current index using the target bytes given.  An
    index range sets an artificial end of index after any value which fails to
    satisfy the key used to create the range.  A DBMove which would land on the
    artificial end of index acts the same as if it had walked of the real end of
    the index.

Arguments:

    pDB - The DBLayer positon block to use.

    Cursor - Which table to use

    pTarget - the data to use for the index range key.

    cbTarget - the size of the data.

    fSubstring - Substring match. If true, this index range is intended to be
         over a string data column and does an initial substring match key.

Return Values:

    0 if the comparison was done, an error code otherwise.

--*/
{
    JET_ERR err;
    DWORD   i;
    DWORD grbits = fSubstring ? JET_bitStrLimit : 0;

    Assert(VALID_DBPOS(pDB));

    for (i=0; i<nVals; i++) {
        err = JetMakeKey(pDB->JetSessID,
                         Cursor,
                         pIV[i].pvData,
                         pIV[i].cbData,
                         i ? 0 : (grbits | JET_bitNewKey));

        if(err != DB_success)
            return err;
    }

    return JetSetIndexRangeEx(pDB->JetSessID,
                              Cursor,
                              (JET_bitRangeUpperLimit |
                               JET_bitRangeInclusive ));

}

DWORD
DBSetIndexRange (
        DBPOS *pDB,
        INDEX_VALUE *pIV,
        DWORD nVals
        )
/*++

Routine Description:

    Sets an index range on the current index using the target bytes given.  An
    index range sets an artificial end of index after any value which fails to
    satisfy the key used to create the range.  A DBMove which would land on the
    artificial end of index acts the same as if it had walked of the real end of
    the index.  Note that this index range is intended to be over a string data
    column and does an initial substring match key.

Arguments:

    pDB - The DBLayer positon block to use.

    pTarget - the data to use for the index range key.

    cbTarget - the size of the data.

Return Values:

    0 if the comparison was done, an error code otherwise.

--*/
{
    return DBSetIndexRangeEx( pDB, pDB->JetObjTbl, pIV, nVals, TRUE /*substring*/ );
}

void
DBGetIndexSizeEx(
        DBPOS *pDB,
        JET_TABLEID Cursor,
        ULONG *pSize,
        BOOL  fGetRoughEstimate
        )
/*++

Routine Description:

    Returns the number of objects in the current index.

Arguments:

    pDB - The DBLayer positon block to use.

    Cursor - Which table to search

    pSize - the place to return the size of the index.

    fGetRoughEstimate - use the (very) approximate algorithm. If FALSE, beware
                        of the ineffectiveness of the exact call -- it scans the
                        whole index, which might be both time- and
                        version-store-consuming.

Return Values:

    None.

--*/
{
    JET_ERR err;

    Assert(VALID_DBPOS(pDB));
    Assert(pSize);

    *pSize = 0;

    if (fGetRoughEstimate) {
        DWORD       BeginNum, BeginDenom;
        DWORD       EndNum, EndDenom;
        DWORD       Denom;
        JET_RECPOS  RecPos;

        if (JetMoveEx(pDB->JetSessID, Cursor, JET_MoveFirst, 0)) {
            return;
        }
        JetGetRecordPositionEx(pDB->JetSessID, Cursor, &RecPos, sizeof(RecPos));
        BeginNum = RecPos.centriesLT;
        BeginDenom = RecPos.centriesTotal;

        if (JetMoveEx(pDB->JetSessID, Cursor, JET_MoveLast, 0)) {
            return;
        }
        JetGetRecordPositionEx(pDB->JetSessID, Cursor, &RecPos, sizeof(RecPos));
        EndNum = RecPos.centriesLT;
        EndDenom = RecPos.centriesTotal;

        // Normalize the fractions of the fractional position to the average of
        // the two denominators.
        Denom = (BeginDenom + EndDenom) / 2;
        EndNum = MulDiv(EndNum, Denom - 1, EndDenom - 1) + 1;
        BeginNum = MulDiv(BeginNum, Denom - 1, BeginDenom - 1) + 1;

        if (BeginDenom == 1 || EndDenom == 1) {
            *pSize = 1;
        } else if (EndNum >= BeginNum) {
            *pSize = EndNum - BeginNum + 1;
        }
    }
    else {
        err = JetIndexRecordCountEx(pDB->JetSessID, Cursor, pSize, ULONG_MAX);
        if ( (err != JET_errSuccess) &&
             (err != JET_errNoCurrentRecord) ) {
            DPRINT1( 0, "JetIndexRecountCountEx failed, err = %d\n", err );
        }

        // Check that this API is not abused
        Assert( ((*pSize) < (32 * 1024)) && "Perf warning, this api doesn't scale!" );
    }
}


void
DBGetBookMark (
        DBPOS *pDB,
        DBBOOKMARK *pBookMark
    )

/*++

Routine Description:

Record the position in the object table.

Arguments:

    pDB -
    pBookMark - pointer to updated bookmark structure

Return Value:

    None

--*/

{
    DBGetBookMarkEx( pDB, pDB->JetObjTbl, pBookMark );
} /* DBGetBookMark  */


void
DBGotoBookMark (
        DBPOS *pDB,
        DBBOOKMARK BookMark
        )

/*++

Routine Description:

Goto bookmark position in object table

Arguments:

    pDB -
    BookMark - passed by value for historical reasons

Return Value:

    None

--*/

{
    DBGotoBookMarkEx( pDB, pDB->JetObjTbl, &BookMark );

} /* DBGotoBookMark  */

void
DBGetBookMarkEx (
        DBPOS *pDB,
        JET_TABLEID Cursor,
        DBBOOKMARK *pBookMark)
/*
   Description:
      A very thin wrapper around JetGetBookMark.  Allocates the memory for the
      bookmark and drops it into a structure passed in.

   Free using DbFreeBookMark() when done

   Parameters
      pDB - DBPOS to use
      Cursor - which table to use
      pBookMark - pointer to already existing structure to fill in the bookmark
      data.

   Returns:
      No return code, but the bookmark structure is filled in when we return.

*/
{
    BOOL  fSecondary = TRUE;
    DWORD cbPrimaryBookMark = 0;
    DWORD cbSecondaryBookMark = 0;
    DWORD err;

    pBookMark->pvPrimaryBookMark   = NULL;
    pBookMark->cbPrimaryBookMark   = 0;
    pBookMark->pvSecondaryBookMark = NULL;
    pBookMark->cbSecondaryBookMark = 0;

    err = JetGetSecondaryIndexBookmark(pDB->JetSessID,
                                       Cursor,
                                       NULL,
                                       0,
                                       &cbSecondaryBookMark,
                                       NULL,
                                       0,
                                       &cbPrimaryBookMark,
                                       NO_GRBIT);

    if (err == JET_errNoCurrentIndex) {
        // we must be on the primary index (rare), so just get the key for
        // our current position.  this key completely describes our current
        // position on this index because the primary index must be unique
        fSecondary = FALSE;
        err = JetGetBookmark(pDB->JetSessID,
                             Cursor,
                             NULL,
                             0,
                             &cbPrimaryBookMark);
    }
    if (err != JET_errBufferTooSmall) {
        // This shouldn't happen.
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
    }

    pBookMark->pvPrimaryBookMark = THAllocEx(pDB->pTHS, cbPrimaryBookMark);
    pBookMark->cbPrimaryBookMark = cbPrimaryBookMark;

    if (fSecondary) {
        pBookMark->pvSecondaryBookMark = THAllocEx(pDB->pTHS, cbSecondaryBookMark);
        pBookMark->cbSecondaryBookMark = cbSecondaryBookMark;

        err = JetGetSecondaryIndexBookmarkEx(pDB->JetSessID,
                                             Cursor,
                                             pBookMark->pvSecondaryBookMark,
                                             cbSecondaryBookMark,
                                             &cbSecondaryBookMark,
                                             pBookMark->pvPrimaryBookMark,
                                             cbPrimaryBookMark,
                                             &cbPrimaryBookMark);
        //  shouldn't get JET_errNoCurrentIndex, because we've
        //  already checked that we're on a secondary index
        //
        Assert( JET_errSuccess == err );
    } else {
        err = JetGetBookmarkEx(pDB->JetSessID,
                               Cursor,
                               pBookMark->pvPrimaryBookMark,
                               cbPrimaryBookMark,
                               &cbPrimaryBookMark);
    }
    if (err != JET_errSuccess) {
        Assert( FALSE );        //  should be impossible, something went horribly wrong
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
    }
    Assert(cbPrimaryBookMark == pBookMark->cbPrimaryBookMark);
    Assert(cbSecondaryBookMark == pBookMark->cbSecondaryBookMark);

    return;
}

void
DBGotoBookMarkEx (
        DBPOS *pDB,
        JET_TABLEID Cursor,
        DBBOOKMARK *pBookMark
        )
/*
   Description:
      A very thin wrapper around JetGotoBookMark.  After going to the bookmark,
      reset position data in the dbpos.

   Parameters
      pDB - DBPOS to use
      Cursor - which table to use
      pBookMark - bookmark to goto.

   Returns:
      No return code.

*/
{
    Assert(pBookMark->pvPrimaryBookMark);
    Assert(pBookMark->cbPrimaryBookMark);
    if (pBookMark->pvSecondaryBookMark) {
        Assert(pBookMark->cbPrimaryBookMark);
        JetGotoSecondaryIndexBookmarkEx(pDB->JetSessID,
                                        Cursor,
                                        pBookMark->pvSecondaryBookMark,
                                        pBookMark->cbSecondaryBookMark,
                                        pBookMark->pvPrimaryBookMark,
                                        pBookMark->cbPrimaryBookMark,
                                        NO_GRBIT);
    } else {
        JetGotoBookmarkEx(pDB->JetSessID,
                          Cursor,
                          pBookMark->pvPrimaryBookMark,
                          pBookMark->cbPrimaryBookMark);
    }
    // Guarantee that DBPOS is updated with new position
    if (Cursor == pDB->JetObjTbl) {
        dbMakeCurrent(pDB, NULL);
    }

    return;
}

void
DBFreeBookMark(THSTATE *pTHS,
               DBBOOKMARK *pBookMark)
{
    THFreeEx(pTHS, pBookMark->pvPrimaryBookMark);
    if (pBookMark->pvSecondaryBookMark) {
        THFreeEx(pTHS, pBookMark->pvSecondaryBookMark);
    }
    memset(pBookMark, 0, sizeof(*pBookMark));
}


DWORD
DBGetEstimatedNCSizeEx(
    IN DBPOS *pDB,
    IN ULONG dntNC
    )
/*++

Routine Description:

This was written to replace DBGetNCSizeEx() in cases where an estimated
size would suffice.  This routines uses the CountAncestorsIndexSizeHelper()
function to get the number of objects in the index with a common chain
of ancestors.

Note that this routine implicitly works on set of objects in the object
table. This routine does not work on other tables, or on other indexes.
Use DbGetApproxNcSizeEx for that.

Used as a base:
  src\mddit.c:MakeNCEntry()
  dblayer\dbtools.c:CountAncestorsIndexSizeHelper/CountAncestorsIndexSize


Arguments:

    pDB - Which session to use.
    dntNC - DNT of NC you want to count.

Return Value:

    (DWORD) - Estimated size of NC.  Raises exceptions on errors.  Finally,
    note currency will be lost, caller must restore.

--*/
{
    DWORD       cbAncestors = 0;
    DWORD *     pAncestors = NULL;
    DWORD       numAncestors = 0;
    ULONG       ulEstimatedSize = 0;

    DBFindDNT(pDB, dntNC);

    DBGetAncestors (pDB, &cbAncestors, &pAncestors, &numAncestors);

    ulEstimatedSize = CountAncestorsIndexSizeHelper (pDB,
                                                     cbAncestors,
                                                     pAncestors);

    THFreeEx (pTHStls, pAncestors);
    return(ulEstimatedSize);
}


DWORD
DBGetNCSizeExSlow(
    IN DBPOS *pDB,
    IN JET_TABLEID Cursor,
    IN eIndexId indexid,
    IN ULONG dntNC
    )

/*++

Routine Description:

Return the number of objects in a given NC.  This relies on the fact we have
an index with ncdnt as the primary segment.

Currency is left at the first record of the next nc, or the last record of the
desired nc.

This routine counts every record on the index. It is very accurate. This routine should
not be used on large indexes.  Use of this routine has been linked
to "out of version store" errors due to excessively long transaction times when
this routine is used on large indexes.

Arguments:

    pDB - Which session to use
    Cursor - Which table to search
    dntNC - nc

Return Value:

    DWORD -

--*/

{
    DB_ERR dberr;
    INDEX_VALUE indexValue;
    DWORD count = 0;
    DWORD dntSearchNC = dntNC;

    // We want one that is indexed by NCDNT
    dberr = DBSetCurrentIndex(pDB, indexid, NULL, FALSE);
    if (dberr == JET_errNoCurrentRecord) {
        // No range exists
        return 0;
    } else if (dberr) {
        DsaExcept(DSA_DB_EXCEPTION, dberr,0);
    }

    // Start at the beginning of the index
    dberr = DBMoveEx(pDB, Cursor, DB_MoveFirst);
    if (dberr == JET_errNoCurrentRecord) {
        // No range exists
        return 0;
    } else if (dberr) {
        DsaExcept(DSA_DB_EXCEPTION, dberr,0);
    }

    // Seek to first record with that ncdnt
    indexValue.pvData = &dntSearchNC;
    indexValue.cbData = sizeof( ULONG );

    dberr = DBSeekEx( pDB, Cursor, &indexValue, 1, DB_SeekGE );
    if (dberr == JET_errRecordNotFound) {
        // No records on this index
        return 0;
    } else if (dberr) {
        DsaExcept(DSA_DB_EXCEPTION, dberr,0);
    }

    // Point the index value at the next higher NC
    dntSearchNC++;

    // Set the counting limit to be the top of the NC
    dberr = DBSetIndexRangeEx( pDB, Cursor, &indexValue, 1, FALSE /*notsubstring*/ );
    if (dberr == JET_errNoCurrentRecord) {
        // No range exists
        return 0;
    } else if (dberr) {
        DsaExcept(DSA_DB_EXCEPTION, dberr,0);
    }

    // Check if we're shutting down before doing this expensive call.
    if(eServiceShutdown){
        DsaExcept(DSA_EXCEPTION, ERROR_DS_SHUTTING_DOWN, 0);
    }

    // Get index size from position to end
    // SCALING: This call counts every record
    // PERFORMANCE: Call JetIndexRecordCount directly and set the upper bound
    // option on the number of records counted.  This will bound the amount
    // of index processing time we put into this.
    DBGetIndexSizeEx( pDB, Cursor, &count, FALSE );

    // Check if we're shutting down right after this expensive call.
    if(eServiceShutdown){
        DsaExcept(DSA_EXCEPTION, ERROR_DS_SHUTTING_DOWN, 0);
    }

    DPRINT2( 1, "Accurate size of NC %s is %d record(s).\n",
             DBGetExtDnFromDnt( pDB, dntNC ), count );

    return count;
} /* DBGetNCSizeExSlow */


DWORD
DBGetApproxNCSizeEx(
    IN DBPOS *pDB,
    IN JET_TABLEID Cursor,
    IN eIndexId indexid,
    IN ULONG dntNC
    )

/*++

Routine Description:

Return the number of objects in a given NC.  This relies on the fact we have
an index with ncdnt as the primary segment.

Currency is left at the first record of the next nc, or the last record of the
desired nc.

This routine uses fractional positions to calculate an approximate size of the
index range.  It is much faster than counting every record, but potentially less
accurate. However this should be suitable for display of statistics and progress
indicators.

Arguments:

    pDB - database position
    Cursor - table
    indexid - Which index. Must have ncdnt has first segment
    dntNC - nc to search

Return Value:

    DWORD -

--*/

{
    DB_ERR dberr;
    INDEX_VALUE indexValue;
    DWORD count = 0;
    DWORD dntSearchNC = dntNC;
    DWORD Denominator, Numerator;
    DWORD BeginDenom, BeginNum, EndDenom, EndNum;

    // We want one that is indexed by NCDNT
    dberr = DBSetCurrentIndex(pDB, indexid, NULL, FALSE);
    if (dberr == JET_errNoCurrentRecord) {
        // No range exists
        return 0;
    } else if (dberr) {
        DsaExcept(DSA_DB_EXCEPTION, dberr,0);
    }

    // Start at the beginning of the index
    dberr = DBMoveEx(pDB, Cursor, DB_MoveFirst);
    if (dberr == JET_errNoCurrentRecord) {
        // No range exists
        return 0;
    } else if (dberr) {
        DsaExcept(DSA_DB_EXCEPTION, dberr,0);
    }

    // Seek to first record with that ncdnt
    indexValue.pvData = &dntSearchNC;
    indexValue.cbData = sizeof( ULONG );

    dberr = DBSeekEx( pDB, Cursor, &indexValue, 1, DB_SeekGE );
    if (dberr == JET_errRecordNotFound) {
        // No records on this index
        return 0;
    } else if (dberr) {
        DsaExcept(DSA_DB_EXCEPTION, dberr,0);
    }

    DBGetFractionalPositionEx(pDB, Cursor, &BeginNum, &BeginDenom);

    // Point the index value at the next higher NC
    dntSearchNC++;

    // Seek to first record in next ncdnt
    dberr = DBSeekEx( pDB, Cursor, &indexValue, 1, DB_SeekGE );
    if (dberr) {
        // Seek to the end of the index
        dberr = DBMoveEx(pDB, Cursor, DB_MoveLast);
        if (dberr == JET_errNoCurrentRecord) {
            // No range exists
            return 0;
        } else if (dberr) {
            DsaExcept(DSA_DB_EXCEPTION, dberr,0);
        }
    }

    DBGetFractionalPositionEx(pDB, Cursor, &EndNum, &EndDenom);

    // Normalize the fractions of the fractional position to the average of
    // the two denominators.
    Denominator = (BeginDenom + EndDenom) / 2;
    EndNum = MulDiv(EndNum, Denominator - 1, EndDenom - 1) + 1;
    BeginNum = MulDiv(BeginNum, Denominator - 1, BeginDenom - 1) + 1;

    if ( BeginDenom == 1 || EndDenom == 1 ) {
        count = 1;
    } else {
        count = NormalizeIndexPosition(BeginNum, EndNum);
    }

    DPRINT5( 2, "BeginNum %d BeginDenom %d EndNum %d EndDenom %d Count %d\n",
             BeginNum, BeginDenom, EndNum, EndDenom, count );

    // Estimate too small to be accurate. Use slow method.
    if (count < EPSILON) {
      count = DBGetNCSizeExSlow( pDB, Cursor, indexid, dntNC );
    }

    DPRINT2( 1, "Size of NC %s is %d record(s).\n",
             DBGetExtDnFromDnt( pDB, dntNC ), count );

    return count;
} /* DBGetApproxNCSizeEx */


VOID
DBSearchCriticalByDnt(
    DBPOS *pDB,
    DWORD dntObject,
    BOOL *pCritical
    )

/*++

Routine Description:

    Check if the given dnt refers to a critical object
    Use the search table so not to disturb ObjectTable Concurrency

    This is a performance optimization helper for
    GetNextObjOrValByUsn. In the case where we are searching for critical
    objects and have found a value, we have the dnt of an object. We want
    to know quickly and with minimal disturbance of the object referenced
    by the dnt is critical.

    In the future, we might consider caching the results of this lookup
    somehow.

Arguments:

    pDB -
    dntObject -
    pCritical -

Return Value:

    DWORD -

--*/

{
    JET_ERR err;
    DWORD cbActual;

    Assert(VALID_DBPOS(pDB));

    // Switch to dnt index
    JetSetCurrentIndexSuccess(pDB->JetSessID,
                              pDB->JetSearchTbl,
                              NULL);  // OPTIMISATION: pass NULL to switch to primary index (SZDNTINDEX)

    // Seek to this item
    JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl,
                 &dntObject, sizeof(dntObject),
                 JET_bitNewKey);

    err = JetSeekEx(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekEQ);
    if (err) {
        DPRINT1( 0, "dnt %d not found on dnt index\n", dntObject );
        DsaExcept(DSA_DB_EXCEPTION, err,0);
    }

    // At this point, we have seeked to the dnt on a separate Jet cursor.
    // We have a choice: we can read ATT_IS_CRITICAL_SYSTEM_OBJECT from the
    // data page, or we can switch to USN-CRITICAL index and read the att
    // out of the index. I chose the latter.

    // Switch to Usn Critical index, preserving currency
    err = JetSetCurrentIndex4Warnings(pDB->JetSessID,
                                      pDB->JetSearchTbl,
                                      SZDRAUSNCRITICALINDEX,
                                      &idxDraUsnCritical,
                                      JET_bitNoMove);
    if (err) {
        // Record not on this index, not critical
        DPRINT1( 3, "dnt %d not found on usn critical index\n", dntObject );
        *pCritical = FALSE;
        return;
    }

    // Should succeed if on the index
    JetRetrieveColumnSuccess(pDB->JetSessID,
                             pDB->JetSearchTbl,
                             iscriticalid,
                             pCritical,
                             sizeof(BOOL),
                             &cbActual,
                             JET_bitRetrieveFromIndex,
                             NULL );

    DPRINT2( 3, "critical value of dnt %d is %d\n", dntObject, *pCritical );

} /* DBSearchCriticalByDnt */


BOOL
DBSearchHasValuesByDnt(
    IN DBPOS        *pDB,
    IN DWORD        DNT,
    IN JET_COLUMNID jColid
    )

/*++

Routine Description:

    Does object at DNT have values for jColid?

    pDB->JetSearchTbl is used. Currency in pDB->JetObjTbl is not disturbed.

    This is a performance optimization helper for SetSpecialAttsForAuxClasses
    when creating a dynamic object.

Arguments:

    pDB - database currency
    DNT - for the object in question
    jColid - retrieve value for this column

Return Value:
    An exception is raised if there is an unexpected jet error.
    TRUE - value exists and has been returned.
    FALSE - value doesn't exist.

--*/

{
    JET_ERR err;
    DWORD   Data;
    DWORD   cbActual;

    Assert(VALID_DBPOS(pDB));

    // Switch to dnt index using the search table
    if (JET_errSuccess != JetSetCurrentIndexWarnings(pDB->JetSessID,
                                                     pDB->JetSearchTbl,
                                                     NULL)) {   // OPTIMISATION: pass NULL to switch to primary index (SZDNTINDEX)
        return FALSE;
    }

    // Seek to the object by dnt
    JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl,
                 &DNT, sizeof(DNT), JET_bitNewKey);
    if (JET_errSuccess != JetSeekEx(pDB->JetSessID,
                                    pDB->JetSearchTbl,
                                    JET_bitSeekEQ)) {
        return FALSE;
    }

    // Has values?
    switch(JetRetrieveColumnWarnings(pDB->JetSessID,
                                     pDB->JetSearchTbl,
                                     jColid,
                                     &Data,
                                     0,
                                     &cbActual,
                                     0,
                                     NULL)) {

    case JET_errColumnNotFound:
    case JET_wrnColumnNull:
        return FALSE;
        break;

    case JET_wrnBufferTruncated:
    case JET_errSuccess:
        return TRUE;
        break;
    default:
        return FALSE;
    }

} // DBSearchHasValuesByDnt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dblayer\dbfilter.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       dbfilter.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <mdlocal.h>
#include <dsatools.h>                   // For pTHS
#include <limits.h>


// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>
#include "ntdsctr.h"

// Assorted DSA headers
#include <anchor.h>
#include <mappings.h>
#include <dsevent.h>
#include <filtypes.h>                   // Def of FI_CHOICE_???
#include "objids.h"                     // Hard-coded Att-ids and Class-ids
#include "dsconfig.h"
#include <sdprop.h>
#include "debug.h"                      // standard debugging header
#define DEBSUB "DBFILTER:"              // define the subsystem for debugging

// DBLayer includes
#include "dbintrnl.h"

#include <fileno.h>
#define  FILENO FILENO_DBFILTER


/* Internal functions */
DWORD
dbFlattenFilter (
        DBPOS *pDB,
        FILTER *pFil,
        size_t iLevel,
        FILTER **ppOutFil,
        ATTRTYP *pErrAttrTyp);

DWORD
dbCloneFilter (
    DBPOS *pDB,
    FILTER *pFil,
    FILTER **ppOutFil);


DWORD
dbOptFilter (
        DBPOS     *pDB,
        DWORD     Flags,
        KEY_INDEX **ppBestIndex,
        FILTER    *pFil
        );

DWORD
dbOptAndFilter (
    DBPOS     *pDB,
    DWORD     Flags,
    KEY_INDEX **ppBestIndex,
    FILTER    *pFil
    );

DWORD
dbOptItemFilter (
    DBPOS    *pDB,
    DWORD     fParentFilterType,
    DWORD     Flags,
    KEY_INDEX **ppBestIndex,
    FILTER    *pFil,
    FILTER    *pFil2
    );

DWORD
dbOptSubstringFilter (
        DBPOS *pDB,
        DWORD  fParentFilterType,
        DWORD     Flags,
        KEY_INDEX **ppBestIndex,
        DWORD     *pIndexCount,
        FILTER    *pFil
        );

//
// Index optimization flags.
//
#define DBOPTINDEX_fUSE_SHOW_IN_AB             0x1
#define DBOPTINDEX_fDONT_INTERSECT             0x2
#define DBOPTINDEX_fDONT_OPT_MEDIAL_SUBSTRING  0x4


// this is the maximum number of the indexes that can be intersected.
// this is related to the filters that are under the AND filter.
// for each one, we have to create a new jet cursor, which limits the number
// of active open cursors we can have at any time.
// the Jet limit for this is 64, but we think 16 will be enough for our case.
#define MAX_NUMBER_INTERSECTABLE_INDEXES 16

// this is the number of entries that if found on the default index,
// we do not optimize the filter
#define MIN_NUM_ENTRIES_ON_OPT_INDEX 2

BOOL gfUseIndexOptimizations = TRUE;

BOOL gfUseRangeOptimizations = TRUE;
BOOL gfUseANDORFilterOptimizations = TRUE;

ULONG gulIntersectExpenseRatio = DEFAULT_DB_INTERSECT_RATIO;
ULONG gulMaxRecordsWithoutIntersection = DEFAULT_DB_INTERSECT_THRESHOLD;
ULONG gulEstimatedAncestorsIndexSize = 100000000;

BOOL gfSupressFirstLastANR=FALSE;
BOOL gfSupressLastFirstANR=FALSE;

const char c_szIntersectIndex[] = "INTERSECT_INDEX";
const DWORD cIntersectIndex = sizeof (c_szIntersectIndex);

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Set a new filter.
*/

void
DBSetFilter (
        DBPOS FAR *pDB,
        FILTER *pFil,
        POBJECT_TYPE_LIST pSec,
        DWORD *pSecResults,
        ULONG SecSize,
        BOOL *pbSortSkip
        )
{
    BOOL fDontFreeFilter = pDB->Key.fDontFreeFilter;

    if (pDB->Key.pIndex) {
        dbFreeKeyIndex (pDB->pTHS, pDB->Key.pIndex);
    }
    if (pDB->Key.pFilter) {
        dbFreeFilter (pDB, pDB->Key.pFilter);
    }
    memset(&pDB->Key, 0, sizeof(KEY));
    pDB->Key.fDontFreeFilter = fDontFreeFilter;

    pDB->Key.pFilter = pFil;   /*Set filter pointer*/
    pDB->Key.pFilterSecurity = pSec;
    pDB->Key.pFilterResults = pSecResults;
    pDB->Key.FilterSecuritySize = SecSize;
    pDB->Key.pbSortSkip = pbSortSkip;

    return;

}/*DBSetFilter*/

/*++

Routine Description:

    Generates the correct index name to be used for an attribute.
    Takes in consideration the type of index required (SUBTREE/ONELEVEL),
    and whether there exists a pre-existing index for this attribute.
    Also considers the required language this index has to be for
    the ONELEVEL case.

Arguments:

    pAC - the attribute to use
    flags - fATTINDEX OR fPDNTATTINDEX  (what index to generate)
    dwLcid - the required locale (DS_DEFAULT_LOCALE is default)
    szIndexName - where to store the generated index name
    cchIndexName - the size of the passed in szIndexName

Return Value:

    TRUE on success

--*/
BOOL DBGetIndexName (ATTCACHE *pAC, DWORD flags, DWORD dwLcid, CHAR *szIndexName, DWORD cchIndexName)
{
    int ret;
    if (flags == fATTINDEX) {
        ret = _snprintf(szIndexName, cchIndexName, SZATTINDEXPREFIX"%08X", pAC->id);
        Assert (ret>=0);
    }
    else if (flags == fTUPLEINDEX) {
        ret = _snprintf(szIndexName, cchIndexName, SZATTINDEXPREFIX"T_%08X", pAC->id);
        Assert (ret>=0);
    }
    else if (flags == fPDNTATTINDEX ) {

        if (dwLcid == DS_DEFAULT_LOCALE) {
            if (pAC->id == ATT_RDN) {
                strncpy(szIndexName, SZPDNTINDEX, cchIndexName);
            }
            else {
                ret = _snprintf(szIndexName, cchIndexName, SZATTINDEXPREFIX"P_%08X", pAC->id);
                Assert (ret>=0);
            }
        }
        else {
            ret = _snprintf(szIndexName, cchIndexName, SZATTINDEXPREFIX"LP_%08X_%04X", pAC->id, dwLcid);
            Assert (ret>=0);
        }
    }
    else {
        Assert (!"DBGetIndexName: Bad parameter passed");
        return FALSE;
    }

    return TRUE;
}

BOOL dbSetToTupleIndex(
    DBPOS    *  pDB,
    ATTCACHE *  pAC )
    {
    BOOL        fResult     = TRUE;     //  be optimistic

#ifdef DBG
    CHAR        szIndexName[MAX_INDEX_NAME];
    sprintf( szIndexName, SZATTINDEXPREFIX"T_%08X", pAC->id );
    Assert( NULL == pAC->pszTupleIndex
            || 0 == strcmp( szIndexName, pAC->pszTupleIndex ) );
#endif

    if ( NULL == pAC->pszTupleIndex )
        {
        DPRINT2(
            2,
            "dbSetToTupleIndex: Index %sT_%08X does not exist.\n",
            SZATTINDEXPREFIX,
            pAC->id );
        fResult = FALSE;
        }
    else
        {
        const JET_ERR   err     = JetSetCurrentIndex4Warnings(
                                            pDB->JetSessID,
                                            pDB->JetObjTbl,
                                            pAC->pszTupleIndex,
                                            pAC->pidxTupleIndex,
                                            JET_bitMoveFirst );

        if ( JET_errSuccess != err )
            {
            DPRINT1( 2, "dbSetToTupleIndex: Unable to set to index %s\n", pAC->pszTupleIndex );
            fResult = FALSE;
            }
        }

    return fResult;
    }

BOOL
dbSetToIndex(
        DBPOS    *pDB,
        BOOL      fCanUseShowInAB,
        BOOL     *pfPDNT,
        CHAR     *szIndexName,
        JET_INDEXID **ppindexid,
        ATTCACHE *pAC
        )
{
    THSTATE *pTHS=pDB->pTHS;
    *pfPDNT = FALSE;

    Assert(VALID_DBPOS(pDB));

    if(!pTHS->fDefaultLcid && !pDB->Key.pVLV) {
        // We have a non-default locale.  That implies that this is a mapi
        // request.  So, try to use the index we build mapi tables out of.
        switch(pAC->id) {
        case ATT_SHOW_IN_ADDRESS_BOOK:
            sprintf(szIndexName,"%s%08X",SZABVIEWINDEX,
                    LANGIDFROMLCID(pTHS->dwLcid));
            *ppindexid = NULL;

            if(!JetSetCurrentIndexWarnings(pDB->JetSessID,
                                           pDB->JetObjTbl,
                                           szIndexName)) {
                return TRUE;
            }
            break;
        case ATT_DISPLAY_NAME:
            // It would be cool if we could use the ABVIEW index to
            // support this.  The ABVIEW index is over ATT_SHOW_IN_ADDRESS_BOOK
            // followed by ATT_DISPLAY_NAME.  To support the ATT_DISPLAY_NAME
            // case, we would need a way to figure out what the value of
            // ATT_SHOW_IN_ADDRESS_BOOK needs to be.  Maybe I'll figure out how
            // to do this later.  Until then, do nothing special.
            break;

        default:
            // No special index use available.
            break;
        }
    }
    else if(fCanUseShowInAB && pAC->id == ATT_SHOW_IN_ADDRESS_BOOK) {
        // We can use the index we build mapi tables out of anyway, because we
        // have previously checked the filter and the caller is also doing
        // something that implies presence of display name (the AB index is
        // compound over SHOW_IN.. and DISPLAY_NAME

        if (!pDB->Key.pVLV) {
            sprintf(szIndexName,"%s%08X",SZABVIEWINDEX,
                    LANGIDFROMLCID(gAnchor.ulDefaultLanguage));
        }
        else {
            sprintf(szIndexName,"%s%08X",SZABVIEWINDEX,
                    LANGIDFROMLCID(pTHS->dwLcid));
        }
        *ppindexid = NULL;

        if(!JetSetCurrentIndexWarnings(pDB->JetSessID,
                                       pDB->JetObjTbl,
                                       szIndexName)) {
            return TRUE;
        }
    }

    // First, see if we should try a PDNT version
    if(pDB->Key.ulSearchType ==  SE_CHOICE_IMMED_CHLDRN) {

        if (pAC->fSearchFlags & fPDNTATTINDEX) {
            // We are looking only for children of a certain parent and the schema
            // cache says that such an index should exist.
            // Try for a PDNT based index.

            // if we are doing VLV on a language other than the default
            // we will try to use the language specific PDNT index
            if (pDB->Key.pVLV && pTHS->dwLcid != DS_DEFAULT_LOCALE) {
                DPRINT1 (0, "Using Language 0x%x\n", pTHS->dwLcid);

                sprintf(szIndexName, SZATTINDEXPREFIX"LP_%08X_%04X",
                                    pAC->id, pTHS->dwLcid);
                *ppindexid = NULL;

                if (!JetSetCurrentIndex4Warnings(pDB->JetSessID,
                                                 pDB->JetObjTbl,
                                                 szIndexName,
                                                 NULL,
                                                 JET_bitMoveFirst)) {
                    *pfPDNT = TRUE;
                    return TRUE;
                }
            }

            //copy cached index to return variable, since it used afterwards
            Assert (pAC->pszPdntIndex);
            strcpy (szIndexName, pAC->pszPdntIndex);
            *ppindexid = pAC->pidxPdntIndex;

            if (!JetSetCurrentIndex4Warnings(pDB->JetSessID,
                                             pDB->JetObjTbl,
                                             szIndexName,
                                             pAC->pidxPdntIndex,
                                             JET_bitMoveFirst)) {
                *pfPDNT = TRUE;
                return TRUE;
            }
        }

        else if (pAC->id == ATT_RDN) {
            // this is a special case
            // we can use the pDNTRDN index directly when we ask for the default lang

            if (pTHS->dwLcid == DS_DEFAULT_LOCALE) {

                strcpy (szIndexName, SZPDNTINDEX);
                *ppindexid = &idxPdnt;
                if (!JetSetCurrentIndex4Warnings(pDB->JetSessID,
                                                 pDB->JetObjTbl,
                                                 szIndexName,
                                                 &idxPdnt,
                                                 JET_bitMoveFirst)) {
                    *pfPDNT = TRUE;
                    return TRUE;
                }
            }
        }
    }

    // Don't have an index yet.
    if(pAC->fSearchFlags & fATTINDEX) {
        // But the schema cache says one should exist.

        //copy cached index to return variable, since it used afterwards
        Assert (pAC->pszIndex);
        strcpy (szIndexName, pAC->pszIndex);
        *ppindexid = pAC->pidxIndex;

        if (!JetSetCurrentIndex4Warnings(pDB->JetSessID,
                                         pDB->JetObjTbl,
                                         szIndexName,
                                         pAC->pidxIndex,
                                         JET_bitMoveFirst))  {
            // index defined for this column
            return TRUE;
        }
    }

    //
    // Special case: If distinguishedName (OBJ-DIST-NAME) requested,
    // use the DNT index
    //

    if ( pAC->id == ATT_OBJ_DIST_NAME ) {
        strcpy(szIndexName, SZDNTINDEX);
        *ppindexid = &idxDnt;
        if ( !JetSetCurrentIndex4Warnings(pDB->JetSessID,
                                        pDB->JetObjTbl,
                                        szIndexName,
                                        &idxDnt,
                                        JET_bitMoveFirst) ) {
            // index defined for this column
            return TRUE;
        }
    }

    // if we still don't have an index and this is a linked attr then we will
    // use the appropriate index on the link table

    if (pAC->ulLinkID) {
        if (FIsBacklink(pAC->ulLinkID)) {
            strcpy(szIndexName, SZBACKLINKINDEX);
            *ppindexid = &idxBackLink;
        }
        else {
            strcpy(szIndexName, SZLINKINDEX);
            *ppindexid = &idxLink;
        }
        if (!JetSetCurrentIndex4Warnings(pDB->JetSessID,
                                        pDB->JetLinkTbl,
                                        szIndexName,
                                        *ppindexid,
                                        JET_bitMoveFirst)) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
dbFIsAlwaysPresent (
        ATTRTYP type
        )
/*++

Routine Description:

    Worker routine that tells callers whether an attrtyp is always present on an
    instantiated object (i.e. not a phantom).  Usually called from
    dbFlattenItemFilter to turn FI_CHOICE_PRESENT filter items into
    FI_CHOICE_TRUE filter items.
    Note: ATT_OBJECT_CATEGORY is not present on deleted objects,
    thus we will not optimize it out.

Arguments:

    type - attribute in question.

Return Value:

    TRUE if we think the attribute ALWAYS exists on objects.

--*/
{
    switch(type) {
    case ATT_OBJECT_CLASS:
    case ATT_OBJ_DIST_NAME:
    case ATT_RDN:
    case ATT_OBJECT_GUID:
        return TRUE;
        break;

    default:
        return FALSE;
        break;
    }
}

BOOL
dbIsPresenceOnDisplayName (
        FILTER *pFil
        )
/*++
Description:
          Returns True if the itemfilter passed in implies a presence test of
          the DISPLAY_NAME attribute (i.e. Presence filter, Equality Filter,
          Greater Than/Less Than filter, etc.).

--*/
{
    ATTRTYP type;

    if(pFil->choice != FILTER_CHOICE_ITEM) {
        return FALSE;
    }

    // Just a normal item filter.
    switch(pFil->FilterTypes.Item.choice) {
    case FI_CHOICE_TRUE:
    case FI_CHOICE_FALSE:
    case FI_CHOICE_UNDEFINED:
        return FALSE;
        break;

    case FI_CHOICE_SUBSTRING:
        type = pFil->FilterTypes.Item.FilTypes.pSubstring->type;
        break;

    case FI_CHOICE_GREATER_OR_EQ:
    case FI_CHOICE_GREATER:
    case FI_CHOICE_LESS_OR_EQ:
    case FI_CHOICE_LESS:
    case FI_CHOICE_EQUALITY:
    case FI_CHOICE_BIT_AND:
    case FI_CHOICE_BIT_OR:
        type = pFil->FilterTypes.Item.FilTypes.ava.type;
        break;

    case FI_CHOICE_PRESENT:
        type = pFil->FilterTypes.Item.FilTypes.present;
        break;

    default:
        // Huh?
        return FALSE;
    }

    return (type == ATT_DISPLAY_NAME);
}


#define OPT_FILTER_VALUE_OK      0
#define OPT_FILTER_VALUE_IGNORE  1
#define OPT_FILTER_VALUE_ERROR   2

DWORD
dbMakeValuesForOptimizedFilter (
        IN  THSTATE *pTHS,
        IN  DWORD   fParentFilterType,
        IN  BOOL    fFullValues,
        IN  FILTER  *pFil,
        IN  FILTER  *pFil2,
        OUT ATTRTYP *ptype,
        OUT UCHAR   **ppVal1,
        OUT UCHAR   **ppVal2,
        OUT ULONG   *pcbVal1,
        OUT ULONG   *pcbVal2
        )
/*++
    Given a filter item, fill in the type and the appropriate values used to set
    a subrange.

    fParentFilterType -  the type of the parent filter:
                  FILTER_CHOICE_AND, FILTER_CHOICE_OR, FILTER_CHOICE_NOT,
                  or
                  FILTER_CHOICE_ITEM

    fFullValues - if TRUE return full information regarding the filter,
                  otherwise (FALSE) return information only regarding the
                  ATTR type of the filter (ptype variable).

    pFil1, pFil2 - Use these filters to extract the value contained in the filter
                   and put it in the ppVal?, pcbVal? variables
                   the pFil2 is used only when the pFil1 type is on of (<, <=, >, >=)
                   inorder to construct a range
                   If pFil1 is of type (<, <=) it is assumed the pFil2 will be
                   of type (>, >=) and both will construct a range, with pFil2
                   having the lower bound.

                   Similarly, if pFil1 if of type (>, >=) it is assumed
                   that pFil2 is (<, <=) and that pFil2 has the upper bound.

    ppVal1, ppVal2 - pointers to memory containing the data for this filter
    pcbVal1, pcBVal2 - size of the data

    returns OPT_FILTER_VALUE_OK (which == 0) if all went well, an error
    otherwise.
--*/
{
    DWORD i=0;
    DWORD dwTemp;
    DWORD cbTemp;
    PUCHAR pTemp=NULL;
    ULONGLONG ullTemp=0;
    LONGLONG llTemp=0;
    LONG     lTemp = 0;
    BOOL     bNeg;

    // NOTICE-2002/03/06-andygo:  unreachable code
    // REVIEW:  this branch is dead code because we always end up here with an ITEM filter
    if(pFil->choice != FILTER_CHOICE_ITEM) {
        return OPT_FILTER_VALUE_OK;
    }

    // Just a normal item filter.
    switch(pFil->FilterTypes.Item.choice) {
    case FI_CHOICE_TRUE:
        // if we're doing an OR filter, then this means the whole OR is
        // non-optimizable.  If we're not doing an OR filter, we just skip it.
        if(fParentFilterType == FILTER_CHOICE_OR) {
            return OPT_FILTER_VALUE_ERROR;
        }
        else {
            return OPT_FILTER_VALUE_IGNORE;
        }
        break;

    case FI_CHOICE_FALSE:
        // If we're doing an OR filter, we can just skip this.  If we're not
        // doing an OR filter, make up some values that will get us an index
        // that hit's a single object.
        if(fParentFilterType == FILTER_CHOICE_OR) {
            return OPT_FILTER_VALUE_IGNORE;
        }
        else {
            // Pick an index, any index, which is simple to walk, and that
            // we can restrict to a single entry.  Here, we use the DNT
            // index and restrict to the base object.  That way, we don't
            // upset the rest of the code that walks indices during
            // searches, but we only look at one object ever.

            *ptype = ATT_OBJ_DIST_NAME;
            if (fFullValues) {
                *ppVal2 = *ppVal1 = (BYTE *)&pTHStls->pDB->Key.ulSearchRootDnt;
                *pcbVal2 = *pcbVal1 = sizeof(DWORD);
            }
        }
        break;

    case FI_CHOICE_SUBSTRING:
        if(!pFil->FilterTypes.Item.FilTypes.pSubstring->initialProvided) {
            return OPT_FILTER_VALUE_ERROR;
        }

        if (fFullValues) {
                *ppVal1 = pFil->FilterTypes.Item.FilTypes.pSubstring->InitialVal.pVal;
                *pcbVal1= pFil->FilterTypes.Item.FilTypes.pSubstring->InitialVal.valLen;
                *ppVal2 = pFil->FilterTypes.Item.FilTypes.pSubstring->InitialVal.pVal;
                *pcbVal2= pFil->FilterTypes.Item.FilTypes.pSubstring->InitialVal.valLen;
        }
        *ptype = pFil->FilterTypes.Item.FilTypes.pSubstring->type;
        break;

    case FI_CHOICE_GREATER_OR_EQ:
    case FI_CHOICE_GREATER:
        if (fFullValues) {
                *ppVal1 = pFil->FilterTypes.Item.FilTypes.ava.Value.pVal;
                *pcbVal1 = pFil->FilterTypes.Item.FilTypes.ava.Value.valLen;

                if (pFil2) {
                    *ppVal2 = pFil2->FilterTypes.Item.FilTypes.ava.Value.pVal;
                    *pcbVal2 = pFil2->FilterTypes.Item.FilTypes.ava.Value.valLen;
                }
                else {
                    *ppVal2 = NULL;
                    *pcbVal2 = 0;
                }
        }
        *ptype = pFil->FilterTypes.Item.FilTypes.ava.type;
        break;

    case FI_CHOICE_LESS_OR_EQ:
    case FI_CHOICE_LESS:
        if (fFullValues) {
                if (pFil2) {
                    *ppVal1 = pFil2->FilterTypes.Item.FilTypes.ava.Value.pVal;
                    *pcbVal1 = pFil2->FilterTypes.Item.FilTypes.ava.Value.valLen;
                }
                else {
                    *ppVal1 = NULL;
                    *pcbVal1 = 0;
                }
                *ppVal2 = pFil->FilterTypes.Item.FilTypes.ava.Value.pVal;
                *pcbVal2 = pFil->FilterTypes.Item.FilTypes.ava.Value.valLen;
        }
        *ptype = pFil->FilterTypes.Item.FilTypes.ava.type;
        break;

    case FI_CHOICE_EQUALITY:
        if (fFullValues) {
                *ppVal1 = pFil->FilterTypes.Item.FilTypes.ava.Value.pVal;
                *pcbVal1 = pFil->FilterTypes.Item.FilTypes.ava.Value.valLen;
                *ppVal2 = pFil->FilterTypes.Item.FilTypes.ava.Value.pVal;
                *pcbVal2 = pFil->FilterTypes.Item.FilTypes.ava.Value.valLen;
        }
        *ptype = pFil->FilterTypes.Item.FilTypes.ava.type;
        break;

    case FI_CHOICE_PRESENT:
        if (fFullValues) {
                *ppVal1 = NULL;
                *pcbVal1 = 0;
                *ppVal2 = NULL;
                *pcbVal2 = 0;
        }
        *ptype = pFil->FilterTypes.Item.FilTypes.present;
        break;

    case FI_CHOICE_BIT_AND:
        // Remember, Jet Indices over out int values are SIGNED,  So, if someone
        // is looking for BIT_AND 0000100000000000, that implies two ranges
        // (16 bit numbers used for discussion only)
        // 0000100000000000 through 0111111111111111 and
        // 1000100000000000 through 1111111111111111
        // Anyway, we don't support mulitple ranges.  So, in this case, we can
        // only use the range 1000100000000000 through 0111111111111111, but
        // remember that 0111111111111111 is the end of the index.  So, if the
        // number passed in is positive, then the range is from the number
        // created by ORing in the highbit through the end of the index.
        //
        // If, on the other hand, the number passed already had the high bit set
        // (i.e is negative), then only the second range is valid.  So, in that
        // case, the optimized subrange is from the number passed in through -1.

        if (fFullValues) {
                switch(pFil->FilterTypes.Item.FilTypes.ava.Value.valLen) {
                case sizeof(LONG):
                    lTemp = *((LONG *)pFil->FilterTypes.Item.FilTypes.ava.Value.pVal);
                    bNeg = (lTemp < 0);
                    pTemp = THAllocEx(pTHS, sizeof(LONG));
                    cbTemp = sizeof(LONG);
                    if(bNeg) {
                        *((LONG *)pTemp) = -1;
                    }
                    else {
                        *((LONG *)pTemp) = 0x80000000 | lTemp;
                    }
                    break;

                case sizeof(ULONGLONG):
                    llTemp =
                        *((LONGLONG *) pFil->FilterTypes.Item.FilTypes.ava.Value.pVal);

                    bNeg = (llTemp < 0);
                    pTemp = THAllocEx(pTHS, sizeof(LONGLONG));
                    cbTemp = sizeof(LONGLONG);
                    if(bNeg) {
                        *((ULONGLONG *)pTemp) = ((LONGLONG)-1);
                    }
                    else {
                        *((ULONGLONG *)pTemp) = 0x8000000000000000 | llTemp;
                    }
                    break;

                default:
                    // Uh, this shouldn't really happen.  Don't bother optimizing
                    // anything, but then again, don't complain.
                    bNeg = FALSE;
                    cbTemp = 0;
                    pTemp = NULL;
                    break;
                }

                if(bNeg) {
                    // Range is from value passed in to -1.  -1 was already constructed
                    *ppVal1 = pFil->FilterTypes.Item.FilTypes.ava.Value.pVal;
                    *pcbVal1 = pFil->FilterTypes.Item.FilTypes.ava.Value.valLen;
                    *ppVal2 = pTemp;
                    *pcbVal2 = cbTemp;

                }
                else {
                    // Range is from (highbit | value passed in) to end of index.
                    // (highbit | value passed in) was already constructed.
                    *ppVal1 = pTemp;
                    *pcbVal1 = cbTemp;
                    *ppVal2 = NULL;
                    *pcbVal2 = 0;
                }
        }
        *ptype = pFil->FilterTypes.Item.FilTypes.ava.type;
        break;

    case FI_CHOICE_BIT_OR:
        // Remember, Jet Indices over out int values are SIGNED,  So, if someone
        // is looking for BIT_OR 0010100000000000, that implies two ranges
        // (16 bit numbers used for discussion only)
        // 0000100000000000 through 0111111111111111 and
        // 1000100000000000 through 1111111111111111
        // Anyway, we don't support mulitple ranges.  So, we can only optimize
        // this to one range.  The smallest single range is from
        // 1000100000000000 through 0111111111111111
        // Remember that 0111111111111111 is the end of the index.
        // So, the optimization is to find the lowest order bit, and create a
        // number that has ONLY that bit sit and the high order bit.  Then
        // search from there to the end of the index.

        if (fFullValues) {
                switch(pFil->FilterTypes.Item.FilTypes.ava.Value.valLen) {
                case sizeof(DWORD):
                    dwTemp = *((DWORD *)pFil->FilterTypes.Item.FilTypes.ava.Value.pVal);

                    pTemp = THAllocEx(pTHS, sizeof(DWORD));
                    if (dwTemp) {
                        while(!(dwTemp & 1)) {
                            dwTemp = dwTemp >> 1;
                            i++;
                        }
                        *((DWORD *)pTemp) = (1 << i);
                    } else {
                        *((DWORD *)pTemp) = 0;
                    }

                    cbTemp = sizeof(DWORD);
                    *((DWORD *)pTemp) |= 0x80000000;
                    break;

                case sizeof(ULONGLONG):
                    ullTemp =
                        *((ULONGLONG *) pFil->FilterTypes.Item.FilTypes.ava.Value.pVal);

                    pTemp = THAllocEx(pTHS, sizeof(LONGLONG));

                    if (ullTemp) {
                        while(!(ullTemp & 1)) {
                            ullTemp = ullTemp >> 1;
                            i++;
                        }
                        *((ULONGLONG *)pTemp) = ((ULONGLONG)1 << i);
                    } else {
                        *((ULONGLONG *)pTemp) = 0;
                    }

                    cbTemp = sizeof(LONGLONG);
                    *((ULONGLONG *)pTemp) |= 0x8000000000000000;
                    break;

                default:
                    // Uh, this should really happen.  Don't bother optimizing anything,
                    // but then again, don't complain.
                    cbTemp = 0;
                    pTemp = NULL;
                }
                *ppVal1 = pTemp;
                *pcbVal1 = cbTemp;
                *ppVal2 = NULL;
                *pcbVal2 = 0;
        }

        *ptype = pFil->FilterTypes.Item.FilTypes.ava.type;
        break;

    case FI_CHOICE_UNDEFINED:

        // if we are doing an OR filter, we can ingore this.
        // if we are doing an AND or a nOT, it is an error
        // otherwise, devise a simple index and use it
        //

        if(fParentFilterType == FILTER_CHOICE_OR) {
            return OPT_FILTER_VALUE_IGNORE;
        }
        else if (fParentFilterType == FILTER_CHOICE_AND ||
                 fParentFilterType == FILTER_CHOICE_NOT) {
                    return OPT_FILTER_VALUE_ERROR;
        }
        else {
            // Pick an index, any index, which is simple to walk, and that
            // we can restrict to a single entry.  Here, we use the DNT
            // index and restrict to the base object.  That way, we don't
            // upset the rest of the code that walks indices during
            // searches, but we only look at one object ever.

            *ptype = ATT_OBJ_DIST_NAME;
            if (fFullValues) {
                *ppVal2 = *ppVal1 = (BYTE *)&pTHStls->pDB->Key.ulSearchRootDnt;
                *pcbVal2 = *pcbVal1 = sizeof(DWORD);
            }
        }
        break;

    default:
        // Hey, this isn't really optimizable
        return OPT_FILTER_VALUE_ERROR;
    }

    return OPT_FILTER_VALUE_OK;
}

BOOL
IsFilterOptimizable (
    THSTATE *pTHS,
    FILTER  *pFil)
{
    ATTCACHE   *pAC = NULL;
    ATTRTYP     type = -1;  // init to non-existent attid
    UCHAR      *pVal1;
    UCHAR      *pVal2;
    ULONG       cbVal1;
    ULONG       cbVal2;
    DWORD       filterSubType;

    // when the filter is of type ITEM, we can only optimize it if it
    // is of one of the following subtypes.
    if ( pFil->choice == FILTER_CHOICE_ITEM ) {

        if(  ( (filterSubType = pFil->FilterTypes.Item.choice) == FI_CHOICE_EQUALITY) ||
             (filterSubType == FI_CHOICE_SUBSTRING)     ||
             (filterSubType == FI_CHOICE_GREATER)       ||
             (filterSubType == FI_CHOICE_GREATER_OR_EQ) ||
             (filterSubType == FI_CHOICE_LESS)          ||
             (filterSubType == FI_CHOICE_LESS_OR_EQ)    ||
             (filterSubType == FI_CHOICE_PRESENT)       ||
             (filterSubType == FI_CHOICE_BIT_OR)        ||
             (filterSubType == FI_CHOICE_BIT_AND)     ) {

            // See if this item is indexed.
            if (dbMakeValuesForOptimizedFilter (pTHS,
                                                FILTER_CHOICE_ITEM,
                                                FALSE,
                                                pFil,
                                                NULL,
                                                &type,
                                                &pVal1,
                                                &pVal2,
                                                &cbVal1,
                                                &cbVal2) == OPT_FILTER_VALUE_OK) {

                // find the att in schema cache
                if (!(pAC = SCGetAttById(pTHS, type))) {
                    DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, type);
                }
                // check if we have an index on this property so we can optimize it
                //
                else if (   (pAC->fSearchFlags & fATTINDEX) ||
                            (pAC->fSearchFlags & fPDNTATTINDEX &&
                             pTHS->pDB->Key.ulSearchType == SE_CHOICE_IMMED_CHLDRN) ){

                    return TRUE;
                }
                // if this is an equality match on a linked attr then we can
                // use an index on the link table
                else if (filterSubType == FI_CHOICE_EQUALITY && pAC->ulLinkID) {
                    return TRUE;
                }


                // we already have an index for this which is used in dbSetToIndex
                if (pAC->id == ATT_OBJ_DIST_NAME) {
                    return TRUE;
                }
            }

            //
            // If it's a SUBSTRING filter there may be a tuple index.
            //
            if (filterSubType == FI_CHOICE_SUBSTRING) {
                // find the att in schema cache
                if (!pAC && !(pAC = SCGetAttById(pTHS, pFil->FilterTypes.Item.FilTypes.pSubstring->type))) {
                    DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, type);
                }
                // check if we have an index on this property so we can optimize it
                //
                else if (pAC->fSearchFlags & fTUPLEINDEX) {

                    return TRUE;
                }
            }
        }
    }
    // this filter has something other than an ITEM, or it is not optimizable

    return FALSE;
}


DWORD
dbOptOrFilter (
        DBPOS *pDB,
        DWORD Flags,
        KEY_INDEX **ppBestIndex,
        FILTER *pFil
        )
/*++
    The filter is an OR of at least one index property.  Create the list of
    index ranges for this filter.

--*/
{
    DWORD      count1, count2;
    ATTCACHE  *pAC;
    ATTRTYP    type;
    UCHAR     *pVal1;
    UCHAR     *pVal2;
    ULONG      cbVal1;
    ULONG      cbVal2;
    BOOL       fPDNT;
    char       szIndexName[MAX_INDEX_NAME];
    FILTER    *pFilTemp, *pFilTemp2;
    BOOL       fNotIndexable = TRUE;
    KEY_INDEX *pAndIndex=NULL;
    KEY_INDEX *pNewIndex=NULL;
    KEY_INDEX *pIndices=NULL;
    THSTATE    *pTHS=pDB->pTHS;
    INDEX_RANGE IndexRange;
    BOOL        needRecordCount;
    KEY_INDEX *pTemp1, *pTemp2;
    DWORD      err;

    Assert(VALID_DBPOS(pDB));
    Assert(ppBestIndex);

    DPRINT(2, "dbOptORFilter: entering OR\n");

    // Preliminary check, that the or is over only ITEM filters or
    // AND filters which contain at least one indexable item.
    // If the OR filter is over AND filters that cannot be indexed,
    // there is no meaning in continuing with the optimization
    // and we can fallback to the default index (Ancestors).  Also,
    // check for OR terms that are TRUE as these cause the OR
    // filter to not be optimizable
    count1 = pFil->FilterTypes.Or.count;
    for (pFilTemp = pFil->FilterTypes.Or.pFirstFilter; count1;
         count1--, pFilTemp = pFilTemp->pNextFilter) {

        switch(pFilTemp->choice) {
        case FILTER_CHOICE_ITEM:
            if (pFil->FilterTypes.Item.choice == FI_CHOICE_TRUE) {
                DPRINT(2, "dbOptOrFilter: TRUE ITEM Branch not optimizable\n");
                return 0;
            }
            break;

        case FILTER_CHOICE_AND:
            // This is optimizable if there is at least one indexed
            // attribute in the AND.
            fNotIndexable = TRUE;
            count2 = pFilTemp->FilterTypes.And.count;
            for (pFilTemp2 = pFilTemp->FilterTypes.And.pFirstFilter;
                 (fNotIndexable && count2);
                 count2--, pFilTemp2 = pFilTemp2->pNextFilter) {

                if(pFilTemp2->choice == FILTER_CHOICE_ITEM) {

                    // See if this item is indexed.

                    if (dbMakeValuesForOptimizedFilter (pTHS,
                                                        FILTER_CHOICE_AND,
                                                        FALSE,
                                                        pFilTemp2,
                                                        NULL,
                                                        &type,
                                                        &pVal1,
                                                        &pVal2,
                                                        &cbVal1,
                                                        &cbVal2) == OPT_FILTER_VALUE_OK) {

                        // find the att in schema cache
                        if (!(pAC = SCGetAttById(pTHS, type))) {
                            DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, type);
                        }
                        // well, this is an indication that there is some kind of index
                        // on this attribute. if not, we will error later
                        else if ((pAC->fSearchFlags & fATTINDEX) ||
                                 (pAC->fSearchFlags & fPDNTATTINDEX &&
                                  pDB->Key.ulSearchType == SE_CHOICE_IMMED_CHLDRN)) {
                            fNotIndexable = FALSE;
                        }
                        // if this is an equality filter on a linked attr then
                        // we can use an index on the link table
                        else if (pFilTemp2->FilterTypes.Item.choice == FI_CHOICE_EQUALITY &&
                                pAC->ulLinkID) {
                            fNotIndexable = FALSE;
                        }
                    }
                    else if (pFilTemp2->FilterTypes.Item.choice == FI_CHOICE_UNDEFINED) {
                        // this is an AND with an Undefined term. continue as usual
                        fNotIndexable = FALSE;
                    }
                }
            }
            if(fNotIndexable) {
                DPRINT1 (2, "dbOptOrFilter: AND Branch not optimizable (no index for attribute: 0x%x)\n", type);
                return 0;
            }
            break;
        default:
            // Not optimizable
            DPRINT(2, "dbOptOrFilter: Branch not optimizable \n");
            return 0;
            break;
        }
    }

    // Now, loop over each index and get the key_index structure.
    count1 = pFil->FilterTypes.Or.count;
    for (pFil = pFil->FilterTypes.Or.pFirstFilter;
         count1;
         count1--, pFil = pFil->pNextFilter) {

        switch(pFil->choice) {
        case FILTER_CHOICE_ITEM:
            DPRINT(2, "dbOptOrFilter: ITEM \n");
            break;
        case FILTER_CHOICE_AND:

            // We already know that at least one of the things in this index
            // should be indexable. call dbOptFilter to do the hard work.
            // if it return an error, then we forget all the indexes,
            // otherwise we continue with the next filter.

            err = dbOptAndFilter(pDB,
                                 Flags,
                                 &pAndIndex,
                                 pFil);

            if (err) {
                    DPRINT (2, "dbOptOrFilter: Error Optimizing AND branch\n");

                    // we had an error optimizing this branch, exit optimization
                    dbFreeKeyIndex(pTHS, pIndices);
                    return 0;
            }
            else if(!pAndIndex) {
                // we didn't had an error optimizing this branch, but we got no
                // result to work with. try next one, since we are in an OR

                DPRINT (2, "dbOptOrFilter: AND branch not optimizable\n");

                // ISSUE-2002/03/06-andygo:  unreachable code
                // REVIEW:  I think this branch is dead code.  if it isn't then we will fail to eval some
                // REVIEW:  objects for inclusion in the result set or worse yet, behave unpredictably!
                // REVIEW:  if we get here then the filter is not optimizable and we should return 0
                // REVIEW:  BTW, this code branch is ancient! (at least Win2k)
                continue;
            }

            break;
        default:
            // Huh? how did this get here?
            DPRINT(2, "dbOptOrFilter: OTHER->ERROR \n");
            dbFreeKeyIndex(pTHS, pIndices);
            return DB_ERR_NOT_OPTIMIZABLE;
        }

        if(pAndIndex) {
            // we did an and optimization

            #if DBG

            {
            KEY_INDEX *pIndex = pAndIndex;

                while(pIndex) {
                    if(pIndex->szIndexName) {
                        DPRINT1 (2, "dbOptOrFilter: AND queue index %s\n", pIndex->szIndexName);
                    }
                    pIndex = pIndex->pNext;
                }
            }
            #endif

            pNewIndex = pAndIndex;
            pAndIndex = NULL;
        }
        else {
            // A normal Item optimization

            pNewIndex = NULL;

            // this is a false or undefined in the OR. skip it
            if (pFil->FilterTypes.Item.choice == FI_CHOICE_FALSE ||
                pFil->FilterTypes.Item.choice == FI_CHOICE_UNDEFINED) {
                continue;
            }

            if (pFil->FilterTypes.Item.choice == FI_CHOICE_SUBSTRING) {
                err = dbOptSubstringFilter(pDB,
                                           FILTER_CHOICE_OR,
                                           Flags,
                                           &pNewIndex,
                                           NULL,
                                           pFil);
            } else {
                err = dbOptItemFilter(pDB,
                                      FILTER_CHOICE_OR,
                                      Flags,
                                      &pNewIndex,
                                      pFil,
                                      NULL);
            }

            // we didn't manage to find an index for this item
            //
            if (err || !pNewIndex) {
                DPRINT(2, "dbOptOrFilter: Couldn't optimize ITEM filter.\n");
                dbFreeKeyIndex(pTHS, pIndices);
                return DB_ERR_NOT_OPTIMIZABLE;
            }
        }

        if(pIndices) {
            // Note that ulEstimatedRecsInRange is the estimate of ALL the
            // records in range in the rest of the indices in the chain.
            ULONG ulEstimatedRecsInRangeSum = pNewIndex->ulEstimatedRecsInRange + pIndices->ulEstimatedRecsInRange;
            if (ulEstimatedRecsInRangeSum < pNewIndex->ulEstimatedRecsInRange) {
                ulEstimatedRecsInRangeSum = -1;  //  trap overflow
            }
            pNewIndex->ulEstimatedRecsInRange = ulEstimatedRecsInRangeSum;

            DPRINT1(2, "dbOptOrFilter: TOTAL in OR: %d \n", pNewIndex->ulEstimatedRecsInRange);
        }

        // we have a queue of indexes, so add the indexes in the correct place

        pTemp1 = pNewIndex;
        pTemp2 = NULL;

        while(pTemp1) {
            pTemp2 = pTemp1;
            pTemp1 = pTemp1->pNext;
        }

        Assert (pTemp2);

        pTemp2->pNext = pIndices;
        pIndices = pNewIndex;

        if(*ppBestIndex &&
           (pNewIndex->ulEstimatedRecsInRange >
            (*ppBestIndex)->ulEstimatedRecsInRange)) {
            // Darn, this OR is bigger than the best we had so far.

            DPRINT(2, "dbOptOrFilter: BIGGER than best so far\n");
            dbFreeKeyIndex(pTHS, pIndices);
            return 0;
        }
    }

    if(*ppBestIndex) {
        DPRINT2(2, "dbOptOrFilter: freeing previous filter %s %d\n",(*ppBestIndex)->szIndexName, (*ppBestIndex)->ulEstimatedRecsInRange);
        dbFreeKeyIndex(pTHS, *ppBestIndex);
    }

    *ppBestIndex = pIndices;

#if DBG

    {
        KEY_INDEX *pIndex = pIndices;

        while(pIndex) {
            if(pIndex->szIndexName) {
                DPRINT1 (2, "dbOptOrFilter: queue index %s\n", pIndex->szIndexName);
            }
            pIndex = pIndex->pNext;
        }
    }

#endif

    return 0;
}

DWORD
dbOptDoIntersection (
        DBPOS     *pDB,
        DWORD     Flags,
        KEY_INDEX **ppBestIndex,
        KEY_INDEX **ppIntersectIndexes,
        int       cntIntersect
        )
/*++
    The filter is an AND of indexed properties.
    Try evaluating this filter using JetIntersectIndexes.
--*/
{
    THSTATE     *pTHS=pDB->pTHS;
    USHORT       count;
    JET_ERR      err = JET_errSuccess;
    BOOL         fReturnSuccess = FALSE;

    KEY_INDEX    *pIndex = NULL;

    JET_RECORDLIST  recordlist = {sizeof(JET_RECORDLIST)};
    JET_INDEXRANGE      *rgindexrange;

    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;


    Assert (cntIntersect >= 2);

    DPRINT1 (2, "dbOptDoIntersection: Attempting intersection of %d indexes\n", cntIntersect);

#ifdef DBG
    DPRINT(2, "Intersecting the following indexes: \n");
    for (count=0; count<cntIntersect; count++) {
        DPRINT2(2, "  %s %d\n", ppIntersectIndexes[count]->szIndexName, ppIntersectIndexes[count]->ulEstimatedRecsInRange);
    }
#endif

    rgindexrange = dbAlloc (sizeof (JET_INDEXRANGE) * cntIntersect);
    // NOTICE-2002/03/06-andygo:  unreachable code
    // REVIEW:  this branch is dead code
    if (!rgindexrange) {
        return 1;
    }
    // NOTICE-2002/03/06-andygo:  unnecessary code
    // REVIEW:  this memset is unnecessary
    memset (rgindexrange, 0, sizeof (JET_INDEXRANGE) * cntIntersect);

    __try {
        for (count=0; count < cntIntersect; count++ ){

            pIndex = ppIntersectIndexes[count];

            // get a duplicate cursor over the table containing this index
            if (err = JetDupCursor(pDB->JetSessID,
                                    (pIndex->pAC && pIndex->pAC->ulLinkID ?
                                        pDB->JetLinkTbl :
                                        pDB->JetSearchTbl),
                                    &rgindexrange[count].tableid,
                                    0)) {

                rgindexrange[count].tableid = 0;
                break;
            }

            rgindexrange[count].cbStruct = sizeof( JET_INDEXRANGE );
            rgindexrange[count].grbit = JET_bitRecordInIndex;


            // set to appropriate index
            //

            JetSetCurrentIndex4Success(pDB->JetSessID,
                                    rgindexrange[count].tableid,
                                    pIndex->szIndexName,
                                    pIndex->pindexid,
                                    JET_bitMoveFirst);


            // Move to the start of this index
            //
            if (pIndex->cbDBKeyLower) {
                JetMakeKeyEx(pDB->JetSessID,
                                rgindexrange[count].tableid,
                                pIndex->rgbDBKeyLower,
                                pIndex->cbDBKeyLower,
                                JET_bitNormalizedKey);

                // this call might fail, if we can't find any records
                err = JetSeekEx(pDB->JetSessID,
                                    rgindexrange[count].tableid,
                                    JET_bitSeekGE);
            }
            else {
                // this call might fail, if we can't find any records
                err = JetMoveEx(pDB->JetSessID,
                                    rgindexrange[count].tableid,
                                    JET_MoveFirst, 0);
            }

            if ((err == JET_errSuccess) ||
                (err == JET_wrnRecordFoundGreater)) {

                // move to the upper bound
                if (pIndex->cbDBKeyUpper) {

                    JetMakeKeyEx( pDB->JetSessID,
                            rgindexrange[count].tableid,
                            pIndex->rgbDBKeyUpper,
                            pIndex->cbDBKeyUpper,
                            JET_bitNormalizedKey );

                    err = JetSetIndexRangeEx( pDB->JetSessID,
                                              rgindexrange[count].tableid,
                                              JET_bitRangeUpperLimit | JET_bitRangeInclusive
                                              );
                    // REVIEW:  if we get JET_errNoCurrentRecord here then we should return an
                    // REVIEW:  empty index range (BOF->BOF) as the new best index
                    err = JET_errSuccess;
                }
            }

            else {
                // REVIEW:  if we get JET_errNoCurrentRecord here then we should return an
                // REVIEW:  empty index range (BOF->BOF) as the new best index

                // no records. so there is no point in intersecting

                // we should flag this function as succesfull, since the fact that
                // we found no records in the AND filter is not bad.
                // as a result the passed in BestIndex remains the same
                fReturnSuccess = TRUE;

                break;
            }
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);

        DPRINT1 (2, "Failed while preparing AND intersection at %d index\n", count);

        err = 1;
    }


    __try {
        if (!err) {
            // They should be the same. otherwise we shouldn't be here
            Assert ( count == cntIntersect );

            DPRINT1 (2, "Intersecting %d indexes\n", cntIntersect);

            // do the intersection of these indexes
            // NTRAID#NTRAID-560446-2002/02/28-andygo:  SECURITY:  a really wide AND/OR term in a filter can be used to consume all resources on a DC
            // REVIEW:  we need to check for the search time limit and the temp table size limit
            // REVIEW:  in JetIntersectIndexes to prevent huge resource consumption during the
            // REVIEW:  optimization phase of a search
            if (!(err = JetIntersectIndexesEx( pDB->JetSessID,
                                               rgindexrange,
                                               cntIntersect,
                                               &recordlist,
                                               0) ) )
            {
                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_QUERY_INDEX_CONSIDERED,
                         szInsertSz(c_szIntersectIndex),   // maybe construct full string
                         szInsertUL(recordlist.cRecord),
                         NULL);

                DPRINT1 (2, "Estimated intersect index size: %d\n", recordlist.cRecord);

                // see if it has better results than what we have so far
                //
                if(!(*ppBestIndex) ||
                   (recordlist.cRecord < (*ppBestIndex)->ulEstimatedRecsInRange)) {
                    // yes - it sure looks that way...

                    if(*ppBestIndex) {
                        dbFreeKeyIndex(pDB->pTHS, *ppBestIndex);
                    }
                    pIndex = *ppBestIndex = dbAlloc(sizeof(KEY_INDEX));
                    pIndex->pNext = NULL;
                    pIndex->bFlags = 0;
                    pIndex->ulEstimatedRecsInRange = recordlist.cRecord;
                    pIndex->szIndexName = dbAlloc(cIntersectIndex + 1);
                    strcpy(pIndex->szIndexName, c_szIntersectIndex);
                    pIndex->pindexid = NULL;

                    pIndex->bIsIntersection = TRUE;
                    pIndex->tblIntersection = recordlist.tableid;
                    Assert (pIndex->tblIntersection);
                    pIndex->columnidBookmark = recordlist.columnidBookmark;

                    #if DBG
                    pDB->numTempTablesOpened++;
                    #endif
                }
                else {
                    // REVIEW:  CONSIDER:  log the fact that we wasted time doing an index intersection

                    // nop. it is not good, so close temp table
                    JetCloseTable (pDB->JetSessID, recordlist.tableid );
                    recordlist.tableid = 0;
                }
            }
            else {
                Assert(err = JET_errNoCurrentRecord);

                // REVIEW:  if we get JET_errNoCurrentRecord here then we should return an
                // REVIEW:  empty index range (BOF->BOF) as the new best index

                // this means that the Intersect found no common record on both indexes. cool.
                err = JET_errSuccess;
            }
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);

        DPRINT1 (0, "Failed while doing AND intersection for %d indexes\n", cntIntersect);

        if (recordlist.tableid != 0 && recordlist.tableid != JET_tableidNil) {
            JetCloseTable(pDB->JetSessID, recordlist.tableid);
        }
    }

    // free stuff. close tables
    for (count=0; count<cntIntersect; count++) {
        if (rgindexrange[count].tableid) {
            JetCloseTable (pDB->JetSessID, rgindexrange[count].tableid);
        }
    }
    dbFree (rgindexrange);

    if (fReturnSuccess) {
        err = JET_errSuccess;
    }

    // done
    return err;
}

DWORD
dbOptAndIntersectFilter (
        DBPOS     *pDB,
        DWORD     Flags,
        KEY_INDEX **ppBestIndex,
        KEY_INDEX **ppIntersectIndexes,
        DWORD     cntPossIntersect
        )
/*++
    Takes a set of indexes that can potentially be intersected, puts the indexes
    in order, determines whether intersection is warranted, and if so performs
    the intersection.  This function has the side affect of sorting the list of
    indexes passed in.
--*/
{
    THSTATE     *pTHS=pDB->pTHS;

    DWORD       count, count2;
    DWORD       err = 0;
    BOOL        fNotAbleToIntersect = FALSE;

    if (cntPossIntersect < 2) {
        if (cntPossIntersect == 0) {
            return err;
        }
        fNotAbleToIntersect = TRUE;
    }

    // sort the array of candidate indexes on EstimatedRecsInRange
    //

    DPRINT(2, "dbOptAndIntersectFilter: Sorting Array\n");

    for (count=0; count<(cntPossIntersect-1); count++) {
        ULONG numRecs;
        KEY_INDEX  *tmpIndex;

        // NOTICE-2002/03/06-andygo:  unreachable code
        // REVIEW:  it is not possible to have a NULL entry in this array.  if we allowed this
        // REVIEW:  then this sort would malfunction and cause the subsequent code to fail
        if (!ppIntersectIndexes[count]) {
            continue;
        }

        numRecs = ppIntersectIndexes[count]->ulEstimatedRecsInRange;

        for (count2=count+1; count2<cntPossIntersect; count2++) {

            // NOTICE-2002/03/06-andygo:  unreachable code
            // REVIEW:  it is not possible to have a NULL entry in this array.  if we allowed this
            // REVIEW:  then this sort would malfunction and cause the subsequent code to fail
            if (ppIntersectIndexes[count2] &&
                ppIntersectIndexes[count2]->ulEstimatedRecsInRange < numRecs) {

                tmpIndex = ppIntersectIndexes[count];
                ppIntersectIndexes[count] = ppIntersectIndexes[count2];
                ppIntersectIndexes[count2] = tmpIndex;

                numRecs = ppIntersectIndexes[count]->ulEstimatedRecsInRange;
            }
        }
    }

#if DBG
    // the best index should be in pos 0
    // the worst index should be in pos cntPossIntersect-1
    for (count=1; count<cntPossIntersect-1; count++) {
        if (  (ppIntersectIndexes[count]->ulEstimatedRecsInRange <
               ppIntersectIndexes[0]->ulEstimatedRecsInRange)             ||
              (ppIntersectIndexes[cntPossIntersect-1]->ulEstimatedRecsInRange <
               ppIntersectIndexes[count]->ulEstimatedRecsInRange)           ) {

            Assert (!"Sort Order Bad\n");
        }
    }
#endif


    // we cannot use index intersection when:
    // a) the number of optimizable indexes is less that two
    // b) global flags say so
    // c) we already have an index that is small enough without intersection.
    // d) the smallest index range is so large that we might as well walk the
    //    entire DIT
    // this is a double negation, but it is better than an AND with 4 components

    fNotAbleToIntersect =  fNotAbleToIntersect ||
                           (Flags & DBOPTINDEX_fDONT_INTERSECT) ||
                           cntPossIntersect<2 ||
                           !gfUseIndexOptimizations ||
                           ppIntersectIndexes[0]->ulEstimatedRecsInRange < gulMaxRecordsWithoutIntersection ||
                           ppIntersectIndexes[0]->ulEstimatedRecsInRange > gulEstimatedAncestorsIndexSize ||
                           gulEstimatedAncestorsIndexSize - ppIntersectIndexes[0]->ulEstimatedRecsInRange < gulEstimatedAncestorsIndexSize / 10;


    // check the result of all indexes and try to find the ratio between
    // the best and the worst one, and decide whether it is worth it to
    // go for the brute force way (visiting each entry), or is better for
    // Jet to cut some entries (using Intersections)
    //
    if (!fNotAbleToIntersect) {

        // the best index should be in pos 0 due to sorting
        // the worst index should be in pos cntIntersect-1
        //
        DWORD cntIntersect;
        DWORD cutoff;

        DPRINT(2, "dbOptAndIntersectFilter: Investigating use of Intersections\n");

        // the largest index range we will use in the intersection must be less
        // than gulIntersectExpenseRatio times the size of the smallest index
        // range
        cutoff = ppIntersectIndexes[0]->ulEstimatedRecsInRange * gulIntersectExpenseRatio;
        // if this overflowed then accept all index ranges
        if (cutoff < ppIntersectIndexes[0]->ulEstimatedRecsInRange) {
            cutoff = -1;
        }

        for (cntIntersect = 1; cntIntersect < cntPossIntersect; cntIntersect++) {
            if (ppIntersectIndexes[cntIntersect]->ulEstimatedRecsInRange > cutoff) {
                break;
            }
        }

        if (cntIntersect < 2) {
            fNotAbleToIntersect = TRUE;
            DPRINT(2, "dbOptAndIntersectFilter: Intersection not advisable.\n");
        } else {
            // do not try to intersect too many indices at once
            cntIntersect = min(cntIntersect, MAX_NUMBER_INTERSECTABLE_INDEXES);

            DPRINT1(2, "dbOptAndIntersectFilter: Attempting to intersect %d indexes\n", cntIntersect);
            err = dbOptDoIntersection(pDB,
                          FALSE,
                          ppBestIndex,
                          ppIntersectIndexes,
                          cntIntersect);
        }
    }

    // If we managed to do an intersection then that is the best index to return.
    // Other wise compare the first index in the list to ppBestIndex and return
    // the best one.
    if (fNotAbleToIntersect) {
        if(!(*ppBestIndex)
           || (*ppBestIndex)->ulEstimatedRecsInRange < ppIntersectIndexes[0]->ulEstimatedRecsInRange) {
            dbFreeKeyIndex(pTHS, *ppBestIndex);
            *ppBestIndex = ppIntersectIndexes[0];
            ppIntersectIndexes[0] = NULL;
        }
    }

    return err;
}

// This is the the min tuple length in bytes for unicode strings, the only syntax
// currently supported.
#define DB_UNICODE_TUPLES_LEN_MIN  (sizeof(WCHAR) * DB_TUPLES_LEN_MIN)


DWORD
dbOptSubstringFilter (
        DBPOS *pDB,
        DWORD  fParentFilterType,
        DWORD Flags,
        KEY_INDEX **ppBestIndex,
        DWORD  *pIndexCount,
        FILTER *pFil
        )
/*++
    This filter is a SUBSTRING filter which can be made up of several parts.
    Create the list of index ranges for this filter.

    If the caller passed a value for pIndexCount, return the list of indexes
    so that the caller can decide whether to intersect the substring indexes
    with any other indexes available from an AND clause.

    Otherwise if pIndexCount is NULL, decide whether to intersect just these
    indexes and return either the intersected index, or the best index out of
    the list of indexes.

    For the time being this function only picks the best of the tuple index
    ranges.  It might make sense to revisit this if support is ever added in
    Jet for intersecting an index range with another index range on the same
    index.

--*/
{
    THSTATE         *pTHS=pDB->pTHS;

    DWORD           err;
    DWORD           countIndexes = 0;
    DWORD           count;
    BOOL            fTupleIndex = FALSE;
    KEY_INDEX       *pLocalBestIndex = NULL;
    KEY_INDEX       *pIndexList, *pTempIndex, *pCurIndex;
    KEY_INDEX       *pBestTupleIndex = NULL;
    KEY_INDEX       **ppIntersectIndexes;
    SUBSTRING       *pSubstring;
    INDEX_RANGE     IndexRange;
    ATTCACHE        *pAC;
    // NOTICE-2002/03/06-andygo:  unreachable code
    // REVIEW:  dbMakeKeyIndex never returns NULL so fError is always FALSE
    BOOL            fError = FALSE;

    pSubstring = pFil->FilterTypes.Item.FilTypes.pSubstring;

    // find the att in schema cache
    if (!(pAC = SCGetAttById(pTHS, pSubstring->type))) {
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, pSubstring->type);
    }

    // Get any initial string index if one exists.
    err = dbOptItemFilter(pDB, fParentFilterType, Flags, &pLocalBestIndex, pFil, NULL);

    if (Flags & DBOPTINDEX_fDONT_OPT_MEDIAL_SUBSTRING) {
        goto LeaveOnNoTupleIndex;
    }

    if (pSubstring->AnyVal.count || pSubstring->finalProvided || !pLocalBestIndex) {
        // Find out if there is a tuple index for this attribute.
        fTupleIndex = dbSetToTupleIndex(pDB, pAC);
    }

    if ( !fTupleIndex
         || (pLocalBestIndex
             && !pSubstring->finalProvided
             && !pSubstring->AnyVal.count)) {
        //
        // One of two cases:
        // 1. There's only an initial substring filter and we have an index for
        // it from dbOptItemFilter.
        // 2. There's no tuple index so there's no point in continuing.
        // See if we've managed to get a better index and then return.
        //
        goto LeaveOnNoTupleIndex;
    }

    // At this point we know that we have a Tuple index.

    if (!pLocalBestIndex
        && pSubstring->initialProvided
        && pSubstring->InitialVal.valLen >= DB_UNICODE_TUPLES_LEN_MIN) {
        // There's an initial substring, but we don't have a regular index
        // over this attribute.  If the initial substring is long enough
        // we'll use the tuple index instead.

        IndexRange.cbValLower = pSubstring->InitialVal.valLen;
        IndexRange.pvValLower = pSubstring->InitialVal.pVal;
        IndexRange.cbValUpper = pSubstring->InitialVal.valLen;
        IndexRange.pvValUpper = pSubstring->InitialVal.pVal;

        pTempIndex =
            dbMakeKeyIndex(pDB,
                           pFil->FilterTypes.Item.choice,
                           pAC->isSingleValued,
                           0,
                           pAC->pszTupleIndex,
                           pAC->pidxTupleIndex,
                           DB_MKI_GET_NUM_RECS,
                           1,  // only one component in the index range
                           &IndexRange
                           );
        // NOTICE-2002/03/06-andygo:  unreachable code
        // REVIEW:  dbMakeKeyIndex never returns NULL so this if branch is dead code
        if (!pTempIndex) {
            DPRINT1(0, "dbOptSubstringFilter: Failed to create KEY_INDEX for tuple index on att %s\n",
                    pAC->name);
            goto LeaveOnNoTupleIndex;
        } else {
            pTempIndex->pAC = pAC;
            pTempIndex->bIsTupleIndex = TRUE;

            if (!pBestTupleIndex
                || pBestTupleIndex->ulEstimatedRecsInRange > pTempIndex->ulEstimatedRecsInRange) {
                dbFreeKeyIndex(pTHS, pBestTupleIndex);
                pBestTupleIndex = pTempIndex;
            }
        }

    }

    //
    // Build KEY_INDEXES for medial substring filters.
    //
    if (pSubstring->AnyVal.count) {
        ANYSTRINGLIST   *pAnyString;

        if (pSubstring->AnyVal.FirstAnyVal.AnyVal.valLen >= DB_UNICODE_TUPLES_LEN_MIN) {
            // Get the first medial substring.
            IndexRange.cbValLower = pSubstring->AnyVal.FirstAnyVal.AnyVal.valLen;
            IndexRange.pvValLower = pSubstring->AnyVal.FirstAnyVal.AnyVal.pVal;
            IndexRange.cbValUpper = pSubstring->AnyVal.FirstAnyVal.AnyVal.valLen;
            IndexRange.pvValUpper = pSubstring->AnyVal.FirstAnyVal.AnyVal.pVal;

            pTempIndex =
                dbMakeKeyIndex(pDB,
                               pFil->FilterTypes.Item.choice,
                               pAC->isSingleValued,
                               0,
                               pAC->pszTupleIndex,
                               pAC->pidxTupleIndex,
                               DB_MKI_GET_NUM_RECS,
                               1,  // only one component in the index range
                               &IndexRange
                               );
            // NOTICE-2002/03/06-andygo:  unreachable code
            // REVIEW:  dbMakeKeyIndex never returns NULL so this if branch is dead code
            if (!pTempIndex) {
                DPRINT1(0, "dbOptSubstringFilter: Failed to create KEY_INDEX for tuple index on att %s\n",
                        pAC->name);
                fError = TRUE;
            } else {
                pTempIndex->pAC = pAC;
                pTempIndex->bIsTupleIndex = TRUE;

                if (!pBestTupleIndex
                    || pBestTupleIndex->ulEstimatedRecsInRange > pTempIndex->ulEstimatedRecsInRange) {
                    dbFreeKeyIndex(pTHS, pBestTupleIndex);
                    pBestTupleIndex = pTempIndex;
                }
            }
        }


        // NOTICE-2002/03/06-andygo:  unreachable code
        // REVIEW:  dbMakeKeyIndex never returns NULL so fError is always FALSE
        if (!fError) {
            pAnyString = pSubstring->AnyVal.FirstAnyVal.pNextAnyVal;

            // Get the rest of the medial substrings.
            while (pAnyString) {

                // If the substring is too small don't bother
                // making a KEY_INDEX
                if (pAnyString->AnyVal.valLen >= DB_UNICODE_TUPLES_LEN_MIN) {

                    IndexRange.cbValLower = pAnyString->AnyVal.valLen;
                    IndexRange.pvValLower = pAnyString->AnyVal.pVal;
                    IndexRange.cbValUpper = pAnyString->AnyVal.valLen;
                    IndexRange.pvValUpper = pAnyString->AnyVal.pVal;

                    pTempIndex =
                        dbMakeKeyIndex(pDB,
                                       pFil->FilterTypes.Item.choice,
                                       pAC->isSingleValued,
                                       0,
                                       pAC->pszTupleIndex,
                                       pAC->pidxTupleIndex,
                                       DB_MKI_GET_NUM_RECS,
                                       1,  // only one component in the index range
                                       &IndexRange
                                       );

                    if (pTempIndex) {
                        pTempIndex->pAC = pAC;
                        pTempIndex->bIsTupleIndex = TRUE;
                        if (!pBestTupleIndex
                            || pBestTupleIndex->ulEstimatedRecsInRange > pTempIndex->ulEstimatedRecsInRange) {
                            dbFreeKeyIndex(pTHS, pBestTupleIndex);
                            pBestTupleIndex = pTempIndex;
                        }
                    // NOTICE-2002/03/06-andygo:  unreachable code
                    // REVIEW:  dbMakeKeyIndex never returns NULL so this else branch is dead code
                    } else {
                        //
                        // There's no reason to continue.
                        //
                        DPRINT1(0, "dbOptSubstringFilter: Failed to create KEY_INDEX for tuple index on att %s\n",
                                pAC->name);
                        pAnyString = NULL;
                        fError = TRUE;
                    }
                }
                // move to the next medial substring
                pAnyString = pAnyString->pNextAnyVal;
            }
        }

    }

    // If there is a final substring set that up.
    // NOTICE-2002/03/06-andygo:  unreachable code
    // REVIEW:  dbMakeKeyIndex never returns NULL so fError is always FALSE
    if (!fError
        && pSubstring->finalProvided
        && pSubstring->FinalVal.valLen >= DB_UNICODE_TUPLES_LEN_MIN) {

        IndexRange.cbValLower = pSubstring->FinalVal.valLen;
        IndexRange.pvValLower = pSubstring->FinalVal.pVal;
        IndexRange.cbValUpper = pSubstring->FinalVal.valLen;
        IndexRange.pvValUpper = pSubstring->FinalVal.pVal;

        pTempIndex =
        dbMakeKeyIndex(pDB,
                       pFil->FilterTypes.Item.choice,
                       pAC->isSingleValued,
                       0,
                       pAC->pszTupleIndex,
                       pAC->pidxTupleIndex,
                       DB_MKI_GET_NUM_RECS,
                       1,  // only one component in the index range
                       &IndexRange
                      );

        // NOTICE-2002/03/06-andygo:  unreachable code
        // REVIEW:  dbMakeKeyIndex never returns NULL so this if branch is dead code
        if (!pTempIndex) {
            DPRINT1(0, "dbOptSubstringFilter: Failed to create KEY_INDEX for tuple index on att %s\n",
                    pAC->name);
        } else {
            pTempIndex->pAC = pAC;
            pTempIndex->bIsTupleIndex = TRUE;
            if (!pBestTupleIndex
                || pBestTupleIndex->ulEstimatedRecsInRange > pTempIndex->ulEstimatedRecsInRange) {
                dbFreeKeyIndex(pTHS, pBestTupleIndex);
                pBestTupleIndex = pTempIndex;
            }
        }
    }

    if (pBestTupleIndex) {
        countIndexes = 1;
    }
    if (pLocalBestIndex) {
        pIndexList = pLocalBestIndex;
        pIndexList->pNext = pBestTupleIndex;
        countIndexes++;
    } else {
        pIndexList = pBestTupleIndex;
    }

    // NOTICE-2002/03/06-andygo:  unreachable code
    // REVIEW:  dbMakeKeyIndex never returns NULL so fError is always FALSE
    if (fError || !pIndexList) {
        // For some reason we couldn't make use of the tuple index.
        goto LeaveOnNoTupleIndex;
    }

    //
    // We now have a list of KEY_INDEXES we can use for this filter.
    // Now decide whether to intersect them or not.
    //
    if (pIndexCount) {
        // The caller is willing to accept a list of indexes which means that
        // they are willing to attempt the intersection themselves.  Time to go
        // home.
        *pIndexCount = countIndexes;
        *ppBestIndex = pIndexList;
        DPRINT1(2, "dbOptSubstringFilter: returning a linked list of %d filters\n", countIndexes);
        return 0;
    }

    //
    // If we made it to here, then we are considering intersecting indexes.
    //

    if (countIndexes == 1) {
        DPRINT(2, "dbOptSubstringFilter: returning a single filter\n");
        //
        // There's only one index, so go ahead and return it.
        //
        pLocalBestIndex = pIndexList;
        goto LeaveOnNoTupleIndex;
    }


    // Put all the potential KEY_INDEXES pointers into an array so that they
    // can be passed to the intersection routine.
    ppIntersectIndexes = THAllocEx(pTHS, sizeof(KEY_INDEX *) * countIndexes);
    pCurIndex = pIndexList;
    for (count=0; count < countIndexes; count++) {
        ppIntersectIndexes[count] = pCurIndex;
        pCurIndex = pCurIndex->pNext;
        ppIntersectIndexes[count]->pNext = NULL;
    }

    // Intersect if possible.
    DPRINT1(2, "dbOptSubstringFilter: calling dbOptAndIntersectFilter with %d KEY_INDEX's\n", countIndexes);
    err = dbOptAndIntersectFilter (pDB,
                                   Flags,
                                   ppBestIndex,
                                   ppIntersectIndexes,
                                   countIndexes
                                   );

    // Free the rest of the indexes
    for (count=1; count<countIndexes; count++) {
        if (ppIntersectIndexes[count]) {
            dbFreeKeyIndex(pTHS, ppIntersectIndexes[count]);
        }
    }

    return err;

LeaveOnNoTupleIndex:

// Check to see if we found a better index or not.
    if (pLocalBestIndex) {
        if (!(*ppBestIndex) ||
            (*ppBestIndex)->ulEstimatedRecsInRange > pLocalBestIndex->ulEstimatedRecsInRange) {

            if (*ppBestIndex) {
                DPRINT2(2, "dbOptSubstringFilter: freeing previous filter %s %d\n",(*ppBestIndex)->szIndexName, (*ppBestIndex)->ulEstimatedRecsInRange);
                dbFreeKeyIndex(pDB->pTHS, (*ppBestIndex));
            }
            (*ppBestIndex) = pLocalBestIndex;
        } else {
            DPRINT2 (2, "dbOptSubstringFilter: Initial Index %s is NOT best so far %d\n", pLocalBestIndex->szIndexName, pLocalBestIndex->ulEstimatedRecsInRange);
            dbFreeKeyIndex(pDB->pTHS, pLocalBestIndex);
        }
        if (pIndexCount) {
            *pIndexCount = (*ppBestIndex) ? 1 : 0;
        }
    }
    return err;

}



DWORD
dbOptItemFilter (
    DBPOS    *pDB,
    DWORD     fParentFilterType,
    DWORD     Flags,
    KEY_INDEX **ppBestIndex,
    FILTER    *pFil,
    FILTER    *pFil2
    )
{
    THSTATE    *pTHS=pDB->pTHS;

    ATTCACHE   *pAC;
    ATTRTYP     type = -1;  // init to non-existent attid
    UCHAR      *pVal1;
    UCHAR      *pVal2;
    ULONG       cbVal1;
    ULONG       cbVal2;
    char        szIndexName[MAX_INDEX_NAME];
    JET_INDEXID *pindexid = NULL;
    INDEX_RANGE rgIndexRange[2] = { 0 };
    ULONG       ulLinkBase;

    BOOL        fPDNT = FALSE;
    BOOL        needRecordCount;
    KEY_INDEX  *pNewIndex = NULL;

    DPRINT(2, "dbOptItemFilter: entering ITEM\n");

    // NOTICE-2002/03/06-andygo:  LDAP filter optimization contains many potential memory leaks
    // we will leak memory allocated in dbMakeValuesForOptimizedFilter if we later
    // decide that the filter is not optimizable.  this currently only happens for
    // the bit-AND and bit-OR operators.  we would have to have a very large AND
    // or OR term containing lots of these operators to make a difference
    switch(dbMakeValuesForOptimizedFilter(pTHS,
                                          fParentFilterType,
                                          TRUE,
                                          pFil,
                                          pFil2,
                                          &type,
                                          &pVal1,
                                          &pVal2,
                                          &cbVal1,
                                          &cbVal2)) {
    case OPT_FILTER_VALUE_OK:
        // Normal Success path
        break;
    case OPT_FILTER_VALUE_IGNORE:
        // No optimization possible
        return DB_ERR_NOT_OPTIMIZABLE;
        break;

    default:
        // Huh?
        return DB_ERR_NOT_OPTIMIZABLE;
    }

    // find the att in schema cache
    if (!(pAC = SCGetAttById(pTHS, type))) {
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, type);
    }

    // if this is a linked attr then we can only optimize EQUALITY filters.  if
    // a new index is ever added to the link table that starts with link_base
    // then we could also optimize PRESENT filters

    if (pAC->ulLinkID && pFil->FilterTypes.Item.choice != FI_CHOICE_EQUALITY) {
        return DB_ERR_NOT_OPTIMIZABLE;
    }

    // if this is a linked attr then switch to its matched linked attr.  we do
    // this because a filter on member=<dn> will need to walk those values of
    // ismemberof and walk the objects corresponding to the values of member.
    // if there is no matched linked attr then we cannot optimize the filter

    if (pAC->ulLinkID) {
        pAC = SCGetAttByLinkId(pTHS, MakeMatchingLinkId(pAC->ulLinkID));
        if (!pAC) {
            return DB_ERR_NOT_OPTIMIZABLE;
        }
    }

    if(!dbSetToIndex(pDB, (Flags & DBOPTINDEX_fUSE_SHOW_IN_AB), &fPDNT, szIndexName, &pindexid, pAC)) {
        // Couldn't set to the required index

        DPRINT1(2, "dbOptItemFilter: Error setting to index %s\n", szIndexName);

        return DB_ERR_NOT_OPTIMIZABLE;
    }

     // set up the index range structure

    rgIndexRange[0].cbValLower = cbVal1;
    rgIndexRange[0].pvValLower = pVal1;
    rgIndexRange[0].cbValUpper = cbVal2;
    rgIndexRange[0].pvValUpper = pVal2;

    if (pAC->ulLinkID) {
        ulLinkBase = MakeLinkBase(pAC->ulLinkID);

        rgIndexRange[1].cbValLower = sizeof(ulLinkBase);
        rgIndexRange[1].pvValLower = &ulLinkBase;
        rgIndexRange[1].cbValUpper = sizeof(ulLinkBase);
        rgIndexRange[1].pvValUpper = &ulLinkBase;
    }

    // Now we evaluate the associated index

    // if we "know" the expected number of items for this filter
    // there is no need to try to find them, unless we supress optimizations

    needRecordCount = (pFil->FilterTypes.Item.expectedSize == 0) || !gfUseIndexOptimizations;

    pNewIndex =
        dbMakeKeyIndex(
                pDB,
                pFil->FilterTypes.Item.choice,
                pAC->isSingleValued,
                (fPDNT?dbmkfir_PDNT:(pAC->ulLinkID?dbmkfir_LINK:0)),
                szIndexName,
                pindexid,
                needRecordCount ? DB_MKI_GET_NUM_RECS : 0,
                2,
                rgIndexRange
                );

    // NOTICE-2002/03/06-andygo:  unreachable code
    // REVIEW:  dbMakeKeyIndex never returns NULL so this if branch is dead code
    if(!pNewIndex) {
        DPRINT1 (2, "dbOptItemFilter: Not optimizable ITEM: 0x%x\n", pAC->id);

        return DB_ERR_NOT_OPTIMIZABLE;
    }

    pNewIndex->pAC = pAC;

    if (!needRecordCount) {
        pNewIndex->ulEstimatedRecsInRange = pFil->FilterTypes.Item.expectedSize;
    }

    DPRINT2 (2, "dbOptItemFilter: Index %s estimated size %d\n", szIndexName, pNewIndex->ulEstimatedRecsInRange);

    pNewIndex->bIsPDNTBased = fPDNT;

    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
             DS_EVENT_SEV_VERBOSE,
             DIRLOG_QUERY_INDEX_CONSIDERED,
             szInsertSz(szIndexName),
             szInsertUL(pNewIndex->ulEstimatedRecsInRange),
             NULL);

    // is this index best so far?

    if(!(*ppBestIndex) ||
       (pNewIndex->ulEstimatedRecsInRange <
        (*ppBestIndex)->ulEstimatedRecsInRange)) {
        // yes - it sure looks that way...

        DPRINT2 (2, "dbOptItemFilter: Index %s estimated is best so far %d\n", szIndexName, pNewIndex->ulEstimatedRecsInRange);

        if(*ppBestIndex) {
            DPRINT2(2, "dbOptItemFilter: freeing previous filter %s %d\n",(*ppBestIndex)->szIndexName, (*ppBestIndex)->ulEstimatedRecsInRange);
            dbFreeKeyIndex(pDB->pTHS, *ppBestIndex);
        }
        *ppBestIndex = pNewIndex;
    }
    else {
        // Nope, free it.
        DPRINT2 (2, "dbOptItemFilter: Index %s is NOT best so far %d\n", szIndexName, pNewIndex->ulEstimatedRecsInRange);
        dbFreeKeyIndex(pDB->pTHS, pNewIndex);
    }

    return 0;
}

DWORD
dbOptAndFilter (
    DBPOS     *pDB,
    DWORD     Flags,
    KEY_INDEX **ppBestIndex,
    FILTER    *pFil
    )
{
    THSTATE    *pTHS=pDB->pTHS;
    unsigned    count, count2;
    JET_ERR     err = 0;

    ATTCACHE   *pAC;
    ATTRTYP     type = -1;  // init to non-existent attid
    UCHAR      *pVal1;
    UCHAR      *pVal2;
    ULONG       cbVal1;
    ULONG       cbVal2;
    char        szIndexName[MAX_INDEX_NAME];
    INDEX_RANGE IndexRange;

    FILTER      *pFilTemp;
    KEY_INDEX   *pNewIndex = NULL;
    KEY_INDEX    HeadSubstrIndexList, *pCurSubstrIndex;
    DWORD        dwSubstrIndexCount=0, dwTempIndexCount;

    BOOL         fOptimizationFinished = FALSE;
    BOOL         fNonIndexableComponentsPresent = FALSE;

    unsigned     cntFilters = 0;
    FILTER     **pFilArray = NULL;
    DWORD        cntPossOpt = 0;
    FILTER     **pFilPossOpt = NULL;

    KEY_INDEX  **ppIndex = NULL;
    DWORD        cRecMinLinkTbl = -1;
    DWORD        cRecMinObjTbl = -1;

    DPRINT(2, "dbOptAndFilter: entering AND\n");

    // Do this in three passes.
    // 1) Look for an Item filter that implies a PRESENCE test for
    //    DISPLAY_NAME.  If we find one, we can optimize filters over the
    //    SHOW_IN_ADDRESSBOOK attribute.  SHOW_IN_ADDRESSBOOK is indexed,
    //    but it is a compound index over SHOW_IN_ADDRESSBOOK and
    //    DISPLAY_NAME with Jet set to ignore any nulls.  The index is
    //    defined this way so the MAPI head can use it to create tables.
    //    So, before we can use it, we have to make sure that the filter
    //    will drop out items that have NULLs for DISPLAY_NAME.
    //
    // 2) Optimize the ITEMS.
    //
    // 3) Finally, go back and try for any ORs.  We do all the items first
    //    since we have to check them anyway, and once we have our best ITEM
    //    filter, we can use it's count to short circuit looking for an OR
    //    optimization.  As an example, if the last Item filter implies an
    //    index range with 3 entries, and we have an OR with 7 parts that
    //    comes before that in the filter, if we do the items first, we can
    //    stop checking the OR after the first part of the OR if it is
    //    already bigger than 3 entries.  If we did things in linear order,
    //    we would set to the indices described by all 7 parts of the OR and
    //    later find out that we didn't need to.
    //


    // put all the filters in an array
    // check to see which filters have a possibility
    // of being optimizable and put them on a separate array
    //
    cntFilters = count = pFil->FilterTypes.And.count;
    pFilArray = (FILTER **) THAllocEx (pTHS, sizeof (FILTER *) * cntFilters);
    pFilPossOpt = (FILTER **) THAllocEx (pTHS, sizeof (FILTER *) * cntFilters);

    for (count2=0, pFilTemp = pFil->FilterTypes.And.pFirstFilter; count;
         count--, count2++, pFilTemp = pFilTemp->pNextFilter) {

        pFilArray[count2] = pFilTemp;

        if (IsFilterOptimizable (pTHS, pFilTemp)) {
            pFilPossOpt[cntPossOpt++] = pFilTemp;
        }
    }

    // we might have a non indexable component
    //
    if (cntFilters != cntPossOpt) {
        fNonIndexableComponentsPresent = TRUE;
    }

    DPRINT2(2, "dbOptAndFilter: initially found %d out of %d optimizable filters\n",
                    cntPossOpt, cntFilters );

    // New level of filter, so we can't use the ShowInAB unless this level
    // says we can.
    Flags &= ~DBOPTINDEX_fUSE_SHOW_IN_AB;

    for (count=0; count<cntFilters; count++) {
        pFilTemp = pFilArray[count];
        if (pFilTemp && pFilTemp->choice == FILTER_CHOICE_ITEM) {
            if (dbIsPresenceOnDisplayName(pFilTemp)) {
                Flags |= DBOPTINDEX_fUSE_SHOW_IN_AB;
                break;
            }
        }
    }

    // we create a KEY INDEX for every filter that is optimizable
    // using two parallel arrays: ppIndex and pFilPossOpt
    // This way, once we have the KEY_INDEX we can decide how to use it.
    // In addition, we take care of ranges
    //
    if (cntPossOpt) {

        FILTER *pFilTemp2 = NULL;
        UCHAR relop1, relop2;
        AVA *pAVA1, *pAVA2;

        ppIndex = (KEY_INDEX **)
                        THAllocEx (pTHS, sizeof (KEY_INDEX *) * cntPossOpt);
        // NOTICE-2002/03/06-andygo:  unnecessary code
        // REVIEW:  this memset is redundant
        memset (ppIndex, 0, sizeof (KEY_INDEX *) * cntPossOpt);


        for (count=0;
                count<cntPossOpt &&
                err == JET_errSuccess &&
                gfUseRangeOptimizations; count++) {


            pFilTemp = pFilPossOpt[count];

            // filter might have been deleted in the mean time
            if (!pFilTemp) {
                continue;
            }

            // we shouldn't be here if this is FALSE
            Assert (pFilTemp->choice == FILTER_CHOICE_ITEM);

            // get the first relop
            // and for simplicity, treat equalities as inequalities
            //
            relop1 = pFilTemp->FilterTypes.Item.choice;
            if (relop1 == FI_CHOICE_GREATER_OR_EQ) {
                relop1 = FI_CHOICE_GREATER;
            }
            else if (relop1 == FI_CHOICE_LESS_OR_EQ) {
                relop1 = FI_CHOICE_LESS;
            }

            if (relop1 == FI_CHOICE_GREATER || relop1 == FI_CHOICE_LESS) {

                pAVA1 = &pFilTemp->FilterTypes.Item.FilTypes.ava;

                // find the att in schema cache
                if (!(pAC = SCGetAttById(pTHS, pAVA1->type))) {
                    DsaExcept(DSA_EXCEPTION,
                              DIRERR_ATT_NOT_DEF_IN_SCHEMA,
                              pAVA1->type);
                }

                // we cannot start removing entries if the attr is multivalued
                //
                if (!pAC->isSingleValued) {
                    continue;
                }


                // start with the case case of x<A and x<B when A<B
                // where we can have x<A (same for >)
                //
                for (count2=count+1; count2<cntPossOpt; count2++) {

                    pFilTemp2 = pFilPossOpt[count2];

                    // filter might have been deleted in the mean time
                    if (!pFilTemp2) {
                        continue;
                    }

                    Assert (pFilTemp2->choice == FILTER_CHOICE_ITEM);

                    pAVA2 = &pFilTemp2->FilterTypes.Item.FilTypes.ava;

                    // check to see if we are comparing on the same type
                    //
                    if (pAVA2->type == pAVA1->type) {
                        relop2 = pFilTemp2->FilterTypes.Item.choice;

                        if (relop2 == FI_CHOICE_GREATER_OR_EQ) {
                            relop2 = FI_CHOICE_GREATER;
                        }
                        else if (relop2 == FI_CHOICE_LESS_OR_EQ) {
                            relop2 = FI_CHOICE_LESS;
                        }

                        if ( relop1 == relop2)  {

                            // case A<B
                            if (gDBSyntax[pAC->syntax].Eval(pDB,
                                                            FI_CHOICE_LESS,
                                                            pAVA2->Value.valLen,
                                                            pAVA2->Value.pVal,
                                                            pAVA1->Value.valLen,
                                                            pAVA1->Value.pVal)) {

                                // X<A and X<B when A < B => X<A
                                if (relop1 == FI_CHOICE_LESS) {
                                    pFilPossOpt[count2] = NULL;

                                    DPRINT(2, "dbOptAndFilter: found case X<A & X<B when A<B\n");
                                }
                                // X>A and X>B when A < B => X>B
                                else {
                                    pFilPossOpt[count] = pFilPossOpt[count2];
                                    pFilPossOpt[count2] = NULL;
                                    pFilTemp = pFilTemp2;
                                    pAVA1 = pAVA2;
                                    DPRINT(2, "dbOptAndFilter: found case X>A & X>B when A<B\n");
                                }
                            }
                            // case A>B
                            else if (gDBSyntax[pAC->syntax].Eval(pDB,
                                                            FI_CHOICE_GREATER,
                                                            pAVA2->Value.valLen,
                                                            pAVA2->Value.pVal,
                                                            pAVA1->Value.valLen,
                                                            pAVA1->Value.pVal)) {


                                // X<A and X<B when A > B => X<B
                                if (relop1 == FI_CHOICE_LESS) {
                                    pFilPossOpt[count] = pFilPossOpt[count2];
                                    pFilPossOpt[count2] = NULL;
                                    pFilTemp = pFilTemp2;
                                    pAVA1 = pAVA2;
                                    DPRINT(2, "dbOptAndFilter: found case X<A & X<B when A>B\n");
                                }
                                // X>A and X>B when A > B => X>A
                                else {
                                    pFilPossOpt[count2] = NULL;
                                    DPRINT(2, "dbOptAndFilter: found case X>A & X>B when A>B\n");
                                }
                            }
                            // case A==B
                            else {
                                pFilPossOpt[count2] = NULL;
                                DPRINT(2, "dbOptAndFilter: found case X>A & X>B when A==B\n");
                            }
                        }
                    }
                } // count2 loop
            }
        } // count loop


        // RANGE optimizations
        // check to see if we have a case of:   val<=HighVal AND val>=LowVal
        // that we can convert to a LowVal<=val<=HighVal range
        //
        DPRINT(2, "dbOptAndFilter: looking for RANGE optimizations\n");

        for (count=0;
                count<cntPossOpt &&
                err == JET_errSuccess &&
                gfUseRangeOptimizations; count++) {


            pFilTemp = pFilPossOpt[count];

            // filter might have been deleted in the mean time
            if (!pFilTemp) {
                continue;
            }

            // we shouldn't be here if this is FALSE
            Assert (pFilTemp->choice == FILTER_CHOICE_ITEM);

            // get the first relop
            // and for simplicity, treat equalities as inequalities
            //
            relop1 = pFilTemp->FilterTypes.Item.choice;
            if (relop1 == FI_CHOICE_GREATER_OR_EQ) {
                relop1 = FI_CHOICE_GREATER;
            }
            else if (relop1 == FI_CHOICE_LESS_OR_EQ) {
                relop1 = FI_CHOICE_LESS;
            }

            if (relop1 == FI_CHOICE_GREATER || relop1 == FI_CHOICE_LESS) {

                pAVA1 = &pFilTemp->FilterTypes.Item.FilTypes.ava;

                // find the att in schema cache
                if (!(pAC = SCGetAttById(pTHS, pAVA1->type))) {
                    DsaExcept(DSA_EXCEPTION,
                              DIRERR_ATT_NOT_DEF_IN_SCHEMA,
                              pAVA1->type);
                }

                // we cannot start removing entries if the attr is multivalued
                //
                // assume you have an object1, with A=20, 41, object2, with A=19, 45
                // if you say, & (X>20) (X<40) that should give you back both objects
                // so if this was converted to the range [20..40]
                // you would miss object2.
                //

                if (!pAC->isSingleValued) {
                    continue;
                }

                // we found one potential part of the range (low or high end)
                // look for the oposite side
                //
                for (count2=count+1; count2<cntPossOpt; count2++) {

                    pFilTemp2 = pFilPossOpt[count2];

                    // filter might have been deleted in the mean time
                    if (!pFilTemp2) {
                        continue;
                    }

                    Assert (pFilTemp2->choice == FILTER_CHOICE_ITEM);

                    pAVA2 = &pFilTemp2->FilterTypes.Item.FilTypes.ava;

                    // check to see if we are comparing on the same type
                    //
                    if (pAVA2->type == pAVA1->type) {
                        relop2 = pFilTemp2->FilterTypes.Item.choice;

                        if (relop2 == FI_CHOICE_GREATER_OR_EQ) {
                            relop2 = FI_CHOICE_GREATER;
                        }
                        else if (relop2 == FI_CHOICE_LESS_OR_EQ) {
                            relop2 = FI_CHOICE_LESS;
                        }

                        // check to see if this relop is a compatible
                        // one for use in a range
                        //
                        if (  ( relop1 == FI_CHOICE_GREATER  &&
                                relop2 == FI_CHOICE_LESS     )  ||
                              ( relop2 == FI_CHOICE_GREATER &&
                                 relop1 == FI_CHOICE_LESS    )  )  {

                            DPRINT1 (2, "dbOptAndFilter: found RANGE on 0x%x \n",
                                                pAVA1->type );

                            if (err = dbOptItemFilter(pDB,
                                                      FILTER_CHOICE_AND,
                                                      Flags,
                                                      &ppIndex[count],
                                                      pFilTemp,
                                                      pFilTemp2) ) {
                                break;
                            }

                            // NOTICE-2002/03/06-andygo:  unreachable code
                            // REVIEW:  ppIndex[count] != NULL if err == 0, so if is unnecessary
                            // REVIEW:  and following elimination of a filter is always correct
                            if (ppIndex[count]) {
                                DPRINT2 (2, "dbOptAndFilter: RANGE on %s = %d\n",
                                         ppIndex[count]->szIndexName,
                                         ppIndex[count]->ulEstimatedRecsInRange );
                            }

                            // we managed to concatanate these two filters
                            // remove the second one from the array

                            pFilPossOpt[count2] = NULL;

                        }
                    }
                } // count2 loop
            }
        } // count loop

        // if something failed, then we cannot optimize this, so exit
        if (err) {
            DPRINT1(2, "dbOptAndFilter: AND Optimization Failed1:  %d\n", err);

            goto exitAndOptimizer;
        }
    }


    pCurSubstrIndex = &HeadSubstrIndexList;
    pCurSubstrIndex->pNext = NULL;

    // First try the brute force way, by visiting all indexes
    // and counting possible entries in each index.
    // Keep all the results for later evaluation
    //
    for (count = 0; count < cntPossOpt; count++) {

        pFilTemp = pFilPossOpt[count];

        if (!pFilTemp) {
            continue;
        }

        if (ppIndex[count] == NULL) {
            if (pFilTemp->choice == FILTER_CHOICE_ITEM
                && pFilTemp->FilterTypes.Item.choice == FI_CHOICE_SUBSTRING) {

                // Find the current end of the substring filter list.
                while (pCurSubstrIndex->pNext) {
                    pCurSubstrIndex = pCurSubstrIndex->pNext;
                }
                err = dbOptSubstringFilter(pDB,
                                           FILTER_CHOICE_AND,
                                           Flags,
                                           &pCurSubstrIndex->pNext,
                                           &dwTempIndexCount,
                                           pFilTemp
                                           );
                if (err) {
                    break;
                }
                dwSubstrIndexCount += dwTempIndexCount;

            } else {
                // Recursively call opt filter to get the item case
                if (err = dbOptFilter(pDB, Flags, &ppIndex[count], pFilTemp)) {
                    break;
                }
            }
        }

        // we don't need to continue. we have a complete match
        // REVIEW:  we do not check for very small substring index ranges (wrt
        // REVIEW:  gulMaxRecordsWithoutIntersection), most notably on (attr=foo*)
        if (ppIndex[count] &&
            ppIndex[count]->ulEstimatedRecsInRange < gulMaxRecordsWithoutIntersection) {

                DPRINT1 (2, "dbOptAndFilter: Found Index with %d entries. Registry says we should use it.\n",
                            ppIndex[count]->ulEstimatedRecsInRange);

                fOptimizationFinished = TRUE;
                break;
        }
    }

    // if something failed, then we cannot optimize this, so exit
    if (err) {
        DPRINT1(2, "dbOptAndFilter: AND Optimization Failed2: %d\n", err);
        goto exitAndOptimizer;
    }

    DPRINT(2, "dbOptAndFilter: Putting substring indexes at the end of the Array\n");
    //
    // Make room for any substring indexes we may have receieved and put them
    // at the end of the list of possible index optimizations.
    //
    if (dwSubstrIndexCount) {
        ppIndex = THReAllocEx(pTHS, ppIndex, (cntPossOpt + dwSubstrIndexCount) * sizeof(KEY_INDEX *));

        pCurSubstrIndex = HeadSubstrIndexList.pNext;

        count = cntPossOpt;
        cntPossOpt += dwSubstrIndexCount;
        while (pCurSubstrIndex) {
            ppIndex[count] = pCurSubstrIndex;
            pCurSubstrIndex = pCurSubstrIndex->pNext;
            ppIndex[count]->pNext = NULL;
            count++;
        }
    }

    DPRINT(2, "dbOptAndFilter: Removing duplicates.\n");

    // Since jet won't currently intersect to KEY_INDEXES over the same index,
    // we need to make sure that we only have the best KEY_INDEX for any
    // particular index.
    for (count=0; count<cntPossOpt; count++) {
        if (ppIndex[count]) {
            for (count2=count + 1; count2<cntPossOpt; count2++) {
                if (ppIndex[count2]
                    && !strcmp(ppIndex[count]->szIndexName, ppIndex[count2]->szIndexName)) {

                    DWORD  dwIndexToFree;
                    if (ppIndex[count]->ulEstimatedRecsInRange <= ppIndex[count2]->ulEstimatedRecsInRange) {
                        dwIndexToFree = count2;
                    } else {
                        dwIndexToFree = count;
                    }
                    DPRINT1(2, "dbOptAndFilter: removing KEY_INDEX over duplicate index '%s'\n",
                           ppIndex[dwIndexToFree]->szIndexName);
                    dbFreeKeyIndex(pTHS, ppIndex[dwIndexToFree]);
                    ppIndex[dwIndexToFree] = NULL;
                    if (dwIndexToFree == count) {
                        break;
                    }
                }
            }
        }
    }

    // Since jet won't currently intersect KEY_INDEXs over different tables,
    // we need to make sure that we only have KEY_INDEXs from the table with
    // the KEY_INDEX that has the smallest estimated size
    //
    // NOTE:  do not do this if we found an optimal index already because we
    // could inadvertently remove the optimal index!

    if (!fOptimizationFinished) {
        DPRINT(2, "dbOptAndFilter: Removing un-intersectable index ranges.\n");

        for (count=0; count<cntPossOpt; count++) {
            if (ppIndex[count]) {
                if (ppIndex[count]->pAC->ulLinkID) {
                    cRecMinLinkTbl = min( cRecMinLinkTbl, ppIndex[count]->ulEstimatedRecsInRange );
                } else {
                    cRecMinObjTbl = min( cRecMinObjTbl, ppIndex[count]->ulEstimatedRecsInRange );
                }
            }
        }

        for (count=0; count<cntPossOpt; count++) {
            if (ppIndex[count]) {
                if (ppIndex[count]->pAC->ulLinkID) {
                    if (cRecMinLinkTbl >= cRecMinObjTbl) {
                        DPRINT1(2, "dbOptAndFilter: removing KEY_INDEX over index '%s'\n",
                               ppIndex[count]->szIndexName);
                        dbFreeKeyIndex(pTHS, ppIndex[count]);
                        ppIndex[count] = NULL;
                    }
                } else {
                    if (cRecMinLinkTbl < cRecMinObjTbl) {
                        DPRINT1(2, "dbOptAndFilter: removing KEY_INDEX over index '%s'\n",
                               ppIndex[count]->szIndexName);
                        dbFreeKeyIndex(pTHS, ppIndex[count]);
                        ppIndex[count] = NULL;
                    }
                }
            }
        }
    }

    DPRINT(2, "dbOptAndFilter: Compacting Array\n");
    // move all valid entries in the start of the array
    //
    for (count=0; count<cntPossOpt; count++) {
        if (ppIndex[count]==NULL) {
            for (count2=count+1 ; count2<cntPossOpt; count2++) {
                if (ppIndex[count2]) {
                    break;
                }
            }
            if (count2 < cntPossOpt) {
                ppIndex[count] = ppIndex[count2];
                ppIndex[count2] = NULL;
            }
            else {
                break;
            }
        }
    }
    cntPossOpt = count;

    #if 0
    for (count=0; count<cntPossOpt; count++) {
        if (pFilPossOpt[count] == NULL || ppIndex[count]==NULL) {
            DPRINT4 (0, "pFilPossOpt[%d]=0x%x, ooPindex[%d]=0x%x\n",
                    count, pFilPossOpt[count],
                    count, ppIndex[count]);
        }
        Assert (ppIndex[count] && pFilPossOpt[count]);
    }
    #endif

    //
    // Intersect if it makes sense to do so.
    if (!fOptimizationFinished) {
        err = dbOptAndIntersectFilter(pDB, Flags, ppBestIndex, ppIndex, cntPossOpt);
    }

    // consolidate best indexes found until now
    // and free the remaining
    //
    DPRINT(2, "dbOptAndFilter: Consolidating best indexes for far\n");

    for (count=0; count<cntPossOpt; count++) {

        // is it better than the one we already have ?
        if(!(*ppBestIndex) ||
           (ppIndex[count] &&
            (ppIndex[count]->ulEstimatedRecsInRange < (*ppBestIndex)->ulEstimatedRecsInRange)) ) {
                // yes - it sure looks that way...

                if(*ppBestIndex) {
                    dbFreeKeyIndex(pTHS, *ppBestIndex);
                }
                *ppBestIndex = ppIndex[count];
                ppIndex[count] = NULL;
        }
        else {
            dbFreeKeyIndex(pTHS, ppIndex[count]);
            ppIndex[count] = NULL;
        }
    }

    // if we can't use the special AND optimize,
    // or we used it and somehow it failed
    // we try with a simpler brute force optimizer
    //
    if (!fOptimizationFinished && (fNonIndexableComponentsPresent || err != JET_errSuccess) ) {

        // Now that we've picked the best ITEM, go back and try for ORs.
        //
        count = cntFilters;
        for (count = 0; count < cntFilters; count++) {
            pFilTemp = pFilArray[count];
            if (pFilTemp && pFilTemp->choice == FILTER_CHOICE_OR) {

                err = dbOptOrFilter(pDB, Flags, ppBestIndex, pFilTemp);
                if(err) {

                    DPRINT1(2, "dbOptAndFilter: Error optimizing OR filter %d\n", err);

                    goto exitAndOptimizer;
                }
            }
        }

        // if we didn't manage to optimize this branch, return an indication.
        if (*ppBestIndex == NULL) {

            DPRINT(2, "dbOptAndFilter: AND branch not optimizable\n");

            err = 1;
        }
    }

exitAndOptimizer:

    // first free all potential KEY_INDEXES so far
    for (count=0; count<cntPossOpt; count++) {
        if (ppIndex[count]) {
            dbFreeKeyIndex(pTHS, ppIndex[count]);
            ppIndex[count] = NULL;
        }
    }

    THFreeEx (pTHS, ppIndex);
    THFreeEx (pTHS, pFilArray);
    THFreeEx (pTHS, pFilPossOpt);

    return err;
}

// NTRAID#NTRAID-560446-2002/02/28-andygo:  SECURITY:  a really wide AND/OR term in a filter can be used to consume all resources on a DC
// REVIEW:  we need to check for the search time limit in dbOptFilter and/or its children so
// REVIEW:  that a huge filter cannot consume an LDAP thread forever during the optimization phase

DWORD
dbOptFilter (
        DBPOS     *pDB,
        DWORD     Flags,
        KEY_INDEX **ppBestIndex,
        FILTER    *pFil
         )
{
    DWORD       err = 0;

    Assert(VALID_DBPOS(pDB));

    DPRINT(2, "dbOptFilter: entering\n");

    if (pFil == NULL)
        return 0;

    if (  eServiceShutdown
        && !(   (eServiceShutdown == eRemovingClients)
             && (pDB->pTHS->fDSA)
             && !(pDB->pTHS->fSAM))) {
        // Shutting down, bail.
        return DB_ERR_SHUTTING_DOWN;
    }

    switch (pFil->choice) {
    case FILTER_CHOICE_AND:
        err = dbOptAndFilter (pDB,
                              Flags,
                              ppBestIndex,
                              pFil);
        return err;
        break;

    case FILTER_CHOICE_OR:
        dbOptOrFilter(pDB,
                      Flags,
                      ppBestIndex,
                      pFil);
        return 0;
        break;

    case FILTER_CHOICE_NOT:
        DPRINT(2, "dbOptFilter: NOT\n");
        // No optimization possible.
        return 0;

    case FILTER_CHOICE_ITEM:
        if (pFil->FilterTypes.Item.choice == FI_CHOICE_SUBSTRING) {
            err = dbOptSubstringFilter(pDB,
                                       FILTER_CHOICE_ITEM,
                                       Flags,
                                       ppBestIndex,
                                       NULL,
                                       pFil);
        } else {
            err = dbOptItemFilter (pDB,
                                   FILTER_CHOICE_ITEM,
                                   Flags,
                                   ppBestIndex,
                                   pFil,
                                   NULL);
        }
        return err;

    default:
        DPRINT1(2, "DBOptFilter got unknown filter element, %X\n", pFil->choice);
        Assert(!"DBOptFilter got unknown fitler element\n");
        return DB_ERR_UNKNOWN_ERROR;

    }  /*switch FILTER*/

    return 0;
}

void* JET_API dbProcessSortCandidateRealloc(
    THSTATE*    pTHS,
    void*       pv,
    ULONG       cb
    )
{
    void* pvRet = NULL;

    if (!pv) {
        pvRet = THAllocNoEx(pTHS, cb);
    } else if (!cb) {
        THFreeNoEx(pTHS, pv);
    } else {
        pvRet = THReAllocNoEx(pTHS, pv, cb);
    }

    return pvRet;
}

void dbProcessSortCandidateFreeData(
    THSTATE*            pTHS,
    ULONG               cEnumColumn,
    JET_ENUMCOLUMN*     rgEnumColumn
    )
{
    size_t                  iEnumColumn         = 0;
    JET_ENUMCOLUMN*         pEnumColumn         = NULL;
    size_t                  iEnumColumnValue    = 0;
    JET_ENUMCOLUMNVALUE*    pEnumColumnValue    = NULL;

    if (rgEnumColumn) {
        for (iEnumColumn = 0; iEnumColumn < cEnumColumn; iEnumColumn++) {
            pEnumColumn = rgEnumColumn + iEnumColumn;

            if (pEnumColumn->err != JET_wrnColumnSingleValue) {
                if (pEnumColumn->rgEnumColumnValue) {
                    for (   iEnumColumnValue = 0;
                            iEnumColumnValue < pEnumColumn->cEnumColumnValue;
                            iEnumColumnValue++) {
                        pEnumColumnValue = pEnumColumn->rgEnumColumnValue + iEnumColumnValue;

                        if (pEnumColumnValue->pvData) {
                            THFreeEx(pTHS, pEnumColumnValue->pvData);
                        }
                    }

                    THFreeEx(pTHS, pEnumColumn->rgEnumColumnValue);
                }
            } else {
                if (pEnumColumn->pvData) {
                    THFreeEx(pTHS, pEnumColumn->pvData);
                }
            }
        }

        THFreeEx(pTHS, rgEnumColumn);
    }
}

DWORD
dbProcessSortCandidate(
        IN      DBPOS       *pDB,
        IN      ATTCACHE    *pACSort,
        IN      DWORD        SortFlags,
        IN OUT  DWORD       *Count,
        IN      DWORD        MaxCount
        )
{
    THSTATE              *pTHS = pDB->pTHS;
    BOOL                  bCanRead;
    DWORD                 err = 0;
    ULONG                 cbData = 240;  //  DBInsertSortTable truncates to 240
    UCHAR                 rgbData[240];
    ULONG                 cEnumColumnId = 1;
    JET_ENUMCOLUMNID      rgEnumColumnId[1] = { pACSort->jColid };
    JET_ENUMCOLUMNID      EnumColumnIdT;
    ULONG                 cEnumColumn = 0;
    JET_ENUMCOLUMN       *rgEnumColumn = NULL;
    JET_ENUMCOLUMN        EnumColumnLocal;
    JET_ENUMCOLUMN       *pEnumColumn;
    JET_ENUMCOLUMNVALUE   EnumColumnValueT = { 1, JET_errSuccess, 0, NULL };
    JET_ENUMCOLUMN        EnumColumnT = { 0, JET_errSuccess, 1, &EnumColumnValueT };
    size_t                iEnumColumnValue = 0;
    JET_ENUMCOLUMNVALUE *pEnumColumnValue;

    pDB->SearchEntriesVisited++;
    PERFINC(pcSearchSubOperations);

    if (dbMakeCurrent(pDB, NULL) != DIRERR_NOT_AN_OBJECT &&
        dbFObjectInCorrectDITLocation(pDB, pDB->JetObjTbl) &&
        dbFObjectInCorrectNC(pDB, pDB->DNT, pDB->JetObjTbl) &&
        dbMatchSearchCriteriaForSortedTable(pDB, &bCanRead)) {
        // In the correct place and NC, and the filter matches.

        if (bCanRead) {
            // Get the values we are sorting on.
            if (pACSort->isSingleValued) {
                // fast path single valued attributes
                cEnumColumn     = 1;
                rgEnumColumn    = &EnumColumnLocal;
                rgEnumColumn[0].columnid    = rgEnumColumnId[0].columnid;
                rgEnumColumn[0].err         = JET_wrnColumnSingleValue;
                rgEnumColumn[0].cbData      = cbData;
                rgEnumColumn[0].pvData      = rgbData;

                err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                                pDB->JetObjTbl,
                                                rgEnumColumn[0].columnid,
                                                rgEnumColumn[0].pvData,
                                                rgEnumColumn[0].cbData,
                                                &rgEnumColumn[0].cbData,
                                                0,
                                                NULL);
                if (err) {
                    if (err == JET_wrnBufferTruncated) {
                        rgEnumColumn[0].cbData = cbData;
                        err = JET_wrnColumnSingleValue;
                    }
                    rgEnumColumn[0].err = err;
                    if (err == JET_wrnColumnNull) {
                        rgEnumColumn[0].cEnumColumnValue    = 0;
                        rgEnumColumn[0].rgEnumColumnValue   = NULL;
                    }
                }
            }
            else {
                // efficiently retrieve multivalued attributes
                JetEnumerateColumnsEx(pDB->JetSessID,
                                      pDB->JetObjTbl,
                                      cEnumColumnId,
                                      rgEnumColumnId,
                                      &cEnumColumn,
                                      &rgEnumColumn,
                                      (JET_PFNREALLOC)dbProcessSortCandidateRealloc,
                                      pTHS,
                                      -1,
                                      0);
            }
        }
        else {
            // We can't read the value due to security.  Make it be
            // a null value.
            cEnumColumn     = 1;
            rgEnumColumn    = &EnumColumnLocal;
            rgEnumColumn[0].columnid            = rgEnumColumnId[0].columnid;
            rgEnumColumn[0].err                 = JET_wrnColumnNull;
            rgEnumColumn[0].cEnumColumnValue    = 0;
            rgEnumColumn[0].rgEnumColumnValue   = NULL;
        }

        pEnumColumn = &rgEnumColumn[0];
        if(pEnumColumn->err == JET_wrnColumnSingleValue) {
            // Decompress this column value to a temp enum column struct
            EnumColumnT.columnid = pEnumColumn->columnid;
            EnumColumnValueT.cbData = pEnumColumn->cbData;
            EnumColumnValueT.pvData = pEnumColumn->pvData;
            pEnumColumn = &EnumColumnT;
        }
        err = pEnumColumn->err;

        // ISSUE-2002/06/18-andygo:  VLV vs. non-VLV search results
        // isn't it true according to the VLV spec that VLV searches should
        // be identical in results to an ordinary search?  If so, then we
        // SHOULD treat VLVs the same as ordinary searches here

        // we are doing a VLV search
        if (pDB->Key.pVLV) {

            // if this is a VLV then do not insert a record into the sort
            // table for this NULL value because it will make the result
            // of a VLV over an attribute that doesn't have a containerized
            // index different from that of a VLV over an attribute that
            // does have a containerized index.  this is because the
            // containerized index will never have entries for objects
            // that have no value for the given attribute
            if (err == JET_wrnColumnNull) {
                err = 0;
            }

            // if this is a VLV then we must insert one record into the sort
            // for every value of this attribute.  this is so that a VLV over
            // a containerized index will look the same as a VLV done using a
            // sort
            else {
                for (iEnumColumnValue = 0;
                     !err && iEnumColumnValue < pEnumColumn->cEnumColumnValue;
                     iEnumColumnValue++) {
                    err = DBInsertSortTable(pDB,
                                         pEnumColumn->rgEnumColumnValue[iEnumColumnValue].pvData,
                                         pEnumColumn->rgEnumColumnValue[iEnumColumnValue].cbData,
                                         pDB->DNT);

                    switch (err) {
                    case DB_success:
                        if ((*Count)++ >= MaxCount) {
                            // This table is too big.  Bail.
                            err = DB_ERR_TOO_MANY;
                        }
                        break;
                    case DB_ERR_ALREADY_INSERTED:
                        // This is ok, it just means that we've already
                        // added this object to the sort table. Don't inc
                        // the count;
                        err = 0;
                        break;
                    default:
                        // Something went wrong.
                        err = DB_ERR_UNKNOWN_ERROR;
                        break;
                    }
                }
            }
        }

        // we are doing an ordinary search
        else {

            // find the value of this attribute that is the lowest/highest
            // (depending on sort direction) and insert a record into the sort
            // for that value.  if the attribute is NULL then we will insert
            // that into the sort as well
            pEnumColumnValue = &pEnumColumn->rgEnumColumnValue[0];
            for (iEnumColumnValue = 1;
                 iEnumColumnValue < pEnumColumn->cEnumColumnValue;
                 iEnumColumnValue++) {

                UCHAR oper = FI_CHOICE_LESS;
                if (SortFlags & DB_SORT_DESCENDING) {
                    oper = FI_CHOICE_GREATER;
                }

                if (gDBSyntax[pACSort->syntax].Eval(pDB,
                                                    oper,
                                                    pEnumColumnValue->cbData,
                                                    pEnumColumnValue->pvData,
                                                    pEnumColumn->rgEnumColumnValue[iEnumColumnValue].cbData,
                                                    pEnumColumn->rgEnumColumnValue[iEnumColumnValue].pvData) == TRUE) {
                    pEnumColumnValue = &pEnumColumn->rgEnumColumnValue[iEnumColumnValue];
                }
            }

            if (pEnumColumnValue) {
                err = DBInsertSortTable(pDB,
                                     pEnumColumnValue->pvData,
                                     pEnumColumnValue->cbData,
                                     pDB->DNT);
            } else {
                err = DBInsertSortTable(pDB, NULL, 0, pDB->DNT);
            }

            switch (err) {
            case DB_success:
                if ((*Count)++ >= MaxCount) {
                    // This table is too big.  Bail.
                    err = DB_ERR_TOO_MANY;
                }
                break;
            case DB_ERR_ALREADY_INSERTED:
                // This is ok, it just means that we've already
                // added this object to the sort table. Don't inc
                // the count;
                err = 0;
                break;
            default:
                // Something went wrong.
                err = DB_ERR_UNKNOWN_ERROR;
                break;
            }
        }
    }

    if (rgEnumColumn != &EnumColumnLocal) {
        dbProcessSortCandidateFreeData(pTHS, cEnumColumn, rgEnumColumn);
    }
    return err;
}

DWORD
dbCreateSortedTable (
        IN DBPOS *pDB,
        IN DWORD StartTick,
        IN DWORD DeltaTick,
        IN DWORD SortAttr,
        IN DWORD SortFlags,
        IN DWORD MaxSortTableSize
        )
{
    THSTATE   *pTHS=pDB->pTHS;
    ATTCACHE  *pACSort = NULL;
    KEY_INDEX *pIndex;
    DWORD     Count=0;
    DWORD     err;
    unsigned char rgbBookmark[JET_cbBookmarkMost];
    unsigned long cbBookmark;
    JET_TABLEID   JetTbl;


    //
    // ok, these callers are exempted from the table size check
    //

    if ( pTHS->fDRA ||
         pTHS->fDSA ||
         pTHS->fSAM ) {

        MaxSortTableSize = UINT_MAX;
    }

    Assert(VALID_DBPOS(pDB));

    if (!(pACSort = SCGetAttById(pTHS, SortAttr))) {
        // What?  The sort attribute is invalid?
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, SortAttr);
    }

    if(DBOpenSortTable(
            pDB,
            pTHS->dwLcid,
            // REVIEW:  this flag hack should be done in DBChooseIndex
            pDB->Key.pVLV ? ( SortFlags & ~DB_SORT_DESCENDING ) : SortFlags,
            pACSort)) {
        // Can't open a sort table on this attribute, bail
        return DB_ERR_NO_SORT_TABLE;
    }

    pIndex = pDB->Key.pIndex;
    while (pIndex) {

        // get current table
        if (pIndex->pAC && pIndex->pAC->ulLinkID) {
            if (JET_tableidNil == pDB->JetLinkEnumTbl) {
                // REVIEW:  consider silently failing the optimization on out of cursors so that
                // REVIEW:  we more gracefully handle low resource conditions
                JetDupCursorEx(pDB->JetSessID,
                                pDB->JetLinkTbl,
                                &pDB->JetLinkEnumTbl,
                                0);
            }
            JetTbl = pDB->JetLinkEnumTbl;
        } else {
            JetTbl = pDB->JetObjTbl;
        }

        // handle intersections differently
        if (pIndex->bIsIntersection) {
            err = JetMoveEx( pDB->JetSessID,
                             pIndex->tblIntersection,
                             JET_MoveFirst,
                             0 );

            Assert(err == JET_errSuccess || err == JET_errNoCurrentRecord);

            if (err == JET_errSuccess) {
                JetRetrieveColumnSuccess(
                                    pDB->JetSessID,
                                    pIndex->tblIntersection,
                                    pIndex->columnidBookmark,
                                    rgbBookmark,
                                    sizeof( rgbBookmark ),
                                    &cbBookmark,
                                    0,
                                    NULL );
                JetGotoBookmarkEx(
                               pDB->JetSessID,
                               JetTbl,
                               rgbBookmark,
                               cbBookmark );
            }
        }
        else {
            // Set to the index.
            JetSetCurrentIndex4Success(pDB->JetSessID,
                                       JetTbl,
                                       pIndex->szIndexName,
                                       pIndex->pindexid,
                                       JET_bitMoveFirst);

            if (pIndex->cbDBKeyLower) {
                // Seek to the first element.
                JetMakeKeyEx(pDB->JetSessID,
                         JetTbl,
                         pIndex->rgbDBKeyLower,
                         pIndex->cbDBKeyLower,
                         JET_bitNormalizedKey);

                err = JetSeekEx(pDB->JetSessID,
                            JetTbl,
                            JET_bitSeekGE);
            } else {
                err = JetMoveEx(pDB->JetSessID,
                                JetTbl,
                                JET_MoveFirst, 0);
            }

            Assert(err == JET_errSuccess ||
                   err == JET_wrnSeekNotEqual||
                   err == JET_errRecordNotFound ||
                   err == JET_errNoCurrentRecord);

            switch(err) {
            case JET_errSuccess:
            case JET_wrnSeekNotEqual:
                // Normal case
                break;

            case JET_errRecordNotFound:
            case JET_errNoCurrentRecord:
                // Already outside the bounds of the range we wanted.  This means
                // that there are no objects from this keyindex that we care about.
                // Go on to the next one.
                pIndex = pIndex->pNext;
                continue;
                break;
            }

            // OK, we seeked to something.  Set the index range.
            JetMakeKeyEx(pDB->JetSessID,
                         JetTbl,
                         pIndex->rgbDBKeyUpper,
                         pIndex->cbDBKeyUpper,
                         JET_bitNormalizedKey);

            err = JetSetIndexRangeEx(pDB->JetSessID,
                                     JetTbl,
                                     (JET_bitRangeUpperLimit |
                                      JET_bitRangeInclusive ));

            Assert(err == JET_errSuccess || err == JET_errNoCurrentRecord);
        }

        while(!err) {
            if(StartTick) {       // There is a time limit
                if((GetTickCount() - StartTick) > DeltaTick) {
                    DBCloseSortTable(pDB);
                    return DB_ERR_TIMELIMIT;
                }
            }

            // set our currency on the object table
            if (pIndex->pAC && pIndex->pAC->ulLinkID) {
                JET_COLUMNID    colidDNT;
                DWORD           DNT;

                if (FIsBacklink(pIndex->pAC->ulLinkID)) {
                    colidDNT = linkdntid;
                } else {
                    colidDNT = backlinkdntid;
                }

                JetRetrieveColumnSuccess(pDB->JetSessID,
                                        pDB->JetLinkEnumTbl,
                                        colidDNT,
                                        &DNT,
                                        sizeof(DNT),
                                        NULL,
                                        JET_bitRetrieveFromIndex,
                                        NULL);

                if (DBTryToFindDNT(pDB, DNT)) {
                    DPRINT1(2, "DBCreateSortedTable failed to set currency, err %d\n",err);
                    Assert(!"DBCreateSortedTable failed to set currency\n");
                    return DB_ERR_UNKNOWN_ERROR;
                }
            }

            //  Process this candidate for the sort
            err = dbProcessSortCandidate(pDB, pACSort, SortFlags, &Count, MaxSortTableSize);
            if (err) {
                DBCloseSortTable(pDB);
                DPRINT1(2, "DBCreateSortedTable failed to process a candidate, err %d\n", err);
                return err;
            }

            //  Move to next, retrieve it's key.
            if (pIndex->bIsIntersection) {
                err = JetMoveEx( pDB->JetSessID,
                                 pIndex->tblIntersection,
                                 JET_MoveNext,
                                 0 );

                Assert(err == JET_errSuccess || err == JET_errNoCurrentRecord);

                if (err == JET_errSuccess) {
                    JetRetrieveColumnSuccess(
                                        pDB->JetSessID,
                                        pIndex->tblIntersection,
                                        pIndex->columnidBookmark,
                                        rgbBookmark,
                                        sizeof( rgbBookmark ),
                                        &cbBookmark,
                                        0,
                                        NULL );
                    JetGotoBookmarkEx(
                                   pDB->JetSessID,
                                   JetTbl,
                                   rgbBookmark,
                                   cbBookmark );
                }
            }
            else {
                err = JetMoveEx(pDB->JetSessID,
                                JetTbl,
                                JET_MoveNext,
                                0);

                Assert(err == JET_errSuccess || err == JET_errNoCurrentRecord);
            }
        }
        pIndex = pIndex->pNext;
    }

    dbFreeKeyIndex(pTHS, pDB->Key.pIndex);
    pDB->Key.fSearchInProgress = FALSE;
    pDB->Key.indexType = TEMP_TABLE_INDEX_TYPE;
    pDB->Key.ulEntriesInTempTable = Count;
    pDB->Key.bOnCandidate = FALSE;
    pDB->Key.fChangeDirection = FALSE;
    pDB->Key.pIndex = NULL;

    if (pDB->Key.pVLV) {
        DWORD *pDNTs;

        DPRINT1 (1, "Doing VLV using INMEMORY Sorted Table. Num Entries: %d\n", Count);

        pDB->Key.cdwCountDNTs = pDB->Key.pVLV->contentCount = 0;

        if (Count) {
            pDB->Key.pVLV->currPosition = 1;
            pDB->Key.currRecPos = 1;

            pDNTs = pDB->Key.pDNTs = THAllocEx(pTHS, (Count+1) * sizeof (DWORD));

            err = JetMoveEx(pDB->JetSessID,
                            pDB->JetSortTbl,
                            JET_MoveFirst,
                            0);

            if(!err) {
                do {
                    // OK, pull the DNT out of the sort table
                    DBGetDNTSortTable (
                            pDB,
                            pDNTs);

                    pDNTs++;

                    // we bump these counts here because the we will not know
                    // the actual count until after the sort table removes any
                    // duplicates from the result set
                    pDB->Key.cdwCountDNTs++;
                    pDB->Key.pVLV->contentCount++;

                    err = JetMoveEx(pDB->JetSessID,
                                    pDB->JetSortTbl,
                                    JET_MoveNext,
                                    0);

                    if(StartTick) {       // There is a time limit
                        if((GetTickCount() - StartTick) > DeltaTick) {
                            DBCloseSortTable(pDB);
                            return DB_ERR_TIMELIMIT;
                        }
                    }

                } while (!err);
            }
        }

        DBCloseSortTable(pDB);
        pDB->Key.indexType = TEMP_TABLE_MEMORY_ARRAY_TYPE;
    }

    return 0;
}

DWORD
dbCreateASQTable (
        IN DBPOS *pDB,
        IN DWORD StartTick,
        IN DWORD DeltaTick,
        IN DWORD SortAttr,
        IN DWORD MaxSortTableSize
        )
{
    THSTATE   *pTHS=pDB->pTHS;
    ATTCACHE  *pACSort = NULL;
    ATTCACHE  *pACASQ = NULL;

    ATTCACHE  *rgpAC[1];
    ATTRBLOCK  AttrBlock;

    RANGEINFSEL   SelectionRange;
    RANGEINFOITEM RangeInfoItem;
    RANGEINF      RangeInf;

    DWORD     upperLimit;
    DWORD    *pDNTs = NULL;

    DWORD     err = 0;
    DWORD     Count=0, j, loopCount=0;
    BOOL      fDone = FALSE;

    DWORD     DNT;
    DWORD     SortFlags = DB_SORT_ASCENDING;
    BOOL      fSort = SortAttr != 0;

    //
    // ok, these callers are exempted from the table size check
    //

    if ( pTHS->fDRA ||
         pTHS->fDSA ||
         pTHS->fSAM ) {

        MaxSortTableSize = UINT_MAX;
    }

    Assert(VALID_DBPOS(pDB));

    if (fSort) {
        if (!(pACSort = SCGetAttById(pTHS, SortAttr))) {
            // What?  The sort attribute is invalid?
            DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, SortAttr);
        }
    }

    if (!(pACASQ = SCGetAttById(pTHS, pDB->Key.asqRequest.attrType))) {
        // What?  The ASQ attribute is invalid?
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA,
                  pDB->Key.asqRequest.attrType);
    }

    rgpAC[0] = pACASQ;

    SelectionRange.valueLimit = 1000;
    SelectionRange.count = 1;
    SelectionRange.pRanges = &RangeInfoItem;

    RangeInfoItem.AttId = pDB->Key.asqRequest.attrType;

    upperLimit = pDB->Key.ulASQLastUpperBound + pDB->Key.ulASQSizeLimit;
    if (upperLimit < pDB->Key.ulASQLastUpperBound) {  //  overflow
        upperLimit = UINT_MAX;
    }

    while (!err && !fDone) {

        RangeInfoItem.lower = loopCount * 1000 + pDB->Key.ulASQLastUpperBound;
        RangeInfoItem.upper = RangeInfoItem.lower + 1000;

        if (RangeInfoItem.upper >= upperLimit) {
            RangeInfoItem.upper = upperLimit;
            fDone = TRUE;
        }

        // REVIEW:  DBFindDNT always excepts on failure so not checking the retval is OK
        err = DBFindDNT(pDB, pDB->Key.ulSearchRootDnt);

        err = DBGetMultipleAtts(pDB,
                                1,
                                rgpAC,
                                &SelectionRange,
                                &RangeInf,
                                &AttrBlock.attrCount,
                                &AttrBlock.pAttr,
                                DBGETMULTIPLEATTS_fGETVALS,
                                0);

        if (err) {
            return err;
        }

        if (!AttrBlock.attrCount) {
            break;
        }

        if (loopCount == 0) {
            if(fSort) {
                if (AttrBlock.pAttr[0].AttrVal.valCount >= MIN_NUM_ENTRIES_FOR_FORWARDONLY_SORT) {
                    SortFlags = SortFlags | DB_SORT_FORWARDONLY;
                }
                if (DBOpenSortTable(
                        pDB,
                        pTHS->dwLcid,
                        SortFlags,
                        pACSort)) {
                    // Can't open a sort table on this attribute, bail
                    return DB_ERR_NO_SORT_TABLE;
                }
            }
            else {
                if (pDB->Key.pDNTs) {
                    pDB->Key.pDNTs = THReAllocEx(pTHS, pDB->Key.pDNTs, (pDB->Key.ulASQSizeLimit+1) * sizeof (DWORD));
                }
                else {
                    pDB->Key.pDNTs = THAllocEx(pTHS, (pDB->Key.ulASQSizeLimit+1) * sizeof (DWORD));
                }
                pDNTs = pDB->Key.pDNTs;
            }
        }

        if (fSort) {
            err = JetSetCurrentIndexWarnings(pDB->JetSessID,
                                             pDB->JetObjTbl,
                                             NULL);  // OPTIMISATION: pass NULL to switch to primary index (SZDNTINDEX)
        }

        j = 0;
        while(!err && j < AttrBlock.pAttr[0].AttrVal.valCount) {

            DNT = *(DWORD *)AttrBlock.pAttr[0].AttrVal.pAVal[j].pVal;

            if (fSort) {

                // REVIEW:  sorted/paged ASQ works because we grab everything we are willing
                // REVIEW:  to return to the user in the first pass and never come back for more
                // REVIEW:  once that is exhausted.  otherwise, the results would not be sorted

                if(StartTick) {       // There is a time limit
                    if((GetTickCount() - StartTick) > DeltaTick) {
                        DBCloseSortTable(pDB);
                        return DB_ERR_TIMELIMIT;
                    }
                }

                JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl, &DNT,
                             sizeof(DNT), JET_bitNewKey);

                if (err = JetSeekEx(pDB->JetSessID, pDB->JetObjTbl, JET_bitSeekEQ))
                {
                    DsaExcept(DSA_DB_EXCEPTION, err, 0);
                }

                //  Process this candidate for the sort
                err = dbProcessSortCandidate(pDB, pACSort, SortFlags, &Count, MaxSortTableSize);
                if (err) {
                    DBCloseSortTable(pDB);
                    DPRINT1(2, "DBCreateASQTable failed to process a candidate, err %d\n", err);
                    return err;
                }
            }
            else {
                if( Count++ >= pDB->Key.ulASQSizeLimit ) {
                    // we don't need any more entries
                    Count--;
                    fDone = TRUE;
                    break;
                }
                *pDNTs = DNT;

                pDNTs++;
            }

            //  Move to next, retrieve it's key.
            j++;
        }

        loopCount++;

        if (!RangeInf.pRanges || RangeInf.pRanges->upper == -1) {
            break;
        }

        if(StartTick) {       // There is a time limit
            if((GetTickCount() - StartTick) > DeltaTick) {
                if (fSort) {
                    DBCloseSortTable(pDB);
                }
                return DB_ERR_TIMELIMIT;
            }
        }

        DBFreeMultipleAtts(pDB, &AttrBlock.attrCount, &AttrBlock.pAttr);
    }

    Assert (!pDB->Key.pIndex);

    pDB->Key.fSearchInProgress = FALSE;
    pDB->Key.ulEntriesInTempTable = Count;
    pDB->Key.bOnCandidate = FALSE;
    pDB->Key.fChangeDirection = FALSE;
    pDB->Key.pIndex = NULL;

    if (!Count) {
        if (fSort) {
            DBCloseSortTable(pDB);
        }
        return DB_ERR_NEXTCHILD_NOTFOUND;
    }


    if (pDB->Key.pVLV || fSort) {
        #if DBG
        DWORD DntIndex = 0;
        #endif

        DPRINT1 (1, "Doing VLV/ASQ using INMEMORY Sorted Table. Num Entries: %d\n", Count);

        pDB->Key.cdwCountDNTs = 0;
        if (pDB->Key.pVLV) {
            pDB->Key.pVLV->contentCount = 0;
        }

        if (Count) {
            if (pDB->Key.pVLV) {
                pDB->Key.pVLV->currPosition = 1;
            }
            pDB->Key.currRecPos = 1;

            pDNTs = pDB->Key.pDNTs = THAllocEx(pTHS, (Count+1) * sizeof (DWORD));

            err = JetMoveEx(pDB->JetSessID,
                            pDB->JetSortTbl,
                            JET_MoveFirst,
                            0);

            if(!err) {
                do {
                    // OK, pull the DNT out of the sort table
                    DBGetDNTSortTable (
                            pDB,
                            pDNTs);

                    pDNTs++;

                    // we bump these counts here because the we will not know
                    // the actual count until after the sort table removes any
                    // duplicates from the result set
                    pDB->Key.cdwCountDNTs++;
                    if (pDB->Key.pVLV) {
                        pDB->Key.pVLV->contentCount++;
                    }

                    err = JetMoveEx(pDB->JetSessID,
                                    pDB->JetSortTbl,
                                    JET_MoveNext,
                                    0);

                    if(StartTick) {       // There is a time limit
                        if((GetTickCount() - StartTick) > DeltaTick) {
                            DBCloseSortTable(pDB);
                            return DB_ERR_TIMELIMIT;
                        }
                    }

                } while (!err);
            }
        }

        DBCloseSortTable(pDB);
        pDB->Key.indexType = TEMP_TABLE_MEMORY_ARRAY_TYPE;
    }
    else {
        pDB->Key.cdwCountDNTs = Count;
        pDB->Key.indexType = TEMP_TABLE_MEMORY_ARRAY_TYPE;

        if (Count) {
            pDB->Key.currRecPos = 1;
            pDB->Key.pDNTs = THReAllocEx(pTHS, pDB->Key.pDNTs, (Count+1) * sizeof (DWORD));
        }
        else {
            pDB->Key.currRecPos = 0;
        }
    }

    return 0;
}

/*++

Routine Description:

    Attempt to find an index to use for walking the database for a search.  Sets
    up the index information in the pDB->Key.  If a SortAttribute is given, use
    the index on that attribute if it exists, fail the call if it doesn't.  If
    instructed to fUseFilter, try to pick a better index based on the filter
    supplied on the pDB.

    Note we must use the sort index if a size limit is specified and the
    resultant output is likely to be larger than the size limit.  We do this for
    two reasons.
    1) if they want paged results, we need to be able to come back and continue
    the search.  This is exceedingly tricky to do unless we are walking the sort
    index in the first place (paged results are done via passing back to the
    client the index and associated keys we are using)
    2) Even if they don't want paged results, walking another index requires
    sorting after we evaluate the filter.  It seems to be less than advantageous
    to completely evaluate a filter, getting perhaps many more times the amount
    of data we want, just to sort and then throw most of it away.


Arguments:

    pDB - The DBPos to use.  Specifies the filter to use.

    StartTick - if !0, specifies a time limit is in effect, and this is the tick
            count when the call was started.

    DeltaTick - if a time limit is in effect, this is the maximum number of
            ticks past StartTick to allow.

    SortAttr - an optional attribute to sort on.  If 0, no sort specified.

    SortType - the type of the sort (SORT_NEVER, SORT_OPTIONAL, SORT_MANTADORY)

    Flags - DBCHOOSEINDEX_fUSEFILTER - use filter for choosing better index.
            DBCHOOSEINDEX_fREVERSE_SORT - this is a reverse sort
            DBCHOOSEINDEX_fPAGED_SEARCH - this is a paged search
            DBCHOOSEINDEX_fVLV_SEARCH - this is a VLV search

    MaxTempTableSize - the maximum Temporary size that we are allowed to use
                       for the sorted results.

Return Values:

    0 if all went well,
    DB_ERR_CANT_SORT - no sort exists on specified SortAttr.
    DB_ERR_SHUTTING_DOWN - if we are

--*/
DWORD
DBChooseIndex (
        IN DBPOS  *pDB,
        IN DWORD   StartTick,
        IN DWORD   DeltaTick,
        IN ATTRTYP SortAttr,
        IN ULONG   SortType,
        IN DWORD   Flags,
        IN DWORD   MaxTempTableSize
        )
{
    THSTATE     *pTHS=pDB->pTHS;
    ULONG       actuallen = 0;
    char        szTempIndex[MAX_INDEX_NAME];
    JET_INDEXID *pindexidTemp = NULL;
    char        *pszDefaultIndex = NULL;
    JET_INDEXID *pindexidDefault = NULL;
    BOOL        fIntersectDefaultIndex = TRUE;
    ULONG       cbSortKey1, cbSortKey2;
    ULONG       SortedIndexSize = (ULONG)-1;
    BOOL        fPDNT=FALSE;            // Is the sort index over a PDNT index?
    BOOL        fNormalSearch = TRUE;
    BOOL        fVLVSearch = FALSE;
    BOOL        fASQSearch = FALSE;
    BOOL        fUseTempSortedTable = FALSE;
    DWORD       fType = 0;
    DWORD       cAncestors=0;
    DWORD       dwOptFlags=0;
    KEY_INDEX  *pSortIndex = NULL;
    KEY_INDEX  *pTempIndex = NULL;
    KEY_INDEX  *pOptimizedIndex = NULL;
    KEY_INDEX  *pDefaultIndex = NULL;
    DWORD       SortFlags = 0;
    KEY_INDEX  *pIndex = NULL;
    DWORD       ulEstimatedRecsTotal = 0;

    INDEX_RANGE rgIndexRange[2]; // we support indices upto 2 components
                                  // excluding PDNT, DNT etc.
    DWORD       cIndexRanges=0;
    NAMING_CONTEXT_LIST *pNCL;
    ULONG       ulEstimatedSubTreeSize = 0;
    ULONG       ulEstimatedDefaultIndex = 0;
    BOOL        fGetNumRecs;
    ATTCACHE    *pAC;
    BOOL        fIndexIsSingleValued = TRUE;
    DWORD       dwErr;
    BOOL        bAppropriateVLVIndexFound = FALSE;
    BOOL        bSkipCreateSortTable = FALSE;
    BOOL        bSkipUseDefaultIndex = FALSE;
    NCL_ENUMERATOR nclEnum;

    KEY_INDEX  *rgpBestIndex[2] = { NULL };
    BOOL        fAncestryIsConsistent = TRUE;

    Assert(VALID_DBPOS(pDB));
    if (  eServiceShutdown
        && !(   (eServiceShutdown == eRemovingClients)
             && (pTHS->fDSA)
             && !(pTHS->fSAM))) {
        // Shutting down, bail.
        return DB_ERR_SHUTTING_DOWN;
    }

    pDB->Key.ulSorted = SORT_NEVER;
    pDB->Key.fSearchInProgress = FALSE;
    pDB->Key.bOnCandidate = FALSE;
    pDB->Key.fChangeDirection = FALSE;
    pDB->Key.dupDetectionType = DUP_NEVER;
    pDB->Key.cDupBlock = 0;
    pDB->Key.pDupBlock = NULL;
    pDB->Key.indexType = UNSET_INDEX_TYPE;

    // init special search flags
    fVLVSearch = Flags & DBCHOOSEINDEX_fVLV_SEARCH;
    fASQSearch = pDB->Key.asqRequest.fPresent;
    // are we instructed to create a temp sort table no matter what the
    // sort index might be ?
    fUseTempSortedTable = Flags & DBCHOOSEINDEX_fUSETEMPSORTEDTABLE;

    // See if the search is tagged with a hint from SAM
    if(pTHS->pSamSearchInformation) {
        SAMP_SEARCH_INFORMATION *pSearchInfo;
        BOOL fUseFilter;

        // Just a typing shortcut.
        pSearchInfo = pTHS->pSamSearchInformation;

        // Save the fUsefilter flag, we might need to restore it.
        fUseFilter = (Flags & DBCHOOSEINDEX_fUSEFILTER);

        // We will not use the filter in this case.
        Flags &= ~DBCHOOSEINDEX_fUSEFILTER;

        // And, we aren't going to go through the normal index choice code.
        fNormalSearch = FALSE;

        //
        // Set up the index ranges structure
        //

        rgIndexRange[0].cbValUpper = pSearchInfo->HighLimitLength1;
        rgIndexRange[0].pvValUpper = (BYTE *)pSearchInfo->HighLimit1;
        rgIndexRange[1].cbValUpper = pSearchInfo->HighLimitLength2;
        rgIndexRange[1].pvValUpper = (BYTE *)pSearchInfo->HighLimit2;

        rgIndexRange[0].cbValLower = pSearchInfo->LowLimitLength1;
        rgIndexRange[0].pvValLower = (BYTE *)pSearchInfo->LowLimit1;
        rgIndexRange[1].cbValLower = pSearchInfo->LowLimitLength2;
        rgIndexRange[1].pvValLower = (BYTE *)pSearchInfo->LowLimit2;

        switch(pSearchInfo->IndexType) {
        case SAM_SEARCH_SID:
            pszDefaultIndex = SZSIDINDEX;
            pindexidDefault = &idxSid;
            fType = 0;
            cIndexRanges = 1;
            break;

        case SAM_SEARCH_NC_ACCTYPE_NAME:
            pszDefaultIndex = SZ_NC_ACCTYPE_NAME_INDEX;
            pindexidDefault = &idxNcAccTypeName;
            // This is so dbmakekeyindex knows we are ncdnt based.
            fType = dbmkfir_NCDNT;
            cIndexRanges = 2;
            break;

        case SAM_SEARCH_NC_ACCTYPE_SID:
            pszDefaultIndex = SZ_NC_ACCTYPE_SID_INDEX;
            pindexidDefault = &idxNcAccTypeSid;
            // This is so dbmakekeyindex knows we are ncdnt based.
            fType = dbmkfir_NCDNT;
            cIndexRanges = 2;
            break;

        case SAM_SEARCH_PRIMARY_GROUP_ID:
            pszDefaultIndex = SZPRIMARYGROUPIDINDEX;
            pindexidDefault = NULL;     // UNDONE: add an index hint for this index
            fType = 0;
            cIndexRanges = 1;
            pAC = SCGetAttById(pTHS, ATT_PRIMARY_GROUP_ID);
            Assert(pAC != NULL);
            fIndexIsSingleValued = pAC->isSingleValued;
            break;

        default:
            //Huh?  Oh, well, skip the search hints.  Undo the setup we did
            // above.
            Assert(FALSE);
            fNormalSearch = TRUE;
            fType = 0;
            Flags |= fUseFilter;
            break;
        }
    }

    if (pDB->Key.ulSearchType == SE_CHOICE_WHOLE_SUBTREE && pDB->DNT != ROOTTAG) {
        // we need to check whether it is safe to use ancestry
        // for subtree searches. SDP might have an outstanding
        // propagation for this object, or it might be currently
        // processing descendants of the object. In either case,
        // ancestry values are not guaranteed to be correct in
        // the subtree.
        // We should be positioned on the root.
        Assert(pDB->DNT == pDB->Key.ulSearchRootDnt);
        dwErr = AncestryIsConsistentInSubtree(pDB, &fAncestryIsConsistent);
        if (dwErr) {
            // we were unable to determine if the ancestry is consistent.
            return dwErr;
        }
    }

    // First, set up the default indices so that we can see how big they are.
    if(fNormalSearch) {

        // this is a NormalSearch (not SAM related)
        switch (pDB->Key.ulSearchType) {
        case SE_CHOICE_BASE_ONLY:
            if (!fASQSearch) {
                pDB->Key.pIndex = dbAlloc(sizeof(KEY_INDEX));
                memset( pDB->Key.pIndex, 0, sizeof(KEY_INDEX) );
                pDB->Key.pIndex->bIsForSort = ( SortType ? TRUE : FALSE );
                pDB->Key.ulSorted = SortType;
                pDB->Key.pIndex->bIsSingleValued = TRUE;
                pDB->Key.pIndex->ulEstimatedRecsInRange = 1;
                return 0;
            }
            break;

        case SE_CHOICE_IMMED_CHLDRN:
            pszDefaultIndex = SZPDNTINDEX;
            pindexidDefault = &idxPdnt;
            rgIndexRange[0].pvValUpper =  rgIndexRange[0].pvValLower
                            = (BYTE *)&pDB->Key.ulSearchRootDnt;
            rgIndexRange[0].cbValUpper =  rgIndexRange[0].cbValLower
                            = sizeof(pDB->Key.ulSearchRootDnt);
            cIndexRanges=1;
            break;

        case SE_CHOICE_WHOLE_SUBTREE:

            // first check whether this sub-tree search starts at root of the DIT
            if (pDB->DNT == ROOTTAG) {
                // we will walk the primary index
                pszDefaultIndex = SZDNTINDEX;
                pindexidDefault = &idxDnt;

                cIndexRanges = 0;

                ulEstimatedSubTreeSize = gulEstimatedAncestorsIndexSize;

                // REVIEW:  the reason we don't intersect with the ancestry in this case
                // REVIEW:  is because we don't wish to include subordinate NCs
                fIntersectDefaultIndex = FALSE;

                DPRINT (1, "Subtree Searching on root of GC\n");
            }
            else {
                // then check to see if it a subtree search starting at a known NC
                NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
                NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_NCDNT, (PVOID)UlongToPtr(pDB->DNT));
                while (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
                    if (pNCL->pAncestors) {
                        // cool. we are doing a subtree search on the start of an NC
                        break;
                    }
                }

                // this is the standard case, an arbitrary subtree search
                if (!pNCL && fAncestryIsConsistent) {
                    // walk the appropriate section of the ancestors index
                    pszDefaultIndex = SZANCESTORSINDEX;
                    pindexidDefault = &idxAncestors;

                    // We do not want to call DBGetAncestors to get ancestry.
                    // This is because if it determines that there are outstanding
                    // propagations, it will construct the "correct" ancestry value
                    // by walking up the parent chain. However, this may be useless for
                    // search if the ancestry on the root has not been updated yet.
                    // In this case, the "correct" ancestry value will not exist in the
                    // DB and the search will be empty. Let's try to do a better job
                    // and read the ancestry value from the DB or from the cache.

                    rgIndexRange[0].cbValLower = 0;
                    rgIndexRange[0].pvValLower = NULL;
                    
                    DBGetAncestorsFromCache(pDB,
                                            &rgIndexRange[0].cbValLower,
                                            (ULONG **)&rgIndexRange[0].pvValLower,
                                            &cAncestors);

                    rgIndexRange[0].pvValUpper = rgIndexRange[0].pvValLower;
                    rgIndexRange[0].cbValUpper = rgIndexRange[0].cbValLower;
                    cIndexRanges = 1;
                }
                // we are doing a subtree search starting at an NC but that NC
                // holds most (>90%) of the objects in the database
                // Also, if we figured out the ancestry index is unsafe to use
                // then we will default to the DNT index.
                //
                // NOTE: the size of the primary index is about the same as the
                // size of the ancestry so we use that size in the comparison
                else if (!fAncestryIsConsistent ||
                         pNCL->ulEstimatedSize > gulEstimatedAncestorsIndexSize ||
                         gulEstimatedAncestorsIndexSize - pNCL->ulEstimatedSize < gulEstimatedAncestorsIndexSize / 10) {
                    // we will walk the primary index
                    pszDefaultIndex = SZDNTINDEX;
                    pindexidDefault = &idxDnt;

                    cIndexRanges = 0;

                    ulEstimatedSubTreeSize = gulEstimatedAncestorsIndexSize;

                    // REVIEW:  the reason we don't intersect with the ancestry in this case
                    // REVIEW:  is because we don't wish to include subordinate NCs
                    fIntersectDefaultIndex = FALSE;

                    DPRINT (1, "Subtree Searching on root instead of on an NC\n");
                }
                // we are doing a subtree search starting at an NC
                else {
                    // walk the appropriate section of the ancestors index
                    pszDefaultIndex = SZANCESTORSINDEX;
                    pindexidDefault = &idxAncestors;

                    rgIndexRange[0].pvValLower = THAllocEx (pTHS, pNCL->cbAncestors);
                    rgIndexRange[0].cbValLower = pNCL->cbAncestors;
                    memcpy (rgIndexRange[0].pvValLower, pNCL->pAncestors, pNCL->cbAncestors);
                    rgIndexRange[0].pvValUpper = rgIndexRange[0].pvValLower;
                    rgIndexRange[0].cbValUpper = rgIndexRange[0].cbValLower;
                    cIndexRanges = 1;

                    ulEstimatedSubTreeSize = pNCL->ulEstimatedSize;

                    // REVIEW:  the reason we don't intersect with the ancestry in this case
                    // REVIEW:  is because we don't wish to include subordinate NCs
                    fIntersectDefaultIndex = FALSE;

                    DPRINT (1, "Subtree Searching on an NC\n");
                }
            }

            ulEstimatedDefaultIndex = ulEstimatedSubTreeSize;

            break;
        }

        Assert (pDB->Key.pIndex == NULL);
    }
    else {
        // this is a special search (SAM), so we need to evaluate this index too
        pDefaultIndex =
            dbMakeKeyIndex(pDB,
                           FI_CHOICE_SUBSTRING,
                           fIndexIsSingleValued,
                           fType,
                           pszDefaultIndex,
                           pindexidDefault,
                           DB_MKI_GET_NUM_RECS | DB_MKI_SET_CURR_INDEX,
                           cIndexRanges,
                           rgIndexRange
                           );

        if (Flags & DBCHOOSEINDEX_fUSEFILTER) {
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_QUERY_INDEX_CONSIDERED,
                     szInsertSz(pszDefaultIndex),
                     szInsertUL(pDefaultIndex->ulEstimatedRecsInRange),
                     NULL);
        }

        ulEstimatedDefaultIndex = pDefaultIndex->ulEstimatedRecsInRange;
    }

    // we should not choose Ancestors as default index if the ancestry values
    // are not consistent.
    Assert(fAncestryIsConsistent || pindexidDefault != &idxAncestors);


    // for asq mode we don't do any optimizations, since they are meaningless
    //
    if (fASQSearch) {
        goto skipOptimizations;
    }

    if(!fVLVSearch && SortType && !fUseTempSortedTable) {
        // An attribute to sort on has been specified.  Set up the name of the
        // index. this is for the simple sort case
        pAC = SCGetAttById(pTHS, SortAttr);
        Assert(pAC != NULL);

        // ISSUE-2002/03/07-andygo:  handling of unknown attributes
        // REVIEW:  shouldn't we throw a schema exception here as we do everywhere else?
        if (!pAC) {
            return DB_ERR_CANT_SORT;
        }

        if(dbSetToIndex(pDB, FALSE, &fPDNT, szTempIndex, &pindexidTemp, pAC)) {
            // Found the required index.

            // We are on the sort index, set up the key.
            // See how many are in the sort index, and what the keys are.  Note
            // that the effective search type on this index is present
            // (i.e. we're looking for anything that has a value for the sort
            // index).

            pSortIndex = dbMakeKeyIndex(pDB,
                                        FI_CHOICE_PRESENT,
                                        pAC->isSingleValued,
                                        (fPDNT?dbmkfir_PDNT:0),
                                        szTempIndex,
                                        pindexidTemp,
                                        DB_MKI_GET_NUM_RECS,
                                        0,
                                        NULL
                                        );

            pSortIndex->bIsForSort = TRUE;

            pSortIndex->pAC = pAC;

            pSortIndex->bIsPDNTBased = fPDNT;
            // Keep the sort index around, but don't put it in place of the
            // default indices just yet.
        }
    }
    else if (fVLVSearch) {

        FILTER *pFirstFilter, *pSecondFilter;

        // since we are doing vlv, we have an attribute to sort on.
        // set up the index and see if it is a good one.
        pAC = SCGetAttById(pTHS, SortAttr);
        Assert(pAC != NULL);

        // ISSUE-2002/03/07-andygo:  handling of unknown attributes
        // REVIEW:  shouldn't we throw a schema exception here as we do everywhere else?
        if (!pAC) {
            return DB_ERR_CANT_SORT;
        }

        // check for MAPI like VLV search
        // check to see if this a ROOT search, asking for subtree,
        // that refers to a MAPI container.
        // If so we have to transform this query.
        // what an if statement !!
        //
        if ( (pDB->Key.ulSearchRootDnt == ROOTTAG ) &&
             (pDB->Key.ulSearchType == SE_CHOICE_WHOLE_SUBTREE ) &&
             (pAC->id == ATT_DISPLAY_NAME) &&
             pDB->Key.pFilter &&
             (pDB->Key.pFilter->choice == FILTER_CHOICE_AND) &&
             (pFirstFilter = pDB->Key.pFilter->FilterTypes.And.pFirstFilter) &&
             (pFirstFilter->choice == FILTER_CHOICE_ITEM) &&
             (pFirstFilter->FilterTypes.Item.choice == FI_CHOICE_EQUALITY) &&
             (pFirstFilter->FilterTypes.Item.FilTypes.ava.type == ATT_SHOW_IN_ADDRESS_BOOK) &&
             (pSecondFilter = pFirstFilter->pNextFilter) &&
             (pSecondFilter->choice == FILTER_CHOICE_ITEM) &&
             (pSecondFilter->FilterTypes.Item.choice == FI_CHOICE_PRESENT) &&
             (pSecondFilter->FilterTypes.Item.FilTypes.present == ATT_DISPLAY_NAME)) {

            ATTCACHE    *pABAC;
            INDEX_RANGE IndexRange;
            AVA         *pAVA;

            pABAC = SCGetAttById(pTHS, ATT_SHOW_IN_ADDRESS_BOOK);
            Assert(pABAC != NULL);

            if (dbSetToIndex(pDB, TRUE, &fPDNT, szTempIndex, &pindexidTemp, pABAC)) {

                pAVA = &pDB->Key.pFilter->FilterTypes.And.pFirstFilter->FilterTypes.Item.FilTypes.ava;

                // fake this as a one level search
                pDB->Key.ulSearchType = SE_CHOICE_IMMED_CHLDRN;
                pDB->Key.ulSearchRootDnt = *(DWORD *)pAVA->Value.pVal;

                pDB->Key.pVLV->bUsingMAPIContainer = TRUE;
                pDB->Key.pVLV->MAPIContainerDNT = *(DWORD *)pAVA->Value.pVal;
                DPRINT1 (0, "VLV/MAPI on container: %d\n", pDB->Key.ulSearchRootDnt);

                IndexRange.cbValLower = pAVA->Value.valLen;
                IndexRange.pvValLower = pAVA->Value.pVal;
                IndexRange.cbValUpper = pAVA->Value.valLen;
                IndexRange.pvValUpper = pAVA->Value.pVal;

                pSortIndex = dbMakeKeyIndex(pDB,
                                            FI_CHOICE_PRESENT,
                                            pAC->isSingleValued,
                                            0,
                                            szTempIndex,
                                            pindexidTemp,
                                            DB_MKI_GET_NUM_RECS,
                                            1,
                                            &IndexRange
                                            );

                bAppropriateVLVIndexFound = TRUE;

                pSortIndex->bIsForSort = TRUE;

                pSortIndex->pAC = pAC;

            }
            else {
                DPRINT (0, "Doing VLV(MAPI like) and no INDEX found\n");
            }
        }
        else if(dbSetToIndex(pDB, FALSE, &fPDNT, szTempIndex, &pindexidTemp, pAC)) {
            // Found the required index.

            // We are on the sort index, set up the key.
            // See how many are in the sort index, and what the keys are.

            // Note that the effective search type on this index is present.
            // (i.e. we're looking for anything that has a value for the sort
            // index under the specified container).

            DPRINT1 (1, "Using Index for VLV %s\n", szTempIndex);

            pSortIndex = dbMakeKeyIndex(pDB,
                                        FI_CHOICE_PRESENT,
                                        pAC->isSingleValued,
                                        (fPDNT?dbmkfir_PDNT:0),
                                        szTempIndex,
                                        pindexidTemp,
                                        DB_MKI_GET_NUM_RECS,
                                        0,
                                        NULL
                                        );

            pSortIndex->pAC = pAC;

            if (pDB->Key.ulSearchType == SE_CHOICE_IMMED_CHLDRN) {

                if (fPDNT == FALSE) {
                    // we found an index, but we would be better of if we had a
                    // PDNT index on this sorted attribute, since we are doing
                    // VLV in one level

                    DPRINT (0, "Doing VLV on Immediate Children and no PDNT INDEX found\n");

                    // HINT: when WMI is available, use trace for this event
                    LogEvent8(DS_EVENT_CAT_FIELD_ENGINEERING,
                             DS_EVENT_SEV_EXTENSIVE,
                             DIRLOG_SEARCH_VLV_INDEX_NOT_FOUND,
                             szInsertSz(pAC->name),
                             NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                }
                else {
                    // we have a VLV sort index, and this is a good one

                    bAppropriateVLVIndexFound = TRUE;

                    pSortIndex->bIsPDNTBased = fPDNT;
                }
            }

            pSortIndex->bIsForSort = TRUE;
            // Keep the sort index around, but don't put it in place of the
            // default indices just yet.
        }
        else {
            // we didn't find the required index for sorting
            // if we are doing VLV we want to keep track of the requested
            // index, cause we might rebuild this index later

            DPRINT (1, "Doing VLV and no appropriate INDEX found\n");

            if (pDB->Key.ulSearchType == SE_CHOICE_IMMED_CHLDRN) {

                // HINT: when WMI is available, use trace for this event
                LogEvent8(DS_EVENT_CAT_FIELD_ENGINEERING,
                         DS_EVENT_SEV_EXTENSIVE,
                         DIRLOG_SEARCH_VLV_INDEX_NOT_FOUND,
                         szInsertSz(pAC->name),
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            }
        }
    }


    // now optimize the filter if we are allowed to.
    // we optimize the filter if the flags say so and the estimated default index
    // is unknown or is more that a specified number of entries, cause we believe
    // we might do better, by taking the risk of the extra cycles

    // PERFHINT: we need to know later if we ever find a more restrictive index
    // range over the index we are sorting on (if we are sorting), and
    // dbOptFilter doesn't give back that info.  If we do, then in the case
    // later on where we have to fall back to walking the search index, we can
    // use the better limits.  We might even find that two subranges of the
    // index were found, which if disjoing implies a null result set, and if not
    // disjoint, implies a smaller range.

    if ((Flags & DBCHOOSEINDEX_fUSEFILTER) &&
         ( (ulEstimatedDefaultIndex == 0) ||
           (ulEstimatedDefaultIndex > MIN_NUM_ENTRIES_ON_OPT_INDEX)) ) {

        // if this is a paged search or
        // a VLV search and a sort index was not found,
        // we cannot use index intersections cause there is
        // no efficient way  to restart intersect index operations

        if ((Flags & DBCHOOSEINDEX_fPAGED_SEARCH) ||
            (fVLVSearch && bAppropriateVLVIndexFound) ||
            ((SortType == SORT_OPTIONAL) && !fVLVSearch)) {

            dwOptFlags |= DBOPTINDEX_fDONT_INTERSECT;
        }
        if (Flags & DBCHOOSEINDEX_fDELETIONS_VISIBLE) {
            //
            // Tuple indexes do not include deleted object, so we can't
            // use them on a search that must return deleted objects.
            //
            dwOptFlags |= DBOPTINDEX_fDONT_OPT_MEDIAL_SUBSTRING;
        }

        dbOptFilter(pDB,
                    dwOptFlags,
                    &pOptimizedIndex,
                    pDB->Key.pFilter);

        if(pOptimizedIndex) {
            // if we are sorting, and it happened that the filter
            // matched the sort order (same index), we are not going to
            // drop this one, even if the index that we have now
            // (propably ancestors index) might be a better choice
            if (pSortIndex &&
                pOptimizedIndex->pNext == NULL &&
                pOptimizedIndex->szIndexName &&
                !fVLVSearch &&
                strcmp (pOptimizedIndex->szIndexName, pSortIndex->szIndexName) == 0) {

                    bSkipCreateSortTable = TRUE;
                    bSkipUseDefaultIndex = TRUE;

                    DPRINT2 (1, "Using Sorted Index: %s %d\n",
                            pOptimizedIndex->szIndexName,
                            pOptimizedIndex->ulEstimatedRecsInRange);

                    if (pDefaultIndex) {
                        dbFreeKeyIndex(pTHS, pDefaultIndex);
                        pDefaultIndex = NULL;
                    }
                    pOptimizedIndex->bIsForSort = TRUE;
            }
        }
    }

    // now have a look at the default index, if needed
    //
    if (fNormalSearch &&
        (!bSkipUseDefaultIndex) &&
        ( (pOptimizedIndex== NULL) ||
          (pOptimizedIndex->ulEstimatedRecsInRange > MIN_NUM_ENTRIES_ON_OPT_INDEX) ) ) {

        Assert (pDefaultIndex == NULL);

        // if we know the size (ulEstimatedSubTreeSize != 0),
        //    then there is no need calculating it again
        // if we don't know the size (ulEstimatedSubTreeSize == 0)
        //    then we have to calculate the size only if we had an index as a
        //    result of the filter optimization (pOptimizedIndex) or we
        //    are considering of using a sortIndex (pSortIndex).
        fGetNumRecs = ulEstimatedSubTreeSize ?
                          0 : ( (pOptimizedIndex!=NULL) || (pSortIndex!=NULL) );

        // now evaluate the index
        pDefaultIndex =
            dbMakeKeyIndex(pDB,
                           FI_CHOICE_SUBSTRING,
                           fIndexIsSingleValued,
                           fType,
                           pszDefaultIndex,
                           pindexidDefault,
                           (fGetNumRecs ? DB_MKI_GET_NUM_RECS : 0) | DB_MKI_SET_CURR_INDEX,
                           cIndexRanges,
                           rgIndexRange
                           );

        // when fGetNumRecs is FALSE, this means that ulEstimatedSubTreeSize !=0 or
        // that we don't care, since we don't have an optimized index or sort index,
        // so we don't bother finding the real value of the entries which is set
        // to zero in dbMakeKeyIndex.

        if (ulEstimatedSubTreeSize) {
            pDefaultIndex->ulEstimatedRecsInRange = ulEstimatedSubTreeSize;
            DPRINT1 (1, "Used estimated subtree size: %d\n", ulEstimatedSubTreeSize);
        }

        if (Flags & DBCHOOSEINDEX_fUSEFILTER) {
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_QUERY_INDEX_CONSIDERED,
                     szInsertSz(pszDefaultIndex),
                     szInsertUL(pDefaultIndex->ulEstimatedRecsInRange),
                     NULL);
        }
    }

    // decide which index is better, the default or the optimized one ?
    //
    if (pDefaultIndex) {
        if (pOptimizedIndex) {
            if (pOptimizedIndex->ulEstimatedRecsInRange <
                      pDefaultIndex->ulEstimatedRecsInRange) {
                // the optimized index was better than the default one
                rgpBestIndex[0] = pOptimizedIndex;
                pOptimizedIndex = NULL;
                rgpBestIndex[1] = pDefaultIndex;
                pDefaultIndex = NULL;
            }
            else {
                rgpBestIndex[0] = pDefaultIndex;
                pDefaultIndex = NULL;
                rgpBestIndex[1] = pOptimizedIndex;
                pOptimizedIndex = NULL;
            }
        }
        else {
            rgpBestIndex[0] = pDefaultIndex;
            pDefaultIndex = NULL;
        }
    }
    else {
        rgpBestIndex[0] = pOptimizedIndex;
        pOptimizedIndex = NULL;
    }

    // if we still have two indices and those indices are over the datatable and
    // both are simple indices (i.e. not a temp table or containerized index)
    // then see if intersecting them won't help us further reduce the records
    // to traverse

    if (rgpBestIndex[0] && rgpBestIndex[1] && fIntersectDefaultIndex &&
        (!rgpBestIndex[0]->pNext &&
         (!rgpBestIndex[0]->pAC || !rgpBestIndex[0]->pAC->ulLinkID) &&
         !rgpBestIndex[0]->bIsPDNTBased &&
         !rgpBestIndex[0]->bIsIntersection) &&
        (!rgpBestIndex[1]->pNext &&
         (!rgpBestIndex[1]->pAC || !rgpBestIndex[1]->pAC->ulLinkID) &&
         !rgpBestIndex[1]->bIsPDNTBased &&
         !rgpBestIndex[1]->bIsIntersection)) {
        DPRINT (1, "Attempting to intersect scope and filter index ranges\n");
        dbOptAndIntersectFilter(pDB,
                                    dwOptFlags,
                                    &pDB->Key.pIndex,
                                    rgpBestIndex,
                                    2);
        if (!pDB->Key.pIndex) {
            //  there must have been an error so choose the smaller index range
            pDB->Key.pIndex = rgpBestIndex[0];
            rgpBestIndex[0] = NULL;
        }
    }
    else {
        pDB->Key.pIndex = rgpBestIndex[0];
        rgpBestIndex[0] = NULL;
    }
    dbFreeKeyIndex(pTHS, rgpBestIndex[0]);
    dbFreeKeyIndex(pTHS, rgpBestIndex[1]);

    Assert (pDB->Key.pIndex);

    // if the chosen index ranges represent a very large fraction of the DIT
    // then it will be much more efficient to simply walk the primary index
    //
    // NOTE: the size of the primary index is about the same as the size of the
    // ancestry so we use that size in the comparison

    if (pDB->Key.pIndex->pindexid != &idxDnt &&
        fNormalSearch &&
        !pDB->Key.pIndex->bIsForSort &&
        (pDB->Key.pIndex->ulEstimatedRecsInRange > gulEstimatedAncestorsIndexSize ||
         gulEstimatedAncestorsIndexSize - pDB->Key.pIndex->ulEstimatedRecsInRange < gulEstimatedAncestorsIndexSize / 10)) {
        dbFreeKeyIndex(pTHS, pDB->Key.pIndex);
        pDB->Key.pIndex = dbMakeKeyIndex(pDB,
                                         FI_CHOICE_SUBSTRING,
                                         TRUE,
                                         0,
                                         SZDNTINDEX,
                                         &idxDnt,
                                         DB_MKI_SET_CURR_INDEX,
                                         0,
                                         rgIndexRange
                                         );
        pDB->Key.pIndex->ulEstimatedRecsInRange = gulEstimatedAncestorsIndexSize;
        DPRINT(1, "Scanning entire primary index instead of walking very large index range(s)\n");
    }

skipOptimizations:

    if (  eServiceShutdown
        && !(   (eServiceShutdown == eRemovingClients)
             && (pTHS->fDSA)
             && !(pTHS->fSAM))) {
        // Shutting down, bail.
        return DB_ERR_SHUTTING_DOWN;
    }

    // Assume we have sorted if they asked us to.
    pDB->Key.ulSorted = SortType;

    if (SortType && !fASQSearch && !fVLVSearch &&
        (IsExactMatch(pDB) ||
         pDB->Key.pFilter &&
         pDB->Key.pFilter->choice == FILTER_CHOICE_ITEM &&
         pDB->Key.pFilter->FilterTypes.Item.choice == FI_CHOICE_FALSE)) {
        // if we know that there are less than two results then no sorting is
        // required because they are already sorted.  note that we already
        // handle the non-ASQ base search case above
    }
    else if(SortType && !fASQSearch) {
        if(pSortIndex) {
            MaxTempTableSize = min(MaxTempTableSize,
                                   (pSortIndex->ulEstimatedRecsInRange +
                                    pDB->Key.pIndex->ulEstimatedRecsInRange));

            if (!bSkipCreateSortTable) {
                if (pDB->Key.pIndex &&
                    pDB->Key.pIndex->pNext == NULL &&
                    pDB->Key.pIndex->szIndexName &&
                    !fVLVSearch &&
                    strcmp (pDB->Key.pIndex->szIndexName, pSortIndex->szIndexName) == 0) {

                        bSkipCreateSortTable = TRUE;

                        DPRINT2 (1, "Using Sorted Index: %s %d\n",
                                pDB->Key.pIndex->szIndexName,
                                pDB->Key.pIndex->ulEstimatedRecsInRange);

                        pDB->Key.pIndex->bIsForSort = TRUE;
                }
                else if (bAppropriateVLVIndexFound) {

                    bSkipCreateSortTable = TRUE;

                    DPRINT2 (1, "Using Sorted Index: %s %d\n",
                            pSortIndex->szIndexName,
                            pSortIndex->ulEstimatedRecsInRange);
                }
            }
        }

        if (!bSkipCreateSortTable) {
            if (Flags & DBCHOOSEINDEX_fREVERSE_SORT) {
                SortFlags = SortFlags | DB_SORT_DESCENDING;
            }
            for (pIndex = pDB->Key.pIndex; pIndex != NULL; pIndex = pIndex->pNext) {
                ulEstimatedRecsTotal += pIndex->ulEstimatedRecsInRange;
            }
            if (ulEstimatedRecsTotal >= MIN_NUM_ENTRIES_FOR_FORWARDONLY_SORT &&
                !(Flags & DBCHOOSEINDEX_fUSETEMPSORTEDTABLE)) {
                SortFlags = SortFlags | DB_SORT_FORWARDONLY;
            }
        }

        // OK, we are to sort.  See if we should use a pre-sort.
        if( (bSkipCreateSortTable || dbCreateSortedTable(pDB,
                                                  StartTick,
                                                  DeltaTick,
                                                  SortAttr,
                                                  SortFlags,
                                                  MaxTempTableSize) ) ) {

            // Either we couldn't create a pre-sort, or we thought it was too
            // big. Our only fall back now is to use a sort index.
            if(!pSortIndex) {
                // We can't sort.
                pDB->Key.ulSorted = SORT_NEVER;

                // See if we need to care.
                if (fVLVSearch) {
                    return DB_ERR_CANT_SORT;
                }
                else if(SortType == SORT_MANDATORY || fUseTempSortedTable) {
                    // Yes, we need to care.
                    return DB_ERR_CANT_SORT;
                }
                // the sort was optional so blow it off
                else if (Flags & DBCHOOSEINDEX_fREVERSE_SORT) {
                    // HACK:  hide the fact that a descending sort was requested
                    // HACK:  via this flag.  we have to do this because the
                    // HACK:  code is poorly structured wrt sorting
                    pDB->Key.fChangeDirection = TRUE;
                }

                // REVIEW:  if we get here and the input index for the sorted
                // REVIEW:  table was an intersect index then there is no way to
                // REVIEW:  efficiently restart the walk of those records so we
                // REVIEW:  cannot continue!  if we do continue then we will only
                // REVIEW:  return the records that were not consumed in the failed
                // REVIEW:  sort attempt (after the first 10k results, typically).
                // REVIEW:  this will not be detectable by the user unless there are
                // REVIEW:  not enough remaining records to hit the size or time
                // REVIEW:  limits.  this is why we currently do not allow the use
                // REVIEW:  of intersection when an optional sort has been requested
            }
            else {
                if (fVLVSearch && (bSkipCreateSortTable == FALSE)) {
                    // we are doing VLV and the sortindex that we had was not good
                    // we expected to be able to create a SORT table, but we failed
                    return DB_ERR_CANT_SORT;
                }
                // use the sort index we found for VLV
                else if (bAppropriateVLVIndexFound) {

                    if (pDB->Key.pIndex) {
                        dbFreeKeyIndex (pTHS, pDB->Key.pIndex);
                    }
                    pDB->Key.pIndex = pSortIndex;
                    pSortIndex = NULL;
                }
                // We can sort
                else if(SortType == SORT_MANDATORY) {
                    // And, we have to sort.  Stitch the sort index in to the
                    // list of indices to walk.

                    // The index already in the key will find every object that
                    // matches the filter.  The pSortIndex will match every
                    // object in the filter (and lots more besides) EXCEPT those
                    // objects which have a NULL value.  Thus, to satisfy a
                    // forward sort, we will first walk the sort index then the
                    // rest of the indices.  This gets us all the objects with
                    // values for the sort attribute in the correct order, and
                    // then the objects with NULL values sorted to the end of
                    // the list. A mechanism in dbMatchSearchCriteria keeps us
                    // from return objects twice.  Also, it lets us ignore those
                    // objects on the sort index that effectively have no value
                    // for the sort attribute due to security (note we then pick
                    // them up in the other indices).  So, to make everything
                    // work out, we add the sort index to the head of the list
                    // of indices.  Entries with no value for for the sort attr
                    // will always be sorted to the end.

                    // if it happened that the sort index and the filter index
                    // are the same (bSkipCreateSortTable==TRUE from above),
                    // we should use only one of them. so we choose to use
                    // the index from the filter optimization (since it is better)
                    // (we don't worry about skipping null entries which are included
                    // in the sortIndex, since the filter wouldn't match them anyway.)

                    // if we cannot simply walk the filter index and this is a
                    // descending sort then we cannot stitch the filter and sort
                    // indices together in a manner that will return objects
                    // with null or unknown entries first without sorting the
                    // entire result set.  since we already tried to do that and
                    // failed, we are forced to fail the sort
                    if (!bSkipCreateSortTable) {
                        if (Flags & DBCHOOSEINDEX_fREVERSE_SORT) {
                            return DB_ERR_CANT_SORT;
                        }
                        pSortIndex->pNext = pDB->Key.pIndex;
                        pSortIndex->ulEstimatedRecsInRange +=
                            pDB->Key.pIndex->ulEstimatedRecsInRange;
                        pDB->Key.pIndex = pSortIndex;

                        // we no longer need it. it will be freed when
                        // pDB->key is freed
                        pSortIndex = NULL;
                    }
                }
                else {
                    // OK, we don't actually have to sort.  However, we could if
                    // we wanted to.
                    // For now, we don't sort.  We could check to see if
                    // this makes the ulEstimatedRecsInRange not too much
                    // larger, and sort if it doesn't.  Later.
                    pDB->Key.ulSorted = SORT_NEVER;
                    if (Flags & DBCHOOSEINDEX_fREVERSE_SORT) {
                        // HACK:  hide the fact that a descending sort was requested
                        // HACK:  via this flag.  we have to do this because the
                        // HACK:  code is poorly structured wrt sorting
                        pDB->Key.fChangeDirection = TRUE;
                    }
                }
            }
        }
    }
    else if(SortType && fASQSearch) {
        DPRINT (1, "Doing Sorted ASQ\n");

        if (dwErr = dbCreateASQTable(pDB,
                                     StartTick,
                                     DeltaTick,
                                     SortAttr,
                                     MaxTempTableSize) ) {
            if (dwErr == DB_ERR_NO_SORT_TABLE || dwErr == DB_ERR_TOO_MANY) {
                return DB_ERR_CANT_SORT;
            } else {
                return dwErr;
            }
        }
    }
    else if (fASQSearch) {
        DPRINT (1, "Doing Simple ASQ\n");

        if (dwErr = dbCreateASQTable(pDB,
                                     StartTick,
                                     DeltaTick,
                                     0,
                                     0) ) {
            return dwErr;
        }
    }

    if (pSortIndex) {
        dbFreeKeyIndex (pTHS, pSortIndex);
    }

    if (fVLVSearch && pDB->Key.pIndex) {

        // if the estimated size for this VLV search is very small and it is
        // truly an estimate (which only happens for a normal index) then we
        // must get an exact count.  the reason for this is that DBPositionVLVSearch
        // will return no entries if the VLV content count (which is based on
        // this estimate) is zero so we must be sure that it is only zero if it
        // is in fact zero.  this also makes the content count for small containers
        // very accurate
        if (pDB->Key.pIndex->ulEstimatedRecsInRange < EPSILON) {

            JetSetCurrentIndex4Success(pDB->JetSessID,
                                       pDB->JetObjTbl,
                                       pDB->Key.pIndex->szIndexName,
                                       pDB->Key.pIndex->pindexid,
                                       0);
            JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetObjTbl,
                         pDB->Key.pIndex->rgbDBKeyLower,
                         pDB->Key.pIndex->cbDBKeyLower,
                         JET_bitNormalizedKey);
            JetSeekEx(pDB->JetSessID, pDB->JetObjTbl, JET_bitSeekGE);
            JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetObjTbl,
                         pDB->Key.pIndex->rgbDBKeyUpper,
                         pDB->Key.pIndex->cbDBKeyUpper,
                         JET_bitNormalizedKey);
            JetSetIndexRangeEx(pDB->JetSessID,
                               pDB->JetObjTbl,
                               JET_bitRangeInclusive | JET_bitRangeUpperLimit);
            pDB->Key.pIndex->ulEstimatedRecsInRange = 0;
            JetIndexRecordCountEx(pDB->JetSessID,
                                  pDB->JetObjTbl,
                                  &pDB->Key.pIndex->ulEstimatedRecsInRange,
                                  EPSILON);
        }

        // set the initial content count and current position for this VLV
        pDB->Key.pVLV->contentCount = pDB->Key.pIndex->ulEstimatedRecsInRange;
        pDB->Key.pVLV->currPosition = 1;
    }

    if(SORTED_INDEX (pDB->Key.indexType)) {
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_VERBOSE,
                 DIRLOG_QUERY_INDEX_CHOSEN,
                 szInsertSz("Sorted Temporary Table"),
                 NULL,
                 NULL);
    }
    else if (fASQSearch) {
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_VERBOSE,
                 DIRLOG_QUERY_INDEX_CHOSEN,
                 szInsertSz("ASQ Table"),
                 NULL,
                 NULL);
    }
    else {
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_VERBOSE,
                 DIRLOG_QUERY_INDEX_CHOSEN,
                 szInsertSz(pDB->Key.pIndex->szIndexName),
                 NULL,
                 NULL);
    }

    // Set up the temp table to filter out duplicates.
    if((pDB->Key.indexType == TEMP_TABLE_INDEX_TYPE) || fVLVSearch || fASQSearch) {
        pDB->Key.dupDetectionType = DUP_NEVER;
    }
    else if(pDB->Key.pIndex->bIsSingleValued &&
            !pDB->Key.pIndex->pNext &&
            !pDB->Key.pIndex->bIsTupleIndex) {
        // We're walking one, single-valued, index.  We believe that we'll never
        // find duplicates.

        // we could also use this if we are walking multiple ranges of
        // one single-valued attribute.
        pDB->Key.dupDetectionType = DUP_NEVER;
    }
    else if(pDB->Key.pIndex->bIsEqualityBased &&
            !pDB->Key.pIndex->pNext) {
        // We're walking one index, doing an equality search.  Our range on the
        // index should include ONLY those values which are equal.  Since it is
        // impossible for an object to have multiple equal values for a single
        // attribute, we believe that this range of the index will never have a
        // duplicate in it.  So, set the duplicate detection algorithm to not
        // check for duplicates.
        pDB->Key.dupDetectionType = DUP_NEVER;
    }
    else {
        // OK, create the memory block to track duplicates
        pDB->Key.pDupBlock = THAllocEx(pTHS, DUP_BLOCK_SIZE * sizeof(DWORD));
        pDB->Key.cDupBlock = 0;
        pDB->Key.dupDetectionType = DUP_MEMORY;
    }

    return 0;
}

// translate a value from external to internal format, moving from one ATTRVAL
// to another

DWORD
MakeInternalValue (
        DBPOS *pDB,
        int syntax,
        ATTRVAL *pInAVal,
        ATTRVAL *pOutAVal)
{
    THSTATE *pTHS=pDB->pTHS;
    UCHAR *puc;
    ULONG intLen;


    int status =  gDBSyntax[syntax].ExtInt(pDB,
                                           DBSYN_INQ,
                                           pInAVal->valLen,
                                           pInAVal->pVal,
                                           &intLen,
                                           &puc,
                                           0,
                                           0,
                                           0);

    Assert(VALID_DBPOS(pDB));

    if (status)
        return status;

    pOutAVal->valLen = intLen;
    pOutAVal->pVal = THAllocEx(pTHS, intLen);
    memcpy(pOutAVal->pVal, puc, intLen);

    return 0;
}

DWORD dbFreeFilterItem (DBPOS *pDB, FILTER *pFil)
{
    THSTATE *pTHS = pDB->pTHS;
    SUBSTRING *pSub;
    ANYSTRINGLIST *pAny, *pAny2;

    if (!pFil) {
        return 0;
    }
    Assert (pFil->choice == FILTER_CHOICE_ITEM);

    switch(pFil->FilterTypes.Item.choice) {
    case FI_CHOICE_SUBSTRING:

        pSub = pFil->FilterTypes.Item.FilTypes.pSubstring;

        if (pSub) {
            if (pSub->initialProvided && pSub->InitialVal.pVal) {
                THFreeEx (pTHS, pSub->InitialVal.pVal);
            }
            if (pSub->finalProvided && pSub->FinalVal.pVal) {
                THFreeEx (pTHS, pSub->FinalVal.pVal);
            }

            if (pSub->AnyVal.count) {

                pAny = pSub->AnyVal.FirstAnyVal.pNextAnyVal;

                if (pSub->AnyVal.FirstAnyVal.AnyVal.pVal) {
                    THFreeEx (pTHS, pSub->AnyVal.FirstAnyVal.AnyVal.pVal);
                }

                while (pAny) {
                    pAny2 = pAny->pNextAnyVal;

                    THFreeEx (pTHS, pAny->AnyVal.pVal);

                    pAny = pAny2;
                }

                if (pSub->AnyVal.FirstAnyVal.pNextAnyVal) {
                    THFreeEx(pTHS, pSub->AnyVal.FirstAnyVal.pNextAnyVal);
                }
            }

            THFreeEx (pTHS, pSub);
        }
        break;

    case FI_CHOICE_PRESENT:
    case FI_CHOICE_TRUE:
    case FI_CHOICE_FALSE:
    case FI_CHOICE_UNDEFINED:
        break;

    default:
        if (pFil->FilterTypes.Item.FilTypes.ava.Value.pVal) {
            THFreeEx (pTHS, pFil->FilterTypes.Item.FilTypes.ava.Value.pVal);
        }
        break;
    }

    return 0;
}

DWORD dbFreeFilter(DBPOS *pDB, FILTER *pFil)
{
    THSTATE *pTHS = pDB->pTHS;
    FILTER *pTemp, *pTemp2;
    DWORD err;

    if (!pFil || pDB->Key.fDontFreeFilter) {
        return 0;
    }

    pTemp = pFil;

    while (pTemp) {
        pTemp2 = pTemp->pNextFilter;

        switch (pTemp->choice) {
        case FILTER_CHOICE_AND:
            if (err = dbFreeFilter (pDB, pTemp->FilterTypes.And.pFirstFilter)) {
                return err;
            }
            break;

        case FILTER_CHOICE_OR:
            if (err = dbFreeFilter (pDB, pTemp->FilterTypes.Or.pFirstFilter)) {
                return err;
            }
            break;

        case FILTER_CHOICE_NOT:
            if (err = dbFreeFilter (pDB, pTemp->FilterTypes.pNot)) {
                return err;
            }
            break;

        case FILTER_CHOICE_ITEM:

            if (err = dbFreeFilterItem (pDB, pTemp)) {
                return err;
            }
            break;

        default:
            return DB_ERR_UNKNOWN_ERROR;

        }  /*switch FILTER*/

        THFreeEx (pTHS, pTemp);

        pTemp = pTemp2;
    }

    return 0;
}

DWORD
IsConstFilterType (
        FILTER * pFil
        )
{
    if(pFil->choice == FILTER_CHOICE_ITEM) {
        return pFil->FilterTypes.Item.choice;
    }
    else {
        return FI_CHOICE_PRESENT;
    }
}

DWORD
dbMakeANRItem (
        DBPOS   *pDB,
        FILITEM *pFilterItem,
        BOOL     fExact,
        ATTRTYP  aid,
        ATTRVAL *pVal
        )
/*++
Make an ANR filter item based on the incoming pVal.  pVal should be holding a
unicode valued, aid holds the attribute we're going to search for, pFilterItem
is the pointer to the item filter to instantiate.  If fExact, we're need to do
an equality filter, otherwise it's an initial substring filter.

--*/
{
    THSTATE   *pTHS=pDB->pTHS;
    ATTCACHE  *pAC;
    SUBSTRING *pOut;
    ATTRVAL   *pOutVal;
    ATTRVAL   TempVal;

    if(!fExact) {
        pOut = THAllocEx(pTHS, sizeof(SUBSTRING));
        pFilterItem->FilTypes.pSubstring = pOut;
        pFilterItem->choice  = FI_CHOICE_SUBSTRING;

        pOut->type = aid;
        pOut->initialProvided = TRUE;
        pOut->finalProvided = FALSE;
        pOut->AnyVal.count = 0;
        pOut->AnyVal.FirstAnyVal.pNextAnyVal = NULL;
        pOutVal = &pOut->InitialVal;

    }
    else {
        // Do an exact equality match.
        pFilterItem->choice  = FI_CHOICE_EQUALITY;
        pFilterItem->FilTypes.ava.type = aid;
        pOutVal = &pFilterItem->FilTypes.ava.Value;
    }

    pAC = SCGetAttById(pTHS, aid);
    if(pAC) {
        switch(pAC->syntax) {
        case SYNTAX_UNICODE_TYPE:

            return MakeInternalValue(pDB,
                                     pAC->syntax,
                                     pVal,
                                     pOutVal);

            break;

        case SYNTAX_CASE_STRING_TYPE:
        case SYNTAX_NOCASE_STRING_TYPE:
        case SYNTAX_PRINT_CASE_STRING_TYPE:
            // These are all string 8 types.  Translate to string 8

            TempVal.pVal =
                String8FromUnicodeString(TRUE,
                                         CP_TELETEX,
                                         (wchar_t *)pVal->pVal,
                                         pVal->valLen/sizeof(wchar_t),
                                         &TempVal.valLen,
                                         NULL);

            return MakeInternalValue(pDB,
                                     pAC->syntax,
                                     &TempVal,
                                     pOutVal);
            break;
        default:
            DPRINT1(2, "DBMakeANRItem got bad syntax, %X\n", pAC->syntax);
            Assert(!"DBMakeANRItem got bad syntax, %X\n");
            return DB_ERR_UNKNOWN_ERROR;
            break;
        }
    }

    DPRINT1(2, "DBMakeANRItem got unknowtn attribute, %X\n", aid);
    Assert(!"DBMakeANRItem got unknowtn attribute, %X\n");
    // ISSUE-2002/03/07-andygo:  handling of unknown attributes
    // REVIEW:  we should throw a schema exception like we do elsewhere
    return DB_ERR_UNKNOWN_ERROR;
}

VOID
dbMakeANRFilter (
        DBPOS *pDB,
        FILTER *pFil,
        FILTER **ppOutFil
        )
/*++
  Given an ANR item filter and a pointer to already allocated output filter,
  make the output filter into a valid ANR filter tree.
  Returns 0 for success.
  Returns non-zero for error, and frees all allocated memory INCLUDING the
  ppOutFil.
--*/
{
    THSTATE    *pTHS=pDB->pTHS;
    USHORT     count=0, itemCount = 0;
    PFILTER    pOutFil;
    PFILTER    pTemp = NULL, pTemp2 = NULL;
    DWORD      dwStatus;
    ATTRVAL   *pVal;
    DWORD     *pIDs = NULL;
    DWORD      i;
    wchar_t   *pStringTemp;
    wchar_t   *pFirst=NULL, *pLast=NULL;
    DWORD      cbFirst=0, cbLast = 0;
    BOOL       fExact=FALSE;
    ULONG      expectedIndexSize;


    pDB->Key.fDontFreeFilter = TRUE;

    // Make an 'OR' filter over the various ANR attributes
    pOutFil = *ppOutFil;

    pOutFil->choice = FILTER_CHOICE_OR;

    // Pluck out the string to ANR on.  If they gave us a substring filter, we
    // use the initial value and ignore the rest.  If they gave us a normal
    // filter, use the string from that.  Note that we don't pay any attention
    // to the type of filter they specified (i.e. ==, <= , etc.).
    if(pFil->FilterTypes.Item.choice == FI_CHOICE_SUBSTRING) {
        if(!pFil->FilterTypes.Item.FilTypes.pSubstring->initialProvided) {
            // No initial substring.  Turn this into an undefined.
            pOutFil->choice = FILTER_CHOICE_ITEM;
            pOutFil->FilterTypes.Item.choice = FI_CHOICE_UNDEFINED;
            return;
        }

        pVal = &pFil->FilterTypes.Item.FilTypes.pSubstring->InitialVal;
    }
    else if (pFil->FilterTypes.Item.choice == FI_CHOICE_NOT_EQUAL) {
        // _NOT_EQUAL on ANR doesn't make any sense
        pOutFil->choice = FILTER_CHOICE_ITEM;
        pOutFil->FilterTypes.Item.choice = FI_CHOICE_UNDEFINED;
        return;
    }
    else {
        pVal = &pFil->FilterTypes.Item.FilTypes.ava.Value;
    }

    // Note from the above that we ignore non-initial provided substrings.
    // Now, massage the value.  First, we trim initial whitespace.
    // ISSUE-2002/03/07-andygo:  ANR searches use custom parsing
    // REVIEW:  this code scans for whitespace explicitly with L' ' and L'\t' instead of iswspace.
    // REVIEW:  however, ANR searches are pretty special anyway
    pStringTemp = (wchar_t *)pVal->pVal;
    while(pVal->valLen && (*pStringTemp == L' ' || *pStringTemp == L'\t')) {
        pVal->valLen -= sizeof(wchar_t);
        pStringTemp++;
    }

    // Look for an '=' here, implying exact match, not initial substring
    // (initial substring is the default).
    if(pVal->valLen && *pStringTemp == L'=') {
        // Found one.
        fExact = TRUE;
        pStringTemp++;
        pVal->valLen -= sizeof(wchar_t);
        // And, skip any more leading whitespace
        while(pVal->valLen && (*pStringTemp == L' ' || *pStringTemp == L'\t')) {
            pVal->valLen -= sizeof(wchar_t);
            pStringTemp++;
        }
    }

    // Now, remove trailing whitespace.
    pVal->pVal = (PUCHAR)pStringTemp;

    if (pVal->valLen >= sizeof(wchar_t)) {
        pStringTemp = &pStringTemp[(pVal->valLen/sizeof(wchar_t)) - 1];
        while(pVal->valLen && (*pStringTemp == L' ' || *pStringTemp == L'\t')) {
            pVal->valLen -= sizeof(wchar_t);
            pStringTemp--;
        }
    }

    if(!pVal->valLen) {
        // ANRing on nothing.  Set filter to match nothing and return.
        pOutFil->choice = FILTER_CHOICE_ITEM;
        pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
        return;
    }


    if(!gfSupressFirstLastANR ||
       !gfSupressLastFirstANR    ) {
        // Not supressing both forms of first/last ANR

        // The final massage is to look for a medial whitespace and split the
        // string at that whitespace, copying the two fragments to scratch
        // space.  Then, make a ((firstname AND lastname) OR (lastname AND
        // firstname)) filter using the two fragments.
        pFirst = THAllocEx(pTHS, pVal->valLen);
        pStringTemp = (wchar_t *)pVal->pVal;
        i=0;
        while(i < pVal->valLen/sizeof(wchar_t) &&
              (*pStringTemp != L' ' && *pStringTemp != L'\t')) {
            pFirst[i] = *pStringTemp;
            i++;
            pStringTemp++;
        }
        if(i < pVal->valLen/sizeof(wchar_t)) {
            cbFirst = i * sizeof(wchar_t);

            // There was some medial whitespace
            while(*pStringTemp == L' ' || *pStringTemp == L'\t') {
                pStringTemp++;
                i++;
            }
            cbLast = (pVal->valLen - (i * sizeof(wchar_t)));
            pLast = THAllocEx(pTHS, cbLast);
            memcpy(pLast, pStringTemp, cbLast);
        }
        // At this point, cbLast != 0 implies we were able to split the string.
    }
    else {
        // No splitting necessary.
        cbLast = 0;
    }

    // Now, find the attributes we do ANR over.
    count = (USHORT)SCGetANRids(&pIDs);
    if(!count && !cbLast) {
        // Nothing to ANR on, no first/last filter necessary.  Set filter to
        // match nothing and return.
        pOutFil->choice = FILTER_CHOICE_ITEM;
        pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
        THFreeEx(pTHS, pFirst);
        THFreeEx(pTHS, pLast);
        return;
    }

    pOutFil->FilterTypes.Or.count = count;
    if(cbLast) {
        // And, we're doing a first/last last/first filter
        pOutFil->FilterTypes.Or.count+= 2;

        if(gfSupressFirstLastANR) {
            // Actually, we're not doing the first/last anr
            pOutFil->FilterTypes.Or.count-=1;
        }
        if(gfSupressLastFirstANR) {
            // Actually, we're not doing the last/first anr
            pOutFil->FilterTypes.Or.count-=1;
        }

    }

    // calculate the expected Index Size that the indexes used in ANR will have
    if ((pVal->valLen / 2) > 3) {
        expectedIndexSize = 1;
    }
    else {
        expectedIndexSize = 1;
        for (i = 4 - (pVal->valLen / 2 ); i; i--) {
            expectedIndexSize = expectedIndexSize * 10;
        }
    }

    pTemp = THAllocEx(pTHS, pOutFil->FilterTypes.Or.count * sizeof(FILTER));
    pOutFil->FilterTypes.Or.pFirstFilter = pTemp;


    itemCount=0;
    for(i=0;i<count;i++) {
        pTemp->choice = FILTER_CHOICE_ITEM;

        // this check is to ensure that on ATT_LEGACY_EXCHANGE_DN we do exact match.

        // NTRAID#NTRAID-569714-2002/03/07-andygo:  ANR filter construction has no error checking
        // REVIEW:  there is no error check on dbMakeANRItem
        if(!dbMakeANRItem(pDB,
                          &pTemp->FilterTypes.Item,
                          (pIDs[i] == ATT_LEGACY_EXCHANGE_DN) ? TRUE : fExact,
                          pIDs[i],
                          pVal)) {
            // Succeeded in making an anr item.
            pTemp->FilterTypes.Item.expectedSize = expectedIndexSize;

            pTemp->pNextFilter = &pTemp[1];
            pTemp++;
            itemCount++;
        }
    }

    if(cbLast) {
        // We have a first/last or last/first ANR to do
        Assert(!gfSupressFirstLastANR || !gfSupressLastFirstANR);

        if(!gfSupressFirstLastANR) {
            // First, make the (firstname AND lastname) filter.
            pTemp->choice = FILTER_CHOICE_AND;
            pTemp->FilterTypes.And.count = 2;

            pTemp2 = THAllocEx(pTHS, 2 * sizeof(FILTER));
            pTemp->FilterTypes.And.pFirstFilter = pTemp2;
            // Make the "firstname" portion.
            pTemp2->choice = FILTER_CHOICE_ITEM;

            pVal->valLen = cbFirst;
            pVal->pVal = (PUCHAR)pFirst;

            // NTRAID#NTRAID-569714-2002/03/07-andygo:  ANR filter construction has no error checking
            // REVIEW:  there is no error check on dbMakeANRItem
            if(!dbMakeANRItem(pDB,
                              &pTemp2->FilterTypes.Item,
                              fExact,
                              ATT_GIVEN_NAME,
                              pVal)) {

                // Set estimated hint to zero so as to calculate
                pTemp2->FilterTypes.Item.expectedSize = 0;

                // Succeeded in translating given name, continue.
                pTemp2->pNextFilter = &pTemp2[1];
                pTemp2++;


                // Now, make the "lastname" portion.
                pTemp2->choice = FILTER_CHOICE_ITEM;

                pVal->valLen = cbLast;
                pVal->pVal = (PUCHAR)pLast;
                if(!dbMakeANRItem(pDB,
                                  &pTemp2->FilterTypes.Item,
                                  fExact,
                                  ATT_SURNAME,
                                  pVal)) {
                    // Set estimated hint to zero so as to calculate
                    pTemp2->FilterTypes.Item.expectedSize = 0;
                    pTemp2->pNextFilter = NULL;

                    pTemp->pNextFilter = &pTemp[1];
                    // We made a (firstname AND lastname) filter.  Now, make the
                    // (lastname AND firstname) filter, if we need to.
                    itemCount++;
                    pTemp++;
                }
            }
        }

        if(!gfSupressLastFirstANR) {
            // Now, the (lastname AND firstname) filter.
            pTemp->choice = FILTER_CHOICE_AND;
            pTemp->FilterTypes.And.count = 2;
            pTemp2 = THAllocEx(pTHS, 2 * sizeof(FILTER));
            pTemp->FilterTypes.And.pFirstFilter = pTemp2;
            // Make the "lastname" portion.
            pTemp2->choice = FILTER_CHOICE_ITEM;

            pVal->valLen = cbLast;
            pVal->pVal = (PUCHAR)pLast;
            // NTRAID#NTRAID-569714-2002/03/07-andygo:  ANR filter construction has no error checking
            // REVIEW:  there is no error check on dbMakeANRItem
            if(!dbMakeANRItem(pDB,
                              &pTemp2->FilterTypes.Item,
                              fExact,
                              ATT_GIVEN_NAME,
                              pVal)) {

                // Set estimated hint to zero so as to calculate
                pTemp2->FilterTypes.Item.expectedSize = 0;

                // Succeeded in translating surname, continue.
                pTemp2->pNextFilter = &pTemp2[1];
                pTemp2++;
                // Finally, make the "lastname" portion.
                pTemp2->choice = FILTER_CHOICE_ITEM;

                pVal->valLen = cbFirst;
                pVal->pVal = (PUCHAR)pFirst;
                if(!dbMakeANRItem(pDB,
                                  &pTemp2->FilterTypes.Item,
                                  fExact,
                                  ATT_SURNAME,
                                  pVal)) {
                    // Set estimated hint to zero so as to calculate
                    pTemp2->FilterTypes.Item.expectedSize = 0;

                    pTemp2->pNextFilter = NULL;
                    // Succeeded in making the (lastname AND firstname) filter.
                    itemCount++;
                }
            }
        }
    }

    if(!itemCount) {
        // We ended up with nothing to ANR on.  Set filter to match nothing and
        // return.
        pOutFil->choice = FILTER_CHOICE_ITEM;
        pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
        THFreeEx(pTHS, pOutFil->FilterTypes.Or.pFirstFilter);
    }
    else {
        pOutFil->FilterTypes.Or.count = itemCount;
        pOutFil->FilterTypes.Or.pFirstFilter[itemCount - 1].pNextFilter = NULL;
    }
    return;
}

DWORD dbConcatenateFilters (
    DBPOS *pDB,
    FILTER *pFirstFilter,
    FILTER *pSecondFilter,
    FILTER **pOutFil)
/*
    This function takes two filters (pFirstFilter, pSecondFilter)
    and creates a new filter (pOutFil) by concatenating these two filters.
    The original memory of the input filters remains unchanged and the
    whole filter is copied in new memory.
*/
{

    DWORD err;
    FILTER *pFil1 = NULL,
           *pFil2 = NULL,
           *pTemp;

    DPRINT (2, "dbConcatenateFilters \n");

    if (err = dbCloneFilter (pDB, pFirstFilter, &pFil1)) {
        return err;
    }

    if (err = dbCloneFilter (pDB, pSecondFilter, &pFil2)) {
        dbFreeFilter(pDB, pFil1);
        return err;
    }

    pTemp = pFil1;
    while (pTemp) {
        if (pTemp->pNextFilter == NULL) {
            pTemp->pNextFilter = pFil2;
            break;
        }
        pTemp = pTemp->pNextFilter;
    }

    if (pFil1) {
        *pOutFil = pFil1;
    }
    else {
        *pOutFil = pFil2;
    }

    return ERROR_SUCCESS;
}


BOOL dbCheckOptimizableAllItems(
        DBPOS *pDB,
        FILTER *pFil
        )
/*
    returns TRUE is ALL filters under pFil are ITEM_FILTERS
    and they are optimizable.
*/
{
    FILTER *pTemp = pFil;


    while (pTemp) {
        if (pTemp->choice != FILTER_CHOICE_ITEM) {
            return FALSE;
        }

        if (!IsFilterOptimizable(pDB->pTHS, pTemp)) {
            return FALSE;
        }

        pTemp = pTemp->pNextFilter;
    }

    return TRUE;
}


BOOL dbCheckOptimizableOneItem(
    DBPOS *pDB,
    FILTER *pFil
    )
/*
    returns TRUE is at least ONE of filters under pFil is ITEM_FILTERS
    and they is optimizable.
*/
{
    FILTER *pTemp = pFil;

    while (pTemp) {
        if (pTemp->choice == FILTER_CHOICE_ITEM) {
            if (IsFilterOptimizable(pDB->pTHS, pTemp)) {
                return TRUE;
            }
        }

        pTemp = pTemp->pNextFilter;
    }

    return FALSE;
}


DWORD
dbFlattenOrFilter (
        DBPOS *pDB,
        FILTER *pFil,
        size_t iLevel,
        FILTER **ppOutFil,
        ATTRTYP *pErrAttrTyp
        )
{
    THSTATE  *pTHS=pDB->pTHS;
    USHORT   count=0, undefined=0;
    PFILTER  pOutFil;
    PFILTER  pTemp;
    PFILTER  *ppTemp2;
    DWORD    err;

    Assert(VALID_DBPOS(pDB));

    // Presume failure.
    *ppOutFil = NULL;

    pOutFil = THAllocEx(pTHS, sizeof(FILTER));

    pOutFil->choice = pFil->choice;

    // First, recursively flatten the elements of the OR

    // pTemp walks along the elements of the filter passed in.
    pTemp = pFil->FilterTypes.Or.pFirstFilter;

    // ppTemp2 walks along the OutFil we are creating.  It is doubly indirect
    // because we are creating the out filter as we go.
    ppTemp2 = &pOutFil->FilterTypes.Or.pFirstFilter;

    while(pTemp) {
        if ((err = dbFlattenFilter(pDB, pTemp, iLevel + 1, ppTemp2, pErrAttrTyp)) != ERROR_SUCCESS) {
            dbFreeFilter(pDB, pOutFil);
            return err;
        }

        if((*ppTemp2)->choice == FILTER_CHOICE_OR) {
            // This element of the OR is itself an OR.  We can merge this with
            // the current OR filter.
            FILTER *pTemp2; // Very local use, so declare var in here.

            pTemp2 = (*ppTemp2)->FilterTypes.Or.pFirstFilter;

            // Free this node of the top level OR.
            THFreeEx(pTHS, *ppTemp2);

            // Link in the lower level OR.
            *ppTemp2 = pTemp2;

            // Now, walk through the lower level OR to get ppTemp2 pointing to
            // the correct spot and to set the count correctly.
            count++;
            while(pTemp2->pNextFilter) {
                count++;
                pTemp2 = pTemp2->pNextFilter;
            }
            ppTemp2 = &pTemp2->pNextFilter;
        }
        else {
            switch (IsConstFilterType(*ppTemp2)) {
            // Check for a true or false filter, which can be optimized
            case FI_CHOICE_FALSE:
                // A false element can simply be ignored.  Free the filter we got
                // back from the recursive call.  Note we don't increment the count.
                THFreeEx(pTHS, *ppTemp2);
                *ppTemp2 = NULL;
                break;

            case FI_CHOICE_TRUE:
                // A true element can be returned in place of the OR

                // First, free the linked list of filter elements already hanging
                // off the OR filter (if there is such a list).
                dbFreeFilter(pDB, pOutFil->FilterTypes.Or.pFirstFilter);

                // Now, turn the OR filter into a TRUE item filter.
                pOutFil->choice = FILTER_CHOICE_ITEM;
                pOutFil->FilterTypes.Item.choice = FI_CHOICE_TRUE;

                *ppOutFil = pOutFil;
                // OK, return
                return ERROR_SUCCESS;
                break;

            case FI_CHOICE_UNDEFINED:
                // an undefined element, cannot be ignored, but we are interested
                // in knowing how many undefines we have so as to take appropriate action
                undefined++;
                // fall through
            default:
                // Normal case.  Inc the count, advance the pointer in the output
                // filter we are constructing.
                ppTemp2 = &(*ppTemp2)->pNextFilter;
                count++;
                break;
            }
        }
        pTemp = pTemp->pNextFilter;
    }

    if(count == 0) {
        // We must have trimmed away a bunch of FALSEs. Return a FALSE.
        pOutFil->choice = FILTER_CHOICE_ITEM;
        pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
        *ppOutFil = pOutFil;
        return ERROR_SUCCESS;
    }

    if(count == 1) {
        // Only one object.  Cut the OR out completely
        *ppOutFil = pOutFil->FilterTypes.Or.pFirstFilter;
        THFreeEx(pTHS, pOutFil);
        return ERROR_SUCCESS;
    }

    if (undefined == count) {
        // all the filter is undefined. remove the OR
        pOutFil->choice = FILTER_CHOICE_ITEM;
        pOutFil->FilterTypes.Item.choice = FI_CHOICE_UNDEFINED;
        *ppOutFil = pOutFil;
        return ERROR_SUCCESS;
    }

    // Returning a normal OR filter
    pOutFil->FilterTypes.Or.count = count;
    *ppOutFil = pOutFil;

    return ERROR_SUCCESS;
}

DWORD
dbFlattenAndFilter (
        DBPOS *pDB,
        FILTER *pFil,
        size_t iLevel,
        FILTER **ppOutFil,
        ATTRTYP *pErrAttrTyp
        )
{
    THSTATE  *pTHS=pDB->pTHS;
    USHORT   count=0, undefined=0;
    PFILTER  pOutFil;
    PFILTER  pTemp;
    PFILTER  *ppTemp2;
    DWORD    err;

    Assert(VALID_DBPOS(pDB));

    // Presume failure.
    *ppOutFil = NULL;

    pOutFil = THAllocEx(pTHS, sizeof(FILTER));

    pOutFil->choice = pFil->choice;

    // First, recursively flatten the elements of the AND

    // pTemp walks along the elements of the filter passed in.
    pTemp = pFil->FilterTypes.And.pFirstFilter;

    // ppTemp2 walks along the OutFil we are creating.  It is doubly indirect
    // because we are creating the out filter as we go.
    ppTemp2 = &pOutFil->FilterTypes.And.pFirstFilter;

    while(pTemp) {

        if ((err = dbFlattenFilter(pDB, pTemp, iLevel + 1, ppTemp2, pErrAttrTyp)) != ERROR_SUCCESS) {
            dbFreeFilter(pDB, pOutFil);
            return err;
        }

        if((*ppTemp2)->choice == FILTER_CHOICE_AND) {
            // This element of the AND is itself an AND.  We can merge this with
            // the current AND filter.
            FILTER *pTemp2; // Very local use, so declare var in here.

            pTemp2 = (*ppTemp2)->FilterTypes.And.pFirstFilter;

            // Free this node of the top level AND.
            THFreeEx(pTHS, *ppTemp2);

            // Link in the lower level AND.
            *ppTemp2 = pTemp2;

            // Now, walk through the lower level AND to get ppTemp2 pointing to
            // the correct spot and to set the count correctly.
            count++;
            while(pTemp2->p