);

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));

	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperties | OnFormatChanged | This
 *    method is used to retrieve the format selected by the user.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperties::OnFormatChanged()
{
	HRESULT	Hr = E_UNEXPECTED;
	DWORD dw;

	FX_ENTRY("CCaptureProperties::OnFormatChanged")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	if (!m_pITFormatControl)
	{
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Associate the current compression index with the right range index
	m_CurrentFormat = ComboBox_GetCurSel(m_hWndFormat);
	if (m_CurrentFormat < m_dwRangeCount)
	{
//		Hr = m_pITFormatControl->SetPreferredFormat(m_FormatList[m_CurrentFormat]);
	}

MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperties | InitialRangeScan | This
 *    method is used to retrieve the list of supported formats on the stream.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperties::InitialRangeScan()
{
	HRESULT			Hr = NOERROR;
	DWORD           dw;
	AM_MEDIA_TYPE	*pmt = NULL;

	FX_ENTRY("CCaptureProperties::InitialRangeScan")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	if (!m_pITFormatControl)
	{
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	Hr = m_pITFormatControl->GetNumberOfCapabilities(&m_dwRangeCount);
	if (!SUCCEEDED(Hr))
	{
		Hr = E_FAIL;
		goto MyExit;
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   NumberOfRanges=%d"), _fx_, m_dwRangeCount));

	if (!(m_CapsList = new TAPI_STREAM_CONFIG_CAPS [m_dwRangeCount]))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s: ERROR: new failed"), _fx_));
		Hr = E_OUTOFMEMORY;
		goto MyExit;
	}

	if (!(m_FormatList = new AM_MEDIA_TYPE* [m_dwRangeCount]))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s: ERROR: new failed"), _fx_));
		Hr = E_OUTOFMEMORY;
		goto MyError;
	}
	ZeroMemory(m_FormatList, m_dwRangeCount * sizeof(AM_MEDIA_TYPE*));

	for (dw = 0; dw < m_dwRangeCount; dw++)
	{
		BOOL fEnabled; // Is this format currently enabled (according to the H.245 capability resolver)

		Hr = m_pITFormatControl->GetStreamCaps(dw, &m_FormatList[dw], &m_CapsList[dw], &fEnabled);
	}

	// Get default format
	Hr = GetCurrentMediaType();

	goto MyExit;

MyError:
	if (m_CapsList)
		delete[] m_CapsList, m_CapsList = NULL;
MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;
	int		j;
	CMediaType *pmt = NULL;
	BOOL fEnabled; // Is this format currently enabled (according to the H.245 capability resolver)

	FX_ENTRY("CCaptureProperties::OnApplyChanges")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Apply format changes on video stream
	m_CurrentFormat = ComboBox_GetCurSel(m_hWndFormat);
	
	// Only apply change if the format is different
	if (m_CurrentFormat != m_OriginalFormat)
	{
//		if (FAILED(Hr = m_pITFormatControl->SetPreferredFormat(m_FormatList[m_CurrentFormat])))
		{
			// Why did you mess with the format that was returned to you?
		}

		// Update our copy of the current format
		GetCurrentMediaType();
	}

	// Apply target bitrate and target frame rate changes on video stream
	for (j = 0; j < IDC_Capture_CurrentBitrate; j++)
	{
		if (m_Controls[j])
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: calling m_Controls[%ld]=0x%08lX->OnApply"), _fx_, j, m_Controls[j]));
			if (m_Controls[j]->HasChanged())
				m_Controls[j]->OnApply();
			Hr = NOERROR;
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: can't calling m_Controls[%ld]=NULL->OnApply"), _fx_, j));
			Hr = E_UNEXPECTED;
		}
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc BOOL | CCaptureProperties | BaseDlgProc | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
INT_PTR CALLBACK CCaptureProperties::BaseDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
    CCaptureProperties *pSV = (CCaptureProperties*)GetWindowLong(hDlg, DWL_USER);

	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
        case WM_INITDIALOG:
			{
				LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)lParam;
				pSV = (CCaptureProperties*)psp->lParam;
				pSV->m_hDlg = hDlg;
				SetWindowLong(hDlg, DWL_USER, (LPARAM)pSV);
				pSV->m_bInit = FALSE;
				//pSV->OnActivate();
				//pSV->m_bInit = TRUE;
				return TRUE;
			}
			break;

		case WM_TIMER:
			if (pSV && pSV->m_bInit)
			{
				// Update the Vu-Meters
				for (j = 0; j < pSV->m_NumProperties; j++)
				{
					if (pSV->m_Controls[j]->GetProgressHWnd())
					{
						pSV->m_Controls[j]->UpdateProgress();
						pSV->SetDirty();
					}
				}
			}
			break;

		case WM_HSCROLL:
		case WM_VSCROLL:
            if (pSV && pSV->m_bInit)
            {
				// Process all of the Trackbar messages
				for (j = 0; j < pSV->m_NumProperties; j++)
				{
					if (pSV->m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
					{
						pSV->m_Controls[j]->OnScroll(uMsg, wParam, lParam);
						pSV->SetDirty();
					}
				}
				// pSV->OnApplyChanges();
			}
			break;

		case WM_COMMAND:
            if (pSV && pSV->m_bInit)
            {
				// Process all of the auto checkbox messages
				for (j = 0; j < pSV->m_NumProperties; j++)
				{
					if (pSV->m_Controls[j] && pSV->m_Controls[j]->GetAutoHWnd() == (HWND)lParam)
					{
						pSV->m_Controls[j]->OnAuto(uMsg, wParam, lParam);
						pSV->SetDirty();
						break;
					}
				}

				// Process all of the edit box messages
				for (j = 0; j < pSV->m_NumProperties; j++)
				{
					if (pSV->m_Controls[j] && pSV->m_Controls[j]->GetEditHWnd() == (HWND)lParam)
					{
						pSV->m_Controls[j]->OnEdit(uMsg, wParam, lParam);
						pSV->SetDirty();
						break;
					}
				}

				switch (LOWORD(wParam))
				{
					case IDC_CONTROL_DEFAULT:
						for (j = 0; j < pSV->m_NumProperties; j++)
						{
							if (pSV->m_Controls[j])
								pSV->m_Controls[j]->OnDefault();
						}
						break;

					case IDC_FORMAT_Compression:
						if (HIWORD(wParam) == CBN_SELCHANGE)
						{
							pSV->OnFormatChanged();
						}
						break;

					default:
						break;
				}

				//pSV->OnApplyChanges();
			}
			break;

        case WM_NOTIFY:
			if (pSV)
			{
				switch (((NMHDR FAR *)lParam)->code)
				{
					case PSN_SETACTIVE:
						{
							// We call out here specially so we can mark this page as having been init'd.
							int iRet = pSV->OnActivate();
							pSV->m_bInit = TRUE;
							return iRet;
						}
						break;

					case PSN_APPLY:
						pSV->OnApplyChanges();
						break;

					case PSN_QUERYCANCEL:    
						// return pSV->QueryCancel();
						break;

					default:
						break;
				}
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc BOOL | CCaptureProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void CCaptureProperties::SetDirty()
{
	PropSheet_Changed(GetParent(m_hDlg), m_hDlg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\test\t3out\networkp.cpp ===
/****************************************************************************
 *  @doc INTERNAL NETWORKP
 *
 *  @module NetworkP.cpp | Source file for the <c CNetworkProperty>
 *    class used to implement a property page to test the TAPI control
 *    interface <i ITQualityControl>.
 ***************************************************************************/

#include "Precomp.h"

extern HINSTANCE ghInst;

/****************************************************************************
 *  @doc INTERNAL CNETWORKPMETHOD
 *
 *  @mfunc void | CNetworkProperty | CNetworkProperty | This
 *    method is the constructor for bitrate and frame rate property objects. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    pointers to the <i ITQualityControl> interfaces.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm ITQualityControl* | pITQualityControl | Specifies a pointer to the
 *    <i ITQualityControl> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CNetworkProperty::CNetworkProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ITStreamQualityControl *pITQualityControl)
: CPropertyEditor(hDlg, IDLabel, IDMinControl, IDMaxControl, IDDefaultControl, IDStepControl, IDEditControl, IDTrackbarControl, IDProgressControl, IDProperty, 0)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("CNetworkProperty::CNetworkProperty")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointers are NULL, we'll grey the
	// associated items in the property page
	m_pITQualityControl = pITQualityControl;

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CNETWORKPMETHOD
 *
 *  @mfunc void | CNetworkProperty | ~CNetworkProperty | This
 *    method is the destructor for capture property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CNetworkProperty::~CNetworkProperty()
{
	FX_ENTRY("CNetworkProperty::~CNetworkProperty")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CNETWORKPMETHOD
 *
 *  @mfunc HRESULT | CNetworkProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CNetworkProperty::GetValue()
{
	HRESULT Hr = E_NOTIMPL;
	LONG CurrentValue;
	TAPIControlFlags CurrentFlag;
	LONG Mode;

	FX_ENTRY("CNetworkProperty::GetValue")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	switch (m_IDProperty)
	{									
		case IDC_Video_PlayoutDelay:
		case IDC_Audio_PlayoutDelay:
/*
			if (m_pITQualityControl && SUCCEEDED (Hr = m_pITQualityControl->Get(StreamQuality_MaxPlayoutDelay, &m_CurrentValue, &CurrentFlag)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwMaxPlayoutDelay=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
*/
			break;
		case IDC_VideoOut_RTT:
		case IDC_VideoIn_RTT:
		case IDC_AudioOut_RTT:
		case IDC_AudioIn_RTT:
/*
			if (m_pITQualityControl && SUCCEEDED (Hr = m_pITQualityControl->Get(Quality_RoundTripTime, &m_CurrentValue, &CurrentFlag)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwMaxRTT=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
*/
			break;
		case IDC_VideoOut_LossRate:
		case IDC_VideoIn_LossRate:
		case IDC_AudioOut_LossRate:
		case IDC_AudioIn_LossRate:
/*
			if (m_pITQualityControl && SUCCEEDED (Hr = m_pITQualityControl->Get(Quality_LossRate, &m_CurrentValue, &CurrentFlag)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwMaxLossRate=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
*/
			break;
		default:
			Hr = E_UNEXPECTED;
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Unknown property"), _fx_));
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CNETWORKPMETHOD
 *
 *  @mfunc HRESULT | CNetworkProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CNetworkProperty::SetValue()
{
	HRESULT Hr = E_NOTIMPL;
	LONG CurrentValue;

	FX_ENTRY("CNetworkProperty::SetValue")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));
/*
	switch (m_IDProperty)
    {
		case IDC_Video_PlayoutDelay:
		case IDC_Audio_PlayoutDelay:
			if (m_pITQualityControl && SUCCEEDED (Hr = m_pITQualityControl->Set(Quality_MaxPlayoutDelay, m_CurrentValue, TAPIControl_Flags_None)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: dwMaxPlayoutDelay=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_VideoOut_RTT:
		case IDC_VideoIn_RTT:
		case IDC_AudioOut_RTT:
		case IDC_AudioIn_RTT:
		case IDC_VideoOut_LossRate:
		case IDC_VideoIn_LossRate:
		case IDC_AudioOut_LossRate:
		case IDC_AudioIn_LossRate:
			// This is a read-only property. Don't do anything.
			Hr = NOERROR;
			break;
		default:
			Hr = E_UNEXPECTED;
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Unknown property"), _fx_));
	}
*/
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CNETWORKPMETHOD
 *
 *  @mfunc HRESULT | CNetworkProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CNetworkProperty::GetRange()
{
	HRESULT Hr = E_NOTIMPL;
	LONG Min;
	LONG Max;
	LONG SteppingDelta;
	LONG Default;
	LONG CapsFlags;

	FX_ENTRY("CNetworkProperty::GetRange")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));
/*
	switch (m_IDProperty)
	{
		case IDC_Video_PlayoutDelay:
		case IDC_Audio_PlayoutDelay:
			if (m_pITQualityControl && SUCCEEDED (Hr = m_pITQualityControl->GetRange(Quality_MaxPlayoutDelay, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, &m_CapsFlags)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_VideoOut_RTT:
		case IDC_VideoIn_RTT:
		case IDC_AudioOut_RTT:
		case IDC_AudioIn_RTT:
			if (m_pITQualityControl && SUCCEEDED (Hr = m_pITQualityControl->GetRange(Quality_RoundTripTime, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, &m_CapsFlags)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_VideoOut_LossRate:
		case IDC_VideoIn_LossRate:
		case IDC_AudioOut_LossRate:
		case IDC_AudioIn_LossRate:
			if (m_pITQualityControl && SUCCEEDED (Hr = m_pITQualityControl->GetRange(Quality_LossRate, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, &m_CapsFlags)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		default:
			Hr = E_UNEXPECTED;
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Unknown property"), _fx_));
	}
*/
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CNETWORKPMETHOD
 *
 *  @mfunc HPROPSHEETPAGE | CNetworkProperties | OnCreate | This
 *    method creates a new page for a property sheet.
 *
 *  @rdesc Returns the handle to the new property sheet if successful, or
 *    NULL otherwise.
 ***************************************************************************/
HPROPSHEETPAGE CNetworkProperties::OnCreate()
{
    PROPSHEETPAGE psp;
    
	psp.dwSize        = sizeof(psp);
    psp.dwFlags       = PSP_USEREFPARENT;
    psp.hInstance     = ghInst;
    psp.pszTemplate   = MAKEINTRESOURCE(IDD_NetworkProperties);
    psp.pfnDlgProc    = BaseDlgProc;
    psp.pcRefParent   = 0;
    psp.pfnCallback   = (LPFNPSPCALLBACK)NULL;
    psp.lParam        = (LPARAM)this;

    return CreatePropertySheetPage(&psp);
}

/****************************************************************************
 *  @doc INTERNAL CNETWORKPMETHOD
 *
 *  @mfunc void | CNetworkProperties | CNetworkProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CNetworkProperties::CNetworkProperties()
{
	FX_ENTRY("CNetworkProperties::CNetworkProperties")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	m_pVideoInITQualityControl = NULL;
	m_pVideoOutITQualityControl = NULL;
	m_pAudioInITQualityControl = NULL;
	m_pAudioOutITQualityControl = NULL;
	m_NumProperties = NUM_NETWORK_CONTROLS;
	m_hDlg = NULL;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CNETWORKPMETHOD
 *
 *  @mfunc void | CNetworkProperties | ~CNetworkProperties | This
 *    method is the destructor for the capture pin property page. It
 *    simply calls the base class destructor after deleting all the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CNetworkProperties::~CNetworkProperties()
{
	int		j;

	FX_ENTRY("CNetworkProperties::~CNetworkProperties")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX"), _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: control already freed"), _fx_));
		}
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CNETWORKPMETHOD
 *
 *  @mfunc HRESULT | CNetworkProperties | OnConnect | This
 *    method is called when the property page is connected to a TAPI object.
 *
 *  @parm ITStream* | pStream | Specifies a pointer to the <i ITStream>
 *    interface. It is used to QI for the <i ITQualityControl> and
 *    <i ITFormatControl> interfaces.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CNetworkProperties::OnConnect(ITStream *pVideoInStream, ITStream *pVideoOutStream, ITStream *pAudioInStream, ITStream *pAudioOutStream)
{
	FX_ENTRY("CNetworkProperties::OnConnect")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Get the quality control interfaces
	if (pVideoInStream && SUCCEEDED (pVideoInStream->QueryInterface(__uuidof(ITStreamQualityControl), (void **)&m_pVideoInITQualityControl)))
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_pVideoInITQualityControl=0x%08lX"), _fx_, m_pVideoInITQualityControl));
	}
	else
	{
		m_pVideoInITQualityControl = NULL;
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
	}

	if (pVideoOutStream && SUCCEEDED (pVideoOutStream->QueryInterface(__uuidof(ITStreamQualityControl), (void **)&m_pVideoOutITQualityControl)))
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_pVideoOutITQualityControl=0x%08lX"), _fx_, m_pVideoOutITQualityControl));
	}
	else
	{
		m_pVideoOutITQualityControl = NULL;
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
	}

	if (pAudioInStream && SUCCEEDED (pAudioInStream->QueryInterface(__uuidof(ITStreamQualityControl), (void **)&m_pAudioInITQualityControl)))
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_pAudioInITQualityControl=0x%08lX"), _fx_, m_pAudioInITQualityControl));
	}
	else
	{
		m_pAudioInITQualityControl = NULL;
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
	}

	if (pAudioOutStream && SUCCEEDED (pAudioOutStream->QueryInterface(__uuidof(ITStreamQualityControl), (void **)&m_pAudioOutITQualityControl)))
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_pAudioOutITQualityControl=0x%08lX"), _fx_, m_pAudioOutITQualityControl));
	}
	else
	{
		m_pAudioOutITQualityControl = NULL;
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers
	// We'll just grey the controls in the property page
	// to make it clear to the user that they can't
	// control those properties on the capture device

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CNETWORKPMETHOD
 *
 *  @mfunc HRESULT | CNetworkProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CNetworkProperties::OnDisconnect()
{
	FX_ENTRY("CNetworkProperties::OnDisconnect")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	if (!m_pVideoInITQualityControl)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pVideoInITQualityControl->Release();
		m_pVideoInITQualityControl = NULL;
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: releasing m_pVideoInITQualityControl"), _fx_));
	}

	// Validate input parameters
	if (!m_pVideoOutITQualityControl)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pVideoOutITQualityControl->Release();
		m_pVideoOutITQualityControl = NULL;
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: releasing m_pVideoOutITQualityControl"), _fx_));
	}

	// Validate input parameters
	if (!m_pAudioInITQualityControl)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pAudioInITQualityControl->Release();
		m_pAudioInITQualityControl = NULL;
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: releasing m_pAudioInITQualityControl"), _fx_));
	}

	// Validate input parameters
	if (!m_pAudioOutITQualityControl)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pAudioOutITQualityControl->Release();
		m_pAudioOutITQualityControl = NULL;
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: releasing m_pAudioOutITQualityControl"), _fx_));
	}
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CNETWORKPMETHOD
 *
 *  @mfunc HRESULT | CNetworkProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CNetworkProperties::OnActivate()
{
	HRESULT	Hr = E_OUTOFMEMORY;
	int		j;

	FX_ENTRY("CNetworkProperties::OnActivate")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Create the controls for the properties
	if (!(m_Controls[IDC_VideoOut_RTT] = new CNetworkProperty(m_hDlg, IDC_VideoOut_RTT_Label, IDC_VideoOut_RTT_Minimum, IDC_VideoOut_RTT_Maximum, IDC_VideoOut_RTT_Default, IDC_VideoOut_RTT_Stepping, IDC_VideoOut_RTT_Actual, IDC_VideoOut_RTT_Slider, IDC_VideoOut_RTT_Meter, IDC_VideoOut_RTT, m_pVideoOutITQualityControl)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[IDC_VideoOut_RTT] failed - Out of memory"), _fx_));
		goto MyExit;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[IDC_VideoOut_RTT]=0x%08lX"), _fx_, m_Controls[IDC_VideoOut_RTT]));
	}

	if (!(m_Controls[IDC_VideoOut_LossRate] = new CNetworkProperty(m_hDlg, IDC_VideoOut_LossRate_Label, IDC_VideoOut_LossRate_Minimum, IDC_VideoOut_LossRate_Maximum, IDC_VideoOut_LossRate_Default, IDC_VideoOut_LossRate_Stepping, IDC_VideoOut_LossRate_Actual, IDC_VideoOut_LossRate_Slider, IDC_VideoOut_LossRate_Meter, IDC_VideoOut_LossRate, m_pVideoOutITQualityControl)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[IDC_VideoOut_LossRate] failed - Out of memory"), _fx_));
		goto MyError0;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[IDC_VideoOut_LossRate]=0x%08lX"), _fx_, m_Controls[IDC_VideoOut_LossRate]));
	}

	if (!(m_Controls[IDC_VideoIn_RTT] = new CNetworkProperty(m_hDlg, IDC_VideoIn_RTT_Label, IDC_VideoIn_RTT_Minimum, IDC_VideoIn_RTT_Maximum, IDC_VideoIn_RTT_Default, IDC_VideoIn_RTT_Stepping, IDC_VideoIn_RTT_Actual, IDC_VideoIn_RTT_Slider, IDC_VideoIn_RTT_Meter, IDC_VideoIn_RTT, m_pVideoOutITQualityControl)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[IDC_VideoIn_RTT] failed - Out of memory"), _fx_));
		goto MyError1;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[IDC_VideoIn_RTT]=0x%08lX"), _fx_, m_Controls[IDC_VideoIn_RTT]));
	}

	if (!(m_Controls[IDC_VideoIn_LossRate] = new CNetworkProperty(m_hDlg, IDC_VideoIn_LossRate_Label, IDC_VideoIn_LossRate_Minimum, IDC_VideoIn_LossRate_Maximum, IDC_VideoIn_LossRate_Default, IDC_VideoIn_LossRate_Stepping, IDC_VideoIn_LossRate_Actual, IDC_VideoIn_LossRate_Slider, IDC_VideoIn_LossRate_Meter, IDC_VideoIn_LossRate, m_pVideoInITQualityControl)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[IDC_VideoIn_LossRate] failed - Out of memory"), _fx_));
		goto MyError2;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[IDC_VideoIn_LossRate]=0x%08lX"), _fx_, m_Controls[IDC_VideoIn_LossRate]));
	}

	if (!(m_Controls[IDC_AudioOut_RTT] = new CNetworkProperty(m_hDlg, IDC_AudioOut_RTT_Label, IDC_AudioOut_RTT_Minimum, IDC_AudioOut_RTT_Maximum, IDC_AudioOut_RTT_Default, IDC_AudioOut_RTT_Stepping, IDC_AudioOut_RTT_Actual, IDC_AudioOut_RTT_Slider, IDC_AudioOut_RTT_Meter, IDC_AudioOut_RTT, m_pAudioOutITQualityControl)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[IDC_AudioOut_RTT] failed - Out of memory"), _fx_));
		goto MyError3;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[IDC_AudioOut_RTT]=0x%08lX"), _fx_, m_Controls[IDC_AudioOut_RTT]));
	}

	if (!(m_Controls[IDC_AudioOut_LossRate] = new CNetworkProperty(m_hDlg, IDC_AudioOut_LossRate_Label, IDC_AudioOut_LossRate_Minimum, IDC_AudioOut_LossRate_Maximum, IDC_AudioOut_LossRate_Default, IDC_AudioOut_LossRate_Stepping, IDC_AudioOut_LossRate_Actual, IDC_AudioOut_LossRate_Slider, IDC_AudioOut_LossRate_Meter, IDC_AudioOut_LossRate, m_pAudioOutITQualityControl)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[IDC_AudioOut_LossRate] failed - Out of memory"), _fx_));
		goto MyError4;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[IDC_AudioOut_LossRate]=0x%08lX"), _fx_, m_Controls[IDC_AudioOut_LossRate]));
	}

	if (!(m_Controls[IDC_AudioIn_RTT] = new CNetworkProperty(m_hDlg, IDC_AudioIn_RTT_Label, IDC_AudioIn_RTT_Minimum, IDC_AudioIn_RTT_Maximum, IDC_AudioIn_RTT_Default, IDC_AudioIn_RTT_Stepping, IDC_AudioIn_RTT_Actual, IDC_AudioIn_RTT_Slider, IDC_AudioIn_RTT_Meter, IDC_AudioIn_RTT, m_pAudioInITQualityControl)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[IDC_AudioIn_RTT] failed - Out of memory"), _fx_));
		goto MyError5;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[IDC_AudioIn_RTT]=0x%08lX"), _fx_, m_Controls[IDC_AudioIn_RTT]));
	}

	if (!(m_Controls[IDC_AudioIn_LossRate] = new CNetworkProperty(m_hDlg, IDC_AudioIn_LossRate_Label, IDC_AudioIn_LossRate_Minimum, IDC_AudioIn_LossRate_Maximum, IDC_AudioIn_LossRate_Default, IDC_AudioIn_LossRate_Stepping, IDC_AudioIn_LossRate_Actual, IDC_AudioIn_LossRate_Slider, IDC_AudioIn_LossRate_Meter, IDC_AudioIn_LossRate, m_pAudioInITQualityControl)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[IDC_AudioIn_LossRate] failed - Out of memory"), _fx_));
		goto MyError6;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[IDC_AudioIn_LossRate]=0x%08lX"), _fx_, m_Controls[IDC_AudioIn_LossRate]));
	}

	if (!(m_Controls[IDC_Video_PlayoutDelay] = new CNetworkProperty(m_hDlg, IDC_Video_PlayoutDelay_Label, IDC_Video_PlayoutDelay_Minimum, IDC_Video_PlayoutDelay_Maximum, IDC_Video_PlayoutDelay_Default, IDC_Video_PlayoutDelay_Stepping, IDC_Video_PlayoutDelay_Actual, IDC_Video_PlayoutDelay_Slider, IDC_Video_PlayoutDelay_Meter, IDC_Video_PlayoutDelay, m_pVideoInITQualityControl)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[IDC_VideoOut_PlayoutDelay] failed - Out of memory"), _fx_));
		goto MyError7;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[IDC_VideoOut_PlayoutDelay]=0x%08lX"), _fx_, m_Controls[IDC_Video_PlayoutDelay]));
	}

	if (!(m_Controls[IDC_Audio_PlayoutDelay] = new CNetworkProperty(m_hDlg, IDC_Audio_PlayoutDelay_Label, IDC_Audio_PlayoutDelay_Minimum, IDC_Audio_PlayoutDelay_Maximum, IDC_Audio_PlayoutDelay_Default, IDC_Audio_PlayoutDelay_Stepping, IDC_Audio_PlayoutDelay_Actual, IDC_Audio_PlayoutDelay_Slider, IDC_Audio_PlayoutDelay_Meter, IDC_Audio_PlayoutDelay, m_pAudioInITQualityControl)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[IDC_AudioOut_PlayoutDelay] failed - Out of memory"), _fx_));
		goto MyError8;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[IDC_AudioOut_PlayoutDelay]=0x%08lX"), _fx_, m_Controls[IDC_Audio_PlayoutDelay]));
	}

	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the device. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j]->Init())
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[%ld]->Init()"), _fx_, j));
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: m_Controls[%ld]->Init() failed"), _fx_, j));
		}
	}

	Hr = NOERROR;
	goto MyExit;

MyError8:
	if (m_Controls[IDC_Video_PlayoutDelay])
		delete m_Controls[IDC_Video_PlayoutDelay], m_Controls[IDC_Video_PlayoutDelay] = NULL;
MyError7:
	if (m_Controls[IDC_AudioIn_LossRate])
		delete m_Controls[IDC_AudioIn_LossRate], m_Controls[IDC_AudioIn_LossRate] = NULL;
MyError6:
	if (m_Controls[IDC_AudioIn_RTT])
		delete m_Controls[IDC_AudioIn_RTT], m_Controls[IDC_AudioIn_RTT] = NULL;
MyError5:
	if (m_Controls[IDC_AudioOut_LossRate])
		delete m_Controls[IDC_AudioOut_LossRate], m_Controls[IDC_AudioOut_LossRate] = NULL;
MyError4:
	if (m_Controls[IDC_AudioOut_RTT])
		delete m_Controls[IDC_AudioOut_RTT], m_Controls[IDC_AudioOut_RTT] = NULL;
MyError3:
	if (m_Controls[IDC_VideoIn_LossRate])
		delete m_Controls[IDC_VideoIn_LossRate], m_Controls[IDC_VideoIn_LossRate] = NULL;
MyError2:
	if (m_Controls[IDC_VideoIn_RTT])
		delete m_Controls[IDC_VideoIn_RTT], m_Controls[IDC_VideoIn_RTT] = NULL;
MyError1:
	if (m_Controls[IDC_VideoOut_LossRate])
		delete m_Controls[IDC_VideoOut_LossRate], m_Controls[IDC_VideoOut_LossRate] = NULL;
MyError0:
	if (m_Controls[IDC_VideoOut_RTT])
		delete m_Controls[IDC_VideoOut_RTT], m_Controls[IDC_VideoOut_RTT] = NULL;
MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CNETWORKPMETHOD
 *
 *  @mfunc HRESULT | CNetworkProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CNetworkProperties::OnDeactivate()
{
	int	j;

	FX_ENTRY("CNetworkProperties::OnDeactivate")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX"), _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: control already freed"), _fx_));
		}
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CNETWORKPMETHOD
 *
 *  @mfunc HRESULT | CNetworkProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CNetworkProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;

	FX_ENTRY("CNetworkProperties::OnApplyChanges")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	for (int j = IDC_Video_PlayoutDelay; j < IDC_Audio_PlayoutDelay; j++)
	{
		if (m_Controls[j])
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: calling m_Controls[%ld]=0x%08lX->OnApply"), _fx_, j, m_Controls[j]));
			if (m_Controls[j]->HasChanged())
				m_Controls[j]->OnApply();
			Hr = NOERROR;
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: can't calling m_Controls[%ld]=NULL->OnApply"), _fx_, j));
			Hr = E_UNEXPECTED;
		}
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CNETWORKPMETHOD
 *
 *  @mfunc BOOL | CNetworkProperties | BaseDlgProc | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
INT_PTR CALLBACK CNetworkProperties::BaseDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
    CNetworkProperties *pSV = (CNetworkProperties*)GetWindowLong(hDlg, DWL_USER);

	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
        case WM_INITDIALOG:
			{
				LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)lParam;
				pSV = (CNetworkProperties*)psp->lParam;
				pSV->m_hDlg = hDlg;
				SetWindowLong(hDlg, DWL_USER, (LPARAM)pSV);
				pSV->m_bInit = FALSE;
				//pSV->OnActivate();
				//pSV->m_bInit = TRUE;
				return TRUE;
			}
			break;

		case WM_TIMER:
			if (pSV && pSV->m_bInit)
			{
				// Update the Vu-Meters
				for (j = IDC_VideoOut_RTT; j < IDC_AudioIn_LossRate; j++)
				{
					if (pSV->m_Controls[j]->GetProgressHWnd())
					{
						pSV->m_Controls[j]->UpdateProgress();
						pSV->SetDirty();
					}
				}
			}
			break;

		case WM_HSCROLL:
		case WM_VSCROLL:
            if (pSV && pSV->m_bInit)
            {
				// Process all of the Trackbar messages
				for (j = IDC_Video_PlayoutDelay; j < IDC_Audio_PlayoutDelay; j++)
				{
					if (pSV->m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
					{
						pSV->m_Controls[j]->OnScroll(uMsg, wParam, lParam);
						pSV->SetDirty();
					}
				}
				//pSV->OnApplyChanges();
			}
			break;

		case WM_COMMAND:
            if (pSV && pSV->m_bInit)
            {
				// Process all of the auto checkbox messages
				for (j = 0; j < pSV->m_NumProperties; j++)
				{
					if (pSV->m_Controls[j] && pSV->m_Controls[j]->GetAutoHWnd() == (HWND)lParam)
					{
						pSV->m_Controls[j]->OnAuto(uMsg, wParam, lParam);
						pSV->SetDirty();
						break;
					}
				}

				// Process all of the edit box messages
				for (j = 0; j < pSV->m_NumProperties; j++)
				{
					if (pSV->m_Controls[j] && pSV->m_Controls[j]->GetEditHWnd() == (HWND)lParam)
					{
						pSV->m_Controls[j]->OnEdit(uMsg, wParam, lParam);
						pSV->SetDirty();
						break;
					}
				}

				switch (LOWORD(wParam))
				{
					case IDC_CONTROL_DEFAULT:
						for (j = IDC_Video_PlayoutDelay; j < IDC_Audio_PlayoutDelay; j++)
						{
							if (pSV->m_Controls[j])
								pSV->m_Controls[j]->OnDefault();
						}
						break;

					default:
						break;
				}

				//pSV->OnApplyChanges();
			}
			break;

        case WM_NOTIFY:
			if (pSV)
			{
				switch (((NMHDR FAR *)lParam)->code)
				{
					case PSN_SETACTIVE:
						{
							// We call out here specially so we can mark this page as having been init'd.
							int iRet = pSV->OnActivate();
							pSV->m_bInit = TRUE;
							return iRet;
						}
						break;

					case PSN_APPLY:
						pSV->OnApplyChanges();
						break;

					case PSN_QUERYCANCEL:    
						// return pSV->QueryCancel();
						break;

					default:
						break;
				}
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CNETWORKPMETHOD
 *
 *  @mfunc BOOL | CNetworkProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void CNetworkProperties::SetDirty()
{
	PropSheet_Changed(GetParent(m_hDlg), m_hDlg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\test\t3out\outgoing.cpp ===
//////////////////////////////////////////////////////////
// T3OUT.EXE
//
// Example of making an outgoing call with TAPI 3.0
//
// This application will allow a user to make a call
// by using TAPI 3.0.  The application will simply look
// for the first TAPI line that support Audio, and can
// dial a phone number.  It will then use that line to
// make calls.
//
// This application does not handle incoming calls, and
// does not process incoming messages.
//
//////////////////////////////////////////////////////////

#include "Precomp.h"

//////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////

const DWORD ADDRESSLENGTH   = 128;
const DWORD MAXTERMINALS    = 5;

const WCHAR * const gszTapi30           = L"TAPI 3.0 Outgoing Call Sample";


const WCHAR * const SDP = L"\
v=0\n\
o=muhan 0 0 IN IP4 172.31.76.157\n\
s=TestConf_01\n\
c=IN IP4 239.9.20.11/15\n\
t=0 0\n\
m=video 20050 RTP/AVP 34\n\
a=fmtp:34 CIF=4\n\
";
/*
k=clear:testkey\n\
m=video 20000 RTP/AVP 34\n\
m=audio 20040 RTP/AVP 0 4\n\
*/
const WCHAR * const gszConferenceName   = L"Conference Name";
const WCHAR * const gszEmailName        = L"Email Name";
const WCHAR * const gszMachineName      = L"Machine Name";
const WCHAR * const gszPhoneNumber      = L"Phone Number";
const WCHAR * const gszIPAddress        = L"IP Address";

//////////////////////////////////////////////////////////
// GLOBALS
//////////////////////////////////////////////////////////
HINSTANCE               ghInst;
HWND                    ghDlg = NULL;
ITTAPI *                gpTapi;
ITAddress *             gpAddress = NULL;
ITBasicCallControl *    gpCall;
ITStream *              gpVideoRenderStream;
ITTerminal *            gpLastVideoWindow;

//////////////////////////////////////////////////////////
// PROTOTYPES
//////////////////////////////////////////////////////////
BOOL
CALLBACK
MainDialogProc(
               HWND hDlg,
               UINT uMsg,
               WPARAM wParam,
               LPARAM lParam
              );

HRESULT
FindAnAddress(
              DWORD dwAddressType,
              BSTR  * ppName
             );

HRESULT
GetTerminal(
            ITStream * pStream,
            ITTerminal ** ppTerminal
           );

HRESULT
FindCaptureTerminal(
            ITStream * pStream,
            ITTerminal ** ppTerminal
           );

HRESULT
GetVideoRenderTerminal(
                   ITTerminal ** ppTerminal
                  );

HRESULT
MakeTheCall(
            DWORD dwAddressType,
            PWCHAR szAddressToCall
           );

HRESULT
DisconnectTheCall();

void
DoMessage(
          LPWSTR pszMessage
         );

HRESULT
InitializeTapi();

void
ShutdownTapi();

void
EnableButton(
             HWND hDlg,
             int ID
            );
void
DisableButton(
              HWND hDlg,
              int ID
             );

BOOL
AddressSupportsMediaType(
                         ITAddress * pAddress,
                         long        lMediaType
                        );

void ShowDialogs(ITBasicCallControl *pCall);

//////////////////////////////////////////////////////////
// WinMain
//////////////////////////////////////////////////////////
int
WINAPI
WinMain(
        HINSTANCE hInst,
        HINSTANCE hPrevInst,
        LPSTR lpCmdLine,
        int nCmdShow
       )
{
    ghInst = hInst;

    
    // need to coinit
    if ( FAILED( CoInitializeEx(NULL, COINIT_MULTITHREADED) ) )
    {
        return 0;
    }

    if ( FAILED( InitializeTapi() ) )
    {
        return 0;
    }
    
    // everything is initialized, so
    // start the main dialog box
    DialogBox(
              ghInst,
              MAKEINTRESOURCE(IDD_MAINDLG),
              NULL,
              MainDialogProc
             );


    ShutdownTapi();
    
    CoUninitialize();

    return 1;
}


//////////////////////////////////////////////////////////////
// InitializeTapi
//
// Various initializations
///////////////////////////////////////////////////////////////
HRESULT
InitializeTapi()
{
    HRESULT         hr;

    
    // cocreate the TAPI object
    hr = CoCreateInstance(
                          CLSID_TAPI,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ITTAPI,
                          (LPVOID *)&gpTapi
                         );

    if ( FAILED(hr) )
    {
        DoMessage(L"CoCreateInstance on TAPI failed");
        return hr;
    }

    // call initialize.  this must be called before
    // any other tapi functions are called.
    hr = gpTapi->Initialize();

    if (S_OK != hr)
    {
        DoMessage(L"TAPI failed to initialize");

        gpTapi->Release();
        gpTapi = NULL;
        
        return hr;
    }

    return S_OK;
}


///////////////////////////////////////////////////////////////
// ShutdownTapi
///////////////////////////////////////////////////////////////
void
ShutdownTapi()
{
    // if there is still a call,
    // release it
    if (NULL != gpCall)
    {
        gpCall->Release();
        gpCall = NULL;
    }

    // if we have an address object
    // release it
    if (NULL != gpAddress)
    {
        gpAddress->Release();
        gpAddress = NULL;
    }
    
    // release main object.
    if (NULL != gpTapi)
    {
        gpTapi->Shutdown();
        gpTapi->Release();
        gpTapi = NULL;
    }

}

///////////////////////////////////////////////////////////////////////////
// InitAddressTypeComboBox
//
// Put address type string in the combo box
// and save the addresstype with the string
//
///////////////////////////////////////////////////////////////////////////
void
InitAddressTypeComboBox(
    HWND hComboBox
    )
{
    int i;

    i = SendMessage( hComboBox, CB_ADDSTRING, 0, (long)gszConferenceName );
    
    SendMessage(
                hComboBox,
                CB_SETITEMDATA , 
                i,
                (long)LINEADDRESSTYPE_SDP
               );

    SendMessage( hComboBox, CB_SETCURSEL, i, 0 );

  
    i = SendMessage( hComboBox, CB_ADDSTRING, 0, (long)gszEmailName );
    
    SendMessage(
                hComboBox,
                CB_SETITEMDATA , 
                i,
                (long)LINEADDRESSTYPE_EMAILNAME
               );

    
    i = SendMessage( hComboBox, CB_ADDSTRING, 0, (long)gszMachineName );
    
    SendMessage(
                hComboBox,
                CB_SETITEMDATA , 
                i,
                (long)LINEADDRESSTYPE_DOMAINNAME
               );

    i = SendMessage( hComboBox, CB_ADDSTRING, 0, (long)gszPhoneNumber );
    
    SendMessage(
                hComboBox,
                CB_SETITEMDATA , 
                i,
                (long)LINEADDRESSTYPE_PHONENUMBER
               );

    
    i = SendMessage( hComboBox, CB_ADDSTRING, 0, (long)gszIPAddress );
    
    SendMessage(
                hComboBox,
                CB_SETITEMDATA , 
                i,
                (long)LINEADDRESSTYPE_IPADDRESS
               );

}

///////////////////////////////////////////////////////////////////////////
// MainDlgProc
///////////////////////////////////////////////////////////////////////////
BOOL
CALLBACK
MainDialogProc(
               HWND hDlg,
               UINT uMsg,
               WPARAM wParam,
               LPARAM lParam
              )
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            HWND hComboBox;

            
            // set up dialog
            ghDlg = hDlg;
            
            EnableButton( hDlg, IDOK );
            DisableButton( hDlg, IDC_DISCONNECT );
            DisableButton( hDlg, IDC_SETTINGS );

            hComboBox = GetDlgItem( hDlg, IDC_ADDRESSTYPE );

            InitAddressTypeComboBox(hComboBox);

            SetFocus( hComboBox );

            return 0;
        }

        case WM_COMMAND:
        {
			switch(LOWORD(wParam))
			{
				case IDCANCEL:
	            {
	                // quit
	                EndDialog( hDlg, 0 );

	                break;
	            }

				case IDOK:
	            {
		            // dial request
	                HWND hComboBox;
	                DWORD dwIndex;
	                DWORD dwAddressType;
	                WCHAR szAddressToCall[ADDRESSLENGTH];

	                
	                // get the address type the user selected.
	                hComboBox = GetDlgItem( hDlg, IDC_ADDRESSTYPE );
	                dwIndex = SendMessage( hComboBox, CB_GETCURSEL, 0, 0 );

	                dwAddressType = SendMessage( 
	                                             hComboBox,
	                                             CB_GETITEMDATA,
	                                             dwIndex,
	                                             0
	                                           );

	                // get the address the user wants to call
	                GetDlgItemText(
	                               hDlg,
	                               IDC_ADDRESS,
	                               szAddressToCall,
	                               ADDRESSLENGTH
	                              );

	                // make the call
	                if ( S_OK == MakeTheCall(dwAddressType, szAddressToCall) )
	                {
	                    EnableButton( hDlg, IDC_DISCONNECT );
	                    EnableButton( hDlg, IDC_SETTINGS );
	                    DisableButton( hDlg, IDOK );
	                }
	                else
	                {
	                    DoMessage(L"The call failed to connect");
	                }

	                break;
	            }

	            case IDC_DISCONNECT:
	            {
		            // disconnect request
	                if (S_OK == DisconnectTheCall())
	                {
	                    EnableButton( hDlg, IDOK );
	                    DisableButton( hDlg, IDC_DISCONNECT );
	                    DisableButton( hDlg, IDC_SETTINGS );
	                }
	                else
	                {
	                    DoMessage(L"The call failed to disconnect");
	                }

	                break;
	            }

	            case IDC_SETTINGS:
	            {
		            // Show TAPI 3.1 configuration dialogs
	                ShowDialogs(gpCall);

	                break;
	            }

	            case IDC_ADDWINDOW:
	            {
                    if (gpVideoRenderStream)
                    {
                        ITTerminal * pTerminal;
                        HRESULT hr = GetVideoRenderTerminal(&pTerminal);

                        if ( SUCCEEDED(hr) )
                        {
                            hr = gpVideoRenderStream->SelectTerminal(pTerminal);

                            if (SUCCEEDED(hr))
                            {
                                if (gpLastVideoWindow) gpLastVideoWindow->Release();
                                gpLastVideoWindow = pTerminal;
                            }
                            else
                            {
                                pTerminal->Release();
                            }
                        }
                    }

	                break;
	            }

	            case IDC_DELWINDOW:
	            {
                    if (gpVideoRenderStream && gpLastVideoWindow)
                    {
                        HRESULT hr = gpVideoRenderStream->UnselectTerminal(gpLastVideoWindow);

                        gpLastVideoWindow->Release();
                        gpLastVideoWindow = NULL;
                    }

	                break;
	            }

				default:
		            return 0;
			}
            return 1;
        }
        default:

            return 0;
    }
}


////////////////////////////////////////////////////////////////////////
// FindAnAddress
//
// Finds an address object that this application will use to make calls on.
//
// This function finds an address that supports the addresstype passed
// in, as well as the audioin and audioout media types.
//
// Return Value
//          S_OK if it finds an address
//          E_FAIL if it does not find an address
////////////////////////////////////////////////////////////////////////
HRESULT
FindAnAddress(
              DWORD dwAddressType,
              BSTR  * ppName
             )
{
    HRESULT                 hr = S_OK;
    BOOL                    bFoundAddress = FALSE;
    IEnumAddress          * pEnumAddress;
    ITAddress             * pAddress;
    ITAddressCapabilities * pAddressCaps;
    long                    lType = 0;

    // if we have an address object
    // release it
    if (NULL != gpAddress)
    {
        gpAddress->Release();
        gpAddress = NULL;
    }

    // enumerate the addresses
    hr = gpTapi->EnumerateAddresses( &pEnumAddress );

    if ( FAILED(hr) )
    {
        return hr;
    }

    while ( !bFoundAddress )
    {
        // get the next address
        hr = pEnumAddress->Next( 1, &pAddress, NULL );

        if (S_OK != hr)
        {
            break;
        }


        hr = pAddress->QueryInterface(IID_ITAddressCapabilities, (void**)&pAddressCaps);
        
        if ( SUCCEEDED(hr) )
        {

            hr = pAddressCaps->get_AddressCapability( AC_ADDRESSTYPES, &lType );
 
            pAddressCaps->Release();
 
            if ( SUCCEEDED(hr) )
            {
                // is the type we are looking for?
                if ( dwAddressType & lType )
                {
                    // does it support audio?
                    if ( AddressSupportsMediaType(pAddress, TAPIMEDIATYPE_AUDIO) )
                    {
                        // does it have a name?
                        if ( SUCCEEDED( pAddress->get_AddressName(ppName) ) )
                        {
                            // save it in the global variable
                            // since we break out of the loop, this one won't
                            // get released

                            gpAddress = pAddress;

                            bFoundAddress = TRUE;

                            break;
                        }
                    }
                }
            }
        }
       
        pAddress->Release();

    } // end while loop

    pEnumAddress->Release();
    
    if (!bFoundAddress)
    {
        return E_FAIL;
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////
// IsVideoCaptureStream
//
// Returns true if the stream is for video capture
/////////////////////////////////////////////////////////////////

BOOL
IsVideoCaptureStream(
                     ITStream * pStream
                    )
{
    TERMINAL_DIRECTION tdStreamDirection;
    long               lStreamMediaType;

    if ( FAILED( pStream  ->get_Direction(&tdStreamDirection)   ) ) { return FALSE; }
    if ( FAILED( pStream  ->get_MediaType(&lStreamMediaType)    ) ) { return FALSE; }

    return (tdStreamDirection == TD_CAPTURE) &&
           (lStreamMediaType  == TAPIMEDIATYPE_VIDEO);
}

/////////////////////////////////////////////////////////////////
// IsVideoRenderStream
//
// Returns true if the stream is for video render
/////////////////////////////////////////////////////////////////

BOOL
IsVideoRenderStream(
                     ITStream * pStream
                    )
{
    TERMINAL_DIRECTION tdStreamDirection;
    long               lStreamMediaType;

    if ( FAILED( pStream  ->get_Direction(&tdStreamDirection)   ) ) { return FALSE; }
    if ( FAILED( pStream  ->get_MediaType(&lStreamMediaType)    ) ) { return FALSE; }

    return (tdStreamDirection == TD_RENDER) &&
           (lStreamMediaType  == TAPIMEDIATYPE_VIDEO);
}

/////////////////////////////////////////////////////////////////
// IsAudioCaptureStream
//
// Returns true if the stream is for audio capture
/////////////////////////////////////////////////////////////////

BOOL
IsAudioCaptureStream(
                     ITStream * pStream
                    )
{
    TERMINAL_DIRECTION tdStreamDirection;
    long               lStreamMediaType;

    if ( FAILED( pStream  ->get_Direction(&tdStreamDirection)   ) ) { return FALSE; }
    if ( FAILED( pStream  ->get_MediaType(&lStreamMediaType)    ) ) { return FALSE; }

    return (tdStreamDirection == TD_CAPTURE) &&
           (lStreamMediaType  == TAPIMEDIATYPE_AUDIO);
}

/////////////////////////////////////////////////////////////////
// EnablePreview
//
// Selects a video render terminal on a video capture stream,
// thereby enabling video preview.
/////////////////////////////////////////////////////////////////

HRESULT
EnablePreview(
              ITStream * pStream
             )
{
    ITTerminal * pTerminal;

    HRESULT hr = GetVideoRenderTerminal(&pTerminal);

    if ( SUCCEEDED(hr) )
    {
        hr = pStream->SelectTerminal(pTerminal);

        pTerminal->Release();
    }

    return hr;
}

HRESULT
EnableAEC(
              ITStream * pStream
             )
{
    ITAudioDeviceControl *pITAudioDeviceControl;

    HRESULT hr = pStream->QueryInterface(&pITAudioDeviceControl);

    if ( SUCCEEDED(hr) )
    {
        hr = pITAudioDeviceControl->Set(AudioDevice_AcousticEchoCancellation, 1, TAPIControl_Flags_None);

        pITAudioDeviceControl->Release();
    }

    return hr;
}

void WINAPI DeleteMediaType(AM_MEDIA_TYPE* pmt)
{
    if (pmt->cbFormat != 0) {
        CoTaskMemFree((PVOID)pmt->pbFormat);
    }
    if (pmt->pUnk != NULL) {
        pmt->pUnk->Release();
        pmt->pUnk = NULL;
    }
    CoTaskMemFree((PVOID)pmt);;
}

HRESULT
CheckFormats(
    ITStream *pStream                     
    )
{
    HRESULT hr;
    DWORD dw;
    BYTE * buf;

    ITFormatControl *pITFormatControl;
    hr = pStream->QueryInterface(&pITFormatControl);

    if (FAILED(hr))
    {
        return hr;
    }

    // get the number of capabilities of the stream.
    DWORD dwCount;
    hr = pITFormatControl->GetNumberOfCapabilities(&dwCount);

    if (FAILED(hr))
    {
        goto cleanup;
    }

    TAPI_STREAM_CONFIG_CAPS caps;
    AM_MEDIA_TYPE *pMediaType;

    // Walk through each capability.
    for (dw = 0; dw < dwCount; dw ++)
    {
        BOOL fEnabled;

        hr = pITFormatControl->GetStreamCaps(dw, &pMediaType, &caps, &fEnabled);

        if (FAILED(hr))
        {
            break;
        }
        DeleteMediaType(pMediaType);
    }

    // get the current format.
    hr = pITFormatControl->GetCurrentFormat(&pMediaType);
    if (FAILED(hr))
    {
        goto cleanup;
    }

    // set it back just for fun.
//    hr = pITFormatControl->SetPreferredFormat(pMediaType);
    
    DeleteMediaType(pMediaType);

cleanup:
    pITFormatControl->Release();
    return hr;
}


#if USE_VFW
HRESULT
CheckVfwDialog(
    ITTerminal *pTerminal
    )
{
    ITVfwCaptureDialogs *pVfwCaptureDialogs;
    HRESULT hr = pTerminal->QueryInterface(&pVfwCaptureDialogs);

    if (FAILED(hr))
    {
        return hr;
    }

    hr = pVfwCaptureDialogs->HasDialog(VfwCaptureDialog_Source);

    pVfwCaptureDialogs->Release();
    
    return hr;
}
#endif

/////////////////////////////////////////////////////////////////
// SelectTerminalsOnCall
//
// Creates and selects terminals for all streams on the given
// call.
/////////////////////////////////////////////////////////////////

HRESULT
SelectTerminalsOnCall(
                     ITBasicCallControl * pCall
                     )
{
    HRESULT hr;

    //
    // get the ITStreamControl interface for this call
    //

    ITStreamControl * pStreamControl;

    hr = pCall->QueryInterface(IID_ITStreamControl,
                               (void **) &pStreamControl);

    if ( SUCCEEDED(hr) )
    {
        //
        // enumerate the streams
        //

        IEnumStream * pEnumStreams;
    
        hr = pStreamControl->EnumerateStreams(&pEnumStreams);

        pStreamControl->Release();

        if ( SUCCEEDED(hr) )
        {
            //
            // for each stream
            //

            ITStream * pStream;

            while ( S_OK == pEnumStreams->Next(1, &pStream, NULL) )
            {
                ITTerminal * pTerminal;

                //
                // Find out the media type and direction of this stream,
                // and create the default terminal for this media type and
                // direction.
                //

                hr = GetTerminal(pStream,
                                 &pTerminal);

                if ( SUCCEEDED(hr) )
                {
                    //
                    // Select the terminal on the stream.
                    //

                    if ( IsAudioCaptureStream( pStream ) )
                    {
                        //EnableAEC( pStream );
                    }

                    hr = pStream->SelectTerminal(pTerminal);

                    if ( SUCCEEDED(hr) )
                    {
                        //
                        // Also enable preview on the video capture stream.
                        //


                        if ( IsVideoCaptureStream( pStream ) )
                        {
                            EnablePreview( pStream );
                        }

                        if ( IsVideoRenderStream( pStream ) )
                        {
                            pStream->AddRef();
                            gpVideoRenderStream = pStream;
 
                            if (gpLastVideoWindow) gpLastVideoWindow->Release();
                            gpLastVideoWindow = pTerminal;
                            gpLastVideoWindow->AddRef();
                        }
                    }

                    CheckFormats(pStream);

                    pTerminal->Release();
                }
            
                pStream->Release();

            }

            pEnumStreams->Release();
        }
    }

    return hr;
}


HRESULT SetLocalInfo()
{
    const WCHAR * const LocalInfo[] = {
        L"My CName",
        L"Mu Han",
        L"muhan@microsoft.com",
        L"703-5484",
        L"Redmond",
        L"Test app",
        L"New interface test",
        L"Some randmon info"
    };

    ITLocalParticipant *pLocalParticipant;
    HRESULT hr = gpCall->QueryInterface(
        IID_ITLocalParticipant, 
        (void **)&pLocalParticipant
        );

    if (SUCCEEDED(hr))
    {
        for (int i = 0; i < PTI_PRIVATE; i ++)
        {
            BSTR info;
            hr = pLocalParticipant->get_LocalParticipantTypedInfo(
                (PARTICIPANT_TYPED_INFO)i, &info
                );

            if (SUCCEEDED(hr))
            {
                SysFreeString(info);
            }

            info = SysAllocString(LocalInfo[i]);
            hr = pLocalParticipant->put_LocalParticipantTypedInfo(
                (PARTICIPANT_TYPED_INFO)i, info
                );

            SysFreeString(info);
        }

        pLocalParticipant->Release();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////
// MakeTheCall
//
// Sets up and makes a call
/////////////////////////////////////////////////////////////////

HRESULT
MakeTheCall(
            DWORD dwAddressType,
            PWCHAR szAddressToCall
           )
{
    HRESULT                 hr = S_OK;
    BSTR                    bstrAddressToCall;
    BSTR                    pAddressName;
    

    // find an address object that
    // we will use to make calls on

    hr = FindAnAddress(dwAddressType, &pAddressName);

    if ( FAILED(hr) )
    {
        DoMessage(L"Could not find a TAPI address for making calls.");

        return hr;
    }

    SysFreeString(pAddressName);

    //
    // find out which media types this address supports
    //
    
    long lMediaTypes = 0;

    if ( AddressSupportsMediaType(gpAddress, TAPIMEDIATYPE_AUDIO) )
    {
        lMediaTypes |= TAPIMEDIATYPE_AUDIO; // we will use audio
    }


    if ( AddressSupportsMediaType(gpAddress, TAPIMEDIATYPE_VIDEO) )
    {
        lMediaTypes |= TAPIMEDIATYPE_VIDEO; // we will use video
    }


    //
    // Create the call.
    //

    if (dwAddressType == LINEADDRESSTYPE_SDP)
    {
        bstrAddressToCall = SysAllocString( SDP );
    }
    else
    {
        bstrAddressToCall = SysAllocString( szAddressToCall );
    }

    hr = gpAddress->CreateCall( bstrAddressToCall,
                                dwAddressType,
                                lMediaTypes,
                                &gpCall);

    SysFreeString ( bstrAddressToCall );
    
    if ( FAILED(hr) )
    {
        DoMessage(L"Could not create a call.");

        return hr;
    }

    //
    // Select our terminals on the call; if any of the selections fail we
    // proceed without that terminal.
    //

    hr = SelectTerminalsOnCall( gpCall );

    //
    // We're now ready to call connect.
    //
    // the VARIANT_TRUE parameter indicates that this
    // call is sychronous - that is, it won't
    // return until the call is in the connected
    // state (or fails to connect)
    // Since this is called in the UI thread,
    // this means that the app will appear
    // to hang until this function returns.
    // Some TAPI service providers may take a long
    // time for a call to reach the connected state.
    //

    // SetLocalInfo();

    hr = gpCall->Connect( VARIANT_TRUE );

    if ( FAILED(hr) )
    {
        gpCall->Release();
        gpCall = NULL;

        DoMessage(L"Could not connect the call.");

        return hr;
    }
    
    return S_OK;
}

HRESULT CheckBasicAudio(
            ITTerminal * pTerminal
                        )
{
    HRESULT hr;
    
    ITBasicAudioTerminal *pITBasicAudioTerminal;
    hr = pTerminal->QueryInterface(&pITBasicAudioTerminal);
    if ( FAILED(hr) ) return hr;

    long lVolume;
    hr = pITBasicAudioTerminal->get_Volume(&lVolume);
    if ( SUCCEEDED(hr) )
    {
        hr = pITBasicAudioTerminal->put_Volume(lVolume * 2);
    }

    pITBasicAudioTerminal->Release();
    return hr;
}

/////////////////////////////////////////////////////////
// GetTerminal
//
// Creates the default terminal for the passed-in stream.
//
/////////////////////////////////////////////////////////
HRESULT
GetTerminal(
            ITStream * pStream,
            ITTerminal ** ppTerminal
           )
{
    //
    // Determine the media type and direction of this stream.
    //
    
    HRESULT            hr;
    long               lMediaType;
    TERMINAL_DIRECTION dir;

    hr = pStream->get_MediaType( &lMediaType );
    if ( FAILED(hr) ) return hr;

    hr = pStream->get_Direction( &dir );
    if ( FAILED(hr) ) return hr;

    //
    // Since video render is a dynamic terminal, the procedure for creating
    // it is different.
    //
    
    if ( ( lMediaType == TAPIMEDIATYPE_VIDEO ) &&
         ( dir        == TD_RENDER ) )
    {
        return GetVideoRenderTerminal(ppTerminal);
    }

    //
    // For all other terminals we use GetDefaultStaticTerminal.
    // First, get the terminal support interface.
    //

    ITTerminalSupport * pTerminalSupport;

    hr = gpAddress->QueryInterface( IID_ITTerminalSupport, 
                                    (void **)&pTerminalSupport);

    if ( SUCCEEDED(hr) )
    {
        //
        // get the default terminal for this MediaType and direction
        //

        hr = pTerminalSupport->GetDefaultStaticTerminal(lMediaType,
                                                        dir,
                                                        ppTerminal);

        pTerminalSupport->Release();

        if (TAPIMEDIATYPE_AUDIO)
        {
            CheckBasicAudio(*ppTerminal);
        }

    }

    return hr;

}

/////////////////////////////////////////////////////////
// FindCaptureTerminal
//
// Find the capture terminal on a stream.
//
/////////////////////////////////////////////////////////
HRESULT
FindCaptureTerminal(
            ITStream * pStream,
            ITTerminal ** ppTerminal
           )
{
    HRESULT            hr;
    TERMINAL_DIRECTION dir;

    // enumerate all the terminals.
    IEnumTerminal *pEnumTerminals;
    hr = pStream->EnumerateTerminals(&pEnumTerminals);

    if (FAILED(hr))
    {
        return hr;
    }

    BOOL fFound = FALSE;
    ITTerminal *pTerminal;

    // find the capture terminal.
    while (S_OK == pEnumTerminals->Next(1, &pTerminal, NULL))
    {
        hr = pTerminal->get_Direction( &dir );
        if ( FAILED(hr) ) continue;

        if ( ( dir == TD_CAPTURE ) )
        {
            fFound = TRUE;
            break;
        }
        pTerminal->Release();
    }

    pEnumTerminals->Release();

    if (fFound)
    {
        *ppTerminal = pTerminal;
        return S_OK;
    }

    return E_FAIL;
}

/////////////////////////////////////////////////////////
// GetVideoRenderTerminal
//
// Creates a dynamic terminal for the Video Render mediatype / direction
//
/////////////////////////////////////////////////////////
HRESULT
GetVideoRenderTerminal(
                   ITTerminal ** ppTerminal
                  )
{
    //
    // Construct a BSTR for the correct IID.
    //

    LPOLESTR            lpTerminalClass;

    HRESULT             hr;

    hr = StringFromIID(CLSID_VideoWindowTerm,
                       &lpTerminalClass);

    if ( SUCCEEDED(hr) )
    {
        BSTR                bstrTerminalClass;

        bstrTerminalClass = SysAllocString ( lpTerminalClass );

        CoTaskMemFree( lpTerminalClass );

        if ( bstrTerminalClass == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {

            //
            // Get the terminal support interface
            //

            ITTerminalSupport * pTerminalSupport;

            hr = gpAddress->QueryInterface(IID_ITTerminalSupport, 
                                           (void **)&pTerminalSupport);

            if ( SUCCEEDED(hr) )
            {
                //
                // Create the video render terminal.
                //

                hr = pTerminalSupport->CreateTerminal(bstrTerminalClass,
                                                      TAPIMEDIATYPE_VIDEO,
                                                      TD_RENDER,
                                                      ppTerminal);

                pTerminalSupport->Release();

                if ( SUCCEEDED(hr) )
                {
                    // Get the video window interface for the terminal
                    IVideoWindow *pVideoWindow = NULL;

                    hr = (*ppTerminal)->QueryInterface(IID_IVideoWindow, 
                                                       (void**)&pVideoWindow);
            
                    if ( SUCCEEDED(hr) )
                    {
                        //
                        // Set the visible member to true
                        //
                        // Note that the visibility property is the only one
                        // we can use on this terminal's IVideoWindow and
                        // IBasicVideo interfaces before the CME_STREAM_ACTIVE
                        // event is received for the stream. All other methods
                        // will fail until CME_STREAM_ACTIVE has been sent.
                        // Applications that need to control more about a video
                        // window than just its visibility must listen for the
                        // CME_STREAM_ACTIVE event. See the "t3in.exe" sample
                        // for how to do this.
                        //

                        hr = pVideoWindow->put_AutoShow( VARIANT_TRUE );

                        pVideoWindow->Release();                            
                    }            
                }
            }

            SysFreeString( bstrTerminalClass );
        }
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////
// DisconnectTheCall
//
// Disconnects the call
//////////////////////////////////////////////////////////////////////
HRESULT
DisconnectTheCall()
{
    HRESULT         hr = S_OK;

    if (gpVideoRenderStream)
    {
        gpVideoRenderStream->Release();
        gpVideoRenderStream = NULL;
    }

    if (gpLastVideoWindow) 
    {
        gpLastVideoWindow->Release();
        gpLastVideoWindow = NULL;
    }

    if (NULL != gpCall)
    {
        hr = gpCall->Disconnect( DC_NORMAL );

        gpCall->Release();
        gpCall = NULL;
    
        return hr;
    }

    return S_FALSE;
}



///////////////////////////////////////////////////////////////////
//
// HELPER FUNCTIONS
//
///////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////
// DoMessage
///////////////////////////////////////////////////////////////////
void
DoMessage(
          LPWSTR pszMessage
         )
{
    MessageBox(
               ghDlg,
               pszMessage,
               gszTapi30,
               MB_OK
              );
}

///////////////////////////////////////////////////////////////
// EnableButton
//
// Enable, make default, and setfocus to a button
///////////////////////////////////////////////////////////////
void
EnableButton(
             HWND hDlg,
             int ID
            )
{
    SendDlgItemMessage(
                       hDlg,
                       ID,
                       BM_SETSTYLE,
                       BS_DEFPUSHBUTTON,
                       0
                      );
    EnableWindow(
                 GetDlgItem( hDlg, ID ),
                 TRUE
                );
    SetFocus(
             GetDlgItem( hDlg, ID )
            );
}

//////////////////////////////////////////////////////////////
// DisableButton
//
// Disable a button
//////////////////////////////////////////////////////////////
void
DisableButton(
              HWND hDlg,
              int ID
             )
{
    SendDlgItemMessage(
                       hDlg,
                       ID,
                       BM_SETSTYLE,
                       BS_PUSHBUTTON,
                       0
                      );
    EnableWindow(
                 GetDlgItem( hDlg, ID ),
                 FALSE
                );
}

//////////////////////////////////////////////////////////////
// AddressSupportsMediaType
//
// Finds out if the given address supports the given media
// type, and returns TRUE if it does.
//////////////////////////////////////////////////////////////

BOOL
AddressSupportsMediaType(
                         ITAddress * pAddress,
                         long        lMediaType
                        )
{
    VARIANT_BOOL     bSupport = VARIANT_FALSE;
    ITMediaSupport * pMediaSupport;
    
    if ( SUCCEEDED( pAddress->QueryInterface( IID_ITMediaSupport,
                                              (void **)&pMediaSupport ) ) )
    {
        // does it support this media type?
        pMediaSupport->QueryMediaType(
                                      lMediaType,
                                      &bSupport
                                     );
    
        pMediaSupport->Release();
    }

    return (bSupport == VARIANT_TRUE);
}

//////////////////////////////////////////////////////////////
// ShowDialogs
//
// Puts up TAPI 3.1 configuration dialogs:
//   Camera Control page
//   Video Settings page
//   Format Control page
//   Bitrate and Frame Rate Control page
//////////////////////////////////////////////////////////////

void
ShowDialogs(ITBasicCallControl *pCall)
{
	#define MAX_PAGES 9
	HRESULT Hr;
	PROPSHEETHEADER	Psh;
	HPROPSHEETPAGE	Pages[MAX_PAGES];
    ITStreamControl *pITStreamControl = NULL;
    IEnumStream *pEnumStreams = NULL;
    ITTerminal *pVideoCaptureTerminal = NULL;
    ITStream *pVideoCaptureStream = NULL;
    ITStream *pVideoRenderStream = NULL;
    ITStream *pAudioCaptureStream = NULL;
	BOOL bfMatch = FALSE;

	// Only show settings in a call
	if (!pCall)
		return;

    // Get the ITStreamControl interface for this call
    if (FAILED(Hr = pCall->QueryInterface(IID_ITStreamControl, (void **) &pITStreamControl)))
		return;

	// Look for the video capture stream and terminal
    Hr = pITStreamControl->EnumerateStreams(&pEnumStreams);
    pITStreamControl->Release();

    if (FAILED(Hr))
		return;

    // For each stream
    ITStream *pStream;
    while (S_OK == pEnumStreams->Next(1, &pStream, NULL))
    {
        // Find out the media type and direction of this stream,
        if (IsVideoCaptureStream(pStream))
        {
            pVideoCaptureStream = pStream;

            // find the capture terminal selected on this stream.
            FindCaptureTerminal(pVideoCaptureStream, &pVideoCaptureTerminal);
        }
        else if (IsAudioCaptureStream(pStream))
        {
            pAudioCaptureStream = pStream;
        }
        else if (IsVideoRenderStream(pStream))
        {
            pVideoRenderStream = pStream;
        }
        else
        {
            pStream->Release();
        }
    }

    pEnumStreams->Release();

	CCameraControlProperties CamControlOut;
	CCameraControlProperties CamControlIn;
	CProcAmpProperties VideoSettingsIn;
	CProcAmpProperties VideoSettingsOut;
	CCaptureProperties CaptureSettings;
	CVDeviceProperties VideoDevice;
	CNetworkProperties NetworkSettings;
	CSystemProperties SystemSettings;
	CAudRecProperties AudRecSettings;

	// Initialize property sheet header	and common controls
	Psh.dwSize		= sizeof(Psh);
	Psh.dwFlags		= PSH_DEFAULT;
	Psh.hInstance	= ghInst;
	Psh.hwndParent	= ghDlg;
	Psh.pszCaption	= L"Settings";
	Psh.nPages		= 0;
	Psh.nStartPage	= 0;
	Psh.pfnCallback	= NULL;
	Psh.phpage		= Pages;

    if (pVideoCaptureStream)
    {
	    // Create the outgoing video settings property page
		if (Pages[Psh.nPages] = VideoSettingsOut.OnCreate(L"Image Settings Out"))
			Psh.nPages++;

		// Connect page to the stream
		VideoSettingsOut.OnConnect(pVideoCaptureStream);

		// Create the outgoing camera control property page
		if (Pages[Psh.nPages] = CamControlOut.OnCreate(L"Camera Control Out"))
			Psh.nPages++;

		// Connect page to the stream
		CamControlOut.OnConnect(pVideoCaptureStream);

	    // Create the incoming video settings property page
		if (Pages[Psh.nPages] = VideoSettingsIn.OnCreate(L"Image Settings In"))
			Psh.nPages++;

		// Connect page to the stream
		VideoSettingsIn.OnConnect(pVideoRenderStream);

		// Create the incoming camera control property page
		if (Pages[Psh.nPages] = CamControlIn.OnCreate(L"Camera Control In"))
			Psh.nPages++;

		// Connect page to the stream
		CamControlIn.OnConnect(pVideoRenderStream);

		// Create the video stream control property page
		if (Pages[Psh.nPages] = CaptureSettings.OnCreate())
			Psh.nPages++;

		// Connect page to the stream
		CaptureSettings.OnConnect(pVideoCaptureStream);

		// Create the video device control property page
		if (Pages[Psh.nPages] = VideoDevice.OnCreate())
			Psh.nPages++;

		// Connect page to the stream
		NetworkSettings.OnConnect(NULL, pVideoCaptureStream, NULL, NULL);

		// Create the system settings property page
		if (Pages[Psh.nPages] = SystemSettings.OnCreate())
			Psh.nPages++;

		// Connect page to the address object
		SystemSettings.OnConnect(gpAddress);

	}

    if (pVideoCaptureTerminal)
    {
		// Connect page to the stream
		VideoDevice.OnConnect(pVideoCaptureTerminal);

		// Create the network control property page
		if (Pages[Psh.nPages] = NetworkSettings.OnCreate())
			Psh.nPages++;
    }

    if (pAudioCaptureStream)
    {
		// Connect page to the stream
		AudRecSettings.OnConnect(pAudioCaptureStream);

		// Create the network control property page
		if (Pages[Psh.nPages] = AudRecSettings.OnCreate())
			Psh.nPages++;
    }

    // Put up the property sheet
	if (Psh.nPages)
		PropertySheet(&Psh);

	// Disconnect pages from the stream
	VideoSettingsOut.OnDisconnect();
	CamControlOut.OnDisconnect();
	VideoSettingsIn.OnDisconnect();
	CamControlIn.OnDisconnect();
	CaptureSettings.OnDisconnect();
	VideoDevice.OnDisconnect();
	NetworkSettings.OnDisconnect();
	SystemSettings.OnDisconnect();
    AudRecSettings.OnDisconnect();

    if (pVideoCaptureTerminal) pVideoCaptureTerminal->Release();
    if (pVideoCaptureStream) pVideoCaptureStream->Release();
    if (pVideoRenderStream) pVideoRenderStream->Release();
    if (pAudioCaptureStream) pAudioCaptureStream->Release();

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\test\t3out\propedit.cpp ===
/****************************************************************************
 *  @doc INTERNAL PROPEDIT
 *
 *  @module PropEdit.cpp | Source file for the <c CPropertyEditor>
 *    class used to implement behavior of a single property to be displayed
 *    in a property page.
 ***************************************************************************/

#include "Precomp.h"

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc void | CPropertyEditor | CPropertyEditor | This
 *    method is the constructor for property objects.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    progress bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the property.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CPropertyEditor::CPropertyEditor(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl)
: m_hDlg (hDlg), m_hWndMin (NULL), m_hWndMax (NULL), m_hWndDefault (NULL), m_hWndStep (NULL), m_hWndEdit (NULL), m_hWndTrackbar (NULL), m_hWndProgress (NULL), m_IDLabel (IDLabel), m_hWndAuto (NULL), m_IDAutoControl (IDAutoControl)
, m_IDMinControl (IDMinControl), m_IDMaxControl (IDMaxControl), m_IDDefaultControl (IDDefaultControl), m_IDStepControl (IDStepControl), m_IDTrackbarControl (IDTrackbarControl), m_IDProgressControl (IDProgressControl)
, m_IDEditControl (IDEditControl), m_IDProperty (IDProperty), m_Active (FALSE), m_Min (0), m_Max (0), m_DefaultValue (0), m_DefaultFlags (0), m_SteppingDelta (0), m_CurrentValue (0), m_TrackbarOffset (0), m_ProgressOffset (0), m_fCheckBox (0)
, m_CurrentFlags (0), m_CanAutoControl (FALSE)

{
	FX_ENTRY("CPropertyEditor::CPropertyEditor")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | Init | This initializes the controls.
 *
 *  @rdesc TRUE on success, FALSE otherwise.
 ***************************************************************************/
BOOL CPropertyEditor::Init()
{
	HRESULT Hr = NOERROR;
	BOOL	fRes = TRUE;

	FX_ENTRY("CPropertyEditor::Init")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// For now disable all controls, and re-enable only the ones that make sense
	// at the end of this initialization function

	// Those GetDlgItem calls 'd better not fail ;)
	if (m_IDLabel)
		EnableWindow(GetDlgItem(m_hDlg, m_IDLabel), FALSE);
	if (m_IDMinControl)
		EnableWindow(m_hWndMin = GetDlgItem(m_hDlg, m_IDMinControl), FALSE);
	if (m_IDMaxControl)
		EnableWindow(m_hWndMax = GetDlgItem(m_hDlg, m_IDMaxControl), FALSE);
	if (m_IDDefaultControl)
		EnableWindow(m_hWndDefault = GetDlgItem(m_hDlg, m_IDDefaultControl), FALSE);
	if (m_IDStepControl)
		EnableWindow(m_hWndStep = GetDlgItem(m_hDlg, m_IDStepControl), FALSE);
	if (m_IDEditControl)
		EnableWindow(m_hWndEdit = GetDlgItem(m_hDlg, m_IDEditControl), FALSE);
	if (m_IDTrackbarControl)
		EnableWindow(m_hWndTrackbar = GetDlgItem(m_hDlg, m_IDTrackbarControl), FALSE);
	if (m_IDProgressControl)
		EnableWindow(m_hWndProgress = GetDlgItem(m_hDlg, m_IDProgressControl), FALSE);
	if (m_IDAutoControl)
		EnableWindow(m_hWndAuto = GetDlgItem(m_hDlg, m_IDAutoControl), FALSE);

	// Default values if the property isn't supported
	m_CurrentFlags = TAPIControl_Flags_Manual;
	m_CurrentValue = 0L;

	// Only enable the control if we can read the current value
	if (FAILED(Hr = GetValue()))
	{
		fRes = FALSE;
		goto MyExit;
	}

	// Save original value in case user clicks Cancel
	m_OriginalValue = m_CurrentValue;
	m_OriginalFlags = m_CurrentFlags;

	// Get the range, stepping, default, and capabilities
	if (FAILED(Hr = GetRange()))
	{
		// Special case, if no trackbar and no edit box, treat the
		// autocheck box as a boolean to control the property
		if (m_hWndTrackbar || m_hWndEdit || m_hWndProgress)
		{
			fRes = FALSE;
			goto MyExit;
		}
	}
	else
	{
		if (m_Min > m_Max || m_CurrentValue > m_Max || m_CurrentValue < m_Min || m_DefaultValue > m_Max || m_DefaultValue < m_Min)
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s: ERROR: Invalid range or current value"), _fx_));
			fRes = FALSE;
			goto MyExit;
		}

		if (m_Min == 0 && m_Max == 1 && m_SteppingDelta == 1)
			m_fCheckBox = TRUE;
	}

	// We're ready to rock & roll
	m_Active = TRUE;

	// Re-enable appropriate controls
	if (m_IDLabel)
	{
		EnableWindow(GetDlgItem(m_hDlg, m_IDLabel), TRUE);
	}
	if (m_hWndMin)
	{
		SetDlgItemInt(m_hDlg, m_IDMinControl, m_Min, TRUE);
		EnableWindow(m_hWndMin, TRUE);
	}
	if (m_hWndMax)
	{
		SetDlgItemInt(m_hDlg, m_IDMaxControl, m_Max, TRUE);
		EnableWindow(m_hWndMax, TRUE);
	}
	if (m_hWndDefault)
	{
		SetDlgItemInt(m_hDlg, m_IDDefaultControl, m_DefaultValue, TRUE);
		EnableWindow(m_hWndDefault, TRUE);
	}
	if (m_hWndStep)
	{
		SetDlgItemInt(m_hDlg, m_IDStepControl, m_SteppingDelta, TRUE);
		EnableWindow(m_hWndStep, TRUE);
	}
	if (m_hWndEdit)
	{
		UpdateEditBox();
		EnableWindow(m_hWndEdit, TRUE);
	}
	if (m_hWndTrackbar)
	{
		EnableWindow(m_hWndTrackbar, TRUE);

		// Trackbars don't handle negative values, so slide everything positive
		if (m_Min < 0)
			m_TrackbarOffset = -m_Min;

		SendMessage(m_hWndTrackbar, TBM_SETRANGEMAX, FALSE, m_Max + m_TrackbarOffset);
		SendMessage(m_hWndTrackbar, TBM_SETRANGEMIN, FALSE, m_Min + m_TrackbarOffset);

		// Have fun with the keyboards Page Up, Page Down, and arrows
		SendMessage(m_hWndTrackbar, TBM_SETLINESIZE, FALSE, (LPARAM) m_SteppingDelta);
		SendMessage(m_hWndTrackbar, TBM_SETPAGESIZE, FALSE, (LPARAM) m_SteppingDelta);

		UpdateTrackbar();
	}
	if (m_hWndProgress)
	{
		EnableWindow(m_hWndProgress, TRUE);

		// Progress controls don't handle negative values, so slide everything positive
		if (m_Min < 0)
			m_ProgressOffset = -m_Min;

		SendMessage(m_hWndProgress, PBM_SETRANGE32, m_Min + m_ProgressOffset, m_Max + m_ProgressOffset);

		UpdateProgress();

		// Set a timer to update the progress regularly
		SetTimer(m_hDlg, 123456, 250, NULL);
	}
	if (m_hWndAuto)
	{
		// If the control has an auto setting, enable the auto checkbox
		m_CanAutoControl = CanAutoControl();
		EnableWindow (m_hWndAuto, m_CanAutoControl);
		if (m_CanAutoControl)
		{
			Button_SetCheck (m_hWndAuto, GetAuto ());
		}
	}

MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return fRes;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc void | CPropertyEditor | ~CPropertyEditor | Destructor for this class.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CPropertyEditor::~CPropertyEditor()
{
	FX_ENTRY("CPropertyEditor::~CPropertyEditor")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Kill timer if we have a progress bar
	if (m_hWndProgress)
		KillTimer(m_hDlg, 123456);

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc void | CPropertyEditor | OnApply | This member function is
 *    called by the framework when the user chooses the OK or the Apply Now
 *    button. When the framework calls this member function, changes made on
 *    all property pages in the property sheet are accepted, the property
 *    sheet retains focus.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::OnApply()
{
	int nCurrentValue;

	FX_ENTRY("CPropertyEditor::OnApply")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Make sure the value is a multiple of the stepping delta
	if (m_SteppingDelta)
	{
		nCurrentValue = m_CurrentValue;
		m_CurrentValue = m_CurrentValue / m_SteppingDelta * m_SteppingDelta;
		if (m_CurrentValue != nCurrentValue)
		{
			UpdateEditBox();
			UpdateTrackbar();
		}
	}

	// Backup current value in order to only apply changes if something has really changed
	m_OriginalValue = m_CurrentValue;
	m_OriginalFlags = m_CurrentFlags;

	// Set the value on the device
	SetValue();

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc void | CPropertyEditor | HasChanged | This member tests for a
 *    change in value.
 *
 *  @rdesc Returns TRUE if value has changed.
 ***************************************************************************/
BOOL CPropertyEditor::HasChanged()
{
	FX_ENTRY("CPropertyEditor::HasChanged")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));

	return (m_CurrentValue != m_OriginalValue);
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | OnDefault | Resets the position of the
 *    slide bar and updates the content of the Target windows after the user
 *    pressed the Default button.
 *
 *  @rdesc Returns TRUE if Active, FALSE otherwise.
 ***************************************************************************/
BOOL CPropertyEditor::OnDefault()
{
	BOOL fRes = TRUE;

	FX_ENTRY("CPropertyEditor::OnDefault")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	if (!m_Active)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s: WARNING: Control not active yet!"), _fx_));
		fRes = FALSE;
		goto MyExit;
	}

	// Backup value in case user goes for the Cancel button
	m_CurrentValue = m_DefaultValue;
    m_CurrentFlags = m_DefaultFlags;

	// Update appropriate controls
	UpdateEditBox();
	UpdateTrackbar();
	UpdateAuto();

MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return fRes;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | OnScroll | Reads the position of the
 *    slide bar and updates the content of the Target windows after the user
 *    has messed with the slide bar.
 *
 *  @rdesc Returns TRUE if Active, FALSE otherwise.
 ***************************************************************************/
BOOL CPropertyEditor::OnScroll(ULONG nCommand, WPARAM wParam, LPARAM lParam)
{
	int pos;
	int command = LOWORD(wParam);
	BOOL fRes = TRUE;

	FX_ENTRY("CPropertyEditor::OnScroll")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Validate input params
	if (command != TB_ENDTRACK && command != TB_THUMBTRACK && command != TB_LINEDOWN && command != TB_LINEUP && command != TB_PAGEUP && command != TB_PAGEDOWN)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s: ERROR: Invalid input parameter!"), _fx_));
		fRes = FALSE;
		goto MyExit;
	}
	if (!m_Active)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s: WARNING: Control not active yet!"), _fx_));
		fRes = FALSE;
		goto MyExit;
	}

	// Retrieve position in slide bar
	pos = (int)SendMessage((HWND) lParam, TBM_GETPOS, 0, 0L);

	// Make sure the value is a multiple of the stepping delta
	if (m_SteppingDelta)
		m_CurrentValue = (pos - m_TrackbarOffset - m_Min) / m_SteppingDelta * m_SteppingDelta + m_Min;
	else
		m_CurrentValue = pos - m_TrackbarOffset;

	// Sync edit box to the slide bar
	UpdateEditBox();

MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return fRes;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | OnEdit | Reads the content of the
 *    Target window and updates the postion of the slider after the user
 *    has messed with the Target edit control.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::OnEdit(ULONG nCommand, WPARAM wParam, LPARAM lParam)
{
	BOOL fTranslated;
	int nCurrentValue;

	FX_ENTRY("CPropertyEditor::OnEdit")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// We get called even before init has been done -> test for m_Active
	if (m_Active)
	{
		if (!m_fCheckBox)
		{
			// Read the value from the control
			if (m_hWndEdit)
				nCurrentValue = GetDlgItemInt(m_hDlg, m_IDEditControl, &fTranslated, TRUE);

			// Is the value garbage?
			if (fTranslated)
			{
				if (nCurrentValue > m_Max)
				{
					// The value is already large than its max -> clamp it and update the control
					m_CurrentValue = m_Max;
					UpdateEditBox();
				}
				else if (nCurrentValue < m_Min)
				{
					// The value is already smaller than its min -> clamp it and update the control
					m_CurrentValue = m_Min;
					UpdateEditBox();
				}
				else
					m_CurrentValue = nCurrentValue;
			}
			else
			{
				// It's garbage -> Reset the control to its minimum value
				m_CurrentValue = m_Min;
				UpdateEditBox();
			}

			// Sync slide bar to edit box
			UpdateTrackbar();
		}
		else
		{
			// Read the value from the control
			if (m_hWndEdit)
				m_CurrentValue = Button_GetCheck(m_hWndEdit);
		}
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | OnAuto | Gets the status of the
 *    checkbox.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::OnAuto(ULONG nCommand, WPARAM wParam, LPARAM lParam)
{
	SetAuto(Button_GetCheck(m_hWndAuto));

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HWND | CPropertyEditor | GetTrackbarHWnd | Helper method to allow
 *    the property page code to access the slide bar window (private member) of
 *    a property.
 *
 *  @rdesc Returns a handle to the slide bar window.
 ***************************************************************************/
HWND CPropertyEditor::GetTrackbarHWnd()
{
	return m_hWndTrackbar;
};

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HWND | CPropertyEditor | GetProgressHWnd | Helper method to allow
 *    the property page code to access the progress bar window (private member) of
 *    a property.
 *
 *  @rdesc Returns a handle to the progress window.
 ***************************************************************************/
HWND CPropertyEditor::GetProgressHWnd()
{
	return m_hWndProgress;
};

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HWND | CPropertyEditor | GetEditHWnd | Helper method to allow
 *    the property page code to access the Target window (private member) of
 *    a property.
 *
 *  @rdesc Returns a handle to the Target window.
 ***************************************************************************/
HWND CPropertyEditor::GetEditHWnd()
{
	return m_hWndEdit;
};

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HWND | CPropertyEditor | GetAutoHWnd | Helper method to allow
 *    the property page code to access the auto window (private member) of
 *    a property.
 *
 *  @rdesc Returns a handle to the auto window.
 ***************************************************************************/
HWND CPropertyEditor::GetAutoHWnd()
{
	return m_hWndAuto;
};

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | UpdateEditBox | Updates the content of
 *    the Target window after user has moved the slide bar.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::UpdateEditBox()
{
	if (m_hWndEdit)
	{
		if (!m_fCheckBox)
			SetDlgItemInt(m_hDlg, m_IDEditControl, m_CurrentValue, TRUE);
		else
			Button_SetCheck(m_hWndEdit, m_CurrentValue);
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | UpdateTrackbar | Updates the position of
 *    the slide bar after user has messed with the Target window.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::UpdateTrackbar()
{
	if (m_hWndTrackbar)
		SendMessage(m_hWndTrackbar, TBM_SETPOS, TRUE, (LPARAM) m_CurrentValue + m_TrackbarOffset);

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | UpdateProgress | Updates the position of
 *    the progress bar.
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::UpdateProgress()
{
	// Get current value from the device
	GetValue();

	if (m_hWndProgress)
		SendMessage(m_hWndProgress, PBM_SETPOS, (WPARAM) m_CurrentValue + m_ProgressOffset, 0);

	UpdateEditBox();

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc BOOL | CPropertyEditor | UpdateAuto | Updates the auto checkbox
 *
 *  @rdesc Returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::UpdateAuto()
{
	if (m_hWndAuto && CanAutoControl())
	{
		m_CanAutoControl = GetAuto();
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HRESULT | CPropertyEditor | CanAutoControl | This method
 *    retrieves the automatic control capabilities for a property.
 *
 *  @rdesc This method returns TRUE if automatic control is supported, FALSE
 *    otherwise.
 ***************************************************************************/
BOOL CPropertyEditor::CanAutoControl(void)
{
	FX_ENTRY("CPropertyEditor::CanAutoControl")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));

	return m_CapsFlags & TAPIControl_Flags_Auto;
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HRESULT | CPropertyEditor | GetAuto | This method
 *    retrieves the current automatic control mode of a property.
 *
 *  @rdesc This method returns TRUE if automatic control is supported, FALSE
 *    otherwise.
 ***************************************************************************/
BOOL CPropertyEditor::GetAuto(void)
{
	FX_ENTRY("CPropertyEditor::GetAuto")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	GetValue();

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));

	return m_CurrentFlags & TAPIControl_Flags_Auto; 
}

/****************************************************************************
 *  @doc INTERNAL CPROPEDITMETHOD
 *
 *  @mfunc HRESULT | CPropertyEditor | SetAuto | This method
 *    sets the automatic control mode of a property.
 *
 *  @parm BOOL | fAuto | Specifies the automatic control mode.
 *
 *  @rdesc This method returns TRUE.
 ***************************************************************************/
BOOL CPropertyEditor::SetAuto(BOOL fAuto)
{
	FX_ENTRY("CPropertyEditor::SetAuto")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	m_CurrentFlags = (fAuto ? TAPIControl_Flags_Auto : (m_CapsFlags & TAPIControl_Flags_Manual) ? TAPIControl_Flags_Manual : TAPIControl_Flags_None);

	SetValue();

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));

	return TRUE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\test\t3out\procampp.h ===
/****************************************************************************
 *  @doc INTERNAL PROCAMPP
 *
 *  @module ProcAmpP.h | Header file for the <c CProcAmpProperty>
 *    class used to implement a property page to test the control interface
 *    <i ITVideoSettings>.
 ***************************************************************************/

#define NUM_PROCAMP_CONTROLS (VideoProcAmp_BacklightCompensation + 1)

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPCLASS
 *
 *  @class CProcAmpProperty | This class implements handling of a
 *    single video proc amp control property in a property page.
 *
 *  @mdata int | CProcAmpProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata ITVideoSettings * | CProcAmpProperty | m_pInterface | Pointer
 *    to the <i ITVideoSettings> interface.
***************************************************************************/
class CProcAmpProperty : public CPropertyEditor 
{
	public:
	CProcAmpProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, ITVideoSettings *pInterface);
	~CProcAmpProperty ();

	// CPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();

	private:
	ITVideoSettings *m_pInterface;
};

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPCLASS
 *
 *  @class CProcAmpProperties | This class runs a property page to test
 *    the TAPI VfW Capture Filter <i ITVideoSettings> implementation.
 *
 *  @mdata int | CProcAmpProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata ITVideoSettings * | CProcAmpProperties | m_pITVideoSettings | Pointer
 *    to the <i ITVideoSettings> interface.
 *
 *  @mdata CProcAmpProperty * | CProcAmpProperties | m_Controls[NUM_PROCAMP_CONTROLS] | Array
 *    of video proc amp properties.
***************************************************************************/
class CProcAmpProperties
{
	public:
	CProcAmpProperties();
	~CProcAmpProperties();

	HPROPSHEETPAGE OnCreate(LPWSTR pszTitle);

	HRESULT OnConnect(ITStream *pStream);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();

	private:

	void SetDirty();

	BOOL				m_bInit;
	HWND				m_hDlg;
	int					m_NumProperties;
	ITVideoSettings		*m_pITVideoSettings;
	CProcAmpProperty	*m_Controls[NUM_PROCAMP_CONTROLS];

	// Dialog proc
	static INT_PTR CALLBACK BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\test\t3out\procampp.cpp ===
/****************************************************************************
 *  @doc INTERNAL PROCAMPP
 *
 *  @module ProcAmpP.cpp | Source file for the <c CProcAmpProperty>
 *    class used to implement a property page to test the control interface
 *    <i ITVideoSettings>.
 ***************************************************************************/

#include "Precomp.h"

extern HINSTANCE ghInst;

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc void | CProcAmpProperty | CProcAmpProperty | This
 *    method is the constructor for video proc amp control property objects. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    a pointer to the <i ITVideoSettings> interface.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property progress bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm ITVideoSettings* | pInterface | Specifies a pointer to the
 *    <i ITVideoSettings> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CProcAmpProperty::CProcAmpProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, ITVideoSettings *pInterface)
: CPropertyEditor(hDlg, IDLabel, IDMinControl, IDMaxControl, IDDefaultControl, IDStepControl, IDEditControl, IDTrackbarControl, IDProgressControl, IDProperty, IDAutoControl)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("CProcAmpProperty::CProcAmpProperty")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointer is NULL, we'll grey the
	// associated items in the property page
	m_pInterface = pInterface;

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc void | CProcAmpProperty | ~CProcAmpProperty | This
 *    method is the destructor for video proc amp control property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CProcAmpProperty::~CProcAmpProperty()
{
	FX_ENTRY("CProcAmpProperty::~CProcAmpProperty")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperty::GetValue()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CProcAmpProperty::GetValue")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: invalid input parameter"), _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->Get((VideoSettingsProperty)m_IDProperty, &m_CurrentValue, (TAPIControlFlags*)&m_CurrentFlags)))
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_CurrentValue=%ld, m_CurrentFlags=%ld"), _fx_, m_CurrentValue, m_CurrentFlags));
	}
	else
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: m_pITVideoSettings->Get failed Hr=0x%08lX"), _fx_, Hr));
	}

MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperty::SetValue()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CProcAmpProperty::SetValue")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: invalid input parameter"), _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->Set((VideoSettingsProperty)m_IDProperty, m_CurrentValue, (TAPIControlFlags)m_CurrentFlags)))
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_CurrentValue=%ld, m_CurrentFlags=%ld"), _fx_, m_CurrentValue, m_CurrentFlags));
	}
	else
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: m_pITVideoSettings->Set failed Hr=0x%08lX"), _fx_, Hr));
	}

MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperty::GetRange()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CProcAmpProperty::GetRange")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: invalid input parameter"), _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->GetRange((VideoSettingsProperty)m_IDProperty, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, (TAPIControlFlags*)&m_CapsFlags)))
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Min=%ld, m_Max=%ld, m_SteppingDelta=%ld, m_DefaultValue=%ld, m_CapsFlags=%ld"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue, m_CapsFlags));
	}
	else
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: m_pITVideoSettings->GetRange failed Hr=0x%08lX"), _fx_, Hr));
	}
	m_DefaultFlags = m_CapsFlags;

MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HPROPSHEETPAGE | CProcAmpProperties | OnCreate | This
 *    method creates a new page for a property sheet.
 *
 *  @rdesc Returns the handle to the new property sheet if successful, or
 *    NULL otherwise.
 ***************************************************************************/
HPROPSHEETPAGE CProcAmpProperties::OnCreate(LPWSTR pszTitle)
{
    PROPSHEETPAGE psp;
    
	psp.dwSize        = sizeof(psp);
    psp.dwFlags       = PSP_USEREFPARENT | PSP_USETITLE;
    psp.hInstance     = ghInst;
    psp.pszTemplate   = MAKEINTRESOURCE(IDD_VideoProcAmpProperties);
    psp.pszTitle      = pszTitle;
    psp.pfnDlgProc    = BaseDlgProc;
    psp.pcRefParent   = 0;
    psp.pfnCallback   = (LPFNPSPCALLBACK)NULL;
    psp.lParam        = (LPARAM)this;

    return CreatePropertySheetPage(&psp);
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc void | CProcAmpProperties | CProcAmpProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CProcAmpProperties::CProcAmpProperties()
{
	FX_ENTRY("CProcAmpProperties::CProcAmpProperties")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	m_pITVideoSettings = NULL;
	m_NumProperties = NUM_PROCAMP_CONTROLS;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc void | CProcAmpProperties | ~CProcAmpProperties | This
 *    method is the destructor for the video proc amp control property page. It
 *    simply calls the base class destructor after deleting all the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CProcAmpProperties::~CProcAmpProperties()
{
	int		j;

	FX_ENTRY("CProcAmpProperties::~CProcAmpProperties")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX"), _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: control already freed"), _fx_));
		}
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperties | OnConnect | This
 *    method is called when the property page is connected to a TAPI object.
 *
 *  @parm ITStream* | pStream | Specifies a pointer to the <i ITStream>
 *    interface. It is used to QI for the <i ITVideoSettings> interface.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperties::OnConnect(ITStream *pStream)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CProcAmpProperties::OnConnect")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	if (!pStream)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: invalid input parameter"), _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the video proc amp interface
	if (SUCCEEDED (Hr = pStream->QueryInterface(&m_pITVideoSettings)))
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_pITVideoSettings=0x%08lX"), _fx_, m_pITVideoSettings));
	}
	else
	{
		m_pITVideoSettings = NULL;
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: IOCTL failed Hr=0x%08lX"), _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers. We'll just grey the controls in the property page
	// to make it clear to the user that they can't control those properties on the device
	Hr = NOERROR;

MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperties::OnDisconnect()
{
	FX_ENTRY("CProcAmpProperties::OnDisconnect")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	if (!m_pITVideoSettings)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pITVideoSettings->Release();
		m_pITVideoSettings = NULL;
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: releasing m_pITVideoSettings"), _fx_));
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperties::OnActivate()
{
	HRESULT	Hr = E_OUTOFMEMORY;
	int		j;

	FX_ENTRY("CProcAmpProperties::OnActivate")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Create the controls for the properties
	if (!(m_Controls[0] = new CProcAmpProperty(m_hDlg, IDC_Brightness_Label, IDC_Brightness_Minimum, IDC_Brightness_Maximum, IDC_Brightness_Default, IDC_Brightness_Stepping, IDC_Brightness_Edit, IDC_Brightness_Slider, 0, VideoProcAmp_Brightness, IDC_Brightness_Auto, m_pITVideoSettings)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[VideoProcAmp_Brightness] failed - Out of memory"), _fx_));
		goto MyExit;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[VideoProcAmp_Brightness]=0x%08lX"), _fx_, m_Controls[0]));
	}

	if (!(m_Controls[1] = new CProcAmpProperty(m_hDlg, IDC_Contrast_Label, IDC_Contrast_Minimum, IDC_Contrast_Maximum, IDC_Contrast_Default, IDC_Contrast_Stepping, IDC_Contrast_Edit, IDC_Contrast_Slider, 0, VideoProcAmp_Contrast, IDC_Contrast_Auto, m_pITVideoSettings)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[VideoProcAmp_Contrast] failed - Out of memory"), _fx_));
		goto MyError0;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[VideoProcAmp_Contrast]=0x%08lX"), _fx_, m_Controls[1]));
	}

	if (!(m_Controls[2] = new CProcAmpProperty(m_hDlg, IDC_Hue_Label, IDC_Hue_Minimum, IDC_Hue_Maximum, IDC_Hue_Default, IDC_Hue_Stepping, IDC_Hue_Edit, IDC_Hue_Slider, 0, VideoProcAmp_Hue, IDC_Hue_Auto, m_pITVideoSettings)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[VideoProcAmp_Hue] failed - Out of memory"), _fx_));
		goto MyError1;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[VideoProcAmp_Hue]=0x%08lX"), _fx_, m_Controls[2]));
	}

	if (!(m_Controls[3] = new CProcAmpProperty(m_hDlg, IDC_Saturation_Label, IDC_Saturation_Minimum, IDC_Saturation_Maximum, IDC_Saturation_Default, IDC_Saturation_Stepping, IDC_Saturation_Edit, IDC_Saturation_Slider, 0, VideoProcAmp_Saturation, IDC_Saturation_Auto, m_pITVideoSettings)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[VideoProcAmp_Saturation] failed - Out of memory"), _fx_));
		goto MyError2;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[VideoProcAmp_Saturation]=0x%08lX"), _fx_, m_Controls[3]));
	}

	if (!(m_Controls[4] = new CProcAmpProperty(m_hDlg, IDC_Sharpness_Label, IDC_Sharpness_Minimum, IDC_Sharpness_Maximum, IDC_Sharpness_Default, IDC_Sharpness_Stepping, IDC_Sharpness_Edit, IDC_Sharpness_Slider, 0, VideoProcAmp_Sharpness, IDC_Sharpness_Auto, m_pITVideoSettings)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[VideoProcAmp_Sharpness] failed - Out of memory"), _fx_));
		goto MyError3;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[VideoProcAmp_Sharpness]=0x%08lX"), _fx_, m_Controls[4]));
	}

	if (!(m_Controls[5] = new CProcAmpProperty(m_hDlg, IDC_Gamma_Label, IDC_Gamma_Minimum, IDC_Gamma_Maximum, IDC_Gamma_Default, IDC_Gamma_Stepping, IDC_Gamma_Edit, IDC_Gamma_Slider, 0, VideoProcAmp_Gamma, IDC_Gamma_Auto, m_pITVideoSettings)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[VideoProcAmp_Gamma] failed - Out of memory"), _fx_));
		goto MyError4;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[VideoProcAmp_Gamma]=0x%08lX"), _fx_, m_Controls[5]));
	}

	if (!(m_Controls[6] = new CProcAmpProperty(m_hDlg, IDC_ColorEnable_Label, IDC_ColorEnable_Minimum, IDC_ColorEnable_Maximum, IDC_ColorEnable_Default, IDC_ColorEnable_Stepping, IDC_ColorEnable_Edit, IDC_ColorEnable_Slider, 0, VideoProcAmp_ColorEnable, IDC_ColorEnable_Auto, m_pITVideoSettings)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[VideoProcAmp_ColorEnable] failed - Out of memory"), _fx_));
		goto MyError5;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[VideoProcAmp_ColorEnable]=0x%08lX"), _fx_, m_Controls[6]));
	}

	if (!(m_Controls[7] = new CProcAmpProperty(m_hDlg, IDC_WhiteBalance_Label, IDC_WhiteBalance_Minimum, IDC_WhiteBalance_Maximum, IDC_WhiteBalance_Default, IDC_WhiteBalance_Stepping, IDC_WhiteBalance_Edit, IDC_WhiteBalance_Slider, 0, VideoProcAmp_WhiteBalance, IDC_WhiteBalance_Auto, m_pITVideoSettings)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[VideoProcAmp_WhiteBalance] failed - Out of memory"), _fx_));
		goto MyError5;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[VideoProcAmp_WhiteBalance]=0x%08lX"), _fx_, m_Controls[6]));
	}

	if (!(m_Controls[8] = new CProcAmpProperty(m_hDlg, IDC_BacklightComp_Label, IDC_BacklightComp_Minimum, IDC_BacklightComp_Maximum, IDC_BacklightComp_Default, IDC_BacklightComp_Stepping, IDC_BacklightComp_Edit, IDC_BacklightComp_Slider, 0, VideoProcAmp_BacklightCompensation, IDC_BacklightComp_Auto, m_pITVideoSettings)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[VideoProcAmp_BacklightComp] failed - Out of memory"), _fx_));
		goto MyError5;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[VideoProcAmp_BacklightComp]=0x%08lX"), _fx_, m_Controls[6]));
	}

	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the device. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j]->Init())
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[%ld]->Init()"), _fx_, j));
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: m_Controls[%ld]->Init() failed"), _fx_, j));
		}
	}

	Hr = NOERROR;
	goto MyExit;

MyError5:
	if (m_Controls[5])
		delete m_Controls[5], m_Controls[5] = NULL;
MyError4:
	if (m_Controls[4])
		delete m_Controls[4], m_Controls[4] = NULL;
MyError3:
	if (m_Controls[3])
		delete m_Controls[3], m_Controls[3] = NULL;
MyError2:
	if (m_Controls[2])
		delete m_Controls[2], m_Controls[2] = NULL;
MyError1:
	if (m_Controls[1])
		delete m_Controls[1], m_Controls[1] = NULL;
MyError0:
	if (m_Controls[0])
		delete m_Controls[0], m_Controls[0] = NULL;
MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperties::OnDeactivate()
{
	int		j;

	FX_ENTRY("CProcAmpProperties::OnDeactivate")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX"), _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: control already freed"), _fx_));
		}
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc HRESULT | CProcAmpProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CProcAmpProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;

	FX_ENTRY("CProcAmpProperties::OnApplyChanges")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	for (int j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			if (m_Controls[j]->HasChanged())
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: calling m_Controls[%ld]=0x%08lX->OnApply"), _fx_, j, m_Controls[j]));
				m_Controls[j]->OnApply();
			}
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: can't call m_Controls[%ld]=NULL->OnApply"), _fx_, j));
			Hr = E_UNEXPECTED;
			break;
		}
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc BOOL | CProcAmpProperties | BaseDlgProc | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
INT_PTR CALLBACK CProcAmpProperties::BaseDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
    CProcAmpProperties *pSV = (CProcAmpProperties*)GetWindowLong(hDlg, DWL_USER);

	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
        case WM_INITDIALOG:
			{
				LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)lParam;
				pSV = (CProcAmpProperties*)psp->lParam;
				pSV->m_hDlg = hDlg;
				SetWindowLong(hDlg, DWL_USER, (LPARAM)pSV);
				pSV->m_bInit = FALSE;
				pSV->OnActivate();
				pSV->m_bInit = TRUE;
				return TRUE;
			}
			break;

		case WM_HSCROLL:
		case WM_VSCROLL:
            if (pSV && pSV->m_bInit)
            {
				// Process all of the Trackbar messages
				for (j = 0; j < pSV->m_NumProperties; j++)
				{
					if (pSV->m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
					{
						pSV->m_Controls[j]->OnScroll(uMsg, wParam, lParam);
						pSV->SetDirty();
					}
				}
				pSV->OnApplyChanges();
			}
			break;

		case WM_COMMAND:
            if (pSV && pSV->m_bInit)
            {
				// Process all of the auto checkbox messages
				for (j = 0; j < pSV->m_NumProperties; j++)
				{
					if (pSV->m_Controls[j] && pSV->m_Controls[j]->GetAutoHWnd() == (HWND)lParam)
					{
						pSV->m_Controls[j]->OnAuto(uMsg, wParam, lParam);
						pSV->SetDirty();
						break;
					}
				}

				// Process all of the edit box messages
				for (j = 0; j < pSV->m_NumProperties; j++)
				{
					if (pSV->m_Controls[j] && pSV->m_Controls[j]->GetEditHWnd() == (HWND)lParam)
					{
						pSV->m_Controls[j]->OnEdit(uMsg, wParam, lParam);
						pSV->SetDirty();
						break;
					}
				}

				switch (LOWORD(wParam))
				{
					case IDC_CONTROL_DEFAULT:
						for (j = 0; j < pSV->m_NumProperties; j++)
						{
							if (pSV->m_Controls[j])
								pSV->m_Controls[j]->OnDefault();
						}
						break;

					default:
						break;
				}

				pSV->OnApplyChanges();
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPPMETHOD
 *
 *  @mfunc BOOL | CProcAmpProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void CProcAmpProperties::SetDirty()
{
	PropSheet_Changed(GetParent(m_hDlg), m_hDlg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\test\t3out\propedit.h ===
/****************************************************************************
 *  @doc INTERNAL PROPEDIT
 *
 *  @module PropEdit.h | Header file for the <c CPropertyEditor>
 *    class used to implement behavior of a single property to be displayed
 *    in a property page.
 *
 *  @comm This code tests the Ks interface handlers. This code is only
 *    compiled if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

/****************************************************************************
 *  @doc INTERNAL CPROPEDITCLASS
 *
 *  @class CPropertyEditor | This class implements behavior of a single
 *    property to be displayed in a property page.
 *
 *  @mdata ULONG | CPropertyEditor | m_IDProperty | Property ID
 *
 *  @mdata LONG | CPropertyEditor | m_CurrentValue | Property current value
 *
 *  @mdata LONG | CPropertyEditor | m_Min | Property minimum value
 *
 *  @mdata LONG | CPropertyEditor | m_Max | Property maximum value
 *
 *  @mdata LONG | CPropertyEditor | m_SteppingDelta | Property stepping delta
 *
 *  @mdata LONG | CPropertyEditor | m_DefaultValue | Property default value
 *
 *  @mdata BOOL | CPropertyEditor | m_Active | Set to TRUE after all property values have been initialized
 *
 *  @mdata LONG | CPropertyEditor | m_OriginalValue | Backup of the original value
 *
 *  @mdata HWND | CPropertyEditor | m_hDlg | Window handle to the Parent dialog
 *
 *  @mdata HWND | CPropertyEditor | m_hWndMin | Window handle to the Minimum dialog item
 *
 *  @mdata HWND | CPropertyEditor | m_hWndMax | Window handle to the Maximum dialog item
 *
 *  @mdata HWND | CPropertyEditor | m_hWndDefault | Window handle to the Default dialog item
 *
 *  @mdata HWND | CPropertyEditor | m_hWndStep | Window handle to the Stepping Delta dialog item
 *
 *  @mdata HWND | CPropertyEditor | m_hWndEdit | Window handle to the Target dialog item
 *
 *  @mdata HWND | CPropertyEditor | m_hWndTrackbar | Window handle to the slide bar
 *
 *  @mdata HWND | CPropertyEditor | m_hWndProgress | Window handle to the progress bar
 *
 *  @mdata ULONG | CPropertyEditor | m_IDLabel | Resource ID of the property label
 *
 *  @mdata ULONG | CPropertyEditor | m_IDMinControl | Resource ID of the Minimum dialog item
 *
 *  @mdata ULONG | CPropertyEditor | m_IDMaxControl | Resource ID of the Maximum dialog item
 *
 *  @mdata ULONG | CPropertyEditor | m_IDStepControl | Resource ID of the Stepping Delta dialog item
 *
 *  @mdata ULONG | CPropertyEditor | m_IDDefaultControl | Resource ID of the Default dialog item
 *
 *  @mdata ULONG | CPropertyEditor | m_IDEditControl | Resource ID of the Target dialog item
 *
 *  @mdata ULONG | CPropertyEditor | m_IDTrackbarControl | Resource ID of the slide bar
 *
 *  @mdata ULONG | CPropertyEditor | m_IDProgressControl | Resource ID of the progress bar
 ***************************************************************************/
class CPropertyEditor
{
	public:
	CPropertyEditor(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl);
	virtual ~CPropertyEditor();

	BOOL Init();

	HWND GetTrackbarHWnd();
	HWND GetProgressHWnd();
	HWND GetEditHWnd();
	HWND GetAutoHWnd();

	BOOL UpdateEditBox();
	BOOL UpdateTrackbar();
	BOOL UpdateProgress();
	BOOL UpdateAuto();

	BOOL OnApply();
	BOOL OnDefault();
	BOOL OnScroll(ULONG nCommand, WPARAM wParam, LPARAM lParam);
	BOOL OnEdit(ULONG nCommand, WPARAM wParam, LPARAM lParam);
	BOOL OnAuto(ULONG nCommand, WPARAM wParam, LPARAM lParam);
	BOOL HasChanged();

	protected:

	BOOL CanAutoControl(void);
	BOOL GetAuto(void);
	BOOL SetAuto(BOOL fAuto);

	// Pure virtual functions to set/get actual property values, and the ranges
	virtual HRESULT GetValue(void) PURE;
	virtual HRESULT SetValue(void) PURE;
	virtual HRESULT GetRange(void) PURE; 

	ULONG	m_IDProperty;	// Property ID

	// The following are used by GetValue and SetValue
	LONG	m_CurrentValue;
	LONG	m_CurrentFlags;

	// The following must be set by GetRange
	LONG	m_Min;
	LONG	m_Max;
	LONG	m_SteppingDelta;
	LONG	m_DefaultValue;
	LONG	m_DefaultFlags;
	TAPIControlFlags	m_CapsFlags;

	private:
	BOOL	m_Active;
	BOOL	m_fCheckBox;
	LONG	m_OriginalValue;
	LONG	m_OriginalFlags;
	HWND	m_hDlg;				// Parent
	HWND	m_hWndMin;			// Min window
	HWND	m_hWndMax;			// Max window
	HWND	m_hWndDefault;		// Default window
	HWND	m_hWndStep;			// Step window
	HWND	m_hWndEdit;			// Edit window
	HWND	m_hWndTrackbar;		// Slider
	HWND	m_hWndProgress;		// Progress
	HWND	m_hWndAuto;			// Auto checkbox
	ULONG	m_IDLabel;			// ID of label
	ULONG	m_IDMinControl;		// ID of min control
	ULONG	m_IDMaxControl;		// ID of max control
	ULONG	m_IDStepControl;	// ID of step control
	ULONG	m_IDDefaultControl;	// ID of default control
	ULONG	m_IDEditControl;	// ID of edit control
	ULONG	m_IDTrackbarControl;// ID of trackbar
	ULONG	m_IDProgressControl;// ID of trackbar
	ULONG	m_IDAutoControl;	// ID of auto checkbox
	LONG	m_TrackbarOffset;	// Handles negative trackbar offsets
	LONG	m_ProgressOffset;	// Handles negative trackbar offsets
	BOOL	m_CanAutoControl;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\test\t3out\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Script1.rc
//
#define IDD_MAINDLG                     100
#define IDC_ADDRESSTYPE                 1002
#define IDC_ADDRESS                     1009
#define IDC_DISCONNECT                  1001
#define IDC_SETTINGS                    1003
#define IDC_ADDWINDOW                   1004
#define IDC_DELWINDOW                   1005
#define IDC_STATIC                      -1

#define IDD_CaptureFormatProperties     101
#define IDD_RenderFormatProperties      102
#define IDD_CameraControlProperties     103
#define IDD_RecordFormatProperties      104
#define IDD_CaptureDeviceProperties     105
#define IDD_PlaybackFormatProperties    106
#define IDD_VideoProcAmpProperties      107
#define IDD_AudioDeviceProperties       108
#define IDD_SystemProperties            109
#define IDD_NetworkProperties           110

#define IDC_BitrateControl_Label        200
#define IDC_BitrateControl_Minimum      201
#define IDC_BitrateControl_Maximum      202
#define IDC_BitrateControl_Default      203
#define IDC_BitrateControl_Stepping     204
#define IDC_BitrateControl_Edit         205
#define IDC_BitrateControl_Slider       206
#define IDC_BitrateControl_Meter        207
#define IDC_BitrateControl_Actual       208

#define IDC_FrameRateControl_Label      210
#define IDC_FrameRateControl_Minimum    211
#define IDC_FrameRateControl_Maximum    212
#define IDC_FrameRateControl_Default    213
#define IDC_FrameRateControl_Stepping   214
#define IDC_FrameRateControl_Edit       215
#define IDC_FrameRateControl_Slider     216
#define IDC_FrameRateControl_Meter      217
#define IDC_FrameRateControl_Actual     218

#define IDC_TsTradeOff_Slider           220
#define IDC_TsTradeOff_Edit             221

#define IDC_CONTROL_DEFAULT             230

#define IDC_FORMAT_Compression          240
#define IDC_FORMAT_FlipVertical         241
#define IDC_FORMAT_FlipHorizontal       242

#define IDC_AudioLevel_Label            300
#define IDC_AudioLevel_Minimum          301
#define IDC_AudioLevel_Maximum          302
#define IDC_AudioLevel_Default          303
#define IDC_AudioLevel_Stepping         304
#define IDC_AudioLevel_Edit             305
#define IDC_AudioLevel_Slider           306
#define IDC_AudioLevel_Meter            307

#define IDC_VolumeLevel_Label           0
#define IDC_VolumeLevel_Minimum         0
#define IDC_VolumeLevel_Maximum         0
#define IDC_VolumeLevel_Default         0
#define IDC_VolumeLevel_Stepping        0
#define IDC_VolumeLevel_Edit            0
#define IDC_VolumeLevel_Slider          309
#define IDC_VolumeLevel_Meter           0

#define IDC_SilenceLevel_Label          310
#define IDC_SilenceLevel_Minimum        311
#define IDC_SilenceLevel_Maximum        312
#define IDC_SilenceLevel_Default        313
#define IDC_SilenceLevel_Stepping       314
#define IDC_SilenceLevel_Edit           315
#define IDC_SilenceLevel_Slider         316
#define IDC_SilenceLevel_Meter          0

#define IDC_SILENCECONTROL_DEFAULT      320

#define IDC_FORMAT_SilenceCompression   330
#define IDC_FORMAT_SilenceDetection     331

#define IDC_Pan_Label                   400
#define IDC_Pan_Minimum                 0
#define IDC_Pan_Maximum                 0
#define IDC_Pan_Default                 0
#define IDC_Pan_Stepping                0
#define IDC_Pan_Edit                    405
#define IDC_Pan_Slider                  406
#define IDC_Pan_Auto                    407

#define IDC_Tilt_Label                  410
#define IDC_Tilt_Minimum                0
#define IDC_Tilt_Maximum                0
#define IDC_Tilt_Default                0
#define IDC_Tilt_Stepping               0
#define IDC_Tilt_Edit                   415
#define IDC_Tilt_Slider                 416
#define IDC_Tilt_Auto                   417

#define IDC_Roll_Label                  420
#define IDC_Roll_Minimum                0
#define IDC_Roll_Maximum                0
#define IDC_Roll_Default                0
#define IDC_Roll_Stepping               0
#define IDC_Roll_Edit                   425
#define IDC_Roll_Slider                 426
#define IDC_Roll_Auto                   427

#define IDC_Zoom_Label                  430
#define IDC_Zoom_Minimum                0
#define IDC_Zoom_Maximum                0
#define IDC_Zoom_Default                0
#define IDC_Zoom_Stepping               0
#define IDC_Zoom_Edit                   435
#define IDC_Zoom_Slider                 436
#define IDC_Zoom_Auto                   437

#define IDC_Exposure_Label              440
#define IDC_Exposure_Minimum            0
#define IDC_Exposure_Maximum            0
#define IDC_Exposure_Default            0
#define IDC_Exposure_Stepping           0
#define IDC_Exposure_Edit               445
#define IDC_Exposure_Slider             446
#define IDC_Exposure_Auto               447

#define IDC_Iris_Label                  450
#define IDC_Iris_Minimum                0
#define IDC_Iris_Maximum                0
#define IDC_Iris_Default                0
#define IDC_Iris_Stepping               0
#define IDC_Iris_Edit                   455
#define IDC_Iris_Slider                 456
#define IDC_Iris_Auto                   457

#define IDC_Focus_Label                 460
#define IDC_Focus_Minimum               0
#define IDC_Focus_Maximum               0
#define IDC_Focus_Default               0
#define IDC_Focus_Stepping              0
#define IDC_Focus_Edit                  465
#define IDC_Focus_Slider                466
#define IDC_Focus_Auto                  467

#define IDC_FlipVertical_Label          470
#define IDC_FlipVertical_Minimum        0
#define IDC_FlipVertical_Maximum        0
#define IDC_FlipVertical_Default        0
#define IDC_FlipVertical_Stepping       0
#define IDC_FlipVertical_Edit           475
#define IDC_FlipVertical_Slider         0
#define IDC_FlipVertical_Auto           0

#define IDC_FlipHorizontal_Label        480
#define IDC_FlipHorizontal_Minimum      0
#define IDC_FlipHorizontal_Maximum      0
#define IDC_FlipHorizontal_Default      0
#define IDC_FlipHorizontal_Stepping     0
#define IDC_FlipHorizontal_Edit         485
#define IDC_FlipHorizontal_Slider       0
#define IDC_FlipHorizontal_Auto         0

#define IDC_Brightness_Label            500
#define IDC_Brightness_Minimum          0
#define IDC_Brightness_Maximum          0
#define IDC_Brightness_Default          0
#define IDC_Brightness_Stepping         0
#define IDC_Brightness_Edit             505
#define IDC_Brightness_Slider           506
#define IDC_Brightness_Auto             507

#define IDC_Contrast_Label              510
#define IDC_Contrast_Minimum            0
#define IDC_Contrast_Maximum            0
#define IDC_Contrast_Default            0
#define IDC_Contrast_Stepping           0
#define IDC_Contrast_Edit               515
#define IDC_Contrast_Slider             516
#define IDC_Contrast_Auto               517

#define IDC_Hue_Label                   520
#define IDC_Hue_Minimum                 0
#define IDC_Hue_Maximum                 0
#define IDC_Hue_Default                 0
#define IDC_Hue_Stepping                0
#define IDC_Hue_Edit                    525
#define IDC_Hue_Slider                  526
#define IDC_Hue_Auto                    527

#define IDC_Saturation_Label            530
#define IDC_Saturation_Minimum          0
#define IDC_Saturation_Maximum          0
#define IDC_Saturation_Default          0
#define IDC_Saturation_Stepping         0
#define IDC_Saturation_Edit             535
#define IDC_Saturation_Slider           536
#define IDC_Saturation_Auto             537

#define IDC_Sharpness_Label             540
#define IDC_Sharpness_Minimum           0
#define IDC_Sharpness_Maximum           0
#define IDC_Sharpness_Default           0
#define IDC_Sharpness_Stepping          0
#define IDC_Sharpness_Edit              545
#define IDC_Sharpness_Slider            546
#define IDC_Sharpness_Auto              547

#define IDC_Gamma_Label                 550
#define IDC_Gamma_Minimum               0
#define IDC_Gamma_Maximum               0
#define IDC_Gamma_Default               0
#define IDC_Gamma_Stepping              0
#define IDC_Gamma_Edit                  555
#define IDC_Gamma_Slider                556
#define IDC_Gamma_Auto                  557

#define IDC_ColorEnable_Label           560
#define IDC_ColorEnable_Minimum         0
#define IDC_ColorEnable_Maximum         0
#define IDC_ColorEnable_Default         0
#define IDC_ColorEnable_Stepping        0
#define IDC_ColorEnable_Edit            565
#define IDC_ColorEnable_Slider          566
#define IDC_ColorEnable_Auto            567

#define IDC_WhiteBalance_Label          570
#define IDC_WhiteBalance_Minimum        0
#define IDC_WhiteBalance_Maximum        0
#define IDC_WhiteBalance_Default        0
#define IDC_WhiteBalance_Stepping       0
#define IDC_WhiteBalance_Edit           575
#define IDC_WhiteBalance_Slider         576
#define IDC_WhiteBalance_Auto           577

#define IDC_BacklightComp_Label         580
#define IDC_BacklightComp_Minimum       0
#define IDC_BacklightComp_Maximum       0
#define IDC_BacklightComp_Default       0
#define IDC_BacklightComp_Stepping      0
#define IDC_BacklightComp_Edit          585
#define IDC_BacklightComp_Slider        586
#define IDC_BacklightComp_Auto          587

#define IDC_Device_SourceDlg            600
#define IDC_Device_FormatDlg            601
#define IDC_Device_DisplayDlg           602
#define IDC_Capture_Mode                603
#define IDC_Overlay_Support             604
#define IDC_Device_Version              605
#define IDC_Device_Type                 606
#define IDC_Device_Selection            607

#define IDC_Record_Driver_Type          650
#define IDC_Playback_Driver_Type        651
#define IDC_DSound                      652
#define IDC_AGC                         653
#define IDC_AEC                         654
#define IDC_FullDuplex                  655
#define IDC_Playback_Device_Selection   656
#define IDC_Record_Device_Selection     657
#define IDC_Record_Source_Selection     658

#define IDC_Max_OutputBandwidth_Label       700
#define IDC_Max_OutputBandwidth_Minimum     701
#define IDC_Max_OutputBandwidth_Maximum     702
#define IDC_Max_OutputBandwidth_Default     703
#define IDC_Max_OutputBandwidth_Stepping    704
#define IDC_Max_OutputBandwidth_Edit        705
#define IDC_Max_OutputBandwidth_Slider      706
#define IDC_Max_OutputBandwidth_Meter       0
#define IDC_Max_OutputBandwidth_Actual      0

#define IDC_Max_InputBandwidth_Label        710
#define IDC_Max_InputBandwidth_Minimum      711
#define IDC_Max_InputBandwidth_Maximum      712
#define IDC_Max_InputBandwidth_Default      713
#define IDC_Max_InputBandwidth_Stepping     714
#define IDC_Max_InputBandwidth_Edit         715
#define IDC_Max_InputBandwidth_Slider       716
#define IDC_Max_InputBandwidth_Meter        0
#define IDC_Max_InputBandwidth_Actual       0

#define IDC_Max_CPULoad_Label            720
#define IDC_Max_CPULoad_Minimum          721
#define IDC_Max_CPULoad_Maximum          722
#define IDC_Max_CPULoad_Default          723
#define IDC_Max_CPULoad_Stepping         724
#define IDC_Max_CPULoad_Edit             725
#define IDC_Max_CPULoad_Slider           726
#define IDC_Max_CPULoad_Meter            0
#define IDC_Max_CPULoad_Actual           0

#define IDC_Curr_OutputBandwidth_Label       730
#define IDC_Curr_OutputBandwidth_Minimum     0
#define IDC_Curr_OutputBandwidth_Maximum     0
#define IDC_Curr_OutputBandwidth_Default     0
#define IDC_Curr_OutputBandwidth_Stepping    0
#define IDC_Curr_OutputBandwidth_Edit        0
#define IDC_Curr_OutputBandwidth_Slider      0
#define IDC_Curr_OutputBandwidth_Meter       737
#define IDC_Curr_OutputBandwidth_Actual      738

#define IDC_Curr_InputBandwidth_Label        740
#define IDC_Curr_InputBandwidth_Minimum      0
#define IDC_Curr_InputBandwidth_Maximum      0
#define IDC_Curr_InputBandwidth_Default      0
#define IDC_Curr_InputBandwidth_Stepping     0
#define IDC_Curr_InputBandwidth_Edit         0
#define IDC_Curr_InputBandwidth_Slider       0
#define IDC_Curr_InputBandwidth_Meter        747
#define IDC_Curr_InputBandwidth_Actual       748

#define IDC_Curr_CPULoad_Label            750
#define IDC_Curr_CPULoad_Minimum          0
#define IDC_Curr_CPULoad_Maximum          0
#define IDC_Curr_CPULoad_Default          0
#define IDC_Curr_CPULoad_Stepping         0
#define IDC_Curr_CPULoad_Edit             0
#define IDC_Curr_CPULoad_Slider           0
#define IDC_Curr_CPULoad_Meter            757
#define IDC_Curr_CPULoad_Actual           758

#define IDC_VideoOut_RTT_Label          800
#define IDC_VideoOut_RTT_Minimum        0
#define IDC_VideoOut_RTT_Maximum        0
#define IDC_VideoOut_RTT_Default        0
#define IDC_VideoOut_RTT_Stepping       0
#define IDC_VideoOut_RTT_Edit           0
#define IDC_VideoOut_RTT_Slider         0
#define IDC_VideoOut_RTT_Meter          807
#define IDC_VideoOut_RTT_Actual         808

#define IDC_VideoIn_RTT_Label           810
#define IDC_VideoIn_RTT_Minimum         0
#define IDC_VideoIn_RTT_Maximum         0
#define IDC_VideoIn_RTT_Default         0
#define IDC_VideoIn_RTT_Stepping        0
#define IDC_VideoIn_RTT_Edit            0
#define IDC_VideoIn_RTT_Slider          0
#define IDC_VideoIn_RTT_Meter           817
#define IDC_VideoIn_RTT_Actual          818

#define IDC_AudioOut_RTT_Label          820
#define IDC_AudioOut_RTT_Minimum        0
#define IDC_AudioOut_RTT_Maximum        0
#define IDC_AudioOut_RTT_Default        0
#define IDC_AudioOut_RTT_Stepping       0
#define IDC_AudioOut_RTT_Edit           0
#define IDC_AudioOut_RTT_Slider         0
#define IDC_AudioOut_RTT_Meter          827
#define IDC_AudioOut_RTT_Actual         828

#define IDC_AudioIn_RTT_Label           830
#define IDC_AudioIn_RTT_Minimum         0
#define IDC_AudioIn_RTT_Maximum         0
#define IDC_AudioIn_RTT_Default         0
#define IDC_AudioIn_RTT_Stepping        0
#define IDC_AudioIn_RTT_Edit            0
#define IDC_AudioIn_RTT_Slider          0
#define IDC_AudioIn_RTT_Meter           837
#define IDC_AudioIn_RTT_Actual          838

#define IDC_VideoOut_LossRate_Label     840
#define IDC_VideoOut_LossRate_Minimum   0
#define IDC_VideoOut_LossRate_Maximum   0
#define IDC_VideoOut_LossRate_Default   0
#define IDC_VideoOut_LossRate_Stepping  0
#define IDC_VideoOut_LossRate_Edit      0
#define IDC_VideoOut_LossRate_Slider    0
#define IDC_VideoOut_LossRate_Meter     847
#define IDC_VideoOut_LossRate_Actual    848

#define IDC_VideoIn_LossRate_Label      850
#define IDC_VideoIn_LossRate_Minimum    0
#define IDC_VideoIn_LossRate_Maximum    0
#define IDC_VideoIn_LossRate_Default    0
#define IDC_VideoIn_LossRate_Stepping   0
#define IDC_VideoIn_LossRate_Edit       0
#define IDC_VideoIn_LossRate_Slider     0
#define IDC_VideoIn_LossRate_Meter      857
#define IDC_VideoIn_LossRate_Actual     858

#define IDC_AudioOut_LossRate_Label     860
#define IDC_AudioOut_LossRate_Minimum   0
#define IDC_AudioOut_LossRate_Maximum   0
#define IDC_AudioOut_LossRate_Default   0
#define IDC_AudioOut_LossRate_Stepping  0
#define IDC_AudioOut_LossRate_Edit      0
#define IDC_AudioOut_LossRate_Slider    0
#define IDC_AudioOut_LossRate_Meter     867
#define IDC_AudioOut_LossRate_Actual    868

#define IDC_AudioIn_LossRate_Label      870
#define IDC_AudioIn_LossRate_Minimum    0
#define IDC_AudioIn_LossRate_Maximum    0
#define IDC_AudioIn_LossRate_Default    0
#define IDC_AudioIn_LossRate_Stepping   0
#define IDC_AudioIn_LossRate_Edit       0
#define IDC_AudioIn_LossRate_Slider     0
#define IDC_AudioIn_LossRate_Meter      877
#define IDC_AudioIn_LossRate_Actual     878

#define IDC_Audio_PlayoutDelay_Label    880
#define IDC_Audio_PlayoutDelay_Minimum  881
#define IDC_Audio_PlayoutDelay_Maximum  882
#define IDC_Audio_PlayoutDelay_Default  883
#define IDC_Audio_PlayoutDelay_Stepping 884
#define IDC_Audio_PlayoutDelay_Edit     885
#define IDC_Audio_PlayoutDelay_Slider   886
#define IDC_Audio_PlayoutDelay_Meter    0
#define IDC_Audio_PlayoutDelay_Actual   0

#define IDC_Video_PlayoutDelay_Label    890
#define IDC_Video_PlayoutDelay_Minimum  891
#define IDC_Video_PlayoutDelay_Maximum  892
#define IDC_Video_PlayoutDelay_Default  893
#define IDC_Video_PlayoutDelay_Stepping 894
#define IDC_Video_PlayoutDelay_Edit     895
#define IDC_Video_PlayoutDelay_Slider   896
#define IDC_Video_PlayoutDelay_Meter    0
#define IDC_Video_PlayoutDelay_Actual   0

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1010
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\test\t3out\systemp.h ===
/****************************************************************************
 *  @doc INTERNAL SYSTEMP
 *
 *  @module SystemP.h | Header file for the <c CSystemProperty>
 *    class used to implement a property page to test the TAPI control
 *    interface <i ITQualityControllerConfig>.
 ***************************************************************************/

#define NUM_SYSTEM_CONTROLS				6
#define IDC_Curr_OutputBandwidth		0
#define IDC_Curr_InputBandwidth			1
#define IDC_Curr_CPULoad				2
#define IDC_Max_OutputBandwidth			3
#define IDC_Max_InputBandwidth			4
#define IDC_Max_CPULoad					5

/****************************************************************************
 *  @doc INTERNAL CSYSTEMPCLASS
 *
 *  @class CSystemProperty | This class implements handling of a
 *    single net property in a property page.
 *
 *  @mdata int | CSystemProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata ITQualityControllerConfig* | CSystemProperty | m_pITQualityControllerConfig | Pointer
 *    to the <i ITQualityControllerConfig> interface.
***************************************************************************/
class CSystemProperty : public CPropertyEditor 
{
	public:
	CSystemProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty); //, ITQualityControllerConfig *pITQualityControllerConfig);
	~CSystemProperty ();

	// CPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();

	private:
//	ITQualityControllerConfig *m_pITQualityControllerConfig;
};

/****************************************************************************
 *  @doc INTERNAL CSYSTEMPCLASS
 *
 *  @class CSystemProperties | This class implements a property page
 *    to test the new TAPI control interface <i ITQualityControl>.
 *
 *  @mdata int | CSystemProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata ITQualityControllerConfig* | CSystemProperties | m_pITQualityControllerConfig | Pointer
 *    to the <i ITQualityControllerConfig> interface.
 *
 *  @mdata CSystemProperty* | CSystemProperties | m_Controls[NUM_SYSTEM_CONTROLS] | Array
 *    of capture properties.
***************************************************************************/
class CSystemProperties
{
	public:
	CSystemProperties();
	~CSystemProperties();

	HPROPSHEETPAGE OnCreate();

	HRESULT OnConnect(ITAddress *pITAddress);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();

	private:

	void SetDirty();

	BOOL						m_bInit;
	HWND						m_hDlg;
	int							m_NumProperties;
//	ITQualityControllerConfig	*m_pITQualityControllerConfig;

	CSystemProperty *m_Controls[NUM_SYSTEM_CONTROLS];

	// Dialog proc
	static INT_PTR CALLBACK BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\test\t3out\systemp.cpp ===
/****************************************************************************
 *  @doc INTERNAL SYSTEMP
 *
 *  @module SystemP.cpp | Source file for the <c CSystemProperty>
 *    class used to implement a property page to test the TAPI control
 *    interface <i ITQualityControllerConfiglerConfig>.
 ***************************************************************************/

#include "Precomp.h"

extern HINSTANCE ghInst;

/****************************************************************************
 *  @doc INTERNAL CSYSTEMPMETHOD
 *
 *  @mfunc void | CSystemProperty | CSystemProperty | This
 *    method is the constructor for property objects. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    pointers to the <i ITQualityControllerConfig> interfaces.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm ITQualityControllerConfiglerConfig* | pITQualityControllerConfiglerConfig | Specifies a pointer to the
 *    <i ITQualityControllerConfiglerConfig> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CSystemProperty::CSystemProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty) //, ITStreamQualityControl *pITQualityControllerConfig)
: CPropertyEditor(hDlg, IDLabel, IDMinControl, IDMaxControl, IDDefaultControl, IDStepControl, IDEditControl, IDTrackbarControl, IDProgressControl, IDProperty, 0)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("CSystemProperty::CSystemProperty")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointers are NULL, we'll grey the
	// associated items in the property page
//	m_pITQualityControllerConfig = pITQualityControllerConfig;

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CSYSTEMPMETHOD
 *
 *  @mfunc void | CSystemProperty | ~CSystemProperty | This
 *    method is the destructor for property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CSystemProperty::~CSystemProperty()
{
	FX_ENTRY("CSystemProperty::~CSystemProperty")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CSYSTEMPMETHOD
 *
 *  @mfunc HRESULT | CSystemProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CSystemProperty::GetValue()
{
	HRESULT Hr = E_NOTIMPL;
	LONG CurrentValue;
	TAPIControlFlags CurrentFlag;
	LONG Mode;

	FX_ENTRY("CSystemProperty::GetValue")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));
/*
	switch (m_IDProperty)
	{									
		case IDC_Max_OutputBandwidth:
			if (m_pITQualityControllerConfig && SUCCEEDED (Hr = m_pITQualityControllerConfig->Get(QualityController_MaxApplicationOutputBandwidth, &m_CurrentValue, &CurrentFlag)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwMaxApplicationOutputBandwidth=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_Max_InputBandwidth:
			if (m_pITQualityControllerConfig && SUCCEEDED (Hr = m_pITQualityControllerConfig->Get(QualityController_MaxApplicationInputBandwidth, &m_CurrentValue, &CurrentFlag)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwMaxApplicationInputBandwidth=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_Max_CPULoad:
			if (m_pITQualityControllerConfig && SUCCEEDED (Hr = m_pITQualityControllerConfig->Get(QualityController_MaxSystemCPULoad, &m_CurrentValue, &CurrentFlag)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwMaxSystemCPULoad=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_Curr_OutputBandwidth:
			if (m_pITQualityControllerConfig && SUCCEEDED (Hr = m_pITQualityControllerConfig->Get(QualityController_CurrApplicationOutputBandwidth, &m_CurrentValue, &CurrentFlag)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwCurrApplicationOutputBandwidth=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_Curr_InputBandwidth:
			if (m_pITQualityControllerConfig && SUCCEEDED (Hr = m_pITQualityControllerConfig->Get(QualityController_CurrApplicationInputBandwidth, &m_CurrentValue, &CurrentFlag)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwCurrApplicationInputBandwidth=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_Curr_CPULoad:
			if (m_pITQualityControllerConfig && SUCCEEDED (Hr = m_pITQualityControllerConfig->Get(QualityController_CurrSystemCPULoad, &m_CurrentValue, &CurrentFlag)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwCurrSystemCPULoad=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;

		default:
			Hr = E_UNEXPECTED;
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Unknown property"), _fx_));
	}
*/
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CSYSTEMPMETHOD
 *
 *  @mfunc HRESULT | CSystemProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CSystemProperty::SetValue()
{
	HRESULT Hr = E_NOTIMPL;
	LONG CurrentValue;

	FX_ENTRY("CSystemProperty::SetValue")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));
/*
	switch (m_IDProperty)
	{
		case IDC_Max_OutputBandwidth:
			if (m_pITQualityControllerConfig && SUCCEEDED (Hr = m_pITQualityControllerConfig->Set(QualityController_MaxApplicationOutputBandwidth, m_CurrentValue, TAPIControl_Flags_None)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: dwMaxApplicationOutputBandwidth=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_Max_InputBandwidth:
			if (m_pITQualityControllerConfig && SUCCEEDED (Hr = m_pITQualityControllerConfig->Set(QualityController_MaxApplicationInputBandwidth, m_CurrentValue, TAPIControl_Flags_None)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: dwMaxApplicationInputBandwidth=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_Max_CPULoad:
			if (m_pITQualityControllerConfig && SUCCEEDED (Hr = m_pITQualityControllerConfig->Set(QualityController_MaxSystemCPULoad, m_CurrentValue, TAPIControl_Flags_None)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwMaxSystemCPULoad=%ld"), _fx_, m_CurrentValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_Curr_OutputBandwidth:
		case IDC_Curr_InputBandwidth:
		case IDC_Curr_CPULoad:
			// This is a read-only property. Don't do anything.
			Hr = NOERROR;
			break;
		default:
			Hr = E_UNEXPECTED;
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Unknown property"), _fx_));
	}
*/
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CSYSTEMPMETHOD
 *
 *  @mfunc HRESULT | CSystemProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CSystemProperty::GetRange()
{
	HRESULT Hr = E_NOTIMPL;
	LONG Min;
	LONG Max;
	LONG SteppingDelta;
	LONG Default;
	TAPIControlFlags CapsFlags;

	FX_ENTRY("CSystemProperty::GetRange")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));
/*
	switch (m_IDProperty)
	{

		case IDC_Max_OutputBandwidth:
			if (m_pITQualityControllerConfig && SUCCEEDED (Hr = m_pITQualityControllerConfig->GetRange(QualityController_MaxApplicationOutputBandwidth, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, &m_CapsFlags)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_Max_InputBandwidth:
			if (m_pITQualityControllerConfig && SUCCEEDED (Hr = m_pITQualityControllerConfig->GetRange(QualityController_MaxApplicationInputBandwidth, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, &m_CapsFlags)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_Max_CPULoad:
			if (m_pITQualityControllerConfig && SUCCEEDED (Hr = m_pITQualityControllerConfig->GetRange(QualityController_MaxSystemCPULoad, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, &m_CapsFlags)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_Curr_OutputBandwidth:
			if (m_pITQualityControllerConfig && SUCCEEDED (Hr = m_pITQualityControllerConfig->GetRange(QualityController_CurrApplicationOutputBandwidth, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, &m_CapsFlags)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_Curr_InputBandwidth:
			if (m_pITQualityControllerConfig && SUCCEEDED (Hr = m_pITQualityControllerConfig->GetRange(QualityController_CurrApplicationInputBandwidth, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, &m_CapsFlags)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;
		case IDC_Curr_CPULoad:
			if (m_pITQualityControllerConfig && SUCCEEDED (Hr = m_pITQualityControllerConfig->GetRange(QualityController_CurrSystemCPULoad, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, &m_CapsFlags)))
			{
				DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld"), _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
			}
			break;

		default:
			Hr = E_UNEXPECTED;
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Unknown property"), _fx_));
	}
*/
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CSYSTEMPMETHOD
 *
 *  @mfunc HPROPSHEETPAGE | CSystemProperties | OnCreate | This
 *    method creates a new page for a property sheet.
 *
 *  @rdesc Returns the handle to the new property sheet if successful, or
 *    NULL otherwise.
 ***************************************************************************/
HPROPSHEETPAGE CSystemProperties::OnCreate()
{
    PROPSHEETPAGE psp;
    
	psp.dwSize        = sizeof(psp);
    psp.dwFlags       = PSP_USEREFPARENT;
    psp.hInstance     = ghInst;
    psp.pszTemplate   = MAKEINTRESOURCE(IDD_SystemProperties);
    psp.pfnDlgProc    = BaseDlgProc;
    psp.pcRefParent   = 0;
    psp.pfnCallback   = (LPFNPSPCALLBACK)NULL;
    psp.lParam        = (LPARAM)this;

    return CreatePropertySheetPage(&psp);
}

/****************************************************************************
 *  @doc INTERNAL CSYSTEMPMETHOD
 *
 *  @mfunc void | CSystemProperties | CSystemProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CSystemProperties::CSystemProperties()
{
	FX_ENTRY("CSystemProperties::CSystemProperties")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

//	m_pITQualityControllerConfig = NULL;
	m_NumProperties = NUM_SYSTEM_CONTROLS;
	m_hDlg = NULL;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CSYSTEMPMETHOD
 *
 *  @mfunc void | CSystemProperties | ~CSystemProperties | This
 *    method is the destructor for the property page. It simply deletes all
 *    the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CSystemProperties::~CSystemProperties()
{
	int		j;

	FX_ENTRY("CSystemProperties::~CSystemProperties")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX"), _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: control already freed"), _fx_));
		}
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CSYSTEMPMETHOD
 *
 *  @mfunc HRESULT | CSystemProperties | OnConnect | This
 *    method is called when the property page is connected to a TAPI object.
 *
 *  @parm ITStream* | pStream | Specifies a pointer to the <i ITStream>
 *    interface. It is used to QI for the <i ITQualityControllerConfig> and
 *    <i ITFormatControl> interfaces.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CSystemProperties::OnConnect(ITAddress *pITAddress)
{
	FX_ENTRY("CSystemProperties::OnConnect")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Get the quality control interfaces
/*
	if (pITAddress && SUCCEEDED (pITAddress->QueryInterface(__uuidof(ITQualityControllerConfig), (void **)&m_pITQualityControllerConfig)))
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_pITQualityControllerConfig=0x%08lX"), _fx_, m_pITQualityControllerConfig));
	}
	else
	{
		m_pITQualityControllerConfig = NULL;
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: Failed Hr=0x%08lX"), _fx_, Hr));
	}
*/
	// It's Ok if we couldn't get interface pointers
	// We'll just grey the controls in the property page
	// to make it clear to the user that they can't
	// control those properties on the capture device

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CSYSTEMPMETHOD
 *
 *  @mfunc HRESULT | CSystemProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CSystemProperties::OnDisconnect()
{
	FX_ENTRY("CSystemProperties::OnDisconnect")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Validate input parameters
/*
	if (!m_pITQualityControllerConfig)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pITQualityControllerConfig->Release();
		m_pITQualityControllerConfig = NULL;
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: releasing m_pITQualityControllerConfig"), _fx_));
	}
*/
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CSYSTEMPMETHOD
 *
 *  @mfunc HRESULT | CSystemProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CSystemProperties::OnActivate()
{
	HRESULT	Hr = E_OUTOFMEMORY;
	int		j;

	FX_ENTRY("CSystemProperties::OnActivate")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Create the controls for the properties
/*
	if (!(m_Controls[IDC_Curr_OutputBandwidth] = new CSystemProperty(m_hDlg, IDC_Curr_OutputBandwidth_Label, IDC_Curr_OutputBandwidth_Minimum, IDC_Curr_OutputBandwidth_Maximum, IDC_Curr_OutputBandwidth_Default, IDC_Curr_OutputBandwidth_Stepping, IDC_Curr_OutputBandwidth_Actual, IDC_Curr_OutputBandwidth_Slider, IDC_Curr_OutputBandwidth_Meter, IDC_Curr_OutputBandwidth, m_pITQualityControllerConfig)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[IDC_Curr_OutputBandwidth] failed - Out of memory"), _fx_));
		goto MyExit;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[IDC_Curr_OutputBandwidth]=0x%08lX"), _fx_, m_Controls[IDC_Curr_OutputBandwidth]));
	}

	if (!(m_Controls[IDC_Curr_InputBandwidth] = new CSystemProperty(m_hDlg, IDC_Curr_InputBandwidth_Label, IDC_Curr_InputBandwidth_Minimum, IDC_Curr_InputBandwidth_Maximum, IDC_Curr_InputBandwidth_Default, IDC_Curr_InputBandwidth_Stepping, IDC_Curr_InputBandwidth_Actual, IDC_Curr_InputBandwidth_Slider, IDC_Curr_InputBandwidth_Meter, IDC_Curr_InputBandwidth, m_pITQualityControllerConfig)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[IDC_Curr_InputBandwidth] failed - Out of memory"), _fx_));
		goto MyError0;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[IDC_Curr_InputBandwidth]=0x%08lX"), _fx_, m_Controls[IDC_Curr_InputBandwidth]));
	}

	if (!(m_Controls[IDC_Curr_CPULoad] = new CSystemProperty(m_hDlg, IDC_Curr_CPULoad_Label, IDC_Curr_CPULoad_Minimum, IDC_Curr_CPULoad_Maximum, IDC_Curr_CPULoad_Default, IDC_Curr_CPULoad_Stepping, IDC_Curr_CPULoad_Actual, IDC_Curr_CPULoad_Slider, IDC_Curr_CPULoad_Meter, IDC_Curr_CPULoad, m_pITQualityControllerConfig)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[IDC_Curr_CPULoad] failed - Out of memory"), _fx_));
		goto MyError1;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[IDC_Curr_CPULoad]=0x%08lX"), _fx_, m_Controls[IDC_Curr_CPULoad]));
	}

	if (!(m_Controls[IDC_Max_OutputBandwidth] = new CSystemProperty(m_hDlg, IDC_Max_OutputBandwidth_Label, IDC_Max_OutputBandwidth_Minimum, IDC_Max_OutputBandwidth_Maximum, IDC_Max_OutputBandwidth_Default, IDC_Max_OutputBandwidth_Stepping, IDC_Max_OutputBandwidth_Actual, IDC_Max_OutputBandwidth_Slider, IDC_Max_OutputBandwidth_Meter, IDC_Max_OutputBandwidth, m_pITQualityControllerConfig)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[IDC_Max_OutputBandwidth] failed - Out of memory"), _fx_));
		goto MyError2;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[IDC_Max_OutputBandwidth]=0x%08lX"), _fx_, m_Controls[IDC_Max_OutputBandwidth]));
	}

	if (!(m_Controls[IDC_Max_InputBandwidth] = new CSystemProperty(m_hDlg, IDC_Max_InputBandwidth_Label, IDC_Max_InputBandwidth_Minimum, IDC_Max_InputBandwidth_Maximum, IDC_Max_InputBandwidth_Default, IDC_Max_InputBandwidth_Stepping, IDC_Max_InputBandwidth_Actual, IDC_Max_InputBandwidth_Slider, IDC_Max_InputBandwidth_Meter, IDC_Max_InputBandwidth, m_pITQualityControllerConfig)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[IDC_Max_InputBandwidth] failed - Out of memory"), _fx_));
		goto MyError3;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[IDC_Max_InputBandwidth]=0x%08lX"), _fx_, m_Controls[IDC_Max_InputBandwidth]));
	}

	if (!(m_Controls[IDC_Max_CPULoad] = new CSystemProperty(m_hDlg, IDC_Max_CPULoad_Label, IDC_Max_CPULoad_Minimum, IDC_Max_CPULoad_Maximum, IDC_Max_CPULoad_Default, IDC_Max_CPULoad_Stepping, IDC_Max_CPULoad_Actual, IDC_Max_CPULoad_Slider, IDC_Max_CPULoad_Meter, IDC_Max_CPULoad, m_pITQualityControllerConfig)))
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: mew m_Controls[IDC_Max_CPULoad] failed - Out of memory"), _fx_));
		goto MyError4;
	}
	else
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[IDC_Max_CPULoad]=0x%08lX"), _fx_, m_Controls[IDC_Max_CPULoad]));
	}

	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the device. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j]->Init())
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_Controls[%ld]->Init()"), _fx_, j));
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: m_Controls[%ld]->Init() failed"), _fx_, j));
		}
	}

	Hr = NOERROR;
	goto MyExit;

MyError4:
	if (m_Controls[IDC_Max_InputBandwidth])
		delete m_Controls[IDC_Max_InputBandwidth], m_Controls[IDC_Max_InputBandwidth] = NULL;
MyError3:
	if (m_Controls[IDC_Max_OutputBandwidth])
		delete m_Controls[IDC_Max_OutputBandwidth], m_Controls[IDC_Max_OutputBandwidth] = NULL;
MyError2:
	if (m_Controls[IDC_Curr_CPULoad])
		delete m_Controls[IDC_Curr_CPULoad], m_Controls[IDC_Curr_CPULoad] = NULL;
MyError1:
	if (m_Controls[IDC_Curr_InputBandwidth])
		delete m_Controls[IDC_Curr_InputBandwidth], m_Controls[IDC_Curr_InputBandwidth] = NULL;
MyError0:
	if (m_Controls[IDC_Curr_OutputBandwidth])
		delete m_Controls[IDC_Curr_OutputBandwidth], m_Controls[IDC_Curr_OutputBandwidth] = NULL;
MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
*/
    return S_OK;
}

/****************************************************************************
 *  @doc INTERNAL CSYSTEMPMETHOD
 *
 *  @mfunc HRESULT | CSystemProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CSystemProperties::OnDeactivate()
{
	int	j;

	FX_ENTRY("CSystemProperties::OnDeactivate")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX"), _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: control already freed"), _fx_));
		}
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CSYSTEMPMETHOD
 *
 *  @mfunc HRESULT | CSystemProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CSystemProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;

	FX_ENTRY("CSystemProperties::OnApplyChanges")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	for (int j = IDC_Max_OutputBandwidth; j < IDC_Max_CPULoad; j++)
	{
		if (m_Controls[j])
		{
			DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: calling m_Controls[%ld]=0x%08lX->OnApply"), _fx_, j, m_Controls[j]));
			if (m_Controls[j]->HasChanged())
				m_Controls[j]->OnApply();
			Hr = NOERROR;
		}
		else
		{
			DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: can't calling m_Controls[%ld]=NULL->OnApply"), _fx_, j));
			Hr = E_UNEXPECTED;
		}
	}

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CSYSTEMPMETHOD
 *
 *  @mfunc BOOL | CSystemProperties | BaseDlgProc | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
INT_PTR CALLBACK CSystemProperties::BaseDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
    CSystemProperties *pSV = (CSystemProperties*)GetWindowLong(hDlg, DWL_USER);

	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
        case WM_INITDIALOG:
			{
				LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)lParam;
				pSV = (CSystemProperties*)psp->lParam;
				pSV->m_hDlg = hDlg;
				SetWindowLong(hDlg, DWL_USER, (LPARAM)pSV);
				pSV->m_bInit = FALSE;
				//pSV->OnActivate();
				//pSV->m_bInit = TRUE;
				return TRUE;
			}
			break;

		case WM_TIMER:
			if (pSV && pSV->m_bInit)
			{
				// Update the Vu-Meters
				for (j = IDC_Curr_OutputBandwidth; j < IDC_Curr_CPULoad; j++)
				{
					if (pSV->m_Controls[j]->GetProgressHWnd())
					{
						pSV->m_Controls[j]->UpdateProgress();
						pSV->SetDirty();
					}
				}
			}
			break;

		case WM_HSCROLL:
		case WM_VSCROLL:
            if (pSV && pSV->m_bInit)
            {
				// Process all of the Trackbar messages
				for (j = IDC_Max_OutputBandwidth; j < IDC_Max_CPULoad; j++)
				{
					if (pSV->m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
					{
						pSV->m_Controls[j]->OnScroll(uMsg, wParam, lParam);
						pSV->SetDirty();
					}
				}
				//pSV->OnApplyChanges();
			}
			break;

		case WM_COMMAND:
            if (pSV && pSV->m_bInit)
            {
				// Process all of the auto checkbox messages
				for (j = 0; j < pSV->m_NumProperties; j++)
				{
					if (pSV->m_Controls[j] && pSV->m_Controls[j]->GetAutoHWnd() == (HWND)lParam)
					{
						pSV->m_Controls[j]->OnAuto(uMsg, wParam, lParam);
						pSV->SetDirty();
						break;
					}
				}

				// Process all of the edit box messages
				for (j = 0; j < pSV->m_NumProperties; j++)
				{
					if (pSV->m_Controls[j] && pSV->m_Controls[j]->GetEditHWnd() == (HWND)lParam)
					{
						pSV->m_Controls[j]->OnEdit(uMsg, wParam, lParam);
						pSV->SetDirty();
						break;
					}
				}

				switch (LOWORD(wParam))
				{
					case IDC_CONTROL_DEFAULT:
						for (j = IDC_Max_OutputBandwidth; j < IDC_Max_CPULoad; j++)
						{
							if (pSV->m_Controls[j])
								pSV->m_Controls[j]->OnDefault();
						}
						break;

					default:
						break;
				}

				//pSV->OnApplyChanges();
			}
			break;

        case WM_NOTIFY:
			if (pSV)
			{
				switch (((NMHDR FAR *)lParam)->code)
				{
					case PSN_SETACTIVE:
						{
							// We call out here specially so we can mark this page as having been init'd.
							int iRet = pSV->OnActivate();
							pSV->m_bInit = TRUE;
							return iRet;
						}
						break;

					case PSN_APPLY:
						pSV->OnApplyChanges();
						break;

					case PSN_QUERYCANCEL:    
						// return pSV->QueryCancel();
						break;

					default:
						break;
				}
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CSYSTEMPMETHOD
 *
 *  @mfunc BOOL | CSystemProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void CSystemProperties::SetDirty()
{
	PropSheet_Changed(GetParent(m_hDlg), m_hDlg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\tsp\confdbg.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name

    confdbg.h

Description

    Defines functions used for debugging

Note

    Revised based on msplog.h by

    Qianbo Huai (qhuai) Apr 5 2000

--*/

#ifndef _CONFDBG_H
#define _CONFDBG_H

    #include <rtutils.h>

    #define FAIL ((DWORD)0x00010000 | TRACE_USE_MASK)
    #define WARN ((DWORD)0x00020000 | TRACE_USE_MASK)
    #define INFO ((DWORD)0x00040000 | TRACE_USE_MASK)
    #define TRCE ((DWORD)0x00080000 | TRACE_USE_MASK)
    #define ELSE ((DWORD)0x00100000 | TRACE_USE_MASK)

    BOOL DBGRegister(LPCTSTR szName);
    void DBGDeRegister();
    void DBGPrint(DWORD dwDbgLevel, LPCSTR DbgMessage, ...);

#ifdef TSPLOG

    #define DBGREGISTER(arg) DBGRegister(arg)
    #define DBGDEREGISTER() DBGDeRegister()
    #define DBGOUT(arg) DBGPrint arg

#else

    #define DBGREGISTER(arg)
    #define DBGDEREGISTER()
    #define DBGOUT(arg)

#endif // TSPLOG

#endif // _CONFDBG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\tsp\confdbg.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name

    confdbg.h

Description

    Defines functions used for debugging

Note

    Revised based on msplog.h by

    Qianbo Huai (qhuai) Apr 5 2000

--*/

#include "stdafx.h"
#include <stdio.h>
#include "confdbg.h"

#define MAXDEBUGSTRINGLENGTH 512

static DWORD   sg_dwTraceID = INVALID_TRACEID;

static char    sg_szTraceName[100];   // saves name of dll
static DWORD   sg_dwTracingToDebugger = 0;
static DWORD   sg_dwDebuggerMask      = 0;


BOOL DBGRegister(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szTracingEnableValue[] = "EnableDebuggerTracing";
    const char szTracingMaskValue[]   = "ConsoleTracingMask";

    sg_dwTracingToDebugger = 0;

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ,
                                        &hTracingKey) )
    {
		DWORD      dwDataSize = sizeof (DWORD);
		DWORD      dwDataType;

        RegQueryValueExA(hTracingKey,
                         szTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToDebugger,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szTracingMaskValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwDebuggerMask,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

#ifdef UNICODE
    wsprintfA(sg_szTraceName, "%ls", szName);
#else
    wsprintfA(sg_szTraceName, "%s", szName);
#endif

    sg_dwTraceID = TraceRegister(szName);

    return (sg_dwTraceID != INVALID_TRACEID);
}

void DBGDeRegister()
{
    sg_dwTracingToDebugger = 0;

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(sg_dwTraceID);
        sg_dwTraceID = INVALID_TRACEID;
    }
}


void DBGPrint(DWORD dwDbgLevel, LPCSTR lpszFormat, IN ...)
/*++

Routine Description:

    Formats the incoming debug message & calls TraceVprintfEx to print it.

Arguments:

    dwDbgLevel   - The type of the message.

    lpszFormat - printf-style format string, followed by appropriate
                 list of arguments

Return Value:

--*/
{
    static char * message[] = 
    {
        "ERROR", 
        "WARNING", 
        "INFO", 
        "TRACE", 
        "EVENT",
        "INVALID TRACE LEVEL"
    };

    char  szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];
    
    DWORD dwIndex;

    if ( ( sg_dwTracingToDebugger > 0 ) &&
         ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )
    {
        switch(dwDbgLevel)
        {
        case FAIL: dwIndex = 0; break;
        case WARN: dwIndex = 1; break;
        case INFO: dwIndex = 2; break;
        case TRCE: dwIndex = 3; break;
        case ELSE: dwIndex = 4; break;
        default:   dwIndex = 5; break;
        }

        // retrieve local time
        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);

        wsprintfA(szTraceBuf,
                  "%s:[%02u:%02u:%02u.%03u,tid=%x:]%s: ",
                  sg_szTraceName,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond,
                  SystemTime.wMilliseconds,
                  GetCurrentThreadId(), 
                  message[dwIndex]);

        va_list ap;
        va_start(ap, lpszFormat);

        _vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)], 
            MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf), 
            lpszFormat, 
            ap
            );

        lstrcatA (szTraceBuf, "\n");

        OutputDebugStringA (szTraceBuf);

        va_end(ap);
    }

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        switch(dwDbgLevel)
        {
        case FAIL: dwIndex = 0; break;
        case WARN: dwIndex = 1; break;
        case INFO: dwIndex = 2; break;
        case TRCE: dwIndex = 3; break;
        case ELSE: dwIndex = 4; break;
        default:   dwIndex = 5; break;
        }

        wsprintfA(szTraceBuf, "[%s] %s", message[dwIndex], lpszFormat);

        va_list arglist;
        va_start(arglist, lpszFormat);
        TraceVprintfExA(sg_dwTraceID, dwDbgLevel, szTraceBuf, arglist);
        va_end(arglist);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\test\t3out\vdevicep.cpp ===
/****************************************************************************
 *  @doc INTERNAL VDEVICEP
 *
 *  @module VDeviceP.cpp | Source file for the <c CVDeviceProperties>
 *    class used to implement a property page to test the <i ITVfwCaptureDialogs>,
 *    as well as <i ITAddress> and <ITStream> interfaces to select video
 *    capture devices.
 ***************************************************************************/

#include "Precomp.h"

extern HINSTANCE ghInst;

/****************************************************************************
 *  @doc INTERNAL CVDEVICEPMETHOD
 *
 *  @mfunc HPROPSHEETPAGE | CVDeviceProperties | OnCreate | This
 *    method creates a new page for a property sheet.
 *
 *  @rdesc Returns the handle to the new property sheet if successful, or
 *    NULL otherwise.
 ***************************************************************************/
HPROPSHEETPAGE CVDeviceProperties::OnCreate()
{
    PROPSHEETPAGE psp;
    
	psp.dwSize        = sizeof(psp);
    psp.dwFlags       = PSP_USEREFPARENT;
    psp.hInstance     = ghInst;
    psp.pszTemplate   = MAKEINTRESOURCE(IDD_CaptureDeviceProperties);
    psp.pfnDlgProc    = BaseDlgProc;
    psp.pcRefParent   = 0;
    psp.pfnCallback   = (LPFNPSPCALLBACK)NULL;
    psp.lParam        = (LPARAM)this;

    return CreatePropertySheetPage(&psp);
}

/****************************************************************************
 *  @doc INTERNAL CVDEVICEPMETHOD
 *
 *  @mfunc void | CVDeviceProperties | CVDeviceProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CVDeviceProperties::CVDeviceProperties()
{
	FX_ENTRY("CVDeviceProperties::CVDeviceProperties")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

#if USE_VFW
	m_pITVfwCaptureDialogs = NULL;
#endif

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CVDEVICEPMETHOD
 *
 *  @mfunc void | CVDeviceProperties | ~CVDeviceProperties | This
 *    method is the destructor for capture device property page. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CVDeviceProperties::~CVDeviceProperties()
{
	FX_ENTRY("CVDeviceProperties::~CVDeviceProperties")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CVDEVICEPMETHOD
 *
 *  @mfunc HRESULT | CVDeviceProperties | OnConnect | This
 *    method is called when the property page is connected to a TAPI object.
 *
 *  @parm ITTerminal* | pITTerminal | Specifies a pointer to the <i ITTerminal>
 *    interface used to identify the capture device.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CVDeviceProperties::OnConnect(ITTerminal *pITTerminal)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CVDeviceProperties::OnConnect")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

	// Validate input parameters
	if (!pITTerminal)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: invalid input parameter"), _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

#if USE_VFW
	// Get the video VfW capture device interface
	if (SUCCEEDED (Hr = pITTerminal->QueryInterface(&m_pITVfwCaptureDialogs)))
	{
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: m_pITVfwCaptureDialogs=0x%08lX"), _fx_, m_pITVfwCaptureDialogs));
	}
	else
	{
		m_pITVfwCaptureDialogs = NULL;
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   ERROR: IOCTL failed Hr=0x%08lX"), _fx_, Hr));
	}
#endif

MyExit:
	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVDEVICEPMETHOD
 *
 *  @mfunc HRESULT | CVDeviceProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CVDeviceProperties::OnDisconnect()
{
	FX_ENTRY("CVDeviceProperties::OnDisconnect")

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: begin"), _fx_));

#if USE_VFW
	// Make sure the interface pointer is still valid
	if (!m_pITVfwCaptureDialogs)
	{
		DbgLog((LOG_ERROR, DBG_LEVEL_TRACE_FAILURES, TEXT("%s:   WARNING: already disconnected!"), _fx_));
	}
	else
	{
		// Release the interface
		m_pITVfwCaptureDialogs->Release();
		m_pITVfwCaptureDialogs = NULL;
		DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s:   SUCCESS: releasing m_pITVfwCaptureDialogs"), _fx_));
	}
#endif 

	DbgLog((LOG_TRACE, DBG_LEVEL_TRACE_DETAILS, TEXT("%s: end"), _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CVDEVICEPMETHOD
 *
 *  @mfunc BOOL | CVDeviceProperties | BaseDlgProc | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
INT_PTR CALLBACK CVDeviceProperties::BaseDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
    CVDeviceProperties *pSV = (CVDeviceProperties*)GetWindowLong(hDlg, DWL_USER);

	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
        case WM_INITDIALOG:
			{
				LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE)lParam;
				pSV = (CVDeviceProperties*)psp->lParam;
				pSV->m_hDlg = hDlg;
				SetWindowLong(hDlg, DWL_USER, (LPARAM)pSV);
				pSV->m_bInit = FALSE;
#if USE_VFW
				EnableWindow(GetDlgItem(hDlg, IDC_Device_SourceDlg), (BOOL)(pSV->m_pITVfwCaptureDialogs && pSV->m_pITVfwCaptureDialogs->HasDialog(VfwCaptureDialog_Source) == S_OK));
				EnableWindow(GetDlgItem(hDlg, IDC_Device_FormatDlg), (BOOL)(pSV->m_pITVfwCaptureDialogs && pSV->m_pITVfwCaptureDialogs->HasDialog(VfwCaptureDialog_Format) == S_OK));
				EnableWindow(GetDlgItem(hDlg, IDC_Device_DisplayDlg), (BOOL)(pSV->m_pITVfwCaptureDialogs && pSV->m_pITVfwCaptureDialogs->HasDialog(VfwCaptureDialog_Display) == S_OK));
#endif

				// Put some code here to enumerate the terminals and populate the dialog box

				EnableWindow(GetDlgItem(hDlg, IDC_Device_Selection), FALSE);
				EnableWindow(GetDlgItem(hDlg, IDC_CONTROL_DEFAULT), FALSE);
				pSV->m_bInit = TRUE;
				return TRUE;
			}
			break;

		case WM_COMMAND:
            if (pSV && pSV->m_bInit)
            {
				switch (LOWORD(wParam))
				{
#if USE_VFW
					case IDC_Device_SourceDlg:
						if (pSV->m_pITVfwCaptureDialogs)
							pSV->m_pITVfwCaptureDialogs->ShowDialog(VfwCaptureDialog_Source, hDlg);
						break;

					case IDC_Device_FormatDlg:
						if (pSV->m_pITVfwCaptureDialogs)
							pSV->m_pITVfwCaptureDialogs->ShowDialog(VfwCaptureDialog_Format, hDlg);
						break;

					case IDC_Device_DisplayDlg:
						if (pSV->m_pITVfwCaptureDialogs)
							pSV->m_pITVfwCaptureDialogs->ShowDialog(VfwCaptureDialog_Display, hDlg);
						break;
#endif

					case IDC_Device_Selection:
						if (HIWORD(wParam) == CBN_SELCHANGE)
						{
							// Put some code to select a new terminal on the stream

							PropSheet_Changed(GetParent(hDlg), hDlg);
						}
						break;

					default:
						break;
				}
			}

		default:
			return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\tsp\conftsp.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

     sdpsp.cpp

Abstract:

    This module contains a multicast conference service provider for TAPI3.0. 
    It is first designed and implemented in c. Later, in order to use the SDP
    parser, which is written in C++, this file is changed to cpp. It still 
    uses only c features except the lines that uses the parser.

Author:
    
    Mu Han (muhan)   26-March-1997

--*/


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include <initguid.h>
#include <confpdu.h>
#include "resource.h"
#include "conftsp.h"
#include "confdbg.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static WCHAR gszUIDLLName[] = L"IPCONF.TSP";

//
// Some data used in talking with TAPI.
//
HPROVIDER           ghProvider;
DWORD               gdwPermanentProviderID;
DWORD               gdwLineDeviceIDBase;

// The handle of this dll.
extern "C" 
{
    HINSTANCE       g_hInstance;
}

//
// This function is called if the completion of the process will be sent
// as an asynchrous event. Set in TSPI_ProviderInit.
//
ASYNC_COMPLETION    glpfnCompletionProc; 

//
// Notify tapi about events in the provider. Set in TSPI_LineOpen. 
//
LINEEVENT           glpfnLineEventProc;

// This service provider has only one line.
LINE                gLine;

// Calls are stored in an array of structures. The array will grow as needed.
CCallList           gpCallList;
DWORD               gdwNumCallsInUse    = 0;

// The critical section the protects the global variables.
CRITICAL_SECTION    gCritSec;

#if 0 // we dont' need the user name anymore.
// The name of the user.    
CHAR                gszUserName[MAXUSERNAMELEN + 1];
#endif


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Functiion definitions for the call object.                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD CALL::Init(
    HTAPICALL           htCall,
    LPLINECALLPARAMS    const lpCallParams
    )
{
    m_htCall        = htCall;
    m_dwState       = LINECALLSTATE_IDLE;
    m_dwStateMode   = 0;
    m_dwMediaMode   = IPCONF_MEDIAMODES;
    m_dwAudioQOSLevel  = LINEQOSSERVICELEVEL_IFAVAILABLE;
    m_dwVideoQOSLevel  = LINEQOSSERVICELEVEL_IFAVAILABLE;
//    m_dwAudioQOSLevel  = LINEQOSSERVICELEVEL_BESTEFFORT;
//    m_dwVideoQOSLevel  = LINEQOSSERVICELEVEL_BESTEFFORT;

    if (!lpCallParams)
    {
        return NOERROR;
    }

    // set my media modes.
    m_dwMediaMode = lpCallParams->dwMediaMode;

    if (lpCallParams->dwReceivingFlowspecOffset == 0)
    {
        // No QOS policy specified.
        DBGOUT((WARN, "no qos level request."));
        return NOERROR;
    }

    // get the QOS policy requirements.
    LPLINECALLQOSINFO pQOSInfo = (LPLINECALLQOSINFO)
        (((LPBYTE)lpCallParams) + lpCallParams->dwReceivingFlowspecOffset);
    
    ASSERT(pQOSInfo->dwKey == LINEQOSSTRUCT_KEY);

    // find out if this is a QOS level request.
    if (pQOSInfo->dwQOSRequestType != LINEQOSREQUESTTYPE_SERVICELEVEL)
    {
        // It is not a request for qos service level.
        DBGOUT((WARN, "wrong qos request type."));
        return NOERROR;
    }

    DWORD dwCount = pQOSInfo->SetQOSServiceLevel.dwNumServiceLevelEntries;
    for (DWORD i = 0; i < dwCount; i ++)
    {
        LINEQOSSERVICELEVEL &QOSLevel = 
            pQOSInfo->SetQOSServiceLevel.LineQOSServiceLevel[i];

        switch (QOSLevel.dwMediaMode)
        {
        case LINEMEDIAMODE_VIDEO:
            m_dwVideoQOSLevel  = QOSLevel.dwQOSServiceLevel;
            break;

        case LINEMEDIAMODE_INTERACTIVEVOICE:
        case LINEMEDIAMODE_AUTOMATEDVOICE:
            m_dwAudioQOSLevel  = QOSLevel.dwQOSServiceLevel;
            break;

        default:
            DBGOUT((WARN, "Unknown mediamode for QOS, %x", dwMediaMode));
            break;
        }
    }

    return NOERROR;
}

void CALL::SetCallState(
    DWORD   dwCallState,
    DWORD   dwCallStateMode
    )
{
    if (m_dwState != dwCallState)
    {
        m_dwState     = dwCallState;
        m_dwStateMode = dwCallStateMode;

        (*glpfnLineEventProc)(
            gLine.htLine,
            m_htCall,
            LINE_CALLSTATE,
            m_dwState,
            m_dwStateMode,
            m_dwMediaMode
            );
        DBGOUT((INFO, "sending event to htCall: %x", m_htCall));
    }
}

DWORD CALL::SendMSPStartMessage(LPCWSTR lpszDestAddress)
{
    DWORD dwStrLen = lstrlenW(lpszDestAddress);
    DWORD dwSize = sizeof(MSG_TSPMSPDATA) + dwStrLen * sizeof(WCHAR);

    MSG_TSPMSPDATA *pData = (MSG_TSPMSPDATA *)MemAlloc(dwSize);

    if (pData == NULL)
    {
        DBGOUT((FAIL, "No memory for the TSPMSP data, size: %d", dwSize));
        return LINEERR_NOMEM;
    }

    pData->command = CALL_START;

    pData->CallStart.dwAudioQOSLevel = m_dwAudioQOSLevel;
    pData->CallStart.dwVideoQOSLevel = m_dwVideoQOSLevel;
    pData->CallStart.dwSDPLen = dwStrLen;
    lstrcpyW(pData->CallStart.szSDP, lpszDestAddress);

    DBGOUT((INFO, "Send MSP call Start message"));
    (*glpfnLineEventProc)(
        gLine.htLine,
        m_htCall,
        LINE_SENDMSPDATA,
        0,
        (ULONG_PTR)(pData),
        dwSize
        );

    MemFree(pData);

    return NOERROR;
}

DWORD CALL::SendMSPStopMessage()
{
    MSG_TSPMSPDATA Data;

    Data.command = CALL_STOP;

    DBGOUT((INFO, "Send MSP call Stop message"));
    (*glpfnLineEventProc)(
        gLine.htLine,
        m_htCall,
        LINE_SENDMSPDATA,
        0,
        (ULONG_PTR)(&Data),
        sizeof(MSG_TSPMSPDATA)
        );

    return NOERROR;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Functiion definitions                                             //
//                                                                           //
// Note: none of these functions uses critical sections operations inside.   //
//       The caller is responsible for critical sections.                    //
///////////////////////////////////////////////////////////////////////////////

LONG
CheckCallParams(
    LPLINECALLPARAMS    const lpCallParams
    )
{
    // validate pointer
    if (lpCallParams == NULL) 
    {
        return NOERROR;
    }

    // see if the address type is right 
    if (lpCallParams->dwAddressType != LINEADDRESSTYPE_SDP) 
    {
        DBGOUT((FAIL,
            "wrong address type 0x%08lx.\n", lpCallParams->dwAddressType
            ));
        return LINEERR_INVALADDRESSTYPE;
    }

    // see if we support call parameters
    if (lpCallParams->dwCallParamFlags != 0) 
    {
        DBGOUT((FAIL,
            "do not support call parameters 0x%08lx.\n",
            lpCallParams->dwCallParamFlags
            ));
        return LINEERR_INVALCALLPARAMS;
    }

    // see if we support media modes specified
    if (lpCallParams->dwMediaMode & ~IPCONF_MEDIAMODES) 
    {
        DBGOUT((FAIL,
            "do not support media modes 0x%08lx.\n",
             lpCallParams->dwMediaMode
             ));
        return LINEERR_INVALMEDIAMODE;
    }

    // see if we support bearer modes
    if (lpCallParams->dwBearerMode & ~IPCONF_BEARERMODES) 
    {
        DBGOUT((FAIL,
            "do not support bearer mode 0x%08lx.\n",
            lpCallParams->dwBearerMode
            ));
        return LINEERR_INVALBEARERMODE;
    }

    // see if we support address modes
    if (lpCallParams->dwAddressMode & ~IPCONF_ADDRESSMODES) 
    {
        DBGOUT((FAIL,
            "do not support address mode 0x%08lx.\n",
            lpCallParams->dwAddressMode
            ));
        return LINEERR_INVALADDRESSMODE;
    }
    
    // validate address id specified There is only one address per line
    if (lpCallParams->dwAddressID != 0) 
    {
        DBGOUT((FAIL,
            "address id 0x%08lx invalid.\n",
            lpCallParams->dwAddressID
            ));
        return LINEERR_INVALADDRESSID;
    }
    return NOERROR;
}

DWORD
FreeCall(DWORD hdCall)
/*++

Routine Description:

    Decrement the ref count on the call and release the call if the ref
    count gets 0.

Arguments:
    
    hdCall  - The handle of the call.

Return Value:
    
    NOERROR
--*/
{
    if (gpCallList[hdCall] == NULL)
    {
        return NOERROR;
    }

    DWORD dwLine = (DWORD)gpCallList[hdCall]->hdLine();

    MemFree(gpCallList[hdCall]);
    gpCallList[hdCall] = NULL;

    gdwNumCallsInUse --;
    gLine.dwNumCalls --;

    DBGOUT((INFO, "No.%d call was deleted.", hdCall));
    return NOERROR;
}

long FindFreeCallSlot(DWORD_PTR &hdCall)
{
    if (gdwNumCallsInUse < gpCallList.size())
    {
        for (DWORD i = 0; i < gpCallList.size(); i++)
        {
            if (gpCallList[i] == NULL)
            {
                hdCall = i;
                return TRUE;;
            }
        }
    }

    if (!gpCallList.add())
    {
        return FALSE;
    }

    hdCall = gpCallList.size() - 1;

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// DllMain definition                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
BOOL
WINAPI
DllMain(
    HINSTANCE   hDLL,
    DWORD       dwReason,
    LPVOID      lpReserved
   )
{
    DWORD i;
    DWORD dwUserNameLen = MAXUSERNAMELEN;

    HRESULT hr;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:

            DisableThreadLibraryCalls(hDLL);
            g_hInstance = hDLL;

#if 0 // we dont' need the user name anymore.
            // switch in user's context
            RpcImpersonateClient(0);

            // determine name of current user
            GetUserNameA(gszUserName, &dwUserNameLen);

            // switch back
            RpcRevertToSelf();    

#endif 
            // Initialize critical sections.
            __try 
            {
                InitializeCriticalSection(&gCritSec);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) 
            {
                return FALSE;
            }
        break;

        case DLL_PROCESS_DETACH:

            DeleteCriticalSection(&gCritSec);
        break;
   
    } // switch

    return TRUE;
}


//
// We get a slough of C4047 (different levels of indrection) warnings down
// below in the initialization of FUNC_PARAM structs as a result of the
// real func prototypes having params that are types other than DWORDs,
// so since these are known non-interesting warnings just turn them off
//

#pragma warning (disable:4047)


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// TSPI_lineXxx functions                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


LONG
TSPIAPI
TSPI_lineClose(
    HDRVLINE    hdLine
   )
{
    DBGOUT((TRCE, "TSPI_lineClose, hdLine %p", hdLine));

    DWORD dwLine = HandleToUlong(hdLine);

    if (dwLine != IPCONF_LINE_HANDLE)
    {
        DBGOUT((FAIL, "invalide line handle, hdLine %p", hdLine));
        return LINEERR_INVALLINEHANDLE;
    }

    EnterCriticalSection(&gCritSec);

    // Clean up all the open calls when this line is closed.
    for (DWORD i = 0; i < gpCallList.size(); i++)
    {
        if ((gpCallList[i] != NULL))
        {
            FreeCall(i);
        }
    }

    gLine.bOpened = FALSE;

    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_lineClose succeeded."));
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineCloseCall(
    HDRVCALL    hdCall
   )
{
    DBGOUT((TRCE, "TSPI_lineCloseCall, hdCall %p", hdCall));

    DWORD dwCall = HandleToUlong(hdCall);

    EnterCriticalSection(&gCritSec);

    if (dwCall >= gpCallList.size())
    {
        LeaveCriticalSection(&gCritSec);
        DBGOUT((FAIL, "TSPI_lineCloseCall invalid call handle: %p", hdCall));
        return LINEERR_INVALCALLHANDLE;
    }

    FreeCall(dwCall);

    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_lineCloseCall succeeded"));
    return NOERROR;
}

LONG
TSPIAPI
TSPI_lineCreateMSPInstance(
    HDRVLINE        hdLine,
    DWORD           dwAddressID,
    HTAPIMSPLINE    htMSPLine,
    LPHDRVMSPLINE   phdMSPLine
    )
{
    DBGOUT((TRCE, "TSPI_lineCreateMSPInstance"));

    if (IsBadWritePtr(phdMSPLine, sizeof (HDRVMSPLINE)))
    {
        DBGOUT((FAIL, "TSPI_lineCreateMSPInstance bad pointer"));
        return LINEERR_INVALPOINTER;
    }

    if (HandleToUlong(hdLine) != IPCONF_LINE_HANDLE)
    {
        DBGOUT((FAIL, "TSPI_lineCreateMSPInstance, bad line handle:%p", hdLine));
        return LINEERR_INVALLINEHANDLE;
    }

    EnterCriticalSection(&gCritSec);

    // We are not keeping the msp handles. Just fake a handle here.
    *phdMSPLine = (HDRVMSPLINE)(gLine.dwNextMSPHandle ++);

    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_lineCloseCall succeeded"));
    return (NOERROR);
}

LONG
TSPIAPI
TSPI_lineCloseMSPInstance(
    HDRVMSPLINE         hdMSPLine
    )
{
    DBGOUT((TRCE, "TSPI_lineCloseMSPInstance, hdMSPLine %p", hdMSPLine));
    DBGOUT((TRCE, "TSPI_lineCloseCall succeeded"));
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineDrop(
    DRV_REQUESTID   dwRequestID,
    HDRVCALL        hdCall,
    LPCSTR          lpsUserUserInfo,
    DWORD           dwSize
   )
{
    DBGOUT((TRCE, "TSPI_lineDrop, hdCall %p", hdCall));

    DWORD dwCall = HandleToUlong(hdCall);

    EnterCriticalSection(&gCritSec);

    // check the call handle.
    if (dwCall >= gpCallList.size())
    {
        LeaveCriticalSection(&gCritSec);
        (*glpfnCompletionProc)(dwRequestID, LINEERR_INVALCALLHANDLE);

        DBGOUT((FAIL, "TSPI_lineDrop invalid call handle %p", hdCall));
        return dwRequestID;
    }

    CALL *pCall = gpCallList[dwCall];
    if (pCall != NULL)
    {
        pCall->SetCallState(LINECALLSTATE_IDLE, 0);
        pCall->SendMSPStopMessage();
    
        DBGOUT((INFO, "call %d state changed to idle", dwCall));
    }

    LeaveCriticalSection(&gCritSec);

    (*glpfnCompletionProc)(dwRequestID, 0);

    DBGOUT((TRCE, "TSPI_lineDrop succeeded"));
    return dwRequestID;
}

LONG
TSPIAPI
TSPI_lineGetAddressCaps(
    DWORD              dwDeviceID,
    DWORD              dwAddressID,
    DWORD              dwTSPIVersion,
    DWORD              dwExtVersion,
    LPLINEADDRESSCAPS  lpAddressCaps
   )
{
    DBGOUT((TRCE, "TSPI_lineGetAddressCaps"));

    if (dwDeviceID != gdwLineDeviceIDBase)
    {
        DBGOUT((TRCE, "TSPI_lineGetAddressCaps bad device id: %d", dwDeviceID));
        return LINEERR_BADDEVICEID;
    }

    // Check the address ID.
    if (dwAddressID != 0)
    {
        DBGOUT((TRCE, "TSPI_lineGetAddressCaps bad address id: %d", dwAddressID));
        return LINEERR_INVALADDRESSID;
    }

    // load the address name from the string table.
    WCHAR szAddressName[IPCONF_BUFSIZE + 1];
    if (0 == LoadStringW(g_hInstance, IDS_IPCONFADDRESSNAME, szAddressName, IPCONF_BUFSIZE))
    {
        szAddressName[0] = L'\0';
    }

    DWORD dwAddressSize = (lstrlenW(szAddressName) + 1) * (sizeof WCHAR);

    lpAddressCaps->dwNeededSize = sizeof(LINEADDRESSCAPS) + dwAddressSize;

    if (lpAddressCaps->dwTotalSize >= lpAddressCaps->dwNeededSize)
    {
        // Copy the IP address to the end of the structure.
        lpAddressCaps->dwUsedSize = lpAddressCaps->dwNeededSize;

        lpAddressCaps->dwAddressSize   = dwAddressSize;
        lpAddressCaps->dwAddressOffset = sizeof(LINEADDRESSCAPS);
        lstrcpyW ((WCHAR *)(lpAddressCaps + 1), szAddressName);
    }
    else
    {
        lpAddressCaps->dwUsedSize   = sizeof(LINEADDRESSCAPS);
    }
    lpAddressCaps->dwLineDeviceID       = dwDeviceID;
    lpAddressCaps->dwAddressSharing     = LINEADDRESSSHARING_PRIVATE;
    lpAddressCaps->dwCallInfoStates     = LINECALLINFOSTATE_MEDIAMODE;
    lpAddressCaps->dwCallerIDFlags      =
    lpAddressCaps->dwCalledIDFlags      =
    lpAddressCaps->dwConnectedIDFlags   =
    lpAddressCaps->dwRedirectionIDFlags =
    lpAddressCaps->dwRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;
    lpAddressCaps->dwCallStates         = LINECALLSTATE_IDLE |
                                          LINECALLSTATE_DIALING |
                                          LINECALLSTATE_CONNECTED;
    lpAddressCaps->dwDialToneModes      = 0; 
    lpAddressCaps->dwBusyModes          = 0;
    lpAddressCaps->dwSpecialInfo        = 0;
    lpAddressCaps->dwDisconnectModes    = LINEDISCONNECTMODE_NORMAL |
                                          LINEDISCONNECTMODE_UNAVAIL;
    lpAddressCaps->dwMaxNumActiveCalls  = MAXCALLSPERADDRESS;
    lpAddressCaps->dwAddrCapFlags       = LINEADDRCAPFLAGS_DIALED |
                                          LINEADDRCAPFLAGS_ORIGOFFHOOK;

    lpAddressCaps->dwCallFeatures       = LINECALLFEATURE_DROP | 
                                          LINECALLFEATURE_SETQOS;

    lpAddressCaps->dwAddressFeatures    = LINEADDRFEATURE_MAKECALL;

    DBGOUT((TRCE, "TSPI_lineGetAddressCaps succeeded."));
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetAddressID(
    HDRVLINE    hdLine,
    LPDWORD     lpdwAddressID,
    DWORD       dwAddressMode,
    LPCWSTR     lpsAddress,
    DWORD       dwSize
   )
{
    DBGOUT((TRCE, "TSPI_lineGetAddressID htLine:%p", hdLine));
    *lpdwAddressID = 0;
    DBGOUT((TRCE, "TSPI_lineGetAddressID succeeded."));
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetAddressStatus(
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS lpAddressStatus
   )
{
    DBGOUT((TRCE, "TSPI_lineGetAddressStatus htLine:%p", hdLine));

    if (HandleToUlong(hdLine) != IPCONF_LINE_HANDLE)
    {
        DBGOUT((FAIL, "TSPI_lineGetAddressStatus htLine:%p", hdLine));
        return LINEERR_INVALLINEHANDLE;
    }

    lpAddressStatus->dwNeededSize =
    lpAddressStatus->dwUsedSize   = sizeof(LINEADDRESSSTATUS);

    EnterCriticalSection(&gCritSec);

    lpAddressStatus->dwNumActiveCalls = gLine.dwNumCalls;

    LeaveCriticalSection(&gCritSec);

    lpAddressStatus->dwAddressFeatures = LINEADDRFEATURE_MAKECALL;

    DBGOUT((TRCE, "TSPI_lineGetAddressStatus succeeded."));
    return NOERROR;
}



LONG
TSPIAPI
TSPI_lineGetCallAddressID(
    HDRVCALL    hdCall,
    LPDWORD     lpdwAddressID
   )
{
    DBGOUT((TRCE, "TSPI_lineGetCallAddressID hdCall %p", hdCall));
    //
    // We only support 1 address (id=0) per line
    //
    *lpdwAddressID = 0;

    DBGOUT((TRCE, "TSPI_lineGetCallAddressID succeeded."));
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetCallInfo(
    HDRVCALL        hdCall,
    LPLINECALLINFO  lpLineInfo
   )
{
    DBGOUT((TRCE, "TSPI_lineGetCallInfo hdCall %p", hdCall));

    DWORD dwCall = HandleToUlong(hdCall);

    EnterCriticalSection(&gCritSec);

    if (dwCall >= gpCallList.size())
    {
        LeaveCriticalSection(&gCritSec);
    
        DBGOUT((FAIL, "TSPI_lineGetCallInfo bad call handle %p", hdCall));
        return LINEERR_INVALCALLHANDLE;
    }

    // get the call object.
    CALL *pCall = gpCallList[dwCall];
    if (pCall == NULL)
    {
        LeaveCriticalSection(&gCritSec);
        DBGOUT((FAIL, "TSPI_lineGetCallInfo bad call handle %p", hdCall));
        return LINEERR_INVALCALLHANDLE;
    }

    lpLineInfo->dwMediaMode          = pCall->dwMediaMode();
    LeaveCriticalSection(&gCritSec);

    lpLineInfo->dwLineDeviceID       = gLine.dwDeviceID;
    lpLineInfo->dwAddressID          = 0; // There is only on address per line.

    lpLineInfo->dwBearerMode         = IPCONF_BEARERMODES;
    lpLineInfo->dwCallStates         = LINECALLSTATE_IDLE |
                                       LINECALLSTATE_DIALING |
                                       LINECALLSTATE_CONNECTED;
    lpLineInfo->dwOrigin             = LINECALLORIGIN_OUTBOUND;
    lpLineInfo->dwReason             = LINECALLREASON_DIRECT;

    lpLineInfo->dwCallerIDFlags      =
    lpLineInfo->dwCalledIDFlags      =
    lpLineInfo->dwConnectedIDFlags   =
    lpLineInfo->dwRedirectionIDFlags =
    lpLineInfo->dwRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;

    DBGOUT((TRCE, "TSPI_lineGetCallInfo succeeded."));
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetCallStatus(
    HDRVCALL            hdCall,
    LPLINECALLSTATUS    lpLineStatus
   )
{
    DBGOUT((TRCE, "TSPI_lineGetCallStatus hdCall %p", hdCall));

    DWORD dwCall = HandleToUlong(hdCall);

    EnterCriticalSection(&gCritSec);
    
    // check the call handle.
    if (dwCall >= gpCallList.size())
    {
        LeaveCriticalSection(&gCritSec);
        DBGOUT((TRCE, "TSPI_lineGetCallStatus bad call handle %p", hdCall));
        return LINEERR_INVALCALLHANDLE;
    }

    lpLineStatus->dwNeededSize =
    lpLineStatus->dwUsedSize   = sizeof(LINECALLSTATUS);

    lpLineStatus->dwCallState  = gpCallList[dwCall]->dwState();
    if (lpLineStatus->dwCallState != LINECALLSTATE_IDLE)
    {
        lpLineStatus->dwCallFeatures = LINECALLFEATURE_DROP | 
                                       LINECALLFEATURE_SETQOS;
    }
    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_lineGetCallStatus succeeded."));
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetDevCaps(
    DWORD           dwDeviceID,
    DWORD           dwTSPIVersion,
    DWORD           dwExtVersion,
    LPLINEDEVCAPS   lpLineDevCaps
   )
{
    DBGOUT((TRCE, "TSPI_lineGetDevCaps"));
    
    if (dwDeviceID != gdwLineDeviceIDBase)
    {
        DBGOUT((FAIL, "TSPI_lineGetDevCaps bad device id %d", dwDeviceID));
        return LINEERR_BADDEVICEID;
    }

    DWORD dwProviderInfoSize;
    DWORD dwLineNameSize;
    DWORD dwDevSpecificSize;
    DWORD dwOffset;
  
    // load the name of the service provider from the string table.
    WCHAR szProviderInfo[IPCONF_BUFSIZE + 1];
    if (0 == LoadStringW(g_hInstance, IDS_IPCONFPROVIDERNAME, szProviderInfo, IPCONF_BUFSIZE))
    {
        szProviderInfo[0] = L'\0';
    }

    dwProviderInfoSize = (lstrlenW(szProviderInfo) + 1) * sizeof(WCHAR);

    // load the line name format from the string table and print the line name.
    WCHAR szLineName[IPCONF_BUFSIZE + 1];
    if (0 == LoadStringW(g_hInstance, IDS_IPCONFLINENAME, szLineName, IPCONF_BUFSIZE))
    {
        szLineName[0] = L'\0';
    }

    dwLineNameSize = (lstrlenW(szLineName) + 1) * (sizeof WCHAR);

    lpLineDevCaps->dwNeededSize = sizeof (LINEDEVCAPS) 
        + dwProviderInfoSize 
        + dwLineNameSize;

    if (lpLineDevCaps->dwTotalSize >= lpLineDevCaps->dwNeededSize)
    {
        lpLineDevCaps->dwUsedSize = lpLineDevCaps->dwNeededSize;

        CHAR *pChar;
        
        pChar = (CHAR *)(lpLineDevCaps + 1);
        dwOffset = sizeof(LINEDEVCAPS);
        
        // fill in the provider info.
        lpLineDevCaps->dwProviderInfoSize   = dwProviderInfoSize;
        lpLineDevCaps->dwProviderInfoOffset = dwOffset;
        lstrcpyW ((WCHAR *)pChar, szProviderInfo);

        pChar += dwProviderInfoSize;
        dwOffset += dwProviderInfoSize;

        // fill in the name of the line.
        lpLineDevCaps->dwLineNameSize   = dwLineNameSize;
        lpLineDevCaps->dwLineNameOffset = dwOffset; 
        lstrcpyW ((WCHAR *)pChar, szLineName);
    }
    else
    {
        lpLineDevCaps->dwUsedSize = sizeof(LINEDEVCAPS);
    }

    // We don't have really "Permanent" line ids. So just fake one here.
    lpLineDevCaps->dwPermanentLineID = 
        ((gdwPermanentProviderID & 0xffff) << 16) | 
        ((dwDeviceID - gdwLineDeviceIDBase) & 0xffff);
    
    CopyMemory(
               &(lpLineDevCaps->PermanentLineGuid),
               &GUID_LINE,
               sizeof(GUID)
              );

    lpLineDevCaps->PermanentLineGuid.Data1 += dwDeviceID - gdwLineDeviceIDBase;

    lpLineDevCaps->dwStringFormat      = STRINGFORMAT_UNICODE;
    lpLineDevCaps->dwAddressModes      = IPCONF_ADDRESSMODES;
    lpLineDevCaps->dwNumAddresses      = IPCONF_NUMADDRESSESPERLINE;
    lpLineDevCaps->dwBearerModes       = IPCONF_BEARERMODES;
    lpLineDevCaps->dwMediaModes        = IPCONF_MEDIAMODES;
    lpLineDevCaps->dwMaxRate           = (1 << 20);
    lpLineDevCaps->dwAddressTypes      = LINEADDRESSTYPE_SDP;
    lpLineDevCaps->dwDevCapFlags       = 
        LINEDEVCAPFLAGS_CLOSEDROP
        | LINEDEVCAPFLAGS_MSP
        | LINEDEVCAPFLAGS_LOCAL;

    lpLineDevCaps->dwMaxNumActiveCalls = 
        MAXCALLSPERADDRESS * IPCONF_NUMADDRESSESPERLINE;  
    lpLineDevCaps->dwRingModes         = 0;
    lpLineDevCaps->dwLineFeatures      = LINEFEATURE_MAKECALL;

    CopyMemory(
               &(lpLineDevCaps->ProtocolGuid),
               &TAPIPROTOCOL_Multicast,
               sizeof(GUID)
              );
    
    DBGOUT((TRCE, "TSPI_lineGetDevCaps succeeded."));
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetIcon(
    DWORD   dwDeviceID,
    LPCWSTR lpgszDeviceClass,
    LPHICON lphIcon
   )
{
    DBGOUT((TRCE, "TSPI_lineGetIcon:"));
    return LINEERR_OPERATIONUNAVAIL;
}


LONG
TSPIAPI
TSPI_lineGetID(
    HDRVLINE    hdLine,
    DWORD       dwAddressID,
    HDRVCALL    hdCall,
    DWORD       dwSelect,
    LPVARSTRING lpDeviceID,
    LPCWSTR     lpgszDeviceClass,
    HANDLE      hTargetProcess
   )
{
    DBGOUT((TRCE, "TSPI_lineGetID:"));
    return LINEERR_OPERATIONUNAVAIL;
}


LONG
TSPIAPI
TSPI_lineGetLineDevStatus(
    HDRVLINE        hdLine,
    LPLINEDEVSTATUS lpLineDevStatus
   )
{
    DBGOUT((TRCE, "TSPI_lineGetLineDevStatus %p", hdLine));

    if (HandleToUlong(hdLine) != IPCONF_LINE_HANDLE)
    {
        DBGOUT((FAIL, "TSPI_lineGetLineDevStatus bad line handle %p", hdLine));
        return LINEERR_INVALLINEHANDLE;
    }

    lpLineDevStatus->dwUsedSize         =
    lpLineDevStatus->dwNeededSize       = sizeof (LINEDEVSTATUS);

    EnterCriticalSection(&gCritSec);
    lpLineDevStatus->dwNumActiveCalls   = gLine.dwNumCalls;
    LeaveCriticalSection(&gCritSec);

    lpLineDevStatus->dwLineFeatures     = LINEFEATURE_MAKECALL;
    lpLineDevStatus->dwDevStatusFlags   = LINEDEVSTATUSFLAGS_CONNECTED |
                                          LINEDEVSTATUSFLAGS_INSERVICE;

    DBGOUT((TRCE, "TSPI_lineGetLineDevStatus succeeded"));
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetNumAddressIDs(
    HDRVLINE    hdLine,
    LPDWORD     lpdwNumAddressIDs
   )
{
    DBGOUT((TRCE, "TSPI_lineGetNumAddressIDs"));

    *lpdwNumAddressIDs = IPCONF_NUMADDRESSESPERLINE;

    DBGOUT((TRCE, "TSPI_lineGetNumAddressIDs succeeded."));
    return NOERROR;
}

LONG
TSPIAPI
TSPI_lineMakeCall(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    HTAPICALL           htCall,
    LPHDRVCALL          lphdCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
   )
{
    DBGOUT((TRCE, "TSPI_lineMakeCall hdLine %p, htCall %p",
        hdLine, htCall));

    // check the line handle.
    if (HandleToUlong(hdLine) != IPCONF_LINE_HANDLE)
    {
        DBGOUT((FAIL, "TSPI_lineMakeCall Bad line handle %p", hdLine));
        return LINEERR_INVALLINEHANDLE;
    }

    LONG lResult;
    if ((lResult = CheckCallParams(lpCallParams)) != NOERROR)
    {
        DBGOUT((FAIL, "TSPI_lineMakeCall Bad call params"));
        return lResult;
    }

    // check the destination address.
    if (lpszDestAddress == NULL || lstrlenW(lpszDestAddress) == 0)
    {
        DBGOUT((FAIL, "TSPI_lineMakeCall invalid address."));
        return LINEERR_INVALADDRESS;
    }
    
    DBGOUT((TRCE, "TSPI_lineMakeCall making call to %ws", lpszDestAddress));

    // check the line handle.
    EnterCriticalSection(&gCritSec);

    // create a call object.
    CALL * pCall = (CALL *)MemAlloc(sizeof(CALL));

    if (pCall == NULL)
    {
        LeaveCriticalSection(&gCritSec);

        DBGOUT((FAIL, "out of memory for a new call"));
        return LINEERR_NOMEM;
    }

    if (pCall->Init(
        htCall,
        lpCallParams
        ) != NOERROR)
    {
        MemFree(pCall);
        LeaveCriticalSection(&gCritSec);

        DBGOUT((FAIL, "out of memory in init a new call"));
        return LINEERR_NOMEM;
    }

    // add the call into the call list.
    DWORD_PTR hdCall; 
    if (!FindFreeCallSlot(hdCall))
    {
        LeaveCriticalSection(&gCritSec);
        MemFree(pCall);
        
        DBGOUT((FAIL, "out of memory finding a new slot"));
        return LINEERR_NOMEM;
    }

    gpCallList[(ULONG)hdCall] = pCall;

    // Increament the call count for the line and the provider.
    gLine.dwNumCalls ++;

    gdwNumCallsInUse ++;

    // Complete the request and set the initial call state.
    (*glpfnCompletionProc)(dwRequestID, lResult);

    *lphdCall = (HDRVCALL)(hdCall);

    // Send the MSP a message about this call. It has the SDP in it.
    lResult = pCall->SendMSPStartMessage(lpszDestAddress);

    if (lResult == NOERROR)
    {
        // Set the call state to dialing. 
        pCall->SetCallState(
            LINECALLSTATE_DIALING, 
            0
            );
        DBGOUT((INFO, "call %d state changed to dialing", hdCall));
    }
    else
    {
        DBGOUT((FAIL, "send MSP message failed, err:%x", lResult));

        // Set the call state to idel. 
        pCall->SetCallState(
            LINECALLSTATE_DISCONNECTED,
            LINEDISCONNECTMODE_UNREACHABLE
            );
        DBGOUT((INFO, "call %d state changed to disconnected", hdCall));
    }

    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_lineMakeCall succeeded."));
    return dwRequestID;
}

LONG                                    
TSPIAPI
TSPI_lineMSPIdentify(
    DWORD               dwDeviceID,
    GUID *              pCLSID
    )
{
    DBGOUT((TRCE, "TSPI_lineMSPIdentify dwDeviceID %d", dwDeviceID));
    
    *pCLSID = CLSID_CONFMSP;
    
    DBGOUT((TRCE, "TSPI_lineMSPIdentify succeeded."));
    return NOERROR;

}

LONG
TSPIAPI
TSPI_lineNegotiateTSPIVersion(
    DWORD   dwDeviceID,
    DWORD   dwLowVersion,
    DWORD   dwHighVersion,
    LPDWORD lpdwTSPIVersion
   )
{
    DBGOUT((TRCE, "TSPI_lineNegotiateTSPIVersion dwDeviceID %d", dwDeviceID));

    LONG        lResult = 0;

    if (TAPI_CURRENT_VERSION <= dwHighVersion 
        && TAPI_CURRENT_VERSION >= dwLowVersion)
    {
        *lpdwTSPIVersion = TAPI_CURRENT_VERSION;
    }
    else
    {
        DBGOUT((FAIL, "TSPI_lineNegotiateTSPIVersion failed."));

        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    DBGOUT((TRCE, "TSPI_lineNegotiateTSPIVersion succeeded. version %x", 
        TAPI_CURRENT_VERSION));

    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineOpen(
    DWORD       dwDeviceID,
    HTAPILINE   htLine,
    LPHDRVLINE  lphdLine,
    DWORD       dwTSPIVersion,
    LINEEVENT   lpfnEventProc
   )
{
    DBGOUT((TRCE, "TSPI_lineOpen dwDiviceID %d", dwDeviceID)); 

    LONG        lResult;

    if (dwDeviceID != gdwLineDeviceIDBase)
    {
        DBGOUT((FAIL, "TSPI_lineOpen bad DiviceID %d", dwDeviceID)); 
        return LINEERR_BADDEVICEID;
    }

    EnterCriticalSection(&gCritSec);

    lResult = LINEERR_RESOURCEUNAVAIL;

    if (!gLine.bOpened)
    {
        *lphdLine = (HDRVLINE)IPCONF_LINE_HANDLE;
        gLine.bOpened = TRUE;
        gLine.htLine = htLine;
        gLine.dwNumCalls = 0;
        lResult = 0;
    }
    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_lineOpen returns:%d", lResult)); 

    return lResult;
}

LONG 
TSPIAPI
TSPI_lineReceiveMSPData(
    HDRVLINE        hdLine,
    HDRVCALL        hdCall,         // can be NULL
    HDRVMSPLINE     hdMSPLine, // from lineCreateMSPInstance
    LPBYTE          pBuffer,
    DWORD           dwSize
    )
{
    DBGOUT((TRCE, "TSPI_lineReceiveMSPData hdLine %p", hdLine)); 

    if ((dwSize == 0) || IsBadReadPtr(pBuffer, dwSize))
    {
        DBGOUT((FAIL, "TSPI_lineReceiveMSPData bad puffer"));
        return LINEERR_INVALPOINTER;
    }

    DWORD dwCall = HandleToUlong(hdCall);

    EnterCriticalSection(&gCritSec);

    // check the call handle.
    if (dwCall >= gpCallList.size() || gpCallList[dwCall] == NULL)
    {
        LeaveCriticalSection(&gCritSec);

        DBGOUT((FAIL, "TSPI_lineReceiveMSPData invalide call handle: %x", 
            dwCall));
        
        return LINEERR_INVALCALLHANDLE;
    }

    MSG_TSPMSPDATA *pData = (MSG_TSPMSPDATA *)pBuffer;

    long lResult = NOERROR;

    switch (pData->command)
    {
        case CALL_CONNECTED:
            // Set the call state to connected. 
            gpCallList[dwCall]->SetCallState(
                LINECALLSTATE_CONNECTED,
                LINECONNECTEDMODE_ACTIVE
            );
            DBGOUT((INFO, "call %d state changed to connected", dwCall));
            break;

        case CALL_DISCONNECTED:
            // Set the call state to idel. 
            gpCallList[dwCall]->SetCallState(
                LINECALLSTATE_DISCONNECTED,
                LINEDISCONNECTMODE_UNREACHABLE
                );
            DBGOUT((INFO, "call %d state changed to disconnected", dwCall));
            break;

        case CALL_QOS_EVENT:
            (*glpfnLineEventProc)(
                gLine.htLine,
                gpCallList[dwCall]->htCall(),
                LINE_QOSINFO,
                pData->QosEvent.dwEvent,
                pData->QosEvent.dwMediaMode,
                0
                );
            break;

        default:
            DBGOUT((FAIL, "invalide command: %x", pData->command));
            lResult = LINEERR_OPERATIONFAILED;
    }

    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_lineReceiveMSPData returns:%d", lResult)); 
    return lResult;
}

LONG
TSPIAPI
TSPI_lineSetDefaultMediaDetection(
    HDRVLINE    hdLine,
    DWORD       dwMediaModes
    )
{
    DBGOUT((TRCE, "TSPI_lineSetDefaultMediaDetection:"));
    return LINEERR_OPERATIONUNAVAIL;
}

LONG
TSPIAPI
TSPI_lineSetMediaMode(
    HDRVCALL    hdCall,
    DWORD       dwMediaMode
   )
{
    DBGOUT((TRCE, "TSPI_lineSetMediaMode:"));
    return LINEERR_OPERATIONUNAVAIL;
}




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// TSPI_providerXxx functions                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#if 0 // we dont' need the user name anymore.
LONG
TSPIAPI
TSPI_providerCheckForNewUser(
    IN DWORD dwPermanentProviderID
)
/*++

Routine Description:

    Once a line is opened, it will never be opened twice, even when the user
    logs off and logs on. So we need a way to find out when the user changes.
    That's why this function is added. It only work for single user.

    Everytime a new app starts using tapi, tapisrv will call this function.
    We need to check to see if the user has changed and register the new user
    in the ILS server.

Arguments:

    NONE.

Return Values:

    NOERROR always.

--*/
{
    DBGOUT((TRCE, "TSPI_providerCheckForNewUser"));

    DWORD dwUserNameLen = MAXUSERNAMELEN;
    CHAR szNewUserName[MAXUSERNAMELEN + 1];

    UNREFERENCED_PARAMETER(dwPermanentProviderID ); // It is me.

    // switch in user's context
    RpcImpersonateClient(0);

    // determine name of current user
    GetUserNameA(szNewUserName, &dwUserNameLen);

    // switch back
    RpcRevertToSelf();

    EnterCriticalSection(&gCritSec);

    lstrcpy(gszUserName, szNewUserName);

    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_providerCheckForNewUser succeeded, new user :%ws",
        gszUserName ));

    return NOERROR;
}
#endif


LONG
TSPIAPI
TSPI_providerEnumDevices(
    DWORD       dwPermanentProviderID,
    LPDWORD     lpdwNumLines,
    LPDWORD     lpdwNumPhones,
    HPROVIDER   hProvider,
    LINEEVENT   lpfnLineCreateProc,
    PHONEEVENT  lpfnPhoneCreateProc
   )
{
    DBGOUT((TRCE, "TSPI_providerEnumDevices"));

    EnterCriticalSection(&gCritSec);

    *lpdwNumLines = IPCONF_NUMLINES;
    *lpdwNumPhones = IPCONF_NUMPHONES;

    // save provider handle
    ghProvider = hProvider;

    // save the callback used in creating new lines.
    glpfnLineEventProc = lpfnLineCreateProc;

    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_providerEnumDevices succeeded."));
    return NOERROR;
}

LONG
TSPIAPI
TSPI_providerInit(
    DWORD               dwTSPIVersion,
    DWORD               dwPermanentProviderID,
    DWORD               dwLineDeviceIDBase,
    DWORD               dwPhoneDeviceIDBase,
    DWORD               dwNumLines,
    DWORD               dwNumPhones,
    ASYNC_COMPLETION    lpfnCompletionProc,
    LPDWORD             lpdwTSPIOptions
   )
{
    EnterCriticalSection(&gCritSec);

    DBGREGISTER (("conftsp"));

    DBGOUT((TRCE, "TSPI_providerInit"));

    LONG        hr = LINEERR_OPERATIONFAILED;
    

    glpfnCompletionProc = lpfnCompletionProc;
    gdwLineDeviceIDBase = dwLineDeviceIDBase;
    gdwPermanentProviderID = dwPermanentProviderID;

    gLine.dwDeviceID = gdwLineDeviceIDBase;
    gLine.bOpened = FALSE;

    LeaveCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_providerInit succeeded."));
    return NOERROR;
}


LONG
TSPIAPI
TSPI_providerInstall(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
   )
{
    DBGOUT((TRCE, "TSPI_providerInstall:"));
    //
    // Although this func is never called by TAPI v2.0, we export
    // it so that the Telephony Control Panel Applet knows that it
    // can add this provider via lineAddProvider(), otherwise
    // Telephon.cpl will not consider it installable
    //
    //

    return NOERROR;
}

LONG
TSPIAPI
TSPI_providerRemove(
    HWND    hwndOwner,
    DWORD   dwPermanentProviderID
   )
{
    //
    // Although this func is never called by TAPI v2.0, we export
    // it so that the Telephony Control Panel Applet knows that it
    // can configure this provider via lineConfigProvider(),
    // otherwise Telephon.cpl will not consider it configurable
    //

    return NOERROR;
}

LONG
TSPIAPI
TSPI_providerShutdown(
    DWORD   dwTSPIVersion,
    DWORD   dwPermanentProviderID
   )
{
    EnterCriticalSection(&gCritSec);

    DBGOUT((TRCE, "TSPI_providerShutdown."));

    // Clean up all the open calls when this provider is shutted down.
    for (DWORD i = 0; i < gpCallList.size(); i++)
    {
        FreeCall(i);
    }

    DBGOUT((TRCE, "TSPI_providerShutdown succeeded."));

    DBGDEREGISTER ();

    LeaveCriticalSection(&gCritSec);

    return NOERROR;
}

LONG
TSPIAPI
TSPI_providerUIIdentify(
    LPWSTR   lpszUIDLLName
   )
{
    lstrcpyW(lpszUIDLLName, gszUIDLLName);
    return NOERROR;
}

LONG
TSPIAPI
TUISPI_providerRemove(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
    DBGOUT((TRCE, "TUISPI_providerInstall"));
    return NOERROR;
}

LONG
TSPIAPI
TUISPI_providerInstall(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
    DBGOUT((TRCE, "TUISPI_providerInstall"));

    const CHAR szKey[] =
        "Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Providers";
    
    HKEY  hKey;
    DWORD dwDataSize, dwDataType;
    DWORD dwNumProviders;

    CHAR szName[IPCONF_BUFSIZE + 1], szPath[IPCONF_BUFSIZE + 1];

    // open the providers key
    if (RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        szKey,
        0,
        KEY_READ,
        &hKey
       ) == ERROR_SUCCESS)
    {
        // first get the number of providers installed.
        dwDataSize = sizeof(DWORD);
        if (RegQueryValueEx(
            hKey,
            "NumProviders",
            0,
            &dwDataType,
            (LPBYTE) &dwNumProviders,
            &dwDataSize
           ) != ERROR_SUCCESS)
        {
            RegCloseKey (hKey);
            return LINEERR_UNINITIALIZED;
        }

        // then go through the list of providers to see if
        // we are already installed.
        for (DWORD i = 0; i < dwNumProviders; i ++)
        {
            wsprintf (szName, "ProviderFileName%d", i);
            dwDataSize = sizeof(szPath);
            if (RegQueryValueEx(
                hKey,
                szName,
                0,
                &dwDataType,
                (LPBYTE) &szPath,
                &dwDataSize
               ) != ERROR_SUCCESS)
            {
                RegCloseKey (hKey);
                return LINEERR_UNINITIALIZED;
            }

            _strupr(szPath);

            if (strstr(szPath, "IPCONF") != NULL)
            {
                RegCloseKey (hKey);

                // found, we don't want to be installed twice.
                return LINEERR_NOMULTIPLEINSTANCE;
            }
        }
        RegCloseKey (hKey);
        return NOERROR;
    }
    
    return LINEERR_UNINITIALIZED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\test\t3out\vdevicep.h ===
/****************************************************************************
 *  @doc INTERNAL VDEVICEP
 *
 *  @module VDeviceP.h | Header file for the <c CVDeviceProperties>
 *    class used to implement a property page to test the <i ITVfwCaptureDialogs>,
 *    as well as <i ITAddress> and <ITStream> interfaces to select video
 *    capture devices.
 ***************************************************************************/

/****************************************************************************
 *  @doc INTERNAL CDEVICEPCLASS
 *
 *  @class CVDeviceProperties | This class implements a property page
 *    to test the new TAPI internal interface <i IVideoDeviceControl>.
 *
 *  @mdata ITVfwCaptureDialogs* | CVDeviceProperties | m_pITVfwCaptureDialogs | Pointer
 *    to the <i m_pITVfwCaptureDialogs> interface used to put VfW capture dialogs.
 ***************************************************************************/
class CVDeviceProperties
{
	public:
	CVDeviceProperties();
	~CVDeviceProperties();

	HPROPSHEETPAGE OnCreate();

	HRESULT OnConnect(ITTerminal *pITTerminal);
	HRESULT OnDisconnect();

	private:

#if USE_VFW
	ITVfwCaptureDialogs *m_pITVfwCaptureDialogs;
#endif

	BOOL  m_bInit;
	HWND  m_hDlg;

	// Dialog proc
	static INT_PTR CALLBACK BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\tsp\stdafx.h ===
#ifndef __STDAFX_H_
#define __STDAFX_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winreg.h>
#include <objbase.h>
#include <tapi.h>
#include <tspi.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F8FF7774_4BD5_11D1_AFD1_00C04FC31FEE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\tsp\resource.h ===
#ifndef __RESOURCE_H
#define __RESOURCE_H

#define IDS_IPCONFPROVIDERNAME          1
#define IDS_IPCONFLINENAME              2
#define IDS_IPCONFADDRESSNAME           3

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\ipconf\tsp\conftsp.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    SDPSP.h

Abstract:

    Definitions for multicast service provider.

Author:
    
    Mu Han (muhan) 1-April-1997

--*/

#ifndef __CONFTSP_H
#define __CONFTSP_H

// There is no phone devices in this provider.
#define IPCONF_NUMPHONES           0

// By default we have just one line.
#define IPCONF_NUMLINES            1

// Each network interface has only one address.
#define IPCONF_NUMADDRESSESPERLINE 1

#define IPCONF_LINE_HANDLE 'CONF'

// The number of calls for each address.
#define MAXCALLSPERADDRESS  32768

#define IPCONF_MEDIAMODES (LINEMEDIAMODE_INTERACTIVEVOICE | \
                          LINEMEDIAMODE_AUTOMATEDVOICE | \
                          LINEMEDIAMODE_VIDEO | \
                          LINEMEDIAMODE_UNKNOWN)

#define IPCONF_BEARERMODES (LINEBEARERMODE_DATA | LINEBEARERMODE_VOICE)

#define IPCONF_ADDRESSMODES LINEADDRESSMODE_ADDRESSID

#define IPCONF_BUFSIZE      255

#define MAXUSERNAMELEN      255

#define MemAlloc(size) (LocalAlloc(LPTR, size))
#define MemFree(p) if (p) LocalFree((HLOCAL)p)

// {28B853D5-FC04-11d1-8302-00A0244D2298}
DEFINE_GUID(GUID_LINE, 
0x28b853d5, 0xfc04, 0x11d1, 0x83, 0x2, 0x0, 0xa0, 0x24, 0x4d, 0x22, 0x98);

// {0F1BE7F7-45CA-11d2-831F-00A0244D2298}
DEFINE_GUID(CLSID_CONFMSP,
0x0F1BE7F7,0x45CA, 0x11d2, 0x83, 0x1F, 0x0, 0xA0, 0x24, 0x4D, 0x22, 0x98);


typedef struct _LINE
{
    BOOL        bOpened;    // This line is opened or not.
    HTAPILINE   htLine;     // The handle for this line in TAPI's space.
    DWORD       dwDeviceID;
    DWORD       dwNumCalls; // Number of calls made on this line.
    
    DWORD_PTR   dwNextMSPHandle; // This is a hack to keep tapi happy.

} LINE, *PLINE;

typedef struct _Call
{

    DWORD
    Init(
        IN  HTAPICALL           htCall,
        IN  LPLINECALLPARAMS    const lpCallParams
        );

    void
    SetCallState(
        IN  DWORD   dwCallState,
        IN  DWORD   dwCallStateMode
        );

    DWORD SendMSPStartMessage(
        IN  LPCWSTR lpszDestAddress
        );
    
    DWORD SendMSPStopMessage();

    DWORD           hdLine()        { return m_hdLine; }
    DWORD           dwState()       { return m_dwState; }
    DWORD           dwMediaMode()   { return m_dwMediaMode; }
    DWORD           dwStateMode()   { return m_dwStateMode; }
    HTAPICALL       htCall()        { return m_htCall; }

    DWORD           dwAudioQOSLevel()   { return m_dwAudioQOSLevel; }
    DWORD           dwVideoQOSLevel()   { return m_dwVideoQOSLevel; }

private:

    DWORD           m_hdLine;     // The handle for this line in this provider. 
                                  // It is the offset of the Line structure in 
                                  // a global array.
    HTAPICALL       m_htCall;     // The hadle of this call in TAPI's space. 
    DWORD           m_dwState;    // The state of this call.
    DWORD           m_dwMediaMode;
    DWORD           m_dwStateMode;

    DWORD           m_dwAudioQOSLevel;
    DWORD           m_dwVideoQOSLevel;

} CALL, *PCALL;

const DWORD DELTA = 8;

template <class T, DWORD delta = DELTA>
class SimpleVector
{
public:
    SimpleVector() : m_dwSize(0), m_dwCapacity(0), m_Elements(NULL) {};
    ~SimpleVector() {if (m_Elements) free(m_Elements); }
    
    void Init()
    {
        m_dwSize = 0; 
        m_dwCapacity = 0; 
        m_Elements = NULL; 
    }

    BOOL add(T& elem) 
    { 
        return grow() ? (m_Elements[m_dwSize ++] = elem, TRUE) : FALSE;
    }

    BOOL add()
    {
        return grow() ? (m_dwSize ++, TRUE) : FALSE;
    }

    DWORD size() const { return m_dwSize; }
    T& operator [] (DWORD index) { return m_Elements[index]; }
    const T* elements() const { return m_Elements; };
    void shrink() {if (m_dwSize > 0) m_dwSize --;}
    void reset() 
    { 
        m_dwSize = 0; 
        m_dwCapacity = 0; 
        if (m_Elements) free(m_Elements); 
        m_Elements = NULL; 
    }

protected:
    BOOL grow()
    {
        if (m_dwSize >= m_dwCapacity)
        {
            T *p = (T*)realloc(m_Elements, (sizeof T)*(m_dwCapacity+delta));
            if (p == NULL)
            {
                return FALSE;
            }
            m_Elements = p;
            m_dwCapacity += delta;
        }
        return TRUE;
    }

protected:
    DWORD m_dwSize;
    DWORD m_dwCapacity;
    T *   m_Elements;
};

typedef SimpleVector<CALL *> CCallList;

#endif //__CONFTSP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mdhcp\cmdhcp.cpp ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    CMDhcp.cpp

Abstract:
    Implementation of CMdhcp.

Author:

*/

#include "stdafx.h"

#include <winsock2.h>

#include "mdhcp.h"
#include "CMDhcp.h"
#include "lease.h"
#include "local.h"

// template for collections
#include "collect.h"

// From rendezvous control code:
// sets the first bit to indicate error
// sets the win32 facility code
// this is used instead of the HRESULT_FROM_WIN32 macro
// because that clears the customer flag
inline long
HRESULT_FROM_ERROR_CODE(IN long ErrorCode)
{
    return ( 0x80070000 | (0xa000ffff & ErrorCode) );
}



/////////////////////////////////////////////////////////////////////////////
// Helper functions.
/////////////////////////////////////////////////////////////////////////////

HRESULT CMDhcp::CreateWrappers(
    DWORD                 dwScopeCount, // the number of scopes we were given
    MCAST_SCOPE_ENTRY   * pScopeList,   // array of scope structs
    IMcastScope       *** pppWrappers,  // here we will put an array of if ptrs
    BOOL                  fLocal        // true = scopes are locally generated
    )
{
    LOG((MSP_TRACE, "CMDhcp::CreateWrappers enter"));

    HRESULT hr;

    // Allocate the array of interface pointers.
    typedef IMcastScope * ScopeIfPtr;
    *pppWrappers = new ScopeIfPtr[dwScopeCount];

    if ( (*pppWrappers) == NULL )
    {
        LOG((MSP_ERROR,
            "can't create allocate array of interface pointers"));
        return E_OUTOFMEMORY;
    }

    // For each scope in the list of scopes returned by the C API
    for (DWORD i = 0; i < dwScopeCount; i++)
    {
        // create the com object.
        CComObject<CMDhcpScope> * pMDhcpScope;
        hr = CComObject<CMDhcpScope>::CreateInstance(&pMDhcpScope);

        if ( (FAILED(hr)) || (NULL == pMDhcpScope) )
        {
            LOG((MSP_ERROR, "can't create MDhcpScope Object (%d/%d): %08x",
                i, dwScopeCount, hr));
            // get rid of all previously created COM objects
            for (DWORD j = 0; j < i; j++) (*pppWrappers)[j]->Release();
            delete (*pppWrappers);

            return hr;
        }

        // Get the IMcastScope interface.
        hr = pMDhcpScope->_InternalQueryInterface(
            IID_IMcastScope,
            (void **) (& (*pppWrappers)[i])
            );

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CreateWrappers:QueryInterface (%d/%d) failed: %08x",
                i, dwScopeCount, hr));

            // get rid of all previously created COM objects
            for (DWORD j = 0; j < i; j++) (*pppWrappers)[j]->Release();
            delete (*pppWrappers);

            delete pMDhcpScope; // don't know if it addrefed or not

            return hr;
        }

        // Set the object's info based on the struct. From now on the
        // object will be read-only.
        hr = pMDhcpScope->Initialize(pScopeList[i], fLocal);

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CreateWrappers:Initialize (%d/%d) failed: %08x",
                i, dwScopeCount, hr));
            // get rid of all previously created COM objects
            for (DWORD j = 0; j < i; j++) (*pppWrappers)[j]->Release();
            delete (*pppWrappers);

            pMDhcpScope->Release(); // we know it addrefed in the QI
            return hr;
        }
    }

    LOG((MSP_TRACE, "CMDhcp::CreateWrappers exit"));
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Get a list of scopes from the C API.

HRESULT CMDhcp::GetScopeList(
    DWORD              * pdwScopeCount,
    MCAST_SCOPE_ENTRY ** ppScopeList,
    BOOL               * pfLocal
    )
{
    LOG((MSP_TRACE, "CMDhcp::GetScopeList enter"));

    _ASSERTE( ! IsBadWritePtr(pdwScopeCount, sizeof(DWORD) ) );
    _ASSERTE( ! IsBadWritePtr(ppScopeList, sizeof(MCAST_SCOPE_ENTRY *) ) );

    HRESULT hr;

    DWORD dwScopeLen = 0;   // size in bytes of returned scopes structure
    DWORD dwCode;           // return code

    *pfLocal = FALSE; // try mdhcp first

    dwCode = LocalEnumerateScopes(NULL, // only want to know how many we have
                                  &dwScopeLen,    // # of bytes should be zero
                                  pdwScopeCount,  // # of scopes placed here
                                  pfLocal);

    // This must succeed for us to continue.
    if (dwCode != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_ERROR_CODE(dwCode);
        LOG((MSP_ERROR, "GetScopeList: First C API call failed "
                "(code: %d hresult: %08x)", dwCode, hr));
        return hr;
    }

    do
    {
        // If there are no scopes to choose from, let's not enumerate them.
        // We also need at least the length fields from the first
        // UNICODE_STRING.
        if ( (dwScopeLen < sizeof(MCAST_SCOPE_ENTRY)) || (*pdwScopeCount < 1) )
        {
            LOG((MSP_ERROR, "GetScopeList: don't have enough scopes (%d;%d)",
                    dwScopeLen, *pdwScopeCount));
            return E_FAIL;
        }

        // Now that we know how many there are, allocate an array to hold the
        // scope structs returned by the C method.

        // The API acts very strangely here. We have to give it dwScopeLen
        // bytes as one big chunk. The first dwScopeCount * sizeof(MCAST_SCOPE_ENTRY)
        // bytes contain dwScopeCount MCAST_SCOPE_ENTRY structures. Each of these
        // structures has a pointer to a wide string. The first of these points
        // to the first byte after all the MCAST_SCOPE_ENTRY structures! In this way
        // they avoid doing so many mallocs. We therefore have to
        // copy each string in the COM wrapper for each scope, and then delete
        // this buffer (ppScopeList) all at once after all the wrapping is complete.

        *ppScopeList = (MCAST_SCOPE_ENTRY *) new CHAR[dwScopeLen];

        if (*ppScopeList == NULL)
        {
            LOG((MSP_ERROR, "GetScopeList: not enough memory to allocate scope"
                    " list (size = %d)", dwScopeLen));
            return E_OUTOFMEMORY;
        }

        // *pdwScopeCount still specifies the number of scopes we can get.

        // Now ask for all the scopes.
        dwCode = LocalEnumerateScopes(*ppScopeList,
                                      &dwScopeLen,
                                      pdwScopeCount,
                                      pfLocal);


        // If things changed in this bried time, just try again.
        if (dwCode == ERROR_MORE_DATA)
        {
            LOG((MSP_INFO, "GetScopeList: got more scopes than we were told "
                    "existed (we though there were %d) -- retrying",
                    *pdwScopeCount));
            delete (*ppScopeList);
        }
    }
    while (dwCode == ERROR_MORE_DATA);

    if (dwCode != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_ERROR_CODE(dwCode);
        LOG((MSP_ERROR, "GetScopeList: Second C API call failed "
                "(code: %d hresult: %08x)", dwCode, hr));
        delete (*ppScopeList);
        return hr;
    }

    LOG((MSP_TRACE, "CMDhcp::GetScopeList exit"));
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// This is a private helper method that creates a CMDhcpLeaseInfo object and
// uses it to wrap a lease info structure and request ID into an
// IMcastLeaseInfo interface.

HRESULT CMDhcp::WrapMDhcpLeaseInfo(
    BOOL                fGotTtl,
    long                lTtl,
    BOOL                fLocal,
    MCAST_LEASE_INFO  * pLeaseInfo,
    MCAST_CLIENT_UID  * pRequestID,
    IMcastLeaseInfo  ** ppInterface
    )
{
    LOG((MSP_TRACE, "CMDhcp::WrapMDhcpLeaseInfo enter"));

    // We don't check pLeaseInfo or pRequestID -- they'll be comprehensively
    // checked in the Wrap call below.

    if ( IsBadWritePtr(ppInterface, sizeof(IMcastLeaseInfo *) ) )
    {
        LOG((MSP_ERROR, "WrapMDhcpLeaseInfo: invalid pointer: %x",
            ppInterface));
        
        return E_POINTER;
    }

    HRESULT hr;

    // create the com object.
    CComObject<CMDhcpLeaseInfo> * pMDhcpLeaseInfo;
    hr = CComObject<CMDhcpLeaseInfo>::CreateInstance(&pMDhcpLeaseInfo);

    if ( (FAILED(hr)) || (pMDhcpLeaseInfo == NULL) )
    {
        LOG((MSP_ERROR, "can't create MDhcpLeaseInfo Object."));
        
        return hr;
    }

    // Get the IMcastLeaseInfo interface.
    hr = pMDhcpLeaseInfo->_InternalQueryInterface(
        IID_IMcastLeaseInfo,
        (void **)ppInterface
        );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "WrapMDhcpLeaseInfo:QueryInterface failed: %x", hr));
        
        delete pMDhcpLeaseInfo;

        return hr;
    }

    // Wrap the object in the interface.
    hr = pMDhcpLeaseInfo->Wrap(pLeaseInfo, pRequestID, fGotTtl, lTtl);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "WrapMDhcpLeaseInfo:Wrap failed: %x", hr));
        
        (*ppInterface)->Release();

        return hr;
    }

    hr = pMDhcpLeaseInfo->SetLocal(fLocal);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "WrapMDhcpLeaseInfo: SetLocal failed: %x", hr));
        
        (*ppInterface)->Release();

        return hr;
    }

    LOG((MSP_TRACE, "CMDhcp::WrapMDhcpLeaseInfo exit"));
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// This is a private helper method that munges the arguments into structs
// at the beginning of a Request call.

HRESULT CMDhcp::PrepareArgumentsRequest(
    IN   IMcastScope           * pScope,
    IN   DATE                    LeaseStartTime,
    IN   DATE                    LeaseStopTime,
    IN   long                    lNumAddresses,
    OUT  MCAST_CLIENT_UID      * pRequestIDStruct,
    OUT  MCAST_SCOPE_CTX       * pScopeCtxStruct,
    OUT  MCAST_LEASE_INFO     ** ppLeaseStruct,
    OUT  BOOL                  * pfLocal,
    OUT  long                  * plTtl
    )
{
    LOG((MSP_TRACE, "CMDhcp::PrepareArgumentsRequest enter"));

    _ASSERTE ( ! IsBadReadPtr(pScope, sizeof(IMcastScope) ) );

    _ASSERTE ( ! IsBadWritePtr(pRequestIDStruct, sizeof(MCAST_CLIENT_UID) ) );
    _ASSERTE ( ! IsBadWritePtr(pScopeCtxStruct, sizeof(MCAST_SCOPE_CTX) ) );
    _ASSERTE ( ! IsBadWritePtr(ppLeaseStruct, sizeof(MCAST_LEASE_INFO *) ) );
    _ASSERTE ( ! IsBadWritePtr(pfLocal, sizeof(BOOL) ) );
    _ASSERTE ( ! IsBadWritePtr(plTtl, sizeof(long) ) );

    HRESULT hr;

    //
    // The start time must be less than the stop time.
    //

    if ( LeaseStartTime > LeaseStopTime )
    {
        LOG((MSP_ERROR, "CMDhcp::PrepareArgumentsRequest - "
            "start time is greater than stop time - exit E_INVALIDARG"));

        return E_INVALIDARG;
    }

    //
    // lNumAddresses must be stuffed into a WORD for the C API -- check to see if
    // it's in range.
    //

    if ( ( lNumAddresses < 0 ) || ( lNumAddresses > USHRT_MAX ) )
    {
        LOG((MSP_ERROR, "CMDhcp::PrepareArgumentsRequest - "
            "invalid number of addresses - exit E_INVALIDARG"));

        return E_INVALIDARG;
    }

    //
    // dynamic_cast to get an object pointer from the passed-in interface
    // pointer. This will cause an exception if the user tries to use their
    // own implementation of IMcastScope, which is quite unlikely.
    //

    CMDhcpScope * pCScope = dynamic_cast<CMDhcpScope *>(pScope);

    if (pCScope == NULL)
    {
        LOG((MSP_ERROR, "CMDhcp::PrepareArgumentsRequest - "
            "Unsupported CMDhcpScope object"));

        return E_POINTER;
    }

    //
    // Find out if this scope uses local alloc.
    //

    hr = pCScope->GetLocal(pfLocal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMDhcp::PrepareArgumentsRequest: "
            "GetLocal failed %08x", hr));

        return hr;
    }

    //
    // Find out the ttl to stuff in leases from this scope.
    //

    hr = pCScope->get_TTL( plTtl );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMDhcp::PrepareArgumentsRequest: "
            "get_TTL failed %08x", hr));

        return hr;
    }

    //
    // Get the normal scope info.
    // ScopeID is stored in network byte order but the get_ method
    // returns it in host byte order for the benefit of apps.
    //

    long lScopeID;

    hr = pScope->get_ScopeID( &lScopeID );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMDhcp::PrepareArgumentsRequest - "
           "can't get scope ID from scope object - exit 0x%08x", hr));

        return hr;
    }

    pScopeCtxStruct->ScopeID.IpAddrV4 = htonl(lScopeID);




    hr = pScope->get_ServerID(
                     (long *) &(pScopeCtxStruct->ServerID.IpAddrV4) );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMDhcp::PrepareArgumentsRequest - "
           "can't get server ID from scope object - exit 0x%08x", hr));

        return hr;
    }

    hr = pScope->get_InterfaceID(
                     (long *) &(pScopeCtxStruct->Interface.IpAddrV4) );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMDhcp::PrepareArgumentsRequest - "
           "can't get interface ID from scope object - exit 0x%08x", hr));

        return hr;
    }

    //
    // Allocate space for the client UID.
    //

    pRequestIDStruct->ClientUIDLength = MCAST_CLIENT_ID_LEN;
    pRequestIDStruct->ClientUID = new BYTE[ MCAST_CLIENT_ID_LEN ];

    if ( pRequestIDStruct->ClientUID == NULL )
    {
        LOG((MSP_ERROR, "CMDhcp::PrepareArgumentsRequest: out of memory in "
           "buffer allocation"));
        return E_OUTOFMEMORY;
    }

    //
    // Generate a random client UID.
    //

    DWORD dwResult = McastGenUID( pRequestIDStruct );

    if ( dwResult != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_ERROR_CODE( dwResult );

        LOG((MSP_TRACE, "CMDhcp::PrepareArgumentsRequest: "
            "McastGenUID failed (dw = %d; hr = 0x%08x)", dwResult, hr));

        return hr;
    }

    LOG((MSP_TRACE, "CMDhcp::PrepareArgumentsRequest: before MCAST_LEASE_INFO "
        "alloc; we are asking for %d addresses", lNumAddresses));

    //
    // Allocate the lease info structure.
    // The caller will delete it after the API call.
    // This is a REQUEST, so we do not specify any particular addresses
    // in the array -- we do not need space for them.
    //
    //

    (*ppLeaseStruct) = new MCAST_LEASE_INFO;

    if ( (*ppLeaseStruct) == NULL )
    {
        LOG((MSP_ERROR, "CMDhcp::PrepareArgumentsRequest: out of memory in "
           "MCAST_LEASE_INFO allocation"));
        delete (pRequestIDStruct->ClientUID);
        return E_OUTOFMEMORY;
    }

    //
    // Fill in the times.
    //

    hr = DateToLeaseTime(LeaseStartTime,
                         &((*ppLeaseStruct)->LeaseStartTime));

    if ( FAILED(hr) )
    {
        delete (pRequestIDStruct->ClientUID);
        delete (*ppLeaseStruct);
        return hr;
    }

    hr = DateToLeaseTime(LeaseStopTime,
                         &((*ppLeaseStruct)->LeaseEndTime));

    if ( FAILED(hr) )
    {
        delete (pRequestIDStruct->ClientUID);
        delete (*ppLeaseStruct);
        return hr;
    }

    //
    // Fill in the address info fields.
    //

    (*ppLeaseStruct)->ServerAddress.IpAddrV4 = 0;

    (*ppLeaseStruct)->AddrCount = (WORD) lNumAddresses; // checked above
    
    //
    // This is a REQUEST, so we do not specify any particular addresses
    // in the array -- we make the array NULL.
    //

    (*ppLeaseStruct)->pAddrBuf = NULL;

    LOG((MSP_TRACE, "CMDhcp::PrepareArgumentsRequest exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// This is a private helper method that munges the arguments into structs
// at the beginning of a Renew or Release call.

HRESULT CMDhcp::PrepareArgumentsNonRequest(
    IN   IMcastLeaseInfo       * pLease,
    OUT  MCAST_CLIENT_UID      * pRequestIDStruct,
    OUT  MCAST_LEASE_INFO     ** ppLeaseStruct,
    OUT  BOOL                  * pfLocal,
    OUT  BOOL                  * pfGotTtl,
    OUT  long                  * plTtl
    )
{
    LOG((MSP_TRACE, "CMDhcp::PrepareArgumentsNonRequest enter"));

    if ( IsBadReadPtr(pLease, sizeof(IMcastLeaseInfo) ) )
    {
        LOG((MSP_ERROR, "PrepareArgumentsNonRequest: bad pLease pointer argument"));

        return E_POINTER;
    }

    _ASSERTE ( ! IsBadWritePtr(pRequestIDStruct, sizeof(MCAST_CLIENT_UID) ) );
    _ASSERTE ( ! IsBadWritePtr(ppLeaseStruct, sizeof(MCAST_LEASE_INFO *) ) );
    _ASSERTE ( ! IsBadWritePtr(pfLocal, sizeof(BOOL) ) );
    _ASSERTE ( ! IsBadWritePtr(pfGotTtl, sizeof(BOOL) ) );
    _ASSERTE ( ! IsBadWritePtr(plTtl, sizeof(long) ) );

    HRESULT hr;

    // We approach things in a completely different way here, compared
    // to the other PrepareArguments method -- we use
    // dynamic_cast to get an object pointer from the passed-in interface
    // pointer. This will cause an exception if the user tries to use their
    // own implementation of IMcastRequestID, which is quite unlikely.

    CMDhcpLeaseInfo * pCLease = dynamic_cast<CMDhcpLeaseInfo *>(pLease);

    if (pCLease == NULL)
    {
        LOG((MSP_ERROR, "PrepareArgumentsNonRequest: Unsupported CMDhcpLeaseInfo object"));

        return E_POINTER;
    }

    //
    // Find out if this lease was obtained using local alloc.
    //

    hr = pCLease->GetLocal(pfLocal);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "PrepareArgumentsNonRequest: "
            "GetLocal failed %08x", hr));

        return hr;
    }

    //
    // If the lease had a TTL set, then retrieve it for use in a
    // resulting response. Else just say we don't have a ttl.
    //

    hr = pCLease->get_TTL( plTtl );
    *pfGotTtl = SUCCEEDED(hr);

    //
    // Get our request ID from the lease info object.
    //

    pRequestIDStruct->ClientUIDLength = MCAST_CLIENT_ID_LEN;

    pRequestIDStruct->ClientUID = new BYTE[ MCAST_CLIENT_ID_LEN ];

    if (pRequestIDStruct->ClientUID == NULL)
    {
        LOG((MSP_ERROR, "PrepareArgumentsNonRequest: out of memory in "
           "buffer allocation"));
    
        return E_OUTOFMEMORY;
    }

    hr = pCLease->GetRequestIDBuffer(pRequestIDStruct->ClientUIDLength,
                                     pRequestIDStruct->ClientUID);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "PrepareArgumentsNonRequest: RequestID "
            "GetBuffer failed %08x", hr));
        
        delete (pRequestIDStruct->ClientUID);

        return hr;
    }

    //
    // Get the rest of the stuff, which belongs in the straight lease info
    // structure, from the lease info object.
    //

    // this does a new for us
    hr = pCLease->GetStruct(ppLeaseStruct);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "PrepareArgumentsNonRequest - "
            "failed to grab pLeaseStruct - 0x%08x", hr));
        
        delete (pRequestIDStruct->ClientUID);
    
        return hr;
    }

    LOG((MSP_TRACE, "CMDhcp::PrepareArgumentsNonRequest exit"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// VerifyAndGetArrayBounds
//
// Helper function for variant/safearrays
//
// Array
//      IN Variant that contains a safearray
//
// ppsa
//      OUT safearray returned here
//
// pllBound
//      OUT array lower bound returned here
//
// pluBound
//      OUT array upper bound returned here
//
// RETURNS
//
// verifies that Array contains an array, and returns the array, upper
// and lower bounds.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

static HRESULT
VerifyAndGetArrayBounds(
                        VARIANT Array,
                        SAFEARRAY ** ppsa,
                        long * pllBound,
                        long * pluBound
                       )
{
    LOG((MSP_TRACE, "VerifyAndGetArrayBounds: enter"));

    UINT                uDims;
    HRESULT             hr = S_OK;


    //
    // see if the variant & safearray are valid
    //
    try
    {
        if (!(V_ISARRAY(&Array)))
        {
            if ( Array.vt == VT_NULL )
            {
                //
                // null is usually valid
                //

                *ppsa = NULL;

                LOG((MSP_INFO, "Returning NULL array"));

                return S_FALSE;
            }

            LOG((MSP_ERROR, "Array - not an array"));

            return E_INVALIDARG;
        }

        if ( Array.parray == NULL )
        {
            //
            // null is usually valide
            //
            *ppsa = NULL;

            LOG((MSP_INFO, "Returning NULL array"));

            return S_FALSE;
        }

        *ppsa = V_ARRAY(&Array);

        uDims = SafeArrayGetDim( *ppsa );

    }
    catch(...)
    {
        hr = E_POINTER;
    }


    if (!SUCCEEDED(hr))
    {
        LOG((MSP_ERROR, "Array - invalid array"));

        return hr;
    }


    //
    // verify array
    //
    if ( uDims != 1 )
    {
        if ( uDims == 0 )
        {
            LOG((MSP_ERROR, "Array - has 0 dim"));

            return E_INVALIDARG;
        }
        else
        {
            LOG((MSP_WARN, "Array - has > 1 dim - will only use 1"));
        }
    }


    //
    // Get array bounds
    //
    SafeArrayGetUBound(
                       *ppsa,
                       1,
                       pluBound
                      );

    SafeArrayGetLBound(
                       *ppsa,
                       1,
                       pllBound
                      );

    LOG((MSP_TRACE, "VerifyAndGetArrayBounds: exit"));
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
// CMDhcp::FinalContruct
//
// Parameters
//     none
//
// Return Values
//     S_OK             Success
//     E_OUTOFMEMORY    Not enough memory to create free thread marshaler
//     E_FAIL           We are running the wrong version of dhcpcsvc.dll
//
// Description
//     This is called on construction. It creates the free threaded marshaler
//     and checks if the C API's DLL is the same version that we were compiled
//     with.
//////////////////////////////////////////////////////////////////////////////

HRESULT CMDhcp::FinalConstruct(void)
{
    LOG((MSP_TRACE, "CMDhcp::FinalConstruct - enter"));

    HRESULT hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                & m_pFTM );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMDhcp::FinalConstruct - "
            "failed to create FTM - exit 0x%08x", hr));

        //
        // Now, FinalRelease will get called, and then CoCreate will return
        // failure.
        //

        return hr;
    }

    // Munil uses this as an IN/OUT parameter.
    DWORD dwVersion = MCAST_API_CURRENT_VERSION; // defined in mdhccapi.h
    DWORD dwCode;

    dwCode = McastApiStartup(&dwVersion);

    // dwVersion now contains the actual version of the C API, but we don't
    // really care what it is.

    if (dwCode == ERROR_SUCCESS)
    {
        m_fApiIsInitialized = TRUE;

        LOG((MSP_TRACE, "CMDhcp::FinalConstruct - C API version "
            "is >= our version - exit S_OK"));

        return S_OK;
    }
    else
    {
        LOG((MSP_ERROR, "CMDhcp::FinalConstruct - C API version "
            "is < our version - exit E_FAIL"));

        //
        // Now, FinalRelease will get called, and then CoCreate will return
        // failure.
        //

        return E_FAIL;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// CMDhcp::FinalRelease
//
// Parameters
//     none
//
// Return Values
//     none
//
// Description
//     This is called on destruction. It releases the free threaded marshaler
//     and cleans up the C API instance. Note that it is also called if
//     FinalConstruct failed.
//
//////////////////////////////////////////////////////////////////////////////

void CMDhcp::FinalRelease(void)
{
    LOG((MSP_TRACE, "CMDhcp::FinalRelease - enter"));

    if ( m_pFTM )
    {
        m_pFTM->Release();
    }

    if ( m_fApiIsInitialized )
    {
        McastApiCleanup();
    }

    LOG((MSP_TRACE, "CMDhcp::FinalRelease - exit"));
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// IMcastAddressAllocation
//
// This is the main interface for the MDHCP address allocation.  An
// application will call CoCreateInstance on this interface to create the
// MDHCP client interface object.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// IMcastAddressAllocation::get_Scopes
//
// Parameters
//     pVariant [out] Pointer to a VARIANT that will receive an OLE-standard
//                      Collection of available multicast scopes. Each scope
//                      is an IDispatch pointer to an object that implements
//                      IMcastScope.
//
// Return Values
//     S_OK             Success
//     E_POINTER        The caller passed in an invalid pointer argument
//     E_FAIL           There are no scopes available
//     E_OUTOFMEMORY    Not enough memory to create the required objects
//     other            From MDhcpEnumerateScopes (win32 call)
//
// Description
//     This method is primarily for VB and other scripting languages; C++
//     programmers use EnumerateScopes instead.
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMDhcp::get_Scopes(
        VARIANT * pVariant
        )
{
    LOG((MSP_TRACE, "CMDhcp::get_Scopes enter"));

    // Check argument.
    if ( IsBadWritePtr(pVariant, sizeof(VARIANT) ) )
    {
        LOG((MSP_ERROR, "get_Scopes: invalid pointer passed in "
                "(%08x)", pVariant));
        return E_POINTER;
    }

    DWORD               i;
    DWORD               dwScopeCount = 0;
    MCAST_SCOPE_ENTRY * pScopeList = NULL;
    HRESULT             hr;
    BOOL                fLocal;

    //
    // Grab the scopes from the C API.
    //

    hr = GetScopeList(&dwScopeCount, &pScopeList, &fLocal);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get_Scopes: GetScopeList failed "
                "(hr = %08x)", hr));
        return hr;
    }

    //
    // Now we wrap the array in COM wrappers.
    //

    IMcastScope ** ppWrappers = NULL;

    // this does a new into ppWrappers
    // as well as dwScopeCount individual object instantiations

    hr = CreateWrappers(dwScopeCount,
                        pScopeList,
                        &ppWrappers,
                        fLocal);

    // At this point we've got a bunch of COM objects that contain
    // individual scopes, and so we no longer need the array of
    // scopes. Even if CreateWrappers failed we must get rid of
    // the array of scopes.

    delete pScopeList;

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get_Scopes: CreateWrappers failed "
                "(hr = %08x)", hr));
        return hr;
    }

    //
    // create the collection object - see collect.h
    //

    typedef CTapiIfCollection< IMcastScope * > ScopeCollection;
    CComObject<ScopeCollection> * p;
    hr = CComObject<ScopeCollection>::CreateInstance( &p );

    if ( (FAILED(hr)) || (p == NULL) )
    {
        LOG((MSP_ERROR, "get_Scopes: Could not create CTapiIfCollection "
            "object - return %lx", hr ));

        for (DWORD i = 0 ; i < dwScopeCount; i++) delete ppWrappers[i];
        delete ppWrappers;

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDisp;
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );

    if ( FAILED(hr) )
    {
        // Query interface failed so we don't know that if it addreffed
        // or not.

        LOG((MSP_ERROR, "get_Scopes: QI for IDispatch failed on "
            "ScopeCollection - %lx", hr ));

        delete p;

        //
        // PREFIXBUG 433295 - VLD
        // ppWrappers was allocated into CreateWrappers() method
        // we should deallocate it
        //

        for (DWORD i = 0 ; i < dwScopeCount; i++) delete ppWrappers[i];
        delete ppWrappers;

        return hr;
    }

    // initialize it using an iterator -- pointers to the beginning and
    // the ending element plus one.

    hr = p->Initialize( dwScopeCount,
                        ppWrappers,
                        ppWrappers + dwScopeCount );

    // ZoltanS fixed:
    // We started off by creating and calling QI on each object in
    // CreateWrappers. Then we passed the array of pointers to objects to
    // the Initialize method of the collection object. This method
    // called QI on each object to get each object's IDispatch pointer.
    // So now we are at refcount 2. We now Release() each object and get
    // back to refcount 1 on each object. Of course we must even do this
    // if the initialize failed (in that case to delete them outright).

    for (i = 0; i < dwScopeCount; i++)
    {
        ppWrappers[i]->Release();
    }

    // The array of pointers must now be deleted -- we now store the
    // objects in the collection instead. (or nowhere if initialize failed)

    delete ppWrappers;

    if (FAILED(hr))
    {
        // Initialize has failed -- we assume it did nothing, so we must
        // release all the COM objects ourselves

        LOG((MSP_ERROR, "get_Scopes: Could not initialize "
            "ScopeCollection object - return %lx", hr ));

        p->Release();

        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    LOG((MSP_INFO, "placing IDispatch value %08x in variant", pDisp));

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDisp;

    LOG((MSP_TRACE, "CMDhcp::get_Scopes exit - return %lx", hr ));
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// IMcastAddressAllocation::EnumerateScopes
//
// Parameters
//     ppEnumMcastScope [out] Returns a pointer to a new IEnumMcastScope
//                               object. IEnumMcastScope is a standard
//                               enumerator interface that enumerates
//                               IMcastScope objects.
//
// Return Values
//     S_OK             Success
//     E_POINTER        The caller passed in an invalid pointer argument
//     E_FAIL           There are no scopes available
//     E_OUTOFMEMORY    Not enough memory to create the required objects
//     other            From MDhcpEnumerateScopes (win32 call)
//
// Description
//     This method is primarily for C++ programmers; VB and other scripting
//     languages use get_Scopes instead.
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMDhcp::EnumerateScopes(
        IEnumMcastScope ** ppEnumMcastScope
        )
{
    LOG((MSP_TRACE, "CMDhcp::EnumerateScopes enter"));

    if ( IsBadWritePtr(ppEnumMcastScope, sizeof(IEnumMcastScope *) ) )
    {
        LOG((MSP_ERROR, "EnumerateScopes: bad pointer argument "
                "(%08x)", ppEnumMcastScope));
        return E_POINTER;
    }

    DWORD               dwScopeCount = 0;
    MCAST_SCOPE_ENTRY * pScopeList = NULL;
    HRESULT             hr;
    BOOL                fLocal;

    //
    // Grab the scopes from the C API.
    //

    hr = GetScopeList(&dwScopeCount, &pScopeList, &fLocal);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "EnumerateScopes: GetScopeList failed "
                "(hr = %08x)", hr));
        return hr;
    }

    //
    // Now we wrap the array in COM wrappers.
    //

    IMcastScope ** ppWrappers = NULL;

    // this does a new into ppWrappers
    hr = CreateWrappers(dwScopeCount,
                        pScopeList,
                        &ppWrappers,
                        fLocal);

    // At this point we've got a bunch of COM objects that contain
    // individual scopes, and so we no longer need the array of
    // scopes. Even if CreateWrappers failed we must get rid of
    // the array of scopes.

    delete pScopeList;

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "EnumerateScopes: CreateWrappers failed "
                "(hr = %08x)", hr));
        return hr;
    }

    //
    // Now we create and set up the enumerator.
    //

    typedef _CopyInterface<IMcastScope> CCopy;
    typedef CSafeComEnum<IEnumMcastScope, &IID_IEnumMcastScope,
        IMcastScope *, CCopy> CEnumerator;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = CComObject<CEnumerator>::CreateInstance(&pEnum);
    if ((FAILED(hr)) || (pEnum == NULL))
    {
        LOG((MSP_ERROR, "Couldn't create enumerator object: %08x", hr));
        delete ppWrappers;
        return hr;
    }

    // Get the IEnumMcastScope interface.
    hr = pEnum->_InternalQueryInterface(
        IID_IEnumMcastScope,
        (void **)ppEnumMcastScope
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "QI on enumerator object failed: %08x", hr));
        delete ppWrappers;

        delete pEnum;

        return hr;
    }

    // This takes ownership of the wrapper list so we will no longer
    // delete the wrapper list if this succeeds.
    hr = pEnum->Init(ppWrappers, ppWrappers + dwScopeCount, NULL,
                     AtlFlagTakeOwnership);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Init enumerator object failed: %08x", hr));
        delete ppWrappers;
        pEnum->Release();
        return hr;
    }

    LOG((MSP_TRACE, "CMDhcp::EnumerateScopes exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// IMcastAddressAllocation::RequestAddress
//
// Parameters
//     pScope          [in]  This identifies the multicast scope from which
//                             the application wants to be given an address.
//                             The application first calls get_Scopes or
//                             EnumerateScopes to obtain a list of available
//                             scopes.
//     LeaseStartTime  [in]  Requested time for the lease on these addresses
//                             to start / begin. The start time that is
//                             actually granted may be different.
//     LeaseStopTime   [in]  Requested time for the lease on these addresses
//                             to stop / end. The stop time that is actually
//                             granted may be different.
//     NumAddresses    [in]  The number of addresses requested. Fewer
//                             addresses may actually be granted. NOTE:
//                             although these COM interfaces and their
//                             implementation support allocation of multiple
//                             addresses at a time, this is not currently
//                             supported by the underlying Win32 calls. You
//                             may need to use a loop instead.
//     ppLeaseResponse [out] Pointer to an interface pointer that will be set
//                             to point to a new IMcastLeaseInfo object. This
//                             interface can then be used to discover the
//                             actual attributes of the granted lease. See
//                             below for a description of IMcastScope.
//
// Return Values
//     S_OK            Success
//     E_POINTER       The caller passed in an invalid pointer argument
//     E_OUTOFMEMORY   Not enough memory to create the required objects
//     E_INVALIDARG    Requested too many addresses, format conversion
//                     failed for the start time or stop time, or the stop
//                     time is less than the start time
//     other           From MdhcpRequestAddress (win32 call)
//
// Description
//     Call this method to obtain a new lease for one or more multicast
//     addresses. You will first need to call EnumerateScopes or get_Scopes,
//     as well as CreateMDhcpRequestID.
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMDhcp::RequestAddress(IMcastScope      * pScope,
                                    DATE               LeaseStartTime,
                                    DATE               LeaseStopTime,
                                    long               NumAddresses,
                                    IMcastLeaseInfo ** ppLeaseResponse)
{
    LOG((MSP_TRACE, "CMDhcp::RequestAddress enter: asking for %d addresses",
        NumAddresses));

    if ( IsBadReadPtr( pScope, sizeof(IMcastScope) ) )
    {
        LOG((MSP_ERROR, "CMDhcp::RequestAddress - "
            "bad scope pointer - exit E_POINTER"));

        return E_POINTER;
    }

    // no need to check ppLeaseResponse -- WrapMDhcpLeaseInfo handles it

    MCAST_CLIENT_UID   requestID;
    MCAST_SCOPE_CTX    scopeCtx;
    MCAST_LEASE_INFO * pLeaseRequest;
    HRESULT            hr;
    BOOL               fLocal;
    long               lTtl;

    // Munge input arguments into three structs for passing to the C API.
    // pLeaseRequest and requestID->ClientUID are allocated. We must delete them when
    // we're done.
    hr = PrepareArgumentsRequest(pScope,         // goes into scopeCtx
                                 LeaseStartTime, // goes into leaseRequest
                                 LeaseStopTime,  // goes into leaseRequest
                                 NumAddresses,   // goes into leaseRequest
                                 &requestID,     // we generate it
                                 &scopeCtx,
                                 &pLeaseRequest,
                                 &fLocal,
                                 &lTtl
                                );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMDHcp::RequestAddress - "
            "PrepareArgumentsRequest failed - exit 0x%08x", hr));

        return hr;
    }


    MCAST_LEASE_INFO * pLeaseResponse = (MCAST_LEASE_INFO *) new BYTE
        [ sizeof(MCAST_LEASE_INFO) + sizeof(DWORD) * NumAddresses ];

    if (pLeaseResponse == NULL)
    {
        LOG((MSP_ERROR, "RequestAddress: out of memory in response alloc"));
        delete requestID.ClientUID;
        delete pLeaseRequest;
        return E_OUTOFMEMORY;
    }

    DWORD dwCode;

    dwCode = LocalRequestAddress(fLocal,
                                 &requestID,
                                 &scopeCtx,
                                 pLeaseRequest,
                                 pLeaseResponse);

    // No matter what, we no longer need this.
    delete pLeaseRequest;

    if (dwCode != ERROR_SUCCESS)
    {
        LOG((MSP_ERROR, "RequestAddress: C API call failed "
            "(code = %d)", dwCode));
        delete requestID.ClientUID;
        delete pLeaseResponse;
        return HRESULT_FROM_ERROR_CODE(dwCode);
    }

    // Wrap the lease response, along with the requestID, in an interface
    // and return it.
    // The wrapper assumes ownership of the lease structure and
    // requestID.clientuid.

    hr = WrapMDhcpLeaseInfo(TRUE,
                            lTtl,
                            fLocal,
                            pLeaseResponse,
                            &requestID,
                            ppLeaseResponse);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "RequestAddress: WrapMDhcpLeaseInfo failed "
            "(hr = %08x)", hr));
        
        delete pLeaseResponse;
        delete requestID.ClientUID;

        return hr;
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// IMcastAddressAllocation::RenewAddress
//
// Parameters
//     pRenewRequest   [in]  Pointer to an IMcastLeaseInfo object specifying
//                             the attributes of the requested renewal, such
//                             as which address(es) to renew. This is
//                             obtained by calling CreateLeaseInfo.
//     ppRenewResponse [out] Pointer to an interface pointer that will be set
//                             to point to a new IMcastLeaseInfo object. This
//                             interface can then be used to discover the
//                             attributes of the renewed lease. See below for
//                             a description of IMcastScope.
//
// Return Values
//     S_OK			Success
//     E_OUTOFMEMORY	Not enough memory to create the required objects
//     E_POINTER		The caller passed in an invalid pointer argument
//     E_INVALIDARG     Start time is greater than stop time
//     other			From MdhcpRenewAddress (win32 call)
//
// Description
//     To renew a lease, call CreateLeaseInfo to specify the parameters of
//     the renewal request, and then call this method to make the request.
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMDhcp::RenewAddress(
        long                        lReserved, // unused
        IMcastLeaseInfo           * pRenewRequest,
        IMcastLeaseInfo          ** ppRenewResponse
        )
{
    LOG((MSP_TRACE, "CMDhcp::RenewAddress enter"));

    // no need to check pRequestID or pRenewRequest --
    // PrepareArgumentsNonRequest handles that.
    // ppRenewResponse check handled by WrapMDhcpLeaseInfo

    MCAST_CLIENT_UID   requestID;
    MCAST_LEASE_INFO * pRenewRequestStruct;
    HRESULT            hr;
    BOOL               fLocal;
    BOOL               fGotTtl;
    long               lTtl;

    // Munge input arguments into three structs for passing to the C API.
    // pLeaseRequest and requestID->ClientUID are allocated. We must delete them when
    // we're done.
    hr = PrepareArgumentsNonRequest(pRenewRequest,
                                    &requestID,
                                    &pRenewRequestStruct,
                                    &fLocal,
                                    &fGotTtl,
                                    &lTtl);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "RenewAddress: PrepareArgumentsNonRequest failed "
            "(hr = %08x)", hr));

        return hr;
    }

    //
    // Check that the start time is less than the stop time
    //

    if ( pRenewRequestStruct->LeaseStartTime >
         pRenewRequestStruct->LeaseEndTime )
    {
        LOG((MSP_ERROR, "PrepareArgumentsNonRequest - "
            "start time %d is greater than stop time %d - exit E_INVALIDARG",
            pRenewRequestStruct->LeaseStartTime,
            pRenewRequestStruct->LeaseEndTime));

        delete requestID.ClientUID;
        delete pRenewRequestStruct;

        return E_INVALIDARG;
    }


    MCAST_LEASE_INFO * pRenewResponse = (MCAST_LEASE_INFO *) new BYTE
        [ sizeof(MCAST_LEASE_INFO) +
          sizeof(DWORD) * pRenewRequestStruct->AddrCount ];

    if ( pRenewResponse == NULL )
    {
        LOG((MSP_ERROR, "RenewAddress: out of memory in response alloc"));

        delete requestID.ClientUID;
        delete pRenewRequestStruct;

        return E_OUTOFMEMORY;
    }

    DWORD dwCode = LocalRenewAddress(fLocal,
                                     &requestID,
                                     pRenewRequestStruct,
                                     pRenewResponse);

    //
    // We have performed the renew request so we no longer need the struct
    // for the request, even if the request failed.
    //

    delete pRenewRequestStruct;

    if ( dwCode != ERROR_SUCCESS )
    {
        LOG((MSP_ERROR, "RenewAddress: C API call failed "
            "(code = %d)", dwCode));

        delete requestID.ClientUID;
        delete pRenewResponse;

        return HRESULT_FROM_ERROR_CODE(dwCode);
    }

    //
    // Wrap pRenewResponse and the requestID in an interface and return it.
    // the wrapper takes ownership of the requestID.clientUID and the
    // response struct
    //

    hr = WrapMDhcpLeaseInfo(fGotTtl,
                            lTtl,
                            fLocal,
                            pRenewResponse,
                            &requestID,
                            ppRenewResponse);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "RenewAddress: WrapMDhcpLeaseInfo failed "
            "(hr = %08x)", hr));

        delete requestID.ClientUID;
        delete pRenewResponse;

        return hr;
    }

    LOG((MSP_TRACE, "CMDhcp::RenewAddress exit"));

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// IMcastAddressAllocation::ReleaseAddress
//
// Parameters
//     pReleaseRequest [in] Pointer to an IMcastLeaseInfo object specifying
//                            the which address(es) to release. This is
//                            returned from a previous RequestAddress call or
//                            obtained by calling CreateLeaseInfo.
//
// Return Values
//     S_OK             Success
//     E_POINTER        The caller passed in an invalid pointer argument
//     E_OUTOFMEMORY    Not enough memory to make the request
//     other            From MdhcpReleaseAddress (win32 call)
//
// Description
//     Use this method to release a lease that was obtained previously.
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMDhcp::ReleaseAddress(
        IMcastLeaseInfo  * pReleaseRequest
        )
{
    LOG((MSP_TRACE, "CMDhcp::ReleaseAddress enter"));

    // no need to check pReleaseRequest --
    // PrepareArgumentsNonRequest handles that.

    MCAST_CLIENT_UID   requestID;
    MCAST_LEASE_INFO * pReleaseRequestStruct;
    HRESULT            hr;
    BOOL               fLocal;
    BOOL               fGotTtl; // unused after call
    long               lTtl;    // unused after call

    hr = PrepareArgumentsNonRequest(pReleaseRequest,
                                    &requestID,
                                    &pReleaseRequestStruct,
                                    &fLocal,
                                    &fGotTtl,
                                    &lTtl
                                    );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "ReleaseAddress: PrepareArgumentsNonRequest failed "
            "(hr = %08x)", hr));
        return hr;
    }

    DWORD dwCode;
    dwCode = LocalReleaseAddress(fLocal,
                                 &requestID,
                                 pReleaseRequestStruct);

    //
    // These were allocated by PrepareArgumentsNonRequest and there is no one
    // to own them now -- we delete them. This is true even if the
    // LocalReleaseAddress call failed.
    //

    delete pReleaseRequestStruct;
    delete requestID.ClientUID;

    if ( dwCode != ERROR_SUCCESS )
    {
        LOG((MSP_ERROR, "ReleaseAddress: C API call failed "
            "(code = %d)", dwCode));

        return HRESULT_FROM_ERROR_CODE(dwCode);
    }

    LOG((MSP_TRACE, "CMDhcp::ReleaseAddress exit"));

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// IMcastAddressAllocation::CreateLeaseInfo
//
// Parameters
//     LeaseStartTime    [in] The start time of the lease.
//     LeaseStopTime     [in] The stop time of the lease.
//     dwNumAddresses    [in] The number of addresses associated with the
//                               lease.
//     ppAddresses       [in] An array of LPWSTRs of size dwNumAddresses. Each
//                               LPWSTR (Unicode string pointer) is an IPv4
//                               address in "dot-quad" notation; e.g.
//                               "123.234.12.17".
//     pRequestID        [in] An LPWSTR (Unicode string pointer) specifying
//                               the request ID for the original request.
//     pServerAddress    [in] An LPWSTR (Unicode string pointer) specifying
//                               the address of the server that granted the
//                               original request. This address is an IPv4
//                               address in "dot quad" notation; e.g.
//                               "123.234.12.17".
//     ppReleaseRequest  [out] Returns a pointer to the IMcastLeaseInfo
//                               interface on the newly created lease
//                               information object.
//
// Return Values
//     S_OK             Success
//     E_POINTER        The caller passed in an invalid pointer argument
//     E_OUTOFMEMORY    Not enough memory to create the required objects
//     E_INVALIDARG     An error occured during the date format conversion
//
// Description
//     Use this method to create a lease information object for a subsequent
//     RenewAddress or ReleaseAddress call. This method is primarily for C++
//     programmers; VB and other scripting languages use
//     CreateLeaseInfoFromVariant instead.
//     The dwNumAddresses, ppAddresses, pRequestID, and pServerAddress
//     parameters are normally obtained by calling the corresponding
//     IMcastLeaseInfo methods on the lease info object corresponding to the
//     original request. These values should be saved in persistent storage
//     between executions of the application program. If you are renewing or
//     releasing a lease that was requested during the same run of the
//     application, you have no reason to use CreateLeaseInfo; just pass the
//     existing IMcastLeaseInfo pointer to RenewAddress or ReleaseAddress.
//////////////////////////////////////////////////////////////////////////////
#include <atlwin.cpp>

STDMETHODIMP CMDhcp::CreateLeaseInfo(
        DATE               LeaseStartTime,
        DATE               LeaseStopTime,
        DWORD              dwNumAddresses,
        LPWSTR *           ppAddresses,
        LPWSTR             pRequestID,
        LPWSTR             pServerAddress,
        IMcastLeaseInfo ** ppReleaseRequest
        )
{
    LOG((MSP_TRACE, "CMDhcp::CreateLeaseInfo enter"));

    if ( IsBadWritePtr(ppReleaseRequest, sizeof(IMcastLeaseInfo *) ) )
    {
        LOG((MSP_ERROR, "CMDhcp::CreateLeaseInfo - "
            "invalid lease return pointer: 0x%08x - exit E_POINTER",
            ppReleaseRequest));
        
        return E_POINTER;
    }

    if ( IsBadStringPtr(pRequestID, (UINT) -1 ) )
    {
        LOG((MSP_ERROR, "CMDhcp::CreateLeaseInfo - "
            "invalid RequestID pointer: 0x%08x - exit E_POINTER",
            pRequestID));

        return E_POINTER;
    }

    if ( ( dwNumAddresses < 1 ) || ( dwNumAddresses > USHRT_MAX ) )
    {
        LOG((MSP_ERROR, "CMDhcp::CreateLeaseInfo - "
            "invalid number of addresses: %d - exit E_INVALIDARG",
            dwNumAddresses));

        return E_INVALIDARG;
    }

    if (IsBadReadPtr(ppAddresses, sizeof(LPWSTR) * dwNumAddresses) )
    {
        LOG((MSP_ERROR, "CMDhcp::CreateLeaseInfo - "
            "invalid addresses array pointer: 0x%08x - exit E_POINTER",
            ppAddresses));

        return E_POINTER;
    }

    if ( IsBadStringPtr(pServerAddress, (UINT) -1 ) )
    {
        LOG((MSP_ERROR, "CreateLeaseInfo: invalid Server Address pointer: %08x",
            pRequestID));
        return E_POINTER;
    }

    HRESULT hr;

    // create the com object.
    CComObject<CMDhcpLeaseInfo> * pMDhcpLeaseInfo;
    hr = CComObject<CMDhcpLeaseInfo>::CreateInstance(&pMDhcpLeaseInfo);

    if ( (FAILED(hr)) || (pMDhcpLeaseInfo == NULL) )
    {
        LOG((MSP_ERROR, "CreateLeaseInfo: can't create MDhcpLeaseInfo Object."));
        return hr;
    }

    // Get the IMcastLeaseInfo interface.
    hr = pMDhcpLeaseInfo->_InternalQueryInterface(
        IID_IMcastLeaseInfo,
        (void **)ppReleaseRequest
        );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CreateLeaseInfo: QueryInterface failed: %x", hr));
        delete pMDhcpLeaseInfo;
        return hr;
    }

    // Fill in the object with the stuff the user wanted.
    hr = pMDhcpLeaseInfo->Initialize(LeaseStartTime,
                                     LeaseStopTime,
                                     dwNumAddresses,
                                     ppAddresses,
                                     pRequestID,
                                     pServerAddress);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CreateLeaseInfo: Initialize failed: %x", hr));
        delete pMDhcpLeaseInfo;
        return hr;
    }

    LOG((MSP_TRACE, "CMDhcp::CreateLeaseInfo exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// IMcastAddressAllocation::CreateLeaseInfoFromVariant
//
// Parameters
//     LeaseStartTime   [in] The start time of the lease.
//     LeaseStopTime    [in] The stop time of the lease.
//     vAddresses       [in] A VARIANT containing a SafeArray of BSTRs. Each
//                              BSTR (size-tagged Unicode string pointer) is
//                              an IPv4 address in "dot-quad" notation; e.g.
//                              "123.234.12.17".
//     pRequestID       [in] A BSTR (size-tagged Unicode string pointer)
//                              specifying the request ID for the original
//                              request.
//     pServerAddress   [in]  A BSTR (size-tagged Unicode string pointer)
//                              specifying the address of the server that
//                              granted the original request. This address is
//                              an IPv4 address in "dot quad" notation; e.g.
//                              "123.234.12.17".
//     ppReleaseRequest [out] Returns a pointer to the IMcastLeaseInfo
//                              interface on the newly created lease
//                              information object.
//
// Return Values
//     S_OK             Success
//     E_POINTER        The caller passed in an invalid pointer argument
//     E_OUTOFMEMORY    Not enough memory to create the required objects
//     E_INVALIDARG     An error occured during the date format conversion
//
// Description
//     Use this method to create a lease information object for a subsequent
//     RenewAddress or ReleaseAddress call. This method is primarily for VB
//     and other scripting languages; C++ programmers should use
//     CreateLeaseInfo instead.
//     The dwNumAddresses, ppAddresses, pRequestID, and pServerAddress
//     parameters are normally obtained by calling the corresponding
//     IMcastLeaseInfo methods on the lease info object corresponding to the
//     original request. These values should be saved in persistent storage
//     between executions of the application program. If you are renewing or
//     releasing a lease that was requested during the same run of the
//     application, you have no reason to use CreateLeaseInfoFromVariant; just
//     pass the existing IMcastLeaseInfo pointer to RenewAddress or
//     ReleaseAddress.
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMDhcp::CreateLeaseInfoFromVariant(
        DATE                        LeaseStartTime,
        DATE                        LeaseStopTime,
        VARIANT                     vAddresses,
        BSTR                        pRequestID,
        BSTR                        pServerAddress,
        IMcastLeaseInfo          ** ppReleaseRequest
        )
{
    LOG((MSP_TRACE, "CMDhcp::CreateLeaseInfoFromVariant enter"));

    // We will check the pointers in CreateLeaseInfo.

    HRESULT hr;

    // Get from the variant:
    DWORD    dwNumAddresses;
    LPWSTR * ppAddresses;

    SAFEARRAY * psaAddresses = NULL;  // SafeArray with the addresses
    long        lLowerBound = 0;      // lower bound of safearray
    long        lUpperBound = 0;      // upper bound of safearray

    hr = VerifyAndGetArrayBounds(
                        vAddresses,
                        &psaAddresses,
                        &lLowerBound,
                        &lUpperBound);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMDhcp::CreateLeaseInfoFromVariant: invalid "
            "VARIANT"));
        return E_INVALIDARG;
    }

    // This is how many addresses we *expect* (may have fewer).
    long lAddrCount = lUpperBound - lLowerBound + 1;

    if (lAddrCount < 1)
    {
        LOG((MSP_ERROR, "CMDhcp::CreateLeaseInfoFromVariant: too few "
            "addresses (check #1) (%d)", lAddrCount));
        return E_INVALIDARG;
    }

    // We allocate as many as we are told to expect, but some of this
    // space may end up getting "wasted" if there are fewer valid ones
    // after all.

    ppAddresses = new LPWSTR[lAddrCount];

    if (ppAddresses == NULL)
    {
        LOG((MSP_ERROR, "CMDhcp::CreateLeaseInfoFromVariant: "
            "out of memory in array allocation"));
        return E_OUTOFMEMORY;
    }

    long lCurrSrc;      // the current element in the safearray      (source)
    long lCurrDest = 0; // the current element in the struct's array (destination)

    // Get the addresses from the SafeArray and put them in our array.
    for (lCurrSrc = lLowerBound; lCurrSrc <= lUpperBound; lCurrSrc++)
    {
        hr = SafeArrayGetElement(
                                 psaAddresses,
                                 &lCurrSrc,
                                 & ( ppAddresses[lCurrDest] )
                                );


        if ( FAILED(hr) )
        {
            LOG((MSP_INFO, "CMDhcp::CreateLeaseInfoFromVariant: "
                "failed to get safearray element %d"
                " - skipping (array range %d-%d)",
                lCurrSrc, lLowerBound, lUpperBound));
        }
        else if ( ppAddresses[lCurrDest] == 0 )
        {
            LOG((MSP_INFO, "CMDhcp::CreateLeaseInfoFromVariant: "
                "got ZERO address from safearray "
                "element %d - skipping (array range %d-%d)",
                lCurrSrc, lLowerBound, lUpperBound));
        }
        else
        {
            // We got an element.
            lCurrDest++;
        }
    }

    // note the number of addresses we actually placed in the array
    dwNumAddresses = (DWORD) lCurrDest;

    if (dwNumAddresses < 1)
    {
        LOG((MSP_ERROR, "CMDhcp::CreateLeaseInfoFromVariant: "
            "too few addresses (check #2)"
            "(%d)", lAddrCount));
        delete ppAddresses;
        return E_INVALIDARG;
    }

    hr = CreateLeaseInfo(LeaseStartTime,
                         LeaseStopTime,
                         dwNumAddresses,
                         ppAddresses,
                         pRequestID,
                         pServerAddress,
                         ppReleaseRequest
                        );

    // No matter what, we no longer need this.
    delete ppAddresses;

    if (FAILED(hr))
    {
        LOG((MSP_TRACE, "CMDhcp::CreateLeaseInfoFromVariant : "
            "CreateLeaseInfo returned %08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CMDhcp::CreateLeaseInfoFromVariant exit"));
    return S_OK;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mdhcp\collect.h ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    collect.h

Abstract:

Author:

*/

#ifndef _MDHCP_COLLECTION_H_
#define _MDHCP_COLLECTION_H_

#include "mdhcp.h"
#include "tapi3if.h"
#include "resource.h"       // main symbols

#include <mspenum.h> // for CSafeComEnum

EXTERN_C const IID LIBID_TAPI3Lib;

////////////////////////////////////////////////////////////////////////
// CTapiIfCollection -- adapter from tapi3 code
//      Collection template for collections of IDispatch interfaces
//
////////////////////////////////////////////////////////////////////////

template <class T> class CTapiIfCollection :
    public CComDualImpl<ITCollection, &IID_ITCollection, &LIBID_TAPI3Lib>,
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public CObjectSafeImpl
{
public:

    typedef CTapiIfCollection<T> _CTapiCollectionBase;
    
    BEGIN_COM_MAP(_CTapiCollectionBase)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ITCollection)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
    END_COM_MAP()

    DECLARE_GET_CONTROLLING_UNKNOWN()

private:

    int                 m_nSize;
    CComVariant *       m_Var;
    IUnknown    *       m_pFTM;     // Pointer to the free threaded marshaler.
    
public:

    CTapiIfCollection(void) : m_nSize(0), m_Var(NULL), m_pFTM(NULL) { }

    // initialize
    HRESULT STDMETHODCALLTYPE Initialize(
                                         DWORD dwSize,
                                         T * pBegin,
                                         T * pEnd                                         
                                        )
    {
        int                     i;
        HRESULT                 hr;
        T *                     iter;

        LOG((MSP_TRACE, "CTapiIfCollection::Initialize - enter"));

        hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                            & m_pFTM );

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CTapiIfCollection::Initialize: "
                          "create FTM failed 0x%08x", hr));

            return hr;
        }


        // create variant array
        m_nSize = dwSize;

        m_Var = new CComVariant[m_nSize];
        
        if ( m_Var == NULL )
        {
            LOG((MSP_ERROR, "CTapiIfCollection::Initialize: "
                          "array creation failed - exit E_OUTOFMEMORY"));

            return E_OUTOFMEMORY;
        }

        i = 0;

        for (iter = pBegin; iter != pEnd; iter++)
        {
            // get IDispatch pointer
            IDispatch * pDisp = NULL;

            hr = (*iter)->QueryInterface(IID_IDispatch, (void**)&pDisp);

            if (hr != S_OK)
            {
                return hr;
            }

            // create a variant and add it to the collection
            CComVariant& var = m_Var[i];

            VariantInit(&var);
            
            var.vt = VT_DISPATCH;
            var.pdispVal = pDisp;

            i++;
        }

        LOG((MSP_TRACE, "CTapiIfCollection::Initialize - exit"));
        
        return S_OK;
    }

    void FinalRelease()
    {
        LOG((MSP_TRACE, "CTapiIfCollection::FinalRelease - enter"));

        delete [] m_Var;

        if ( m_pFTM )
        {
            m_pFTM->Release();
        }

        LOG((MSP_TRACE, "CTapiIfCollection::FinalRelease - exit"));
    }
    
    STDMETHOD(get_Count)(
                         long* retval
                        )
    {
        LOG((MSP_TRACE, "CTapiIfCollection::get_Count - enter"));

        if ( IsBadWritePtr(retval, sizeof(long) ) )
        {
            LOG((MSP_ERROR, "CTapiIfCollection::get_Count - exit E_POINTER"));

            return E_POINTER;
        }

        *retval = m_nSize;

        LOG((MSP_TRACE, "CTapiIfCollection::get_Count - exit S_OK"));

        return S_OK;
    }

    STDMETHOD(get_Item)(
                                       long Index, 
                                       VARIANT* retval
                                      )
    {
        LOG((MSP_TRACE, "CTapiIfCollection::get_Item - enter"));
        
        if ( IsBadWritePtr(retval, sizeof(VARIANT) ) )
        {
            LOG((MSP_ERROR, "CTapiIfCollection::get_Item - exit E_POINTER"));

            return E_POINTER;
        }

        VariantInit(retval);

        retval->vt = VT_UNKNOWN;
        retval->punkVal = NULL;

        // use 1-based index, VB like
        if ((Index < 1) || (Index > m_nSize))
        {
            LOG((MSP_ERROR, "CTapiIfCollection::get_Item - exit E_INVALIDARG"));

            return E_INVALIDARG;
        }

        VariantCopy(retval, &m_Var[Index-1]);

        LOG((MSP_TRACE, "CTapiIfCollection::get_Item - exit S_OK"));
        
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE get__NewEnum(
                                           IUnknown** retval
                                          )
    
    {
        HRESULT         hr;

        LOG((MSP_TRACE, "CTapiIfCollection::new__Enum - enter"));
        
        if (retval == NULL)
        {
            return E_POINTER;
        }

        *retval = NULL;

        typedef CComObject<CSafeComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT> > > enumvar;

        enumvar* p; // = new enumvar;
        hr = enumvar::CreateInstance( &p );

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CTapiIfCollection::get__NewEnum: "
                          "enum creation failed - exit 0x%08x", hr));

            return hr;
        }


        hr = p->Init(&m_Var[0], &m_Var[m_nSize], NULL, AtlFlagCopy);

        if (SUCCEEDED(hr))
        {
            hr = p->QueryInterface(IID_IEnumVARIANT, (void**)retval);
        }

        if (FAILED(hr))
        {
            delete p;
        }

        LOG((MSP_TRACE, "CTapiIfCollection::new__Enum - exit"));
        
        return hr;

    }
};

////////////////////////////////////////////////////////////////////////
// CTapiBstrCollection -- adapter from tapi3 code
//    Collection of BSTRs.
////////////////////////////////////////////////////////////////////////
class CTapiBstrCollection :
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public CComDualImpl<ITCollection, &IID_ITCollection, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:
    
    BEGIN_COM_MAP(CTapiBstrCollection)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ITCollection)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
    END_COM_MAP()

    DECLARE_GET_CONTROLLING_UNKNOWN()

private:

    DWORD               m_dwSize;
    CComVariant *       m_Var;
    IUnknown    *       m_pFTM;     // Pointer to the free threaded marshaler.
    
public:

    CTapiBstrCollection(void) : m_dwSize(0), m_Var(NULL), m_pFTM(NULL) { }

    // initialize
    HRESULT STDMETHODCALLTYPE Initialize(
                                         DWORD dwSize,
                                         BSTR * pBegin,
                                         BSTR * pEnd                                         
                                        )
    {
        BSTR *  i;
        HRESULT hr;
        DWORD   dw = 0;

        LOG((MSP_TRACE, "CTapiBstrCollection::Initialize - enter"));

        hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                            & m_pFTM );

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CTapiBstrCollection::Initialize: "
                          "create FTM failed 0x%08x", hr));

            return hr;
        }

        // create variant array
        m_dwSize = dwSize;

        m_Var = new CComVariant[m_dwSize];

        if ( m_Var == NULL )
        {
            LOG((MSP_ERROR, "CTapiBstrCollection::Initialize - exit E_OUTOFMEMORY"));

            return E_OUTOFMEMORY;
        }

        for (i = pBegin; i != pEnd; i++)
        {
            // create a variant and add it to the collection
            CComVariant& var = m_Var[dw];

            var.vt = VT_BSTR;
            var.bstrVal = *i;

            dw++;
        }

        LOG((MSP_TRACE, "CTapiBstrCollection::Initialize - exit"));
        
        return S_OK;
    }
    
    STDMETHOD(get_Count)(
                         long* retval
                        )
    {
        LOG((MSP_TRACE, "CTapiBstrCollection::get_Count - enter"));        

        if ( IsBadWritePtr(retval, sizeof(long) ) )
        {
            LOG((MSP_ERROR, "CTapiBstrCollection::get_Count - exit E_POINTER"));

            return E_POINTER;
        }


        *retval = m_dwSize;

        LOG((MSP_TRACE, "CTapiBstrCollection::get_Count - exit S_OK"));
        
        return S_OK;
    }

    STDMETHOD(get_Item)(
                        long Index, 
                        VARIANT* retval
                       )
    {
        LOG((MSP_TRACE, "CTapiBstrCollection::get_Item - enter"));
        
        if ( IsBadWritePtr(retval, sizeof(VARIANT) ) )
        {
            LOG((MSP_ERROR, "CTapiBstrCollection::get_Item - exit E_POINTER"));

            return E_POINTER;
        }


        VariantInit(retval);

        retval->vt = VT_BSTR;
        retval->bstrVal = NULL;

        // use 1-based index, VB like
        // ZoltanS: no problem with signed/unsigned, since
        // if Index < 0 then first clause is true, making it
        // irrelevant if the second clause is correct or not.

        if ((Index < 1) || ( (DWORD) Index > m_dwSize))
        {
            LOG((MSP_ERROR, "CTapiBstrCollection::get_Item - exit E_INVALIDARG"));

            return E_INVALIDARG;
        }

        //
        // This copies the string, not just the pointer.
        //

        VariantCopy(retval, &m_Var[Index-1]);

        LOG((MSP_TRACE, "CTapiBstrCollection::get_Item - exit S_OK"));

        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE get__NewEnum(
                                           IUnknown** retval
                                          )
    
    {
        HRESULT         hr;

        LOG((MSP_TRACE, "CTapiBstrCollection::get__NumEnum - enter"));
        
        if (retval == NULL)
        {
            return E_POINTER;
        }

        *retval = NULL;

        typedef CComObject<CSafeComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT> > > enumvar;

        enumvar* p = new enumvar;

        if ( p == NULL )
        {
            LOG((MSP_ERROR, "CTapiBstrCollection::get__NumEnum - exit E_OUTOFMEMORY"));

            return E_OUTOFMEMORY;
        }

        hr = p->Init(&m_Var[0], &m_Var[m_dwSize], NULL, AtlFlagCopy);

        if (SUCCEEDED(hr))
        {
            hr = p->QueryInterface(IID_IEnumVARIANT, (void**)retval);
        }

        if (FAILED(hr))
        {
            delete p;
        }

        LOG((MSP_TRACE, "CTapiBstrCollection::get__NewEnum - exit"));
        
        return hr;

    }

    void FinalRelease()
    {
        LOG((MSP_TRACE, "CTapiBstrCollection::FinalRelease() - enter"));

        delete [] m_Var;

        if ( m_pFTM )
        {
            m_pFTM->Release();
        }

        LOG((MSP_TRACE, "CTapiBstrCollection::FinalRelease() - exit"));
    }

};

#endif // _MDHCP_COLLECTION_H_

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mdhcp\cmdhcp.h ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    CMDhcp.h

Abstract:
    Definition of the CMDhcp class

Author:

*/

#ifndef _MDHCP_COM_WRAPPER_CMDHCP_H_
#define _MDHCP_COM_WRAPPER_CMDHCP_H_

#include "resource.h" // for IDR_MDhcp
#include "scope.h"    // for scope delarations
#include "objsf.h"

/////////////////////////////////////////////////////////////////////////////
// CMDhcp

class CMDhcp : 
    public CComDualImpl<IMcastAddressAllocation, &IID_IMcastAddressAllocation, &LIBID_McastLib>, 
    public CComObjectRoot,
    public CComCoClass<CMDhcp,&CLSID_McastAddressAllocation>,
    public CMdhcpObjectSafety
{
public:

    CMDhcp() :
          m_dwSafety         (0),
          m_pFTM             (NULL), 
          m_fApiIsInitialized(FALSE)
    {}

    void FinalRelease(void);

    HRESULT FinalConstruct(void);
    
BEGIN_COM_MAP(CMDhcp)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IMcastAddressAllocation)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_MDhcp)
DECLARE_GET_CONTROLLING_UNKNOWN()

public:
    
    //
    // IMcastAddressAllocation
    //

    STDMETHOD (get_Scopes) (
        VARIANT * pVariant
        );

    STDMETHOD (EnumerateScopes) (
        IEnumMcastScope ** ppEnumMcastScope
        );

    STDMETHOD (RequestAddress) (
        IMcastScope               * pScope,           // from the scope enum
        DATE                        LeaseStartTime,
        DATE                        LeaseStopTime,
        long                        NumAddresses,
        IMcastLeaseInfo          ** ppLeaseResponse    // returned on success.
        );

    STDMETHOD (RenewAddress) (
        long                        lReserved, // unused
        IMcastLeaseInfo           * pRenewRequest,
        IMcastLeaseInfo          ** ppRenewResponse
        );

    STDMETHOD (ReleaseAddress) (
        IMcastLeaseInfo           * pReleaseRequest
        );

    STDMETHOD (CreateLeaseInfo) (
        DATE               LeaseStartTime,
        DATE               LeaseStopTime,
        DWORD              dwNumAddresses,
        LPWSTR *           ppAddresses,
        LPWSTR             pRequestID,
        LPWSTR             pServerAddress,
        IMcastLeaseInfo ** ppReleaseRequest
        );

    STDMETHOD (CreateLeaseInfoFromVariant) (
        DATE                        LeaseStartTime,
        DATE                        LeaseStopTime,
        VARIANT                     vAddresses,
        BSTR                        pRequestID,
        BSTR                        pServerAddress,
        IMcastLeaseInfo          ** ppReleaseRequest
        );

protected:

    //
    // Data
    //

    DWORD      m_dwSafety;          // object safety level
    IUnknown * m_pFTM;              // ptr to free threaded marshaler
    BOOL       m_fApiIsInitialized; // TRUE if api startup succeeded

    //
    // internal implementation
    //

    HRESULT CreateWrappers(
        DWORD                 dwScopeCount, // the number of scopes we were given
        MCAST_SCOPE_ENTRY   * pScopeList,   // array of scope structs
        IMcastScope       *** pppWrappers,  // here we will put an array of if ptrs
        BOOL                  fLocal        // true = scopes are locally generated
        );

    HRESULT GetScopeList(
        DWORD              * pdwScopeCount,
        MCAST_SCOPE_ENTRY ** ppScopeList,
        BOOL               * pfLocal
        );

    HRESULT WrapMDhcpLeaseInfo(
        BOOL                fGotTtl,
        long                lTtl,
        BOOL                fLocal,
        MCAST_LEASE_INFO  * pLeaseInfo,
        MCAST_CLIENT_UID  * pRequestID,
        IMcastLeaseInfo  ** ppInterface
        );

    // Request
    HRESULT PrepareArgumentsRequest(
        IMcastScope          IN    * pScope,
        DATE                 IN      LeaseStartTime,
        DATE                 IN      LeaseStopTime,
        long                 IN      lNumAddresses,
        MCAST_CLIENT_UID     OUT   * pRequestIDStruct,
        MCAST_SCOPE_CTX      OUT   * pScopeCtxStruct,
        MCAST_LEASE_INFO     OUT  ** ppLeaseStruct,
        BOOL                 OUT   * pfLocal,
        long                 OUT   * plTtl
        );

    // Release or Renew
    HRESULT PrepareArgumentsNonRequest(
        IMcastLeaseInfo      IN    * pLease,        
        MCAST_CLIENT_UID     OUT   * pRequestIDStruct,
        MCAST_LEASE_INFO     OUT  ** ppLeaseStruct,
        BOOL                 OUT   * pfLocal,
        BOOL                 OUT   * pfGotTtl,
        long                 OUT   * plTtl
        );
};

#endif // _MDHCP_COM_WRAPPER_CMDHCP_H_

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mdhcp\lease.cpp ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    lease.cpp

Abstract:
    Implementation of CMDhcpLeaseInfo.

Author:

*/

#include "stdafx.h"
#include "mdhcp.h"
#include "lease.h"
#include "collect.h"

#include <winsock2.h>
#include <time.h>

/////////////////////////////////////////////////////////////////////////////
// Convert an OLE DATE (64-bit floating point) to the time format used in
// an MDHCP lease info structure (currently time_t).

HRESULT DateToLeaseTime(DATE date, LONG * pLeaseTime)
{
    //
    // Note:
    //
    // pLeaseTime is intentionally a pointer to LONG instead of a pointer to
    // time_t.  This is because this function is used to convert 32-bit time
    // values that are sent over the wire.
    //

    LOG((MSP_TRACE, "DateToLeaseTime: enter"));
    
    if ( IsBadWritePtr(pLeaseTime, sizeof(LONG)) )
    {
        LOG((MSP_ERROR, "DateToLeaseTime: invalid pLeaseTime pointer "
            "(ptr = %p)", pLeaseTime));
        return E_POINTER;
    }

    //
    // Step one: convert variant time to system time.
    //

    SYSTEMTIME systemTime;
    time_t scratchTime;

    // This is TRUE or FALE, not a Win32 result code.
    INT        iCode;
    
    iCode = VariantTimeToSystemTime(date, &systemTime);

    if (iCode == 0)
    {
        LOG((MSP_ERROR, "DateToLeaseTime: VariantTimeToSystemTime call failed "
            "(code = %d)", iCode));
        return E_INVALIDARG;
    }

    //
    // Step two: Convert system time to time_t.
    //

    tm Tm;

    Tm.tm_year  = (int) systemTime.wYear  - 1900;
    Tm.tm_mon   = (int) systemTime.wMonth - 1;
    Tm.tm_mday  = (int) systemTime.wDay;
    Tm.tm_wday  = (int) systemTime.wDayOfWeek;
    Tm.tm_hour  = (int) systemTime.wHour;
    Tm.tm_min   = (int) systemTime.wMinute;
    Tm.tm_sec   = (int) systemTime.wSecond;
    Tm.tm_isdst = -1; // ask win32 to compute DST for us (crucial!)
    // not filled in: Tm.tm_yday;

    scratchTime = mktime(&Tm);
	if ( scratchTime == -1 )
	{
        LOG((MSP_ERROR, "DateToLeaseTime: mktime call failed "));
		return E_INVALIDARG;
	}

    //
    // Now truncate scratchTime and store in out param.  This will be
    // truncated in 2038.
    //

    *pLeaseTime = (LONG)scratchTime;


    LOG((MSP_TRACE, "DateToLeaseTime: exit"));
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Convert to an OLE DATE structure from a time_t (which is what the MDHCP
// lease info structure now uses).

HRESULT LeaseTimeToDate(time_t leaseTime, DATE * pDate)
{
    LOG((MSP_TRACE, "LeaseTimeToDate: enter"));

    if ( IsBadWritePtr(pDate, sizeof(DATE)) )
    {
        LOG((MSP_ERROR, "LeaseTimeToDate: invalid pDate pointer "
            "(ptr = %08x)", pDate));
        return E_POINTER;
    }

    //
    // Step one: Convert the time_t to a system time.
    //

    // get the tm struct for this time value
    tm * pTm = localtime(&leaseTime);

	if (pTm == NULL)
	{
        LOG((MSP_ERROR, "LeaseTimeToDate: localtime call failed - "
			"exit E_INVALIDARG"));

        return E_INVALIDARG;
	}

    SYSTEMTIME systemTime;

    // set the ref parameters to the tm struct values
    systemTime.wYear          = (WORD) pTm->tm_year + 1900;   // years since 1900
    systemTime.wMonth         = (WORD) pTm->tm_mon + 1; // months SINCE january (0,11)
    systemTime.wDay           = (WORD) pTm->tm_mday;
    systemTime.wDayOfWeek     = (WORD) pTm->tm_wday;
    systemTime.wHour          = (WORD) pTm->tm_hour;
    systemTime.wMinute        = (WORD) pTm->tm_min;
    systemTime.wSecond        = (WORD) pTm->tm_sec;
    systemTime.wMilliseconds  = 0;

    //
    // Step 2: Convert the system time to a variant time.
    //

    int iCode = SystemTimeToVariantTime(&systemTime, pDate);

    if (iCode == 0)
    {
        LOG((MSP_ERROR, "LeaseTimeToDate: SystemToVariantTime call failed "
            "(code = %d)", iCode));
        return E_INVALIDARG;
    }

    LOG((MSP_TRACE, "LeaseTimeToDate: exit"));
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Now for the CMDhcpLeaseInfo class.
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Constructors.

CMDhcpLeaseInfo::CMDhcpLeaseInfo(void) :
        m_pLease(NULL),
        m_fGotTtl(FALSE),
        m_lTtl(0),
        m_pFTM(NULL),
        m_fLocal(FALSE)
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo constructor: enter"));

    m_RequestID.ClientUID       = NULL;
    m_RequestID.ClientUIDLength = 0;

    LOG((MSP_TRACE, "CMDhcpLeaseInfo constructor: exit"));
}

HRESULT CMDhcpLeaseInfo::FinalConstruct(void)
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::FinalConstruct: enter"));

    HRESULT hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                & m_pFTM );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMDhcpLeaseInfo::FinalConstruct: "
                      "create FTM failed 0x%08x", hr));

        return hr;
    }

    hr = m_CriticalSection.Initialize();
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMDhcpLeaseInfo::FinalConstruct: "
                      "critical section initialize failed 0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CMDhcpLeaseInfo::FinalConstruct: exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Destructors.

void CMDhcpLeaseInfo::FinalRelease(void)
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::FinalRelease: enter"));
    
    delete m_pLease;

    delete m_RequestID.ClientUID;

    if ( m_pFTM )
    {
        m_pFTM->Release();
    }

    LOG((MSP_TRACE, "CMDhcpLeaseInfo::FinalRelease: exit"));
}

CMDhcpLeaseInfo::~CMDhcpLeaseInfo(void)
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo destructor: enter"));
    LOG((MSP_TRACE, "CMDhcpLeaseInfo destructor: exit"));
}

/////////////////////////////////////////////////////////////////////////////
// The simplest way to initialize our structure. This happens when the C API
// returns a pointer to an MCAST_LEASE_INFO and we want to return our wrapped
// interface to the user of our COM API, along with the MCAST_CLIENT_UID
// (request ID) that was used.
//
// The MCAST_LEASE_INFO that we're pointing to was created by a COM method in
// IMcastAddressAllocation... it was created via "new" according to the number of addresses
// we expected to get back. We now take ownership of it and it will be deleted
// when we are destroyed. Since this method is not accessible via COM, we trust
// our own IMcastAddressAllocation implementation to do the allocation for us. However we still
// do asserts for debug builds.
//
// We also take ownership of the RequestID; we are responsible for deleting it
// upon our destruction.
//

HRESULT CMDhcpLeaseInfo::Wrap(
    MCAST_LEASE_INFO  * pLease,
    MCAST_CLIENT_UID  * pRequestID,
    BOOL                fGotTtl,
    long                lTtl
    )
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::Wrap: enter"));

    _ASSERTE( ! IsBadReadPtr(pLease, sizeof(MCAST_LEASE_INFO)) );
    _ASSERTE( ! IsBadReadPtr(pLease, sizeof(MCAST_LEASE_INFO) +
                               (pLease->AddrCount - 1) * sizeof(DWORD)) );
    _ASSERTE( ! IsBadWritePtr(pLease, sizeof(MCAST_LEASE_INFO) +
                               (pLease->AddrCount - 1) * sizeof(DWORD)) );
    
    _ASSERTE( ! IsBadReadPtr(pRequestID, sizeof(MCAST_CLIENT_UID)) );
    _ASSERTE( pRequestID->ClientUIDLength == MCAST_CLIENT_ID_LEN );
    _ASSERTE( ! IsBadReadPtr(pRequestID->ClientUID,
                             pRequestID->ClientUIDLength) );

    //
    // Takes ownership of the following dynamically-allocated items:
    //    * lease info
    //    * requestId.clientUID.
    //

    m_fGotTtl    = fGotTtl;
    m_lTtl       = lTtl;
    m_pLease     = pLease;
    m_RequestID  = *pRequestID;

    LOG((MSP_TRACE, "CMDhcpLeaseInfo::Wrap: exit"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Allocate a variable-sized MCAST_LEASE_INFO structure, copy our structure
// into it, and return a pointer to the new structure.

HRESULT CMDhcpLeaseInfo::GetStruct(MCAST_LEASE_INFO ** ppLease)
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::GetStruct: enter"));

    if ( IsBadWritePtr(ppLease, sizeof(MCAST_LEASE_INFO *)) )
    {
        LOG((MSP_ERROR, "CMDhcpLeaseInfo::GetStruct: bad pointer passed in"));

        return E_POINTER;
    }

    //
    // Compute the size of the existing structure.
    //

    DWORD dwSize = sizeof(MCAST_LEASE_INFO) +
        m_pLease->AddrCount * sizeof(DWORD);

    //
    // New an appropriately-sized struct. The caller will delete it after
    // the API call.
    //

    (*ppLease) = (MCAST_LEASE_INFO *) new BYTE[dwSize];

    if ((*ppLease) == NULL)
    {
        LOG((MSP_ERROR, "GetStruct: out of memory in "
           "MCAST_LEASE_INFO allocation"));

        return E_OUTOFMEMORY;
    }

    //
    // Copy to the new structure.
    //

    CopyMemory(*ppLease, m_pLease, dwSize);

    LOG((MSP_TRACE, "CMDhcpLeaseInfo::GetStruct: exit"));
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Initialize the fields of the structure. This is the case where the user
// has called IMcastAddressAllocation::CreateLeaseInfo and intends to do a renew or release
// right after this.
//
// Note: the addresses are in NETWORK byte order and remain so.
//

HRESULT CMDhcpLeaseInfo::Initialize(DATE     LeaseStartTime,
                                    DATE     LeaseStopTime,
                                    DWORD    dwNumAddresses,
                                    LPWSTR * ppAddresses,
                                    LPWSTR   pRequestID,
                                    LPWSTR   pServerAddress)
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::Initialize (create): enter"));

    // For ATL string type conversion macros.
    USES_CONVERSION;

    // These should already have been checked by CreateLeaseInfo
    _ASSERTE( dwNumAddresses >= 1 );
    _ASSERTE( dwNumAddresses <= USHRT_MAX );
    _ASSERTE( ! IsBadReadPtr  (ppAddresses, sizeof(LPWSTR) * dwNumAddresses) );
    _ASSERTE( ! IsBadStringPtr(pRequestID,      (UINT) -1 ) );
    _ASSERTE( ! IsBadStringPtr(pServerAddress,  (UINT) -1 ) );

    // Let's check all the addresses here before we get too deep into this...
    DWORD i;
    for ( i = 0; i < dwNumAddresses; i++ )
    {
        if ( IsBadStringPtr(ppAddresses[i], (UINT) -1 ) )
        {
            LOG((MSP_ERROR, "CMDhcpLeaseInfo::Initialize (create): bad "
                "string pointer found"));
            return E_POINTER;
        }
    }

    // Set the request ID via a private method. No need to check pRequestID --
    // this checks it for us. (It's no problem that it's not really a BSTR,
    // because we don't use the size tag anywhere.)

    HRESULT hr = put_RequestID(pRequestID);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "Initialize: failed to set RequestID"));
        return E_INVALIDARG;
    }

    // Allocate space for as many addresses as needed.
    // NOTE: If we fail from here on, we DO NOT need to delete this buffer,
    // because returning a failure from this function will cause the whole
    // CMDhcpLeaseInfo to be deleted, which will cause m_pLease to be deleted.

    m_pLease = (MCAST_LEASE_INFO *) new BYTE
        [ sizeof(MCAST_LEASE_INFO) + sizeof(DWORD) * dwNumAddresses ];

    if (m_pLease == NULL)
    {
        LOG((MSP_ERROR, "Initialize: out of memory in struct allocation"));
        return E_OUTOFMEMORY;
    }

    // note the number of addresses in the structure
    m_pLease->AddrCount = (WORD) dwNumAddresses;

    m_pLease->pAddrBuf = ( (PBYTE) m_pLease ) + sizeof( MCAST_LEASE_INFO );

    // note: assumes ipv4
    DWORD * pdwAddresses = (DWORD *) m_pLease->pAddrBuf;

    // Get the addresses from the array and put them in our structure.
    for (i = 0; i < dwNumAddresses; i++)
    {
        // we already checked the BSTR
        pdwAddresses[i] = inet_addr(W2A(ppAddresses[i]));
    }

    hr = DateToLeaseTime(LeaseStartTime, &(m_pLease->LeaseStartTime));
    if (FAILED(hr)) return hr;

    hr = DateToLeaseTime(LeaseStopTime, &(m_pLease->LeaseEndTime));
    if (FAILED(hr)) return hr;

    //
    // We don't know the TTL. Leave it alone.
    //

    //
    // Set the server address. If the server addess is 127.0.0.1
    // (in net byte order) then mark this as a local lease.
    //

    m_pLease->ServerAddress.IpAddrV4 = inet_addr(W2A(pServerAddress));

    SetLocal( m_pLease->ServerAddress.IpAddrV4 == 0x0100007f );

    //
    // All done...
    //

    LOG((MSP_TRACE, "CMDhcpLeaseInfo::Initialize (create): exit"));
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// This is a small helper function to print an IP address to a Unicode string.
// We can't use inet_ntoa because we need Unicode.

static inline void ipAddressToStringW(WCHAR * wszDest, DWORD dwAddress)
{
    // The IP address is always stored in NETWORK byte order.
    // So we need to take something like 0x0100007f and produce a string like
    // "127.0.0.1".

    wsprintf(wszDest, L"%d.%d.%d.%d",
             dwAddress        & 0xff,
            (dwAddress >> 8)  & 0xff,
            (dwAddress >> 16) & 0xff,
             dwAddress >> 24          );
}


/////////////////////////////////////////////////////////////////////////////
// Private helper funciton to make an array of BSTRs from our array of
// DWORD addresses.
//

HRESULT CMDhcpLeaseInfo::MakeBstrArray(BSTR ** ppbszArray)
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::MakeBstrArray: enter"));

    if ( IsBadWritePtr(ppbszArray, sizeof(BSTR *)) )
    {
        LOG((MSP_ERROR, "MakeBstrArray: invalid pointer argument passed in"));
        return E_POINTER;
    }

    *ppbszArray = new BSTR[m_pLease->AddrCount];

    if ( (*ppbszArray) == NULL)
    {
        LOG((MSP_ERROR, "MakeBstrArray: out of memory in array allocation"));
        return E_OUTOFMEMORY;
    }

    WCHAR wszBuffer[100]; // quite big enough for this

    for (DWORD i = 0 ; i < m_pLease->AddrCount; i++)
    {
        // note: we do not support ipv6
        ipAddressToStringW( wszBuffer, ((DWORD *) m_pLease->pAddrBuf)[i] );

        (*ppbszArray)[i] = SysAllocString(wszBuffer);

        if ( (*ppbszArray)[i] == NULL )
        {
            LOG((MSP_ERROR, "MakeBstrArray: out of memory in string allocation"));

            for ( DWORD j = 0; j < i; j++ )
            {
                SysFreeString((*ppbszArray)[j]);
            }

            delete (*ppbszArray);
            *ppbszArray = NULL;

            return E_OUTOFMEMORY;
        }
    }

    LOG((MSP_TRACE, "CMDhcpLeaseInfo::MakeBstrArray: exit"));
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
// Private helper method
// CMDhcpLeaseInfo::GetRequestIDBuffer
//
// Parameters
//     lBufferSize [in]      This argument indicates the size of the buffer
//                             pointed to by pBuffer.
//     pBuffer     [in, out] This argument points to a buffer that the caller
//                             has allocated, of size lBufferSize. This
//                             buffer will be filled with a copy of the
//                             unique identifier.
//
// Return Values
//     S_OK           Success
//     E_POINTER      The caller passed in an invalid pointer argument
//     E_INVALIDARG	  The supplied buffer is too small
//
// Description
//     Use this method to obtain a copy of the unique identifier.
/////////////////////////////////////////////////////////////////////////////

HRESULT CMDhcpLeaseInfo::GetRequestIDBuffer(
    long lBufferSize,
    BYTE * pBuffer
    )
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::GetRequestIDBuffer: enter"));

    //
    // Check return pointer.
    //

    if ( IsBadWritePtr(pBuffer, lBufferSize) )
    {
        LOG((MSP_ERROR, "requestID GetRequestIDBuffer: bad pointer passed in"));

        return E_POINTER;
    }

    //
    // Check that the caller has enough space to grab the entire client id.
    //

    if ( lBufferSize < MCAST_CLIENT_ID_LEN )
    {
        LOG((MSP_ERROR, "requestID GetRequestIDBuffer: specified buffer too small"));
        
        return E_INVALIDARG;
    }

    //
    // Copy the info to the caller's buffer.
    //

    m_CriticalSection.Lock();
    
    CopyMemory( pBuffer, m_RequestID.ClientUID, MCAST_CLIENT_ID_LEN );

    m_CriticalSection.Unlock();

    LOG((MSP_TRACE, "CMDhcpLeaseInfo::GetRequestIDBuffer: exit"));
    return S_OK;
}

BYTE HexDigitValue( WCHAR c )
{
    _ASSERTE( iswxdigit(c) );

    c = towlower(c);

    if ( ( c >= L'0' ) && ( c <= L'9' ) )
    {
        return c - L'0';
    }
    else
    {
        return c - L'a' + 10;
    }
}

HRESULT CMDhcpLeaseInfo::put_RequestID(
    BSTR bszGuid
    )
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::put_RequestID: enter"));

    // (UINT) -1 is as big a value as we can give it -- we don't want any
    // limitation on the number of characters it checks.
    if ( IsBadStringPtr(bszGuid, (UINT) -1 ) )
    {
        LOG((MSP_ERROR, "CMDhcpLeaseInfo::put_RequestID: "
            "bad BSTR; fail"));

        return E_POINTER;
    }

    //
    // Determine the byte buffer we need to set based on the string.
    // The string should be MCAST_CLIENT_ID_LEN * 2 characters long;
    // each byte is represented by two hexadecimal digits, starting
    // with the most significant byte.
    //
    // Note that this format is intentionally not specified in the interface
    // spec; the client should not depend on the specific format. The format
    // we happen to use is convenient because it's printable, contains no
    // spaces, and is easy to generate and parse.
    //

    if ( lstrlenW( bszGuid ) < 2 * MCAST_CLIENT_ID_LEN )
    {
        LOG((MSP_ERROR, "CMDhcpLeaseInfo::put_RequestID - "
            "string is only %d characters long; "
            "we require at least %d characters - exit E_INVALIDARG",
            lstrlenW( bszGuid ), 2 * MCAST_CLIENT_ID_LEN));

        return E_INVALIDARG;
    }

    BYTE  NewUID [ MCAST_CLIENT_ID_LEN ];

    for ( DWORD i = 0; i < MCAST_CLIENT_ID_LEN; i++ )
    {
        if ( ( ! iswxdigit( bszGuid[ 2 * i     ] ) ) ||
             ( ! iswxdigit( bszGuid[ 2 * i + 1 ] ) ) )
        {
            LOG((MSP_ERROR, "CMDhcpLeaseInfo::put_RequestID - "
                "invalid value for byte %d / %d - exit E_INVALIDARG",
                i + 1, MCAST_CLIENT_ID_LEN ));

            return E_INVALIDARG;
        }
        
        //
        // Compute value of byte based on corresponding hex digits in string.
        //

        NewUID[ i ] = ( ( HexDigitValue( bszGuid[ 2 * i ] ) ) << 4 ) +
                          HexDigitValue( bszGuid[ 2 * i + 1 ] );
    }        

    //
    // Allocate and initialize the request id structure accordingly.
    // We do this only during initialization, so there is no need to
    // use the critical section.
    //
    // We could have just used this new'ed buffer above and avoided the
    // copy, but this makes the code a bit more straightforward as we
    // don't have to worry about cleaning up the allocation if something's
    // wrong with the string. No one will notice the overhead.
    //

    m_RequestID.ClientUIDLength = MCAST_CLIENT_ID_LEN;
    m_RequestID.ClientUID = new BYTE[ MCAST_CLIENT_ID_LEN ];

    if ( m_RequestID.ClientUID == NULL )
    {
        LOG((MSP_ERROR, "CMDhcpLeaseInfo::put_RequestID - "
            "buffer allocation failed - exit E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    CopyMemory(m_RequestID.ClientUID,
               NewUID,
               MCAST_CLIENT_ID_LEN
               );

    LOG((MSP_TRACE, "CMDhcpLeaseInfo::put_RequestID - exit"));

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// IMcastLeaseInfo
//
// This interface can be obtained by calling IMcastAddressAllocation::CreateLeaseInfo. This
// interface can also be obtained as the result of an IMcastAddressAllocation::RequestAddress
// or IMcastAddressAllocation::RenewAddress call, in which case it indicates the properties of
// a lease that has been granted or renewed. This is a "read-only" interface
// in that it has "get" methods but no "put" methods.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// IMcastLeaseInfo::get_RequestID
//
// Parameters
//     ppRequestID [out] Pointer to a BSTR (size-tagged Unicode string
//                         pointer) that will receive the request ID for this
//                         lease. The request ID uniquely identifies this
//                         lease request to the server. The string is
//                         allocated using SysAllocString(); when the caller
//                         no longer needs the string, it should free it using
//                         SysFreeString().
//
// Return Values
//     S_OK             Success
//     E_POINTER        The caller passed in an invalid pointer argument
//     E_FAIL           The lease info object contains an invalid request ID
//     E_OUTOFMEMORY    Not enough memory to allocate the BSTR
//
// Description
//     Use this method to obtain the request ID for a lease. The primary
//     purpose of this method is to allow you to save the request ID after
//     your application exits, so that you can call IMcastAddressAllocation::CreateLeaseInfo to
//     recreate the lease info object during a subsequent run. This allows you
//     to renew or release a lease after the instance of your program that
//     originally requested the lease has exited.
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMDhcpLeaseInfo::get_RequestID(
    BSTR * pbszGuid
    )
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::get_RequestID: enter"));

    //
    // Check the return pointer.
    //

    if ( IsBadWritePtr(pbszGuid, sizeof(BSTR)) )
    {
        LOG((MSP_ERROR, "CMDhcpLeaseInfo::get_RequestID: "
            "bad BSTR pointer; fail"));

        return E_POINTER;
    }

    //
    // Construct the string; 2 characters of string space per byte of
    // request ID space, plus trailing L'\0'.
    //

    WCHAR wszBuffer[ 2 * MCAST_CLIENT_ID_LEN + 1 ] = L"";

    WCHAR wszThisByte[ 3 ]; // string representation of one byte plus space

    m_CriticalSection.Lock();

    for ( DWORD i = 0; i < MCAST_CLIENT_ID_LEN; i++ )
    {
        swprintf( wszThisByte, L"%02x", m_RequestID.ClientUID[i] );

        lstrcatW( wszBuffer, wszThisByte );
    }
    
    m_CriticalSection.Unlock();

    //
    // Allocate a BSTR and return it.
    //

    *pbszGuid = SysAllocString(wszBuffer);

    if ( (*pbszGuid) == NULL )
    {
        LOG((MSP_ERROR, "CMDhcpLeaseInfo::get_RequestID: "
            "failed to SysAllocString - exit E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CMDhcpLeaseInfo::get_RequestID: exit"));

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// IMcastLeaseInfo::get_LeaseStartTime
//
// Parameters
//     pTime [out] Pointer to a DATE that will receive the start time of the
//                   lease.
//
// Return Values
//     	S_OK            Success
//      E_POINTER       The caller passed in an invalid pointer argument
//      E_INVALIDARG    A failure occurred during date format conversion
//
// Description
//     Use this method to obtain the start time of the lease.
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMDhcpLeaseInfo::get_LeaseStartTime(
     DATE *pTime
    )
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::get_LeaseStartTime: enter"));

    m_CriticalSection.Lock();
    HRESULT hr = LeaseTimeToDate(m_pLease->LeaseStartTime, pTime);
    m_CriticalSection.Unlock();

    LOG((MSP_TRACE, "CMDhcpLeaseInfo::get_LeaseStartTime: exit; hr = %08x", hr));
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
// IMcastLeaseInfo::put_LeaseStartTime
//
// Parameters
//     time [in] A DATE specifying the start time of the lease.
//
// Return Values
//     S_OK            Success
//     E_INVALIDARG    A failure occurred during date format conversion
//
// Description
//     Use this method to set the start time of the lease. This method, along
//     with put_LeaseStopTime, allows you to renew a lease without calling
//     IMcastAddressAllocation::CreateLeaseInfo.
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMDhcpLeaseInfo::put_LeaseStartTime(
     DATE time
    )
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::put_LeaseStartTime: enter"));

    m_CriticalSection.Lock();
    HRESULT hr = DateToLeaseTime(time, &(m_pLease->LeaseStartTime));
    m_CriticalSection.Unlock();

    LOG((MSP_TRACE, "CMDhcpLeaseInfo::put_LeaseStartTime: exit; hr = %08x", hr));
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
// IMcastLeaseInfo::get_LeaseStopTime
//
// Parameters
//     pTime [out] Pointer to a DATE that will receive the stop time of the
//                   lease.
//
// Return Values
//     S_OK             Success
//     E_POINTER        The caller passed in an invalid pointer argument
//     E_INVALIDARG     A failure occurred during date format conversion
//
// Description
//     Use this method to obtain the stop time of the lease.
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMDhcpLeaseInfo::get_LeaseStopTime(
     DATE *pTime
    )
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::get_LeaseStopTime: enter"));

    m_CriticalSection.Lock();
    HRESULT hr = LeaseTimeToDate(m_pLease->LeaseEndTime, pTime);
    m_CriticalSection.Unlock();

    LOG((MSP_TRACE, "CMDhcpLeaseInfo::get_LeaseStopTime: exit; hr = %08x", hr));
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IMcastLeaseInfo::put_LeaseStopTime
//
// Parameters
//     time [in] A DATE specifying the stop time of the lease.
//
// Return Values
//     S_OK            Success
//     E_INVALIDARG    A failure occurred during date format conversion
//
// Description
//     Use this method to set the stop time of the lease. This method,
//     along with put_LeaseStartTime, allows you to renew a lease without
//     calling IMcastAddressAllocation::CreateLeaseInfo.
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMDhcpLeaseInfo::put_LeaseStopTime(
     DATE time
    )
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::put_LeaseStopTime: enter"));

    m_CriticalSection.Lock();
    HRESULT hr = DateToLeaseTime(time, &(m_pLease->LeaseEndTime));
    m_CriticalSection.Unlock();

    LOG((MSP_TRACE, "CMDhcpLeaseInfo::put_LeaseStopTime: exit; hr = %08x", hr));
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
// IMcastLeaseInfo::get_AddressCount
//
// Parameters
//     pCount [out] Pointer to a long that will receive the number of
//                    addresses requested or granted in this lease.
//
// Return Values
//     S_OK             Success
//     E_POINTER        The caller passed in an invalid pointer argument
//
// Description
//     Use this method to obtain the number of addresses requested or granted
//     in this lease.
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMDhcpLeaseInfo::get_AddressCount(
     long *pCount
    )
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::get_AddressCount: enter"));

    if ( IsBadWritePtr(pCount, sizeof(long)) )
    {
        LOG((MSP_ERROR, "get_AddressCount: invalid pCount pointer "
            "(ptr = %08x)", pCount));
        return E_POINTER;
    }

    // we checked when we set it that we didn't overflow a long
    *pCount = (long) m_pLease->AddrCount;

    LOG((MSP_TRACE, "CMDhcpLeaseInfo::get_AddressCount: exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// IMcastLeaseInfo::get_ServerAddress
//
// Parameters
//     ppAddress [out] Pointer to a BSTR (size-tagged Unicode string pointer)
//                       that will receive a string representation of the
//                       address of the server granting this request or
//                       renewal, if this is the case. If lease information
//                       object does not describe a granted lease, i.e., was
//                       not returned by IMcastAddressAllocation::RequestAddress or
//                       IMcastAddressAllocation::RenewAddress, then the address is reported as
//                       the string "Unspecified".
//
// Return Values
//     S_OK             Success
//     S_FALSE          Server address unspecified
//     E_POINTER        The caller passed in an invalid pointer argument
//     E_OUTOFMEMORY    Not enough memory to allocate the string
//
// Description
//     Use this method to obtain a string representing the address of the
//     MDHCP server granting this lease.
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMDhcpLeaseInfo::get_ServerAddress(
     BSTR *ppAddress
    )
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::get_ServerAddress: enter"));

    if ( IsBadWritePtr(ppAddress, sizeof(BSTR)) )
    {
        LOG((MSP_ERROR, "get_ServerAddress: invalid ppAddress pointer "
            "(ptr = %08x)", ppAddress));
        return E_POINTER;
    }

    HRESULT hr = S_OK;
    WCHAR   wszBuffer[100]; // no danger of overflow (see below)

    // SPECBUG: We should discuss what sort of behavior we want for
    // this case.
    if ( m_pLease->ServerAddress.IpAddrV4 == 0 )
    {
        wsprintf(wszBuffer, L"Unspecified");
        hr = S_FALSE;
    }
    else
    {
        ipAddressToStringW(wszBuffer, m_pLease->ServerAddress.IpAddrV4);
    }

    // This allocates space on OLE's heap, copies the wide character string
    // to that space, fille in the BSTR length field, and returns a pointer
    // to the wchar array part of the BSTR.
    *ppAddress = SysAllocString(wszBuffer);

    if ( *ppAddress == NULL )
    {
        LOG((MSP_ERROR, "get_ServerAddress: out of memory in string allocation"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CMDhcpLeaseInfo::get_ServerAddress: exit: hr = %08x", hr));
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// IMcastLeaseInfo::get_TTL
//
// Parameters
//     pTTL [out] Pointer to a long that will receive the TTL value associated
//                  with this lease.
//
// Return Values
//     S_OK             Success
//     E_POINTER        The caller passed in an invalid pointer argument
//     E_FAIL           There is no TTL associated with this lease
//
// Description
//     Use this method to obtain the TTL value associated with this lease.
//     This is more or less significant in the implementation of multicast
//     routing; generally, the higher the TTL value, the "larger" or more
//     inclusive the multicast scope. Probably, most applications need not
//     worry about the TTL.
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMDhcpLeaseInfo::get_TTL(
     long *pTTL
    )
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::get_TTL: enter"));

    if ( IsBadWritePtr(pTTL, sizeof(long)) )
    {
        LOG((MSP_ERROR, "get_TTL: invalid pTTL pointer "
            "(ptr = %08x)", pTTL));
        return E_POINTER;
    }

    if ( ! m_fGotTtl )
    {
        LOG((MSP_ERROR, "get_TTL: no TTL set"));
        return E_FAIL;
    }
    
    // we should check when we set it that we don't overflow a long
    // (only 0 - 255 is actually meaningful, right?)
    *pTTL = (long) m_lTtl;

    LOG((MSP_TRACE, "CMDhcpLeaseInfo::get_TTL: exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// IMcastLeaseInfo::get_Addresses
//
// Parameters
//     pVariant [out] Pointer to a VARIANT that will receive an OLE-standard
//                      Collection of addresses. Each address is represented
//                      as a BSTR (size-tagged Unicode string pointer) in
//                      "dot-quad" notation: e.g., "245.1.2.3".
//
// Return Values
//     S_OK             Success
//     E_POINTER        The caller passed in an invalid pointer argument
//     E_OUTOFMEMORY    Not enough memory to allocate the Collection
//
// Description
//     Use this method to obtain the collection of multicast addresses that
//     are the subject of this lease or lease request. This method is
//     primarily for VB and other scripting languages; C++ programmers use
//     EnumerateAddresses instead. 
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMDhcpLeaseInfo::get_Addresses(
     VARIANT * pVariant
    )
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::get_Addresses: enter"));

    if (IsBadWritePtr(pVariant, sizeof(VARIANT)))
    {
        LOG((MSP_ERROR, "get_Addresses: "
            "invalid pVariant pointer "
            "(ptr = %08x)", pVariant));
        return E_POINTER;
    }
    
    BSTR * pbszArray = NULL;

    // This performs a new and as many SysAllocStrings as there are addresses.
    HRESULT hr = MakeBstrArray(&pbszArray);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get_Addresses: MakeBstrArray failed"));
        return hr;
    }

    //
    // create the collection object - use the tapi collection
    //

    CComObject<CTapiBstrCollection> * p;
    hr = CComObject<CTapiBstrCollection>::CreateInstance( &p );

    if (FAILED(hr) || (p == NULL))
    {
        LOG((MSP_ERROR, "get_Addresses: Could not create CTapiBstrCollection "
            "object - return %lx", hr ));

        for (DWORD i = 0 ; i < m_pLease->AddrCount; i++)
        {
            SysFreeString(pbszArray[i]);
        }
        delete pbszArray;
        return hr;
    }

    // initialize it using an iterator -- pointers to the beginning and
    // the ending element plus one. The collection takes ownership of the
    // BSTRs. We no longer need the array they were kept in.
    hr = p->Initialize(m_pLease->AddrCount,
                       pbszArray,
                       pbszArray + m_pLease->AddrCount);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "get_Addresses: Could not initialize "
            "ScopeCollection object - return %lx", hr ));

        for (DWORD i = 0 ; i < m_pLease->AddrCount; i++)
        {
            SysFreeString(pbszArray[i]);
        }
        delete pbszArray;

        delete p;
        
        return hr;
    }

    // The collection takes ownership of the BSTRs.
    // We no longer need the array they were kept in.
    
    delete pbszArray;

    // get the IDispatch interface
    IDispatch * pDisp;
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );

    if (FAILED(hr))
    {
        // Query interface failed so we don't know that if it addreffed
        // or not.
        
        LOG((MSP_ERROR, "get_Addresses: QI for IDispatch failed on "
            "ScopeCollection - %lx", hr ));

        delete p;
        
        return hr;
    }

    // put it in the variant

    LOG((MSP_INFO, "placing IDispatch value %08x in variant", pDisp));

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDisp;

    LOG((MSP_TRACE, "CMDhcpLeaseInfo::get_Addresses: exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// IMcastLeaseInfo::EnumerateAddresses
//
// Parameters
//     ppEnumAddresses [out] Returns a pointer to a new IEnumBstr object.
//                           IEnumBstr is a standard enumerator interface
//                           that enumerates BSTRs (size-tagged Unicode string
//                           pointers). Each string is in "dot-quad" notation:
//                           e.g., "245.1.2.3".
//
// Return Values
//     S_OK             Success
//     E_POINTER        The caller passed in an invalid pointer argument
//     E_OUTOFMEMORY    Not enough memory to allocate the enumerator
//
// Description
//     Use this method to obtain the collection of multicast addresses that
//     are the subject of this lease or lease request. This method is
//     primarily for C++ programmers; VB and other scripting languages use
//     get_Addresses instead.
/////////////////////////////////////////////////////////////////////////////

class _CopyBSTR
{
public:
#if _ATL_VER >= 0x0203
    static HRESULT copy(BSTR *p1, BSTR *p2)
    {
        (*p1) = SysAllocString(*p2);
        if (*p1) 
            return S_OK;
        else
            return E_OUTOFMEMORY;
    }
#else
    static void copy(BSTR *p1, BSTR *p2)
    {
        (*p1) = SysAllocString(*p2);
    }
#endif     
    static void init(BSTR* p) {*p = NULL;}
    static void destroy(BSTR* p) { SysFreeString(*p);}
};

STDMETHODIMP CMDhcpLeaseInfo::EnumerateAddresses(
     IEnumBstr ** ppEnumAddresses
    )
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::EnumerateAddresses: enter"));

    if (IsBadWritePtr(ppEnumAddresses, sizeof(IEnumBstr *)))
    {
        LOG((MSP_ERROR, "EnumerateAddresses: "
            "invalid ppEnumAddresses pointer "
            "(ptr = %08x)", ppEnumAddresses));
        return E_POINTER;
    }
    
    BSTR * pbszArray = NULL;

    // This performs a new and as many SysAllocStrings as there are addresses.
    HRESULT hr = MakeBstrArray(&pbszArray);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "EnumerateAddresses: MakeBstrArray failed"));
        return hr;
    }
    
    typedef CSafeComEnum<IEnumBstr, &IID_IEnumBstr,
        BSTR, _CopyBSTR> CEnumerator;
    CComObject<CEnumerator> *pEnum = NULL;

    hr = CComObject<CEnumerator>::CreateInstance(&pEnum);
    if (FAILED(hr) || (pEnum == NULL))
    {
        LOG((MSP_ERROR, "EnumerateAddresses: "
            "Couldn't create enumerator object: %08x", hr));

        for (DWORD i = 0 ; i < m_pLease->AddrCount; i++)
        {
            SysFreeString(pbszArray[i]);
        }
        delete pbszArray;
        return hr;
    }


    // Hand the BSTRs to the enumerator. The enumerator takes ownership of the
    // array of BSTRs, so no need to delete them if this succeeds.
    hr = pEnum->Init(&(pbszArray[0]),
                     &(pbszArray[m_pLease->AddrCount]),
                     NULL, AtlFlagTakeOwnership);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "EnumerateAddresses: "
            "Init enumerator object failed: %08x", hr));

        for (DWORD i = 0 ; i < m_pLease->AddrCount; i++)
        {
            SysFreeString(pbszArray[i]);
        }
        delete pbszArray;

        // p has not yet been addreffed so release makes no sense
        delete pEnum;
        
        return hr;
    }

    // The enumerator took ownership, so don't delete the array.

    // Now get the interface we wanted...

    hr = pEnum->_InternalQueryInterface(IID_IEnumBstr,
                                       (void **) ppEnumAddresses);
    
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "EnumerateAddresses: "
            "internal QI failed: %08x", hr));

        // we don't know if p has been addreffed
        delete pEnum;

        return hr;
    }

    LOG((MSP_TRACE, "CMDhcpLeaseInfo::EnumerateAddresses: exit"));
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CMDhcpLeaseInfo::GetLocal(BOOL * pfLocal)
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::GetLocal: enter"));

    _ASSERTE( ! IsBadWritePtr( pfLocal, sizeof(BOOL) ) );

    *pfLocal = m_fLocal;
    
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::GetLocal: exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

HRESULT CMDhcpLeaseInfo::SetLocal(BOOL fLocal)
{
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::SetLocal: enter"));

    m_fLocal = fLocal;
    
    LOG((MSP_TRACE, "CMDhcpLeaseInfo::SetLocal: exit S_OK"));
    
    return S_OK;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mdhcp\lease.h ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    lease.h

Abstract:
    Definition of the CMdhcpLeaseInfo class

Author:

*/

#ifndef _MDHCP_COM_WRAPPER_LEASE_H_
#define _MDHCP_COM_WRAPPER_LEASE_H_

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Includes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Non-class-member helper functions
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

// helper functions for date conversions
HRESULT DateToLeaseTime(DATE date, LONG * pLeaseTime);
HRESULT LeaseTimeToDate(time_t leaseTime, DATE * pDate);

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Custom critical section / locking stuff
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CCritSection
{
private:
    CRITICAL_SECTION m_CritSec;
    BOOL bInitialized;

public:
    CCritSection() :
      bInitialized( FALSE )
    {
    }

    ~CCritSection()
    {
        if( bInitialized )
        {
            DeleteCriticalSection(&m_CritSec);
        }
    }

    HRESULT Initialize()
    {
        if( bInitialized )
        {
            // Already initialized
            _ASSERT( FALSE );
            return S_OK;
        }

        //
        // We have to initialize the critical section
        //

        try
        {
            InitializeCriticalSection(&m_CritSec);
        }
        catch(...)
        {
            // Wrong
            return E_OUTOFMEMORY;
        }

        bInitialized = TRUE;
        return S_OK;
    }

    void Lock() 
    {
        EnterCriticalSection(&m_CritSec);
    }

    BOOL TryLock() 
    {
        return TryEnterCriticalSection(&m_CritSec);
    }

    void Unlock() 
    {
        LeaveCriticalSection(&m_CritSec);
    }
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CMDhcpLeaseInfo
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CMDhcpLeaseInfo : 
	public CComDualImpl<IMcastLeaseInfo, &IID_IMcastLeaseInfo, &LIBID_McastLib>, 
    public CComObjectRootEx<CComObjectThreadModel>,
    public CObjectSafeImpl
{

    /////////////////////////////////////////////////////////////////////////
    // Private data members
    /////////////////////////////////////////////////////////////////////////

private:
    // For synchronization -- defined above.
    CCritSection       m_CriticalSection;

    // This is actually a variable length structure, so we must allocate it
    // dynamically.
    MCAST_LEASE_INFO * m_pLease;

    BOOL               m_fGotTtl; // TRUE if TTL is meaningful
    long               m_lTtl;    // the TTL for this lease (from scope info!)

    // We also contain request ID info. The clientUID field is dynamically
    // allocated and must be released on destruction.
    MCAST_CLIENT_UID   m_RequestID;

    // Pointer to the free threaded marshaler.
    IUnknown         * m_pFTM;

    // locally allocated lease -- by default this is false
    BOOL               m_fLocal;

    /////////////////////////////////////////////////////////////////////////
    // Private implementation
    /////////////////////////////////////////////////////////////////////////

private:
    HRESULT MakeBstrArray(BSTR ** ppbszArray);
    HRESULT put_RequestID(BSTR    pRequestID);

    /////////////////////////////////////////////////////////////////////////
    // Public methods not belonging to any interface
    /////////////////////////////////////////////////////////////////////////

public:
            CMDhcpLeaseInfo (void);
    HRESULT FinalConstruct  (void);
    void    FinalRelease    (void);
            ~CMDhcpLeaseInfo(void);

    // init with values obtained from CreateLeaseInfo
    HRESULT Initialize(
        DATE     LeaseStartTime,
        DATE     LeaseStopTime,
        DWORD    dwNumAddresses,
        LPWSTR * ppAddresses,
        LPWSTR   pRequestID,
        LPWSTR   pServerAddress
        );

    // wrap a struct returned from the C API
    HRESULT Wrap(
        MCAST_LEASE_INFO  * pLease,
        MCAST_CLIENT_UID  * pRequestID,
        BOOL                fGotTtl,
        long                lTtl
        );

    HRESULT GetStruct(
        MCAST_LEASE_INFO ** ppLease
        );

    HRESULT GetRequestIDBuffer(
        long   lBufferSize,
        BYTE * pBuffer
        );

    HRESULT GetLocal(
        BOOL * pfLocal
        );

    HRESULT SetLocal(
        BOOL fLocal
        );

    /////////////////////////////////////////////////////////////////////////
    // General COM stuff
    /////////////////////////////////////////////////////////////////////////

public:
    BEGIN_COM_MAP(CMDhcpLeaseInfo)
	    COM_INTERFACE_ENTRY(IDispatch)
	    COM_INTERFACE_ENTRY(IMcastLeaseInfo)
	    COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
    END_COM_MAP()

    DECLARE_GET_CONTROLLING_UNKNOWN()

    //////////////////////////////////////////////////////////////////////////
    // IMcastLeaseInfo interface
    //////////////////////////////////////////////////////////////////////////

public:
    STDMETHOD (get_RequestID)      (BSTR       * ppRequestID);
    STDMETHOD (get_LeaseStartTime) (DATE       * pTime);
    STDMETHOD (put_LeaseStartTime) (DATE         time);
    STDMETHOD (get_LeaseStopTime)  (DATE       * pTime);
    STDMETHOD (put_LeaseStopTime)  (DATE         time);
    STDMETHOD (get_AddressCount)   (long       * pCount);
    STDMETHOD (get_ServerAddress)  (BSTR       * ppAddress);
    STDMETHOD (get_TTL)            (long       * pTTL);
    STDMETHOD (get_Addresses)      (VARIANT    * pVariant);
    STDMETHOD (EnumerateAddresses) (IEnumBstr ** ppEnumAddresses);

};

#endif // _MDHCP_COM_WRAPPER_LEASE_H_

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mdhcp\local.cpp ===
// MDHCP COM wrapper
// Copyright (c) 1998-1999 Microsoft Corporation
//
// Module: local.cpp
//
// Author: Zoltan Szilagyi
//
// This file contains my implementation of local address allocation, plus a
// function to see if we are doing local address allocation (based on the
// registry). Prototypes are in local.cpp.
//
// These functions are called within CMDhcp, and just delegate calls to the
// corresponding C API calls for MDHCP if the registry indicates that we
// are using MDHCP. Otherwise they try to mimic the MDHCP behavior using
// local allocation.


#include "stdafx.h"
#include "resource.h"
#include "local.h"

#include <string.h>
#include <time.h>
#include <winsock2.h>

DWORD
LocalEnumerateScopes(
    IN OUT PMCAST_SCOPE_ENTRY pScopeList,
    IN OUT PDWORD             pScopeLen,
    OUT    PDWORD             pScopeCount,
    IN OUT BOOL *             pfLocal
    )
/*++

Routine Description:

    This routine enumerates the multicast scopes available on the network.

Arguments:

    pScopeList - pointer to the buffer where the scopelist is to be retrieved.
                 This parameter can be NULL if only the length of the buffer is
                 being retrieved.

                 When this buffer is NULL, the API will force the re-query of the
                 scope list from the MDHCP servers.

    pScopeLen  - Pointer to a variable that specifies the size, in bytes, of the
                 buffer pointed to by the pScopeList parameter. When the function returns,
                 this variable contains the size of the data copied to pScopeList;

                 The pScopeLen parameter can not be NULL.

                 If the buffer specified by pScopeList parameter is not large enough
                 to hold the data, the function returns the value ERROR_MORE_DATA, and
                 stores the required buffer size, in bytes, into the variable pointed
                 to by pScopeLen.

                 If pScopeList is NULL, and pScopeLen is non-NULL, the function returns
                 ERROR_SUCCESS, and stores the size of the data, in bytes, in the variable
                 pointed to by pScopeLen. This lets an application determine the best
                 way to allocate a buffer for the scope list.

    pScopeCount - Pointer to a variable that will store total number of scopes returned
                 in the pScopeList buffer.

    pfLocal     - points to a BOOL value that on exit is set to true if this
                  is a locally-generated scope. If set to true on entry, then
                  we go straight to local alloc (this usually means that this
                  is the second call and the previous call returned local
                  alloc)


Return Value:

    The status of the operation.

--*/
{
    _ASSERTE( pfLocal );


    if ( *pfLocal == FALSE )
    {
        DWORD dwResult = McastEnumerateScopes(
            AF_INET,            // this means IPv4
            pScopeList == NULL, // requery if asking for num scopes
            pScopeList,
            pScopeLen,
            pScopeCount);

        if ( dwResult == ERROR_SUCCESS )
        {
            *pfLocal = FALSE;

            return dwResult;
        }
    }

    _ASSERTE(pScopeLen);
    _ASSERTE(pScopeCount);

    *pfLocal = TRUE;

    //
    // First set up the string for the name of the scope.
    //

    const  int    ciAllocSize = 2048;
    static BOOL   fFirstCall = TRUE;
    static WCHAR  wszScopeDesc[ciAllocSize] = L"";
    static DWORD  dwScopeDescLen = 0;

    if ( fFirstCall )
    {
        //
        // Get the string from the string table.
        //

        int iReturn = LoadString( _Module.GetModuleInstance(),
                                  IDS_LocalScopeName,
                                  wszScopeDesc,
                                  ciAllocSize - 1 );

        if ( iReturn == 0 )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        dwScopeDescLen = sizeof(WCHAR) * (lstrlenW(wszScopeDesc) + 1);

        fFirstCall = FALSE;
    }

    //
    // When doing local allocation, there is only one scope. Return info about it.
    //

    *pScopeCount = 1;
    *pScopeLen   = sizeof(MCAST_SCOPE_ENTRY) + dwScopeDescLen;

    if (pScopeList != NULL)
    {
        // wszDest points to the place in pScopeList right after the contents
        // of the MCAST_SCOPE_ENTRY structure.
        WCHAR * wszDest = (WCHAR *) (((BYTE *) pScopeList) + sizeof(MCAST_SCOPE_ENTRY));

        CopyMemory(wszDest, wszScopeDesc, dwScopeDescLen);

        pScopeList[0].ScopeCtx.ScopeID.IpAddrV4   = 0x01000000; // 1 -- net byte order
        pScopeList[0].ScopeCtx.ServerID.IpAddrV4  = 0x0100007f; // 127.0.0.1 localhost -- net byte order
        pScopeList[0].ScopeCtx.Interface.IpAddrV4 = 0x0100007f; // 127.0.0.1 loopback if -- net byte order
        pScopeList[0].ScopeDesc.Length            = (USHORT) dwScopeDescLen;
        pScopeList[0].ScopeDesc.MaximumLength     = (USHORT) dwScopeDescLen;
        pScopeList[0].ScopeDesc.Buffer            = wszDest;

        pScopeList[0].TTL = 15; 
        
    }

    return ERROR_SUCCESS;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// ConvertLeaseInfoToRequest
//
// Given pRequestInfo, which points to a valid, contiguously stored
// MCAST_LEASE_INFO (aka MCAST_LEASE_RESPONSE) structure for a request, fill
// out the MCAST_LEASE_REQUEST structure pointed to by pRealRequest. The
// pRealRequest structure points to the same addresses array as the
// pRequestInfo structure, which makes it convenient to allocate on the stack.
//

void
ConvertLeaseInfoToRequest(
    IN  PMCAST_LEASE_INFO     pRequestInfo,
    OUT PMCAST_LEASE_REQUEST  pRealRequest
    )
{
    DWORD dwDuration = (DWORD)(pRequestInfo->LeaseEndTime - pRequestInfo->LeaseStartTime);

    pRealRequest->LeaseStartTime     = pRequestInfo->LeaseStartTime;
    pRealRequest->MaxLeaseStartTime  = pRequestInfo->LeaseStartTime;
    pRealRequest->LeaseDuration      = dwDuration;
    pRealRequest->MinLeaseDuration   = dwDuration;
    pRealRequest->ServerAddress      = pRequestInfo->ServerAddress;
    pRealRequest->MinAddrCount       = pRequestInfo->AddrCount;
    pRealRequest->AddrCount          = pRequestInfo->AddrCount;
    pRealRequest->pAddrBuf           = pRequestInfo->pAddrBuf; // see above
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

DWORD
LocalRequestAddress(
    IN     BOOL                   fLocal,
    IN     LPMCAST_CLIENT_UID     pRequestID,
    IN     PMCAST_SCOPE_CTX       pScopeCtx,
    IN     PMCAST_LEASE_INFO      pAddrRequest,
    IN OUT PMCAST_LEASE_INFO      pAddrResponse
    )
/*++

Routine Description:

    This routine request multicast address(es) from the MDHCP server.

Arguments:

    fLocal     - if true, do not go to server

    pRequestID - Unique identifier for this request. Client is responsible for
                 generating unique identifier for every request. One recommendation
                 is to use application specific context hashed by time.

    pRequestIDLen - Length of the pRequestID buffer.

    pScopeCtx  - Pointer to the context of the scope from which the address is to
                 be allocated. Scope context has to be retrieved via MDhcpEnumerateScopes
                 call before calling this.

    pAddrRequest - Pointer to the block containing all the parameters pertaining
                 to multicast address request.

    pAddrResponse - Pointer to the block which contains the response paramters for
                 the multicast address request.

Return Value:

    The status of the operation.

--*/
{
    if ( ! fLocal )
    {
        MCAST_LEASE_REQUEST RealRequest;

        ConvertLeaseInfoToRequest(
            pAddrRequest,
            & RealRequest
            );

        //
        // Tell the C API where to stick the returned addresses and how many
        // we have space for.
        //

        pAddrResponse->pAddrBuf =
            ( (PBYTE) pAddrResponse ) + sizeof( MCAST_LEASE_INFO );
        pAddrResponse->AddrCount = RealRequest.AddrCount;


        return McastRequestAddress(AF_INET,        // this means IPv4
                                   pRequestID,
                                   pScopeCtx,
                                   & RealRequest,
                                   pAddrResponse);
    }

    //
    // Local allocation case...
    //

    DWORD dwAddrCount = pAddrRequest->AddrCount;

    if (dwAddrCount == 0)
    {
        return ERROR_INVALID_DATA;
    }

    //
    // Seed the random number generator the first time we are called.
    //

    static bool fFirstCall = true;

    if ( fFirstCall )
    {
        srand( (unsigned)time( NULL ) );
        fFirstCall = false;
    }

    //
    // We always grant whatever request the user wants. Start by copying the
    // relevant fields. This gives us valid start time, end time, and
    // address count. Still need to fill out serveraddress and array of
    // returned addresses.
    //

    CopyMemory(pAddrResponse,
               pAddrRequest,
               sizeof(MCAST_LEASE_INFO));

    //
    // The array of returned addresses will be contiguous in the strucutre.
    //

    pAddrResponse->pAddrBuf =
        ( (PBYTE) pAddrResponse ) + sizeof( MCAST_LEASE_INFO );

    //
    // The server address is the local host: 127.0.0.1 in net byte order
    //

    pAddrResponse->ServerAddress.IpAddrV4 = 0x0100007f;

    //
    // Allocate the random addresses (Based on Rajeev's code)
    // note: we do not support ipv6 (ipv4 assumed throughout)
    //

    // get mask
    DWORD dwNetworkMask = 0xffff8000;    // 255.255.128.0

    // if the desired number of addresses are more than the range allows
    if ( dwAddrCount > ~ dwNetworkMask )
    {
        return ERROR_INVALID_DATA;
    }

    // get base address
    DWORD dwBaseAddress = 0xe0028000;    // 224.2.128.0

    // transform base address (AND base address with mask)
    dwBaseAddress &= dwNetworkMask;

    //
    // choose unmasked bits of generated number and OR with transformed
    // base address
    // ZoltanS: added - 1 so that we can give out odd addresses too
    //

    DWORD * pdwAddresses = (DWORD *) pAddrResponse->pAddrBuf;

    pdwAddresses[0] = htonl(
        dwBaseAddress | ( rand() & ( ~ dwNetworkMask - (dwAddrCount - 1) )) );

    //
    // Set the rest of the addresses.
    //

    DWORD dwCurrAddr = ntohl(pdwAddresses[0]);

    for (DWORD i = 1; i < dwAddrCount; i++)
    {
        pdwAddresses[i] = htonl( ++dwCurrAddr );
    }

    return ERROR_SUCCESS;
}



DWORD
LocalRenewAddress(
    IN     BOOL                   fLocal,
    IN     LPMCAST_CLIENT_UID     pRequestID,
    IN     PMCAST_LEASE_INFO      pRenewRequest,
    IN OUT PMCAST_LEASE_INFO      pRenewResponse
    )
/*++

Routine Description:

    This routine renews multicast address(es) from the MDHCP server.

Arguments:

    fLocal     - if true, do not go to server

    pRequestID - Unique identifier that was used when the address(es) were
                 obtained initially.

    RequestIDLen - Length of the pRequestID buffer.

    pRenewRequest - Pointer to the block containing all the parameters pertaining
                 to the renew request.

    pRenewResponse - Pointer to the block which contains the response paramters for
                 the renew request.

Return Value:

    The status of the operation.

--*/
{
    if ( ! fLocal )
    {
        MCAST_LEASE_REQUEST RealRequest;

        ConvertLeaseInfoToRequest(
            pRenewRequest,
            & RealRequest
            );

        //
        // Tell the C API where to stick the returned addresses and how many
        // we have space for.
        //

        pRenewResponse->pAddrBuf =
            ( (PBYTE) pRenewResponse ) + sizeof( MCAST_LEASE_INFO );
        pRenewResponse->AddrCount = RealRequest.AddrCount;


        return McastRenewAddress(AF_INET,        // this means IPv4
                                 pRequestID,
                                 & RealRequest,
                                 pRenewResponse);
    }

    //
    // Local renewal...
    //

    //
    // We always grant whatever renewal the user wants. Just copy the
    // structure from the request to the response, keeping in mind
    // that the pAddrBuf member has to change to avoid referencing
    // the old structure.
    //
    // Note that we ASSUME that the response strucutre is big enough
    // to hold the response including all the addresses, allocated
    // CONTIGUOUSLY.
    // note: assumes IPv4
    //

    CopyMemory( pRenewResponse,
                pRenewRequest,
                sizeof(MCAST_LEASE_INFO) +
                    sizeof(DWORD) * pRenewRequest->AddrCount
                );

    //
    // The pAddrbuf member has to change to avoid referencing the old
    // structure. Make it point to the end of this one.
    //

    pRenewResponse->pAddrBuf =
        ( (PBYTE) pRenewResponse ) + sizeof( MCAST_LEASE_INFO );

    return ERROR_SUCCESS;
}

DWORD
LocalReleaseAddress(
    IN     BOOL                  fLocal,
    IN     LPMCAST_CLIENT_UID    pRequestID,
    IN     PMCAST_LEASE_INFO     pReleaseRequest
    )
/*++

Routine Description:

    This routine releases multicast address(es) from the MDHCP server.

Arguments:

    pRequestID - Unique identifier that was used when the address(es) were
                 obtained initially.

    RequestIDLen - Length of the pRequestID buffer.

    pReleaseRequest - Pointer to the block containing all the parameters pertaining
                 to the release request.

Return Value:

    The status of the operation.

--*/
{
    if ( ! fLocal )
    {
        MCAST_LEASE_REQUEST RealRequest;

        ConvertLeaseInfoToRequest(
            pReleaseRequest,
            & RealRequest
            );

        return McastReleaseAddress(AF_INET,        // this means IPv4
                                   pRequestID,
                                   & RealRequest);
    }

    // locally, we don't care about releases.

    return ERROR_SUCCESS;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mdhcp\local.h ===
// MDHCP COM wrapper
// local.h by Zoltan Szilagyi
// Copyright (c) 1998-1999 Microsoft Corporation
//
// This file contains prototypes for my implementation of local address
// allocation, plus a prototype for a function to see if we are doing
// local address allocation (based on the registry). Implementation is in
// local.cpp.
//
// These functions are called within CMDhcp, and just delegate calls to the
// corresponding C API calls for MDHCP if the registry indicates that we
// are using MDHCP. Otherwise they try to mimic the MDHCP behavior using
// local allocation.

#ifndef _LOCAL_H_
#define _LOCAL_H_

#if 0
// Returns zero if we use MDHCP, nonzero if we use local allocation.
DWORD LocalAllocation(void);
#endif


DWORD
LocalEnumerateScopes(
    IN OUT  PMCAST_SCOPE_ENTRY    pScopeList,
    IN OUT  PDWORD                pScopeLen,
    OUT     PDWORD                pScopeCount,
    IN OUT  BOOL *                pfLocal
    );

DWORD
LocalRequestAddress(
    IN      BOOL                  fLocal,
    IN      LPMCAST_CLIENT_UID    pRequestID,
    IN      PMCAST_SCOPE_CTX      pScopeCtx,
    IN      PMCAST_LEASE_INFO     pAddrRequest,
    IN OUT  PMCAST_LEASE_INFO     pAddrResponse
    );

DWORD
LocalRenewAddress(
    IN      BOOL                  fLocal,
    IN      LPMCAST_CLIENT_UID    pRequestID,
    IN      PMCAST_LEASE_INFO     pRenewRequest,
    IN OUT  PMCAST_LEASE_INFO     pRenewResponse
    );

DWORD
LocalReleaseAddress(
    IN      BOOL                  fLocal,
    IN      LPMCAST_CLIENT_UID    pRequestID,
    IN      PMCAST_LEASE_INFO     pReleaseRequest
    );

#endif // _LOCAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mdhcp\resource.h ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    resource.h

Abstract:


Author:

*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mdhcp.rc
//
#define IDR_MDhcp                       102
#define IDS_LocalScopeName              103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           120
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mdhcp\objsf.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    objsf.cpp

Abstract:

--*/

#include <stdafx.h>
#include "objsf.h"

CComAutoCriticalSection CObjectWithSite::s_ObjectWithSiteCritSection;
CObjectWithSite::EnValidation CObjectWithSite::s_enValidation = CObjectWithSite::UNVALIDATED;

CComAutoCriticalSection CObjectSafeImpl::s_CritSection;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mdhcp\mdhcp.cpp ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    mdhcp.cpp 

Abstract:
    Implementation of DLL Exports.

Author:

*/

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f mdhcpps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "mdhcp.h"

#include "CMDhcp.h"
#include "scope.h"
#include "lease.h"

#ifdef DEBUG_HEAPS
// ZoltanS: for heap debugging
#include <crtdbg.h>
#include <stdio.h>
#endif // DEBUG_HEAPS

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_McastAddressAllocation, CMDhcp)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
#ifdef DEBUG_HEAPS
	// ZoltanS: turn on leak detection
	_CrtSetDbgFlag( _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) | _CRTDBG_LEAK_CHECK_DF );

	// ZoltanS: force a memory leak
	char * leak = new char [ 1977 ];
    	sprintf(leak, "mdhcp.dll NORMAL leak");
    	leak = NULL;
#endif // DEBUG_HEAPS

        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);

#ifdef MSPLOG
        // Register for trace output.
        MSPLOGREGISTER(_T("mdhcp"));
#endif // MSPLOG

	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
#ifdef MSPLOG
        // Deregister for trace output.
        MSPLOGDEREGISTER();
#endif // MSPLOG
        
        _Module.Term();
    }

	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mdhcp\objsf.h ===
/*++
Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    objsf.h

Abstract:

    Definitions for CMdhcpObjectSafety class.
--*/


#ifndef _MDHCP_OBJECT_SAFETY_
#define _MDHCP_OBJECT_SAFETY_

#define IDD_TAPI_SECURITY_DIALOG        500
#define IDC_SECURITY_WARNING_TEXT       502
#define IDC_DONOT_PROMPT_IN_THE_FUTURE  503
#define ID_YES                          505
#define ID_NO                           506
#define ID_YES_DONT_ASK_AGAIN           557

#define IDS_MADCAP_SEC_PROMPT           92

#include <PromptedObjectSafety.h>
#include <ScrpScrtDlg.h>
#include <ObjectWithSite.h>

static const TCHAR gszCookieName[] = _T("Mdhcp");


//
// this will pop a message box asking if we want to enable object safety
//

class CMdhcpObjectSafety : 
    public CPromptedObjectSafety, 
    public CObjectWithSite
{
public:

    //
    // call CObjectWithSite's constructor and pass in the cookie name
    //

    CMdhcpObjectSafety()
        :CObjectWithSite(gszCookieName)
    {
    }


    //
    // implementing CPromptedObjectSafety's pure virtual method
    // if the page is not in the safe list, and this is the first 
    // time we are asking, prompt the user. act accordingly.
    // if the user chooses, mark the page safe for scripting (persistently)
    //
    
    virtual BOOL Ask()
    {

        //
        // if the object does not have a site pointer, we should not consider
        // it to be safe. Do not display the prompt.
        //

        if ( !HaveSite() )
        {

          return FALSE;
        }


        EnValidation enCurrentValidation = GetValidation();
        
        //
        // if the page has not been validated, try to validate it.
        //

        if (UNVALIDATED == enCurrentValidation)
        {
            if( IsIntranet())
            {
                Validate(VALIDATED_SAFE);
                enCurrentValidation = GetValidation();
                return TRUE;
            }

           CScriptSecurityDialog *pDialog = new CScriptSecurityDialog;
       
           //
           // if succeeded displaying the dialog
           // validate the page based on user's input
           //
           
           if ( NULL != pDialog )
           {

               switch (pDialog->DoModalWithText(IDS_MADCAP_SEC_PROMPT))
               {

                case ID_YES:

                    Validate(VALIDATED_SAFE);
                    break;

                case ID_NO:

                    Validate(VALIDATED_UNSAFE);
                    break;

                case ID_YES_DONT_ASK_AGAIN:

                    Validate(VALIDATED_SAFE_PERMANENT);
                    break;

                default:

                    break;

               }

               delete pDialog;

                // 
                // get the new validation.
                //

                enCurrentValidation = GetValidation();

           } // if (NULL != pDialog) 

        }

        //
        // by now we either got the validation data or validation did not change
        //
        // return true if the page is validated as safe
        //

        return (VALIDATED_SAFE == enCurrentValidation) ;
    }
};

#endif // _MDHCP_OBJECT_SAFETY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mdhcp\stdafx.cpp ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    stdafx.cpp 

Abstract:
    source file that includes just the standard includes
    stdafx.pch will be the pre-compiled header
    stdafx.obj will contain the pre-compiled type information


Author:

*/

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mdhcp\scope.h ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    scope.h

Abstract:
    Definition of the CMDhcpScope class

Author:

*/

#ifndef _MDHCP_COM_WRAPPER_SCOPE_H_
#define _MDHCP_COM_WRAPPER_SCOPE_H_

/////////////////////////////////////////////////////////////////////////////
// CMDhcpScope

class CMDhcpScope : 
    public CComDualImpl<IMcastScope, &IID_IMcastScope, &LIBID_McastLib>, 
    public CComObjectRootEx<CComObjectThreadModel>,
    public CObjectSafeImpl
{

// Non-interface methods.
public:
    CMDhcpScope();
    
    void FinalRelease(void);

    ~CMDhcpScope();

    HRESULT Initialize(
        MCAST_SCOPE_ENTRY scope,
        BOOL fLocal
        );
    
    HRESULT GetLocal(
        BOOL * pfLocal
        );
    
    BEGIN_COM_MAP(CMDhcpScope)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IMcastScope)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
    END_COM_MAP()

    DECLARE_GET_CONTROLLING_UNKNOWN()

protected:
    MCAST_SCOPE_ENTRY   m_scope;  // wrapped structure
    BOOL                m_fLocal; // local scope?
    IUnknown          * m_pFTM;   // pointer to free threaded marshaler

// IMcastScope
public:
    STDMETHOD (get_ScopeID) (
        long *pID
        );

    STDMETHOD (get_ServerID) (
        long *pID
        );

    STDMETHOD (get_InterfaceID) (
        long * pID
        );

    STDMETHOD (get_ScopeDescription) (
        BSTR *ppAddress
        );

    STDMETHOD (get_TTL) (
        long *plTTL
        );
};

#endif // _MDHCP_COM_WRAPPER_SCOPE_H_

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mdhcp\scope.cpp ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    scope.cpp

Abstract:
    Implementation of CMDhcpScope.

Author:

*/

#include "stdafx.h"

#include <winsock2.h>

#include "mdhcp.h"
#include "scope.h"

/////////////////////////////////////////////////////////////////////////////
// Constructor

CMDhcpScope::CMDhcpScope() : m_pFTM(NULL), m_fLocal(FALSE)
{
    LOG((MSP_TRACE, "CMDhcpScope constructor: enter"));
    LOG((MSP_TRACE, "CMDhcpScope constructor: exit"));
}

/////////////////////////////////////////////////////////////////////////////
// Called by our creator only -- not part of IMDhcpScope.

HRESULT CMDhcpScope::Initialize(
    MCAST_SCOPE_ENTRY scope,
    BOOL fLocal
    )
{
    LOG((MSP_TRACE, "CMDhcpScope::Initialize: enter"));

    HRESULT hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                & m_pFTM );

    if ( FAILED(hr) )
    {
        LOG((MSP_INFO, "CMDhcpScope::Initialize - "
            "create FTM returned 0x%08x; exit", hr));

        return hr;
    }


    m_fLocal = fLocal;

    // elementwise copy...
    m_scope = scope;

    // except for wide character pointer, which points to a string that will
    // get deleted shortly. We need to make a copy of that string.
    // (We allocate too many bytes here -- better safe than sorry. :)
    
    m_scope.ScopeDesc.Buffer = new WCHAR[m_scope.ScopeDesc.MaximumLength + 1];

    if (m_scope.ScopeDesc.Buffer == NULL)
    {
        LOG((MSP_ERROR, "scope Initialize: out of memory for buffer copy"));
        return E_OUTOFMEMORY;
    }

    lstrcpynW(m_scope.ScopeDesc.Buffer,
              scope.ScopeDesc.Buffer,
              m_scope.ScopeDesc.MaximumLength);

    LOG((MSP_TRACE, "CMDhcpScope::Initialize: exit"));
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Destructors

void CMDhcpScope::FinalRelease(void)
{
    LOG((MSP_TRACE, "CMDhcpScope::FinalRelease: enter"));
 
    // this is our private copy of the string.
    delete m_scope.ScopeDesc.Buffer;

    if ( m_pFTM )
    {
        m_pFTM->Release();
    }

    LOG((MSP_TRACE, "CMDhcpScope::FinalRelease: exit"));
}

CMDhcpScope::~CMDhcpScope()
{
    LOG((MSP_TRACE, "CMDhcpScope destructor: enter"));
    LOG((MSP_TRACE, "CMDhcpScope destructor: exit"));
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// IMDhcpScope
//
// This interface is obtained by calling IMDhcp::EnumerateScopes or
// IMDhcp::get_Scopes. It encapsulates all the properties of a multicast
// scope. You can use the methods of this interface to get information about
// the scope. This is a "read-only" interface in that it has "get" methods
// but no "put" methods.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// IMDhcpScope::get_ScopeID
//
// Parameters
//     pID [out] Pointer to a long that will receive the ScopeID of this
//                 scope, which is the ID that was assigned to this scope
//                 when it was configured on the MDHCP server.
//
// Return Values
//     S_OK          Success
//     E_POINTER     The caller passed in an invalid pointer argument
//
// Description
//     Use this method to obtain the ScopeID associated with this scope. The
//     ScopeID and ServerID are needed to select this scope in subsequent
//     calls to IMDhcp::RequestAddress, IMDhcp::RenewAddress, or
//     IMDhcp::ReleaseAddress.
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMDhcpScope::get_ScopeID(
    long *pID
    )
{
    LOG((MSP_TRACE, "CMDhcpScope::get_ScopeID: enter"));

    if ( IsBadWritePtr(pID, sizeof(long)) )
    {
        LOG((MSP_ERROR, "get_ScopeID: bad pointer passed in"));
        return E_POINTER;
    }

    //
    // Stored in network byte order -- we convert to host byte order
    // here in order to be UI friendly
    //

    *pID = ntohl( m_scope.ScopeCtx.ScopeID.IpAddrV4 );

    LOG((MSP_TRACE, "CMDhcpScope::get_ScopeID: exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// IMDhcpScope::get_ServerID
//
// Parameters
//     pID [out] Pointer to a long that will receive the ServerID of this
//                 scope, which is the ID that was assigned to the MDHCP
//                 server that published this scope at the time that the
//                 MDHCP server was configured.
//
// Return Values
//     S_OK             Success
//     E_POINTER        The caller passed in an invalid pointer argument
//
// Description
//     Use this method to obtain the ServerID associated with this scope.
//     The ServerID is provided for informational purposes only; it is not
//     required as input to any of the methods in these interfaces.
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMDhcpScope::get_ServerID(
    long *pID
    )
{
    LOG((MSP_TRACE, "CMDhcpScope::get_ServerID: enter"));

    if ( IsBadWritePtr(pID, sizeof(long)) )
    {
        LOG((MSP_ERROR, "get_ServerID: bad pointer passed in"));
        return E_POINTER;
    }

    *pID = m_scope.ScopeCtx.ServerID.IpAddrV4;

    LOG((MSP_TRACE, "CMDhcpScope::get_ServerID: exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// IMDhcpScope::get_InterfaceID
//
// Parameters
//     pID [out] Pointer to a long that will receive the InterfaceID of this
//                 scope, which identifies the interface on which the server
//                 that published this scope resides. This is normally the
//                 network address of the interface.
//
// Return Values
//     S_OK         Success
//     E_POINTER    The caller passed in an invalid pointer argument
//
// Description
//     Use this method to obtain the ServerID associated with this scope. The
//     InterfaceID is provided for informational purposes only; it is not
//     required as input to any of the methods in these interfaces. However,
//     it may factor into the application's (or the user's) decision as to
//     which scope to use when requesting an address. This is because, in a
//     multi-homed scenario, using a multicast address on one network that was
//     obtained from a server on another network may cause address conflicts.
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMDhcpScope::get_InterfaceID(
        long * pID
        )
{
    LOG((MSP_TRACE, "CMDhcpScope::get_InterfaceID - enter"));

    if ( IsBadWritePtr(pID, sizeof(long)) )
    {
        LOG((MSP_ERROR, "CMDhcpScope::get_InterfaceID - "
            "bad pointer passed in"));

        return E_POINTER;
    }

    *pID = m_scope.ScopeCtx.Interface.IpAddrV4;

    LOG((MSP_TRACE, "CMDhcpScope::get_InterfaceID -  exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// IMDhcpScope::get_ScopeDescription
//
// Parameters
//     ppAddress [out] Pointer to a BSTR (size-tagged Unicode string pointer)
//                       that will receive a description of this scope. The
//                       description was established when this scope was
//                       configured on the MDHCP server.
//
// Return Values
//     S_OK             Success
//     E_POINTER        The caller passed in an invalid pointer argument
//     E_OUTOFMEMORY    Not enough memory to allocate the string
//
// Description
//     Use this method to obtain a textual description associated with this
//     scope. The description is used only for clarifying the purpose or
//     meaning of a scope and is not required as input to any of the methods
//     in these interfaces.
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMDhcpScope::get_ScopeDescription(
    BSTR *ppAddress
    )
{
    LOG((MSP_TRACE, "CMDhcpScope::get_ScopeDescription: enter"));

    if ( IsBadWritePtr(ppAddress, sizeof(BSTR)) )
    {
        LOG((MSP_ERROR, "get_ScopeDescription: bad pointer passed in"));
        return E_POINTER;
    }

    // This allocates space on OLE's heap, copies the wide character string
    // to that space, fille in the BSTR length field, and returns a pointer
    // to the WCHAR array part of the BSTR.
    *ppAddress = SysAllocString(m_scope.ScopeDesc.Buffer);

    if ( *ppAddress == NULL )
    {
        LOG((MSP_ERROR, "get_ScopeDescription: out of memory in string "
            "allocation"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CMDhcpScope::get_ScopeDescription: exit"));
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CMDhcpScope::get_TTL(
    long * plTtl
    )
{
    LOG((MSP_TRACE, "CMDhcpScope::get_TTL - enter"));

    if ( IsBadWritePtr( plTtl, sizeof(long) ) )
    {
        LOG((MSP_ERROR, "get_TTL: bad pointer passed in - exit E_POINTER"));
        return E_POINTER;
    }

    *plTtl = m_scope.TTL;
    
    LOG((MSP_TRACE, "CMDhcpScope::get_TTL - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// public method not on any interface
//

HRESULT CMDhcpScope::GetLocal(BOOL * pfLocal)
{
    LOG((MSP_TRACE, "CMDhcpScope::GetLocal: enter"));

    _ASSERTE( ! IsBadWritePtr( pfLocal, sizeof(BOOL) ) );

    *pfLocal = m_fLocal;
    
    LOG((MSP_TRACE, "CMDhcpScope::GetLocal: exit S_OK"));

    return S_OK;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mdhcp\stdafx.h ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    Precompiled header file for MDHCP COM wrapper.

*/

#ifndef _MDHCP_COM_WRAPPER_STDAFX_H_
    #define _MDHCP_COM_WRAPPER_STDAFX_H_

    #define _ATL_FREE_THREADED
    #include <atlbase.h>
    extern CComModule _Module;
    #include <atlcom.h>

    #include <limits.h>

    #include <msplog.h>

    #include <ntsecapi.h> // for UNICODE_STRING

    #include <dhcpcapi.h>

    extern "C" {
        #include <madcapcl.h>
    }

    #include "objectsafeimpl.h"

    //
    // We use MCAST_LEASE_INFO for all internal storage of lease info. This is
    // just our name for MCAST_LEASE_RESPONSE. Where the C API requires
    // MCAST_LEASE_REQUEST, we just construct an MCAST_LEASE_REQUEST based on
    // the fields of the MCAST_LEASE_INFO.
    //

    typedef  MCAST_LEASE_RESPONSE   MCAST_LEASE_INFO;
    typedef  PMCAST_LEASE_RESPONSE  PMCAST_LEASE_INFO;

#endif // _MDHCP_COM_WRAPPER_STDAFX_H_

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mspbase\mspcall.cpp ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    MSPCall.cpp 

Abstract:

    This module contains implementation of CMSPCall.

--*/

#include "precomp.h"
#pragma hdrstop

/////////////////////////////////////////////////////////////////////////////
// CMSPCallBase
/////////////////////////////////////////////////////////////////////////////

CMSPCallBase::CMSPCallBase()
    : m_pMSPAddress(NULL),
      m_htCall(NULL),
      m_dwMediaType(0)
{
    LOG((MSP_TRACE, "CMSPCallBase::CMSPCallBase[%p] entered.", this));

    LOG((MSP_TRACE, "CMSPCallBase::CMSPCallBase exited."));
}

    
CMSPCallBase::~CMSPCallBase()
{
    LOG((MSP_TRACE, "CMSPCallBase::~CMSPCallBase[%p] entered.", this));


    // We wait until destructor to release the address because
    // they might be used by calls from the stream. If the last stream
    // has released its reference, this pointer will not be used again.

    // If the MSPAddress had a refcount on the call, it should have been
    // released in the ShutdownMSPCall() method. 

    // release the address 
    if (m_pMSPAddress != NULL)
    {
        LOG((MSP_TRACE, "CMSPCallBase::~CMSPCallBase releasing address [%p].", m_pMSPAddress));    

        m_pMSPAddress->MSPAddressRelease();
    }

    LOG((MSP_TRACE, "CMSPCallBase::~CMSPCallBase exited."));
}

// ITStreamControl methods, called by the app.
STDMETHODIMP CMSPCallBase::EnumerateStreams(
    OUT     IEnumStream **      ppEnumStream
    )
{
    LOG((MSP_TRACE, 
        "EnumerateStreams entered. ppEnumStream:%x", ppEnumStream));

    //
    // Check parameters.
    //

    if (MSPB_IsBadWritePtr(ppEnumStream, sizeof(VOID *)))
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateStreams - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // First see if this call has been shut down.
    // acquire the lock before accessing the stream object list.
    //

    CLock lock(m_lock);

    if (m_Streams.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateStreams - "
            "call appears to have been shut down - exit E_UNEXPECTED"));

        // This call has been shut down.
        return E_UNEXPECTED;
    }

    //
    // Create an enumerator object.
    //

    typedef _CopyInterface<ITStream> CCopy;
    typedef CSafeComEnum<IEnumStream, &IID_IEnumStream, 
                ITStream *, CCopy> CEnumerator;

    HRESULT hr;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = CComObject<CEnumerator>::CreateInstance(&pEnum);
    if (pEnum == NULL)
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateStreams - "
            "Could not create enumerator object, %x", hr));

        return hr;
    }

    //
    // query for the IID_IEnumStream i/f
    //

    hr = pEnum->_InternalQueryInterface(IID_IEnumStream, (void**)ppEnumStream);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateStreams - "
            "query enum interface failed, %x", hr));

        delete pEnum;
        return hr;
    }

    //
    // Init the enumerator object. The CSafeComEnum can handle zero-sized
    // array.
    //

    hr = pEnum->Init(
        m_Streams.GetData(),                        // the begin itor
        m_Streams.GetData() + m_Streams.GetSize(),  // the end itor, 
        NULL,                                       // IUnknown
        AtlFlagCopy                                 // copy the data.
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateStreams - "
            "init enumerator object failed, %x", hr));

        (*ppEnumStream)->Release();
        return hr;
    }

    LOG((MSP_TRACE, "CMSPCallBase::EnumerateStreams - exit S_OK"));

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//
// return a VB collection of streams
//

STDMETHODIMP CMSPCallBase::get_Streams(
    OUT     VARIANT *           pVariant
    )
{
    LOG((MSP_TRACE, "CMSPCallBase::get_Streams - enter"));

    //
    // Check parameters.
    //

    if ( MSPB_IsBadWritePtr(pVariant, sizeof(VARIANT) ) )
    {
        LOG((MSP_ERROR, "CMSPCallBase::get_Streams - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // See if this call has been shut down. Acquire the lock before accessing
    // the stream object list.
    //

    CLock lock(m_lock);

    if (m_Streams.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CMSPCallBase::get_Streams - "
            "call appears to have been shut down - exit E_UNEXPECTED"));

        // This call has been shut down.
        return E_UNEXPECTED;
    }

    //
    // create the collection object - see mspcoll.h
    //

    typedef CTapiIfCollection< ITStream * > StreamCollection;
    CComObject<StreamCollection> * pCollection;
    HRESULT hr = CComObject<StreamCollection>::CreateInstance( &pCollection );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPCallBase::get_Streams - "
            "can't create collection - exit 0x%08x", hr));

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;

    hr = pCollection->_InternalQueryInterface(IID_IDispatch,
                                              (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPCallBase::get_Streams - "
            "QI for IDispatch on collection failed - exit 0x%08x", hr));

        delete pCollection;

        return hr;
    }

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one.
    //

    hr = pCollection->Initialize( m_Streams.GetSize(),
                                  m_Streams.GetData(),
                                  m_Streams.GetData() + m_Streams.GetSize() );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMSPCallBase::get_Streams - "
            "Initialize on collection failed - exit 0x%08x", hr));
        
        pDispatch->Release();
        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    LOG((MSP_INFO, "CMSPCallBase::get_Streams - "
        "placing IDispatch value %08x in variant", pDispatch));

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((MSP_TRACE, "CMSPCallBase::get_Streams - exit S_OK"));
 
    return S_OK;
}

// methods called by the MSPstream object.
HRESULT CMSPCallBase::HandleStreamEvent(
    IN      MSPEVENTITEM *     pEventItem
    ) const
{
    _ASSERTE(!MSPB_IsBadWritePtr(pEventItem, sizeof(MSPEVENTITEM)));

    pEventItem->MSPEventInfo.hCall = m_htCall;
    return m_pMSPAddress->PostEvent(pEventItem);
}

STDMETHODIMP CMSPCallBase::CreateStream(
    IN      long                lMediaType,
    IN      TERMINAL_DIRECTION  Direction,
    IN OUT  ITStream **         ppStream
    )
/*++

Routine Description:


Arguments:

  
Return Value:

S_OK

E_POINTER
E_OUTOFMEMORY
TAPI_E_INVALIDMEDIATYPE
TAPI_E_INVALIDTERMINALDIRECTION
TAPI_E_INVALIDTERMINALCLASS

--*/
{
    LOG((MSP_TRACE, 
        "CreateStream--dwMediaType:%x, Direction:%x, ppStream %x",
        lMediaType, Direction, ppStream
        ));
 
    if ( ! IsValidSingleMediaType( (DWORD) lMediaType, m_dwMediaType) )
    {
        LOG((MSP_ERROR, 
            "wrong media type:%x, call media type:%x",
            lMediaType, m_dwMediaType
            ));

        return TAPI_E_INVALIDMEDIATYPE;
    }

    if (MSPB_IsBadWritePtr(ppStream, sizeof (VOID *)))
    {
        LOG((MSP_ERROR, "Bad pointer, ppStream:%x",ppStream));

        return E_POINTER;
    }

    return InternalCreateStream( (DWORD) lMediaType, Direction, ppStream);
}

HRESULT CMSPCallBase::ReceiveTSPCallData(
        IN      PBYTE               pBuffer,
        IN      DWORD               dwSize
        )
/*++

Routine Description:

  Base class receive TSP call data method... does nothing in base class.
  Implemented so that MSP's that only communicate per-address don't have
  to override it.

Arguments:

  
Return Value:

S_OK

--*/

{
    LOG((MSP_TRACE, "CMSPCallBase::ReceiveTSPCallData - enter"));
    LOG((MSP_TRACE, "CMSPCallBase::ReceiveTSPCallData - exit S_OK"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// Debugging utilities
/////////////////////////////////////////////////////////////////////////////

#ifdef DBGGRAPH

HRESULT
SetGraphLogFile(
    IN IGraphBuilder *pIGraphBuilder
    )
/*++

Routine Description:

    Set the log file for the filter graph.

Arguments:
    
    pIGraphBuilder - The filter graph.

Return Value:

    HRESULT.

--*/
{
    const TCHAR GRAPHLOGPATH[] = _T("c:\\temp\\graph.log");

    HANDLE hFile = CreateFile(
        GRAPHLOGPATH,
        GENERIC_WRITE,
        FILE_SHARE_READ, // sharing
        NULL, // no security
        OPEN_ALWAYS,
        0,    // no attributes, no flags
        NULL  // no template
        );

    if (hFile == INVALID_HANDLE_VALUE)
    {
        LOG((MSP_ERROR, 
            "Can not open graph log file: %s, %x", 
            GRAPHLOGPATH, 
            GetLastError()
            ));
        return S_FALSE;
    }
    
    SetFilePointer(hFile, 0, NULL, FILE_END);
    HRESULT hr = pIGraphBuilder->SetLogFile(hFile);

    return hr;
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CMSPCallMultiGraph
/////////////////////////////////////////////////////////////////////////////

CMSPCallMultiGraph::CMSPCallMultiGraph()
    : CMSPCallBase()
{
    LOG((MSP_TRACE, "CMSPCallMultiGraph::CMSPCallMultiGraph entered."));
    LOG((MSP_TRACE, "CMSPCallMultiGraph::CMSPCallMultiGraph exited."));
}
    
CMSPCallMultiGraph::~CMSPCallMultiGraph()
{
    LOG((MSP_TRACE, "CMSPCallMultiGraph::~CMSPCallMultiGraph entered."));

    LOG((MSP_TRACE, "CMSPCallMultiGraph::~CMSPCallMultiGraph exited."));
}

// methods called by the MSPAddress object.
HRESULT CMSPCallMultiGraph::Init(
    IN      CMSPAddress *       pMSPAddress,
    IN      MSP_HANDLE          htCall,
    IN      DWORD               dwReserved,
    IN      DWORD               dwMediaType
    )
/*++

Routine Description:

This method is called by CMSPAddress when the call is first created. 
It creates a filter graph for the streams. It gets the event handle from 
the graph and posts it to the thread pool. The derived method is supposed
to create its own streams based one the mediatypes.

Arguments:
    

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, 
        "MSP call %x initialize entered, pMSPAddress:%x",
        this, pMSPAddress));

    // No need to acquire locks on this call because it is called only
    // once when the object is created. No other calls can be made on
    // this object at this point.
    _ASSERTE(m_pMSPAddress == NULL);

    // initialize the stream array so that the array is not NULL.
    if (!m_Streams.Grow())
    {
        return E_OUTOFMEMORY;
    }

    pMSPAddress->MSPAddressAddRef();
    m_pMSPAddress   = pMSPAddress;
    m_htCall        = htCall;
    m_dwMediaType   = dwMediaType;

    return S_OK;   
}


HRESULT CMSPCallMultiGraph::ShutDown()
/*++

Routine Description:

Cancel the event waiting and then call the base impelmentaion. Call the
shutdown on the stream objects. Release the references on all the stream 
objects. Acquires the lock in the function.

Arguments:
    
    pIGraphBuilder - The filter graph.

Return Value:

    HRESULT.

--*/

{
    LOG((MSP_TRACE, "MSP call %x is shutting down", this));

    // acquire the lock on the terminal data because we are writing to it.
    m_lock.Lock();

    // release all the streams
    for (int i = m_Streams.GetSize() - 1; i >= 0; i --)
    {
        UnregisterWaitEvent(i);

        ((CMSPStream*)m_Streams[i])->ShutDown();
        m_Streams[i]->Release();
    }
    m_Streams.RemoveAll();
    m_ThreadPoolWaitBlocks.RemoveAll();

    m_lock.Unlock();

    return S_OK;
}

HRESULT CMSPCallMultiGraph::InternalCreateStream(
    IN      DWORD               dwMediaType,
    IN      TERMINAL_DIRECTION  Direction,
    IN OUT  ITStream **         ppStream
    )
/*++

Routine Description:


Arguments:

  
Return Value:

S_OK

E_POINTER
E_OUTOFMEMORY
TAPI_E_INVALIDMEDIATYPE
TAPI_E_INVALIDTERMINALDIRECTION
TAPI_E_INVALIDTERMINALCLASS

--*/
{
    // Create a filter graph and get the media event interface.
    CComPtr <IMediaEvent> pIMediaEvent;
    HRESULT hr = CoCreateInstance(
            CLSID_FilterGraph,     
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IMediaEvent,
            (void **) &pIMediaEvent
            );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "create filter graph %x", hr));
        return hr;
    }

    ITStream * pITStream;
    hr = CreateStreamObject(
        dwMediaType, 
        Direction, 
        pIMediaEvent, 
        &pITStream
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateStreamObject returned:%x",hr));
        return hr;
    }

    // Add the stream into our list of streams.
    m_lock.Lock();
    if (!m_Streams.Add(pITStream))
    {
        ((CMSPStream*)pITStream)->ShutDown();
        pITStream->Release();
        
        m_lock.Unlock();

        LOG((MSP_ERROR, "out of memory is adding a stream."));
        return E_OUTOFMEMORY;
    }

    // register the new graph and stream to the thread pool for graph events.
    hr = RegisterWaitEvent(pIMediaEvent, pITStream);

    if (FAILED(hr))
    {
        ((CMSPStream*)pITStream)->ShutDown();
        pITStream->Release();

        m_Streams.Remove(pITStream);

        m_lock.Unlock();

        LOG((MSP_ERROR, "Register wait returned %x.", hr));
        return hr;
    }
    m_lock.Unlock();

    // AddRef the interface pointer and return it.
    pITStream->AddRef(); 
    *ppStream = pITStream;

    return S_OK;
}

HRESULT CMSPCallMultiGraph::RegisterWaitEvent(
    IN  IMediaEvent *   pIMediaEvent,
    IN  ITStream *      pITStream
    )
{
    // This function should only be called within a critical section 
    // on the object.

    HANDLE hEvent;
    HRESULT hr = pIMediaEvent->GetEventHandle((OAEVENT*)&hEvent);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Can not get the event handle. %x", hr));
        return hr;
    }

    THREADPOOLWAITBLOCK WaitBlock;

    WaitBlock.pContext = (MSPSTREAMCONTEXT *)malloc(sizeof(MSPSTREAMCONTEXT));
    if (WaitBlock.pContext == NULL)
    {
        LOG((MSP_ERROR, "out of memory for the context."));
        return E_OUTOFMEMORY;
    }

    if (!m_ThreadPoolWaitBlocks.Add(WaitBlock))
    {
        free(WaitBlock.pContext);

        LOG((MSP_ERROR, "out of memory adding the waitblock."));
        return E_OUTOFMEMORY;
    }

    // increment the ref count before posting the callback to the thread pool.
    // but for the call, use our special inner object addref.

    this->MSPCallAddRef();
    pITStream->AddRef();
    pIMediaEvent->AddRef();

    WaitBlock.pContext->pMSPCall        = this;
    WaitBlock.pContext->pITStream       = pITStream;
    WaitBlock.pContext->pIMediaEvent    = pIMediaEvent;

    //
    // post the event to the thread pool to wait on.
    //

    HANDLE hWaitHandle = NULL;
    
    BOOL fSuccess = RegisterWaitForSingleObject(
        & hWaitHandle,          // pointer to the returned handle
        hEvent,                 // the event handle to wait for.
        DispatchGraphEvent,     // the callback function.
        WaitBlock.pContext,     // the context for the callback.
        INFINITE,               // wait forever.
        WT_EXECUTEINWAITTHREAD  // use the wait thread to call the callback.
        );

    if ( ( ! fSuccess ) || (hWaitHandle == NULL) )
    {
        LOG((MSP_ERROR, 
            "Register wait call back failed. %x", GetLastError()));

        // decrement the ref count if the posting failed.
        this->MSPCallRelease();
        pITStream->Release();
        pIMediaEvent->Release();

        // Free the context block;
        free(WaitBlock.pContext);
        m_ThreadPoolWaitBlocks.Remove(WaitBlock);

        return E_FAIL;
    }

    // If register succeeded, save the wait handle. We know it is the last one.
    m_ThreadPoolWaitBlocks[m_ThreadPoolWaitBlocks.GetSize() - 1].hWaitHandle 
        = hWaitHandle;

    return S_OK;
}

STDMETHODIMP CMSPCallMultiGraph::RemoveStream(
    IN      ITStream *         pStream
    )
/*++

Routine Description:


Arguments:

  
Return Value:

S_OK

E_INVALIDARG

--*/
{
    LOG((MSP_TRACE, "CMSPCallMultiGraph::RemoveStream - pStream %x", pStream));

    // acquire the lock before accessing the stream object list.
    CLock lock(m_lock);

    int index = m_Streams.Find(pStream);
    if (index < 0)
    {
        LOG((MSP_ERROR, "CMSPCallMultiGraph::RemoveStream - Stream %x is not found.", pStream));
        return E_INVALIDARG;
    }

    UnregisterWaitEvent(index);    

    ((CMSPStream*)m_Streams[index])->ShutDown();
    m_Streams[index]->Release();

    m_Streams.RemoveAt(index);

    LOG((MSP_TRACE, "CMSPCallMultiGraph::RemoveStream - exit S_OK"));

    return S_OK;
}

HRESULT CMSPCallMultiGraph::UnregisterWaitEvent(
    IN  int     index
    )
{
    if (index >= m_ThreadPoolWaitBlocks.GetSize())
    {
        // the call must have been disconnected.
        return E_UNEXPECTED;
    }

    THREADPOOLWAITBLOCK &WaitBlock = m_ThreadPoolWaitBlocks[index];

    // These pointers should never be NULL.
    _ASSERTE(WaitBlock.hWaitHandle != NULL);
    _ASSERTE(WaitBlock.pContext != NULL);

    // Cancel the wait posted to the thread pool.
    BOOL fRes = ::UnregisterWaitEx(WaitBlock.hWaitHandle, (HANDLE)-1);
    if (!fRes)
    {
        // we should never get here, UnregisterWaitEx will block until success
        
        LOG((MSP_ERROR, 
            "UnregisterWait failed. %x", GetLastError()));

        // just remove it from the list. keep the data so that it won't AV.
        m_ThreadPoolWaitBlocks.RemoveAt(index);
        return E_FAIL;
    }

    // We need to decrement the refcount because it was incremented 
    // before we post the wait.
    (WaitBlock.pContext->pMSPCall)->MSPCallRelease();
    (WaitBlock.pContext->pITStream)->Release();
    (WaitBlock.pContext->pIMediaEvent)->Release();

    // Free the context block;
    free(WaitBlock.pContext);

    m_ThreadPoolWaitBlocks.RemoveAt(index);

    return S_OK;
}

// methods called by the thread pool
VOID NTAPI CMSPCallMultiGraph::DispatchGraphEvent(
    IN      VOID *              pContext,
    IN      BOOLEAN             bFlag
    )
{
    LOG((MSP_EVENT, 
        "DispatchGraphEvent:pContext:%x, bFlag:%u", 
        pContext, bFlag));

    // the pContext is a pointer to a call, since it carries a ref count,
    // the call should still be alive.
    _ASSERTE( ! IsBadReadPtr(pContext, sizeof(VOID *) ) );

    MSPSTREAMCONTEXT * pEventContext = (MSPSTREAMCONTEXT *)pContext;
    pEventContext->pMSPCall->HandleGraphEvent(pEventContext);
}

VOID CMSPCallMultiGraph::HandleGraphEvent(
    IN  MSPSTREAMCONTEXT * pContext
    )
{
    long     lEventCode;
    LONG_PTR lParam1, lParam2; // win64 fix

    HRESULT hr = pContext->pIMediaEvent->GetEvent(&lEventCode, &lParam1, &lParam2, 0);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Can not get the actual event. %x", hr));
        return;
    }

    LOG((MSP_EVENT, "ProcessGraphEvent, code:%d param1:%x param2:%x",
        lEventCode, lParam1, lParam2));

    //
    // Create an event data structure that we will pass to the worker thread.
    //

    MULTI_GRAPH_EVENT_DATA * pData;
    pData = new MULTI_GRAPH_EVENT_DATA;
    
    if (pData == NULL)
    {
        pContext->pIMediaEvent->FreeEventParams(lEventCode, lParam1, lParam2);

        LOG((MSP_ERROR, "Out of memory for event data."));
        return;
    }
    
    pData->pCall      = this;
    pData->pITStream  = pContext->pITStream;
    pData->lEventCode = lEventCode;
    pData->lParam1    = lParam1;
    pData->lParam2    = lParam2;


    //
    // also pass an addref'ed pointer to IMediaEvent, so that whoever processes
    // the message has the opportunity to free event parameters
    //

    pData->pIMediaEvent = pContext->pIMediaEvent;
    pData->pIMediaEvent->AddRef();

 
    //
    // Make sure the call and stream don't go away while we handle the event.
    // but use our special inner object addref for the call
    //

    pData->pCall->MSPCallAddRef();
    pData->pITStream->AddRef();

    //
    // Queue an async work item to call ProcessGraphEvent.
    //

    hr = g_Thread.QueueWorkItem(AsyncMultiGraphEvent,
                                (void *) pData,
                                FALSE);  // asynchronous

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "QueueWorkItem failed, return code:%x", hr));

        pData->pCall->MSPCallRelease();
        pData->pITStream->Release();


        //
        // no one is going to free event params and release the IMediaEvent
        // pointer, so do it here
        //

        pContext->pIMediaEvent->FreeEventParams(lEventCode, lParam1, lParam2);
        pData->pIMediaEvent->Release();

        delete pData;
    }
}

DWORD WINAPI AsyncMultiGraphEvent(LPVOID pVoid)
{
    MULTI_GRAPH_EVENT_DATA * pData = ( MULTI_GRAPH_EVENT_DATA * ) pVoid;

    //
    // Handle the event.
    //

    (pData->pCall)->ProcessGraphEvent(pData->pITStream,
                                      pData->lEventCode,
                                      pData->lParam1,
                                      pData->lParam2);

    //
    // These were addrefed when the event was queued.
    // but we used our special inner object addref for the call
    //

    pData->pCall->MSPCallRelease();
    pData->pITStream->Release();


    //
    // if we have IMediaEvent pointer, free event params and release the media 
    // event interface pointer
    //

    if (NULL != pData->pIMediaEvent)
    {
        pData->pIMediaEvent->FreeEventParams(pData->lEventCode,
                                             pData->lParam1,
                                             pData->lParam2);
        pData->pIMediaEvent->Release();
        pData->pIMediaEvent = NULL;
    }

    //
    // Free the event data structure.
    //

    delete pData;

    return 0;
}

HRESULT CMSPCallMultiGraph::ProcessGraphEvent(
    IN      ITStream *      pITStream,
    IN      long            lEventCode,
    IN      LONG_PTR        lParam1,
    IN      LONG_PTR        lParam2
    )
{
    CLock lock(m_lock);

    if (m_Streams.Find(pITStream) < 0)
    {
        LOG((MSP_WARN, 
            "stream %x is already removed.", 
            pITStream));
        return TAPI_E_NOITEMS;
    }

    //
    // No dynamic cast because this is our own pointer.
    //

    return ((CMSPStream*)pITStream)->
        ProcessGraphEvent(lEventCode, lParam1, lParam2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mspbase\mspaddr.cpp ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    mspaddr.cpp 

Abstract:

    This module contains implementation of CMSPAddress.

--*/

#include "precomp.h"
#pragma hdrstop



///////////////////////////////////////////////////////////////////////////////
//
// AllocateEventItem and FreeEventItem are MSPEVENTITEM allocation routines.
// they are be used to allocate and deallocate MSPEVENTITEM structures
//
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
//  AllocateEventItem
//
//  allocate an MSPEVENTITEM. Since the structure is of variable size, the 
//  number of extra bytes to be allocated (in addition to the size of 
//  MSPEVENTITEM) is optionally passed as the function's argument
//
//  the function returns a pointer to the newly created structure or NULL in 
//  the case of failure. the caller can then call GetLastError to get more 
//  information on the failure
//

MSPEVENTITEM *AllocateEventItem(SIZE_T nExtraBytes)
{

    LOG((MSP_TRACE, "AllocateEventItem - enter, extra bytes = 0x%p", nExtraBytes));


    //
    // if the caller passes us too big a number, fail.
    //

    if ( ( MAXULONG_PTR - sizeof(MSPEVENTITEM) )  < nExtraBytes )
    {
        SetLastError(ERROR_OUTOFMEMORY);

        LOG((MSP_ERROR, 
            "AllocateEventItem - the caller requested an unreasonably large memory block"));

        return NULL;
    }


    //
    // allocate on the process' heap. get the current process' heap handle.
    //

    HANDLE hHeapHandle = GetProcessHeap();

    if (NULL == hHeapHandle)
    {

        //
        // failed to get process's heap. nothing much we can do here.
        // this will cause a leak.
        //

        LOG((MSP_ERROR, 
            "AllocateEventItem - failed to get current process heap. LastError [%ld]", 
            GetLastError()));

        return NULL;
    }


    //
    // calculate the number of bytes to allocate
    //

    SIZE_T nTotalAllocationSize = sizeof(MSPEVENTITEM) + nExtraBytes;


    //
    // attempt to allocate memory and return result of the allocation
    //
    
    MSPEVENTITEM *pMspEventItem = 
         (MSPEVENTITEM *)HeapAlloc(hHeapHandle, 0, nTotalAllocationSize);


    if (NULL == pMspEventItem)
    {

        LOG((MSP_ERROR,
            "AllocateEventItem - failed to allocate [0x%p] bytes. Heap Handle [%p] LastError [%ld]",
            nTotalAllocationSize, hHeapHandle, GetLastError()));
    }
    else
    {

        LOG((MSP_TRACE, "AllocateEventItem - exit. pMspEventItem = [%p]", pMspEventItem));
    }

    return pMspEventItem;
}


//////////////////////////////////////////////////////////////////////////////
//
//  FreeEventItem
//
//  deallocate the MSPEVENTITEM passed as an argument. The memory must have
//  been previously allocated by AllocateEventItem.
//
//  the function eturns FALSE in case of failure. The caller can use 
//  GetLastError to get a more specific error code.
//

BOOL FreeEventItem(MSPEVENTITEM *pEventItemToBeFreed)
{

    LOG((MSP_TRACE, "FreeEventItem - enter. pEventItemToBeFreed = [%p]", 
        pEventItemToBeFreed));


    //
    // always allow freeing NULL
    //

    if (NULL == pEventItemToBeFreed)
    {

        LOG((MSP_TRACE, "FreeEventItem - finish. NULL -- nothing to do"));

        return TRUE;
    }

    //
    // the event item should have been allocated on the process' heap.
    // get the current process' heap hadle.
    //

    HANDLE hHeapHandle = GetProcessHeap();

    if (NULL == hHeapHandle)
    {

        //
        // failed to get process's heap. nothing much we can do here.
        // this will cause a leak.
        //

        LOG((MSP_ERROR, 
            "FreeEventItem - failed to get current process heap. LastError = %ld", 
            GetLastError()));

        return FALSE;
    }


    //
    // attempt to free memory and return result of the operation
    //
    
    BOOL bFreeSuccess = HeapFree( hHeapHandle, 0, pEventItemToBeFreed );

    if (bFreeSuccess)
    {
         LOG((MSP_TRACE, "FreeEventItem - exit."));
    }
    else
    {
         LOG((MSP_ERROR, 
             "FreeEventItem - failed to free. Heap Handle [%p] LastError = %ld",
             hHeapHandle, GetLastError()));
    }


    return bFreeSuccess;
}


//////////////////////////////////////////////////////////////////////////////


HRESULT CPlugTerminalClassInfo::FinalConstruct(void)
{
    LOG((MSP_TRACE, "CPlugTerminalClassInfo::FinalConstruct - enter"));

    HRESULT hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                & m_pFTM );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::FinalConstruct - "
            "create FTM returned 0x%08x; exit", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::FinalConstruct - exit S_OK"));

    return S_OK;

}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPlugTerminalClassInfo::get_Name(
    /*[out, retval]*/ BSTR*     pName
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::get_Name - enter"));

    //
    // Validates argument
    //

    if( MSPB_IsBadWritePtr( pName, sizeof(BSTR)) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::get_Name exit -"
            "pName invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Validates the name
    //

    if( IsBadStringPtr( m_bstrName, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::get_Name exit -"
            "m_bstrName invalid, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Return the name
    //

    *pName = SysAllocString( m_bstrName );

    //
    // Validates SysAllocString
    //

    if( *pName == NULL )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::get_Name exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::get_Name - exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CPlugTerminalClassInfo::put_Name(
    /*[in]*/    BSTR            bstrName
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::put_Name - enter"));

    //
    // Validates argument
    //

    if(IsBadStringPtr( bstrName, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::put_Name exit -"
            "bstrName invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Clean-up the old name
    //

    if(!IsBadStringPtr( m_bstrName, (UINT)-1) )
    {
        SysFreeString( m_bstrName );
        m_bstrName = NULL;
    }

    //
    // Set the new name
    //

    m_bstrName = SysAllocString( bstrName );

    //
    // Validates SysAllocString
    //

    if( NULL == m_bstrName )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::put_Name exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::put_Name - exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CPlugTerminalClassInfo::get_Company(
    /*[out, retval]*/ BSTR*     pCompany
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::get_Company - enter"));

    //
    // Validates argument
    //

    if( MSPB_IsBadWritePtr( pCompany, sizeof(BSTR)) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::get_Company exit -"
            "pCompany invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Validates the name
    //

    if( IsBadStringPtr( m_bstrCompany, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::get_Company exit -"
            "m_bstrName invalid, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Return the name
    //

    *pCompany = SysAllocString( m_bstrCompany );

    //
    // Validates SysAllocString
    //

    if( *pCompany == NULL )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::get_Company exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::get_Company - exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CPlugTerminalClassInfo::put_Company(
    /*[in]*/    BSTR            bstrCompany
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::put_Company - enter"));

    //
    // Validates argument
    //

    if(IsBadStringPtr( bstrCompany, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::put_Company exit -"
            "bstrCompany invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Clean-up the old name
    //

    if(!IsBadStringPtr( m_bstrCompany, (UINT)-1) )
    {
        SysFreeString( m_bstrCompany );
        m_bstrCompany = NULL;
    }

    //
    // Set the new name
    //

    m_bstrCompany = SysAllocString( bstrCompany );

    //
    // Validates SysAllocString
    //

    if( NULL == m_bstrCompany )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::put_Company exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::put_Company - exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CPlugTerminalClassInfo::get_Version(
    /*[out, retval]*/ BSTR*     pVersion
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::get_Version - enter"));

    //
    // Validates argument
    //

    if( MSPB_IsBadWritePtr( pVersion, sizeof(BSTR)) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::get_Version exit -"
            "pVersion invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Validates the name
    //

    if( IsBadStringPtr( m_bstrVersion, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::get_Version exit -"
            "m_bstrName invalid, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Return the name
    //

    *pVersion = SysAllocString( m_bstrVersion );

    //
    // Validates SysAllocString
    //

    if( *pVersion == NULL )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::get_Version exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::get_Version - exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CPlugTerminalClassInfo::put_Version(
    /*[in]*/    BSTR            bstrVersion
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::put_Version - enter"));

    //
    // Validates argument
    //

    if(IsBadStringPtr( bstrVersion, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::put_Version exit -"
            "bstrVersion invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Clean-up the old name
    //

    if(!IsBadStringPtr( m_bstrVersion, (UINT)-1) )
    {
        SysFreeString( m_bstrVersion );
        m_bstrVersion = NULL;
    }

    //
    // Set the new name
    //

    m_bstrVersion = SysAllocString( bstrVersion );

    //
    // Validates SysAllocString
    //

    if( NULL == m_bstrVersion )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::put_Version exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::put_Version - exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CPlugTerminalClassInfo::get_TerminalClass(
    /*[out, retval]*/ BSTR*     pTerminalClass
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::get_TerminalClass - enter"));

    //
    // Validates argument
    //

    if( MSPB_IsBadWritePtr( pTerminalClass, sizeof(BSTR)) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::get_TerminalClass exit -"
            "pVersion invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Validates the name
    //

    if( IsBadStringPtr( m_bstrTerminalClass, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::get_TerminalClass exit -"
            "m_bstrName invalid, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Return the name
    //

    *pTerminalClass = SysAllocString( m_bstrTerminalClass );

    //
    // Validates SysAllocString
    //

    if( *pTerminalClass == NULL )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::get_TerminalClass exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::get_TerminalClass - exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CPlugTerminalClassInfo::put_TerminalClass(
    /*[in]*/    BSTR            bstrTerminalClass
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::put_TerminalClass - enter"));

    //
    // Validates argument
    //

    if(IsBadStringPtr( bstrTerminalClass, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::put_TerminalClass exit -"
            "bstrTerminalClass invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Is a real CLSID?
    //

    CLSID clsid;
    HRESULT hr = CLSIDFromString(bstrTerminalClass, &clsid);
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::put_TerminalClass exit -"
            "bstrTerminalClass is not a CLSID, returns E_INVALIDARG"));
        return E_INVALIDARG;
    }


    //
    // Clean-up the old name
    //

    if(!IsBadStringPtr( m_bstrTerminalClass, (UINT)-1) )
    {
        SysFreeString( m_bstrTerminalClass );
        m_bstrTerminalClass = NULL;
    }

    //
    // Set the new name
    //

    m_bstrTerminalClass = SysAllocString( bstrTerminalClass );

    //
    // Validates SysAllocString
    //

    if( NULL == m_bstrTerminalClass )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::put_TerminalClass exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::put_TerminalClass - exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CPlugTerminalClassInfo::get_CLSID(
    /*[out, retval]*/ BSTR*     pCLSID
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::get_CLSID - enter"));

    //
    // Validates argument
    //

    if( MSPB_IsBadWritePtr( pCLSID, sizeof(BSTR)) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::get_CLSID exit -"
            "pVersion invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Validates the name
    //

    if( IsBadStringPtr( m_bstrCLSID, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::get_CLSID exit -"
            "m_bstrName invalid, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Return the name
    //

    *pCLSID = SysAllocString( m_bstrCLSID );

    //
    // Validates SysAllocString
    //

    if( *pCLSID == NULL )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::get_CLSID exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::get_CLSID - exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CPlugTerminalClassInfo::put_CLSID(
    /*[in]*/    BSTR            bstrCLSID
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::put_CLSID - enter"));

    //
    // Validates argument
    //

    if(IsBadStringPtr( bstrCLSID, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::put_CLSID exit -"
            "bstrCLSID invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Is a real CLSID?
    //

    CLSID clsid;
    HRESULT hr = CLSIDFromString(bstrCLSID, &clsid);
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::put_CLSID exit -"
            "bstrCLSID is not a CLSID, returns E_INVALIDARG"));
        return E_INVALIDARG;
    }


    //
    // Clean-up the old name
    //

    if(!IsBadStringPtr( m_bstrCLSID, (UINT)-1) )
    {
        SysFreeString( m_bstrCLSID );
        m_bstrCLSID = NULL;
    }

    //
    // Set the new name
    //

    m_bstrCLSID = SysAllocString( bstrCLSID );

    //
    // Validates SysAllocString
    //

    if( NULL == m_bstrCLSID )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::put_CLSID exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::put_CLSID - exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CPlugTerminalClassInfo::get_Direction(
    /*[out, retval]*/ TERMINAL_DIRECTION*  pDirection
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::get_Direction - enter"));

    //
    // Validates argument
    //

    if( MSPB_IsBadWritePtr( pDirection, sizeof(long)) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::get_Direction exit -"
            "pDirection invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Return the name
    //

    *pDirection = m_Direction;

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::get_Direction - exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CPlugTerminalClassInfo::put_Direction(
    /*[in]*/    TERMINAL_DIRECTION  nDirection
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalSuperclassInfo::put_Direction - enter"));

    //
    // Set the new name
    //

    m_Direction = nDirection;

    LOG((MSP_TRACE, "CPlugTerminalSuperclassInfo::put_Direction - exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CPlugTerminalClassInfo::get_MediaTypes(
    /*[out, retval]*/ long*     pMediaTypes
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::get_MediaTypes - enter"));

    //
    // Validates argument
    //

    if( MSPB_IsBadWritePtr( pMediaTypes, sizeof(long)) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::get_MediaTypes exit -"
            "pMediaTypes invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Return the name
    //

    *pMediaTypes = m_lMediaType;

    LOG((MSP_TRACE, "CPlugTerminalClassInfo::get_MediaTypes - exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CPlugTerminalClassInfo::put_MediaTypes(
    /*[in]*/    long            nMediaTypes
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalSuperclassInfo::put_MediaTypes - enter"));

    //
    // Set the new name
    //

    m_lMediaType = nMediaTypes;

    LOG((MSP_TRACE, "CPlugTerminalSuperclassInfo::put_MediaTypes - exit"));
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////


HRESULT CPlugTerminalSuperclassInfo::FinalConstruct(void)
{
    LOG((MSP_TRACE, "CPlugTerminalSuperclassInfo::FinalConstruct - enter"));

    HRESULT hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                & m_pFTM );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclassInfo::FinalConstruct - "
            "create FTM returned 0x%08x; exit", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CPlugTerminalSuperclassInfo::FinalConstruct - exit S_OK"));

    return S_OK;

}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPlugTerminalSuperclassInfo::get_Name(
    /*[out, retval]*/ BSTR*          pName
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalSuperclassInfo::get_Name - enter"));

    //
    // Validates argument
    //

    if( MSPB_IsBadWritePtr( pName, sizeof(BSTR)) )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclassInfo::get_Name exit -"
            "pVersion invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Validates the name
    //

    if( IsBadStringPtr( m_bstrName, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclassInfo::get_Name exit -"
            "m_bstrName invalid, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Return the name
    //

    *pName = SysAllocString( m_bstrName );

    //
    // Validates SysAllocString
    //

    if( *pName == NULL )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclassInfo::get_Name exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminalSuperclassInfo::get_Name - exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPlugTerminalSuperclassInfo::put_Name(
    /*[in]*/          BSTR            bstrName
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalSuperclassInfo::put_Name - enter"));

    //
    // Validates argument
    //

    if(IsBadStringPtr( bstrName, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclassInfo::put_Name exit -"
            "bstrName invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Clean-up the old name
    //

    if(!IsBadStringPtr( m_bstrName, (UINT)-1) )
    {
        SysFreeString( m_bstrName );
        m_bstrName = NULL;
    }

    //
    // Set the new name
    //

    m_bstrName = SysAllocString( bstrName );

    //
    // Validates SysAllocString
    //

    if( NULL == m_bstrName )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclassInfo::put_Name exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminalSuperclassInfo::put_Name - exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPlugTerminalSuperclassInfo::get_CLSID(
    /*[out, retval]*/ BSTR*           pCLSID
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalSuperclassInfo::get_CLSID - enter"));

    //
    // Validates argument
    //

    if( MSPB_IsBadWritePtr( pCLSID, sizeof(BSTR)) )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclassInfo::get_CLSID exit -"
            "pVersion invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Validates the name
    //

    if( IsBadStringPtr( m_bstrCLSID, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclassInfo::get_CLSID exit -"
            "m_bstrName invalid, returns E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Return the name
    //

    *pCLSID = SysAllocString( m_bstrCLSID );

    //
    // Validates SysAllocString
    //

    if( *pCLSID == NULL )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclassInfo::get_CLSID exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminalSuperclassInfo::get_CLSID - exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CPlugTerminalSuperclassInfo::put_CLSID(
    /*[in]*/         BSTR            bstrCLSID
    )
{
    //
    // Critical section
    //

    CLock lock(m_CritSect);

    LOG((MSP_TRACE, "CPlugTerminalSuperclassInfo::put_CLSID - enter"));

    //
    // Validates argument
    //

    if(IsBadStringPtr( bstrCLSID, (UINT)-1) )
    {
        LOG((MSP_ERROR, "CPlugTerminalClassInfo::put_CLSID exit -"
            "bstrCLSID invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Is a real CLSID?
    //

    CLSID clsid;
    HRESULT hr = CLSIDFromString(bstrCLSID, &clsid);
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclassInfo::put_CLSID exit -"
            "bstrCLSID is not a CLSID, returns E_INVALIDARG"));
        return E_INVALIDARG;
    }


    //
    // Clean-up the old name
    //

    if(!IsBadStringPtr( m_bstrCLSID, (UINT)-1) )
    {
        SysFreeString( m_bstrCLSID );
        m_bstrCLSID = NULL;
    }

    //
    // Set the new name
    //

    m_bstrCLSID = SysAllocString( bstrCLSID );

    //
    // Validates SysAllocString
    //

    if( NULL == m_bstrCLSID )
    {
        LOG((MSP_ERROR, "CPlugTerminalSuperclassInfo::put_CLSID exit -"
            "SysAllocString failed, returns E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CPlugTerminalSuperclassInfo::put_CLSID - exit"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////


//
// Our available static terminal types.
//

const STATIC_TERMINAL_TYPE CMSPAddress::m_saTerminalTypes[] =
{
    {
        (DWORD) TAPIMEDIATYPE_AUDIO,
        &CLSID_CWaveinClassManager,
        CAudioCaptureTerminal::CreateTerminal
    },
    {
        (DWORD) TAPIMEDIATYPE_AUDIO,
        &CLSID_CWaveOutClassManager,
        CAudioRenderTerminal::CreateTerminal
    },
    {
        (DWORD) TAPIMEDIATYPE_VIDEO,
        &CLSID_CVidCapClassManager,
        CVideoCaptureTerminal::CreateTerminal
    }
};

const DWORD CMSPAddress::m_sdwTerminalTypesCount = sizeof(m_saTerminalTypes)
                                              / sizeof (STATIC_TERMINAL_TYPE);

/////////////////////////////////////////////////////////////////////////////
// CMSPAddress
/////////////////////////////////////////////////////////////////////////////

//
// Check to see if the mediatype is non-zero and is in the mask.
// Your MSP can override this if it needs to do atypically complex
// checks on specific combinations of media types (e.g., can never
// have more than one media type on a call, can have video with audio
// but not video alone, etc.). The default implementation accepts any
// nonempty set of media types that is a subset of the set of types
// in the mask.
//

BOOL CMSPAddress::IsValidSetOfMediaTypes(DWORD dwMediaType, DWORD dwMask)
{
    return (dwMediaType != 0) && ((dwMediaType & dwMask) == dwMediaType);
}

CMSPAddress::CMSPAddress()
    : m_htEvent(NULL),
      m_fTerminalsUpToDate(FALSE),
      m_pITTerminalManager(NULL)
{
    LOG((MSP_TRACE, "CMSPAddress::CMSPAddress[%p] - enter", this));

    LOG((MSP_TRACE, "CMSPAddress::CMSPAddress - finished"));
}
      
CMSPAddress::~CMSPAddress() 
{
    LOG((MSP_TRACE, "CMSPAddress::~CMSPAddress[%p] - enter", this));


    //
    // this should have been taken care of in Shutdown,
    // but just in case shutdown was never called, do this again, since 
    // we need to make sure the thread does not have any stale entries in 
    // its pnp notification list
    // 
    // the call is likely to return error (since the object is likely to have been
    // unregisted earlier) -- so ignore return code
    //

    g_Thread.UnregisterPnpNotification(this);


    LOG((MSP_TRACE, "CMSPAddress::~CMSPAddress - finished"));
}

STDMETHODIMP CMSPAddress::Initialize(
    IN      MSP_HANDLE          htEvent
    )
/*++

Routine Description:

This method is called by TAPI3 when this MSP is first created. The method 
initiailzes data members and creates the terminal manager. It also tells
the global thread object to Start().

Arguments:

htEvent
    Event the MSP signals when passing an event structure back to TAPI.

  
Return Value:

    S_OK
    E_INVALIDARG
    E_OUTOFMEMORY
    TAPI_E_REGISTERCALLBACK

--*/
{
    LOG((MSP_TRACE, 
        "MSP address %x initialize entered, htEvent:%x",
        this, htEvent));

    if ( htEvent == NULL )
    {
        LOG((MSP_ERROR, " bad handle: htEvent:%x", htEvent));

        return E_INVALIDARG;
    }

    // lock the event related data
    m_EventDataLock.Lock();

    if (m_htEvent != NULL)
    {
        m_EventDataLock.Unlock();

        LOG((MSP_ERROR, "Initialze called twice."));
        return E_UNEXPECTED;
    }

    // save handles.
    m_htEvent   = htEvent;
    
    InitializeListHead(&m_EventList);

    HRESULT hr;

    // release the lock on the event related data
    m_EventDataLock.Unlock();

    // lock the terminal related data. This is a auto lock that will unlock
    // when the function returns.
    CLock lock(m_TerminalDataLock);

    // Create the terminal manager.
    hr = CoCreateInstance(
        CLSID_TerminalManager,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITTerminalManager,
        (void **) &m_pITTerminalManager
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "Creating terminal manager failed. return: %x", hr));

        return hr;
    }

    hr = g_Thread.Start();    

    if (FAILED(hr))
    {
        m_pITTerminalManager->Release();
        m_pITTerminalManager = NULL;

        LOG((MSP_ERROR, 
            "Creating thread failed. return: %x", hr));

        return hr;
    }

    hr = g_Thread.RegisterPnpNotification(this);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR,
            "Unable to register for PNP notification. return: %x", hr));
    }

    LOG((MSP_TRACE, 
        "MSP address %x initialize exited S_OK, htEvent:%x",
        this, htEvent));

    return S_OK;   
}

STDMETHODIMP CMSPAddress::Shutdown ()
/*++

Routine Description:

This method is called by TAPI3 when this address in not in use any more. 
This function releases the terminals and releases the terminal manager.
It releases all unprocessed events, and also stops the worker thread.
When this functions is called, no call should be alive. However, bugs in
the app may keep calls or terminals  around. Currently this function
does not attempt to solve this problem. The calls will have their own
refcounts on the terminals, so it shouldn't fail anyway.

Arguments:
    None.

Return Value:

    S_OK
--*/
{
    LOG((MSP_TRACE, "CMSPAddress::Shutdown - "
        "MSP address %x is shutting down", this));

    HRESULT hr;

    //
    // Unregister for PNP notification
    //

    hr = g_Thread.UnregisterPnpNotification(this);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR,
            "Unable to unregister for PNP notification. return: %x", hr));
    }

    //
    // Tell the worker thread to stop.
    //

    g_Thread.Stop();    

    LOG((MSP_INFO, "CMSPAddress::Shutdown - thread has stopped"));

    // acquire the lock on the terminal data because we are writing to it.
    m_TerminalDataLock.Lock();

    // Release the terminal manager.
    if (m_pITTerminalManager != NULL)
    {
        m_pITTerminalManager->Release();
        m_pITTerminalManager = NULL;
    }

    // release all the terminals.
    for (int i = 0; i < m_Terminals.GetSize(); i ++)
    {
        //
        // Clear its CMSPAddress pointer
        //
        CBaseTerminal * pCTerminal = static_cast<CBaseTerminal *> (m_Terminals[i]);

        m_Terminals[i]->Release();
    }
    m_Terminals.RemoveAll();

    // We are done with terminal related data, release the lock.
    m_TerminalDataLock.Unlock();


    LOG((MSP_INFO, "CMSPAddress::Shutdown - terminals released"));

    // acquire the lock on the event data because we are writing to it.
    m_EventDataLock.Lock();
    
    m_htEvent = NULL;

    // release all the unprocessed events in the list.
    while (!IsListEmpty(&m_EventList)) 
    {
        // retrieve first entry
        PLIST_ENTRY pLE = RemoveHeadList(&m_EventList);

        // convert list entry to structure pointer
        PMSPEVENTITEM pItem = CONTAINING_RECORD(pLE, MSPEVENTITEM, Link);

        // release the refcount in the event.
        LOG((MSP_INFO, 
            "CMSPAddress::Shutdown:releasing event still in the queue: %x",
            pItem->MSPEventInfo.Event
            ));

        switch (pItem->MSPEventInfo.Event)
        {
        case ME_ADDRESS_EVENT:
            if (pItem->MSPEventInfo.MSP_ADDRESS_EVENT_INFO.pTerminal)
            {
                pItem->MSPEventInfo.MSP_ADDRESS_EVENT_INFO.pTerminal->Release();
            }
            break;

        case ME_CALL_EVENT:
            if (pItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pStream)
            {
                pItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pStream->Release();
            }

            if (pItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pTerminal)
            {
                pItem->MSPEventInfo.MSP_CALL_EVENT_INFO.pTerminal->Release();
            }
            break;

        case ME_PRIVATE_EVENT:
            if (pItem->MSPEventInfo.MSP_PRIVATE_EVENT_INFO.pEvent)
            {
                pItem->MSPEventInfo.MSP_PRIVATE_EVENT_INFO.pEvent->Release();
            }
            break;

        case ME_TSP_DATA:
            // nothing inside the structure that we need to free
            break;

        case ME_FILE_TERMINAL_EVENT:

            if( NULL != pItem->MSPEventInfo.MSP_FILE_TERMINAL_EVENT_INFO.pParentFileTerminal)
            {
                (pItem->MSPEventInfo.MSP_FILE_TERMINAL_EVENT_INFO.pParentFileTerminal)->Release();
                pItem->MSPEventInfo.MSP_FILE_TERMINAL_EVENT_INFO.pParentFileTerminal = NULL;
            }

            if( NULL != pItem->MSPEventInfo.MSP_FILE_TERMINAL_EVENT_INFO.pFileTrack )
            {
                (pItem->MSPEventInfo.MSP_FILE_TERMINAL_EVENT_INFO.pFileTrack)->Release();
                pItem->MSPEventInfo.MSP_FILE_TERMINAL_EVENT_INFO.pFileTrack = NULL;
            }

            break;

        case ME_ASR_TERMINAL_EVENT:

            if( NULL != pItem->MSPEventInfo.MSP_ASR_TERMINAL_EVENT_INFO.pASRTerminal)
            {
                (pItem->MSPEventInfo.MSP_ASR_TERMINAL_EVENT_INFO.pASRTerminal)->Release();
            }

            break;

        case ME_TTS_TERMINAL_EVENT:

            if( NULL != pItem->MSPEventInfo.MSP_TTS_TERMINAL_EVENT_INFO.pTTSTerminal)
            {
                (pItem->MSPEventInfo.MSP_TTS_TERMINAL_EVENT_INFO.pTTSTerminal)->Release();
            }

            break;

        case ME_TONE_TERMINAL_EVENT:

            if( NULL != pItem->MSPEventInfo.MSP_TONE_TERMINAL_EVENT_INFO.pToneTerminal)
            {
                (pItem->MSPEventInfo.MSP_TONE_TERMINAL_EVENT_INFO.pToneTerminal)->Release();
            }

            break;

        default:
            LOG((MSP_WARN, "CMSPAddress::Shutdown: unknown event type: %x",
                pItem->MSPEventInfo.Event));            

            break;
        }

        FreeEventItem(pItem);
    }

    // We are done with event related data, release the lcok.
    m_EventDataLock.Unlock();

    LOG((MSP_TRACE, "CMSPAddress::Shutdown - exit S_OK"));

    return S_OK;
}


STDMETHODIMP CMSPAddress::ReceiveTSPData(
    IN      IUnknown        *   pMSPCall,
    IN      LPBYTE              pBuffer,
    IN      DWORD               dwBufferSize
    )
/*++

Routine Description:

This method is called by TAPI3 when the TSP address sends data to this 
MSP address object. The semantics of the data passed in the buffer are
specific to each  TSP - MSP pair. This method dispatches the received
buffer to the address (call == NULL) or call (call != NULL).

Arguments:

pMSPCall
    The call object that the data is for. If it is NULL, the data is for 
    this address.

pBuffer
    Opaque buffer from TSP.

dwBufferSize
    Size in bytes of pBuffer


    
Return Value:

    S_OK

--*/
{
    LOG((MSP_TRACE, "CMSPAddress::ReceiveTSPData entered. pMSPCall:%x",
        pMSPCall));

    _ASSERTE(dwBufferSize > 0);
    _ASSERTE(!IsBadReadPtr(pBuffer, sizeof(BYTE) * (dwBufferSize) ) );

    HRESULT hr;
    
    if ( NULL == pMSPCall )
    {
        hr = ReceiveTSPAddressData(pBuffer, dwBufferSize);

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CMSPAddress::ReceiveTSPData - "
                "ReceiveTSPAddressData failed - exit 0x%08x", hr));

            return hr;
        }

        LOG((MSP_TRACE, "CMSPAddress::ReceiveTSPData - "
            "exit S_OK (dispatched to address)"));

        return S_OK;
    }

    //
    // We have a call to dispatch to.
    //

    _ASSERTE(!IsBadReadPtr(pMSPCall, sizeof(IUnknown) ) );
    
    ITStreamControl * pIStreamControl;

    hr = pMSPCall->QueryInterface(IID_ITStreamControl,
                                  (void **)&pIStreamControl);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::ReceiveTSPData - "
            "can't get the ITStream Control interface - exit 0x%08x", hr));

        return hr;
    }

    CMSPCallBase * pCall = static_cast<CMSPCallBase *> (pIStreamControl);

    if (pCall == NULL)
    {
        LOG((MSP_ERROR, "CMSPAddress::ReceiveTSPData - "
            "invalid msp call pointer: %x", pMSPCall));

        pIStreamControl->Release();

        return E_UNEXPECTED;
    }
    
    hr = pCall->ReceiveTSPCallData(pBuffer, dwBufferSize);

    pIStreamControl->Release();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::ReceiveTSPData - "
            "method on call failed - exit 0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CMSPAddress::ReceiveTSPData - "
        "exit S_OK (dispatched to call)"));

    return S_OK;
}


HRESULT CMSPAddress::GetStaticTerminals(
    IN OUT  DWORD *             pdwNumTerminals,
    OUT     ITTerminal **       ppTerminals
    )
/*++

Routine Description:

This method is called by TAPI3 to get a list of static terminals that can 
be used on this address. If our list is not empty, just return the list. 
If our list is still empty, create the static terminals and return the list.
Derived class can override this method to have their own terminals. Locks 
the terminal lists.

Arguments:

pdwNumTerminals
    Pointer to a DWORD.  On entry, indicates the size of the buffer pointed 
    to in ppTerminals. On success, it will be filled in with the actual number
    of terminals returned.  If the buffer is not big enough, the method will 
    return TAPI_E_NOTENOUGHMEMORY, and it will be filled in the with number
    of terminals needed. 

ppTerminals
    On success, filled in with an array of terminals object pointers that are 
    supported by the MSP for this address.  This value may be NULL, in which 
    case pdwNumTerminals will return the needed buffer size.

    
Return Value:

S_OK
E_OUTOFMEMORY
TAPI_E_NOTENOUGHMEMORY

--*/
{
    LOG((MSP_TRACE, 
        "GetStaticTerminals entered. NumTerminals:%x, ppTerminals:%x",
        *pdwNumTerminals, ppTerminals
        ));

    // lock the terminal related data. This is a auto lock that will unlock
    // when the function returns.
    CLock lock(m_TerminalDataLock);

    if (!m_fTerminalsUpToDate)
    {
        HRESULT hr = UpdateTerminalList();

        if (FAILED(hr))
        {
            LOG((MSP_ERROR,
                "CMSPAddress::GetStaticTerminals - "
                "UpdateTerminalList failed - returning 0x%08x", hr));

            return hr;
        }
    }

    //
    // Check if initialized.
    //

    if ( m_htEvent == NULL )
    {
        LOG((MSP_ERROR, "CMSPAddress::GetStaticTerminals - "
            "not initialized - returning E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    //
    // Check parameters.
    //

    if ( MSPB_IsBadWritePtr(pdwNumTerminals, sizeof(DWORD) ) )
    {
        LOG((MSP_ERROR, "CMSPAddress::GetStaticTerminals - "
            "bad pdwNumTerminals pointer - exit E_POINTER"));

        return E_POINTER;
    }
    
    if ( ppTerminals != NULL )
    {
        if ( MSPB_IsBadWritePtr(ppTerminals,
                           *pdwNumTerminals * sizeof(ITTerminal *) ) )
        {
            LOG((MSP_ERROR, "CMSPAddress::GetStaticTerminals - "
                "bad ppTerminals pointer - exit E_POINTER"));

            return E_POINTER;
        }
    }


    //
    // Grab the size of the terminals list.
    //

    int   iSize = m_Terminals.GetSize();
    _ASSERTE( iSize >= 0 );

    //
    // Add our terminals to the output list if the caller wants an output
    // list, and provided there is enough room in the output list.
    //

    if ( ( ppTerminals != NULL ) &&
         ( (DWORD) iSize <= *pdwNumTerminals ) )
    {
        //
        // For each terminal in the list of terminals we created,
        // AddRef and copy the terminal pointer.
        //

        for (int i = 0; i < iSize; i++)
        {
            m_Terminals[i]->AddRef();

            ppTerminals[i] = m_Terminals[i];
        }
    }
    
    //
    // If there was no output list then we just have to report the number
    // of terminals available.
    //
    
    if ( ppTerminals == NULL )
    {
        *pdwNumTerminals = (DWORD) iSize;

        LOG((MSP_TRACE,
            "CMSPAddress::GetStaticTerminals - just returned number of "
            "terminals available - exit S_OK"));

        return S_OK;
    }
    
    //
    // If there was an output list but it was not large enough, then
    // return the appropriate error.
    //
    
    if ( (DWORD) iSize > *pdwNumTerminals )
    {
        *pdwNumTerminals = (DWORD) iSize;

        LOG((MSP_ERROR,
            "CMSPAddress::GetStaticTerminals - passed-in array not "
            "large enough - exit TAPI_E_NOTENOUGHMEMORY"));

        return TAPI_E_NOTENOUGHMEMORY;
    }
    
    //
    // Otherwise, everything was fine. We just need to report the actual
    // number of terminals we copied and return S_OK.
    //
    
    *pdwNumTerminals = (DWORD) iSize;
    
    LOG((MSP_TRACE,
        "CMSPAddress::GetStaticTerminals - "
        "returned terminals - exit S_OK"));

    return S_OK;
}

HRESULT CMSPAddress::IsMonikerInTerminalList(IMoniker* pMoniker)
{
    CSingleFilterStaticTerminal *pCSingleFilterStaticTerminal;

    //
    // Grab the size of the terminals list.
    //

    int   iSize = m_Terminals.GetSize();
    _ASSERTE( iSize >= 0 );

    //
    // Add our terminals to the output list if the caller wants an output
    // list, and provided there is enough room in the output list.
    //

    for (int i = 0; i < iSize; i++)
    {
        pCSingleFilterStaticTerminal = static_cast<CSingleFilterStaticTerminal *>(m_Terminals[i]);

        if ( pCSingleFilterStaticTerminal->CompareMoniker( pMoniker ) == S_OK )
        {
            LOG((MSP_TRACE, "CMSPAddress::IsMonikerInTerminalList - "
                "moniker found in terminal list"));

            pCSingleFilterStaticTerminal->m_bMark = TRUE;  // mark this terminal so we don't remove it

            return S_OK;
        }

    }

    LOG((MSP_TRACE, "CMSPAddress::IsMonikerInTerminalList - "
                "moniker not found in terminal list"));
    return S_FALSE;
}

HRESULT CMSPAddress::UpdateTerminalListForPnp(
        IN  BOOL    bDeviceArrival
        )
{
    CSingleFilterStaticTerminal *pCSingleFilterStaticTerminal;

    //
    // Clear all marks in the terminal list
    //

    int   iSize = m_Terminals.GetSize();
    _ASSERTE( iSize >= 0 );

    for (int i = 0; i < iSize; i++)
    {
        pCSingleFilterStaticTerminal = static_cast<CSingleFilterStaticTerminal *>(m_Terminals[i]);

        if (pCSingleFilterStaticTerminal == NULL)
        {           
            LOG((MSP_ERROR, "CMSPAddress::IsMonikerInTerminalList - "
                    "bad terminal pointer"));
            return E_FAIL;
        }

        pCSingleFilterStaticTerminal->m_bMark = FALSE;
    }

    //
    // Create DevEnum, which is the DirectShow Category Enumerator Creator
    //

    HRESULT hr;
    ICreateDevEnum * pCreateDevEnum;

    hr = CoCreateInstance(CLSID_SystemDeviceEnum,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ICreateDevEnum,
                          (void**)&pCreateDevEnum);

    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "CMSPAddress::UpdateTerminalListForPnp "
               "can't CoCreate DevEnum - returning  0x%08x", hr));
        return hr;
    }    

    IEnumMoniker  * pCatEnum;

    for ( i = 0; i < m_sdwTerminalTypesCount; i++ )
    {
        //
        // Skip any terminal types that don't use one of the supported media
        // modes.
        //

        if ( ! IsValidSingleMediaType( 
            m_saTerminalTypes[i].dwMediaType, GetCallMediaTypes() ) )
        {
            continue;
        }


        //
        // Create the actual category enumerator.
        //

        hr = pCreateDevEnum->CreateClassEnumerator(
                                *(m_saTerminalTypes[i].clsidClassManager),
                                &pCatEnum,
                                0);

        if ( hr != S_OK ) // S_FALSE means the category does not exist!
        {
            LOG((MSP_ERROR, "CMSPAddress::UpdateTerminalListForPnp "
                   "can't create class enumerator - returning 0x%08x", hr));

            continue;
        }

        IMoniker      * pMoniker;

        while ((hr = pCatEnum->Next(1, &pMoniker, NULL)) == S_OK)
        {
            if (IsMonikerInTerminalList(pMoniker) == S_FALSE)
            {
                //
                // Create a terminal and give it its moniker.
                //

                ITTerminal * pTerminal;
                hr = (m_saTerminalTypes[i].pfnCreateTerm)(pMoniker,
                                                          (MSP_HANDLE) this,
                                                          &pTerminal);

                //
                // The terminal keeps a reference to the moniker if it needs to.
                //

                pMoniker->Release();

                if (SUCCEEDED(hr))
                {
                    //
                    // Add this terminal pointer to our list. Don't release it; we
                    // keep this one reference to it in the list.
                    //

                    BOOL fSuccess = m_Terminals.Add(pTerminal);

                    if ( ! fSuccess )
                    {
                        pCatEnum->Release();
                        pTerminal->Release();

                        LOG((MSP_ERROR, "CMSPAddress::UpdateTerminalListForPnp - "
                            "can't add terminal to list; returning E_OUTOFMEMORY"));

                        return E_OUTOFMEMORY;
                    }

                    //
                    // Set its CMSPAddress pointer
                    //
                    CBaseTerminal * pCTerminal = static_cast<CBaseTerminal *> (pTerminal);

                    //
                    // Mark this terminal so we don't remove it
                    //

                    pCSingleFilterStaticTerminal = static_cast<CSingleFilterStaticTerminal *>(pTerminal);

                    if (pCSingleFilterStaticTerminal == NULL)
                    {           
                        LOG((MSP_ERROR, "CMSPAddress::UpdateTerminalListForPnp - "
                                "bad terminal pointer"));
                        return E_FAIL;
                    }

                    pCSingleFilterStaticTerminal->m_bMark = TRUE;

                    //
                    // Post a TAPI message about the new terminal's arrival
                    //

                    pTerminal->AddRef();

                    MSPEVENTITEM *pEventItem;

                    pEventItem = AllocateEventItem();

                    if (pEventItem == NULL)
                    {
                        LOG((MSP_ERROR, "CMSPAddress::UpdateTerminalListForPnp - "
                        "can't allocate event item; returning E_OUTOFMEMORY"));

                        pTerminal->Release();
                        return E_OUTOFMEMORY;
                    }

                    pEventItem->MSPEventInfo.dwSize = sizeof(MSP_EVENT_INFO);
                    pEventItem->MSPEventInfo.Event = ME_ADDRESS_EVENT;
                    pEventItem->MSPEventInfo.MSP_ADDRESS_EVENT_INFO.Type = ADDRESS_TERMINAL_AVAILABLE;
                    pEventItem->MSPEventInfo.MSP_ADDRESS_EVENT_INFO.pTerminal = pTerminal;

                    hr = PostEvent(pEventItem);

                    if (FAILED(hr))
                    {
                        LOG((MSP_ERROR, "CMSPAddress::UpdateTerminalListForPnp - "
                        "post event failed"));

                        pTerminal->Release();
                        FreeEventItem(pEventItem);
                    } 
                    
                }
            }

            //
            // If it failed, that either means we skipped the device because it
            // was unsuitable (a routine occurance) or something failed, like
            // out of memory. I should come up with a way to differentiate and
            // handle this well.
            //
        }

        //
        // We are done with the enumerator.
        //

        pCatEnum->Release();
    }

    //
    // Release DevEnum.
    //

    pCreateDevEnum->Release();

    //
    // Sweep the terminal list and clean up any terminals which are no longer present
    //

    iSize = m_Terminals.GetSize();
    _ASSERTE( iSize >= 0 );

    for (i = 0; i < iSize; i++)
    {
        pCSingleFilterStaticTerminal = static_cast<CSingleFilterStaticTerminal *>(m_Terminals[i]);

        if (pCSingleFilterStaticTerminal == NULL)
        {           
            LOG((MSP_ERROR, "CMSPAddress::UpdateTerminalListForPnp - "
                    "bad terminal pointer"));
            return E_FAIL;
        }

        if (!pCSingleFilterStaticTerminal->m_bMark)
        {        
            //
            // This terminal has is no longer present, lets remove it from the list
            //

            LOG((MSP_TRACE, "CMSPAddress::UpdateTerminalListForPnp "
                   "found a terminal to be removed"));

            ITTerminal * pTerminal = m_Terminals[i];

            if (m_Terminals.RemoveAt(i))
            {
                //
                // Clear its CMSPAddress pointer
                //
                CBaseTerminal * pCTerminal = static_cast<CBaseTerminal *> (pTerminal);
                
                //
                // We don't release the terminal here even though we are removing
                // it from the terminal list because TAPI3.dll will release it
                // when it releases the event.
                //

                //
                // Post a TAPI message about the new terminal's removal
                //

                MSPEVENTITEM *pEventItem;

                pEventItem = AllocateEventItem();

                if (pEventItem == NULL)
                {
                    LOG((MSP_ERROR, "CMSPAddress::UpdateTerminalListForPnp - "
                    "can't allocate event item; returning E_OUTOFMEMORY"));

                    pTerminal->Release();
                    return E_OUTOFMEMORY;
                }

                pEventItem->MSPEventInfo.dwSize = sizeof(MSP_EVENT_INFO);
                pEventItem->MSPEventInfo.Event = ME_ADDRESS_EVENT;
                pEventItem->MSPEventInfo.MSP_ADDRESS_EVENT_INFO.Type = ADDRESS_TERMINAL_UNAVAILABLE;
                pEventItem->MSPEventInfo.MSP_ADDRESS_EVENT_INFO.pTerminal = pTerminal;

                hr = PostEvent(pEventItem);

                if (FAILED(hr))
                {
                    LOG((MSP_ERROR, "CMSPAddress::UpdateTerminalListForPnp - "
                    "post event failed"));

                    pTerminal->Release();
                    FreeEventItem(pEventItem);
                }
            
                //
                // fix up our search indices to account for a removal
                //
            
                iSize--;
                i--;
            }
        }
    }

    //
    // Our list is now complete.
    //

    m_fTerminalsUpToDate = TRUE;
    
    LOG((MSP_TRACE, "CMSPAddress::UpdateTerminalListForPnp - exit S_OK"));

    return S_OK;
}


HRESULT CMSPAddress::UpdateTerminalList(void)
{
    //
    // Create DevEnum, which is the DirectShow Category Enumerator Creator
    //

    HRESULT hr;
    ICreateDevEnum * pCreateDevEnum;

    hr = CoCreateInstance(CLSID_SystemDeviceEnum,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ICreateDevEnum,
                          (void**)&pCreateDevEnum);

    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "CMSPAddress::UpdateTerminalList "
               "can't CoCreate DevEnum - returning  0x%08x", hr));
        return hr;
    }    

    IEnumMoniker  * pCatEnum;

    for ( DWORD i = 0; i < m_sdwTerminalTypesCount; i++ )
    {
        //
        // Skip any terminal types that don't use one of the supported media
        // modes.
        //

        if ( ! IsValidSingleMediaType( 
            m_saTerminalTypes[i].dwMediaType, GetCallMediaTypes() ) )
        {
            continue;
        }


        //
        // Create the actual category enumerator.
        //

        hr = pCreateDevEnum->CreateClassEnumerator(
                                *(m_saTerminalTypes[i].clsidClassManager),
                                &pCatEnum,
                                0);

        if ( hr != S_OK ) // S_FALSE means the category does not exist!
        {
            LOG((MSP_ERROR, "CMSPAddress::UpdateTerminalList "
                   "can't create class enumerator - returning 0x%08x", hr));

            continue;
        }

        IMoniker      * pMoniker;

        while ((hr = pCatEnum->Next(1, &pMoniker, NULL)) == S_OK)
        {
            //
            // Create a terminal and give it its moniker.
            //

            ITTerminal * pTerminal;
            hr = (m_saTerminalTypes[i].pfnCreateTerm)(pMoniker,
                                                      (MSP_HANDLE) this,
                                                      &pTerminal);

            //
            // The terminal keeps a reference to the moniker if it needs to.
            //

            pMoniker->Release();

            if (SUCCEEDED(hr))
            {
                //
                // Add this terminal pointer to our list. Don't release it; we
                // keep this one reference to it in the list.
                //

                BOOL fSuccess = m_Terminals.Add(pTerminal);

                if ( ! fSuccess )
                {
                    pCatEnum->Release();

                    LOG((MSP_ERROR, "CMSPAddress::UpdateTerminalList - "
                        "can't add terminal to list; returning E_OUTOFMEMORY"));

                    return E_OUTOFMEMORY;
                }
                //
                // Set its CMSPAddress pointer
                //
                CBaseTerminal * pCTerminal = static_cast<CBaseTerminal *> (pTerminal);

            }

            //
            // If it failed, that either means we skipped the device because it
            // was unsuitable (a routine occurance) or something failed, like
            // out of memory. I should come up with a way to differentiate and
            // handle this well.
            //
        }

        //
        // We are done with the enumerator.
        //

        pCatEnum->Release();
    }

    //
    // Release DevEnum.
    //

    pCreateDevEnum->Release();

    //
    // Our list is now complete.
    //

    m_fTerminalsUpToDate = TRUE;
    
    LOG((MSP_TRACE, "CMSPAddress::UpdateTerminalList - exit S_OK"));

    return S_OK;
}

HRESULT CMSPAddress::GetDynamicTerminalClasses(
    IN OUT  DWORD *             pdwNumClasses,
    OUT     IID *               pTerminalClasses
    )
/*++

Routine Description:

This method is called by TAPI3 to get a list of dynamic terminal guids 
that can be used on this address. It asks the terminal manager for the 
list of guids and returns them. Derived class can override this method 
to have their own guids.


Arguments:

pdwNumClasses
    Pointer to a DWORD.  On entry, indicates the size of the buffer 
    pointed to in pTerminalClasses. On success, it will be filled in 
    with the actual number of class IIDs returned.  If the buffer is 
    not big enough, the method will return TAPI_E_NOTENOUGHMEMORY, 
    and it will be filled in the with number of IIDs needed. 

pTerminalClasses

    On success, filled in with an array of terminal class IIDs that 
    are supported by the MSP for this address.  This value may be NULL, 
    in which case pdwNumClasses will return the needed buffer size.
    
Return Value:

S_OK
E_OUTOFMEMORY
TAPI_E_NOTENOUGHMEMORY

--*/
{
    LOG((MSP_TRACE,
        "CMSPAddress::GetDynamicTerminalClasses - enter"));

    //
    // Check if initialized.
    //

    // lock the event related data
    m_EventDataLock.Lock();

    if ( m_htEvent == NULL )
    {
        // unlock the event related data
        m_EventDataLock.Unlock();

        LOG((MSP_ERROR,
            "CMSPAddress::GetDynamicTerminalClasses - "
            "not initialized - returning E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    // unlock the event related data
    m_EventDataLock.Unlock();

    //
    // Ask the Terminal Manager for the dynamic terminals that apply to
    // all of our supported media types. Since the mapping is
    // direct, the Terminal Manager takes care of all argument checking.
    //

    HRESULT hr;

    hr = m_pITTerminalManager->GetDynamicTerminalClasses(
                                                  GetCallMediaTypes(),
                                                  pdwNumClasses,
                                                  pTerminalClasses);


    LOG((MSP_TRACE,
        "CMSPAddress::GetDynamicTerminalClasses - exit 0x%08x", hr));

    return hr;
}

STDMETHODIMP CMSPAddress::CreateTerminal(
    IN      BSTR                pTerminalClass,
    IN      long                lMediaType,
    IN      TERMINAL_DIRECTION  Direction,
    OUT     ITTerminal **       ppTerminal
    )
/*++

Routine Description:

This method is called by TAPI3 to create a dynamic terminal. It asks the 
terminal manager to create a dynamic terminal. Derived class can
override this method to have their own way of creating a dynamic terminal.

Arguments:

iidTerminalClass
    IID of the terminal class to be created.

dwMediaType
    TAPI media type of the terminal to be created.

Direction
    Terminal direction of the terminal to be created.

ppTerminal
    Returned created terminal object
    
Return Value:

S_OK

E_OUTOFMEMORY
TAPI_E_INVALIDMEDIATYPE
TAPI_E_INVALIDTERMINALDIRECTION
TAPI_E_INVALIDTERMINALCLASS

--*/
{
    LOG((MSP_TRACE,
        "CMSPAddress::CreateTerminal - enter"));

    //
    // Check if initialized.
    //

    // lock the event related data
    m_EventDataLock.Lock();

    if ( m_htEvent == NULL )
    {
        // unlock the event related data
        m_EventDataLock.Unlock();

        LOG((MSP_ERROR,
            "CMSPAddress::CreateTerminal - "
            "not initialized - returning E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    // unlock the event related data
    m_EventDataLock.Unlock();

    //
    // Get the IID from the BSTR representation.
    //

    HRESULT hr;
    IID     iidTerminalClass;

    hr = CLSIDFromString(pTerminalClass, &iidTerminalClass);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::CreateTerminal - "
            "bad CLSID string - returning E_INVALIDARG"));

        return E_INVALIDARG;
    }

    //
    // Make sure we support the requested media type.
    // The terminal manager checks the terminal class, terminal direction, 
    // and return pointer.
    //


    
    //
    // requested media type may be aggregated, but it must still be valid
    //

    if ( !IsValidAggregatedMediaType(lMediaType) )
    {
        LOG((MSP_ERROR, "CMSPAddress::CreateTerminal - "
            "unrecognized media type requested - returning E_INVALIDARG"));

        return E_INVALIDARG;
    }

    //
    // Use the terminal manager to create the dynamic terminal.
    //

    _ASSERTE( m_pITTerminalManager != NULL );

    hr = m_pITTerminalManager->CreateDynamicTerminal(NULL,
                                                     iidTerminalClass,
                                                     (DWORD) lMediaType,
                                                     Direction,
                                                     (MSP_HANDLE) this,
                                                     ppTerminal);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::CreateTerminal - "
            "create dynamic terminal failed - returning 0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CMSPAddress::CreateTerminal - exit S_OK"));

    return S_OK;
}

STDMETHODIMP CMSPAddress::GetDefaultStaticTerminal(
    IN      long                lMediaType,
    IN      TERMINAL_DIRECTION  Direction,
    OUT     ITTerminal **       ppTerminal
    )
/*++

Routine Description:

This method is called by TAPI3 to get the default static terminal 
for a certain type and direction. It updates the list if needed, then
figures out which terminal is the first of the appropriate type in our
list. Derived classes can override this method to have 
their own way of deciding which terminal is the default. Locks the 
terminal lists.


Arguments:

dwMediaType
    The TAPIMEDIATYPE of the terminal to retrieve.  Only one bit will be set.

Direction
    TERMINAL_DIRECTION of the terminal to retrieve.

ppTerminal
    Default terminal returned

    
Return Value:

S_OK

E_POINTER
E_OUTOFMEMORY
TAPI_E_NOTSUPPORTED
TAPI_E_INVALIDMEDIATYPE
TAPI_E_INVALIDTERMINALDIRECTION

--*/
{
    LOG((MSP_TRACE,
        "CMSPAddress::GetDefaultStaticTerminal - enter"));

    //
    // Check if initialized.
    //

    // lock the event related data
    m_EventDataLock.Lock();

    if ( m_htEvent == NULL )
    {
        // unlock the event related data
        m_EventDataLock.Unlock();

        LOG((MSP_ERROR,
            "CMSPAddress::GetDefaultStaticTerminal - "
            "not initialized - returning E_UNEXPECTED"));

        return E_UNEXPECTED;
    }
    // unlock the event related data
    m_EventDataLock.Unlock();

    //
    // Make sure we support this media type.
    //

    if ( ! IsValidSingleMediaType( (DWORD) lMediaType, GetCallMediaTypes() ) )
    {
        LOG((MSP_ERROR,
            "CMSPAddress::GetDefaultStaticTerminal - "
            "non-audio terminal requested - returning E_INVALIDARG"));

        return E_INVALIDARG;
    }

    //
    // Check the direction.
    //

    if ( ( Direction != TD_CAPTURE ) && ( Direction != TD_RENDER ) )
    {
        LOG((MSP_ERROR,
            "CMSPAddress::GetDefaultStaticTerminal - "
            "invalid direction - returning E_INVALIDARG"));

        return E_INVALIDARG;
    }

    //
    // Check return pointer.
    //

    if ( MSPB_IsBadWritePtr(ppTerminal, sizeof(ITTerminal *) ) )
    {
        LOG((MSP_ERROR,
            "CMSPAddress::GetDefaultStaticTerminal - "
            "bad terminal return pointer - returning E_POINTER"));

        return E_POINTER;
    }

    // lock the terminal related data. This is a auto lock that will unlock
    // when the function returns.
    CLock lock(m_TerminalDataLock);

    if (!m_fTerminalsUpToDate)
    {
       HRESULT hr = UpdateTerminalList();

        if (FAILED(hr))
        {
            LOG((MSP_ERROR,
                "CMSPAddress::GetDefaultStaticTerminal - "
                "UpdateTerminalList failed - returning 0x%08x", hr));

            return hr;
        }
    }

    //
    // For each terminal in the list of terminals we created...
    //

    int iSize = m_Terminals.GetSize();

    for (int i = 0; i < iSize; i++)
    {
        ITTerminal * pTerminal = m_Terminals[i];

        HRESULT      hr;

        //
        // Make sure this is the right direction.
        // 

        TERMINAL_DIRECTION dir;

        hr = pTerminal->get_Direction(&dir);

        if (FAILED(hr))
        {
            LOG((MSP_WARN,
                "CMSPAddress::GetDefaultStaticTerminal - "
                "could not get terminal direction - skipping"));

            continue;
        }

        if ( dir != Direction )
        {
            continue;
        }

        //
        // Make sure this is the right media type.
        //

        long lMediaTypeObserved;

        hr = pTerminal->get_MediaType(&lMediaTypeObserved);

        if (FAILED(hr))
        {
            LOG((MSP_WARN,
                "CMSPAddress::GetDefaultStaticTerminal - "
                "could not get terminal media type - skipping"));

            continue;
        }

        if ( ( lMediaTypeObserved & lMediaType) == 0 )
        {
            continue;
        }

        //
        // Ok, so this is the terminal we want. Addref it and give it to the
        // caller.
        //

        pTerminal->AddRef();

        *ppTerminal = pTerminal;

        LOG((MSP_TRACE,
            "CMSPAddress::GetDefaultStaticTerminal - "
            "returned a terminal - exit S_OK"));

        return S_OK;
    }
    
    //
    // If we get here then we did not find any matching terminals.
    //

    LOG((MSP_TRACE,
        "CMSPAddress::GetDefaultStaticTerminal - "
        "no match - exit TAPI_E_NOITEMS"));

    return TAPI_E_NOITEMS;
}

STDMETHODIMP CMSPAddress::get_PluggableSuperclasses( 
    OUT VARIANT * pVariant
    )
{
    LOG((MSP_TRACE,
        "CMSPAddress::get_PluggableSuperclasses - enter"));

    //
    // Check parameters.
    //

    if ( MSPB_IsBadWritePtr(pVariant, sizeof(VARIANT) ) )
    {
        LOG((MSP_ERROR, "CMSPAddress::get_PluggableSuperclasses - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // Get ITTemrinalManager2
    //

    ITTerminalManager2* pTermMgr2 = NULL;
    HRESULT hr = E_FAIL;
    hr = m_pITTerminalManager->QueryInterface(
        IID_ITTerminalManager2, (void**)&pTermMgr2);

    if( FAILED(hr) )
    {
        LOG((MSP_ERROR,
            "CMSPAddress::get_PluggableSuperclasses - "
            "QI for ITTerminalManager2 failed - returning 0x%08x", hr));
        return hr;
    }

    //
    // Create the collection object - see mspcoll.h
    //

    typedef CTapiIfCollection< ITPluggableTerminalSuperclassInfo* > SuperclassCollection;
    CComObject<SuperclassCollection> * pCollection;
    hr = CComObject<SuperclassCollection>::CreateInstance( &pCollection );

    if ( FAILED(hr) )
    {
        //Clean-up
        pTermMgr2->Release();

        LOG((MSP_ERROR, "CMSPAddress::get_PluggableSuperclasses - "
            "can't create collection - exit 0x%08x", hr));

        return hr;
    }

    //
    // Get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;
    hr = pCollection->_InternalQueryInterface(
        IID_IDispatch,
        (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        //Clean-up
        pTermMgr2->Release();
        delete pCollection;

        LOG((MSP_ERROR, "CMSPAddress::get_PluggableSuperclasses - "
            "QI for IDispatch on collection failed - exit 0x%08x", hr));
        return hr;
    }

    //
    // Find out how many superclasses are available.
    //

    DWORD   dwNumSuperclasses = 0;

    hr = pTermMgr2->GetPluggableSuperclasses(
            &dwNumSuperclasses,
            NULL);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::get_PluggableSuperclasses - "
            "can't get number of terminals - exit 0x%08x", hr));

        //Clean-up
        pTermMgr2->Release();
        pDispatch->Release();

        return hr;
    }

    //
    // Allocate an array of IID.
    //

    IID* pSuperclassesIID = new IID[dwNumSuperclasses];
    if ( pSuperclassesIID == NULL )
    {
        LOG((MSP_ERROR, "CMSPAddress::get_PluggableSuperclasses - "
            "can't allocate IIDs array - exit E_OUTOFMEMORY"));

        //Clean-up
        pTermMgr2->Release();
        pDispatch->Release();

        return E_OUTOFMEMORY;
    }

    //
    // Fill in the array with actual pointers. We must do this before
    // initializing the enumerator, because the enumerator may want to
    // addref the interface pointers during initialize.
    // 

    hr = pTermMgr2->GetPluggableSuperclasses(
            &dwNumSuperclasses,
            pSuperclassesIID
            );

    //
    // Clean-up
    //

    pTermMgr2->Release();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::get_PluggableSuperclasses - "
            "can't get IIDs - exit 0x%08x", hr));

        //Clean-up
        pDispatch->Release();
        delete[] pSuperclassesIID;

        return hr;
    }

    //
    // Allocate an array of ITPluggableTerminalSuperclassInfo
    //
    typedef ITPluggableTerminalSuperclassInfo* SuperclassPtr; // MS parser
    SuperclassPtr * ppSuperclassesInfo = new SuperclassPtr[dwNumSuperclasses];
    if ( ppSuperclassesInfo == NULL )
    {
        LOG((MSP_ERROR, "CMSPAddress::get_PluggableSuperclasses - "
            "can't allocate SuperclassPtr array - exit E_OUTOFMEMORY"));

        //Clean-up
        pDispatch->Release();
        delete[] pSuperclassesIID;

        return E_OUTOFMEMORY;
    }

    //
    // Get ITPluggableTerminalSuperclassRegistration interface
    //

    ITPluggableTerminalSuperclassRegistration* pSuperclassReg = NULL;
    hr = CoCreateInstance(
        CLSID_PluggableSuperclassRegistration,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITPluggableTerminalSuperclassRegistration,
        (void**)&pSuperclassReg
        );
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::get_PluggableSuperclasses - "
            "QI for ITPluggableTerminalSuperclassRegistration - exit 0x%08x",hr));

        //Clean-up
        pDispatch->Release();
        delete[] pSuperclassesIID;
        delete[] ppSuperclassesInfo;

        return hr;
    }

    //
    // Create the objects
    //

    for(DWORD dwIndex = 0; dwIndex < dwNumSuperclasses; dwIndex++)
    {
        //
        // Get the string from the IID
        //
        LPOLESTR lpszCLSID = NULL;
        hr = StringFromIID( pSuperclassesIID[dwIndex], &lpszCLSID);
        if( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CMSPAddress::get_PluggableSuperclasses - "
                "StringFromIID failed - exit 0x%08x",hr));

            //Clean-up
            pDispatch->Release();
            delete[] pSuperclassesIID;
            delete[] ppSuperclassesInfo;
            pSuperclassReg->Release();

            return hr;
        }

        //
        // Get BSTR for IID
        //
        BSTR bstrCLSID = SysAllocString( lpszCLSID );
        CoTaskMemFree( lpszCLSID ); // Clean-up
        if( NULL == bstrCLSID)
        {
            LOG((MSP_ERROR, "CMSPAddress::get_PluggableSuperclasses - "
                "SysAllocString failed - exit E_OUTOFMEMORY"));

            // Clean-up
            pDispatch->Release();
            delete[] pSuperclassesIID;
            delete[] ppSuperclassesInfo;
            pSuperclassReg->Release();

            return E_OUTOFMEMORY;
        }

        //
        // Read information from registry
        //

        hr = pSuperclassReg->put_CLSID( bstrCLSID);
        if(FAILED(hr) )
        {
            LOG((MSP_ERROR, "CMSPAddress::get_PluggableSuperclasses - "
                "put_CLSID failed - exit 0x%08x",hr));

            // Clean-up
            pDispatch->Release();
            delete[] pSuperclassesIID;
            delete[] ppSuperclassesInfo;
            pSuperclassReg->Release();
            SysFreeString( bstrCLSID);

            return hr;
        }

        hr = pSuperclassReg->GetTerminalSuperclassInfo();
        if( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CMSPAddress::get_PluggableSuperclasses - "
                "GetTerminalSuperclassInfo failed - exit 0x%08x",hr));

            // Clean-up
            pDispatch->Release();
            delete[] pSuperclassesIID;
            delete[] ppSuperclassesInfo;
            pSuperclassReg->Release();
            SysFreeString( bstrCLSID);

            return hr;
        }

        //
        // Get the name
        //
        BSTR bstrName = NULL;
        pSuperclassReg->get_Name( &bstrName );

        //
        // Create the information object
        //
        CComObject<CPlugTerminalSuperclassInfo>* pSuperclassInfo = NULL;
        hr = CComObject<CPlugTerminalSuperclassInfo>::CreateInstance(&pSuperclassInfo);
        if( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CMSPAddress::get_PluggableSuperclasses - "
                "CreateInstance failed - exit 0x%08x", hr));

            //Clean-up
            pDispatch->Release();
            delete[] pSuperclassesIID;
            delete[] ppSuperclassesInfo;
            pSuperclassReg->Release();
            SysFreeString( bstrCLSID );
            SysFreeString( bstrName );

            return hr;
        }

        //
        // Get ITPluggableTerminalSuperclassInfo from this superclass
        //

        hr = pSuperclassInfo->QueryInterface(
            IID_ITPluggableTerminalSuperclassInfo, 
            (void**)&ppSuperclassesInfo[dwIndex]
            );

        _ASSERTE(hr == S_OK);

        //
        // Set the fields
        //

        hr = pSuperclassInfo->put_Name( bstrName);
        if( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CMSPAddress::get_PluggableSuperclasses - "
                "put_Name failed - exit 0x%08x", hr));

            //Clean-up
            pDispatch->Release();
            delete[] pSuperclassesIID;
            delete[] ppSuperclassesInfo;
            pSuperclassReg->Release();
            SysFreeString( bstrCLSID );
            SysFreeString( bstrName );
            return hr;
        }

        hr = pSuperclassInfo->put_CLSID( bstrCLSID );
        if( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CMSPAddress::get_PluggableSuperclasses - "
                "put_CLSID failed - exit 0x%08x", hr));

            //Clean-up
            pDispatch->Release();
            delete[] pSuperclassesIID;
            delete[] ppSuperclassesInfo;
            pSuperclassReg->Release();
            SysFreeString( bstrCLSID );
            SysFreeString( bstrName );
            return hr;
        }

        //
        // Clean-up
        //
        SysFreeString( bstrCLSID );
        SysFreeString( bstrName );
    }


    //
    // Clean-up the IIDs array
    //

    pSuperclassReg->Release();
    delete[] pSuperclassesIID;

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one. If it succeeds, this method addrefs each
    // element of ppterminals by querying for IDispatch.
    //

    hr = pCollection->Initialize( dwNumSuperclasses,
                                  ppSuperclassesInfo,
                                  ppSuperclassesInfo + dwNumSuperclasses );

    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::get_PluggableSuperclasses - exit "
            "pCollection->Initialize failed. returns 0x%08x", hr));

        delete[] ppSuperclassesInfo;
        pDispatch->Release();

        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    LOG((MSP_INFO, "CMSPAddress::get_PluggableSuperclasses - "
        "placing IDispatch value %08x in variant", pDispatch));

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((MSP_TRACE, "CMSPAddress::get_PluggableSuperclasses - exit S_OK"));

    return S_OK;
}

STDMETHODIMP CMSPAddress::EnumeratePluggableSuperclasses( 
    OUT IEnumPluggableSuperclassInfo** ppSuperclassEnumerator 
    )
{
    LOG((MSP_TRACE,
        "CMSPAddress::EnumeratePluggableSuperclasses - enter"));

    //
    // Check parameters.
    //

    if ( MSPB_IsBadWritePtr(ppSuperclassEnumerator, sizeof(IEnumPluggableTerminalClassInfo*) ) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableSuperclasses - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // Get ITTemrinalManager2
    //

    ITTerminalManager2* pTermMgr2 = NULL;
    HRESULT hr = E_FAIL;
    hr = m_pITTerminalManager->QueryInterface(
        IID_ITTerminalManager2, (void**)&pTermMgr2);

    if( FAILED(hr) )
    {
        LOG((MSP_ERROR,
            "CMSPAddress::EnumeratePluggableSuperclasses - "
            "QI for ITTerminalManager2 failed - returning 0x%08x", hr));
        return hr;
    }

    //
    // Find out how many superclasses are available.
    //

    DWORD   dwNumSuperclasses = 0;

    hr = pTermMgr2->GetPluggableSuperclasses(
            &dwNumSuperclasses,
            NULL);

    if ( FAILED(hr) )
    {
        // Clean-up
        pTermMgr2->Release();

        LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableSuperclasses - "
            "can't get number of terminals - exit 0x%08x", hr));

        return hr;
    }

    //
    // Allocate an array of IID.
    //

    IID* pSuperclassesIID = new IID[dwNumSuperclasses];
    if ( pSuperclassesIID == NULL )
    {
        // Clean-up
        pTermMgr2->Release();

        LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableSuperclasses - "
            "can't allocate IIDs array - exit E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    //
    // Fill in the array with actual pointers. We must do this before
    // initializing the enumerator, because the enumerator may want to
    // addref the interface pointers during initialize.
    // 

    hr = pTermMgr2->GetPluggableSuperclasses(
            &dwNumSuperclasses,
            pSuperclassesIID
            );

    //
    // Clean-up
    //

    pTermMgr2->Release();

    if ( FAILED(hr) )
    {
        //Clean-up
        delete[] pSuperclassesIID;

        LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableSuperclasses - "
            "can't get IIDs - exit 0x%08x", hr));

        return hr;
    }

    //
    // Allocate an array of ITPluggableTerminalSuperclassInfo
    //
    typedef ITPluggableTerminalSuperclassInfo* SuperclassPtr; // MS parser
    SuperclassPtr * ppSuperclassesInfo = new SuperclassPtr[dwNumSuperclasses];
    if ( ppSuperclassesInfo == NULL )
    {
        // Clean-up
        delete[] pSuperclassesIID;

        LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableSuperclasses - "
            "can't allocate SuperclassPtr array - exit E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    //
    // Get ITPluggableTerminalSuperclassRegistration interface
    //

    ITPluggableTerminalSuperclassRegistration* pSuperclassReg = NULL;
    hr = CoCreateInstance(
        CLSID_PluggableSuperclassRegistration,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITPluggableTerminalSuperclassRegistration,
        (void**)&pSuperclassReg
        );
    if( FAILED(hr) )
    {
        // Clean-up
        delete[] pSuperclassesIID;
        delete[] ppSuperclassesInfo;

        LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableSuperclasses - "
            "QI for ITPluggableTerminalSuperclassRegistration - exit 0x%08x",hr));

        return hr;
    }

    //
    // Create the objects
    //

    for(DWORD dwIndex = 0; dwIndex < dwNumSuperclasses; dwIndex++)
    {
        //
        // Get the string from the IID
        //
        LPOLESTR lpszCLSID = NULL;
        hr = StringFromIID( pSuperclassesIID[dwIndex], &lpszCLSID);
        if( FAILED(hr) )
        {
            //Clean-up
            delete[] pSuperclassesIID;
            delete[] ppSuperclassesInfo;
            pSuperclassReg->Release();

            LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableSuperclasses - "
                "StringFromIID failed - exit 0x%08x",hr));

            return hr;
        }

        //
        // Get BSTR for IID
        //
        BSTR bstrCLSID = SysAllocString( lpszCLSID );
        CoTaskMemFree( lpszCLSID ); // Clean-up
        if( NULL == bstrCLSID)
        {
            //Clean-up
            delete[] pSuperclassesIID;
            delete[] ppSuperclassesInfo;
            pSuperclassReg->Release();

            LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableSuperclasses - "
                "SysAllocString failed - exit E_OUTOFMEMORY"));

            return E_OUTOFMEMORY;
        }

        //
        // Read information from registry
        //

        pSuperclassReg->put_CLSID( bstrCLSID);
        hr = pSuperclassReg->GetTerminalSuperclassInfo();
        if( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableSuperclasses - "
                "GetTerminalSuperclassInfo failed - exit 0x%08x",hr));

            // Clean-up
            delete[] pSuperclassesIID;
            delete[] ppSuperclassesInfo;
            pSuperclassReg->Release();
            SysFreeString( bstrCLSID);

            return hr;
        }

        //
        // Get the name
        //
        BSTR bstrName = NULL;
        pSuperclassReg->get_Name( &bstrName );

        //
        // Create the information object
        //
        CComObject<CPlugTerminalSuperclassInfo>* pSuperclassInfo = NULL;
        hr = CComObject<CPlugTerminalSuperclassInfo>::CreateInstance(&pSuperclassInfo);
        if( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableSuperclasses - "
                "CreateInstance failed - exit 0x%08x", hr));

            // Clean-up
            delete[] pSuperclassesIID;
            delete[] ppSuperclassesInfo;
            pSuperclassReg->Release();
            SysFreeString( bstrCLSID );
            SysFreeString( bstrName );

            return hr;
        }

        //
        // Get ITPluggableTerminalSuperclassInfo from this superclass
        //

        hr = pSuperclassInfo->QueryInterface(
            IID_ITPluggableTerminalSuperclassInfo, 
            (void**)&ppSuperclassesInfo[dwIndex]
            );

        _ASSERTE( hr == S_OK );

        //
        // Set the fields
        //

        hr = pSuperclassInfo->put_Name( bstrName);
        if(FAILED(hr) )
        {
            LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableSuperclasses - "
                "put_Name failed - exit 0x%08x", hr));

            // Clean-up
            delete[] pSuperclassesIID;
            delete[] ppSuperclassesInfo;
            pSuperclassReg->Release();
            SysFreeString( bstrCLSID );
            SysFreeString( bstrName );

            return hr;
        }

        hr = pSuperclassInfo->put_CLSID( bstrCLSID );
        if(FAILED(hr) )
        {
            LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableSuperclasses - "
                "put_CLSID failed - exit 0x%08x", hr));

            // Clean-up
            delete[] pSuperclassesIID;
            delete[] ppSuperclassesInfo;
            pSuperclassReg->Release();
            SysFreeString( bstrCLSID );
            SysFreeString( bstrName );

            return hr;
        }

        //
        // Clean-up
        //
        SysFreeString( bstrCLSID );
        SysFreeString( bstrName );
    }


    //
    // Clean-up the IIDs array
    //

    pSuperclassReg->Release();
    delete[] pSuperclassesIID;

    //
    // Create the enumerator object.
    //

    typedef CSafeComEnum<IEnumPluggableSuperclassInfo,
                     &IID_IEnumPluggableSuperclassInfo,
                     ITPluggableTerminalSuperclassInfo*, 
                     _CopyInterface<ITPluggableTerminalSuperclassInfo> > CEnumerator;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = CComObject<CEnumerator>::CreateInstance(&pEnum);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableSuperclasses - "
            "can't create enumerator - exit 0x%08x", hr));

        delete[] ppSuperclassesInfo;
        return hr;
    }

    //
    // Query for the desired interface.
    //

    hr = pEnum->_InternalQueryInterface(
        IID_IEnumPluggableSuperclassInfo, 
        (void**) ppSuperclassEnumerator
        );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableSuperclasses - "
            "can't get enumerator interface - exit 0x%08x", hr));

        delete pEnum;
        delete[] ppSuperclassesInfo;
        
        return hr;
    }

    //
    // Init the enumerator object.
    //

    hr = pEnum->Init(ppSuperclassesInfo,
                     ppSuperclassesInfo + dwNumSuperclasses,
                     NULL,
                     AtlFlagTakeOwnership); 

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableSuperclasses - "
            "can't init enumerator - exit 0x%08x", hr));

        (*ppSuperclassEnumerator)->Release();
        delete[] ppSuperclassesInfo;
        
        return hr;
    }
    
    LOG((MSP_TRACE, "CMSPAddress::EnumeratePluggableSuperclasses - exit S_OK"));

    return S_OK;
}

STDMETHODIMP CMSPAddress::get_PluggableTerminalClasses( 
    IN  BSTR bstrTerminalSuperclass,
    IN  long lMediaType,
    OUT VARIANT * pVariant
    )
{
    LOG((MSP_TRACE,
        "CMSPAddress::get_PluggableTerminalClasses - enter"));

    //
    // Check parameters.
    //

    if ( MSPB_IsBadWritePtr(pVariant, sizeof(VARIANT) ) )
    {
        LOG((MSP_ERROR, "CMSPAddress::get_PluggableTerminalClasses - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    if( IsBadStringPtr( bstrTerminalSuperclass, (UINT)-1))
    {
        LOG((MSP_ERROR, "CMSPAddress::get_PluggableTerminalClasses - "
            "bad pointer argument - exit E_INVALIDARG"));

        return E_INVALIDARG;
    }

    IID iidSuperclass = IID_NULL;
    HRESULT hr = IIDFromString( bstrTerminalSuperclass, &iidSuperclass);
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::get_PluggableTerminalClasses - "
            "bad pointer argument - exit E_INVALIDARG"));

        return E_INVALIDARG;
    }

    //
    // Get ITTemrinalManager2
    //

    ITTerminalManager2* pTermMgr2 = NULL;
    hr = m_pITTerminalManager->QueryInterface(
        IID_ITTerminalManager2, (void**)&pTermMgr2);

    if( FAILED(hr) )
    {
        LOG((MSP_ERROR,
            "CMSPAddress::get_PluggableTerminalClasses - "
            "QI for ITTerminalManager2 failed - returning 0x%08x", hr));
        return hr;
    }

    //
    // Create the collection object - see mspcoll.h
    //

    typedef CTapiIfCollection< ITPluggableTerminalClassInfo* > ClassCollection;
    CComObject<ClassCollection> * pCollection;
    hr = CComObject<ClassCollection>::CreateInstance( &pCollection );

    if ( FAILED(hr) )
    {
        //Clean-up
        pTermMgr2->Release();

        LOG((MSP_ERROR, "CMSPAddress::get_PluggableTerminalClasses - "
            "can't create collection - exit 0x%08x", hr));

        return hr;
    }

    //
    // Get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;
    hr = pCollection->_InternalQueryInterface(
        IID_IDispatch,
        (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        // Clean-up
        pTermMgr2->Release();
        delete pCollection;

        LOG((MSP_ERROR, "CMSPAddress::get_PluggableTerminalClasses - "
            "QI for IDispatch on collection failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // Find out how many superclasses are available.
    //

    DWORD   dwNumClasses = 0;

    hr = pTermMgr2->GetPluggableTerminalClasses(
            iidSuperclass,
            lMediaType,
            &dwNumClasses,
            NULL);

    if ( FAILED(hr) )
    {
        //Clean-up
        pTermMgr2->Release();
        pDispatch->Release();

        LOG((MSP_ERROR, "CMSPAddress::get_PluggableTerminalClasses - "
            "can't get number of terminals - exit 0x%08x", hr));

        return hr;
    }

    //
    // Allocate an array of IID.
    //

    IID* pClassesIID = new IID[dwNumClasses];
    if ( pClassesIID == NULL )
    {
        //Clean-up
        pTermMgr2->Release();
        pDispatch->Release();

        LOG((MSP_ERROR, "CMSPAddress::get_PluggableTerminalClasses - "
            "can't allocate IIDs array - exit E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    //
    // Fill in the array with actual pointers. We must do this before
    // initializing the enumerator, because the enumerator may want to
    // addref the interface pointers during initialize.
    // 

    hr = pTermMgr2->GetPluggableTerminalClasses(
            iidSuperclass,
            lMediaType,
            &dwNumClasses,
            pClassesIID
            );

    //
    // Clean-up
    //

    pTermMgr2->Release();

    if ( FAILED(hr) )
    {
        //Clean-up
        pDispatch->Release();
        delete[] pClassesIID;

        LOG((MSP_ERROR, "CMSPAddress::get_PluggableTerminalClasses - "
            "can't get IIDs - exit 0x%08x", hr));

        return hr;
    }

    //
    // Allocate an array of ITPluggableTerminalClassInfo
    //
    typedef ITPluggableTerminalClassInfo* ClassPtr;
    ClassPtr * ppClassesInfo = new ClassPtr[dwNumClasses];
    if ( ppClassesInfo == NULL )
    {
        //Clean-up
        pDispatch->Release();
        delete[] pClassesIID;

        LOG((MSP_ERROR, "CMSPAddress::get_PluggableTerminalClasses - "
            "can't allocate ClassPtr array - exit E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    //
    // Get ITPluggableTerminalClassRegistration interface
    //

    ITPluggableTerminalClassRegistration* pClassReg = NULL;
    hr = CoCreateInstance(
        CLSID_PluggableTerminalRegistration,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITPluggableTerminalClassRegistration,
        (void**)&pClassReg
        );
    if( FAILED(hr) )
    {
        //Clean-up
        pDispatch->Release();
        delete[] pClassesIID;
        delete[] ppClassesInfo;

        LOG((MSP_ERROR, "CMSPAddress::get_PluggableTerminalClasses - "
            "QI for ITPluggableTerminalClassRegistration - exit 0x%08x",hr));

        return hr;
    }

    //
    // Create the objects
    //

    for(DWORD dwIndex = 0; dwIndex < dwNumClasses; dwIndex++)
    {
        //
        // Get the string from the IID
        //
        LPOLESTR lpszPublicCLSID = NULL;
        hr = StringFromIID( pClassesIID[dwIndex], &lpszPublicCLSID);
        if( FAILED(hr) )
        {
            //Clean-up
            pDispatch->Release();
            delete[] pClassesIID;
            delete[] ppClassesInfo;
            pClassReg->Release();

            LOG((MSP_ERROR, "CMSPAddress::get_PluggableTerminalClasses - "
                "StringFromIID failed - exit 0x%08x",hr));

            return hr;
        }

        //
        // Get BSTR for IID
        //
        BSTR bstrPublicCLSID = SysAllocString( lpszPublicCLSID );
        CoTaskMemFree( lpszPublicCLSID ); // Clean-up
        if( NULL == bstrPublicCLSID)
        {
            //Clean-up
            pDispatch->Release();
            delete[] pClassesIID;
            delete[] ppClassesInfo;
            pClassReg->Release();

            LOG((MSP_ERROR, "CMSPAddress::get_PluggableTerminalClasses - "
                "SysAllocString failed - exit E_OUTOFMEMORY"));

            return E_OUTOFMEMORY;
        }

        //
        // Read information from registry
        //

        pClassReg->put_TerminalClass( bstrPublicCLSID);
        hr = pClassReg->GetTerminalClassInfo(
            bstrTerminalSuperclass);
        if( FAILED(hr) )
        {
            // Clean-up
            pDispatch->Release();
            delete[] pClassesIID;
            delete[] ppClassesInfo;
            pClassReg->Release();
            SysFreeString( bstrPublicCLSID);

            LOG((MSP_ERROR, "CMSPAddress::get_PluggableTerminalClasses - "
                "GetTerminalInfo failed - exit 0x%08x",hr));

            return hr;
        }

        //
        // Get the name
        //
        BSTR bstrName = NULL;
        pClassReg->get_Name( &bstrName );
        BSTR bstrCompany = NULL;
        pClassReg->get_Company( &bstrCompany );
        BSTR bstrVersion = NULL;
        pClassReg->get_Version( &bstrVersion );
        BSTR bstrCLSID = NULL;
        pClassReg->get_CLSID( &bstrCLSID );
        TMGR_DIRECTION Direction = TMGR_TD_CAPTURE;
        pClassReg->get_Direction( &Direction );
        long lMediaType = 0;
        pClassReg->get_MediaTypes( &lMediaType );

        //
        // Create the information object
        //
        CComObject<CPlugTerminalClassInfo>* pClassInfo = NULL;
        hr = CComObject<CPlugTerminalClassInfo>::CreateInstance(&pClassInfo);
        if( FAILED(hr) )
        {
            //Clean-up
            pDispatch->Release();
            delete[] pClassesIID;
            delete[] ppClassesInfo;
            pClassReg->Release();
            SysFreeString( bstrPublicCLSID );
            SysFreeString( bstrName );
            SysFreeString( bstrCompany );
            SysFreeString( bstrVersion );
            SysFreeString( bstrCLSID );

            LOG((MSP_ERROR, "CMSPAddress::get_PluggableTerminalClasses - "
                "CreateInstance failed - exit 0x%08x", hr));

            return hr;
        }

        //
        // Get ITPluggableTerminalClassInfo from this superclass
        //

        pClassInfo->QueryInterface(
            IID_ITPluggableTerminalClassInfo, 
            (void**)&ppClassesInfo[dwIndex]
            );

        //
        // Set the fields
        //

        if( NULL == bstrName)
        {
            bstrName = SysAllocString(L"");
        }
        pClassInfo->put_Name( bstrName);
        pClassInfo->put_TerminalClass( bstrPublicCLSID );
        if( NULL == bstrCompany)
        {
            bstrCompany = SysAllocString(L"");
        }
        pClassInfo->put_Company( bstrCompany );
        if( NULL == bstrVersion)
        {
            bstrVersion = SysAllocString(L"");
        }
        pClassInfo->put_Version( bstrVersion );
        if( NULL == bstrCLSID)
        {
            LPOLESTR lpszCLSID = NULL;
            StringFromCLSID( CLSID_NULL, &lpszCLSID);
            bstrCLSID = SysAllocString(lpszCLSID);
            CoTaskMemFree( lpszCLSID);
        }
        pClassInfo->put_CLSID( bstrCLSID );
        TERMINAL_DIRECTION TermDirection = TD_CAPTURE;
        switch( Direction )
        {
        case TMGR_TD_RENDER:
            TermDirection = TD_RENDER;
            break;
        case TMGR_TD_BOTH:
            TermDirection = TD_BIDIRECTIONAL;
            break;
        case TMGR_TD_CAPTURE:
        default:
            TermDirection = TD_CAPTURE;
            break;
        }

        hr = pClassInfo->put_Direction( TermDirection );
        _ASSERTE(hr == S_OK );
        hr = pClassInfo->put_MediaTypes( lMediaType );
        _ASSERTE(hr == S_OK );

        //
        // Clean-up
        //
        SysFreeString( bstrPublicCLSID );
        SysFreeString( bstrName );
        SysFreeString( bstrCompany );
        SysFreeString( bstrVersion );
        SysFreeString( bstrCLSID );
    }


    //
    // Clean-up the IIDs array
    //

    pClassReg->Release();
    delete[] pClassesIID;

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one. If it succeeds, this method addrefs each
    // element of ppterminals by querying for IDispatch.
    //

    hr = pCollection->Initialize( dwNumClasses,
                                  ppClassesInfo,
                                  ppClassesInfo + dwNumClasses );

    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::get_PluggableTerminalClasses - exit "
            "pCollection->Initialize failed. returns 0x%08x", hr));

        delete[] ppClassesInfo;
        pDispatch->Release();

        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    LOG((MSP_INFO, "CMSPAddress::get_PluggableTerminalClasses - "
        "placing IDispatch value %08x in variant", pDispatch));

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((MSP_TRACE, "CMSPAddress::get_PluggableTerminalClasses - exit S_OK"));

    return S_OK;
}

STDMETHODIMP CMSPAddress::EnumeratePluggableTerminalClasses(
    IN  CLSID iidTerminalSuperclass,
    IN  long lMediaType,
    OUT IEnumPluggableTerminalClassInfo ** ppClassEnumerator 
    )
{
    LOG((MSP_TRACE,
        "CMSPAddress::EnumeratePluggableTerminalClasses - enter"));

    //
    // Check parameters.
    //

    if ( MSPB_IsBadWritePtr(ppClassEnumerator, sizeof(IEnumPluggableTerminalClassInfo *) ) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableTerminalClasses - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    LPOLESTR lpszCLSID = NULL;
    HRESULT hr = StringFromCLSID( iidTerminalSuperclass, &lpszCLSID);
    if( FAILED(hr) )
    {
         LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableTerminalClasses - "
            "StringFromCLSID failed - exit 0x%08x", hr));

        return hr;
    }

    BSTR bstrTerminalSuperclass = SysAllocString( lpszCLSID );

    // Clean-up
    CoTaskMemFree(lpszCLSID);
    lpszCLSID = NULL;


    if( NULL == bstrTerminalSuperclass )
    {
         LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableTerminalClasses - "
            "SysAllocString failed - exit E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    //
    // Get ITTemrinalManager2
    //

    ITTerminalManager2* pTermMgr2 = NULL;
    hr = m_pITTerminalManager->QueryInterface(
        IID_ITTerminalManager2, (void**)&pTermMgr2);

    if( FAILED(hr) )
    {
        //Clean-up
        SysFreeString( bstrTerminalSuperclass );

        LOG((MSP_ERROR,
            "CMSPAddress::EnumeratePluggableTerminalClasses - "
            "QI for ITTerminalManager2 failed - returning 0x%08x", hr));
        return hr;
    }

    //
    // Find out how many superclasses are available.
    //

    DWORD   dwNumClasses = 0;

    hr = pTermMgr2->GetPluggableTerminalClasses(
            iidTerminalSuperclass,
            lMediaType,
            &dwNumClasses,
            NULL);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableTerminalClasses - "
            "can't get number of terminals - exit 0x%08x", hr));

        // Clean-up
        SysFreeString( bstrTerminalSuperclass );
        pTermMgr2->Release();

        return hr;
    }

    //
    // Allocate an array of IID.
    //

    IID* pClassesIID = new IID[dwNumClasses];
    if ( pClassesIID == NULL )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableTerminalClasses - "
            "can't allocate IIDs array - exit E_OUTOFMEMORY"));

        // Clean-up
        SysFreeString( bstrTerminalSuperclass );
        pTermMgr2->Release();

        return E_OUTOFMEMORY;
    }

    //
    // Fill in the array with actual pointers. We must do this before
    // initializing the enumerator, because the enumerator may want to
    // addref the interface pointers during initialize.
    // 

    hr = pTermMgr2->GetPluggableTerminalClasses(
            iidTerminalSuperclass,
            lMediaType,
            &dwNumClasses,
            pClassesIID
            );

    //
    // Clean-up
    //

    pTermMgr2->Release();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableTerminalClasses - "
            "can't get IIDs - exit 0x%08x", hr));

        // Clean-up
        SysFreeString( bstrTerminalSuperclass );
        delete[] pClassesIID;

        return hr;
    }

    //
    // Allocate an array of ITPluggableTerminalClassInfo
    //
    typedef ITPluggableTerminalClassInfo* ClassPtr;
    ClassPtr * ppClassesInfo = new ClassPtr[dwNumClasses];
    if ( ppClassesInfo == NULL )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableTerminalClasses - "
            "can't allocate ClassPtr array - exit E_OUTOFMEMORY"));

        // Clean-up
        SysFreeString( bstrTerminalSuperclass );
        delete[] pClassesIID;

        return E_OUTOFMEMORY;
    }

    //
    // Get ITPluggableTerminalClassRegistration interface
    //

    ITPluggableTerminalClassRegistration* pClassReg = NULL;
    hr = CoCreateInstance(
        CLSID_PluggableTerminalRegistration,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ITPluggableTerminalClassRegistration,
        (void**)&pClassReg
        );
    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableTerminalClasses - "
            "QI for ITPluggableTerminalClassRegistration - exit 0x%08x",hr));

        // Clean-up
        SysFreeString( bstrTerminalSuperclass );
        delete[] ppClassesInfo;
        delete[] pClassesIID;

        return hr;
    }

    //
    // Create the objects
    //

    for(DWORD dwIndex = 0; dwIndex < dwNumClasses; dwIndex++)
    {
        //
        // Get the string from the IID
        //
        LPOLESTR lpszPublicCLSID = NULL;
        hr = StringFromIID( pClassesIID[dwIndex], &lpszPublicCLSID);
        if( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableTerminalClasses - "
                "StringFromIID failed - exit 0x%08x",hr));

            // Clean-up
            SysFreeString( bstrTerminalSuperclass );
            delete[] pClassesIID;
            delete[] ppClassesInfo;
            pClassReg->Release();

            return hr;
        }

        //
        // Get BSTR for IID
        //
        BSTR bstrPublicCLSID = SysAllocString( lpszPublicCLSID );
        CoTaskMemFree( lpszPublicCLSID ); // Clean-up
        if( NULL == bstrPublicCLSID)
        {
            LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableTerminalClasses - "
                "SysAllocString failed - exit E_OUTOFMEMORY"));


            // Clean-up
            SysFreeString( bstrTerminalSuperclass );
            delete[] pClassesIID;
            delete[] ppClassesInfo;
            pClassReg->Release();

            return E_OUTOFMEMORY;
        }

        //
        // Read information from registry
        //

        pClassReg->put_TerminalClass( bstrPublicCLSID);
        hr = pClassReg->GetTerminalClassInfo(
            bstrTerminalSuperclass);
        if( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableTerminalClasses - "
                "GetTerminalInfo failed - exit 0x%08x",hr));

            // Clean-up
            SysFreeString( bstrTerminalSuperclass );
            delete[] pClassesIID;
            delete[] ppClassesInfo;
            pClassReg->Release();
            SysFreeString( bstrPublicCLSID);

            return hr;
        }

        //
        // Get the name
        //
        BSTR bstrName = NULL;
        pClassReg->get_Name( &bstrName );
        BSTR bstrCompany = NULL;
        pClassReg->get_Company( &bstrCompany );
        BSTR bstrVersion = NULL;
        pClassReg->get_Version( &bstrVersion );
        BSTR bstrCLSID = NULL;
        pClassReg->get_CLSID( &bstrCLSID );
        TMGR_DIRECTION Direction = TMGR_TD_CAPTURE;
        pClassReg->get_Direction( &Direction );
        long lMediaType = 0;
        pClassReg->get_MediaTypes( &lMediaType );

        //
        // Create the information object
        //
        CComObject<CPlugTerminalClassInfo>* pClassInfo = NULL;
        hr = CComObject<CPlugTerminalClassInfo>::CreateInstance(&pClassInfo);
        if( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableTerminalClasses - "
                "CreateInstance failed - exit 0x%08x", hr));

            // Clean-up
            SysFreeString( bstrTerminalSuperclass );
            delete[] pClassesIID;
            delete[] ppClassesInfo;
            pClassReg->Release();
            SysFreeString( bstrPublicCLSID );
            SysFreeString( bstrName );
            SysFreeString( bstrCompany );
            SysFreeString( bstrVersion );
            SysFreeString( bstrCLSID );

            return hr;
        }

        //
        // Get ITPluggableTerminalClassInfo from this superclass
        //

        hr = pClassInfo->QueryInterface(
            IID_ITPluggableTerminalClassInfo, 
            (void**)&ppClassesInfo[dwIndex]
            );

        _ASSERTE(hr == S_OK);

        //
        // Set the fields
        //

        if( NULL == bstrName)
        {
            bstrName = SysAllocString(L"");
        }
        pClassInfo->put_Name( bstrName);
        pClassInfo->put_TerminalClass( bstrPublicCLSID );
        if( NULL == bstrCompany)
        {
            bstrCompany = SysAllocString(L"");
        }
        pClassInfo->put_Company( bstrCompany );
        if( NULL == bstrVersion)
        {
            bstrVersion = SysAllocString(L"");
        }
        pClassInfo->put_Version( bstrVersion );
        if( NULL == bstrCLSID)
        {
            LPOLESTR lpszCLSID = NULL;
            StringFromCLSID( CLSID_NULL, &lpszCLSID);
            bstrCLSID = SysAllocString(lpszCLSID);
            CoTaskMemFree( lpszCLSID);
        }
        pClassInfo->put_CLSID( bstrCLSID );
        TERMINAL_DIRECTION TermDirection = TD_CAPTURE;
        switch( Direction )
        {
        case TMGR_TD_RENDER:
            TermDirection = TD_RENDER;
            break;
        case TMGR_TD_BOTH:
            TermDirection = TD_BIDIRECTIONAL;
            break;
        case TMGR_TD_CAPTURE:
        default:
            TermDirection = TD_CAPTURE;
            break;
        }
        pClassInfo->put_Direction( TermDirection );
        pClassInfo->put_MediaTypes( lMediaType );

        //
        // Clean-up
        //
        SysFreeString( bstrPublicCLSID );
        SysFreeString( bstrName );
        SysFreeString( bstrCompany );
        SysFreeString( bstrVersion );
        SysFreeString( bstrCLSID );
    }


    //
    // Clean-up the IIDs array
    //

    SysFreeString( bstrTerminalSuperclass );
    delete[] pClassesIID;
    pClassReg->Release();

    //
    // Create the enumerator object.
    //

    typedef CSafeComEnum<IEnumPluggableTerminalClassInfo,
                     &IID_IEnumPluggableTerminalClassInfo,
                     ITPluggableTerminalClassInfo*, 
                     _CopyInterface<ITPluggableTerminalClassInfo> > CEnumerator;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = CComObject<CEnumerator>::CreateInstance(&pEnum);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableTerminalClasses - "
            "can't create enumerator - exit 0x%08x", hr));

        delete[] ppClassesInfo;
        return hr;
    }

    //
    // Query for the desired interface.
    //

    hr = pEnum->_InternalQueryInterface(
        IID_IEnumPluggableTerminalClassInfo, 
        (void**) ppClassEnumerator
        );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableTerminalClasses - "
            "can't get enumerator interface - exit 0x%08x", hr));

        delete pEnum;
        delete[] ppClassesInfo;
        
        return hr;
    }

    //
    // Init the enumerator object.
    //

    hr = pEnum->Init(ppClassesInfo,
                     ppClassesInfo + dwNumClasses,
                     NULL,
                     AtlFlagTakeOwnership); 

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumeratePluggableTerminalClasses - "
            "can't init enumerator - exit 0x%08x", hr));

        (*ppClassEnumerator)->Release();
        delete[] ppClassesInfo;
        
        return hr;
    }
    
    LOG((MSP_TRACE, "CMSPAddress::EnumeratePluggableTerminalClasses - exit S_OK"));

    return S_OK;
}

STDMETHODIMP CMSPAddress::GetEvent(
    IN OUT  DWORD *             pdwSize,
    OUT     BYTE *              pBuffer
    )
/*++

Routine Description:

This method is called by TAPI3 to get detailed information about the 
event that just happened. TAPI3 will normally do this after its event 
is signaled. Locks the event list.

Arguments:

pMSPEvent
    The MSP_EVENT

pdwSize
    Pointer to a DWORD.  On entry, indicates the size in bytes of the 
    buffer pointed to in pbuffer. On success, it will be filled in with 
    the actual number of bytes returned.  If the buffer is not big enough, 
    the method will return TAPI_E_NOTENOUGHMEMORY, and it will be filled 
    in the with number of bytes needed. 

pBuffer
    Event buffer filled in by MSP with the relevant events
    
Return Value:

S_OK
E_OUTOFMEMORY
TAPI_E_NOEVENT
TAPI_E_NOTENOUGHMEMORY

--*/
{
    // We trust TAPI3 not to give us bad pointers.
    _ASSERTE(!MSPB_IsBadWritePtr(pdwSize, sizeof (DWORD *)));
    _ASSERTE((*pdwSize == 0) ? TRUE : 
        !MSPB_IsBadWritePtr(pBuffer, sizeof(BYTE) * (*pdwSize)));

    LOG((MSP_TRACE, "CMSPAddress::GetEvent"));

    CLock lock(m_EventDataLock);

    if (IsListEmpty(&m_EventList))
    {
        return TAPI_E_NOEVENT;
    }

    // retrieve first entry
    PLIST_ENTRY pLE = m_EventList.Flink;

    // convert list entry to structure pointer
    PMSPEVENTITEM pItem = CONTAINING_RECORD(pLE, MSPEVENTITEM, Link);

    if (pItem->MSPEventInfo.dwSize > *pdwSize)
    {
        *pdwSize = pItem->MSPEventInfo.dwSize;
        return TAPI_E_NOTENOUGHMEMORY;
    }
    
    CopyMemory(pBuffer, &pItem->MSPEventInfo, pItem->MSPEventInfo.dwSize);
    *pdwSize = pItem->MSPEventInfo.dwSize;

    // remove the first entry from the event list.
    RemoveHeadList(&m_EventList);

    // free the memory.
    FreeEventItem(pItem);

    return S_OK;
}

HRESULT CMSPAddress::PostEvent(
        IN      MSPEVENTITEM *      pEventItem
        )
/*++

Routine Description:

This method is called by MSPCalls to post an event to TAPI3. This method 
puts the event at the end of the event list and singals TAPI3. 
Locks the event list.


Arguments:

EventItem
    The event to be queued.
    
Return Value:

S_OK
E_OUTOFMEMORY

--*/
{
    CLock lock(m_EventDataLock);

    if (m_htEvent == NULL)
    {
        return E_UNEXPECTED;  // the address was shut down.
    }

    InsertTailList(&m_EventList, &pEventItem->Link);

    SetEvent(m_htEvent);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// OLE Automation wrappers


STDMETHODIMP CMSPAddress::get_StaticTerminals (
        OUT  VARIANT * pVariant
        )
{
    LOG((MSP_TRACE, "CMSPAddress::get_StaticTerminals - enter"));

    //
    // Check parameters.
    //

    if ( MSPB_IsBadWritePtr(pVariant, sizeof(VARIANT) ) )
    {
        LOG((MSP_ERROR, "CMSPAddress::get_StaticTerminals - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // create the collection object - see mspcoll.h
    //

    typedef CTapiIfCollection< ITTerminal * > TerminalCollection;
    CComObject<TerminalCollection> * pCollection;
    HRESULT hr = CComObject<TerminalCollection>::CreateInstance( &pCollection );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::get_StaticTerminals - "
            "can't create collection - exit 0x%08x", hr));

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;

    hr = pCollection->_InternalQueryInterface(IID_IDispatch,
                                              (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::get_StaticTerminals - "
            "QI for IDispatch on collection failed - exit 0x%08x", hr));

        delete pCollection;

        return hr;
    }

    //
    // Find out how many terminals are available.
    //

    DWORD   dwNumTerminals;

    hr = GetStaticTerminals(&dwNumTerminals,
                            NULL);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::get_StaticTerminals - "
            "can't get number of terminals - exit 0x%08x", hr));

        pDispatch->Release();

        return hr;
    }

    //
    // Allocate an array of terminal pointers.
    //

    typedef ITTerminal * TermPtr;
    TermPtr * ppTerminals = new TermPtr[dwNumTerminals];

    if ( ppTerminals == NULL )
    {
        LOG((MSP_ERROR, "CMSPAddress::get_StaticTerminals - "
            "can't allocate terminals array - exit E_OUTOFMEMORY"));

        pDispatch->Release();

        return E_OUTOFMEMORY;
    }

    //
    // Fill in the array with actual pointers. We must do this before
    // initializing the enumerator, because the enumerator may want to
    // addref the interface pointers during initialize.
    // 

    hr = GetStaticTerminals(&dwNumTerminals,
                            ppTerminals);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::get_StaticTerminals - "
            "can't get terminals - exit 0x%08x", hr));

        pDispatch->Release();
        delete ppTerminals;

        return hr;
    }
    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one. If it succeeds, this method addrefs each
    // element of ppterminals by querying for IDispatch.
    //

    hr = pCollection->Initialize( dwNumTerminals,
                                  ppTerminals,
                                  ppTerminals + dwNumTerminals );

    //
    // Release the ITTerminal reference to each terminal (leaving the
    // IDispatch reference, if any). Then delete the array; the
    // collection is now storing the pointers.
    //

    for (DWORD i = 0; i < dwNumTerminals; i++)
    {
        ppTerminals[i]->Release();
    }

    delete ppTerminals;
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMSPAddress::get_StaticTerminals - "
            "Initialize on collection failed - exit 0x%08x", hr));
        
        pDispatch->Release();

        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    LOG((MSP_ERROR, "CMSPAddress::get_StaticTerminals - "
        "placing IDispatch value %08x in variant", pDispatch));

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((MSP_TRACE, "CMSPAddress::get_StaticTerminals - exit S_OK"));
 
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMSPAddress::EnumerateStaticTerminals (
        OUT  IEnumTerminal ** ppTerminalEnumerator
        )
{
    LOG((MSP_TRACE, "CMSPAddress::EnumerateStaticTerminals - "
        "enter"));

    //
    // Check the return pointer.
    //

    if ( MSPB_IsBadWritePtr(ppTerminalEnumerator, sizeof(IEnumTerminal *) ) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumerateStaticTerminals - "
            "bad return pointer - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // Create the enumerator object.
    //

    typedef _CopyInterface<ITTerminal> CCopy;
    typedef CSafeComEnum<IEnumTerminal, &IID_IEnumTerminal,
        ITTerminal *, CCopy> CEnumerator;

    HRESULT hr;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = CComObject<CEnumerator>::CreateInstance(&pEnum);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumerateStaticTerminals - "
            "can't create enumerator - exit 0x%08x", hr));

        return hr;
    }

    //
    // Query for the desired interface.
    //

    hr = pEnum->_InternalQueryInterface(IID_IEnumTerminal,
                                        (void**) ppTerminalEnumerator);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumerateStaticTerminals - "
            "can't get enumerator interface - exit 0x%08x", hr));

        delete pEnum;

        return hr;
    }

    //
    // Find out how many terminals are available.
    //

    DWORD   dwNumTerminals;

    hr = GetStaticTerminals(&dwNumTerminals,
                            NULL);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumerateStaticTerminals - "
            "can't get number of terminals - exit 0x%08x", hr));

        (*ppTerminalEnumerator)->Release();

        return hr;
    }

    //
    // Allocate an array of terminal pointers.
    //

    typedef ITTerminal * TermPtr;
    TermPtr * ppTerminals = new TermPtr[dwNumTerminals];

    if ( ppTerminals == NULL )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumerateStaticTerminals - "
            "can't allocate terminals array - exit E_OUTOFMEMORY"));

        (*ppTerminalEnumerator)->Release();

        return E_OUTOFMEMORY;
    }

    //
    // Fill in the array with actual pointers. We must do this before
    // initializing the enumerator, because the enumerator may want to
    // addref the interface pointers during initialize.
    // 

    hr = GetStaticTerminals(&dwNumTerminals,
                            ppTerminals);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumerateStaticTerminals - "
            "can't get terminals - exit 0x%08x", hr));

        (*ppTerminalEnumerator)->Release();
        delete ppTerminals;

        return hr;
    }

    //
    // Initialize the object with the array of pointers.
    //

    hr = pEnum->Init(ppTerminals,
                     ppTerminals + dwNumTerminals,
                     NULL,
                     AtlFlagTakeOwnership);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMSPCallBase::EnumerateStaticTerminals - "
            "init enumerator failed - exit 0x%08x", hr));

        for (DWORD i = 0; i < dwNumTerminals; i++)
        {
            ppTerminals[i]->Release();
        }
        
        delete ppTerminals;
        (*ppTerminalEnumerator)->Release();

        return hr;
    }

    LOG((MSP_TRACE, "CMSPAddress::EnumerateStaticTerminals - exit S_OK"));

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMSPAddress::get_DynamicTerminalClasses (
        OUT  VARIANT * pVariant
        )
{
    LOG((MSP_TRACE, "CMSPAddress::get_DynamicTerminalClasses - enter"));

    //
    // Check parameters.
    //

    if ( MSPB_IsBadWritePtr(pVariant, sizeof(VARIANT) ) )
    {
        LOG((MSP_ERROR, "CMSPAddress::get_DynamicTerminalClasses - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // create the collection object - see mspcoll.h
    //

    CComObject<CTapiBstrCollection> * pCollection;
    HRESULT hr = CComObject<CTapiBstrCollection>::CreateInstance( &pCollection );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::get_DynamicTerminalClasses - "
            "can't create collection - exit 0x%08x", hr));

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;

    hr = pCollection->_InternalQueryInterface(IID_IDispatch,
                                              (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::get_DynamicTerminalClasses - "
            "QI for IDispatch on collection failed - exit 0x%08x", hr));

        delete pCollection;

        return hr;
    }

    //
    // Find out how many terminals classes are available.
    //

    DWORD   dwNumClasses;

    hr = GetDynamicTerminalClasses(&dwNumClasses,
                                   NULL);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumerateDynamicTerminalClasses - "
            "can't get number of terminal classes - exit 0x%08x", hr));

        pDispatch->Release();

        return hr;
    }

    //
    // Allocate an array of GUIDs.
    //

    IID * pClassGuids = new IID[dwNumClasses];

    if ( pClassGuids == NULL )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumerateDynamicTerminalClasses - "
            "can't allocate class guids array - exit E_OUTOFMEMORY"));

        pDispatch->Release();

        return E_OUTOFMEMORY;
    }

    //
    // Fill in the array with actual pointers.
    // 

    hr = GetDynamicTerminalClasses(&dwNumClasses,
                                   pClassGuids);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumerateDynamicTerminalClasses - "
            "can't get terminal class guids - exit 0x%08x", hr));

        pDispatch->Release();

        delete [] pClassGuids;

        return hr;
    }

    //
    // Allocate an array of BSTRs.
    //

    BSTR * pClassBstrs = new BSTR[dwNumClasses];

    if ( pClassBstrs == NULL )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumerateDynamicTerminalClasses - "
            "can't allocate class bstrs array - exit E_OUTOFMEMORY"));

        pDispatch->Release();

        delete [] pClassGuids;

        return E_OUTOFMEMORY;
    }

    //
    // Allocate a string for each GUID and copy it to the array,
    // then delete the array of GUIDs.
    //

    const int BUFSIZE = 100;
    WCHAR wszBuffer[BUFSIZE];

    for (DWORD i = 0; i < dwNumClasses; i++)
    {
        int ret = StringFromGUID2(pClassGuids[i], wszBuffer, BUFSIZE);

        _ASSERTE(ret != 0);

        pClassBstrs[i] = SysAllocString(wszBuffer);

        if ( pClassBstrs[i] == NULL )
        {
            LOG((MSP_ERROR, "CMSPAddress::EnumerateDynamicTerminalClasses - "
                "can't allocate a bstr - exit E_OUTOFMEMORY"));

            for (DWORD j = 0; j < i; j++)
            {
                SysFreeString(pClassBstrs[j]);
            }

            delete [] pClassBstrs;
            delete [] pClassGuids;

            pDispatch->Release();
    
            return E_OUTOFMEMORY;
        }
    }

    delete [] pClassGuids;

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one.
    //

    hr = pCollection->Initialize( dwNumClasses,
                                  pClassBstrs,
                                  pClassBstrs + dwNumClasses );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::get_DynamicTerminalClasses - "
            "Initialize on collection failed - exit 0x%08x", hr));
        
        pDispatch->Release();

        for (DWORD k = 0; k < dwNumClasses; k++)
        {
            SysFreeString(pClassBstrs[k]);
        }
        
        delete [] pClassBstrs;

        return hr;
    }

    delete [] pClassBstrs;

    //
    // put the IDispatch interface pointer into the variant
    //

    LOG((MSP_ERROR, "CMSPAddress::get_DynamicTerminalClasses - "
        "placing IDispatch value %08x in variant", pDispatch));

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((MSP_TRACE, "CMSPAddress::get_DynamicTerminalClasses - exit S_OK"));
 
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CMSPAddress::EnumerateDynamicTerminalClasses (
        OUT  IEnumTerminalClass ** ppTerminalClassEnumerator
        )
{
    LOG((MSP_TRACE, "CMSPAddress::EnumerateDynamicTerminalClasses - enter"));

    //
    // Check the return pointer.
    //

    if ( MSPB_IsBadWritePtr(ppTerminalClassEnumerator,
                       sizeof(IEnumTerminalClass *) ) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumerateDynamicTerminalClasses - "
            "bad return pointer - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // Find out how many terminals classes are available.
    //

    HRESULT hr;
    DWORD   dwNumClasses;

    hr = GetDynamicTerminalClasses(&dwNumClasses,
                                   NULL);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumerateDynamicTerminalClasses - "
            "can't get number of terminal classes - exit 0x%08x", hr));

        return hr;
    }

    //
    // Allocate an array of GUIDs.
    //

    IID * pClassGuids = new IID[dwNumClasses];

    if ( pClassGuids == NULL )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumerateDynamicTerminalClasses - "
            "can't allocate class guids array - exit E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    //
    // Fill in the array with actual pointers.
    // 

    hr = GetDynamicTerminalClasses(&dwNumClasses,
                                   pClassGuids);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumerateDynamicTerminalClasses - "
            "can't get terminal class guids - exit 0x%08x", hr));

        delete [] pClassGuids;

        return hr;
    }


    //
    // Create an enumerator to hold this array, and have it take ownership
    // so that it will delete the array when it is released. The CSafeComEnum
    // can handle zero-length arrays. This Fn also checks the return arg.
    //

    //
    // Create the enumerator object.
    //

    typedef CSafeComEnum<IEnumTerminalClass,
                     &IID_IEnumTerminalClass,
                     GUID, _Copy<GUID> > CEnumerator;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = CComObject<CEnumerator>::CreateInstance(&pEnum);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumerateDynamicTerminalClasses - "
            "can't create enumerator - exit 0x%08x", hr));

        delete [] pClassGuids;

        return hr;
    }

    //
    // Query for the desired interface.
    //

    hr = pEnum->_InternalQueryInterface(IID_IEnumTerminalClass, 
                                        (void**) ppTerminalClassEnumerator);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumerateDynamicTerminalClasses - "
            "can't get enumerator interface - exit 0x%08x", hr));

        delete pEnum;
        delete [] pClassGuids;
        
        return hr;
    }

    //
    // Init the enumerator object.
    //

    hr = pEnum->Init(pClassGuids,
                     pClassGuids + dwNumClasses,
                     NULL,
                     AtlFlagTakeOwnership); 

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPAddress::EnumerateDynamicTerminalClasses - "
            "can't init enumerator - exit 0x%08x", hr));

        (*ppTerminalClassEnumerator)->Release();
        delete [] pClassGuids;
        
        return hr;
    }

    LOG((MSP_TRACE, "CMSPAddress::EnumerateDynamicTerminalClasses - exit S_OK"));

    return S_OK;
}

HRESULT CMSPAddress::ReceiveTSPAddressData(
        IN      PBYTE               pBuffer,
        IN      DWORD               dwSize
        )
/*++

Routine Description:

  Base class receive TSP address data method... does nothing in base class.
  Implemented so that MSP's that only communicate per-call don't have
  to override it.

Arguments:

  
Return Value:

S_OK

--*/

{
    LOG((MSP_TRACE, "CMSPAddress::ReceiveTSPAddressData - enter"));
    LOG((MSP_TRACE, "CMSPAddress::ReceiveTSPAddressData - exit S_OK"));

    return S_OK;
}

HRESULT CMSPAddress::PnpNotifHandler(
        IN      BOOL                bDeviceArrival
        )
{
    LOG((MSP_TRACE, "CMSPAddress::PnpNotifHandler - enter"));

    if (bDeviceArrival)
        LOG((MSP_TRACE, "CMSPAddress::PnpNotifHandler - device arrival"));
    else
        LOG((MSP_TRACE, "CMSPAddress::PnpNotifHandler - device removal"));

    // lock the terminal related data. This is a auto lock that will unlock
    // when the function returns.
    CLock lock(m_TerminalDataLock);

    // if the terminal list hasn't been built yet, we can skip doing anything
    if (m_fTerminalsUpToDate)
    {
        HRESULT hr = UpdateTerminalListForPnp( bDeviceArrival );

        if (FAILED(hr))
        {
            LOG((MSP_ERROR,
                "CMSPAddress::PnpNotifHandler - "
                "UpdateTerminalList failed - returning 0x%08x", hr));

            return hr;
        }
    }

    LOG((MSP_TRACE, "CMSPAddress::PnpNotifHandler - exit S_OK"));

    return S_OK;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mspbase\dtevntsk.cpp ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    DTEvntSk.cpp 

Abstract:

    This module contains implementation of CPTEventSink.

Author:
    
    vlade Nov 1999

--*/

#include "precomp.h"
#pragma hdrstop


//
// a helper function that releases the resources allocated inside event info
//

HRESULT FreeEventInfo( MSP_EVENT_INFO * pEvent )
{

    LOG((MSP_TRACE, "FreeEventInfo -  enter"));

    switch ( pEvent->Event )
    {

        case ME_ADDRESS_EVENT:

            if (NULL != pEvent->MSP_ADDRESS_EVENT_INFO.pTerminal)
            {
                (pEvent->MSP_ADDRESS_EVENT_INFO.pTerminal)->Release();
            }

            break;
    
        case ME_CALL_EVENT:

            if (NULL != pEvent->MSP_CALL_EVENT_INFO.pTerminal)
            {
                (pEvent->MSP_CALL_EVENT_INFO.pTerminal)->Release();
            }
    
            if (NULL != pEvent->MSP_CALL_EVENT_INFO.pStream)
            {
                (pEvent->MSP_CALL_EVENT_INFO.pStream)->Release();
            }
    
            break;
    
        case ME_TSP_DATA:

            break;

        case ME_PRIVATE_EVENT:
    
            if ( NULL != pEvent->MSP_PRIVATE_EVENT_INFO.pEvent )
            {
                (pEvent->MSP_PRIVATE_EVENT_INFO.pEvent)->Release();
            }

            break;

        case ME_FILE_TERMINAL_EVENT:

            if( NULL != pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pParentFileTerminal)
            {
                (pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pParentFileTerminal)->Release();
                pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pParentFileTerminal = NULL;
            }

            if( NULL != pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pFileTrack )
            {
                (pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pFileTrack)->Release();
                pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pFileTrack = NULL;
            }

            break;

        case ME_ASR_TERMINAL_EVENT:

            if( NULL != pEvent->MSP_ASR_TERMINAL_EVENT_INFO.pASRTerminal)
            {
                (pEvent->MSP_ASR_TERMINAL_EVENT_INFO.pASRTerminal)->Release();
            }

            break;

        case ME_TTS_TERMINAL_EVENT:

            if( NULL != pEvent->MSP_TTS_TERMINAL_EVENT_INFO.pTTSTerminal)
            {
                (pEvent->MSP_TTS_TERMINAL_EVENT_INFO.pTTSTerminal)->Release();
            }

            break;

        case ME_TONE_TERMINAL_EVENT:

            if( NULL != pEvent->MSP_TONE_TERMINAL_EVENT_INFO.pToneTerminal)
            {
                (pEvent->MSP_TONE_TERMINAL_EVENT_INFO.pToneTerminal)->Release();
            }

            break;

        default:

            break;
    }


    LOG((MSP_TRACE, "FreeEventInfo -  finished"));

    return S_OK;
}


CPTEventSink::CPTEventSink() :
    m_pMSPStream(NULL)
{
    LOG((MSP_TRACE, "CPTEventSink::CPTEventSink enter"));
    LOG((MSP_TRACE, "CPTEventSink::CPTEventSink exit"));
}

CPTEventSink::~CPTEventSink()
{
    LOG((MSP_TRACE, "CPTEventSink::~CPTEventSink enter"));
    LOG((MSP_TRACE, "CPTEventSink::~CPTEventSink exit"));
};

// --- ITPluggableTerminalEventSnk ---

/*++
FireEvent

Parameters:

    IN MSPEVENTITEM * pEventItem pointer to the structure that describes the 
    event. all the pointers contained in the structure must be addreffed by 
    the caller, and then released by the caller if FireEvent fails

    FireEvent makes a (shallow) copy of the structure, so the caller can 
    delete the structure when the function returns


Returns:
    S_OK - every thing was OK
    E_FAIL & other - something was wrong

Description:
  This method is called by the dynamic terminals to 
  signal a new event
--*/

STDMETHODIMP CPTEventSink::FireEvent(
    IN const MSP_EVENT_INFO * pEventInfo
    )
{
    LOG((MSP_TRACE, "CPTEventSink::FireEvent enter"));


    //
    // make sure we got a good mspeventitem structure
    //

    if( MSPB_IsBadWritePtr( (void*)pEventInfo, sizeof( MSP_EVENT_INFO )))
    {
        LOG((MSP_ERROR, "CPTEventSink::FireEvent -"
            "pEventItem is bad, returns E_POINTER"));
        return E_POINTER;
    }


    //
    // Create an MSPEVENTITEM
    //

    MSPEVENTITEM *pEventItem = AllocateEventItem();

    if (NULL == pEventItem)
    {
        LOG((MSP_ERROR, "CPTEventSink::FireEvent -"
            "failed to create MSPEVENTITEM. returning E_OUTOFMEMORY "));

        return E_OUTOFMEMORY;
    }


    //
    // make a shallow copy of the structure
    //

    pEventItem->MSPEventInfo = *pEventInfo;


    Lock();

    HRESULT hr = E_FAIL;

    if (NULL != m_pMSPStream)
    {
    
        //
        // nicely ask stream to process our event
        //

        LOG((MSP_TRACE, "CPTEventSink::FireEvent - passing event [%p] to the stream", pEventItem));


        AsyncEventStruct *pAsyncEvent = new AsyncEventStruct;

        if (NULL == pAsyncEvent)
        {
            LOG((MSP_ERROR, 
                "CPTEventSink::FireEvent - failed to allocate memory for AsyncEventStruct"));

            hr = E_OUTOFMEMORY;
        }
        else
        {

            //
            // stuff the structure with the addref'fed stream on which the 
            // event will be fired and the actual event to fire
            //

            ULONG ulRC =  m_pMSPStream->AddRef();

            if (1 == ulRC)
            {
                //
                // this is a workaround for a timing window: the stream could 
                // be in its desctructor while we are doing the addref. this 
                // condition is very-vary rare, as the timing window is very
                // narrow.
                //
                // the good thing is that stream destructor will not finish 
                // while we are here, because it will try to get event sink's 
                // critical section in its call to SetSinkStream() to set our 
                // stream pointer to NULL.
                // 
                // so if we detect that the refcount after our addref is 1, 
                // that would mean that the stream is in (or is about to start
                // executing its desctructor). in which case we should do 
                // nothing.
                //
                // cleanup and return a failure.
                //

                Unlock();

                LOG((MSP_ERROR, 
                    "CPTEventSink::FireEvent - stream is going away"));

                delete pAsyncEvent;
                pAsyncEvent = NULL;

                FreeEventItem(pEventItem);
                pEventItem = NULL;

                return TAPI_E_INVALIDSTREAM;
            }



            pAsyncEvent->pMSPStream = m_pMSPStream;

            pAsyncEvent->pEventItem = pEventItem;


            //
            // now use thread pool api to schedule the event for future async 
            // processing
            //

            BOOL bQueueSuccess = QueueUserWorkItem(
                CPTEventSink::FireEventCallBack,
                (void *)pAsyncEvent,
                WT_EXECUTEDEFAULT);

            if (!bQueueSuccess)
            {
                
                DWORD dwLastError = GetLastError();

                LOG((MSP_ERROR, 
                    "CPTEventSink::FireEvent - QueueUserWorkItem failed. LastError = %ld", dwLastError));


                //
                // undo the addref we did on the stream object. the event will 
                // be freed later
                //

                m_pMSPStream->Release();


                //
                // the event was not enqueued. delete now.
                //

                delete pAsyncEvent;
                pAsyncEvent = NULL;


                //
                // map the code and bail out
                //

                hr = HRESULT_FROM_WIN32(dwLastError);
            }
            else
            {
                
                //
                // log the event we have submitted, so we can match submission 
                // with processing from the log
                //

                LOG((MSP_TRACE,
                    "CPTEventSink::FireEvent - submitted event [%p]", pAsyncEvent));

                hr = S_OK;

            } // async event structure submitted

        } // async event structure allocated 

    } // msp stream exists
    else
    {
        hr = TAPI_E_INVALIDSTREAM;

        LOG((MSP_ERROR, 
            "CPTEventSink::FireEvent - stream pointer is NULL"));
    }


    Unlock();


    //
    // if we don't have a stream, or if the stream refused to process the 
    // event, cleanup and return an error
    //

    if (FAILED(hr))
    {

        LOG((MSP_ERROR, "CPTEventSink::FireEvent - call to HandleStreamEvent failed. hr = 0x%08x", hr));

        FreeEventItem(pEventItem);

        return hr;
    }


    LOG((MSP_TRACE, "CPTEventSink::FireEvent - exit"));

    return S_OK;
}




/////////////////////////////////////////////////////////////////////////////
//
// CPTEventSink::FireEventCallBack
//
// the callback function that is called by thread pool api to asyncronously to
// process events fired by the terminals. 
// 
// the argument should point to the structure that contains the pointer to the 
// stream on which to fire the event and the pointer to the event to fire.
//
// the dll is guaranteed to not go away, since the structure passed in holds a 
// reference to the stream object on which to process the event
//

// static
DWORD WINAPI CPTEventSink::FireEventCallBack(LPVOID lpParameter)
{
    LOG((MSP_TRACE, "CPTEventSink::FireEventCallBack - enter. Argument [%p]", 
        lpParameter));


    AsyncEventStruct *pEventStruct = (AsyncEventStruct *)lpParameter;

    
    //
    // make sure the structure is valid
    //

    if (IsBadReadPtr(pEventStruct, sizeof(AsyncEventStruct)))
    {

        //
        // complain and exit. should not happen, unless there is a problem in 
        // thread pool api or memory corruption
        //

        LOG((MSP_ERROR, 
            "CPTEventSink::FireEventCallBack - Argument does not point to a valid AsyncEventStruct"));

        return FALSE;
    }


    BOOL bBadDataPassedIn = FALSE;

    //
    // the structure contains an addref'fed stream pointer. extract it and 
    // make sure it is still valid
    //

    CMSPStream *pMSPStream = pEventStruct->pMSPStream;

    if (IsBadReadPtr(pMSPStream, sizeof(CMSPStream)))
    {

        //
        // should not happen, unless there is a problem in thread pool api or 
        // memory corruption, or someone is over-releasing the stream object
        //

        LOG((MSP_ERROR, 
            "CPTEventSink::FireEventCallBack - stream pointer is bad"));

        pMSPStream = NULL;

        bBadDataPassedIn = TRUE;
    }



    //
    // the structure contains the event that we are tryint to fire.
    // make sure the event we are about to fire is good.
    //

    MSPEVENTITEM *pEventItem = pEventStruct->pEventItem;

    if (IsBadReadPtr(pEventItem, sizeof(MSPEVENTITEM)))
    {

        //
        // should not happen, unless there is a problem in thread pool api or 
        // memory corruption, or we didn't check success of allocation when we 
        // created the event (which we did!)
        //

        LOG((MSP_ERROR, 
            "CPTEventSink::FireEventCallBack - event is bad"));

        pEventItem = NULL;

        bBadDataPassedIn = TRUE;
    }


    //
    // bad stream or event structure?
    //

    if (bBadDataPassedIn)
    {

        //
        // release the event if it was good.
        //

        if ( NULL != pEventItem)
        {

            FreeEventItem(pEventItem);
            pEventItem = NULL;
        }


        //
        // release the stream if it was good.
        //

        if (NULL != pMSPStream)
        {
            pMSPStream->Release();
            pMSPStream = NULL;
        }


        //
        // no need to keep the event structure itself, delete it
        //

        delete pEventStruct;
        pEventStruct = NULL;

        return FALSE;
    }

   
    //
    // we have both the stream and the event, fire the event on the stream
    //

    HRESULT hr = pMSPStream->HandleSinkEvent(pEventItem);


    //
    // if HandleSinkEvent succeeded, pEventItem will be released by whoever 
    // will handle the event, otherwise we need to release eventitem here
    //

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "CPTEventSink::FireEventCallBack - HandleSinkEvent not called or failed. hr = %lx",
            hr));

        //
        // need to free all the resources held by event info
        //

        FreeEventInfo(&(pEventItem->MSPEventInfo));

        FreeEventItem(pEventItem);
        pEventItem = NULL;
    }


    //
    // release the stream pointer that is a part of the structure -- 
    // we don't want any reference leaks.
    //

    //
    // note that the dll may go away at this point (if we are holding the last 
    // reference to the last object from the dll)
    //

    pMSPStream->Release();
    pMSPStream = NULL;


    //
    // at this point we release the stream pointer and either submitted the 
    // event or freed it. we no longer need the event structure.
    //

    delete pEventStruct;
    pEventStruct = NULL;

    LOG((MSP_(hr), "CPTEventSink::FireEventCallBack - exit. hr = %lx", hr));
    
    return SUCCEEDED(hr);
}


/*++

SetSinkStream

Parameters:

    CMSPStream *pStream 
    
      the stream that will be processing our events, or NULL when no stream is 
      available to process our events

Returns:
    S_OK - 

Description:

    this method is called by the stream that is going to process our events

    when the stream is going away and is no longer available to process our 
    messages, it will call SetSinkStream with NULL.

--*/

HRESULT CPTEventSink::SetSinkStream( CMSPStream *pStream )
{
    LOG((MSP_TRACE, "CPTEventSink::SetSinkStream - enter"));


    Lock();


    LOG((MSP_TRACE, 
        "CPTEventSink::SetSinkStream - replacing sink stream [%p] with [%p]", 
        m_pMSPStream, pStream));


    //
    // we don't keep a reference to the stream -- the stream keeps a reference 
    // to us. when the stream goes away, it will let us know.
    //

    m_pMSPStream = pStream;

    Unlock();


    LOG((MSP_TRACE, "CPTEventSink::SetSinkStream - exit"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mspbase\mspstrm.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    mspstrm.cpp

Abstract:

    This module contains implementation of CMSPStream. The object represents
    one stream in the filter graph.

--*/

#include "precomp.h"
#pragma hdrstop

/////////////////////////////////////////////////////////////////////////////
// CMSPStream
/////////////////////////////////////////////////////////////////////////////

CMSPStream::CMSPStream()
    : m_dwState(STRM_INITIAL),
      m_dwMediaType(0),
      m_pFTM(NULL),
      m_hAddress(NULL),
      m_pMSPCall(NULL),
      m_pIGraphBuilder(NULL),
      m_pIMediaControl(NULL),
      m_pPTEventSink( NULL ),
      m_lMyPersonalRefcount(0),
      m_bFirstAddRef(TRUE)
{
    LOG((MSP_TRACE, "CMSPStream::CMSPStream - enter"));
    LOG((MSP_TRACE, "CMSPStream::CMSPStream - exit"));
}

CMSPStream::~CMSPStream()
{
    LOG((MSP_TRACE, "CMSPStream::~CMSPStream - enter"));
    
    ReleaseSink();

    LOG((MSP_TRACE, "CMSPStream::~CMSPStream - exit"));
}

STDMETHODIMP CMSPStream::get_MediaType(
    OUT     long *                  plTapiMediaType
    )
{
    LOG((MSP_TRACE, "CMSPStream::get_MediaType - enter"));

    if (MSPB_IsBadWritePtr(plTapiMediaType, sizeof (long *)))
    {
        LOG((MSP_ERROR, "CMSPStream::get_MediaType - exit E_POINTER"));

        return E_POINTER;
    }

    
    CLock lock(m_lock);

    *plTapiMediaType = m_dwMediaType;

    LOG((MSP_TRACE, "CMSPStream::get_MediaType - exit S_OK"));

    return S_OK;
}

STDMETHODIMP CMSPStream::get_Direction(
    OUT     TERMINAL_DIRECTION *    pTerminalDirection
    )
{
    LOG((MSP_TRACE, "CMSPStream::get_Direction - enter"));

    if (MSPB_IsBadWritePtr(pTerminalDirection, sizeof (TERMINAL_DIRECTION *)))
    {
        LOG((MSP_ERROR, "CMSPStream::get_Direction - exit E_POINTER"));

        return E_POINTER;
    }


    CLock lock(m_lock);


    *pTerminalDirection = m_Direction;
    
    LOG((MSP_TRACE, "CMSPStream::get_Direction - exit S_OK"));
    
    return S_OK;
}

STDMETHODIMP CMSPStream::SelectTerminal(
    IN      ITTerminal *            pTerminal
    )
/*++

Routine Description:

Arguments:
    

Return Value:

S_OK

E_POINTER
E_OUTOFMEMORY
TAPI_E_MAXTERMINALS
TAPI_E_INVALIDTERMINAL

--*/
{
    LOG((MSP_TRACE, "CMSPStream::SelectTerminal - enter"));

    //
    // Check parameter.
    //

    if ( IsBadReadPtr(pTerminal, sizeof(ITTerminal) ) )
    {
        LOG((MSP_ERROR, "CMSPStream::SelectTerminal - exit E_POINTER"));

        return E_POINTER;
    }

    HRESULT hr;
    ITTerminalControl *pTerminalControl;

    //
    // Get the private interface from this terminal.
    //

    hr = pTerminal->QueryInterface(IID_ITTerminalControl, 
                                   (void **) &pTerminalControl);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMSPStream::SelectTerminal - "
            "can't get ITTerminalControl - exit TAPI_E_INVALIDTERMINAL"));

        return TAPI_E_INVALIDTERMINAL;
    }

    //
    // Get the address handle and release the private interface.
    //

    MSP_HANDLE hAddress;
    hr = pTerminalControl->get_AddressHandle(&hAddress);

    pTerminalControl->Release();

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMSPStream::SelectTerminal - "
            "can't get address handle - exit TAPI_E_INVALIDTERMINAL"));

        return TAPI_E_INVALIDTERMINAL;
    }

    //
    // Find out if the terminal belongs to this address. Reject it if it belongs
    // to another address, but accept it if it is an application-provided terminal
    // (NULL address handle).
    //

    if ( ( hAddress != NULL ) && ( hAddress != (MSP_HANDLE) m_hAddress ) )
    {
        LOG((MSP_ERROR, "CMSPStream::SelectTerminal - "
            "terminal from another address - exit TAPI_E_INVALIDTERMINAL"));

        return TAPI_E_INVALIDTERMINAL;
    }


    //
    // Get the type of the terminal
    //

    TERMINAL_TYPE nTerminalType;
    hr = pTerminal->get_TerminalType( &nTerminalType );

    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPStream::SelectTerminal "
            "get_TerminalType failed, exit E_UNEXPECTED"));

        return E_UNEXPECTED;
    }


    //
    // Find out if the terminal is already in our list.
    //

    CLock lock(m_lock);
    
    if (m_Terminals.Find(pTerminal) >= 0)
    {
        LOG((MSP_ERROR, "CMSPStream::SelectTerminal - "
            "terminal already selected - exit TAPI_E_INVALIDTERMINAL"));

        return TAPI_E_INVALIDTERMINAL;
    }
    
    //
    // Add the new terminal into our list and addref it.
    //

    if (!m_Terminals.Add(pTerminal))
    {
        LOG((MSP_ERROR, "CMSPStream::SelectTerminal - "
            "exit E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    pTerminal->AddRef();


    if( TT_DYNAMIC == nTerminalType)
    {
        hr = RegisterPluggableTerminalEventSink( pTerminal );
        if( FAILED(hr) )
        {
            LOG((MSP_TRACE, "CMSPStream::SelectTerminal - "
                "something wrong in RegisterPluggableTerminalEventSink. hr = %lx", hr));

            m_Terminals.Remove(pTerminal);
            pTerminal->Release();

            return hr;        
        }
    }

    LOG((MSP_TRACE, "CMSPStream::SelectTerminal - exit S_OK"));
    
    return S_OK;
}

STDMETHODIMP CMSPStream::UnselectTerminal(
    IN     ITTerminal *             pTerminal
    )
{
    LOG((MSP_TRACE, "CMSPStream::UnselectTerminal - enter"));

    //
    // find out if the terminal is in our list.
    //

    CLock lock(m_lock);
    int index;
    
    if ((index = m_Terminals.Find(pTerminal)) < 0)
    {
        LOG((MSP_ERROR, "CMSPStream::UnselectTerminal - "
            "exit TAPI_E_INVALIDTERMINAL"));
    
        return TAPI_E_INVALIDTERMINAL;
    }

    //
    // Unregister the PTEventSink object
    //

    HRESULT hr = E_FAIL; 
    hr = UnregisterPluggableTerminalEventSink( pTerminal );

    if( FAILED(hr) )
    {
        LOG((MSP_TRACE, "CMSPStream::UnselectTerminal - "
            "something wrong in UnregisterPluggableTerminalEventSink"));
    }
    
    //
    // remove the terminal from our list and release it.
    //

    if (!m_Terminals.RemoveAt(index))
    {
        LOG((MSP_ERROR, "CMSPStream::UnselectTerminal - "
            "exit E_UNEXPECTED"));
    
        return E_UNEXPECTED;
    }

    pTerminal->Release();

    LOG((MSP_TRACE, "CMSPStream::UnselectTerminal - exit S_OK"));

    return S_OK;
}

STDMETHODIMP CMSPStream::EnumerateTerminals(
    OUT     IEnumTerminal **        ppEnumTerminal
    )
{
    LOG((MSP_TRACE, 
        "EnumerateTerminals entered. ppEnumTerminal:%x", ppEnumTerminal));

    if (MSPB_IsBadWritePtr(ppEnumTerminal, sizeof(VOID *)))
    {
        LOG((MSP_ERROR, "ppEnumTerminal is a bad pointer"));
        return E_POINTER;
    }

    // acquire the lock before accessing the Terminal object list.
    CLock lock(m_lock);

    if (m_Terminals.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CMSPStream::EnumerateTerminals - "
            "stream appears to have been shut down - exit E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    typedef _CopyInterface<ITTerminal> CCopy;
    typedef CSafeComEnum<IEnumTerminal, &IID_IEnumTerminal, 
                ITTerminal *, CCopy> CEnumerator;

    HRESULT hr;

    CMSPComObject<CEnumerator> *pEnum = NULL;

    hr = CMSPComObject<CEnumerator>::CreateInstance(&pEnum);
    if (pEnum == NULL)
    {
        LOG((MSP_ERROR, "Could not create enumerator object, %x", hr));
        return hr;
    }

    // query for the IID_IEnumTerminal i/f
    hr = pEnum->_InternalQueryInterface(IID_IEnumTerminal, (void**)ppEnumTerminal);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "query enum interface failed, %x", hr));
        delete pEnum;
        return hr;
    }

    // The CSafeComEnum can handle zero-sized array.
    hr = pEnum->Init(
        m_Terminals.GetData(),                        // the begin itor
        m_Terminals.GetData() + m_Terminals.GetSize(),  // the end itor, 
        NULL,                                       // IUnknown
        AtlFlagCopy                                 // copy the data.
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "init enumerator object failed, %x", hr));
        (*ppEnumTerminal)->Release();
        return hr;
    }

    LOG((MSP_TRACE, "CMSPStream::EnumerateTerminals - exit S_OK"));

    return hr;
}

STDMETHODIMP CMSPStream::get_Terminals(
    OUT     VARIANT *               pVariant
    )
{
    LOG((MSP_TRACE, "CMSPStream::get_Terminals - enter"));

    //
    // Check parameters.
    //

    if ( MSPB_IsBadWritePtr(pVariant, sizeof(VARIANT) ) )
    {
        LOG((MSP_ERROR, "CMSPStream::get_Terminals - "
            "bad pointer argument - exit E_POINTER"));

        return E_POINTER;
    }

    //
    // See if this stream has been shut down. Acquire the lock before accessing
    // the terminal object list.
    //

    CLock lock(m_lock);

    if (m_Terminals.GetData() == NULL)
    {
        LOG((MSP_ERROR, "CMSPStream::get_Terminals - "
            "stream appears to have been shut down - exit E_UNEXPECTED"));

        return E_UNEXPECTED;
    }


    //
    // create the collection object - see mspcoll.h
    //

    HRESULT hr;
    typedef CTapiIfCollection< ITTerminal * > TerminalCollection;
    CComObject<TerminalCollection> * pCollection;
    hr = CComObject<TerminalCollection>::CreateInstance( &pCollection );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPStream::get_Terminals - "
            "can't create collection - exit 0x%08x", hr));

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;

    hr = pCollection->_InternalQueryInterface(IID_IDispatch,
                                              (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPStream::get_Terminals - "
            "QI for IDispatch on collection failed - exit 0x%08x", hr));

        delete pCollection;

        return hr;
    }

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one.
    //

    hr = pCollection->Initialize( m_Terminals.GetSize(),
                                  m_Terminals.GetData(),
                                  m_Terminals.GetData() + m_Terminals.GetSize() );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CMSPStream::get_Terminals - "
            "Initialize on collection failed - exit 0x%08x", hr));
        
        pDispatch->Release();
        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    LOG((MSP_TRACE, "CMSPStream::get_Terminals - "
        "placing IDispatch value %08x in variant", pDispatch));

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((MSP_TRACE, "CMSPStream::get_Terminals - exit S_OK"));
 
    return S_OK;
}

STDMETHODIMP CMSPStream::StartStream()
{
    LOG((MSP_TRACE, "CMSPStream - RUNNING GRAPH"));

    HRESULT hr = m_pIMediaControl->Run();
    
    if(FAILED(hr))
    {
        LOG((MSP_ERROR, "graph doesn't run, %x", hr));
    }
    return hr;
}

STDMETHODIMP CMSPStream::PauseStream()
{
    LOG((MSP_TRACE, "CMSPStream - PAUSING GRAPH"));

    HRESULT hr = m_pIMediaControl->Pause();
    
    if(FAILED(hr))
    {
        LOG((MSP_ERROR, "graph doesn't pause, %x", hr));
    }
    return hr;
}

STDMETHODIMP CMSPStream::StopStream()
{
    LOG((MSP_TRACE, "CMSPStream - STOPPING GRAPH"));

    HRESULT hr = m_pIMediaControl->Stop();
    
    if(FAILED(hr))
    {
        LOG((MSP_ERROR, "graph doesn't stop, %x", hr));
    }
    return hr;
}

// methods called by the MSPCall object.
HRESULT CMSPStream::Init(
    IN     HANDLE                   hAddress,
    IN     CMSPCallBase *           pMSPCall,
    IN     IMediaEvent *            pGraph,
    IN     DWORD                    dwMediaType,
    IN     TERMINAL_DIRECTION       Direction
    )
{
    LOG((MSP_TRACE, "CMSPStream::Init - enter"));

    
    CLock lock(m_lock);


    // This method is called only once when the object is created. No other
    // method will be called until this function succeeds. No need to lock.
    _ASSERTE(m_hAddress == NULL);

    // initialize the terminal array so that the array is not NULL. Used for
    // generating an empty enumerator if no terminal is selected.
    if (!m_Terminals.Grow())
    {
        LOG((MSP_ERROR, "CMSPStream::Init - exit E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }
    
    HRESULT hr;
    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pFTM);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "create marshaler failed, %x", hr));
        return hr;
    }

    // Get the media control interface on the graph.
    IMediaControl *pMC;
    hr = pGraph->QueryInterface(IID_IMediaControl, (void **) &pMC);
    if(FAILED(hr))
    {
        LOG((MSP_ERROR, "get IMediaControl interface, %x", hr));
        return hr;
    }

    // Get the graph builder interface on the graph.
    IGraphBuilder *pGB;
    hr = pGraph->QueryInterface(IID_IGraphBuilder, (void **) &pGB);
    if(FAILED(hr))
    {
        LOG((MSP_ERROR, "get IGraphBuilder interface, %x", hr));
        pMC->Release();
        return hr;
    }

    m_hAddress          = hAddress;

    m_pMSPCall          = pMSPCall;
    m_pMSPCall->MSPCallAddRef();

    m_pIMediaControl    = pMC;
    // no addref because QI addrefs for us above
    
    m_pIGraphBuilder    = pGB;
    // no addref because QI addrefs for us above

    m_dwMediaType       = dwMediaType;
    m_Direction         = Direction;

    LOG((MSP_TRACE, "CMSPStream::Init - exit S_OK"));

    return S_OK;
}

HRESULT CMSPStream::ShutDown()
{
    LOG((MSP_TRACE, "CMSPStream::Shutdown - enter"));

    CLock lock(m_lock);

    //
    // We are shut down, so the call is now NULL.
    //

    m_pMSPCall->MSPCallRelease();
    m_pMSPCall = NULL;

    //
    // Unselect all the terminals. Rather than just removing all the
    // terminals, we call UnselectTerminal on each one to give the derived
    // class a chance to do whatever else it needs to do when a terminal
    // is unselected.
    //
    // We walk the list in reverse order because the list shrinks with
    // each iteration (see msputils.h).
    //

    for ( int i = m_Terminals.GetSize() - 1; i >= 0; i-- )
    {
        UnselectTerminal(m_Terminals[i]);
    }
 
    //
    // At this point the derive class should have removed and released
    // all of the terminals from the list. If that's not the case, the
    // derived class is buggy.
    //

    _ASSERTE( m_Terminals.GetSize() == 0 );


    //
    // no longer need the sink
    //

    ReleaseSink();

    LOG((MSP_TRACE, "CMSPStream::Shutdown - exit S_OK"));

    return S_OK;
}

void CMSPStream::FinalRelease()
{
    LOG((MSP_TRACE, "CMSPStream::FinalRelease - enter"));

    // release the two interface pointers to the graph.
    if (m_pIMediaControl)
    {
        m_pIMediaControl->Release();
    }

    if (m_pIGraphBuilder)
    {
        m_pIGraphBuilder->Release();
    }

    if (m_pFTM)
    {
        m_pFTM->Release();
    }

    LOG((MSP_TRACE, "CMSPStream::FinalRelease - exit"));
}

HRESULT CMSPStream::HandleTSPData(
    IN     BYTE *                   pData,
    IN     DWORD                    dwSize
    )
{
    LOG((MSP_TRACE, "CMSPStream::HandleTSPData - enter"));
    LOG((MSP_TRACE, "CMSPStream::HandleTSPData - exit S_OK"));

    return S_OK;
}

HRESULT CMSPStream::ProcessGraphEvent(
    IN  long lEventCode,
    IN  LONG_PTR lParam1,
    IN  LONG_PTR lParam2
    )
{
    LOG((MSP_TRACE, "CMSPStream::ProcessGraphEvent - enter"));
    LOG((MSP_TRACE, "CMSPStream::ProcessGraphEvent - exit S_OK"));

    return S_OK;
}

/*++
RegisterPluggableTerminalEventSink

Parameters:
 The terminla interface

Description;
 Is called by SelectTerminal if is a dynamic terminal
--*/
HRESULT CMSPStream::RegisterPluggableTerminalEventSink(
    IN  ITTerminal* pTerminal
    )
{
    LOG((MSP_TRACE, "CMSPStream::RegisterPluggableTerminalEventSink - enter"));

    //
    // Validates arguments
    //

    if( IsBadReadPtr( pTerminal, sizeof( ITTerminal) ))
    {
        LOG((MSP_ERROR, "CMSPStream::RegisterPluggableTerminalEventSink "
            "pTerminal invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Get the type of the terminal
    //

    TERMINAL_TYPE nTerminalType;
    HRESULT hr = E_FAIL;

    hr = pTerminal->get_TerminalType( &nTerminalType );

    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPStream::RegisterPluggableTerminalEventSink "
            "get_TerminalType failed, exit E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    //
    // The terminal should by a dynamic terminal
    //

    if( TT_DYNAMIC != nTerminalType)
    {
        LOG((MSP_ERROR, "CMSPStream::RegisterPluggableTerminalEventSink "
            "terminal is not dynamic, exit E_INVALIDARG"));
        return E_INVALIDARG;
    }

    
    CLock lock(m_lock);


    //
    // Create the sink if we don't have one already
    //

    if(NULL == m_pPTEventSink)
    {
        //Create a PTEventSink object
        CComObject<CPTEventSink>* pPTEventSink;
        hr = CComObject<CPTEventSink>::CreateInstance(&pPTEventSink);

        if( FAILED(hr) )
        {

            LOG((MSP_ERROR, "CMSPStream::RegisterPluggableTerminalEventSink "
                "CreateInstance failed, returns E_OUTOFMEMORY"));
            return E_OUTOFMEMORY;
        }

        
        // tell sink that we are ready to be processing its events

        hr = pPTEventSink->SetSinkStream(this);

        if (FAILED(hr))
        {
            LOG((MSP_ERROR, "CMSPStream::RegisterPluggableTerminalEventSink "
                "event sink refused to accept sink stream. hr = %lx", hr));
            
            delete pPTEventSink;

            return hr;
        }


        // Get ITPluggableTerminalEventSink interface from the sink

        hr = pPTEventSink->QueryInterface(IID_ITPluggableTerminalEventSink, (void**)&m_pPTEventSink);

        if( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CMSPStream::RegisterPluggableTerminalEventSink "
                "QI for ITPluggableTerminalEventSink failed, returns E_UNEXPECTED"));


            //
            // ok, the sink is no good. get rid of it.
            //

            pPTEventSink->SetSinkStream(NULL);
            delete pPTEventSink;
            pPTEventSink = NULL;


            //
            // sink does not expose IID_ITPluggableTerminalEventSink interface? 
            // something is seriously wrong
            //

            return E_UNEXPECTED;
        }


    }

    
    // Get the ITDTEventHandler interface
    ITPluggableTerminalEventSinkRegistration*   pEventRegistration = NULL;

    hr = pTerminal->QueryInterface( IID_ITPluggableTerminalEventSinkRegistration, 
        (void**)&pEventRegistration
        );

    if( FAILED(hr) )
    {
        // The dynamic terminal doesn't implement ITPluggableTerminalEventSinkRegistration
        // This is bad! We cannot use the new event stuff
        LOG((MSP_ERROR, "CMSPStream::RegisterPluggableTerminalEventSink "
           "QI for ITPluggableTerminalEventSinkregistration failed, returns S_FALSE"));

        //
        // no need to keep the sink
        //

        ReleaseSink();

        return S_FALSE;
    }

    // pass the sink to the terminal
    hr = pEventRegistration->RegisterSink(
        m_pPTEventSink
        );


    // Clean up, anyway
    pEventRegistration->Release();

    if( FAILED(hr) )
    {

        LOG((MSP_ERROR, "CMSPStream::RegisterPluggableTerminalEventSink "
           "RegisterSink failed, returns E_FAIL"));


        //
        // no need to keep the sink
        //

        ReleaseSink();

        return E_FAIL;
    }

    LOG((MSP_TRACE, "CMSPStream::RegisterPluggableTerminalEventSink - exit S_OK"));
    return S_OK;
}

/*++
UnregisterPluggableTerminalEventSink

Parameters:
 The terminal interface

Description;
 Is called by UnselectTerminal if is a dynamic terminal
--*/
HRESULT CMSPStream::UnregisterPluggableTerminalEventSink(
    IN  ITTerminal* pTerminal
    )
{
    LOG((MSP_TRACE, "CMSPStream::UnregisterPluggableTerminalEventSink - enter"));

        //
    // Validates arguments
    //

    if( IsBadReadPtr( pTerminal, sizeof( ITTerminal) ))
    {
        LOG((MSP_ERROR, "CMSPStream::UnregisterPluggableTerminalEventSink "
            "pTerminal invalid, returns E_POINTER"));
        return E_POINTER;
    }

    //
    // Get the type of the terminal
    //

    TERMINAL_TYPE nTerminalType;
    HRESULT hr = E_FAIL;

    hr = pTerminal->get_TerminalType( &nTerminalType );

    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPStream::UnregisterPluggableTerminalEventSink "
            "get_TerminalType failed, exit E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    //
    // The terminal should be a dynamic terminal
    //

    if( TT_DYNAMIC != nTerminalType)
    {
        LOG((MSP_ERROR, "CMSPStream::UnregisterPluggableTerminalEventSink "
            "terminal is not dynamic, exit E_INVALIDARG"));
        return E_INVALIDARG;
    }


    CLock lock(m_lock);


    //
    // Have we an EventSink object
    //

    if(NULL == m_pPTEventSink)
    {
        LOG((MSP_TRACE, "CMSPStream::UnregisterPluggableTerminalEventSink - "
            "No EventSink - exit S_OK"));
        return S_OK;
    }

    //
    // Get the ITPluggableTemrinalEventSinkRegistration interface
    //
    ITPluggableTerminalEventSinkRegistration*   pEventRegistration = NULL;

    hr = pTerminal->QueryInterface( IID_ITPluggableTerminalEventSinkRegistration, 
        (void**)&pEventRegistration
        );

    if( FAILED(hr) )
    {
        //
        // The pluggable terminal doesn't implement ITPluggableTerminalEventSinkRegistration
        // This is bad!

        LOG((MSP_ERROR, "CMSPStream::UnregisterPluggableTerminalEventSink "
           "QI for ITPluggableTerminalEventSinkRegistration failed, returns E_NOTIMPL"));
        return E_NOTIMPL;
    }


    hr = pEventRegistration->UnregisterSink( );

    //
    // Clean up, anyway
    //

    pEventRegistration->Release();

    if( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CMSPStream::UnregisterPluggableTerminalEventSink "
           "UnregisterSink failed, returns E_FAIL"));
        return E_FAIL;
    }

    
    //
    // no longer need this sink
    //

    ReleaseSink();


    LOG((MSP_TRACE, "CMSPStream::UnregisterPluggableTerminalEventSink - exit S_OK"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
// CMSPStream::HandleSinkEvent
//
//
// CPTEventSink calls this method when it has an event for us to process
// HandleSinkEvent delegates event processing to the call, if we have one
//
//////////////////////////////////////////////////////////////////////////////

HRESULT CMSPStream::HandleSinkEvent(MSPEVENTITEM *pEventItem)
{
    LOG((MSP_TRACE, "CMSPStream::HandleSinkEvent - enter"));

    HRESULT hr = TAPI_E_CALLUNAVAIL;


    CLock lock(m_lock);


    if (NULL != m_pMSPCall)
    {

        //
        // we have a call. ask it to process the event
        //

        hr = m_pMSPCall->HandleStreamEvent(pEventItem);
    }
    else
    {

        LOG((MSP_WARN,
            "CMSPStream::HandleSinkEvent - there is no call to pass event to"));
    }


    LOG((MSP_(hr), "CMSPStream::HandleSinkEvent - exit hr = %lx", hr));
    
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
// CMSPStream::ReleaseSink
//
//
// this is a helper function that lets go of sink when it no longer needed
//
//////////////////////////////////////////////////////////////////////////////


HRESULT CMSPStream::ReleaseSink()
{
    LOG((MSP_TRACE, "CMSPStream::ReleaseSink - enter"));

    
    HRESULT hr = S_OK;


    CLock lock(m_lock);


    //
    // if sink is present, let it know that we will no longer be available to 
    // process its events and release it
    //

    if( m_pPTEventSink)
    {

        CPTEventSink *pSinkObject = static_cast<CPTEventSink *>(m_pPTEventSink);


        HRESULT hr = pSinkObject->SetSinkStream(NULL);

        if (FAILED(hr))
        {
            
            LOG((MSP_ERROR, 
                "CMSPStream::ReleaseSink - pSinkObject->SetSinkStream failed. hr - %lx", 
                hr));
        }


        m_pPTEventSink->Release();
        m_pPTEventSink = NULL;
    }

    LOG((MSP_(hr), "CMSPStream::ReleaseSink - exit. hr - %lx", hr));

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// CMSPStream::InternalAddRef
//
//
// this is a helper function that lets go of sink when it no longer needed
//
//////////////////////////////////////////////////////////////////////////////

ULONG CMSPStream::InternalAddRef()
{
    LOG((MSP_TRACE, "CMSPStream::InternalAddRef - enter"));

    m_lockRefCount.Lock();


    //
    // if the refcount is zero, return 1. this is the indication that the 
    // addref was called while the object is in its finalrelease or entering
    // destructor. Note that the only time this could happen is when event sink
    // attempts to send an event and addrefs the stream object after the stream
    // objects received its last Release() but before the stream object told 
    // the sink to stop using it (which takes place in stream's destructor).
    //
    // we also need to be able to tell if refcount was 0 because it's a new 
    // object or if the addref was called on an object whose refcount became
    // zero because of a release.
    //

    if ( !m_bFirstAddRef && (0 == m_lMyPersonalRefcount) )
    {

        //
        // the caller (event sink logic) should detect this condition (by the 
        // return value of 1) and not expect that the stream is going to 
        // continue to be valid.
        //

        LOG((MSP_WARN, "CMSPStream::InternalAddRef - current refcount is zero... finalrelease/destructor is probably in progress"));

        m_lockRefCount.Unlock();

        return 1;
    }


    //
    // we have made a transition from non-zero refcount to zero. set the 
    // flag, so that future addrefs know to return 1 in ths case when refcount 
    // is 0
    //

    m_bFirstAddRef = FALSE;


    //
    // since we are inside a lock, no need to use interlocked api
    //

    long lNewRefcountValue = (++m_lMyPersonalRefcount);


    m_lockRefCount.Unlock();

    LOG((MSP_TRACE, "CMSPStream::InternalAddRef - finish. %ld", lNewRefcountValue));

    return lNewRefcountValue;
}


ULONG CMSPStream::InternalRelease()
{
    LOG((MSP_TRACE, "CMSPStream::InternalRelease - enter"));

    m_lockRefCount.Lock();

    // try to catch over-releases
    _ASSERTE(m_lMyPersonalRefcount > 0);


    // we are inside a lock, no need to use interlocked api 
    long lNewRefcount = (--m_lMyPersonalRefcount);


    m_lockRefCount.Unlock();

    LOG((MSP_TRACE, "CMSPStream::InternalRelease - finish. %ld", lNewRefcount));

    return lNewRefcount;
}


// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mspbase\msplog.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    mspdebug.cpp

Abstract:

    This module contains the debugging support for the MSPs. 

--*/

#include "precomp.h"
#pragma hdrstop

#include <stdio.h>
#include <strsafe.h>


//
// no need to build this code if MSPLOG is not defined
//

#ifdef MSPLOG


#define MAXDEBUGSTRINGLENGTH 513

static DWORD   sg_dwTraceID = INVALID_TRACEID;

static const ULONG MAX_KEY_LENGTH = 100;

static const DWORD DEFAULT_DEBUGGER_MASK = 0xffff0000;

static char    sg_szTraceName[MAX_KEY_LENGTH];   // saves name of dll
static DWORD   sg_dwTracingToDebugger = 0;
static DWORD   sg_dwTracingToConsole  = 0;
static DWORD   sg_dwTracingToFile     = 0;
static DWORD   sg_dwDebuggerMask      = 0;


//
// this flag indicates whether any tracing needs to be done at all
//

BOOL g_bMSPBaseTracingOn = FALSE;


BOOL NTAPI MSPLogRegister(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[MAX_KEY_LENGTH];

    const char szDebuggerTracingEnableValue[] = "EnableDebuggerTracing";
    const char szConsoleTracingEnableValue[] = "EnableConsoleTracing";
    const char szFileTracingEnableValue[] = "EnableFileTracing";
    const char szTracingMaskValue[]   = "ConsoleTracingMask";


    sg_dwTracingToDebugger = 0;
    sg_dwTracingToConsole = 0;
    sg_dwTracingToFile = 0; 

#ifdef UNICODE

    HRESULT hr = StringCchPrintfA(szTracingKey, 
                                MAX_KEY_LENGTH, 
                                "Software\\Microsoft\\Tracing\\%ls", 
                                szName);
#else

    HRESULT hr = StringCchPrintfA(szTracingKey, 
                                MAX_KEY_LENGTH, 
                                "Software\\Microsoft\\Tracing\\%s", 
                                szName);
#endif

    if (FAILED(hr))
    {

        //
        // if this assert fires, the chances are the name string passed to us 
        // by the MSP is too long. the msp developer needs to address that.
        //

        _ASSERTE(FALSE);
        return FALSE;
    }

    _ASSERTE(sg_dwTraceID == INVALID_TRACEID);

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ,
                                        &hTracingKey) )
    {
        DWORD      dwDataSize = sizeof (DWORD);
        DWORD      dwDataType;

        LONG lRc = RegQueryValueExA(hTracingKey,
                         szDebuggerTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToDebugger,
                         &dwDataSize);

        if (ERROR_SUCCESS != lRc)
        {
            sg_dwTracingToDebugger = 0;
        }

        lRc = RegQueryValueExA(hTracingKey,
                         szConsoleTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToConsole,
                         &dwDataSize);

        if (ERROR_SUCCESS != lRc)
        {
            sg_dwTracingToConsole = 0;
        }


        lRc = RegQueryValueExA(hTracingKey,
                         szFileTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToFile,
                         &dwDataSize);

        if (ERROR_SUCCESS != lRc)
        {
            sg_dwTracingToFile = 0;
        }

        lRc = RegQueryValueExA(hTracingKey,
                         szTracingMaskValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwDebuggerMask,
                         &dwDataSize);


        if (ERROR_SUCCESS != lRc)
        {
            sg_dwDebuggerMask = DEFAULT_DEBUGGER_MASK;

        }

        RegCloseKey (hTracingKey);

    }
    else
    {

        //
        // the key could not be opened. in case the key does not exist, 
        // register with rtutils so that the reg keys get created
        //

#ifdef UNICODE
        hr = StringCchPrintfA(sg_szTraceName, MAX_KEY_LENGTH, "%ls", szName);
#else
        hr = StringCchPrintfA(sg_szTraceName, MAX_KEY_LENGTH, "%s", szName);
#endif

        if (FAILED(hr))
        {

            //
            // if this assert fires, the chances are the name string passed to us 
            // by the MSP is too long. the msp developer needs to address that.
            //

            _ASSERTE(FALSE);

            return FALSE;
        }


        //
        // tracing should not have been initialized
        //
        
        sg_dwTraceID = TraceRegister(szName);

        if (sg_dwTraceID != INVALID_TRACEID)
        {
            g_bMSPBaseTracingOn = TRUE;
        }

        return TRUE;
    }


    //
    // are we asked to do any tracing at all?
    //
    
    if ( (0 != sg_dwTracingToDebugger) ||
         (0 != sg_dwTracingToConsole ) ||
         (0 != sg_dwTracingToFile    )    )
    {

        //
        // see if we need to register with rtutils
        //

        if ( (0 != sg_dwTracingToConsole ) || (0 != sg_dwTracingToFile) )
        {

            //
            // rtutils tracing is enabled. register with rtutils
            //


#ifdef UNICODE
            hr = StringCchPrintfA(sg_szTraceName, MAX_KEY_LENGTH, "%ls", szName);
#else
            hr = StringCchPrintfA(sg_szTraceName, MAX_KEY_LENGTH, "%s", szName);
#endif
            if (FAILED(hr))
            {

                //
                // if this assert fires, the chances are the name string passed to us 
                // by the MSP is too long. the msp developer needs to address that.
                //

                _ASSERTE(FALSE);

                return FALSE;
            }


            //
            // tracing should not have been initialized
            //

            _ASSERTE(sg_dwTraceID == INVALID_TRACEID);


            //
            // register
            //

            sg_dwTraceID = TraceRegister(szName);
        }


        //
        // if debugger tracing, or succeeded registering with rtutils, we are all set
        //

        if ( (0 != sg_dwTracingToDebugger) || (sg_dwTraceID != INVALID_TRACEID) )
        {

            //
            // some tracing is enabled. set the global flag
            //

            g_bMSPBaseTracingOn = TRUE;

            return TRUE;
        }
        else
        {


            //
            // registration did not go through and debugger logging is off 
            //

            return FALSE;
        }
    }

    
    //
    // logging is not enabled. nothing to do
    //

    return TRUE;
}

void NTAPI MSPLogDeRegister()
{
    if (g_bMSPBaseTracingOn)
    {
        sg_dwTracingToDebugger = 0;
        sg_dwTracingToConsole = 0;
        sg_dwTracingToFile = 0; 


        //
        // if we registered tracing, unregister now
        //

        if ( sg_dwTraceID != INVALID_TRACEID )
        {
            TraceDeregister(sg_dwTraceID);
            sg_dwTraceID = INVALID_TRACEID;
        }
    }
}


void NTAPI LogPrint(IN DWORD dwDbgLevel, IN LPCSTR lpszFormat, IN ...)
/*++

Routine Description:

    Formats the incoming debug message & calls TraceVprintfEx to print it.

Arguments:

    dwDbgLevel   - The type of the message.

    lpszFormat - printf-style format string, followed by appropriate
                 list of arguments

Return Value:

--*/
{
    static char * message[] = 
    {
        "ERROR", 
        "WARNING", 
        "INFO", 
        "TRACE", 
        "EVENT",
        "INVALID TRACE LEVEL"
    };

    char  szTraceBuf[MAXDEBUGSTRINGLENGTH];
    
    DWORD dwIndex;

    if ( ( sg_dwTracingToDebugger > 0 ) &&
         ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )
    {
        switch(dwDbgLevel)
        {
        case MSP_ERROR: dwIndex = 0; break;
        case MSP_WARN:  dwIndex = 1; break;
        case MSP_INFO:  dwIndex = 2; break;
        case MSP_TRACE: dwIndex = 3; break;
        case MSP_EVENT: dwIndex = 4; break;
        default:        dwIndex = 5; break;
        }

        // retrieve local time
        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);

        HRESULT hr = 
            StringCchPrintfA(szTraceBuf,
                  MAXDEBUGSTRINGLENGTH,
                  "%s:[%02u:%02u:%02u.%03u,tid=%x:]%s: ",
                  sg_szTraceName,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond,
                  SystemTime.wMilliseconds,
                  GetCurrentThreadId(), 
                  message[dwIndex]);

        if (FAILED(hr))
        {

            //
            // if this assert fires, there is a good chance a bug was 
            // introduced in this function
            //

            _ASSERTE(FALSE);

            return;
        }


        va_list ap;
        va_start(ap, lpszFormat);

        size_t nStringLength = 0;
        hr = StringCchLengthA(szTraceBuf, 
                              MAXDEBUGSTRINGLENGTH, 
                              &nStringLength);

        if (FAILED(hr))
        {

            //
            // if this assert fires, there is a good chance a bug was 
            // introduced in this function
            //
            _ASSERTE(FALSE);

            return;
        }

        if (nStringLength >= MAXDEBUGSTRINGLENGTH)
        {
            //
            // the string is too long, was a bug introduced in this function?
            //

            _ASSERTE(FALSE);

            return;
        }

        hr = StringCchVPrintfA(&szTraceBuf[nStringLength],
            MAXDEBUGSTRINGLENGTH - nStringLength, 
            lpszFormat, 
            ap
            );

        if (FAILED(hr))
        {

            //
            // the string the msp code is trying to log is too long. assert to
            // indicate this, but proceed to logging it (StringCchVPrintfA 
            // guarantees that in case of ERROR_INSUFFICIENT_BUFFER, the 
            // string is remain null-terminated).
            //

            _ASSERTE(FALSE);

            if (ERROR_INSUFFICIENT_BUFFER != hr)
            {

                return;
            }
        }


        hr = StringCchCatA(szTraceBuf, MAXDEBUGSTRINGLENGTH,"\n");

        // in case of failure, the string is likely to be too long. debugbreak,
        // and proceed to logging, in which case the string will not be ended 
        // with '\n'
        _ASSERTE(SUCCEEDED(hr));

        OutputDebugStringA (szTraceBuf);

        va_end(ap);
    }

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        if ( ( sg_dwTracingToConsole > 0 ) || ( sg_dwTracingToFile > 0 ) )
        {
            switch(dwDbgLevel)
            {
            case MSP_ERROR: dwIndex = 0; break;
            case MSP_WARN:  dwIndex = 1; break; 
            case MSP_INFO:  dwIndex = 2; break;
            case MSP_TRACE: dwIndex = 3; break;
            case MSP_EVENT: dwIndex = 4; break;
            default:        dwIndex = 5; break;
            }

            HRESULT hr = StringCchPrintfA(szTraceBuf, 
                                         MAXDEBUGSTRINGLENGTH, 
                                         "[%s] %s", 
                                         message[dwIndex], 
                                         lpszFormat);

            if (FAILED(hr))
            {

                // the string we are trying to log is too long (or there is an 
                // unexpected error). do not proceed to logging, since we 
                // cannot afford to loose the formatting information contained
                // in the string -- that would confuse TraceVprintfExA()
                _ASSERTE(FALSE);

                return;
            }

            va_list arglist;
            va_start(arglist, lpszFormat);
            TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);
            va_end(arglist);
        }
    }
}

#endif // MSPLOG

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mspbase\msptrmac.cpp ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    msptrmac.cpp

Abstract:

    MSP base classes: implementation of audio capture terminal.

--*/

#include "precomp.h"
#pragma hdrstop

#define MAX_LONG 0xefffffff

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CAudioCaptureTerminal::CAudioCaptureTerminal()
{
    m_TerminalDirection = TD_CAPTURE;
    m_TerminalType = TT_STATIC;

    m_bResourceReserved = false;

    LOG((MSP_TRACE, "CAudioCaptureTerminal::CAudioCaptureTerminal() finished"));
}

CAudioCaptureTerminal::~CAudioCaptureTerminal()
{
    LOG((MSP_TRACE, "CAudioCaptureTerminal::~CAudioCaptureTerminal() finished"));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


HRESULT CAudioCaptureTerminal::CreateTerminal(
    IN  CComPtr<IMoniker>   pMoniker,
    IN  MSP_HANDLE          htAddress,
    OUT ITTerminal        **ppTerm
    )
{
    // Enable ATL string conversion macros.
    USES_CONVERSION;

    LOG((MSP_TRACE, "CAudioCaptureTerminal::CreateTerminal : enter"));

    //
    // Validate the parameters
    //

    if ( MSPB_IsBadWritePtr(ppTerm, sizeof(ITTerminal *) ) )
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::CreateTerminal : "
            "bad terminal pointer; returning E_POINTER"));
        return E_POINTER;
    }

    if ( IsBadReadPtr(pMoniker, sizeof(IMoniker) ) )
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::CreateTerminal : "
            "bad moniker pointer; returning E_POINTER"));
        return E_POINTER;
    }

    //
    // We return a NULL terminal if there is an error.
    //

    *ppTerm = NULL;
    HRESULT hr;

    //
    // Bind the moniker to storage as a property bag.
    //

    CComPtr<IPropertyBag> pBag;
    hr = pMoniker->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pBag);
    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::CreateTerminal (IMoniker::BindToStorage) - returning  %8x", hr));
        return hr;
    }

    VARIANT var;

    //
    // Get the wave ID from the property bag.
    // Skip this terminal if it doesn't have a wave ID.
    // (Needed because WDM devices don't work, and we don't want more than one
    // terminal per device.)
    //

    var.vt = VT_I4;
    hr = pBag->Read(L"WaveInId", &var, 0);

    if (FAILED(hr)) 
    {
        LOG((MSP_INFO, "CAudioCaptureTerminal::CreateTerminal - "
            "IPropertyBag::Read failed on WaveID - "
            "skipping terminal (not cause for alarm) - "
            "returning  0x%08x", hr));

        return hr;
    }

    //
    // Get the name for this filter out of the property bag.
    // Skip this terminal if it doesn't have a name.
    //

    var.vt = VT_BSTR;
    hr = pBag->Read(L"FriendlyName", &var, 0);

    if (FAILED(hr)) 
    {
        LOG((MSP_INFO, "CAudioCaptureTerminal::CreateTerminal - "
            "IPropertyBag::Read failed on FriendlyName - "
            "skipping terminal (not cause for alarm) - "
            "returning  0x%08x", hr));

        return hr;
    }

    //
    // Create the filter.
    //

    CMSPComObject<CAudioCaptureTerminal> *pLclTerm = new CMSPComObject<CAudioCaptureTerminal>;

    if (pLclTerm == NULL) 
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::CreateTerminal - returning E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    //
    // Save some stuff in the terminal.
    //

    pLclTerm->m_pMoniker = pMoniker;
    
    lstrcpyn(pLclTerm->m_szName, OLE2T(var.bstrVal), MAX_PATH);

    SysFreeString(var.bstrVal);

    //
    // Get the ITTerminal interface that we were asked for.
    //
    hr = pLclTerm->_InternalQueryInterface(IID_ITTerminal, (void**)ppTerm);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::CreateTerminal - "
            "Internal QI failed; returning 0x%08x", hr));

        delete pLclTerm;
        *ppTerm = NULL; // just in case        
        
        return hr;
    }

    //
    // Finish initializing the terminal.
    //

    hr = pLclTerm->Initialize(CLSID_MicrophoneTerminal,
                              TAPIMEDIATYPE_AUDIO,
                              TD_CAPTURE,
                              htAddress
                             );
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::CreateTerminal - "
            "Initialize failed; returning 0x%08x", hr));

        (*ppTerm)->Release();
        *ppTerm = NULL;

        return hr;
    }


    LOG((MSP_TRACE, "CAudioCaptureTerminal::CreateTerminal - exit S_OK"));
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Create the filters used by this terminal

HRESULT CAudioCaptureTerminal::CreateFilters(void)
{
    LOG((MSP_TRACE, "CAudioCaptureTerminal::CreateFilters() called"));

    //
    // This should only be called atmost once in the lifetime of this instance
    //

    if ( (m_pIFilter            != NULL) ||
         (m_pIPin               != NULL) ||
         (m_pIAMAudioInputMixer != NULL) )
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::CreateFilters() : we've already been called; returning E_FAIL"));  
        return E_FAIL;
    }

    //
    // Create the filter.
    //

    HRESULT hr = m_pMoniker->BindToObject(0, 0, IID_IBaseFilter, (void**)&m_pIFilter);

    if ( FAILED(hr) || (m_pIFilter == NULL) )
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::CreateFilters() : BindToObject failed 0x%08x", hr));  

        m_pIFilter = NULL; // we are being extra careful...
        return hr;
    }

    //
    // Get the basic audio (mixer) interface for the filter.
    //

    hr = m_pIFilter->QueryInterface(IID_IAMAudioInputMixer,
                                       (void **) &m_pIAMAudioInputMixer);

    if ( FAILED(hr) || (m_pIAMAudioInputMixer == NULL) )
    {
        //
        // The filter doesn't support the mixer interface. This is not catastrophic;
        // all it means is that subsequent mixer operations on the terminal will fail.
        //

        LOG((MSP_WARN, "CAudioCaptureTerminal::CreateFilters() : mixer QI failed 0x%08x", hr));  
        m_pIAMAudioInputMixer = NULL;
    }

    //
    // Find the output pin (this is a private method on the terminal).
    //

    hr = FindTerminalPin();

    if ( FAILED(hr) || (m_pIPin == NULL) )
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::CreateFilters() : FindTerminalPin failed 0x%08x", hr));  

        //
        // Clean up our mess.
        //

        if (m_pIAMAudioInputMixer != NULL)
        {
            m_pIAMAudioInputMixer = NULL; // implicit release
        }

        m_pIFilter = NULL; // implicit release
        
        return hr;
    }

    LOG((MSP_TRACE, "CAudioCaptureTerminal::CreateFilters() succeeded"));
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT 
CAudioCaptureTerminal::FindTerminalPin(
    )
{
    LOG((MSP_TRACE, "CAudioCaptureTerminal::FindTerminalPin - enter"));
    
    // We must not do CreateFiltersIfRequired here because that would
    // result in a recursive call to us again.

    if (m_pIPin != NULL)
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::FindTerminalPin - "
            "we've alread got a pin; returning E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    HRESULT hr;
    CComPtr<IEnumPins> pIEnumPins;
    ULONG cFetched;

    //
    // Find the capture pin for the filter.
    //

    if (FAILED(hr = m_pIFilter->EnumPins(&pIEnumPins)))
    {
        LOG((MSP_ERROR, 
            "CAudioCaptureTerminal::FindTerminalPin - can't enum pins %8x",
            hr));
        return hr;
    }

    IPin * pIPin;

    // Enumerate all the pins and break on the 
    // first pin that meets requirement.
    for (;;)
    {
        if (pIEnumPins->Next(1, &pIPin, &cFetched) != S_OK)
        {
            LOG((MSP_ERROR, 
                "CAudioCaptureTerminal::FindTerminalPin - can't get a pin %8x",
                hr));
            return (hr == S_FALSE) ? E_FAIL : hr;
        }

        if (0 == cFetched)
        {
            LOG((MSP_ERROR, "CAudioCaptureTerminal::FindTerminalPin - got zero pins"));
            return E_FAIL;
        }

        PIN_DIRECTION dir;

        if (FAILED(hr = pIPin->QueryDirection(&dir)))
        {
            LOG((MSP_ERROR, 
                "CAudioCaptureTerminal::FindTerminalPin - can't query pin direction %8x",
                hr));
            pIPin->Release();
            return hr;
        }

        if (PINDIR_OUTPUT == dir)
        {
            break;
        }

        pIPin->Release();
    }

    m_pIPin = pIPin;

    LOG((MSP_TRACE, "CAudioCaptureTerminal::FindTerminalPin - exit S_OK"));
  
    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CAudioCaptureTerminal::AddFiltersToGraph(
    )
{
    LOG((MSP_TRACE, "CAudioCaptureTerminal::AddFiltersToGraph - enter"));

    if (m_pGraph == NULL)
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::AddFiltersToGraph - "
            "we don't have a filter graph; returning E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    HRESULT hr = CreateFiltersIfRequired();
    
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::AddFiltersToGraph - "
            "CreateFiltersIfRequired failed; returning hr = 0x%08x", hr));
        return hr;
    }

    if (m_pIFilter == NULL)
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::AddFiltersToGraph - "
            "we don't have a filter; returning E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Add the filter to the graph.
    //
    // A word about names:
    // If a filter has already been added with the same name (which will
    // happen if we have more than one audio capture terminal in the same
    // graph) then that will return VFW_S_DUPLICATE_NAME, which is not
    // a failure.
    //

    hr = m_pGraph->AddFilter(m_pIFilter, WAVEIN_NAME);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::AddFiltersToGraph - "
            "AddFilter failed; returning hr = 0x%08x", hr));
        return hr;
    }

    LOG((MSP_TRACE, "CAudioCaptureTerminal::AddFiltersToGraph - exit S_OK"));
    return S_OK;
}
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CAudioCaptureTerminal::CompleteConnectTerminal(void)
{
    CLock lock(m_CritSec);
    
    LOG((MSP_TRACE, "CAudioCaptureTerminal::CompleteConnectTerminal - enter"));

    // By default, we need not unreserve later.
    m_bResourceReserved = false;

    HRESULT hr = CSingleFilterTerminal::CompleteConnectTerminal();
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::CompleteConnectTerminal: "
                "CSingleFilterTerminal method failed"));
        return hr;
    }

    // So here we are, after our filter has been added to the filter graph and connected up, but before
    // the MSP has told it to run.

    //////////////////////////////////////////////////////////////////////////
    // connect-time device reservation:
    // we must inform the filter that we want it to grab the wave device.
    // We do this after connecting because the filter needs to negotiate the
    // media type before it can open a wave device.

    CComPtr <IAMResourceControl> pIResource;
 
    hr = m_pIFilter->QueryInterface(IID_IAMResourceControl, (void **) &pIResource);
    if (FAILED(hr)) 
    {
        LOG((MSP_WARN, "CAudioCaptureTerminal::CompleteConnectTerminal - QI failed: %8x", hr)); 
        
        // This is a nonesential operation so we do not "return hr;" here.
    }
    else // QueryInterface didn't fail
    {
        hr = pIResource->Reserve(AMRESCTL_RESERVEFLAGS_RESERVE, NULL);

        if (hr != S_OK)
        {
            LOG((MSP_ERROR, "CAudioCaptureTerminal::CompleteConnectTerminal - "
                    "device reservation failed: %8x", hr));
            return hr;
        }

        // We have succeeded in reserving, so we will want to unreserve later.
        m_bResourceReserved = true;
    }

    LOG((MSP_TRACE, "CAudioCaptureTerminal::CompleteConnectTerminal - exit S_OK"));
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////
// We override this here so we can unreserve the resource when we are done.
// removes filters from the filter graph and resets member variables
// Disconnect may be called anytime after Connect succeeds (it need not be called
// if CompleteConnect fails)

STDMETHODIMP CAudioCaptureTerminal::DisconnectTerminal(
            IN      IGraphBuilder  * pGraph,
            IN      DWORD            dwReserved
            )
{
    LOG((MSP_TRACE, "CAudioCaptureTerminal::DisconnectTerminal - enter"));

    HRESULT hr;

    //
    // First call the base class method, to make sure we validate everything
    // and don't mess with our resource reservation unless this is a valid
    // disconnection (e.g., the filter graph pointersmatch).
    //

    hr = CSingleFilterTerminal::DisconnectTerminal(pGraph, dwReserved);

    if (FAILED(hr))
    {
        LOG((MSP_TRACE, "CAudioCaptureTerminal::DisconnectTerminal : "
                "CSingleFilterTerminal method failed; hr = %d", hr));
        return hr;
    }

    // if we need to unreserve the resource now
    if (m_bResourceReserved)
    {
        CComPtr <IAMResourceControl> pIResource;

        hr = m_pIFilter->QueryInterface(IID_IAMResourceControl,
                                        (void **) &pIResource);
        if (FAILED(hr)) 
        {
            LOG((MSP_WARN, "CAudioCaptureTerminal::DisconnectTerminal - "
                                 "QI failed: %8x", hr)); 
        
            // This is a nonesential operation so we do not "return hr;" here.
        }
        else
        {
            // QueryInterface didn't fail, so UNRESERVE now

            hr = pIResource->Reserve(AMRESCTL_RESERVEFLAGS_UNRESERVE, NULL);
            if (hr != S_OK)
            {
                LOG((MSP_WARN, "CAudioCaptureTerminal::DisconnectTerminal - "
                                     "device unreservation failed: %8x", hr));
                // no reason to completely die at this point, so we just continue
            }

            // if other things fail we may be called again, but we should not try
            // to unreserve again.
            m_bResourceReserved = false;

        } // {if QI succeeded}
    } // {if we need to release}

    LOG((MSP_TRACE, "CAudioCaptureTerminal::DisconnectTerminal - exit S_OK"));

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//***************************************************************************//
//*                                                                         *//
//* NOTE: The input filter does not support IBasicAudio so we need to masage*//
//*       the parameters for the basic audio methods so that the will work  *//
//*       for IAMAudioInputMixer.                                           *//
//*                                                                         *//    
//*****************************************************************************
///////////////////////////////////////////////////////////////////////////////

static const long   TMGR_MIN_API_VOLUME     = 0;      // our terminal semantics
static const long   TMGR_MAX_API_VOLUME     = 0xFFFF;
static const double TMGR_MIN_CAPTURE_VOLUME = 0.0;    // capture filter semantics
static const double TMGR_MAX_CAPTURE_VOLUME = 1.0;

STDMETHODIMP CAudioCaptureTerminal::get_Volume(long * plVolume)
{
    CLock lock(m_CritSec);

    LOG((MSP_TRACE, "CAudioCaptureTerminal::get_Volume - enter"));

    //
    // Check parameters.
    //

    if ( MSPB_IsBadWritePtr(plVolume, sizeof(long)) )
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::get_Volume - "
            "invalid pointer passed in - returning E_POINTER"));
        return E_POINTER;
    }

    //
    // Create the filters if required. This protects us if the creation fails.
    //

    HRESULT hr = CreateFiltersIfRequired();
    
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::get_Volume - "
            "CreateFiltersIfRequired failed; returning hr = 0x%08x", hr));
        return hr;
    }

    //
    // Check if CreateFiltersIfRequired was able to get us the mixer interface.
    // If not, we must fail.
    //

    if (m_pIAMAudioInputMixer == NULL)
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::get_Volume - "
            "filter does not support mixer interface - returning E_FAIL"));
        return E_FAIL;
    }

    //
    // Perform the call on the filter.
    //

    double dVolume;
    hr = m_pIAMAudioInputMixer->get_MixLevel(&dVolume);
    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::get_Volume "
            "(get_MixLevel) - returning  %8x", hr));
        return hr;
    }


    //
    // Massage ranges to convert between disparate semantics.
    //

    
    // Our argument is a pointer to a long in the range 0 - 0xFFFF.
    // We need to output that based on a double ranging from 0.0 to 1.0.

    if (dVolume < TMGR_MIN_CAPTURE_VOLUME)
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::get_Volume - observed "
            "volume %d < %d; returning E_INVALIDARG",
            dVolume, TMGR_MIN_CAPTURE_VOLUME));

        return E_INVALIDARG;
    }

    if (dVolume > TMGR_MAX_CAPTURE_VOLUME)
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::get_Volume - observed "
            "volume %d > %d; returning E_INVALIDARG",
            dVolume, TMGR_MAX_CAPTURE_VOLUME));

        return E_INVALIDARG;
    }

    // Convert the volume from whatever range of doubles the filter uses
    // to the range 0 - 1. Right now this does nothing but makes the code more general.
    dVolume = ( dVolume                 - TMGR_MIN_CAPTURE_VOLUME )
            / ( TMGR_MAX_CAPTURE_VOLUME - TMGR_MIN_CAPTURE_VOLUME );

    // Convert the volume from the range 0 - 1 to the API's range.
    *plVolume = TMGR_MIN_API_VOLUME +
        (long) (( TMGR_MAX_API_VOLUME - TMGR_MIN_API_VOLUME ) * dVolume);

    LOG((MSP_TRACE, "CAudioCaptureTerminal::get_Volume - exit S_OK"));
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CAudioCaptureTerminal::put_Volume(long lVolume)
{
    CLock lock(m_CritSec);

    LOG((MSP_TRACE, "CAudioCaptureTerminal::put_Volume - enter"));
    
    //
    // Create the filters if required. This protects us if the creation fails.
    //

    HRESULT hr = CreateFiltersIfRequired();
    
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::put_Volume - "
            "CreateFiltersIfRequired failed; returning hr = 0x%08x", hr));
        return hr;
    }

    //
    // Check if CreateFiltersIfRequired was able to get us the mixer interface.
    // If not, we must fail.
    //

    if (m_pIAMAudioInputMixer == NULL)
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::put_Volume - "
            "filter does not support mixer interface - returning E_FAIL"));
        return E_FAIL;
    }

    //
    // Massage ranges to convert between disparate semantics.
    //

    // Our argument is a long in the range 0 - 0xFFFF. We need to convert it
    // to a double ranging from 0.0 to 1.0.

    if (lVolume < TMGR_MIN_API_VOLUME)
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::put_Volume - requested "
            "volume %d < %d; returning E_INVALIDARG",
            lVolume, TMGR_MIN_API_VOLUME));

        return E_INVALIDARG;
    }

    if (lVolume > TMGR_MAX_API_VOLUME)
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::put_Volume - requested "
            "volume %d > %d; returning E_INVALIDARG",
            lVolume, TMGR_MAX_API_VOLUME));

        return E_INVALIDARG;
    }

    // Convert to the range 0 to 1.
    double dVolume =
               ( (double) ( lVolume             - TMGR_MIN_API_VOLUME ) )
             / ( (double) ( TMGR_MAX_API_VOLUME - TMGR_MIN_API_VOLUME ) );

    // Convert the volume to whatever range of doubles the filter uses
    // from the range 0 - 1. Right now this does nothing but makes the code
    // more general.

    dVolume = TMGR_MIN_CAPTURE_VOLUME +
        ( TMGR_MAX_CAPTURE_VOLUME - TMGR_MIN_CAPTURE_VOLUME ) * dVolume;

    hr = m_pIAMAudioInputMixer->put_MixLevel(dVolume);

    LOG((MSP_TRACE, "CAudioCaptureTerminal::put_Volume - exit 0x%08x", hr));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CAudioCaptureTerminal::get_Balance(long * plBalance)
{
    
    HRESULT hr = E_NOTIMPL;

    LOG((MSP_TRACE, "CAudioCaptureTerminal::get_Balance - enter"));
    LOG((MSP_TRACE, "CAudioCaptureTerminal::get_Balance - exit 0x%08x", hr));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CAudioCaptureTerminal::put_Balance(long lBalance)
{
    HRESULT hr = E_NOTIMPL;

    LOG((MSP_TRACE, "CAudioCaptureTerminal::put_Balance - enter"));
    LOG((MSP_TRACE, "CAudioCaptureTerminal::put_Balance - exit 0x%08x", hr));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP
CAudioCaptureTerminal::get_WaveId(
    OUT long * plWaveId
    )
{
    LOG((MSP_TRACE, "CAudioCaptureTerminal::get_WaveId - enter"));

    CLock lock(m_CritSec);

    //
    // Parameter checks.
    //

    if ( MSPB_IsBadWritePtr(plWaveId, sizeof(long)) )
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::get_WaveId - "
            "bad pointer argument"));

        return E_POINTER;
    }

    //
    // Check the moniker pointer.
    //

    if ( IsBadReadPtr( m_pMoniker, sizeof(IMoniker) ) )
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::get_WaveId - "
            "bad moniker pointer - exit E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    //
    // Get a property bag from the moniker.
    //

    IPropertyBag * pBag;

    HRESULT hr = m_pMoniker->BindToStorage(0,
                                           0,
                                           IID_IPropertyBag,
                                           (void **) &pBag);
    
    if ( FAILED(hr) ) 
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::get_WaveId - "
            "can't get property bag - exit 0x%08x", hr));

        return hr;
    }

    //
    // Get the ID from the property bag.
    //

    VARIANT var;

    var.vt = VT_I4;

    hr = pBag->Read(
        L"WaveInId",
        &var,
        0);

    pBag->Release();

    if ( FAILED(hr) ) 
    {
        LOG((MSP_ERROR, "CAudioCaptureTerminal::get_WaveId - "
            "can't read wave ID - exit 0x%08x", hr));

        return hr;
    }

    *plWaveId = (long) var.lVal;

    LOG((MSP_TRACE, "CAudioCaptureTerminal::get_WaveId - exit S_OK"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mspbase\msptrmar.cpp ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    msptrmar.cpp

Abstract:

    MSP base classes: implementation of audio render terminal.

--*/

#include "precomp.h"
#pragma hdrstop

#include <mmsystem.h>

// Filter volume level ranges
const long AX_MIN_VOLUME = -9640; // -10000;
const long AX_MAX_VOLUME = 0;

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CAudioRenderTerminal::CAudioRenderTerminal()
{
    m_TerminalDirection = TD_RENDER;
    m_TerminalType = TT_STATIC;

    m_szName[0] = L'\0'; // real name is copied in on creation

    m_bResourceReserved = false;

    LOG((MSP_TRACE, "CAudioRenderTerminal::CAudioRenderTerminal() finished"));
}

CAudioRenderTerminal::~CAudioRenderTerminal()
{
    LOG((MSP_TRACE, "CAudioRenderTerminal::~CAudioRenderTerminal() finished"));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// This function determines if the terminal associated with a given
// moniker is "good". A good terminal returns S_OK; a bad terminal returns an
// error.
//
// A good terminal has the following properties:
//      * has a friendly name
//      * is not a WAVE_MAPPER terminal
//      * is not a DirectSound terminal (unless USE_DIRECT_SOUND is pound-defined)
//

static inline HRESULT TerminalAllowed(IMoniker * pMoniker)
{
    HRESULT hr;
    CComPtr<IPropertyBag> pBag;
    hr = pMoniker->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pBag);
    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "audio render TerminalAllowed (IMoniker::BindToStorage) "
                            "- returning  %8x", hr));
        return hr;
    }

    VARIANT var;

    // we make sure creation is not going to fail on
    // account of a nonexistent friendly name
    VariantInit(&var);
    var.vt = VT_BSTR;
    hr = pBag->Read(L"FriendlyName", &var, 0);
    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "audio render TerminalAllowed "
            "(IPropertyBag::Read on FriendlyName) - got  %8x; skipping terminal", hr));
        return hr;
    }

    // Fix for memory leak!
    SysFreeString(var.bstrVal);

     // NOTE: Magic code selects only wave devices
    VariantInit(&var);
    var.vt = VT_I4;
    hr = pBag->Read(L"WaveOutId", &var, 0);

    if (hr != S_OK)
    {
        #ifndef USE_DIRECT_SOUND

            // This is most likely a DirectSound terminal
            LOG((MSP_WARN, "audio render TerminalAllowed - "
                "this is a DirectSound terminal "
                "so we are skipping it - note that this is a routine "
                "occurance - returning  %8x", hr));

        #else  // we do use DirectSound
            return S_OK;
        #endif
    }
    else if (var.lVal == WAVE_MAPPER)
    {
        // hack: if the value is equal to WAVE_MAPPER then don't use it....    
        hr = E_FAIL; // random failure code :)

        LOG((MSP_WARN, "audio render TerminalAllowed - "
            "this is a WAVE_MAPPER terminal "
            "so we are skipping it - note that this is a routine "
            "occurance - returning  %8x", hr));
    }

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CAudioRenderTerminal::CreateTerminal(
    IN  CComPtr<IMoniker>   pMoniker,
    IN  MSP_HANDLE          htAddress,
    OUT ITTerminal        **ppTerm
    )
{
    // Enable ATL string conversion macros.
    USES_CONVERSION;

    LOG((MSP_TRACE, "CAudioRenderTerminal::CreateTerminal - enter"));

    //
    // Validate the parameters
    //

    if ( MSPB_IsBadWritePtr(ppTerm, sizeof(ITTerminal *) ) )
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::CreateTerminal : "
            "bad terminal pointer; returning E_POINTER"));
        return E_POINTER;
    }

    if ( IsBadReadPtr(pMoniker, sizeof(IMoniker) ) )
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::CreateTerminal : "
            "bad moniker pointer; returning E_POINTER"));
        return E_POINTER;
    }

    //
    // We return a NULL terminal if we fail.
    //

    *ppTerm = NULL;
    HRESULT hr;

    // Refuse to work with DirectSound or WAVE_MAPPER terminals.
    // or if we can't read the friendlyName...
    if (FAILED(hr = TerminalAllowed(pMoniker))) return hr;

    //
    // Get the name for this filter out of the property bag.
    //

    CComPtr<IPropertyBag> pBag;
    hr = pMoniker->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pBag);
    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::CreateTerminal (IMoniker::BindToStorage) - returning  %8x", hr));
        return hr;
    }

    VARIANT var;
    VariantInit(&var);

    var.vt = VT_BSTR;
    hr = pBag->Read(L"FriendlyName", &var, 0);
    if (FAILED(hr)) 
    {
        LOG((MSP_WARN, "CAudioRenderTerminal::CreateTerminal "
            "(IPropertyBag::Read) - got  %8x - we are therefore skipping "
            "this terminal; note that this is fairly routine", hr));

        return hr;
    }

    //
    // Create the terminal.
    //

    CMSPComObject<CAudioRenderTerminal> *pLclTerm = new CMSPComObject<CAudioRenderTerminal>;
    if (pLclTerm == NULL) 
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::CreateTerminal - returning E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    //
    // Save some stuff in the terminal.
    //
    
    pLclTerm->m_pMoniker = pMoniker;
    
    lstrcpyn(pLclTerm->m_szName, OLE2T(var.bstrVal), MAX_PATH);

    SysFreeString(var.bstrVal);

    //
    // Get the ITTerminal interface that we were asked for.
    //
    
    hr = pLclTerm->_InternalQueryInterface(IID_ITTerminal, (void**)ppTerm);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::CreateTerminal - "
            "Internal QI failed; returning 0x%08x", hr));

        delete pLclTerm;
        *ppTerm = NULL; // just in case

        return hr;
    }

    //
    // Finish initializing the terminal.
    //

    hr = pLclTerm->Initialize(CLSID_SpeakersTerminal,
                              TAPIMEDIATYPE_AUDIO,
                              TD_RENDER,
                              htAddress
                             );
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::CreateTerminal - "
            "Initialize failed; returning 0x%08x", hr));

        (*ppTerm)->Release();
        *ppTerm = NULL; // just in case

        return hr;
    }

    LOG((MSP_TRACE, "CAudioRenderTerminal::CreateTerminal - exit S_OK"));
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// Create the filters used by this terminal

HRESULT CAudioRenderTerminal::CreateFilters()
{
    LOG((MSP_TRACE, "CAudioRenderTerminal::CreateFilters - enter"));

    HRESULT hr;

    //
    // We used to recreate the audio render filter every time, but we don't
    // have any real reason for doing so. Just return S_OK if the filter
    // has already been created.
    //

    if ( m_pIFilter != NULL )
    {
        _ASSERTE( m_pIPin != NULL );

        LOG((MSP_TRACE, "CAudioRenderTerminal::CreateFilters - "
            "filter already created - exit S_OK"));

        return S_OK;
    }

    _ASSERTE ( m_pIBasicAudio == NULL );
    _ASSERTE ( m_pIPin == NULL );

    //
    // Sanity checks.
    //
    if ( m_pMoniker == NULL )
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::CreateFilters - "
            "no moniker present - returning E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    //
    // Create a new instance of the filter.    
    //
    hr = m_pMoniker->BindToObject(0, 0, IID_IBaseFilter, (void**)&m_pIFilter);
 
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::CreateFilters - "
            "BindToObject failed; returning  %8x", hr));
        return hr;
    }

    //
    // Get the basic audio interface for the filter. If it doesn't exist, we
    // can live with that, but all our IBasicAudio methods will fail.
    //

    hr = m_pIFilter->QueryInterface(IID_IBasicAudio,
                                       (void **) &m_pIBasicAudio);
    if ( FAILED(hr) ) 
    {
        LOG((MSP_WARN, "CAudioRenderTerminal::CreateFilters - "
            "QI for IBasicAudio failed: %8x", hr)); 
    }

    hr = FindTerminalPin();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::CreateFilters - "
            "FindTerminalPin failed; returning  0x%08x", hr));

        m_pIFilter = NULL; // does an implicit release

        if ( m_pIBasicAudio )
        {
            m_pIBasicAudio = NULL; // does an implicit release
        }
        
        return hr;
    }

    LOG((MSP_TRACE, "CAudioRenderTerminal::CreateFilters - exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT 
CAudioRenderTerminal::FindTerminalPin(
    )
{
    LOG((MSP_TRACE, "CAudioRenderTerminal::FindTerminalPin - enter"));

    //
    // Sanity checks so we don't AV.
    //

    if (m_pIPin != NULL)
    {
        LOG((MSP_TRACE, "CAudioRenderTerminal::FindTerminalPin - "
            "we've already got a pin; exit E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    if (m_pIFilter == NULL)
    {
        LOG((MSP_TRACE, "CAudioRenderTerminal::FindTerminalPin - "
            "we don't have a filter; exit E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    HRESULT hr;
    CComPtr<IEnumPins> pIEnumPins;
    ULONG cFetched;
    
    //
    // Find the render pin for the filter.
    //

    hr = m_pIFilter->EnumPins(&pIEnumPins);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, 
            "CAudioRenderTerminal::FindTerminalPin - can't enum pins 0x%08x",
            hr));
        return hr;
    }

    IPin * pIPin;

    // Enumerate all the pins and break on the 
    // first pin that meets requirement.
    for (;;)
    {
        if (pIEnumPins->Next(1, &pIPin, &cFetched) != S_OK)
        {
            LOG((MSP_ERROR, 
                "CAudioRenderTerminal::FindTerminalPin - can't get a pin %8x",
                hr));
            return (hr == S_FALSE) ? E_FAIL : hr;
        }

        if (0 == cFetched)
        {
            LOG((MSP_ERROR, "CAudioRenderTerminal::FindTerminalPin - got zero pins"));
            return E_FAIL;
        }

        PIN_DIRECTION dir;

        if (FAILED(hr = pIPin->QueryDirection(&dir)))
        {
            LOG((MSP_ERROR, 
                "CAudioRenderTerminal::FindTerminalPin - can't query pin direction %8x",
                hr));
            pIPin->Release();
            return hr;
        }

        if (PINDIR_INPUT == dir)
        {
            break;
        }

        pIPin->Release();
    }

    m_pIPin = pIPin;

    LOG((MSP_TRACE, "CAudioRenderTerminal::FindTerminalPin - exit S_OK"));
  
    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CAudioRenderTerminal::AddFiltersToGraph(
    )
{
    LOG((MSP_TRACE, "CAudioRenderTerminal::AddFiltersToGraph - enter"));

    if (m_pGraph == NULL)
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::AddFiltersToGraph - "
            "haven't got a filter graph; return E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Create the filters if this is the first connection with this terminal.
    //

    HRESULT hr = CreateFilters();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::AddFiltersToGraph - "
            "CreateFilters failed; returning  0x%08x", hr)); 
        return hr; 
    }

    //
    // Add the filter to the graph.
    //
    // A word about names:
    // If a filter has already been added with the same name (which will
    // happen if we have more than one audio render terminal in the same
    // graph) then that will return VFW_S_DUPLICATE_NAME, which is not
    // a failure.
    //

    hr = m_pGraph->AddFilter(m_pIFilter, WAVEOUT_NAME);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::AddFiltersToGraph - "
            "returning  0x%08x", hr)); 
        return hr; 
    }

    LOG((MSP_TRACE, "CAudioRenderTerminal::AddFiltersToGraph - exit S_OK"));
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// we override this here so we can do some stuff
// right after the filter gets connected

STDMETHODIMP CAudioRenderTerminal::CompleteConnectTerminal(void)
{
    LOG((MSP_TRACE, "CAudioRenderTerminal::CompleteConnectTerminal - enter"));

    // By default, we need not unreserve later.
    m_bResourceReserved = false;

    // Don't clobber the base class' machinations (currently nothing...)
    HRESULT hr = CSingleFilterTerminal::CompleteConnectTerminal();

    if (FAILED(hr))
    {
        LOG((MSP_TRACE, "CAudioRenderTerminal::CompleteConnectTerminal: "
                "CSingleFilterTerminal method failed"));
        return hr;
    }

    // So here we are, after our filter has been added to the filter graph and connected up.
    // We need to use the filter's
    // IAMResourceControl::Reserve method to make sure the filter opens the waveOut device
    // now (and keeps it open).

    //////////////////////////////////////////////////////////////////////////
    // we must inform the filter that we want it to grab the wave device.
    // We do this after connecting because the filter needs to negotiate the
    // media type before it can open a wave device.

    CComPtr <IAMResourceControl> pIResource;

    hr = m_pIFilter->QueryInterface(IID_IAMResourceControl, (void **) &pIResource);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::CompleteConnectTerminal - QI failed: %8x", hr)); 
        
        // This is a nonesential operation so we do not fail.
        return S_OK;
    }

    // The QueryInterface didn't fail...

    hr = pIResource->Reserve(AMRESCTL_RESERVEFLAGS_RESERVE, NULL);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::CompleteConnectTerminal - "
                            "device reservation failed: %8x", hr));
        return hr;
    }
    else if (hr == S_FALSE)
    {
        // Well, in this case either another application is already using the wave out device,
        // or we are running half-duplex and we've got both wavein and waveout terminals
        // selected.

        LOG((MSP_ERROR, "CAudioRenderTerminal::CompleteConnectTerminal - "
                "device already in use: %8x", hr));
        return hr;

    } // {if the driver is half-duplex}

    // We have succeeded in reserving, so we will want to unreserve later.
    m_bResourceReserved = true;

    LOG((MSP_TRACE, "CAudioRenderTerminal::CompleteConnectTerminal - exit S_OK"));
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////
// We override this here so we can unreserve the resource when we are done.
// removes filters from the filter graph and resets member variables
// Disconnect may be called anytime after Connect succeeds (it need not be called
// if CompleteConnect fails)

STDMETHODIMP CAudioRenderTerminal::DisconnectTerminal(
            IN      IGraphBuilder  * pGraph,
            IN      DWORD            dwReserved
            )
{
    LOG((MSP_TRACE, "CAudioRenderTerminal::DisconnectTerminal - enter"));

    HRESULT hr;

    //
    // First call the base class method, to make sure we validate everything
    // and don't mess with our resource reservation unless this is a valid
    // disconnection (e.g., the filter graph pointersmatch).
    //

    hr = CSingleFilterTerminal::DisconnectTerminal(pGraph, dwReserved);

    if (FAILED(hr))
    {
        LOG((MSP_TRACE, "CAudioRenderTerminal::DisconnectTerminal : "
                "CSingleFilterTerminal method failed; hr = %d", hr));
        return hr;
    }

    // if we need to release the resource
    if (m_bResourceReserved)
    {
        CComPtr <IAMResourceControl> pIResource;

        hr = m_pIFilter->QueryInterface(IID_IAMResourceControl, (void **) &pIResource);
        if (FAILED(hr)) 
        {
            LOG((MSP_ERROR, "CAudioRenderTerminal::DisconnectTerminal - QI failed: %8x", hr)); 
        
            // This is a nonesential operation so we do not "return hr;" here.
        }
        else
        {
            // QueryInterface didn't fail, and we have reserved WaveOut, so we must
            // unreserve now.

            hr = pIResource->Reserve(AMRESCTL_RESERVEFLAGS_UNRESERVE, NULL);
            if (FAILED(hr))
            {
                LOG((MSP_ERROR, "CAudioRenderTerminal::DisconnectTerminal - "
                                    "device unreservation failed: %8x", hr));
                // no reason to completely die at this point, so we just continue
            }

            // if other things fail we may be called again, but we should not try
            // to unreserve again.
            m_bResourceReserved = false;

        } // {if QI succeeded}
    } // {if need to release resource}

    LOG((MSP_TRACE, "CAudioRenderTerminal::DisconnectTerminal - exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// private helper method:

static HRESULT RangeConvert(long   lInput,
                            long   lInputMin,
                            long   lInputMax,
                            long * plOutput,
                            long   lOutputMin,
                            long   lOutputMax)
{
    _ASSERTE( lInputMin  < lInputMax );
    _ASSERTE( lOutputMin < lOutputMax );
    _ASSERTE( ! MSPB_IsBadWritePtr(plOutput, sizeof(long)) );

    if (lInput < lInputMin)
    {
        LOG((MSP_ERROR, "RangeConvert - value out of range - "
            "%d < %d; returning E_INVALIDARG",
            lInput, lInputMin));

        return E_INVALIDARG;
    }

    if (lInput > lInputMax)
    {
        LOG((MSP_ERROR, "RangeConvert - value out of range - "
            "%d > %d; returning E_INVALIDARG",
            lInput, lInputMax));

        return E_INVALIDARG;
    }

    // This is how much we are going to expand the range of the input.    
    double dRangeWidthRatio = (double) (lOutputMax - lOutputMin) /
                              (double) (lInputMax  - lInputMin);

    *plOutput = (long) ((lInput - lInputMin) * dRangeWidthRatio) + lOutputMin;

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CAudioRenderTerminal::get_Volume(long * plVolume)
{
    CLock lock(m_CritSec);

    LOG((MSP_TRACE, "CAudioRenderTerminal::get_Volume - enter"));

    //
    // Parameter checks.
    //

    if ( MSPB_IsBadWritePtr(plVolume, sizeof(long)) )
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::get_Volume - "
            "bad pointer argument"));
        return E_POINTER;
    }

    if (m_pIBasicAudio == NULL)
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::get_Volume - "
            "don't have necessary interface - exit E_FAIL"));
        return E_FAIL;
    }

    //
    // Let the filter do the work.
    //

    HRESULT hr = m_pIBasicAudio->get_Volume(plVolume);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::get_Volume - "
            "filter call failed: %08x", hr));
        return hr;
    }

    //
    // Asjust the range of the value returned to match the range specified
    // by the TAPI APIs.
    //

    hr = RangeConvert(*plVolume, AX_MIN_VOLUME, AX_MAX_VOLUME,
                      plVolume,  0,             0xFFFF);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::get_Volume - "
            "RangeConvert call failed: %08x", hr));
        return hr;
    }

    LOG((MSP_TRACE, "CAudioRenderTerminal::get_Volume - exit S_OK"));
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CAudioRenderTerminal::put_Volume(long lVolume)
{
    CLock lock(m_CritSec);

    LOG((MSP_TRACE, "CAudioRenderTerminal::put_Volume - enter"));

    if (m_pIBasicAudio == NULL)
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::put_Volume - "
            "don't have necessary interface - exit E_FAIL"));
        return E_FAIL;
    }

    //
    // Asjust the range of the value returned to match the range needed
    // by the WaveOut filter.
    //

    HRESULT hr = RangeConvert(lVolume,  0,             0xFFFF,
                              &lVolume, AX_MIN_VOLUME, AX_MAX_VOLUME);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::put_Volume - "
            "RangeConvert call failed: %08x", hr));
        return hr;
    }

    //
    // Let the filter do the work.
    //

    hr = m_pIBasicAudio->put_Volume(lVolume);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::put_Volume - "
            "filter call failed: %08x", hr));
        return hr;
    }

    LOG((MSP_TRACE, "CAudioRenderTerminal::put_Volume - exit S_OK"));
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CAudioRenderTerminal::get_Balance(long * plBalance)
{
    HRESULT hr = E_NOTIMPL;

    LOG((MSP_TRACE, "CAudioRenderTerminal::get_Balance - enter"));
    LOG((MSP_TRACE, "CAudioRenderTerminal::get_Balance - exit 0x%08x", hr));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CAudioRenderTerminal::put_Balance(long lBalance)
{
    HRESULT hr = E_NOTIMPL;

    LOG((MSP_TRACE, "CAudioRenderTerminal::put_Balance - enter"));
    LOG((MSP_TRACE, "CAudioRenderTerminal::put_Balance - exit 0x%08x", hr));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP
CAudioRenderTerminal::get_WaveId(
    OUT long * plWaveId
    )
{
    LOG((MSP_TRACE, "CAudioRenderTerminal::get_WaveId - enter"));

    CLock lock(m_CritSec);

    //
    // Parameter checks.
    //

    if ( MSPB_IsBadWritePtr(plWaveId, sizeof(long)) )
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::get_WaveId - "
            "bad pointer argument"));

        return E_POINTER;
    }

    //
    // Check the moniker pointer.
    //

    if ( IsBadReadPtr( m_pMoniker, sizeof(IMoniker) ) )
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::get_WaveId - "
            "bad moniker pointer - exit E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    //
    // Get a property bag from the moniker.
    //

    IPropertyBag * pBag;

    HRESULT hr = m_pMoniker->BindToStorage(0,
                                           0,
                                           IID_IPropertyBag,
                                           (void **) &pBag);
    
    if ( FAILED(hr) ) 
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::get_WaveId - "
            "can't get property bag - exit 0x%08x", hr));

        return hr;
    }

    //
    // Get the ID from the property bag.
    //

    VARIANT var;

    var.vt = VT_I4;

    hr = pBag->Read(
        L"WaveOutId",
        &var,
        0);

    pBag->Release();

    if ( FAILED(hr) ) 
    {
        LOG((MSP_ERROR, "CAudioRenderTerminal::get_WaveId - "
            "can't read wave ID - exit 0x%08x", hr));

        return hr;
    }

    *plWaveId = (long) var.lVal;

    LOG((MSP_TRACE, "CAudioRenderTerminal::get_WaveId - exit S_OK"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mspbase\mspthrd.cpp ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    mspthrd.cpp

Abstract:

    Implementation for MSP thread management classes.

--*/

#include "precomp.h"
#pragma hdrstop

#include <dbt.h>


CMSPThread g_Thread;

extern "C" DWORD WINAPI gfThreadProc(LPVOID p)
{
    return ((CMSPThread *)p)->ThreadProc();
}

HRESULT CMSPThread::Start()
/*++

Routine Description:

    Create the thread if it has not already been created. Otherwise, just
    keep track of how many times the thread start was performed so that
    we only stop the thread when all of these have been paired with a stop.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CMSPThread::Start - enter"));

    CLock Lock(m_CountLock);

    if ( m_iStartCount == 0 )
    {

        _ASSERTE(m_hCommandEvent == NULL);
        _ASSERTE(m_hThread == NULL);


        TCHAR *ptczEventName = NULL;

#if DBG

        //
        // in debug build, use named events
        //

        TCHAR tszEventName[MAX_PATH];

        _stprintf(tszEventName,
            _T("CMSPThread_CommandEvent_pid[0x%lx]CMSPThread[%p]"),
            GetCurrentProcessId(), this);

        LOG((MSP_TRACE, "CMSPThread::Start - creating event[%S]", tszEventName));

        ptczEventName = &tszEventName[0];

#endif


        if ((m_hCommandEvent = ::CreateEvent(
            NULL, 
            FALSE,          // flag for manual-reset event
            FALSE,          // initial state is not set.
            ptczEventName   // No name in release builds, named in debug builds
            )) == NULL)
        {
            LOG((MSP_ERROR, "Can't create the command event"));
            return E_FAIL;
        }

        DWORD dwThreadID;
        m_hThread = ::CreateThread(NULL, 0, gfThreadProc, this, 0, &dwThreadID);

        if (m_hThread == NULL)
        {
            LOG((MSP_ERROR, "Can't create thread.  %ld", GetLastError()));
            return E_FAIL;
        }
    }

    m_iStartCount++;

    LOG((MSP_TRACE, "CMSPThread::Start - exit S_OK"));
    return S_OK;
}

HRESULT CMSPThread::Stop()
/*++

Routine Description:

    Stop the thread.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CMSPThread::Stop - enter"));

    CLock Lock(m_CountLock);

    //
    // Complain if we get more Stops than Starts.
    //

    if ( m_iStartCount == 0 )
    {
        LOG((MSP_ERROR, "CMSPThread::Stop - thread already stopped - "
            "exit E_FAIL"));
        return E_FAIL;
    }

    //
    // Decrement the start count. Due to the above check we should
    // never go below zero.
    //

    m_iStartCount--;

    _ASSERTE( m_iStartCount >= 0 );

    //
    // If there have now been just as many stops as starts, it's time to stop
    // the thread.
    //

    if ( m_iStartCount == 0 )
    {
        //
        // Our state should be cleaned up from before.
        //

        _ASSERTE(m_hCommandEvent != NULL);
        _ASSERTE(m_hThread != NULL);

        //
        // Allocate a command queue item which we will pass to the thread.
        //

        COMMAND_QUEUE_ITEM * pItem = new COMMAND_QUEUE_ITEM;

        if ( ! pItem )
        {
            LOG((MSP_ERROR, "CMSPThread::Stop - allocate new queue item"));

            return E_OUTOFMEMORY;
        }

        pItem->node.cmd = STOP;

        //
        // Put the command queue item in the command queue.
        //

        m_QueueLock.Lock();
        InsertTailList(&m_CommandQueue, &(pItem->link));
        m_QueueLock.Unlock();

        //
        // Signal thread to process this stop command.
        //

        if (SignalThreadProc() == 0)
        {
            LOG((MSP_ERROR, "CMSPThread::Stop - can't signal the thread - "
                "exit E_FAIL"));

            return E_FAIL;
        }

        //
        // Wait until the thread stops
        //

        if (::WaitForSingleObject(m_hThread, INFINITE) != WAIT_OBJECT_0)
        {
            LOG((MSP_ERROR, "CMSPThread::Stop - timeout while waiting for the "
                "thread to stop"));
        }

        //
        // Clean up our state.
        //

        ::CloseHandle(m_hCommandEvent);
        ::CloseHandle(m_hThread);

        m_hCommandEvent     = NULL;
        m_hThread           = NULL;

    }

    LOG((MSP_TRACE, "CMSPThread::Stop - exit S_OK"));
    return S_OK;
}

HRESULT CMSPThread::Shutdown()
/*++

Routine Description:

    Unconditionally shutdown the thread. MSPs should by default use Stop()
    instead of Shutdwon(), unless they cannot do matched Start() / Stop()
    calls because of some other issue.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CMSPThread::Shutdown - enter"));

    CLock Lock(m_CountLock);

    //
    // Ignore if we are not started.
    //

    if ( m_iStartCount == 0 )
    {
        LOG((MSP_ERROR, "CMSPThread::Shutdown - thread already stopped - "
            "exit S_OK"));
 
        return S_OK;
    }

    //
    // We are started, so stop now, irrespective of the outstanding start
    // count.
    //

    m_iStartCount = 1;

    HRESULT hr = Stop();
    
    LOG((MSP_(hr), "CMSPThread::Shutodwn - exit 0x%08x", hr));

    return hr;
}

HRESULT CMSPThread::ThreadProc()
/*++

Routine Description:

    the main loop of this thread.

Arguments:
    
Return Value:

    HRESULT.

--*/
{

    LOG((MSP_TRACE, "CMSPThread::ThreadProc - started"));


    BOOL bExitFlag = FALSE;

    m_hDevNotifyVideo = NULL;
    m_hDevNotifyAudio = NULL;
    m_hWndNotif = NULL;


    HRESULT hr = E_FAIL;

    if (FAILED(hr = ::CoInitializeEx(NULL, COINIT_MULTITHREADED)))
    {
        LOG((MSP_ERROR, "CMSPThread::ThreadProc - ConinitialzeEx failed:%x",
            hr));

        return hr;
    }


    //
    // Create a window to receive PNP device notifications. 
    //
    // since this is a base class that is used by more than one msp, we want 
    // to make sure that each msp registers a window class with a unique name
    // 
    // for this reason window class name is derived from threadid.
    //

    DWORD dwThreadID = GetCurrentThreadId();


    //
    // the string needs to be big enough to hold max dword number in hex + 
    // terminating zero. 20 is more than enough.
    //

    TCHAR szWindowClassName[20];

    _stprintf(szWindowClassName, _T("%lx"), dwThreadID);


    //
    // configure window class structure for RegisterClass
    //

    WNDCLASS wc;

    ZeroMemory(&wc, sizeof(wc));

    wc.lpfnWndProc = NotifWndProc;
    wc.lpszClassName = szWindowClassName;

    
    //
    // perform the actual registration
    //

    ATOM atomClassRegistration = 0;

    atomClassRegistration = RegisterClass(&wc);

    if (0 == atomClassRegistration)
    {
        LOG((MSP_ERROR, 
            "CMSPThread::ThreadProc - RegisterClass failed, last error %ld", 
            GetLastError()));
        
        hr = E_FAIL;
        goto exit;
    }
    

    //
    // create window that will receive pnp notifications
    //

    m_hWndNotif = CreateWindow(szWindowClassName, _T("MSP PNP Notification Window"), 0,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, NULL, this);

    if (m_hWndNotif == NULL)
    {
        LOG((MSP_ERROR, "CMSPThread::ThreadProc - can't create notification window"));
        hr = E_FAIL;
        goto exit;
    }


    //
    // success
    //

    LOG((MSP_TRACE, "CMSPThread::ThreadProc - created notification window"));


    //
    // Register to receive PNP device notifications
    //
    DEV_BROADCAST_DEVICEINTERFACE NotificationFilter;

    ZeroMemory( &NotificationFilter, sizeof(NotificationFilter) );
    NotificationFilter.dbcc_size = 
        sizeof(DEV_BROADCAST_DEVICEINTERFACE);
    NotificationFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    NotificationFilter.dbcc_classguid = AM_KSCATEGORY_VIDEO;

    if ((m_hDevNotifyVideo = RegisterDeviceNotification( m_hWndNotif, 
        &NotificationFilter,
        DEVICE_NOTIFY_WINDOW_HANDLE
        )) == NULL)
    {
        LOG((MSP_ERROR, "CMSPThread::ThreadProc - can't register for video device notification"));
        hr = E_FAIL;
        goto exit;
    }

    NotificationFilter.dbcc_classguid = AM_KSCATEGORY_AUDIO;

    if ((m_hDevNotifyAudio = RegisterDeviceNotification( m_hWndNotif, 
        &NotificationFilter,
        DEVICE_NOTIFY_WINDOW_HANDLE
        )) == NULL)
    {
        LOG((MSP_ERROR, "CMSPThread::ThreadProc - can't register for audio device notification"));
        hr = E_FAIL;
        goto exit;
    }
    
    LOG((MSP_TRACE, "CMSPThread::ThreadProc - registered for PNP device notifications"));

    while (!bExitFlag)
    {
        //
        // Msg:      Grab window messages.
        // Multiple: We only use 1, but Msg and Ex only exist with Multiple.
        // Ex:       Allow flags, so we can pass in MWMO_ALERTABLE.
        //
        
        DWORD dwResult = ::MsgWaitForMultipleObjectsEx(
            1,                // wait for one event
            &m_hCommandEvent, // array of events to wait for
            INFINITE,         // wait forever
            QS_ALLINPUT,      // get all window messages
            MWMO_ALERTABLE    // get APC requests (in case this MSP uses them)
            );

        if ( ( dwResult == WAIT_OBJECT_0 ) || ( dwResult == WAIT_OBJECT_0 + 1 ) )
        {
            LOG((MSP_TRACE, "thread is signaled"));

            m_QueueLock.Lock();
            
            while ( ! IsListEmpty(&m_CommandQueue) )
            {

                LIST_ENTRY * links = RemoveHeadList( &m_CommandQueue );
                
                m_QueueLock.Unlock();
            
                COMMAND_QUEUE_ITEM * pItem =
                    CONTAINING_RECORD(links,
                                      COMMAND_QUEUE_ITEM,
                                      link);

                COMMAND_NODE * pNode = &(pItem->node);

                switch (pNode->cmd)
                {

                case WORK_ITEM:
                
                    LOG((MSP_TRACE, "CMSPThread::ThreadProc - "
                        "got command WORK_ITEM"));

                    pNode->pfn( pNode->pContext );

                    if ( pNode->hEvent != NULL )
                    {
                        if ( SetEvent( pNode->hEvent ) == 0 )
                        {
                            LOG((MSP_ERROR, "CMSPThread::ThreadProc - "
                                "can't signal event for synchronous work "
                                "item"));
                        }
                    }
                    break;

                case STOP:
                    
                    LOG((MSP_TRACE, "CMSPThread::ThreadProc - "
                        "thread is exiting"));

                    bExitFlag = TRUE;
                    break;
                }

                delete pItem;
            
                m_QueueLock.Lock();

            }
            m_QueueLock.Unlock();
            

            //
            // We have processed all commands and unblocked everyone
            // who is waiting for us. Now check for window messages.
            //

            MSG msg;

            // Retrieve the next item in the message queue.

            while ( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
        else if ( dwResult == WAIT_IO_COMPLETION )
        {
            // FEATUREFEATURE: The base MSP does not do anything with APC /
            // async I/O. If the derived MSP does something with it, they must
            // implement this to take appropriate action. Question is, how
            // best to expose this to the derived MSP? We could have a method
            // to override, but then how would the derived thread class get
            // instantiated? Instead, we'll have to have a method to set
            // an async I/O completion callback function pointer.
        }
        else
        {
            LOG((MSP_ERROR, "CMSPThread::ThreadProc - "
                "WaitForMultipleObjects failed  %ld", GetLastError()));

            break;
        }
    }

    hr = S_OK;

exit:

    

    //
    //  cleanup: 
    //
    //  Unregister from PNP device notifications
    //  destroy window
    //  unregister window class
    //  couninitialize
    //


    //
    // unregister from video pnp events if needed
    //

    if ( NULL != m_hDevNotifyVideo )
    {
        HRESULT hr2 = UnregisterDeviceNotification(m_hDevNotifyVideo);

        if (FAILED(hr2))
        {

            LOG((MSP_ERROR,
                "CMSPThread::ThreadProc - UnregisterDeviceNotification failed for video events. "
                "hr = %lx", hr2));
        }
    }

    
    //
    // unregister from audio pnp events if needed
    //

    if ( NULL != m_hDevNotifyAudio )
    {

        HRESULT hr2 = UnregisterDeviceNotification(m_hDevNotifyAudio);

        if (FAILED(hr2))
        {

            LOG((MSP_ERROR, 
                "CMSPThread::ThreadProc - UnregisterDeviceNotification failed for audio events. "
                "hr = %lx", hr2));
        }
    }

    
    //
    // destroy window if needed
    //

    if ( NULL != m_hWndNotif )
    {
        
        BOOL bDestroyWindowSuccess = DestroyWindow(m_hWndNotif);

        if ( ! bDestroyWindowSuccess )
        {
            LOG((MSP_ERROR, 
                "CMSPThread::ThreadProc - DestroyWindow failed. LastError = %ld",
                GetLastError()));
        }
    }


    //
    // unregister window class
    //

    if (0 != atomClassRegistration)
    {

        BOOL bUnregisterSuccess = UnregisterClass( (LPCTSTR)atomClassRegistration, ::GetModuleHandle(NULL) );

        if ( ! bUnregisterSuccess )
        {
            LOG((MSP_ERROR, 
                "CMSPThread::ThreadProc - UnregisterClass failed. LastError = %ld", 
                GetLastError()));
        }
    }


    ::CoUninitialize();

    LOG((MSP_(hr), "CMSPThread::ThreadProc - exit. hr = 0x%lx", hr));

    return hr;
}

HRESULT CMSPThread::QueueWorkItem(
    LPTHREAD_START_ROUTINE Function,
    PVOID Context,
    BOOL  fSynchronous
    )
{
    LOG((MSP_TRACE, "CMSPThread::QueueWorkItem - enter"));


    //
    // Create a command block for this.
    //

    COMMAND_QUEUE_ITEM * pItem = new COMMAND_QUEUE_ITEM;

    if ( ! pItem )
    {
        LOG((MSP_ERROR, "CMSPThread::QueueWorkItem - "
            "can't allocate new queue item - exit E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }


    //
    // Create an event to wait on if this is a synchronous work item.
    // Otherwise the thread proc gets a NULL event handle and it knows not to
    // signal it since it's an asynchronous work item.
    //

    TCHAR *ptczEventName = NULL;

#if DBG

    static LONG lSequenceNumber = 0;


    //
    // in debug build, use named events
    //

    TCHAR tszEventName[MAX_PATH];

    InterlockedIncrement(&lSequenceNumber);


    //
    // identify events by the address of the correspoding queue item, and by 
    // the sequence number
    //

    _stprintf(tszEventName,
        _T("CMSPThread_QueueWorkitemEvent_pid[0x%lx]_CMSPThread[%p]_Event[%p]_eventNumber[%lu]"),
        GetCurrentProcessId(), this, pItem, lSequenceNumber);

    LOG((MSP_TRACE, "CMSPThread::QueueWorkItem - creating event[%S]", tszEventName));

    ptczEventName = &tszEventName[0];

#endif


    HANDLE hEvent = NULL;

    if (fSynchronous)
    {
        hEvent = ::CreateEvent(NULL, 
                               FALSE,           // flag for manual-reset event 
                               FALSE,           // initial state is not set.
                               ptczEventName);  // No name in release, named in debug

        if ( hEvent == NULL )
        {
            LOG((MSP_ERROR, "CMSPThread::QueueWorkItem - "
                "Can't create the Job Done event"));

            delete pItem;
            pItem = NULL;

            return E_FAIL;
        }
    }


    //
    // we already have the q item, now initialize it.
    //

    pItem->node.cmd        = WORK_ITEM;
    pItem->node.pfn        = Function;
    pItem->node.pContext   = Context;
    pItem->node.hEvent     = hEvent;


    //
    // Put the command block on the queue. The queue is protected by a
    // critical section.
    //

    m_QueueLock.Lock();
    InsertTailList(&m_CommandQueue, &(pItem->link));


    //
    // Signal the thread to process the command.
    //

    if (SignalThreadProc() == 0)
    {

        //
        // failed to signal processing thread
        // cleanup and return error
        //

        
        //
        // remove the queue entry we have submitted
        //

        RemoveTailList(&m_CommandQueue);


        //
        // unlock the queue so other threads can use it
        //

        m_QueueLock.Unlock();


        //
        // close handle and delete pItem that we have created -- 
        // no one else is going to do this for us
        //

        if (NULL != hEvent)
        {
            ::CloseHandle(hEvent);
            hEvent = NULL;
        }

        delete pItem;
        pItem = NULL;


        LOG((MSP_ERROR, "CMSPThread::QueueWorkItem - "
            "can't signal the thread"));

        return E_FAIL;
    }


    //
    // unlock the event queue, so it can be used by processing and other 
    // threads
    //

    m_QueueLock.Unlock();


    //
    // If this is a sychronous work item, wait for it to complete and
    // then close the event handle.
    //
    // FEATUREFEATURE: Rather than creating and deleting an event for each
    // work item, have a cache of events that can be reused.
    //

    if (fSynchronous)
    {
        LOG((MSP_TRACE, "CMSPThread::QueueWorkItem - "
            "blocked waiting for synchronous work item to complete"));
        
        // Wait for the synchronous work item to complete.

        HANDLE hEvents[2];
        DWORD dwEvent;

        hEvents[0] = hEvent;
        hEvents[1] = m_hThread;

        dwEvent = WaitForMultipleObjects( 
            2,
            hEvents,
            FALSE,
            INFINITE);

        switch (dwEvent)
        {
        case WAIT_OBJECT_0 + 0:
            break;

        case WAIT_OBJECT_0 + 1:
            LOG((MSP_ERROR, "CMSPThread::QueueWorkItem - "
                "thread exited"));

            //
            // if the item is still in the queue, remove it (since the thread 
            // won't)
            //

            m_QueueLock.Lock();
            
            if (IsNodeOnList(&m_CommandQueue, &(pItem->link)))
            {
                RemoveEntryList(&(pItem->link));
                delete pItem;
            }

            m_QueueLock.Unlock();
          

            //
            // time to close event and fail
            //

            ::CloseHandle(hEvent);

            return E_FAIL;        

        default:
            LOG((MSP_ERROR, "CMSPThread::QueueWorkItem - "
                "WaitForSingleObject failed"));
        }

        ::CloseHandle(hEvent);
    }

    LOG((MSP_TRACE, "CMSPThread::QueueWorkItem - exit S_OK"));

    return S_OK;
}

LRESULT CALLBACK CMSPThread::NotifWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{ 
    PNOTIF_LIST pnl;

    if (uMsg == WM_CREATE)
    {
        SetLastError(0);
        if (!SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)(((LPCREATESTRUCT)lParam)->lpCreateParams)))
        {
            if (GetLastError())  // It isn't really an error unless get last error says so
            {
                LOG((MSP_ERROR, "CMSPThread::NotifWndProc - SetWindowLongPtr failed %ld", GetLastError()));
                _ASSERTE(FALSE);
                return -1;
            }
        }
    }
    else
    {
        CMSPThread *me = (CMSPThread*)GetWindowLongPtr(hwnd, GWLP_USERDATA);

        switch (uMsg) 
        { 
            case WM_DEVICECHANGE: 
                switch(wParam)
                {
                case DBT_DEVICEARRIVAL:
                    LOG((MSP_TRACE, "CMSPThread::NotifWndProc - DBT_DEVICEARRIVAL"));

                    me->m_NotifLock.Lock();
                
                    pnl = me->m_NotifList;
                    while (pnl != NULL)
                    {
                        pnl->addr->PnpNotifHandler(TRUE);
                        pnl = pnl->next;
                    }

                    me->m_NotifLock.Unlock();
                    break;

                case DBT_DEVICEREMOVECOMPLETE:
                    LOG((MSP_TRACE, "CMSPThread::NotifWndProc - DBT_DEVICEREMOVECOMPLETE"));

                    me->m_NotifLock.Lock();
                
                    pnl = me->m_NotifList;
                    while (pnl != NULL)
                    {
                        pnl->addr->PnpNotifHandler(FALSE);
                        pnl = pnl->next;
                    }

                    me->m_NotifLock.Unlock();
                    break;
                }

                return 0; 
 
            case WM_DESTROY: 
                return 0; 
 
            default: 
                return DefWindowProc(hwnd, uMsg, wParam, lParam); 
        } 
    }
    return 0; 
} 

HRESULT CMSPThread::RegisterPnpNotification(CMSPAddress *pCMSPAddress)
{
    PNOTIF_LIST pnl;
    HRESULT hr;

    if (IsBadReadPtr(pCMSPAddress, sizeof(CMSPAddress)))
    {
        LOG((MSP_ERROR, "CMSPThread::RegisterPnpNotification - bad address pointer"));
        return E_POINTER;
    }
    
    m_NotifLock.Lock();

    // Add a new node to the list
    pnl = new NOTIF_LIST;

    if (pnl == NULL)
    {
        LOG((MSP_ERROR, "CMSPThread::RegisterPnpNotification - out of memory"));
        hr = E_OUTOFMEMORY;
    }
    else
    {


        //
        // note that we don't keep addref the address -- it is the 
        // caller's responsibility to ensure we are notified through 
        // UnregisterPnpNotification when the address is going away
        //

        pnl->next = m_NotifList;
        pnl->addr = pCMSPAddress;
        m_NotifList = pnl;
        hr = S_OK;
    }

    m_NotifLock.Unlock();
    return hr;
}

HRESULT CMSPThread::UnregisterPnpNotification(CMSPAddress *pCMSPAddress)
{
    PNOTIF_LIST pnl, pnlLast;
    HRESULT hr = E_FAIL;

    if (IsBadReadPtr(pCMSPAddress, sizeof(CMSPAddress)))
    {
        LOG((MSP_ERROR, "CMSPThread::UnregisterPnpNotification - bad address pointer"));
        return E_POINTER;
    }
    
    m_NotifLock.Lock();

    pnl = m_NotifList;

    if ((pnl != NULL) && (pnl->addr == pCMSPAddress))
    {
        // It is fist in the list, remove it
        m_NotifList = pnl->next;
        delete pnl;

        hr = S_OK;
    }
    else while (pnl != NULL)
    {
        pnlLast = pnl;
        pnl = pnl->next;

        if ((pnl != NULL) && (pnl->addr == pCMSPAddress))
        {
            // Found it in the list, remove it
            pnlLast->next = pnl->next;
            delete pnl;

            hr = S_OK;

            break;
        }
    }

    if (pnl == NULL)
    {
        LOG(( MSP_WARN, "CMSPThread::UnregisterPnpNotification - address pointer not found in notification list." ));
        hr = E_FAIL;
    }

    m_NotifLock.Unlock();
    return hr;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mspbase\mspterm.cpp ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    mspterm.cpp

Abstract:

    Implementations for the CBaseTerminal, CSingleFilterTerminal, and various
    work item / worker thread classes.

--*/

#include "precomp.h"
#pragma hdrstop

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CBaseTerminal::CBaseTerminal()
            : m_TerminalDirection(TD_CAPTURE)
            , m_TerminalType(TT_STATIC)
            , m_TerminalState(TS_NOTINUSE)
            , m_TerminalClassID(CLSID_NULL)
            , m_pFTM(NULL)
{
    LOG((MSP_TRACE, "CBaseTerminal::CBaseTerminal() called"));

    HRESULT hr = CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pFTM);

    if ( FAILED(hr) )
    {
        LOG((MSP_TRACE, "CBaseTerminal::CBaseTerminal() - create ftm failed"));
    }
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CBaseTerminal::~CBaseTerminal()
{
    if (NULL != m_pFTM)
    {
         m_pFTM->Release();
    }
    
    LOG((MSP_TRACE, "CBaseTerminal::~CBaseTerminal() finished"));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//
// Dynamic terminals that support only one direction must override this to check
// if the direction is valid (although the terminal manager is supposed to
// ensure that the wrong direction is never passed). Dynamic terminal might want
// to override this for other reasons too (create filters now, etc.).
//
// Static terminals normally just call this in their CreateTerminal().
//
    
HRESULT CBaseTerminal::Initialize(
            IN  IID                   iidTerminalClass,
            IN  DWORD                 dwMediaType,
            IN  TERMINAL_DIRECTION    Direction,
            IN  MSP_HANDLE            htAddress
            )
{
    CLock lock(m_CritSec);

    LOG((MSP_TRACE, "CBaseTerminal::Initialize - enter"));

    //
    // Check if the media type is supported by this terminal.
    //

    if ( ! MediaTypeSupported( (long) dwMediaType) )
    {
        LOG((MSP_ERROR, "CBaseTerminal::Initialize - "
            "media type not supported - returning E_INVALIDARG"));
        return E_INVALIDARG;
    }

    //
    // Save this configurarion.
    //

    m_dwMediaType       = dwMediaType;
    m_TerminalDirection = Direction;
    m_TerminalClassID   = iidTerminalClass;
    m_htAddress         = htAddress;

    LOG((MSP_TRACE, "CBaseTerminal::Initialize - exit S_OK"));
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CBaseTerminal::get_AddressHandle (
        OUT     MSP_HANDLE    * phtAddress
        )
{
    CLock lock(m_CritSec);

    LOG((MSP_TRACE, "CBaseTerminal::get_AddressHandle - enter"));

    if ( MSPB_IsBadWritePtr( phtAddress, sizeof(MSP_HANDLE) ) )
    {
        LOG((MSP_ERROR, "CBaseTerminal::get_AddressHandle - returning E_POINTER")); 
        return E_POINTER;
    }

    *phtAddress = m_htAddress;

    LOG((MSP_TRACE, "CBaseTerminal::get_AddressHandle - exit S_OK"));
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CBaseTerminal::get_Name(BSTR * pbsName)
{
    CLock lock(m_CritSec);

    LOG((MSP_TRACE, "CBaseTerminal::get_Name - enter"));

    if ( MSPB_IsBadWritePtr( pbsName, sizeof(BSTR) ) )
    {
        LOG((MSP_ERROR, "CBaseTerminal::get_Name - "
            "bad BSTR passed in - returning E_POINTER")); 

        return E_POINTER;
    }

    *pbsName = SysAllocString(m_szName);

    if ( *pbsName == NULL )
    {
        LOG((MSP_ERROR, "CBaseTerminal::get_Name - "
            "can't sysallocstring - returning E_OUTOFMEMORY")); 

        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CBaseTerminal::get_Name - exit S_OK"));
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CBaseTerminal::get_State(TERMINAL_STATE * pVal)
{
    CLock lock(m_CritSec);

    LOG((MSP_TRACE, "CBaseTerminal::get_State - enter"));

    if ( MSPB_IsBadWritePtr( pVal, sizeof(TERMINAL_STATE) ) )
    {
        LOG((MSP_ERROR, "CBaseTerminal::get_State - returning E_POINTER")); 
        return E_POINTER;
    }

    *pVal = m_TerminalState;

    LOG((MSP_TRACE, "CBaseTerminal::get_State - exit S_OK"));
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CBaseTerminal::get_TerminalType(TERMINAL_TYPE * pVal)
{
    CLock lock(m_CritSec);

    LOG((MSP_TRACE, "CBaseTerminal::get_TerminalType - enter"));
    
    if ( MSPB_IsBadWritePtr( pVal, sizeof(TERMINAL_TYPE) ) )
    {
        LOG((MSP_ERROR, "CBaseTerminal::get_TerminalType - returning E_POINTER")); 
        return E_POINTER;
    }

    *pVal = m_TerminalType;

    LOG((MSP_TRACE, "CBaseTerminal::get_TerminalType - exit S_OK"));
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CBaseTerminal::get_TerminalClass(BSTR * pbsClassID)
{
    CLock lock(m_CritSec);

    LOG((MSP_TRACE, "CBaseTerminal::get_TerminalClass - enter"));

    if ( MSPB_IsBadWritePtr( pbsClassID, sizeof(BSTR) ) )
    {
        LOG((MSP_ERROR, "CBaseTerminal::get_TerminalClass - returning E_POINTER")); 
        return E_POINTER;
    }

    //
    // Convert the CLSID to an OLE string.
    //

    LPOLESTR lposClass = NULL;
    HRESULT hr = StringFromCLSID(m_TerminalClassID, &lposClass);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CBaseTerminal::get_TerminalClass (StringFromCLSID) - returning  %8x", hr));
        return hr;
    }

    //
    // Put the string in a BSTR.
    //

    *pbsClassID = ::SysAllocString(lposClass);

    //
    // Free the OLE string.
    //

    ::CoTaskMemFree(lposClass);

    if (*pbsClassID == NULL)
    {
        LOG((MSP_ERROR, "CBaseTerminal::get_TerminalClass - returning E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_TRACE, "CBaseTerminal::get_TerminalClass - exit S_OK"));
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CBaseTerminal::get_Direction(
    OUT  TERMINAL_DIRECTION *pDirection
    )
{   
    CLock lock(m_CritSec);

    LOG((MSP_TRACE, "CBaseTerminal::get_Direction - enter"));

    if ( MSPB_IsBadWritePtr( pDirection, sizeof(TERMINAL_DIRECTION) ) )
    {
        LOG((MSP_ERROR, "CBaseTerminal::get_Direction - returning E_POINTER"));
        return E_POINTER;
    }

    *pDirection = m_TerminalDirection;

    LOG((MSP_TRACE, "CBaseTerminal::get_Direction - exit S_OK"));
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// enters each of the internal filters into the filter graph
// connects the internal filters together (if applicable)
// and returns all the filters to be used as connection points
STDMETHODIMP CBaseTerminal::ConnectTerminal(
        IN      IGraphBuilder  * pGraph,
        IN      DWORD            dwTerminalDirection,
        IN OUT  DWORD          * pdwNumPins,
        OUT     IPin          ** ppPins
        )
{
    LOG((MSP_TRACE, "CBaseTerminal::ConnectTerminal - enter"));
    
    //
    // Check parameters.
    //

    if ( IsBadReadPtr(pGraph, sizeof(IGraphBuilder) ) )
    {
        LOG((MSP_ERROR, "CBaseTerminal::ConnectTerminal - "
            "bad graph pointer; exit E_POINTER"));
        
        return E_POINTER;
    }

    if ( MSPB_IsBadWritePtr(pdwNumPins, sizeof(DWORD) ) )
    {
        LOG((MSP_ERROR, "CBaseTerminal::ConnectTerminal - "
            "bad numpins pointer; exit E_POINTER"));

        return E_POINTER;
    }

    //
    // Find out how many pins we expose. For most terminals this is
    // straightforward but we pass in the graph pointer in case they
    // need to do something funky to figure this out.
    //

    DWORD dwActualNumPins;

    HRESULT hr;

    hr = GetNumExposedPins(pGraph, &dwActualNumPins);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CBaseTerminal::ConnectTerminal - "
            "GetNumExposedPins failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // If ppPins is NULL, just return the number of pins and don't try to
    // connect the terminal.
    //

    if ( ppPins == NULL )
    {
        LOG((MSP_TRACE, "CBaseTerminal::ConnectTerminal - "
            "returned number of exposed pins - exit S_OK"));

        *pdwNumPins = dwActualNumPins;
        
        return S_OK;
    }

    //
    // Otherwise, we have a pin return buffer. Check that the purported buffer
    // size is big enough and that the buffer is actually writable to the size
    // we need.
    //

    if ( *pdwNumPins < dwActualNumPins )
    {
        LOG((MSP_ERROR, "CBaseTerminal::ConnectTerminal - "
            "not enough space to place pins; exit TAPI_E_NOTENOUGHMEMORY"));

        *pdwNumPins = dwActualNumPins;
        
        return TAPI_E_NOTENOUGHMEMORY;
    }

    if ( MSPB_IsBadWritePtr(ppPins, dwActualNumPins * sizeof(IPin *) ) )
    {
        LOG((MSP_ERROR, "CBaseTerminal::ConnectTerminal - "
            "bad pins array pointer; exit E_POINTER"));

        return E_POINTER;
    }

    //
    // Check if we're already connected, and if so, change our state to
    // connected. Note that this makes sense for both core static terminals
    // and dynamic terminals. Also note that we need to protect this with
    // a critical section, but after this we can let go of the lock because
    // anyone who subsequently enters the critical section will bail at this
    // point.
    //

    {
        CLock lock(m_CritSec);

        //
        // check if already connected
        //

        if (TS_INUSE == m_TerminalState)
        {
            LOG((MSP_ERROR, "CBaseTerminal::ConnectTerminal - "
                "terminal already in use; exit TAPI_E_TERMINALINUSE"));

            return TAPI_E_TERMINALINUSE;
        }

        //
        // Save important state.
        //

        m_pGraph        = pGraph;
        m_TerminalState = TS_INUSE;
    }


    // add filters to the filter graph
    hr = AddFiltersToGraph();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CBaseTerminal::ConnectTerminal - "
            "can't add filters to graph"));
        goto disconnect_terminal;
    }

    // Give the terminal a chance to do any preconnection
    hr = ConnectFilters();
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CBaseTerminal::ConnectTerminal - "
            "can't do internal filter connection"));
        goto disconnect_terminal;
    }

    //
    // Get the pins that this filter exposes. No need to pass in
    // the filter graph because we already saved the graph pointer.
    //

    *pdwNumPins = dwActualNumPins;
    hr = GetExposedPins(ppPins);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CBaseTerminal::ConnectTerminal - "
            "can't get exposed pins"));
        goto disconnect_terminal;
    }

    LOG((MSP_TRACE, "CBaseTerminal::ConnectTerminal success"));
    return S_OK;

disconnect_terminal:

    //
    // best effort attempt to disconnect - ignore error code
    //

    DisconnectTerminal(pGraph, 0);

    //
    // Release our reference to the graph and set ourselves to notinuse state.
    // DisconnectTerminal does this on success, but we need to make sure this
    // cleanup happens even if DisconnectTerminal failed.
    //

    m_pGraph        = NULL;          // this releases the CComPtr
    
    m_TerminalState = TS_NOTINUSE;

    LOG((MSP_TRACE, "CBaseTerminal::ConnectTerminal - exit 0x%08x", hr));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP 
CBaseTerminal::CompleteConnectTerminal(void)
{
    LOG((MSP_TRACE, "CBaseTerminal::CompleteConnectTerminal - enter"));
    LOG((MSP_TRACE, "CBaseTerminal::CompleteConnectTerminal - exit S_OK"));
    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// disconnects the internal filters from each other (if applicable)
// and removes them from the filter graph (thus breaking connections to
// the stream).
// Filter graph parameter is used for validation, to make sure the terminal
// is disconnected from the same graph that it was originally connected to.


STDMETHODIMP 
CBaseTerminal::DisconnectTerminal(
        IN      IGraphBuilder  * pGraph,
        IN      DWORD            dwReserved
        )
{
    CLock lock(m_CritSec);

    LOG((MSP_TRACE, "CBaseTerminal::DisconnectTerminal called"));

    //
    // If not in use, then there is nothing to be done.
    //

    if ( TS_INUSE != m_TerminalState ) 
    {
        _ASSERTE(m_pGraph == NULL);

        LOG((MSP_TRACE, "CBaseTerminal::DisconnectTerminal success; not in use"));

        return S_OK;
    }

    //
    // Check that we are being disconnected from the correct graph.
    //
    if ( m_pGraph != pGraph )
    {
        LOG((MSP_TRACE, "CBaseTerminal::DisconnectTerminal - "
            "wrong graph; returning E_INVALIDARG"));
        
        return E_INVALIDARG;
    }

    //
    // Extra sanity check.
    //

    if ( m_pGraph == NULL )
    {
        LOG((MSP_TRACE, "CBaseTerminal::DisconnectTerminal - "
            "no graph; returning E_UNEXPECTED"));
        
        return E_UNEXPECTED;
    }

    HRESULT hr;

    //
    // Remove filters from the graph
    //

    hr = RemoveFiltersFromGraph();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CBaseTerminal::DisconnectTerminal - "
            "remove filters from graph failed; returning 0x%08x", hr));

        return hr;
    }

    //
    // Release our reference to the graph and set ourselves to notinuse state.
    //

    m_pGraph        = NULL;          // this releases the CComPtr
    
    m_TerminalState = TS_NOTINUSE;

    LOG((MSP_TRACE, "CBaseTerminal::DisconnectTerminal success"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CBaseTerminal::get_MediaType(long * plMediaType)
{
    CLock lock(m_CritSec);

    LOG((MSP_TRACE, "CBaseTerminal::get_MediaType - enter"));

    if ( MSPB_IsBadWritePtr(plMediaType, sizeof(long) ) )
    {
        LOG((MSP_ERROR, "CBaseTerminal::get_MediaType - returning E_POINTER"));
        return E_POINTER;
    }
    
    *plMediaType = (long) m_dwMediaType;

    LOG((MSP_TRACE, "CBaseTerminal::get_MediaType - exit S_OK"));
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

BOOL CBaseTerminal::MediaTypeSupported(long lMediaType)
{
    return IsValidSingleMediaType( (DWORD) lMediaType,
                                   GetSupportedMediaTypes() );
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// CSingleFilterTerminal                                                   //
//                                                                         //
// This is a base class for a terminal with a single filter and pin. The   //
// terminal could be any direction or media type, and it could be static   //
// or dynamic.                                                             //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


HRESULT CSingleFilterTerminal::GetNumExposedPins(
        IN   IGraphBuilder * pGraph,
        OUT  DWORD         * pdwNumPins)
{
    LOG((MSP_TRACE, "CSingleFilterTerminal::GetNumExposedPins - enter"));

    //
    // We ignote pGraph because we don't need to do anything special to find
    // out how many pins we have.
    //

    *pdwNumPins = 1;
    
    LOG((MSP_TRACE, "CSingleFilterTerminal::GetNumExposedPins - exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CSingleFilterTerminal::GetExposedPins(
        OUT    IPin  ** ppPins
        )
{
    LOG((MSP_TRACE, "CSingleFilterTerminal::GetExposedPins - enter"));

    _ASSERTE( ! MSPB_IsBadWritePtr(ppPins, 1 * sizeof(IPin *) ) );

    //
    // Return our single pin.
    //

    *ppPins = m_pIPin;
    (*ppPins)->AddRef();

    LOG((MSP_TRACE, "CSingleFilterTerminal::GetExposedPins - exit S_OK"));
    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// stops the rightmost render filter in the terminal
// (needed for dynamic filter graphs)
STDMETHODIMP CSingleFilterTerminal::RunRenderFilter(void)
{
    // check that we're really a render filter

    // tell our single filter to run

    return E_NOTIMPL;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

// stops the rightmost render filter in the terminal
// (needed for dynamic filter graphs)
STDMETHODIMP CSingleFilterTerminal::StopRenderFilter(void)
{
    // check that we're really a render filter

    // tell our single filter to stop

    return E_NOTIMPL;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT 
CSingleFilterTerminal::RemoveFiltersFromGraph(void)
{
    LOG((MSP_TRACE, "CSingleFilterTerminal::RemoveFiltersFromGraph - enter"));

    if (m_pGraph == NULL)
    {
        LOG((MSP_ERROR, "CSingleFilterTerminal::RemoveFiltersFromGraph - "
            "no graph; returning E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    if (m_pIFilter == NULL)
    {
        LOG((MSP_ERROR, "CSingleFilterTerminal::RemoveFiltersFromGraph - "
            "no filter; returning E_UNEXPECTED"));
        return E_UNEXPECTED;
    }

    //
    // Remove the filter from the graph. This also disconnects any connections
    // the filter may have.
    //

    HRESULT hr = m_pGraph->RemoveFilter(m_pIFilter);

    LOG((MSP_TRACE, "CSingleFilterTerminal::RemoveFiltersFromGraph - exit 0x%08x", hr));
    return hr;
}

HRESULT 
CSingleFilterStaticTerminal::CompareMoniker(
                                             IMoniker *pMoniker
                                           )
{
    IMoniker    *pReducedMoniker;
    IMoniker    *pReducedNewMoniker;
    IBindCtx    *pbc; 
    HRESULT     hr;

    hr = CreateBindCtx( 0, &pbc ); 

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CSingleFilterStaticTerminal::CompareMoniker - "
            "unable to create bind context"));
        return hr;
    }

    hr = m_pMoniker->Reduce(pbc ,MKRREDUCE_ALL, NULL, &pReducedMoniker);
    
    if (FAILED(hr) || !pReducedMoniker)
    {
        LOG((MSP_ERROR, "CSingleFilterStaticTerminal::CompareMoniker - "
            "unable to reduce moniker"));
        pbc->Release();  // release the bind context              
        return hr;
    }

    hr = pMoniker->Reduce(pbc ,MKRREDUCE_ALL, NULL, &pReducedNewMoniker);
    
    if (FAILED(hr) || !pReducedNewMoniker)
    {
        LOG((MSP_ERROR, "CSingleFilterStaticTerminal::CompareMoniker - "
            "unable to reduce moniker"));
        pbc->Release();  // release the bind context
        pReducedMoniker->Release();   // release the reduced moniker
        return hr;
    }

    pbc->Release();  // release the bind context
   
    if (pReducedMoniker->IsEqual(pReducedNewMoniker) == S_OK)
    {
        LOG((MSP_TRACE, "CSingleFilterStaticTerminal::CompareMoniker - "
            "exit - return S_OK"));

        pReducedMoniker->Release();   // release the reduced monikers
        pReducedNewMoniker->Release();  
        return S_OK;
    }

    pReducedMoniker->Release();   // release the reduced monikers
    pReducedNewMoniker->Release();

    LOG((MSP_TRACE, "CSingleFilterStaticTerminal::CompareMoniker - "
            "exit - return S_FALSE"));
    return S_FALSE;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mspbase\msputils.cpp ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    MSPutils.cpp

Abstract:
    
    data for msputils.h

--*/
#include "precomp.h"
#pragma hdrstop

#include "mspbase.h"
#include "msputils.h"

CMSPCritSection CMSPObjectSafetyImpl::s_CritSection;


BOOL IsNodeOnList(PLIST_ENTRY ListHead, PLIST_ENTRY Entry)
{
    PLIST_ENTRY pCurrent = ListHead;
    while(pCurrent->Flink != Entry)
    {
        pCurrent = pCurrent->Flink;
        if(pCurrent == 0)
        {
            return FALSE;
        }
    }
    return TRUE;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mspbase\precomp.h ===
#include <mspbase.h>
#include <msptrmac.h>
#include <msptrmar.h>
#include <msptrmvc.h>

#define MSPB_IsBadWritePtr(x, y) IsBadWritePtr((x), (y))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\mspbase\msptrmvc.cpp ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    msptrmvc.cpp

Abstract:

    MSP base classes: implementation of video capture terminal.

--*/


#include "precomp.h"
#pragma hdrstop

#include <amvideo.h>

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

CVideoCaptureTerminal::~CVideoCaptureTerminal()
{
    LOG((MSP_TRACE, "CVideoCaptureTerminal::~CVideoCaptureTerminal() finished"));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CVideoCaptureTerminal::CreateTerminal(
    IN    CComPtr<IMoniker>    pMoniker,
    IN    MSP_HANDLE           htAddress,
    OUT   ITTerminal         **ppTerm
    )
{
    USES_CONVERSION;

    LOG((MSP_TRACE, "CVideoCaptureTerminal::CreateTerminal - enter"));

    //
    // Validate the parameters
    //

    if ( MSPB_IsBadWritePtr(ppTerm, sizeof(ITTerminal *) ) )
    {
        LOG((MSP_ERROR, "CVideoCaptureTerminal::CreateTerminal : "
            "bad terminal pointer; returning E_POINTER"));
        return E_POINTER;
    }

    if ( IsBadReadPtr(pMoniker, sizeof(IMoniker) ) )
    {
        LOG((MSP_ERROR, "CVideoCaptureTerminal::CreateTerminal : "
            "bad moniker pointer; returning E_POINTER"));
        return E_POINTER;
    }

    *ppTerm = NULL;
    HRESULT hr;

    //
    // Get the name for this filter out of the property bag.
    //
    CComPtr<IPropertyBag> pBag;
    hr = pMoniker->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pBag);
    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, 
            "CVideoCaptureTerminal::CreateTerminal (BindToStorage) - returning  %8x", hr));
        return hr;
    }

    VARIANT var;
    var.vt = VT_BSTR;
    hr = pBag->Read(L"FriendlyName", &var, 0);
    if (FAILED(hr)) 
    {
        LOG((MSP_ERROR, "CVideoCaptureTerminal::CreateTerminal (IPropertyBag::Read) - returning  %8x", hr));
        return hr;
    }

    //
    // Create the actual terminal object
    //
    CMSPComObject<CVideoCaptureTerminal> *pLclTerm = new CMSPComObject<CVideoCaptureTerminal>;
    if (pLclTerm == NULL)
    {
        LOG((MSP_ERROR, "CVideoCaptureTerminal::CreateTerminal returning E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    //
    // Save some stuff we'll need later
    //
    pLclTerm->m_pMoniker = pMoniker;
    lstrcpyn(pLclTerm->m_szName, OLE2T(var.bstrVal), MAX_PATH);

    SysFreeString(var.bstrVal);

    //
    // Finally get the ITTerminal interface that we were asked for.
    //
    hr = pLclTerm->_InternalQueryInterface(IID_ITTerminal, (void**)ppTerm);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CVideoCaptureTerminal::CreateTerminal - "
            "Internal QI failed; returning 0x%08x", hr));

        delete pLclTerm;
        return hr;
    }

    //
    // Finish initializing the terminal.
    //

    hr = pLclTerm->Initialize(CLSID_VideoInputTerminal,
                              TAPIMEDIATYPE_VIDEO,
                              TD_CAPTURE,
                              htAddress
                             );
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CVideoCaptureTerminal::CreateTerminal - "
            "Initialize failed; returning 0x%08x", hr));

        (*ppTerm)->Release();
        return hr;
    }

    LOG((MSP_TRACE, "CVideoCaptureTerminal::CreateTerminal - exit S_OK"));
    return S_OK;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Create the filters used by this terminal

HRESULT CVideoCaptureTerminal::CreateFilters()
{
    LOG((MSP_TRACE, "CVideoCaptureTerminal::CreateFilters() - enter"));

    //
    // If we already have the filter, just return S_OK.
    //

    if ( m_pIFilter != NULL )
    {
        LOG((MSP_TRACE, "CVideoCaptureTerminal::CreateFilters() - "
            "already have a filter - exit S_OK"));

        return S_OK;
    }

    //
    // Now make the filter.
    //

    HRESULT hr = m_pMoniker->BindToObject(0, 0, IID_IBaseFilter, (void**)&m_pIFilter);

    if ( FAILED(hr) )
    {
        // reset the filer interface - it's a CComPointer so this releases it

        m_pIFilter = NULL;
 
        LOG((MSP_ERROR, "CVideoCaptureTerminal::CreateFilters() - "
            "BindToObject failed - exit 0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CVideoCaptureTerminal::CreateFilters() - exit S_OK"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT 
CVideoCaptureTerminal::FindCapturePin(
    )
{
    LOG((MSP_TRACE, "CVideoCaptureTerminal::FindCapturePin() - enter"));

    if ( m_pIPin != NULL )
    {
        LOG((MSP_INFO, "CVideoCaptureTerminal::FindCapturePin() - "
            "already called, so we already have a pin - exit S_OK"));

        return S_OK;
    }

    HRESULT hr;
    CComPtr<IEnumPins> pIEnumPins;
    ULONG cFetched;
 
    //
    // Find the capture pin for the filter.
    //

    if (FAILED(hr = m_pIFilter->EnumPins(&pIEnumPins)))
    {
        LOG((MSP_ERROR, 
            "CVideoCaptureTerminal::FindCapturePin - can't enum pins %8x",
            hr));
        return hr;
    }

    IPin * pIPin;

    // Enumerate all the pins and break on the 
    // first pin that meets requirement.
    for (;;)
    {
        if (pIEnumPins->Next(1, &pIPin, &cFetched) != S_OK)
        {
            LOG((MSP_ERROR, 
                "CVideoCaptureTerminal::FindCapturePin - can't get a pin %8x",
                hr));
            return (hr == S_FALSE) ? E_FAIL : hr;
        }

        if (0 == cFetched)
        {
            LOG((MSP_ERROR, "CVideoCaptureTerminal::FindCapturePin - got zero pins"));
            return E_FAIL;
        }

        PIN_DIRECTION dir;

        if (FAILED(hr = pIPin->QueryDirection(&dir)))
        {
            LOG((MSP_ERROR, 
                "CVideoCaptureTerminal::FindCapturePin - can't query pin direction %8x",
                hr));
            pIPin->Release();
            return hr;
        }

        if (PINDIR_OUTPUT == dir)
        {
            break;
        }

        pIPin->Release();
    }

    m_pIPin = pIPin;

    LOG((MSP_TRACE, "CVideoCaptureTerminal::FindCapturePin - exit S_OK"));
  
    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT 
CVideoCaptureTerminal::AddFiltersToGraph(
    )
{
    LOG((MSP_TRACE, "CVideoCaptureTerminal::AddFiltersToGraph called"));
    
    if (m_pGraph == NULL)
    {
        LOG((MSP_ERROR, "CVideoCaptureTerminal::AddFiltersToGraph - "
            "no graph - exit E_UNEXPECTED"));

        return E_UNEXPECTED;
    }

    HRESULT hr;

    hr = CreateFilters();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CVideoCaptureTerminal::AddFiltersToGraph - "
            "CreateFilters failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // Add the filter to the graph.
    //
    // A word about names:
    // If a filter has already been added with the same name (which will
    // happen if we have more than one video capture terminal in the same
    // graph) then that will return VFW_S_DUPLICATE_NAME, which is not
    // a failure.
    //

    try 
    {
        USES_CONVERSION;
        hr = m_pGraph->AddFilter(m_pIFilter, T2CW(m_szName));
    }
    catch (...)
    {
        LOG((MSP_ERROR, "CVideoCaptureTerminal::AddFiltersToGraph - T2CW threw an exception - "
            "return E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CVideoCaptureTerminal::AddFiltersToGraph - "
            "AddFilter failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // set the terminal's capture pin (output pin)
    //

    hr = FindCapturePin();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CVideoCaptureTerminal::AddFiltersToGraph - "
            "FindCapturePin failed - exit 0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CVideoCaptureTerminal::AddFiltersToGraph succeeded"));
    return S_OK;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdp.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdp.cpp

Abstract:


Author:

*/
#include "sdppch.h"
#include <strstrea.h>

#include "sdp.h"
#include "sdpstran.h"



// state transitions for each of the states

const STATE_TRANSITION  g_StateStartTransitions[]       =   {   
    {CHAR_VERSION,       STATE_VERSION} 
};

const STATE_TRANSITION  g_StateVersionTransitions[]     =   {   
    {CHAR_ORIGIN,        STATE_ORIGIN}
};

const STATE_TRANSITION  g_StateOriginTransitions[]      =   {   
    {CHAR_SESSION_NAME,  STATE_SESSION_NAME}
};

const STATE_TRANSITION  g_StateSessionNameTransitions[] =   {   
    {CHAR_TITLE,        STATE_TITLE},
    {CHAR_URI,          STATE_URI},
    {CHAR_EMAIL,        STATE_EMAIL},
    {CHAR_PHONE,        STATE_PHONE},
    {CHAR_CONNECTION,   STATE_CONNECTION} 
};

const STATE_TRANSITION  g_StateTitleTransitions[]       =   {   
    {CHAR_URI,          STATE_URI},
    {CHAR_EMAIL,        STATE_EMAIL},
    {CHAR_PHONE,        STATE_PHONE},
    {CHAR_CONNECTION,   STATE_CONNECTION}   
};

const STATE_TRANSITION  g_StateUriTransitions[]         =   {   
    {CHAR_EMAIL,        STATE_EMAIL},
    {CHAR_PHONE,        STATE_PHONE},
    {CHAR_CONNECTION,   STATE_CONNECTION}   
};

const STATE_TRANSITION  g_StateEmailTransitions[]       =   {   
    {CHAR_EMAIL,        STATE_EMAIL},
    {CHAR_PHONE,        STATE_PHONE},
    {CHAR_CONNECTION,   STATE_CONNECTION}   
};

const STATE_TRANSITION  g_StatePhoneTransitions[]       =   {   
    {CHAR_PHONE,        STATE_PHONE},
    {CHAR_CONNECTION,   STATE_CONNECTION}   
};

const STATE_TRANSITION  g_StateConnectionTransitions[]  =   {  
    {CHAR_BANDWIDTH,    STATE_BANDWIDTH},
    {CHAR_TIME,         STATE_TIME},
    {CHAR_KEY,          STATE_KEY},
    {CHAR_ATTRIBUTE,    STATE_ATTRIBUTE},
    {CHAR_MEDIA,        STATE_MEDIA}        
};

const STATE_TRANSITION  g_StateBandwidthTransitions[]   =   {   
    {CHAR_TIME,         STATE_TIME},
    {CHAR_KEY,          STATE_KEY},
    {CHAR_ATTRIBUTE,    STATE_ATTRIBUTE},
    {CHAR_MEDIA,        STATE_MEDIA}        
};

const STATE_TRANSITION  g_StateTimeTransitions[]        =   {  
    {CHAR_TIME,         STATE_TIME},
    {CHAR_REPEAT,       STATE_REPEAT},
    {CHAR_ADJUSTMENT,   STATE_ADJUSTMENT},
    {CHAR_KEY,          STATE_KEY},
    {CHAR_ATTRIBUTE,    STATE_ATTRIBUTE},
    {CHAR_MEDIA,        STATE_MEDIA}        
};

const STATE_TRANSITION  g_StateRepeatTransitions[]      =   {  
    {CHAR_TIME,         STATE_TIME},
    {CHAR_REPEAT,       STATE_REPEAT},
    {CHAR_ADJUSTMENT,   STATE_ADJUSTMENT},
    {CHAR_KEY,          STATE_KEY},
    {CHAR_ATTRIBUTE,    STATE_ATTRIBUTE},
    {CHAR_MEDIA,        STATE_MEDIA}        
};

const STATE_TRANSITION  g_StateAdjustmentTransitions[]  =   {  
    {CHAR_KEY,          STATE_KEY},
    {CHAR_ATTRIBUTE,    STATE_ATTRIBUTE},
    {CHAR_MEDIA,        STATE_MEDIA}        
};

const STATE_TRANSITION  g_StateKeyTransitions[]         =   {  
    {CHAR_ATTRIBUTE,    STATE_ATTRIBUTE},
    {CHAR_MEDIA,        STATE_MEDIA}        
};

const STATE_TRANSITION  g_StateAttributeTransitions[]   =   {  
    {CHAR_ATTRIBUTE,    STATE_ATTRIBUTE},
    {CHAR_MEDIA,        STATE_MEDIA}        
};

const STATE_TRANSITION  g_StateMediaTransitions[]       =   {  
    {CHAR_MEDIA,        STATE_MEDIA},
    {CHAR_MEDIA_TITLE,  STATE_MEDIA_TITLE},
    {CHAR_MEDIA_CONNECTION, STATE_MEDIA_CONNECTION},
    {CHAR_MEDIA_BANDWIDTH,  STATE_MEDIA_BANDWIDTH},
    {CHAR_MEDIA_KEY,    STATE_MEDIA_KEY},
    {CHAR_MEDIA_ATTRIBUTE,  STATE_MEDIA_ATTRIBUTE} 
};

const STATE_TRANSITION  g_StateMediaTitleTransitions[]  =   {  
    {CHAR_MEDIA,        STATE_MEDIA},
    {CHAR_MEDIA_CONNECTION, STATE_MEDIA_CONNECTION},
    {CHAR_MEDIA_BANDWIDTH,  STATE_MEDIA_BANDWIDTH},
    {CHAR_MEDIA_KEY,    STATE_MEDIA_KEY},
    {CHAR_MEDIA_ATTRIBUTE,  STATE_MEDIA_ATTRIBUTE} 
};

const STATE_TRANSITION  g_StateMediaConnectionTransitions[]= {
    {CHAR_MEDIA,        STATE_MEDIA},
    {CHAR_MEDIA_BANDWIDTH,  STATE_MEDIA_BANDWIDTH},
    {CHAR_MEDIA_KEY,    STATE_MEDIA_KEY},
    {CHAR_MEDIA_ATTRIBUTE,  STATE_MEDIA_ATTRIBUTE} 
};

const STATE_TRANSITION  g_StateMediaBandwidthTransitions[]=  {
    {CHAR_MEDIA,        STATE_MEDIA},
    {CHAR_MEDIA_KEY,    STATE_MEDIA_KEY},
    {CHAR_MEDIA_ATTRIBUTE,  STATE_MEDIA_ATTRIBUTE} 
};


const STATE_TRANSITION  g_StateMediaKeyTransitions[]    =   {  
    {CHAR_MEDIA,        STATE_MEDIA},
    {CHAR_MEDIA_ATTRIBUTE,  STATE_MEDIA_ATTRIBUTE} 
};


const STATE_TRANSITION  g_StateMediaAttributeTransitions[]={ 
    {CHAR_MEDIA,        STATE_MEDIA},
    {CHAR_MEDIA_ATTRIBUTE,  STATE_MEDIA_ATTRIBUTE},    
    {CHAR_MEDIA,        STATE_MEDIA}
};


// const state transition table definition
const TRANSITION_INFO g_TransitionTable[STATE_NUM_STATES] = {
    STATE_TRANSITION_ENTRY(STATE_START,         g_StateStartTransitions),

    STATE_TRANSITION_ENTRY(STATE_VERSION,       g_StateVersionTransitions),

    STATE_TRANSITION_ENTRY(STATE_ORIGIN,        g_StateOriginTransitions),

    STATE_TRANSITION_ENTRY(STATE_SESSION_NAME,  g_StateSessionNameTransitions),

    STATE_TRANSITION_ENTRY(STATE_TITLE,         g_StateTitleTransitions),

    STATE_TRANSITION_ENTRY(STATE_URI,           g_StateUriTransitions),

    STATE_TRANSITION_ENTRY(STATE_EMAIL,         g_StateEmailTransitions),

    STATE_TRANSITION_ENTRY(STATE_PHONE,         g_StatePhoneTransitions),

    STATE_TRANSITION_ENTRY(STATE_CONNECTION,    g_StateConnectionTransitions),

    STATE_TRANSITION_ENTRY(STATE_BANDWIDTH,     g_StateBandwidthTransitions),

    STATE_TRANSITION_ENTRY(STATE_TIME,          g_StateTimeTransitions),

    STATE_TRANSITION_ENTRY(STATE_REPEAT,        g_StateRepeatTransitions),

    STATE_TRANSITION_ENTRY(STATE_ADJUSTMENT,    g_StateAdjustmentTransitions),

    STATE_TRANSITION_ENTRY(STATE_KEY,           g_StateKeyTransitions),

    STATE_TRANSITION_ENTRY(STATE_ATTRIBUTE,     g_StateAttributeTransitions),

    STATE_TRANSITION_ENTRY(STATE_MEDIA,         g_StateMediaTransitions),

    STATE_TRANSITION_ENTRY(STATE_MEDIA_TITLE,   g_StateMediaTitleTransitions),

    STATE_TRANSITION_ENTRY(STATE_MEDIA_CONNECTION,  g_StateMediaConnectionTransitions),

    STATE_TRANSITION_ENTRY(STATE_MEDIA_BANDWIDTH,   g_StateMediaBandwidthTransitions),

    STATE_TRANSITION_ENTRY(STATE_MEDIA_KEY,         g_StateMediaKeyTransitions),

    STATE_TRANSITION_ENTRY(STATE_MEDIA_ATTRIBUTE,   g_StateMediaAttributeTransitions)
};



BOOL
SDP::Init(
    )
{
    // check if already initialized
    if ( NULL != m_MediaList )
    {
        SetLastError(ERROR_ALREADY_INITIALIZED);
        return FALSE;
    }

    // create media and time lists
    // set flags to destroy them when the sdp instance destructs

    try
    {
        m_MediaList = new SDP_MEDIA_LIST;
    }
    catch(...)
    {
        m_MediaList = NULL;
    }

    if ( NULL == m_MediaList )
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    m_DestroyMediaList = TRUE;

    try
    {
        m_TimeList = new SDP_TIME_LIST;
    }
    catch(...)
    {
        m_TimeList = NULL;
    }

    if ( NULL == m_TimeList )
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    m_DestroyTimeList = TRUE;

    return TRUE;
}




// determine the character set implicit from the packet
BOOL
SDP::DetermineCharacterSet(
    IN      CHAR                *SdpPacket,
        OUT SDP_CHARACTER_SET   &CharacterSet
    )
{
    ASSERT(NULL != SdpPacket);

    // search for charset string (attribute "\na=charset:")
    CHAR *AttributeString = strstr(SdpPacket, SDP_CHARACTER_SET_STRING);

    // check if the character set is supplied
    if ( NULL == AttributeString )
    {
        // ASCII is the default character set
        CharacterSet = CS_ASCII;
        return TRUE;
    }
    else
    {
        // the character set attribute string must be present before the first media field
        CHAR *FirstMediaField = strstr(SdpPacket, MEDIA_SEARCH_STRING);

        // there is a media field and it doesn't occur after the character set string, signal error
        if ( (NULL != FirstMediaField)              &&
             (FirstMediaField <= AttributeString)    )
        {
            SetLastError(SDP_INVALID_CHARACTER_SET_FORMAT);
            return FALSE;
        }

        // advance attribute string beyond the attribute specification
        AttributeString += SDP_CHARACTER_SET_STRLEN;

        // compare the character set string with each of the well known
        // character set strings
        for ( UINT i=0; i < NUM_SDP_CHARACTER_SET_ENTRIES; i++ )
        {
            // NOTE: no need to null terminate the character string as
            // strncmp will return on finding the first character that
            // doesn't match
            if ( !strncmp(
                    AttributeString, 
                    SDP_CHARACTER_SET_TABLE[i].m_CharSetString, 
                    SDP_CHARACTER_SET_TABLE[i].m_Length
                    ) )
            {
                CharacterSet = SDP_CHARACTER_SET_TABLE[i].m_CharSetCode;
				return TRUE;
            }
        }

        // unrecognized character set
        SetLastError(SDP_INVALID_CHARACTER_SET);
        return FALSE;
    }

    // the code should not reach here
    ASSERT(FALSE);
}



/*
Assumption: We are at the start of a new line. There may or may not be a
new line character before current
*/

BOOL
SDP::GetType(
        OUT CHAR    &Type,
        OUT BOOL    &EndOfPacket
    )
{
    // ensure that we don't peek beyond the end of the string
    if ( EOS == m_Current[0] )
    {
        EndOfPacket = TRUE;
        return TRUE;
    }

    // check if the second char is EQUAL_CHAR
    if ( CHAR_EQUAL != m_Current[1] )
    {
        SetLastError(SDP_INVALID_FORMAT);
        return FALSE;
    }

    EndOfPacket = FALSE;
    Type = m_Current[0];
    return TRUE;
}


BOOL
SDP::CheckTransition(
    IN      CHAR        Type,
    IN      PARSE_STATE CurrentParseState,
        OUT PARSE_STATE &NewParseState
    )
{
    // validate the current state
    ASSERT(STATE_NUM_STATES > CurrentParseState);

    // validate transition table entry
    ASSERT(g_TransitionTable[CurrentParseState].m_ParseState == CurrentParseState);

    // see if such a trigger exists for the current state
    for( UINT i=0; i < g_TransitionTable[CurrentParseState].m_NumTransitions; i++ )
    {
        // check if trigger has been found
       if ( Type == g_TransitionTable[CurrentParseState].m_Transitions[i].m_Type )
        {
            NewParseState = g_TransitionTable[CurrentParseState].m_Transitions[i].m_NewParseState;
            break;
        }
    }
    
    // check if a trigger was found
    if ( g_TransitionTable[CurrentParseState].m_NumTransitions <= i )
    {
        SetLastError(SDP_INVALID_FORMAT);
        return FALSE;
    }

    return TRUE;
}


BOOL
SDP::GetValue(
    IN      CHAR    Type
    )
{
    PARSE_STATE NewParseState;

    // check if such a transition (current parse state --Type--> new parse state) exists
    if ( !CheckTransition(Type, m_ParseState, NewParseState) )
    {
        return FALSE;
    }

    BOOL    LineParseResult = FALSE;

    // fire corresponding action
    switch(NewParseState)
    {
    case STATE_VERSION:
        {
            LineParseResult = m_ProtocolVersion.ParseLine(m_Current);
        }

        break;

    case STATE_ORIGIN:
        {
            LineParseResult = m_Origin.ParseLine(m_Current);
        }

        break;

    case STATE_SESSION_NAME:
        {
            LineParseResult = m_SessionName.ParseLine(m_Current);
        }

        break;

    case STATE_TITLE:
        {
            LineParseResult = m_SessionTitle.ParseLine(m_Current);
        }

        break;

    case STATE_URI:
        {
            LineParseResult = m_Uri.ParseLine(m_Current);
        }

        break;

    case STATE_EMAIL:
        {
            LineParseResult = m_EmailList.ParseLine(m_Current);
        }

        break;

    case STATE_PHONE:
        {
            LineParseResult = m_PhoneList.ParseLine(m_Current);
        }

        break;

    case STATE_CONNECTION:
        {
            LineParseResult = m_Connection.ParseLine(m_Current);
        }

        break;

    case STATE_BANDWIDTH:
        {
            LineParseResult = m_Bandwidth.ParseLine(m_Current);
        }

        break;

    case STATE_TIME:
        {
            LineParseResult = GetTimeList().ParseLine(m_Current);
        }

        break;

    case STATE_REPEAT:
        {
            ParseMember(SDP_TIME, GetTimeList(), SDP_REPEAT_LIST, GetRepeatList, m_Current, LineParseResult);
        }

        break;

    case STATE_ADJUSTMENT:
        {
            LineParseResult = GetTimeList().GetAdjustment().ParseLine(m_Current);
        }

        break;

    case STATE_KEY:
        {
            LineParseResult = m_EncryptionKey.ParseLine(m_Current);
        }

        break;

    case STATE_ATTRIBUTE:
        {
            LineParseResult = m_AttributeList.ParseLine(m_Current);
        }

        break;

    case STATE_MEDIA:
        {
            LineParseResult = GetMediaList().ParseLine(m_Current);
        }

        break;

    case STATE_MEDIA_TITLE:
        {
            ParseMember(SDP_MEDIA, GetMediaList(), SDP_REQD_BSTRING_LINE, GetTitle, m_Current, LineParseResult);
        }

        break;

    case STATE_MEDIA_CONNECTION:
        {
            ParseMember(SDP_MEDIA, GetMediaList(), SDP_CONNECTION, GetConnection, m_Current, LineParseResult);
        }

        break;

    case STATE_MEDIA_BANDWIDTH:
        {
            ParseMember(SDP_MEDIA, GetMediaList(), SDP_BANDWIDTH, GetBandwidth, m_Current, LineParseResult);
        }

        break;

    case STATE_MEDIA_KEY:
        {
            ParseMember(SDP_MEDIA, GetMediaList(), SDP_ENCRYPTION_KEY, GetEncryptionKey, m_Current, LineParseResult);
        }

        break;

    case STATE_MEDIA_ATTRIBUTE:
        {
            ParseMember(SDP_MEDIA, GetMediaList(), SDP_ATTRIBUTE_LIST, GetAttributeList, m_Current, LineParseResult);
        }

        break;

    default:
        {
            // should never reach here
            ASSERT(FALSE);

            SetLastError(SDP_INVALID_FORMAT);
            return FALSE;
        }

        break;
    };

    // check if parsing the line succeeded
    if ( !LineParseResult )
    {
        return FALSE;
    }
        
    // change to the new state
    m_ParseState    = NewParseState;
    return TRUE;
}



BOOL    
SDP::IsValidEndState(
    )   const
{
    if ( (STATE_CONNECTION  <=  m_ParseState)    &&
         (STATE_NUM_STATES  >   m_ParseState)     )
    {
        return TRUE;
    }

    SetLastError(SDP_INVALID_FORMAT);
    return FALSE;
}



void
SDP::Reset(
	)
{
	// perform the destructor actions (release any allocated resources)

	// free the sdp packet if one was created
    if ( NULL != m_SdpPacket )
    {
        delete m_SdpPacket;
 		m_SdpPacket = NULL;
   }

	// perform the constructor actions (initialize variables, resources)

    // initialize the parse state
    m_ParseState = STATE_START;

	m_LastGenFailed = FALSE;
	m_BytesAllocated = 0;
	m_SdpPacketLength = 0;

	m_Current = NULL;
	m_ParseState = STATE_START;

	// m_CharacterSet - nothing needs to be set
    m_CharacterSet = CS_UTF8;

	// reset the member instances
	m_ProtocolVersion.Reset();
	m_Origin.Reset();
	m_SessionName.Reset();
	m_SessionTitle.Reset();
	m_Uri.Reset();
	m_EmailList.Reset();
	m_PhoneList.Reset(); 
	m_Connection.Reset();
	m_Bandwidth.Reset();
	GetTimeList().Reset();
	m_EncryptionKey.Reset();
	m_AttributeList.Reset();
	GetMediaList().Reset();
}


BOOL
SDP::ParseSdpPacket(
    IN      CHAR                *SdpPacket,
    IN      SDP_CHARACTER_SET   CharacterSet
    )
{
    ASSERT(NULL != m_MediaList);
    ASSERT(NULL != m_TimeList);

    // check if the instance has already parsed an sdp packet
    if ( NULL != m_Current )
    {
        // reset the instance and try to parse the sdp packet
		Reset();
    }

    // check if the passed in parameters are valid
    if ( (NULL == SdpPacket) || (CS_INVALID == CharacterSet) )
    {
        SetLastError(SDP_INVALID_PARAMETER);
        return FALSE;
    }

    // point the current pointer to the start of sdp packet
	m_Current = SdpPacket;

    // if the character set has not yet been determined
    if ( CS_IMPLICIT == CharacterSet )
    {
        // determine the character set
        if ( !DetermineCharacterSet(SdpPacket, m_CharacterSet) )
        {
            return FALSE;
        }
    }
    else // it cannot be CS_UNRECOGNIZED (checked on entry)
    {
        ASSERT(CS_INVALID != CharacterSet);

        m_CharacterSet = CharacterSet;
    }

    // set the character sets for all the SDP_BSTRING instances that make up the SDP description
    m_Origin.GetUserName().SetCharacterSet(m_CharacterSet);
    m_SessionName.GetBstring().SetCharacterSet(m_CharacterSet);
    m_SessionTitle.GetBstring().SetCharacterSet(m_CharacterSet);

    m_EmailList.SetCharacterSet(m_CharacterSet);
    m_PhoneList.SetCharacterSet(m_CharacterSet);

    // set the character set for the SDP_MEDIA_LIST instance
    GetMediaList().SetCharacterSet(m_CharacterSet);

    // parse the type and its value for each line in the sdp packet
    do
    {
        BOOL    EndOfPacket;
        CHAR    Type;

        // get the next type
        if ( !GetType(Type, EndOfPacket) )
        {
            return FALSE;
        }

        if ( EndOfPacket )
        {
            break;
        }

        // advance the current pointer to beyond the Type= fields
        m_Current+=2;
          
        // get the value for the specified type
        if ( !GetValue(Type) )
        {
            return FALSE;
        }
    }
    while ( 1 );

    // validate if the parsing state is a valid end state
    if ( !IsValidEndState() )
    {
        return FALSE;
    }

    return TRUE;
}



// clears the modified state for each member field/value
// this is used in sdpblb.dll to clear the modified state (when an sdp 
// is parsed in, the state of all parsed in fields/values is modified) and 
// the m_WasModified dirty flag
void    
SDP::ClearModifiedState(
    )
{
    m_ProtocolVersion.GetCharacterStringSize();
    m_Origin.GetCharacterStringSize();
    m_SessionName.GetCharacterStringSize();
    m_SessionTitle.GetCharacterStringSize();
    m_Uri.GetCharacterStringSize();
    m_EmailList.GetCharacterStringSize();
    m_PhoneList.GetCharacterStringSize();
    m_Connection.GetCharacterStringSize();
    m_Bandwidth.GetCharacterStringSize();
    GetTimeList().GetCharacterStringSize();
    m_EncryptionKey.GetCharacterStringSize();
    m_AttributeList.GetCharacterStringSize();
    GetMediaList().GetCharacterStringSize();
}


BOOL   
SDP::IsValid(
    )
{
    // query only the mandatory values
    return 
        m_ProtocolVersion.IsValid()  &&
        m_Origin.IsValid()           &&
        m_SessionName.IsValid()      &&
        m_Connection.IsValid();
}


BOOL   
SDP::IsModified(
    )
{
    ASSERT(IsValid());

    return 
        m_ProtocolVersion.IsModified()  ||
        m_Origin.IsModified()           ||
        m_SessionName.IsModified()      ||
        m_SessionTitle.IsModified()     ||
        m_Uri.IsModified()              ||
        m_EmailList.IsModified()        ||
        m_PhoneList.IsModified()        ||
        m_Connection.IsModified()       ||
        m_Bandwidth.IsModified()        ||
        GetTimeList().IsModified()      ||
        m_EncryptionKey.IsModified()    ||
        m_AttributeList.IsModified()    ||
        GetMediaList().IsModified();
}


// an sdp packet is not generated the way a line is generated (using a SeparatorChar and
// an sdp field carray). this is mainly because these carrays will have to be modified on
// insertion of email and phone lists, media fields and attribute lists or specification of
// other optional sdp properties.

CHAR    *    
SDP::GenerateSdpPacket(
    )
{
    // check if valid
    if ( !IsValid() )
    {
        return NULL;
    }

    // check if the sdp packet needs to be regenerated
    // (if the sdp packet exists and no modifications have taken place since
    // the last time)
    BOOL HasChangedSinceLast = IsModified();
    if ( (!m_LastGenFailed) && (NULL != m_SdpPacket) && !HasChangedSinceLast )
    {
        return m_SdpPacket;
    }

    // determine the length of character string
    m_SdpPacketLength  =    
        m_ProtocolVersion.GetCharacterStringSize()  +
        m_Origin.GetCharacterStringSize()           +
        m_SessionName.GetCharacterStringSize()      +
        m_SessionTitle.GetCharacterStringSize()     +
        m_Uri.GetCharacterStringSize()              +
        m_EmailList.GetCharacterStringSize()        +
        m_PhoneList.GetCharacterStringSize()        +
        m_Connection.GetCharacterStringSize()       +
        m_Bandwidth.GetCharacterStringSize()        +
        GetTimeList().GetCharacterStringSize()      +
        m_EncryptionKey.GetCharacterStringSize()    +
        m_AttributeList.GetCharacterStringSize()    +
        GetMediaList().GetCharacterStringSize();

    // check if a buffer needs to be allocated, allocate if required
    if ( m_BytesAllocated < (m_SdpPacketLength+1) )
    {
        CHAR * NewSdpPacket;         

        try
        {
            NewSdpPacket = new CHAR[m_SdpPacketLength+1];
        }
        catch(...)
        {
            NewSdpPacket = NULL;
        }

        if (NewSdpPacket == NULL)
        {
            m_LastGenFailed = TRUE;
            return NULL;
        }
       
        // if we have an old sdp packet, get rid of it now
        if ( NULL != m_SdpPacket )
        {
            delete m_SdpPacket;
        }

        m_SdpPacket = NewSdpPacket;
        m_BytesAllocated = m_SdpPacketLength+1;
    }

    // fill in the buffer
    ostrstream  OutputStream(m_SdpPacket, m_BytesAllocated);

    // if this method ever fails here for this instance, further calls to the
    // method without modification will return a ptr
    if ( !( m_ProtocolVersion.PrintValue(OutputStream) &&
            m_Origin.PrintValue(OutputStream)          &&
            m_SessionName.PrintValue(OutputStream)     &&
            m_SessionTitle.PrintValue(OutputStream)    &&
            m_Uri.PrintValue(OutputStream)             &&
            m_EmailList.PrintValue(OutputStream)       &&
            m_PhoneList.PrintValue(OutputStream)       &&
            m_Connection.PrintValue(OutputStream)      &&
            m_Bandwidth.PrintValue(OutputStream)       &&
            GetTimeList().PrintValue(OutputStream)        &&
            m_EncryptionKey.PrintValue(OutputStream)   &&
            m_AttributeList.PrintValue(OutputStream)   &&
            GetMediaList().PrintValue(OutputStream)       )   
       )
    {
        m_LastGenFailed = TRUE;
        return NULL;
    }

    OutputStream << EOS;
    m_LastGenFailed = FALSE;

    // dirty flag - is initially false and is set to TRUE when an sdp is generated because it had
    // been modified since the last time the sdp was generated.
    // NOTE: at this point IsModified() is false, so m_WasModified captures the fact that
    // the sdp was modified at some point
    if ( !m_WasModified && HasChangedSinceLast )
    {
        m_WasModified = TRUE;
    }
    return m_SdpPacket;
}



SDP::~SDP(
    )
{
    if ( NULL != m_SdpPacket )
    {
        delete m_SdpPacket;
    }

    if ( m_DestroyMediaList && (NULL != m_MediaList) )
    {
        delete m_MediaList;
    }

    if ( m_DestroyTimeList && (NULL != m_TimeList) )
    {
        delete m_TimeList;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpatt.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpatt.cpp

Abstract:


Author:

*/

#include "sdppch.h"

#include "sdpatt.h"
#include "sdpbstrl.h"

SDP_VALUE    *
SDP_ATTRIBUTE_LIST::CreateElement(
    )
{
    SDP_CHAR_STRING_LINE *SdpCharStringLine;

    try
    {
        SdpCharStringLine = new SDP_CHAR_STRING_LINE(SDP_INVALID_ATTRIBUTE, m_TypeString);
    }
    catch(...)
    {
        SdpCharStringLine = NULL;
    }

    return SdpCharStringLine;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpadtex.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpadtex.cpp

Abstract:


Author:

*/

#include "sdppch.h"

#include "sdpadtex.h"
#include "sdpltran.h"

#include <basetyps.h>
#include <oleauto.h>


// line transition states
enum PHONE_TRANSITION_STATES
{
    PHONE_START,
    PHONE_ONLY_ADDRESS,
    PHONE_OPEN_ADDRESS,
    PHONE_OPEN_TEXT,
    PHONE_CLOSED_ADDRESS,
    PHONE_CLOSED_TEXT
};


// table for phone number line transitions

const LINE_TRANSITION g_PhoneStartTransitions[]         =   {   
    {CHAR_NEWLINE,      PHONE_ONLY_ADDRESS},
    {CHAR_LEFT_ANGLE,   PHONE_OPEN_ADDRESS},
    {CHAR_LEFT_PAREN,   PHONE_OPEN_TEXT} 
};


/* no transitions */
const LINE_TRANSITION *g_PhoneOnlyAddressTransitions    =   NULL;   


const LINE_TRANSITION g_PhoneOpenAddressTransitions[]   =   {   
    {CHAR_RIGHT_ANGLE,  PHONE_CLOSED_ADDRESS}  
};

const LINE_TRANSITION g_PhoneOpenTextTransitions[]      =   {   
    {CHAR_RIGHT_PAREN,  PHONE_CLOSED_TEXT}  
};

const LINE_TRANSITION g_PhoneClosedAddressTransitions[] =   {   
    {CHAR_NEWLINE,      LINE_END}   
};

const LINE_TRANSITION g_PhoneClosedTextTransitions[]    =   {   
    {CHAR_NEWLINE,      LINE_END}   
};


LINE_TRANSITION_INFO g_PhoneTransitionInfo[] = {
    LINE_TRANSITION_ENTRY(PHONE_START,          g_PhoneStartTransitions),

    LINE_TRANSITION_ENTRY(PHONE_ONLY_ADDRESS,   g_PhoneOnlyAddressTransitions),

    LINE_TRANSITION_ENTRY(PHONE_OPEN_ADDRESS,   g_PhoneOpenAddressTransitions),

    LINE_TRANSITION_ENTRY(PHONE_OPEN_TEXT,      g_PhoneOpenTextTransitions),

    LINE_TRANSITION_ENTRY(PHONE_CLOSED_ADDRESS, g_PhoneClosedAddressTransitions),

    LINE_TRANSITION_ENTRY(PHONE_CLOSED_TEXT,    g_PhoneClosedTextTransitions)
};




// line transition states
enum EMAIL_TRANSITION_STATES
{
    EMAIL_START,
    EMAIL_ONLY_ADDRESS,
    EMAIL_OPEN_ADDRESS,
    EMAIL_OPEN_TEXT,
    EMAIL_CLOSED_ADDRESS,
    EMAIL_CLOSED_TEXT
};



// table for email line transitions

const LINE_TRANSITION g_EmailStartTransitions[]         =   {   
    {CHAR_NEWLINE,      EMAIL_ONLY_ADDRESS},
    {CHAR_LEFT_ANGLE,   EMAIL_OPEN_ADDRESS},
    {CHAR_LEFT_PAREN,   EMAIL_OPEN_TEXT} 
};


/* no transitions */
const LINE_TRANSITION *g_EmailOnlyAddressTransitions    =   NULL;  
      

const LINE_TRANSITION g_EmailOpenAddressTransitions[]   =   {   
    {CHAR_RIGHT_ANGLE,  EMAIL_CLOSED_ADDRESS}  
};

const LINE_TRANSITION g_EmailOpenTextTransitions[]      =   {   
    {CHAR_RIGHT_PAREN,  EMAIL_CLOSED_TEXT}  
};

const LINE_TRANSITION g_EmailClosedAddressTransitions[] =   {   
    {CHAR_NEWLINE,      LINE_END}  
};

const LINE_TRANSITION g_EmailClosedTextTransitions[]    =   {   
    {CHAR_NEWLINE,      LINE_END}  
};


LINE_TRANSITION_INFO    g_EmailTransitionInfo[] = {
    LINE_TRANSITION_ENTRY(EMAIL_START,          g_EmailStartTransitions),

    LINE_TRANSITION_ENTRY(EMAIL_ONLY_ADDRESS,   g_EmailOnlyAddressTransitions),

    LINE_TRANSITION_ENTRY(EMAIL_OPEN_ADDRESS,   g_EmailOpenAddressTransitions),

    LINE_TRANSITION_ENTRY(EMAIL_OPEN_TEXT,      g_EmailOpenTextTransitions),

    LINE_TRANSITION_ENTRY(EMAIL_CLOSED_ADDRESS, g_EmailClosedAddressTransitions),

    LINE_TRANSITION_ENTRY(EMAIL_CLOSED_TEXT,    g_EmailClosedTextTransitions)
};


static SDP_LINE_TRANSITION g_EmailTransition(
                        g_EmailTransitionInfo, 
                        sizeof(g_EmailTransitionInfo)/sizeof(LINE_TRANSITION_INFO)
                        );



static SDP_LINE_TRANSITION g_PhoneTransition(
                        g_PhoneTransitionInfo, 
                        sizeof(g_PhoneTransitionInfo)/sizeof(LINE_TRANSITION_INFO)
                        );



void    
SDP_ADDRESS_TEXT::InternalReset(
    )
{
	m_Address.Reset();
	m_Text.Reset();
}



HRESULT 
SDP_ADDRESS_TEXT::SetAddressTextValues(
    IN      BSTR                AddressBstr,
    IN      BSTR                TextBstr
    )
{
    HRESULT HResult = m_Address.SetBstr(AddressBstr);
    if ( FAILED(HResult) )
    {
        return HResult;
    }

    // the text string can be NULL
    if ( NULL == TextBstr )
    {
        // check if the field and separator char arrays need to be modified
        if ( m_FieldArray.GetSize() != 1 )
        {
            // reset text
            m_Text.Reset();
            
            // clear the field and separator char arrays
            m_FieldArray.RemoveAll();
            m_SeparatorCharArray.RemoveAll();

            try
            {
                // set as (address, '\n')
                m_FieldArray.SetAtGrow(0, &m_Address);
                m_SeparatorCharArray.SetAtGrow(0, CHAR_NEWLINE);
            }
            catch(...)
            {
                m_FieldArray.RemoveAll();
                m_SeparatorCharArray.RemoveAll();

                return E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        // try to set the text bstr
        HResult = m_Text.SetBstr(TextBstr);
        if ( FAILED(HResult) )
        {
            return HResult;
        }

        // check if field and separator char arrays need to be modified
        if ( m_FieldArray.GetSize() != 3 )
        {
            // clear the field and separator char arrays
            m_FieldArray.RemoveAll();
            m_SeparatorCharArray.RemoveAll();

            try
            {
                // set as (address, '('), (text, ')'), (NULL, '\n')
                m_FieldArray.Add(&m_Address);
                m_SeparatorCharArray.Add(CHAR_LEFT_PAREN);

                m_FieldArray.Add(&m_Text);
                m_SeparatorCharArray.Add(CHAR_RIGHT_PAREN);

                m_FieldArray.Add(NULL);
                m_SeparatorCharArray.Add(CHAR_NEWLINE);
            }
            catch(...)
            {
                m_FieldArray.RemoveAll();
                m_SeparatorCharArray.RemoveAll();

                return E_OUTOFMEMORY;
            }
        }
    }

    return S_OK;
}




SDP_EMAIL::SDP_EMAIL(
    )
    : SDP_ADDRESS_TEXT(SDP_INVALID_EMAIL_FIELD, EMAIL_STRING, &g_EmailTransition)
{
}


BOOL
SDP_EMAIL::GetField(
        OUT SDP_FIELD   *&Field,
        OUT BOOL        &AddToArray
    )
{
    // add in all cases by default
    AddToArray = TRUE;

    switch(m_LineState)
    {
    case EMAIL_ONLY_ADDRESS:
    case EMAIL_OPEN_TEXT:
    case EMAIL_CLOSED_ADDRESS:
        {
            Field           = &m_Address;
        }

        break;

    case EMAIL_OPEN_ADDRESS:
    case EMAIL_CLOSED_TEXT:
        {
            Field           = &m_Text;
        }

        break;

    default:
        {
            SetLastError(m_ErrorCode);
            return FALSE;
        }

        break;
    };

    return TRUE;
}


SDP_PHONE::SDP_PHONE(
    )
    : SDP_ADDRESS_TEXT(SDP_INVALID_PHONE_FIELD, PHONE_STRING, &g_PhoneTransition)
{
}



BOOL
SDP_PHONE::GetField(
        OUT SDP_FIELD   *&Field,
        OUT BOOL        &AddToArray
    )
{
    // add in all cases by default
    AddToArray = TRUE;

    switch(m_LineState)
    {
    case PHONE_ONLY_ADDRESS:
    case PHONE_OPEN_TEXT:
    case PHONE_CLOSED_ADDRESS:
        {
            Field           = &m_Address;
        }

        break;

    case PHONE_OPEN_ADDRESS:
    case PHONE_CLOSED_TEXT:
        {
            Field           = &m_Text;
        }

        break;

    default:
        {
            SetLastError(m_ErrorCode);
            return FALSE;
        }

        break;
    };

    return TRUE;
}


SDP_VALUE        *
SDP_PHONE_LIST::CreateElement(
    )
{
    SDP_PHONE   *SdpPhone;
    
    try
    {
        SdpPhone = new SDP_PHONE();
    }
    catch(...)
    {
        SdpPhone = NULL;
    }

    if (NULL == SdpPhone)
    {
        return NULL;
    }

    if ( !SdpPhone->SetCharacterSet(m_CharacterSet) )
    {
        delete SdpPhone;

        return NULL;
    }

    return SdpPhone;
}


SDP_VALUE        *
SDP_EMAIL_LIST::CreateElement(
    )
{
    SDP_EMAIL   *SdpEmail;
    
    try
    {
        SdpEmail = new SDP_EMAIL();
    }
    catch(...)
    {
        SdpEmail = NULL;
    }

    if(NULL == SdpEmail)
    {
        return NULL;
    }

    if ( !SdpEmail->SetCharacterSet(m_CharacterSet) )
    {
        delete SdpEmail;

        return NULL;
    }

    return SdpEmail;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpconn.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpconn.cpp

Abstract:


Author:

*/

#include "sdppch.h"

#include "sdpconn.h"
#include "sdpltran.h"




// limited character strings 
const   CHAR    *LIMITED_NETWORK_TYPES[]        = {INTERNET_STRING};
const   BYTE    NUM_NETWORK_TYPES               = sizeof(LIMITED_NETWORK_TYPES)/sizeof(CHAR *);

const   CHAR    *LIMITED_ADDRESS_TYPES[]        = {IP4_STRING};
const   BYTE    NUM_ADDRESS_TYPES               = sizeof(LIMITED_ADDRESS_TYPES)/sizeof(CHAR *);



// line transition states
enum CONNECTION_TRANSITION_STATES
{
    CONNECTION_START,
    CONNECTION_NETWORK_TYPE,
    CONNECTION_ADDRESS_TYPE,
    CONNECTION_MCAST_ADDRESS,
    CONNECTION_UCAST_ADDRESS,
    CONNECTION_TTL,
    CONNECTION_TTL_NUM_ADDRESSES,
    CONNECTION_NUM_ADDRESSES
};



// table for connection line transitions

const LINE_TRANSITION g_ConnectionStartTransitions[]        =   {   
    {CHAR_BLANK,        CONNECTION_NETWORK_TYPE }   
};

const LINE_TRANSITION g_ConnectionNetworkTypeTransitions[]  =   {   
    {CHAR_BLANK,        CONNECTION_ADDRESS_TYPE }   
};

const LINE_TRANSITION g_ConnectionAddressTypeTransitions[]  =   {   
    {CHAR_BACK_SLASH,   CONNECTION_MCAST_ADDRESS},
    {CHAR_NEWLINE,      CONNECTION_UCAST_ADDRESS}   
};

const LINE_TRANSITION g_ConnectionMcastAddressTransitions[] =   {   
    {CHAR_BACK_SLASH,   CONNECTION_TTL_NUM_ADDRESSES},
    {CHAR_NEWLINE,      CONNECTION_TTL              }   
};


/* no transitions */  
const LINE_TRANSITION *g_ConnectionUcastAddressTransitions  =   NULL;  
 

/* no transitions */
const LINE_TRANSITION *g_ConnectionTtlTransitions           =   NULL;   


const LINE_TRANSITION g_ConnectionTtlNumAddressesTransitions[] ={   
    {CHAR_NEWLINE,      CONNECTION_NUM_ADDRESSES}   
};


/* no transitions */
const LINE_TRANSITION *g_ConnectionNumAddressesTransitions  =   NULL;   


LINE_TRANSITION_INFO g_ConnectionTransitionInfo[] = {
    LINE_TRANSITION_ENTRY(CONNECTION_START,         g_ConnectionStartTransitions),

    LINE_TRANSITION_ENTRY(CONNECTION_NETWORK_TYPE,  g_ConnectionNetworkTypeTransitions),

    LINE_TRANSITION_ENTRY(CONNECTION_ADDRESS_TYPE,  g_ConnectionAddressTypeTransitions),

    LINE_TRANSITION_ENTRY(CONNECTION_MCAST_ADDRESS, g_ConnectionMcastAddressTransitions),

    LINE_TRANSITION_ENTRY(CONNECTION_UCAST_ADDRESS, g_ConnectionUcastAddressTransitions),

    LINE_TRANSITION_ENTRY(CONNECTION_TTL,           g_ConnectionTtlTransitions),

    LINE_TRANSITION_ENTRY(CONNECTION_TTL_NUM_ADDRESSES, g_ConnectionTtlNumAddressesTransitions),
    
    LINE_TRANSITION_ENTRY(CONNECTION_NUM_ADDRESSES, g_ConnectionNumAddressesTransitions)
};




SDP_LINE_TRANSITION g_ConnectionTransition(
                        g_ConnectionTransitionInfo, 
                        sizeof(g_ConnectionTransitionInfo)/sizeof(LINE_TRANSITION_INFO)
                        );



SDP_CONNECTION::SDP_CONNECTION(
    )
    : SDP_VALUE(SDP_INVALID_CONNECTION_FIELD, CONNECTION_STRING, &g_ConnectionTransition),
      m_NetworkType(LIMITED_NETWORK_TYPES, NUM_NETWORK_TYPES),
      m_AddressType(LIMITED_ADDRESS_TYPES, NUM_ADDRESS_TYPES)
{
    m_NumAddresses.SetValue(1);
}



void 
SDP_CONNECTION::InternalReset(
    )
{
	m_NetworkType.Reset();
	m_AddressType.Reset();
	m_StartAddress.Reset();
	m_Ttl.Reset();
    m_NumAddresses.Reset();
}



HRESULT 
SDP_CONNECTION::SetConnection(
    IN      BSTR    StartAddress,
    IN      ULONG   NumAddresses,
    IN      BYTE    Ttl
    )
{
    // validate the address
    HRESULT ToReturn = m_StartAddress.SetAddress(StartAddress);
    if ( FAILED(ToReturn) )
    {
        return ToReturn;
    }

    // if multicast, valid number of addresses and ttl values are expected 
    // set the num addresses and
    if ( m_StartAddress.IsMulticast() )
    {
        if ( (0 == NumAddresses) || (0 == Ttl) )
        {
            return E_INVALIDARG;
        }

        m_NumAddresses.SetValueAndFlag(NumAddresses);
        m_Ttl.SetValueAndFlag(Ttl);
    }
    else    // invalidate the num addresses and ttl fields
    {
        m_NumAddresses.Reset();
        m_Ttl.Reset();
    }

    // if the network type is not valid, parse in the default IN network type
    if ( !m_NetworkType.IsValid() )
    {
        if ( !m_NetworkType.ParseToken("IN") )
        {
            return HRESULT_FROM_ERROR_CODE(GetLastError());
        }
    }

    // if the address type is not valid, parse in the default IP4 address type
    if ( !m_AddressType.IsValid() )
    {
        if ( !m_AddressType.ParseToken("IP4") )
        {
            return HRESULT_FROM_ERROR_CODE(GetLastError());
        }
    }

    // clear the field and separator arrays
    m_FieldArray.RemoveAll();
    m_SeparatorCharArray.RemoveAll();

    // fill in the field, separator char arrays with network/address type and
    // the address, if required
    if ( 0 == m_FieldArray.GetSize() )
    {
        try
        {
            m_FieldArray.SetAtGrow(0, &m_NetworkType);
            m_SeparatorCharArray.SetAtGrow(0, CHAR_BLANK);

            m_FieldArray.SetAtGrow(1, &m_AddressType);
            m_SeparatorCharArray.SetAtGrow(1, CHAR_BLANK);

            m_FieldArray.SetAtGrow(2, &m_StartAddress);
        }
        catch(...)
        {
            m_FieldArray.RemoveAll();
            m_SeparatorCharArray.RemoveAll();

            return E_OUTOFMEMORY;
        }
    }
            
    ASSERT(3 <= m_FieldArray.GetSize());

    // if multicast address, fill in the next three fields
    if ( m_StartAddress.IsMulticast() )
    {
        if ( 4 > m_FieldArray.GetSize() )
        {
            // ZoltanS bugfix: m_Ttl and m_NumAddresses were reversed below!

            try
            {
                m_SeparatorCharArray.SetAtGrow(2, CHAR_BACK_SLASH);

                m_FieldArray.SetAtGrow(3, &m_Ttl);
                m_SeparatorCharArray.SetAtGrow(3, CHAR_BACK_SLASH);

                m_FieldArray.SetAtGrow(4, &m_NumAddresses);
                m_SeparatorCharArray.SetAtGrow(4, CHAR_NEWLINE);
            }
            catch(...)
            {
                m_FieldArray.RemoveAll();
                m_SeparatorCharArray.RemoveAll();

                return E_OUTOFMEMORY;
            }
        }
            
        ASSERT(5 == m_FieldArray.GetSize());
    }
    else
    {
        // else, unicast, fill in the next field and remove from the next two
        try
        {
            m_SeparatorCharArray.SetAtGrow(2, CHAR_NEWLINE);
        }
        catch(...)
        {
            m_FieldArray.RemoveAll();
            m_SeparatorCharArray.RemoveAll();

            return E_OUTOFMEMORY;
        }

        if ( 4 <= m_FieldArray.GetSize() )
        {
            ASSERT(5 == m_FieldArray.GetSize());

            m_FieldArray.RemoveAt(3);
            m_SeparatorCharArray.RemoveAt(3);

            m_FieldArray.RemoveAt(4);
            m_SeparatorCharArray.RemoveAt(4);
        }
            
        ASSERT(3 == m_FieldArray.GetSize());
    }

    // if the address is not a multicast address, the other params are ignored    

    return S_OK;
}




BOOL
SDP_CONNECTION::GetField(
        OUT SDP_FIELD   *&Field,
        OUT BOOL        &AddToArray
    )
{
    // add in all cases by default
    AddToArray = TRUE;

    switch(m_LineState)
    {
    case CONNECTION_NETWORK_TYPE:
        {
            Field = &m_NetworkType;
        }

        break;

    case CONNECTION_ADDRESS_TYPE:
        {
            Field = &m_AddressType;
        }

        break;

    case CONNECTION_MCAST_ADDRESS:
        {
            m_StartAddress.SetMulticast(TRUE);
            Field = &m_StartAddress;
        }

        break;

    case CONNECTION_UCAST_ADDRESS:
        {
            m_StartAddress.SetMulticast(FALSE);
            Field = &m_StartAddress;
        }

        break;

    case CONNECTION_TTL:
    case CONNECTION_TTL_NUM_ADDRESSES:
        {
            Field = &m_Ttl;
        }

        break;

    case CONNECTION_NUM_ADDRESSES:
        {
            Field = &m_NumAddresses;
        }

        break;

    default:
        {
            SetLastError(m_ErrorCode);
            return FALSE;
        }

        break;
    };

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpcstrl.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpcstrl.cpp

Abstract:


Author:

*/

#include "sdppch.h"

#include <strstrea.h>

#include "sdpcstrl.h"
#include "sdpgen.h"

#include <winsock2.h>


void    
SDP_CHAR_STRING::Reset(
    )
{
	// perform the destructor actions (freeing ptrs) and the constructor actions (initializing
	// member variables to starting values)

    // check if there is a valid character string
    if (NULL != m_CharacterString)
    {
        // free the character string
        delete m_CharacterString;
    }
      
	m_CharacterString = NULL;
	m_CharacterStringLength = 0;
	m_LengthByReference = 0;
	m_CharacterStringByReference = NULL;
	m_BytesAllocated = 0;

	// call the base class Reset
	SDP_SINGLE_FIELD::Reset();
}


BOOL    
SDP_CHAR_STRING::InternalSetCharStrByRef(
    IN      CHAR    *CharacterStringByReference, 
	IN		DWORD	Length
    )
{
    // if pointing to a char string by copy, that can be released (though this is not necessary
    // and can be optimized away - speed vs. memory tradeoff)
    // check if there is a valid character string
    if (NULL != m_CharacterString)
    {
        // free the character string
        delete m_CharacterString;
	    m_CharacterString = NULL;
	    m_CharacterStringLength = 0;
	    m_BytesAllocated = 0;
    }

    m_CharacterStringByReference    = CharacterStringByReference;
    m_LengthByReference             = Length;

    return TRUE;
}


BOOL    
SDP_CHAR_STRING::InternalSetCharStrByCopy(
    IN	const	CHAR    *CharacterStringByCopy, 
	IN			DWORD	Length
    )
{	
	// reallocate the char string buffer if required
	if ( !ReAllocCharacterString(Length+1) )
    {
        return FALSE;
    }

    strcpy(m_CharacterString, CharacterStringByCopy);

    return TRUE;
}


DWORD   
SDP_CHAR_STRING::CalcCharacterStringSize(
    )
{
    IsModified(FALSE);
    m_PrintLength = GetLength();
    return m_PrintLength;
}


BOOL    
SDP_CHAR_STRING::CopyField(
        OUT     ostrstream  &OutputStream
    )
{
    ASSERT(IsValid());

    ASSERT(NULL != GetCharacterString());
    if ( NULL != GetCharacterString() )
    {
        OutputStream << GetCharacterString();
        if( OutputStream.fail() )
        {
            SetLastError(SDP_OUTPUT_ERROR);
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
SDP_CHAR_STRING::InternalParseToken(
    IN      CHAR        *Token
    )
{
    if ( !ReAllocCharacterString(strlen(Token)+1) )
    {
        return FALSE;
    }

    strcpy(m_CharacterString, Token);

    return TRUE;
}

    
SDP_CHAR_STRING::~SDP_CHAR_STRING(
    )
{
    // check if there is a valid character string
    if (NULL != m_CharacterString)
    {
        // free the character string
        delete m_CharacterString;
    }
}



BOOL 
SDP_STRING_LINE::InternalParseLine(
    IN  OUT CHAR    *&Line
    )
{
    CHAR SeparatorChar = '\0';

    // identify the token. if one of the the separator characters is found, replace
    // it by EOS and return the separator char. if none of the separator characters are
    // found, return NULL (ex. if EOS found first, return NULL)
    CHAR *Token = GetToken(Line, 1, NEWLINE_STRING, SeparatorChar);

    // when the block goes out of scope, 
    // set the EOS character to the token separator character
    LINE_TERMINATOR LineTerminator(Token, SeparatorChar);

    // if there is no such token
    if ( !LineTerminator.IsLegal() )
    {
        SetLastError(m_ErrorCode);
        return FALSE;
    }

    // advance the line to the start of the next token
    Line += (LineTerminator.GetLength() + 1);

    BOOL ToReturn = GetParseField().ParseToken(Token);

    INT_PTR Index;

    // fill in the CArrays for separator char and field
    try
    {   
        Index = m_SeparatorCharArray.Add(CHAR_NEWLINE);
    }
    catch(...)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    try
    {
        m_FieldArray.Add(&GetParseField());
    }
    catch(...)
    {
        m_SeparatorCharArray.RemoveAt(Index);

        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    return ToReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpbw.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpbw.cpp

Abstract:


Author:

*/
#include "sdppch.h"

#include "sdpbw.h"
#include "sdpltran.h"


// line transition states
enum BANDWIDTH_TRANSITION_STATES
{
    BANDWIDTH_START,
    BANDWIDTH_TYPE,
    BANDWIDTH_VALUE
};


// table for bandwidth line transitions

const LINE_TRANSITION g_BandwidthStartTransitions[] =   {   
    {CHAR_COLON,    BANDWIDTH_TYPE}  
};

const LINE_TRANSITION g_BandwidthTypeTransitions[]  =   {   
    {CHAR_NEWLINE,  BANDWIDTH_VALUE} 
};


/* no transitions */
const LINE_TRANSITION *g_BandwidthValueTransitions  =   NULL;  


LINE_TRANSITION_INFO g_BandwidthTransitionInfo[] = {
    LINE_TRANSITION_ENTRY(BANDWIDTH_START,  g_BandwidthStartTransitions),

    LINE_TRANSITION_ENTRY(BANDWIDTH_TYPE,   g_BandwidthTypeTransitions),

    LINE_TRANSITION_ENTRY(BANDWIDTH_VALUE,  g_BandwidthValueTransitions)
};



SDP_LINE_TRANSITION g_BandwidthTransition(
                        g_BandwidthTransitionInfo, 
                        sizeof(g_BandwidthTransitionInfo)/sizeof(LINE_TRANSITION_INFO)
                        );



SDP_BANDWIDTH::SDP_BANDWIDTH(
    )
    : SDP_VALUE(SDP_INVALID_BANDWIDTH_FIELD, BANDWIDTH_STRING, &g_BandwidthTransition)
{
}


void    
SDP_BANDWIDTH::InternalReset(
	)
{
	m_Modifier.Reset();
	m_Bandwidth.Reset();
}


HRESULT 
SDP_BANDWIDTH::SetBandwidth(
    IN          BSTR    Modifier,
    IN          ULONG   Value
    )
{
    // set the modifier field
    BAIL_ON_FAILURE(m_Modifier.SetBstr(Modifier));

    // set the modifier field
    m_Bandwidth.SetValueAndFlag(Value);

    // if the field/separator char arrays are empty, fill them
    if ( 2 != m_FieldArray.GetSize() )
    {
        ASSERT(0 == m_FieldArray.GetSize());
        ASSERT(0 == m_SeparatorCharArray.GetSize());

        try
        {
            m_FieldArray.SetAtGrow(0, &m_Modifier);
            m_SeparatorCharArray.SetAtGrow(0, CHAR_COLON);

            m_FieldArray.SetAtGrow(1, &m_Bandwidth);
            m_SeparatorCharArray.SetAtGrow(1, CHAR_NEWLINE);
        }
        catch(...)
        {
            m_FieldArray.RemoveAll();
            m_SeparatorCharArray.RemoveAll();

            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}




BOOL
SDP_BANDWIDTH::GetField(
        OUT SDP_FIELD   *&Field,
        OUT BOOL        &AddToArray
    )
{
    // add in all cases by default
    AddToArray = TRUE;

    switch(m_LineState)
    {
    case BANDWIDTH_TYPE:
        {
            Field = &m_Modifier;
        }

        break;

    case BANDWIDTH_VALUE:
        {
            Field = &m_Bandwidth;
        }

        break;

    default:
        {
            SetLastError(m_ErrorCode);
            return FALSE;
        }

        break;
    };

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpbstrl.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpbstrl.cpp

Abstract:


Author:

*/

#include "sdppch.h"

#include "sdpbstrl.h"

#include <basetyps.h>
#include <oleauto.h>
#include <winsock2.h>
#include <wchar.h>

SDP_ARRAY_BSTR::~SDP_ARRAY_BSTR(
    )
{
    int Size = (int)GetSize();

    if ( 0 < Size )
    {
        for ( int i=0; i < Size; i++ )
        {
            BSTR Member = GetAt(i);

            ASSERT(NULL != Member);
            if ( NULL == Member )
            {
                return;
            }

            SysFreeString(Member);
        }
    }

    RemoveAll();
}


void				
SDP_BSTRING::Reset(
	)
{
	// perform the destructor actions (freeing ptrs) and the constructor actions (initializing
	// member variables to starting values)

	// if there is a bstr, free it
    if ( NULL != m_Bstr )
    {
        SysFreeString(m_Bstr);
    }

	m_Bstr = NULL;
	m_CharacterSet = CS_UTF8;
	m_CodePage = CP_UTF8;

	// call the base class Reset
	SDP_CHAR_STRING::Reset();
}


BOOL
SDP_BSTRING::ConvertToBstr(
    )
{
    // ZoltanS bugfix:
    // MutliByteToWideChar always fails if its input string is empty.
    // Therefore, we must special-case a zero-length string.

    DWORD dwOriginalLength = GetLength();

    if ( 0 == dwOriginalLength )
    {
        // Shrink the member BSTR
        if ( !SysReAllocStringLen(&m_Bstr, NULL, dwOriginalLength) )
        {
            return FALSE;
        }

        // Make sure the member BSTR is emptied
        m_Bstr[0] = L'\0';

    }
    else // we have a nonzero-length string to convert
    {
        // get the size of bstr needed to store the unicode representation
        // cast the const char * returned from GetCharacterString to CHAR * because MultiByteToWideChar
        // doesn't accept const char * (although thats what the parameter should be)
        int BstrSize = MultiByteToWideChar(m_CodePage,  0,  (CHAR *)GetCharacterString(),
                                           dwOriginalLength, NULL,   0
                                          );

        // Check if the token can be converted to an appropriate bstr.
        if (0 == BstrSize)
        {
            return FALSE;
        }

        // re-allocate bstr for the unicode representation
        if ( !SysReAllocStringLen(&m_Bstr, NULL, BstrSize) )
        {
            return FALSE;
        }

        // convert character string to bstr
        // cast the const char * returned from GetCharacterString to CHAR * because MultiByteToWideChar
        // doesn't accept const char * (although thats what the parameter should be)
        if ( BstrSize != MultiByteToWideChar(
                    m_CodePage, 0, (CHAR *)GetCharacterString(),
                    dwOriginalLength, m_Bstr, BstrSize
                    )   )
        {
            return FALSE;
        }
    }

    return TRUE;
}



HRESULT
SDP_BSTRING::GetBstr(
    IN BSTR *pBstr
    )
{
    // ZoltanS
    ASSERT( ! IsBadWritePtr(pBstr, sizeof(BSTR)) );

    if ( !IsValid() )
    {
        return HRESULT_FROM_ERROR_CODE(ERROR_INVALID_DATA);
    }

    *pBstr = m_Bstr;
    return S_OK;
}



HRESULT				
SDP_BSTRING::GetBstrCopy(
	IN BSTR * pBstr
	)
{
    // ZoltanS
	if ( IsBadWritePtr(pBstr, sizeof(BSTR)) )
	{
		return E_POINTER;
	}

	BSTR LocalPtr = NULL;
	HRESULT HResult = GetBstr(&LocalPtr);
	if ( FAILED(HResult) )
	{
		return HResult;
	}

    if ( (*pBstr = SysAllocString(LocalPtr)) == NULL )
    {
	    return E_OUTOFMEMORY;
	}

	return S_OK;
}



HRESULT
SDP_BSTRING::SetBstr(
    IN BSTR Bstr
    )
{
    if ( NULL == Bstr )
    {
        return E_INVALIDARG;
    }

    DWORD   BstrLen =  lstrlenW(Bstr);
    BOOL    DefaultUsed = FALSE;

    // determine length of character string buffer
    // If the codepage is UTF8 the last argument should be NULL
    // if the caracterset is ASCII then we need to determine if the
    // WideCharToMultiByte methods nneds replacment characters

    int BufferSize = WideCharToMultiByte(
                            m_CodePage, 0,  Bstr,  BstrLen+1,
                            NULL,   0,  NULL,
                            (m_CharacterSet == CS_ASCII ) ? &DefaultUsed : NULL
                            );

    if ( 0 == BufferSize )
    {
        return HRESULT_FROM_ERROR_CODE(GetLastError());
    }

    if ( DefaultUsed )
    {
        return HRESULT_FROM_ERROR_CODE(SDP_INVALID_VALUE);
    }

    // now conversion cannot fail because the previous call made sure that
    // the bstr can be converted to this multibyte string
    // since failure is not possible, we do not need any code to restore
    // the previous character string and it may be freed
    if ( !ReAllocCharacterString(BufferSize) )
    {
        return HRESULT_FROM_ERROR_CODE(GetLastError());
    }

    // since the char string has been reallocated, the modifiable string must exist
    // (i.e. the char string should not be by reference at this point)
    ASSERT(NULL != GetModifiableCharString());

    // convert to multibyte string
    if ( BufferSize != WideCharToMultiByte(
                            m_CodePage, 0, Bstr, BstrLen+1,
                            GetModifiableCharString(), BufferSize, NULL, NULL
                            )   )
    {
        ASSERT(FALSE);
        return HRESULT_FROM_ERROR_CODE(GetLastError());
    }

    // reallocate memory and copy bstr
    if ( !SysReAllocStringLen(&m_Bstr, Bstr, BstrLen) )
    {
        return HRESULT_FROM_ERROR_CODE(GetLastError());
    }

    IsValid(TRUE);
    IsModified(TRUE);
    return S_OK;
}


BOOL
SDP_BSTRING::InternalSetCharStrByRef(
    IN      CHAR    *CharacterStringByReference,
	IN		DWORD	Length
    )
{
    if ( !SDP_CHAR_STRING::InternalSetCharStrByRef(CharacterStringByReference, Length) )
    {
        return FALSE;
    }

    if ( !ConvertToBstr() )
    {
        return FALSE;
    }

    return TRUE;
}


BOOL
SDP_BSTRING::InternalSetCharStrByCopy(
    IN	const	CHAR    *CharacterStringByCopy,
	IN			DWORD	Length
    )
{
    if ( !SDP_CHAR_STRING::InternalSetCharStrByCopy(CharacterStringByCopy, Length) )
    {
        return FALSE;
    }

    if ( !ConvertToBstr() )
    {
        return FALSE;
    }

    return TRUE;
}



BOOL
SDP_BSTRING::InternalParseToken(
    IN      CHAR        *Token
    )
{
    UINT    CodePage;

    // parse the token using the base class parsing method
    if ( !SDP_CHAR_STRING::InternalParseToken(Token) )
    {
        return FALSE;
    }

    if ( !ConvertToBstr() )
    {
        return FALSE;
    }

    return TRUE;
}




SDP_BSTRING::~SDP_BSTRING()
{
    if ( NULL != m_Bstr )
    {
        SysFreeString(m_Bstr);
    }
}



void				
SDP_OPTIONAL_BSTRING::Reset(
	)
{
	// perform the destructor actions (freeing ptrs) and the constructor actions (initializing
	// member variables to starting values)

	m_IsBstrCreated = FALSE;

	// call the base class Reset
	SDP_BSTRING::Reset();
}


// returns the bstr for the character string
// creates a bstr if required
HRESULT
SDP_OPTIONAL_BSTRING::GetBstr(
    IN BSTR * pBstr
    )
{
    // ZoltanS
    ASSERT( ! IsBadWritePtr(pBstr, sizeof(BSTR)) );

    if ( !IsValid() )
    {
        return HRESULT_FROM_ERROR_CODE(ERROR_INVALID_DATA);
    }

    if ( !m_IsBstrCreated )
    {
        if ( !ConvertToBstr() )
        {
            return HRESULT_FROM_ERROR_CODE(GetLastError());
        }

        m_IsBstrCreated = TRUE;
    }

    *pBstr = m_Bstr;
    return S_OK;
}


HRESULT
SDP_OPTIONAL_BSTRING::SetBstr(
    IN BSTR Bstr
    )
{
    HRESULT HResult = SDP_BSTRING::SetBstr(Bstr);
    if ( FAILED(HResult) )
    {
        return HResult;
    }

    m_IsBstrCreated = TRUE;
    ASSERT(S_OK == HResult);
    return HResult;
}


BOOL
SDP_OPTIONAL_BSTRING::InternalSetCharStrByRef(
    IN      CHAR    *CharacterStringByReference,
	IN		DWORD	Length
    )
{
    if ( !SDP_CHAR_STRING::InternalSetCharStrByRef(CharacterStringByReference, Length) )
    {
        return FALSE;
    }

    m_IsBstrCreated = FALSE;
    return TRUE;
}



BOOL
SDP_OPTIONAL_BSTRING::InternalSetCharStrByCopy(
    IN	const	CHAR    *CharacterStringByCopy,
	IN			DWORD	Length
    )
{
    if ( !SDP_CHAR_STRING::InternalSetCharStrByCopy(CharacterStringByCopy, Length) )
    {
        return FALSE;
    }

    m_IsBstrCreated = FALSE;
    return TRUE;
}



// since the bstr must only be created on demand, parsing must
// be over-ridden such that the bstr is not created during parsing
BOOL
SDP_OPTIONAL_BSTRING::InternalParseToken(
    IN      CHAR    *Token
    )
{
    return SDP_CHAR_STRING::InternalParseToken(Token);
}



HRESULT
SDP_BSTRING_LINE::GetBstrCopy(
    IN BSTR *pBstr
    )
{
    // ZoltanS
	if ( IsBadWritePtr(pBstr, sizeof(BSTR)) )
	{
		return E_POINTER;
	}

    // if no elements in the field array, then the instance is invalid
    if ( 0 >= m_FieldArray.GetSize() )
    {
        // ZoltanS fix: return a valid empty string! Otherwise we aren't
        // conforming to Bstr semantics.

        *pBstr = SysAllocString(L"");

        if ( (*pBstr) == NULL )
        {
            return E_OUTOFMEMORY;
        }

        return S_OK;
    }

    return GetBstring().GetBstrCopy(pBstr);
}


HRESULT
SDP_BSTRING_LINE::SetBstr(
    IN      BSTR    Bstr
    )
{
    BAIL_ON_FAILURE(GetBstring().SetBstr(Bstr));

    try
    {
        // set the field and separator char array
        m_FieldArray.SetAtGrow(0, &GetBstring());
        m_SeparatorCharArray.SetAtGrow(0, CHAR_NEWLINE);
    }
    catch(...)
    {
        m_FieldArray.RemoveAll();
        m_SeparatorCharArray.RemoveAll();

        return E_OUTOFMEMORY;
    }

    return S_OK;
}


void
SDP_REQD_BSTRING_LINE::InternalReset(
	)
{
	m_Bstring.Reset();
}


void
SDP_CHAR_STRING_LINE::InternalReset(
	)
{
	m_SdpOptionalBstring.Reset();
}


HRESULT
SDP_LIMITED_CHAR_STRING::SetLimitedCharString(
    IN          CHAR    *String
    )
{
    // check if the string is a legal string
    // check if the token is one of the legal strings
    for(UINT i=0; i < m_NumStrings; i++)
    {
        if ( !strcmp(m_LegalStrings[i], String) )
        {
            // parse the string using the base class parsing method
            if ( !SDP_CHAR_STRING::InternalParseToken(String) )
            {
                return HRESULT_FROM_ERROR_CODE(GetLastError());
            }

            return S_OK;
        }
    }

    // no matching legal string
    return HRESULT_FROM_ERROR_CODE(ERROR_INVALID_DATA);
}


BOOL
SDP_LIMITED_CHAR_STRING::InternalParseToken(
    IN      CHAR        *Token
    )
{
    // check if the token is one of the legal strings
    for(UINT i=0; i < m_NumStrings; i++)
    {
        if ( !strcmp(m_LegalStrings[i], Token) )
        {
            // parse the token using the base class parsing method
            if ( !SDP_CHAR_STRING::InternalParseToken(Token) )
            {
                return FALSE;
            }

            return TRUE;
        }
    }

    // the token does not match any of the legal strings
    SetLastError(SDP_INVALID_FORMAT);
    return FALSE;
}


BOOL
SDP_ADDRESS::IsValidIP4Address(
    IN  CHAR    *Address,
    OUT ULONG   &Ip4AddressValue
    )
{
    ASSERT(NULL != Address);

    // check if there are atleast 3 CHAR_DOTs in the address string
    // inet_addr accepts 3,2,1 or even no dots
    CHAR *CurrentChar = Address;
    BYTE NumDots = 0;
    while (EOS != *CurrentChar)
    {
        if (CHAR_DOT == *CurrentChar)
        {
            NumDots++;
            if (3 == NumDots)
            {
                break;
            }
        }

        // advance the ptr to the next char
        CurrentChar++;
    }

    // check for the number of dots
    if (3 != NumDots)
    {
        SetLastError(SDP_INVALID_ADDRESS);
        return FALSE;
    }

    // currently only ip4 is supported
    Ip4AddressValue = inet_addr(Address);

    // check if the address is a valid IP4 address
    if ( (ULONG)INADDR_NONE == Ip4AddressValue )
    {
        SetLastError(SDP_INVALID_ADDRESS);
        return FALSE;
    }

    return TRUE;
}


HRESULT
SDP_ADDRESS::SetAddress(
    IN      BSTR    Address
    )
{
    // SetBstr also sets the is modified and is valid flags on success
    HRESULT ToReturn = SDP_OPTIONAL_BSTRING::SetBstr(Address);
    if ( FAILED(ToReturn) )
    {
        return ToReturn;
    }

    // get the ip address
    ULONG Ip4AddressValue;

    // check if the token is a valid IP4 address
    if ( !IsValidIP4Address(GetCharacterString(), Ip4AddressValue) )
    {
        IsModified(FALSE);
        IsValid(FALSE);
        return HRESULT_FROM_ERROR_CODE(GetLastError());
    }

    m_IsMulticastFlag = IN_MULTICAST(ntohl(Ip4AddressValue));

    // the grammar requires that a multicast address be either an administratively scoped
    // address "239.*" or out of the internet multicast conferencing range "224.2.*"
    // we won't check that here as that may be overly restrictive

    return S_OK;
}


HRESULT
SDP_ADDRESS::SetBstr(
    IN BSTR Bstr
    )
{
    return SetAddress(Bstr);
}



BOOL
SDP_ADDRESS::InternalParseToken(
    IN      CHAR        *Token
    )
{
    ULONG Ip4AddressValue;

    // check if the token is a valid IP4 address
    if ( !IsValidIP4Address(Token, Ip4AddressValue) )
    {
        return FALSE;
    }

    // check if the address(unicast or multicast) is same as whats expected
    if ( IN_MULTICAST(ntohl(Ip4AddressValue)) != m_IsMulticastFlag )
    {
        SetLastError(SDP_INVALID_ADDRESS);
        return FALSE;
    }

    // the grammar requires that a multicast address be either an administratively scoped
    // address "239.*" or out of the internet multicast conferencing range "224.2.*"
    // we won't check that here as that may be overly restrictive

    // call the base class parse token method
    if ( !SDP_CHAR_STRING::InternalParseToken(Token) )
    {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpemail.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:


Abstract:


Author:

*/

#ifndef __SDP_EMAIL__
#define __SDP_EMAIL__

#include "sdpcommo.h"
#include "sdpgen.h"
#include "sdpcstrl.h"
#include "sdpbstrl.h"


class _DllDecl SDP_EMAIL : public SDP_VALUE
{
public:

    SDP_EMAIL();

    virtual void    Reset();

    inline  BSTR    CreateBstr();

    inline  void    SetCharacterSet(
        IN      SDP_CHARACTER_SET   CharacterSet
        );

protected:

    BOOL                    m_IsTextValid;

    SDP_OPTIONAL_BSTRING    m_Address;
    SDP_BSTRING             m_Text;

    virtual BOOL GetField(
            OUT SDP_FIELD   *&Field,
            OUT BOOL        &AddToArray
        );
};
 


inline BSTR 
SDP_EMAIL::CreateBstr(
    )
{
    // TBD - to be done
    return NULL;
}




inline void
SDP_EMAIL::SetCharacterSet(
    IN      SDP_CHARACTER_SET   CharacterSet
    )
{
    m_Text.SetCharacterSet(CharacterSet);
}


class _DllDecl SDP_EMAIL_LIST: public BSTR_ARRAY
{
public:

    inline void SetCharacterSet(
        IN          SDP_CHARACTER_SET   CharacterSet
        );

    inline BOOL     ParseLine(
        IN  OUT     CHAR                *&Line
        );

protected:

    SDP_EMAIL           m_Email;
};


inline void
SDP_EMAIL_LIST::SetCharacterSet(
    IN      SDP_CHARACTER_SET   CharacterSet
    )
{
    m_Email.SetCharacterSet(CharacterSet);
}


inline BOOL
SDP_EMAIL_LIST::ParseLine(
    IN  OUT CHAR    *&Line
    )
{
    if ( !m_Email.ParseLine(Line) )
    {
        return FALSE;
    }

    try
    {
        Add(m_Email.CreateBstr());
    }
    catch(...)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    m_Email.Reset();

    return TRUE;
}


#endif // __SDP_EMAIL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpgen.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#include "sdppch.h"

#include "sdpgen.h"




// Isolates tokens by searching for one of the separators 
// and returns the first separator thats found
CHAR    *
GetToken(
    IN              CHAR    *String,
    IN              BYTE    NumSeparators,
    IN      const   CHAR    *SeparatorChars,
        OUT         CHAR    &Separator
    )
{
    // validate the input parameters

    ASSERT(NULL != String);
    ASSERT(NULL != SeparatorChars);
    ASSERT(0 != NumSeparators);

    if ( (NULL == String)           ||
         (NULL == SeparatorChars)   ||
         (0 == NumSeparators)        )
    {
        return NULL;
    }

    // advance character by character until the string ends or
    // one of the separators is found
    for ( UINT i=0; ; i++ )
    {
        // check each separator
        for ( UINT j=0; j < NumSeparators; j++ )
        {
            // if the separator matches the current string character
            if ( SeparatorChars[j] == String[i] )
            {
                // copy the separator character
                Separator = String[i];

                // terminate the token with an end of string character
                String[i] = EOS;

                // return the start of the token
                return String;
            }
        }

        // check if the end of string has been reached
        if ( EOS == String[i] )
        {
            return NULL;
        }
    }

    // should never reach here
    ASSERT(FALSE);

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpenc.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    sdpenc.cpp

Abstract:


Author:

*/

#include "sdppch.h"

#include "sdpenc.h"
#include "sdpltran.h"



// line transition states
enum ENCRYPTION_TRANSITION_STATES
{
    ENCRYPTION_START,
    ENCRYPTION_KEY_TYPE,
    ENCRYPTION_KEY_TYPE_END,
    ENCRYPTION_KEY_DATA_END
};



// table for connection line transitions

const LINE_TRANSITION g_EncryptionStartTransitions[]    =   {   
    {CHAR_NEWLINE,      ENCRYPTION_KEY_TYPE_END },
    {CHAR_COLON,        ENCRYPTION_KEY_TYPE     }
};

const LINE_TRANSITION g_EncryptionKeyTypeTransitions[]  =   { 
    {CHAR_NEWLINE,      ENCRYPTION_KEY_DATA_END }   
};


/* no transitions */
const LINE_TRANSITION *g_EncryptionKeyTypeEndTransitions=   NULL;   


/* no transitions */
const LINE_TRANSITION *g_EncryptionKeyDataEndTransitions=   NULL;   



LINE_TRANSITION_INFO g_EncryptionTransitionInfo[] = {
    LINE_TRANSITION_ENTRY(ENCRYPTION_START,         g_EncryptionStartTransitions),

    LINE_TRANSITION_ENTRY(ENCRYPTION_KEY_TYPE,      g_EncryptionKeyTypeTransitions),

    LINE_TRANSITION_ENTRY(ENCRYPTION_KEY_TYPE_END,  g_EncryptionKeyTypeEndTransitions),

    LINE_TRANSITION_ENTRY(ENCRYPTION_KEY_DATA_END,  g_EncryptionKeyDataEndTransitions)
};



SDP_LINE_TRANSITION g_EncryptionTransition(
                        g_EncryptionTransitionInfo, 
                        sizeof(g_EncryptionTransitionInfo)/sizeof(LINE_TRANSITION_INFO)
                        );



SDP_ENCRYPTION_KEY::SDP_ENCRYPTION_KEY(
    )
    : SDP_VALUE(SDP_INVALID_ENCRYPTION_KEY_FIELD, KEY_STRING, &g_EncryptionTransition)
{}


void 
SDP_ENCRYPTION_KEY::InternalReset(
    )
{
	m_KeyType.Reset();
	m_KeyData.Reset();
}



HRESULT 
SDP_ENCRYPTION_KEY::SetKey(
    IN      BSTR    KeyType,
    IN      BSTR    *KeyData
    )
{
    // set the key type field
    HRESULT ToReturn = m_KeyType.SetBstr(KeyType);
    if ( FAILED(ToReturn) )
    {
        return ToReturn;
    }

    // if required, set the key data field
    if ( NULL != KeyData )
    {
        ToReturn = m_KeyData.SetBstr(*KeyData);
        if ( FAILED(ToReturn) )
        {
            return ToReturn;
        }
    }
    else
    {
        m_KeyData.Reset();
    }

    m_FieldArray.RemoveAll();
    m_SeparatorCharArray.RemoveAll();

    if ( NULL != KeyData )
    {
        try
        {
            // set the field/separator chars
            m_FieldArray.SetAtGrow(0, &m_KeyType);
            m_SeparatorCharArray.SetAtGrow(0, CHAR_COLON);

            m_FieldArray.SetAtGrow(1, &m_KeyData);
            m_SeparatorCharArray.SetAtGrow(1, CHAR_NEWLINE);
        }
        catch(...)
        {
            m_FieldArray.RemoveAll();
            m_SeparatorCharArray.RemoveAll();

            return E_OUTOFMEMORY;
        }
    }
    else
    {
        try
        {
            // set the field/separator chars
            m_FieldArray.SetAtGrow(0, &m_KeyType);
            m_SeparatorCharArray.SetAtGrow(0, CHAR_NEWLINE);
        }
        catch(...)
        {
            m_FieldArray.RemoveAll();
            m_SeparatorCharArray.RemoveAll();

            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}


BOOL
SDP_ENCRYPTION_KEY::GetField(
        OUT SDP_FIELD   *&Field,
        OUT BOOL        &AddToArray
    )
{
    // add in all cases by default
    AddToArray = TRUE;

    switch(m_LineState)
    {
    case ENCRYPTION_KEY_TYPE:
    case ENCRYPTION_KEY_TYPE_END:
        {
            Field = &m_KeyType;
        }

        break;

    case ENCRYPTION_KEY_DATA_END:
        {
            Field = &m_KeyData;
        }

        break;

    default:
        {
            SetLastError(m_ErrorCode);
            return FALSE;
        }

        break;
    };

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpfld.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#include "sdppch.h"

#include <strstrea.h>

#include "sdpfld.h"



void
SDP_SINGLE_FIELD::Reset(
    )
{
    m_IsModified    =   FALSE;
    m_IsValid       =   FALSE;
}


BOOL
SDP_SINGLE_FIELD::IsValid(
        ) const
{
    return m_IsValid;
}


void
SDP_SINGLE_FIELD::IsValid(
    IN          BOOL    ValidFlag
    )
{
    m_IsValid = ValidFlag;
}



BOOL
SDP_SINGLE_FIELD::IsModified(
    ) const
{
    return m_IsModified;
}


void
SDP_SINGLE_FIELD::IsModified(
    IN      BOOL    ModifiedFlag
    )
{
    ASSERT(IsValid());
    m_IsModified = ModifiedFlag;
}


DWORD
SDP_SINGLE_FIELD::GetCharacterStringSize(
    )
{
    if ( m_IsValid )
    {
        if ( m_IsModified )
        {
            return CalcCharacterStringSize();
        }
        else
        {
            return m_PrintLength;
        }
    }
    else
    {
        return 0;
    }
}



BOOL
SDP_SINGLE_FIELD::PrintField(
    OUT     ostrstream  &OutputStream
    )
{
    // should not be modified
    ASSERT(!IsModified());

    return ( IsValid() ? CopyField(OutputStream) : TRUE );
}



BOOL
SDP_SINGLE_FIELD::ParseToken(
    IN          CHAR        *Token
    )
{
    ASSERT(!IsModified());

    if ( !InternalParseToken(Token) )
    {
        ASSERT(!IsModified());
        return FALSE;
    }

    IsValid(TRUE);
    IsModified(TRUE);

    return TRUE;
}



DWORD
SDP_SINGLE_FIELD::CalcCharacterStringSize(
    )
{
    ASSERT(IsModified());

    // this copy should not fail as the buffer size should be sufficient for
    // all forseeable situations
    ASSERT(NULL != m_PrintBuffer);
    ostrstream  OutputStream(m_PrintBuffer, m_PrintBufferSize);

    BOOL    Success = PrintData(OutputStream);
    ASSERT(Success);

    m_PrintLength = OutputStream.pcount();
    m_PrintBuffer[m_PrintLength] = EOS;
    IsModified(FALSE);

    return m_PrintLength;
}




// this method should only be called after GetCharacterStringSize() has
// been called to determine the size of buffer required
BOOL
SDP_SINGLE_FIELD::CopyField(
        OUT ostrstream  &OutputStream
    )
{
    ASSERT(!IsModified());
    ASSERT(NULL != m_PrintBuffer);

    OutputStream << (CHAR *)m_PrintBuffer;
    if( OutputStream.fail() )
    {
        SetLastError(SDP_OUTPUT_ERROR);
        return FALSE;
    }

    return TRUE;
}



void
SDP_FIELD_LIST::Reset(
    )
{
    SDP_POINTER_ARRAY<SDP_FIELD *>::Reset();
}



BOOL
SDP_FIELD_LIST::IsValid(
    ) const
{
    // if there are no members, then the instance is invalid
    if ( 0 >= GetSize() )
    {
        return FALSE;
    }

    // check each of the members in the list for validity
    for ( int i=0; i < GetSize(); i++ )
    {
        // if even one member is invalid, return FALSE
        if ( !GetAt(i)->IsValid() )
        {
            return FALSE;
        }
    }

    // all members are valid
    return TRUE;
}


BOOL
SDP_FIELD_LIST::IsModified(
    ) const
{
    int NumElements = (int)GetSize();

    for ( int i = 0; i < NumElements; i++ )
    {
        if ( GetAt(i)->IsModified() )
        {
            return TRUE;
        }
    }

    return FALSE;
}


void
SDP_FIELD_LIST::IsModified(
    IN          BOOL    ModifiedFlag
    )
{
    // if no elements, the instance isn't "modified"
    if ( 0 >= GetSize() )
    {
        ModifiedFlag = FALSE;
        return;
    }

    for ( int i = 0; i < GetSize(); i++ )
    {
        GetAt(i)->IsModified(ModifiedFlag);
    }
}


DWORD
SDP_FIELD_LIST::GetCharacterStringSize(
    )
{
    DWORD   ReturnValue = 0;
    int NumElements = (int)GetSize();

    for ( int i = 0; i < NumElements; i++ )
    {
        ReturnValue += GetAt(i)->GetCharacterStringSize();
    }

    // if there are elements, add one separator character for each field other
    // than the first
    if ( 0 < NumElements )
    {
        ReturnValue += (NumElements - 1);
    }

    return ReturnValue;
}



BOOL
SDP_FIELD_LIST::ParseToken(
    IN      CHAR     *Token
    )
{
    SDP_FIELD *SdpField = CreateElement();

    if ( NULL == SdpField )
    {
        return FALSE;
    }

    if ( !SdpField->ParseToken(Token) )
    {
        delete SdpField;
        return FALSE;
    }

    try
    {
        Add(SdpField);
    }
    catch(...)
    {
        delete SdpField;

        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    return TRUE;
}



BOOL
SDP_FIELD_LIST::PrintField(
        OUT     ostrstream  &OutputStream
    )
{
    int    NumElements = (int)GetSize();

    if ( 0 == NumElements )
    {
        return TRUE;
    }

    // write into the buffer as Value (separator Value)*

    // write the first element
    if ( !GetAt(0)->PrintField(OutputStream) )
    {
        return FALSE;
    }

    for ( int i=1; i < NumElements; i++ )
    {
        OutputStream << m_SeparatorChar;
        if ( OutputStream.fail() )
        {
            SetLastError(SDP_OUTPUT_ERROR);
            return FALSE;
        }

        if ( !GetAt(i)->PrintField(OutputStream) )
        {
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpltran.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#include "sdppch.h"

#include "sdpltran.h"


SDP_LINE_TRANSITION::SDP_LINE_TRANSITION(
    IN      LINE_TRANSITION_INFO    *LineTransitionInfo,
    IN      DWORD                   NumStates
    )
    : m_IsValid(FALSE),
      m_LineTransitionInfo(LineTransitionInfo),
      m_NumStates(NumStates)
{
    ASSERT(NULL != LineTransitionInfo);
    ASSERT(0 < NumStates);
    if ( (NULL == LineTransitionInfo) || (0 >= NumStates) )
    {
        return;
    }

    // verify each transition info structure
    // 
    for ( UINT i=0; i < NumStates; i++ )
    {
        // check if the line state value is consistent with the corresponding entry
        ASSERT(LineTransitionInfo[i].m_LineState == i);
        if ( LineTransitionInfo[i].m_LineState != i )
        {
            return;
        }

        // check that the separator character string is initialized (NULL)
        ASSERT(NULL == LineTransitionInfo[i].m_SeparatorChars);
        if ( NULL != LineTransitionInfo[i].m_SeparatorChars )
        {
            return;
        }
    }

    m_IsValid = TRUE;

    // prepare separator character arrays for each of the line transition states
    for ( i=0; i < NumStates; i++ )
    {
        CHAR    *SeparatorChars;

        // allocate memory for the separator characters
        try
        {
            SeparatorChars = new CHAR[LineTransitionInfo[i].m_NumTransitions];
        }
        catch(...)
        {
            SeparatorChars = NULL;
        }

        if( NULL == SeparatorChars)
        {
            LineTransitionInfo[i].m_SeparatorChars = NULL;
            continue;
        }

        // copy each separator character into the character array
        for ( UINT j=0; j < LineTransitionInfo[i].m_NumTransitions; j++ )
        {
            SeparatorChars[j] = LineTransitionInfo[i].m_Transitions[j].m_SeparatorChar;
        }

        LineTransitionInfo[i].m_SeparatorChars = SeparatorChars;
    }

    return;
}



SDP_LINE_TRANSITION::~SDP_LINE_TRANSITION(
    )
{
    // if the m_IsValid flag is set, then the separator character arrays must have
    // been filled and need to be freed
    if ( IsValid() )
    {
        for ( UINT i=0; i < m_NumStates; i++ )
        {
            // this check is necessary for situations in which new raised exception when
            // allocating the character arrays in the constructor
            if ( NULL != m_LineTransitionInfo[i].m_SeparatorChars )
            {
                delete m_LineTransitionInfo[i].m_SeparatorChars;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpltran.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_LINE_TRANSITION__
#define __SDP_LINE_TRANSITION__

#include "sdpdef.h"

// this value indicates that line transitions have reached an end state
// this value needs to be different from the value of any of the line states
const DWORD LINE_END    = 10000;

struct LINE_TRANSITION
{
    CHAR    m_SeparatorChar;
    DWORD   m_NewLineState;
};


struct LINE_TRANSITION_INFO
{
    DWORD                   m_LineState;
    CHAR                    *m_SeparatorChars;
    BYTE                    m_NumTransitions;
    const LINE_TRANSITION   *m_Transitions;  // array of state transitions
};




#define LINE_TRANSITION_ENTRY(State, TransitionsArray)                                  \
{                                                                                       \
    State,                                                                              \
    NULL,                                                                               \
    (BYTE)((NULL == TransitionsArray)? 0 : sizeof(TransitionsArray)/sizeof(LINE_TRANSITION)),   \
    TransitionsArray                                                                    \
}



class SDP_LINE_TRANSITION
{
public:

    SDP_LINE_TRANSITION(
        IN      LINE_TRANSITION_INFO    *LineTransitionInfo,
        IN      DWORD                   NumStates
        );

    inline BOOL     IsValid() const;

    inline DWORD    GetNumStates() const;

    inline const LINE_TRANSITION_INFO   *GetAt(IN  DWORD    LineState) const;

    ~SDP_LINE_TRANSITION();

protected:

    BOOL                            m_IsValid;
    LINE_TRANSITION_INFO    * const m_LineTransitionInfo;
    DWORD                           m_NumStates;
};



inline BOOL     
SDP_LINE_TRANSITION::IsValid(
    ) const
{
    return m_IsValid;
}


inline DWORD    
SDP_LINE_TRANSITION::GetNumStates(
    ) const
{
    return m_NumStates;
}


inline const LINE_TRANSITION_INFO   *
SDP_LINE_TRANSITION::GetAt(
    IN  DWORD    LineState
    ) const
{
    ASSERT(LineState < m_NumStates);
    if ( LineState >= m_NumStates )
    {
        SetLastError(SDP_INTERNAL_ERROR);
        return NULL;
    }

    return &m_LineTransitionInfo[LineState];
}


#endif // __SDP_LINE_TRANSITION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdppch.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_PARSER_PCH__
#define __SDP_PARSER_PCH__

// all the common include files, forward declarations
#include "sdpcommo.h"

// all the consts, inline methods
#include "sdpdef.h"



#endif // __SDP_PARSER_PCH__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpmedia.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#include "sdppch.h"

#include <strstrea.h>

#include "sdpmedia.h"
#include "sdpltran.h"
#include "sdp.h"


// line transition states
enum MEDIA_TRANSITION_STATES
{
    MEDIA_START,
    MEDIA_NAME,
    MEDIA_PORT,
    MEDIA_PORT_NUM_PORTS,
    MEDIA_NUM_PORTS,
    MEDIA_PROTOCOL,
    MEDIA_FORMAT_CODE,
    MEDIA_FORMAT_CODE_END
};




// table for media line transitions

const LINE_TRANSITION g_MediaStartTransitions[]     =   {   
    {CHAR_BLANK,        MEDIA_NAME}             
};

const LINE_TRANSITION g_MediaNameTransitions[]      =   {   
    {CHAR_BLANK,        MEDIA_PORT},
    {CHAR_BACK_SLASH,   MEDIA_PORT_NUM_PORTS}   
};

const LINE_TRANSITION g_MediaPortTransitions[]      =   {   
    {CHAR_BLANK,        MEDIA_PROTOCOL}         
};

const LINE_TRANSITION g_MediaPortNumPortsTransitions[]= {   
    {CHAR_BLANK,        MEDIA_NUM_PORTS}        
};

const LINE_TRANSITION g_MediaNumPortsTransitions[]  =   {   
    {CHAR_BLANK,        MEDIA_PROTOCOL}         
};

const LINE_TRANSITION g_MediaProtocolTransitions[]  =   {   
    {CHAR_BLANK,        MEDIA_FORMAT_CODE},
    {CHAR_NEWLINE,      MEDIA_FORMAT_CODE_END}      
};

const LINE_TRANSITION g_MediaFormatCodeTransitions[]=   {   
    {CHAR_BLANK,        MEDIA_FORMAT_CODE},
    {CHAR_NEWLINE,      MEDIA_FORMAT_CODE_END}      
};


/* no transitions */
const LINE_TRANSITION *g_MediaFormatCodeEndTransitions  = NULL;  


LINE_TRANSITION_INFO g_MediaTransitionInfo[] = {
    LINE_TRANSITION_ENTRY(MEDIA_START,          g_MediaStartTransitions),

    LINE_TRANSITION_ENTRY(MEDIA_NAME,           g_MediaNameTransitions),

    LINE_TRANSITION_ENTRY(MEDIA_PORT,           g_MediaPortTransitions),

    LINE_TRANSITION_ENTRY(MEDIA_PORT_NUM_PORTS, g_MediaPortNumPortsTransitions),

    LINE_TRANSITION_ENTRY(MEDIA_NUM_PORTS,      g_MediaNumPortsTransitions),

    LINE_TRANSITION_ENTRY(MEDIA_PROTOCOL,       g_MediaProtocolTransitions),

    LINE_TRANSITION_ENTRY(MEDIA_FORMAT_CODE,    g_MediaFormatCodeTransitions),

    LINE_TRANSITION_ENTRY(MEDIA_FORMAT_CODE_END,g_MediaFormatCodeEndTransitions)
};



SDP_LINE_TRANSITION g_MediaTransition(
                        g_MediaTransitionInfo, 
                        sizeof(g_MediaTransitionInfo)/sizeof(LINE_TRANSITION_INFO)
                        );


SDP_MEDIA::SDP_MEDIA(
    )
    : SDP_VALUE(SDP_INVALID_MEDIA_FIELD, MEDIA_STRING, &g_MediaTransition),
      m_Title(SDP_INVALID_MEDIA_TITLE, MEDIA_TITLE_STRING),
      m_AttributeList(MEDIA_ATTRIBUTE_STRING)
{
    m_NumPorts.SetValue(1);
}



void
SDP_MEDIA::InternalReset(
    )
{
	m_Name.Reset();
	m_StartPort.Reset();
    m_NumPorts.Reset();
    m_TransportProtocol.Reset();
    m_FormatCodeList.Reset();
    m_Title.Reset();
    m_Connection.Reset();
    m_Bandwidth.Reset();
    m_EncryptionKey.Reset();
    m_AttributeList.Reset();

}


BOOL    
SDP_MEDIA::CalcIsModified(
    ) const
{
    ASSERT(IsValid());

    return  
        m_Title.IsModified()            || 
        m_Connection.IsModified()       ||
        m_Bandwidth.IsModified()        ||
        SDP_VALUE::CalcIsModified()     ||
        m_EncryptionKey.IsModified()    ||
        m_AttributeList.IsModified();
}


DWORD   
SDP_MEDIA::CalcCharacterStringSize(
    )
{
    ASSERT(IsValid());

    return  (
        m_Title.GetCharacterStringSize()            + 
        m_Connection.GetCharacterStringSize()       +
        m_Bandwidth.GetCharacterStringSize()        +
        SDP_VALUE::CalcCharacterStringSize()        +
        m_EncryptionKey.GetCharacterStringSize()    +
        m_AttributeList.GetCharacterStringSize()
        );
}


BOOL    
SDP_MEDIA::CopyValue(
        OUT         ostrstream  &OutputStream
    )
{
    ASSERT(IsValid());

    return  (   
        SDP_VALUE::CopyValue(OutputStream)          &&
        m_Title.PrintValue(OutputStream)            &&
        m_Connection.PrintValue(OutputStream)       &&
        m_Bandwidth.PrintValue(OutputStream)        &&
        m_EncryptionKey.PrintValue(OutputStream)    &&
        m_AttributeList.PrintValue(OutputStream)    
        );
}



// this is a workaround/hack for reusing the base class SDP_VALUE code for PrintValue().
// it replaces the separator char for the last read field with a newline, so that when
// PrintValue() executes and prints the time period list, it puts the newline character at
// the end of the list (rather than CHAR_BLANK)
BOOL    
SDP_MEDIA::InternalParseLine(
    IN  OUT         CHAR    *&Line
    )
{
    if ( !SDP_VALUE::InternalParseLine(Line) )
    {
        return FALSE;
    }
    
    m_SeparatorCharArray[m_SeparatorCharArray.GetSize()-1] = CHAR_NEWLINE;
    return TRUE;
}



BOOL
SDP_MEDIA::GetField(
        OUT SDP_FIELD   *&Field,
        OUT BOOL        &AddToArray
    )
{
    // add in all cases by default
    AddToArray = TRUE;

    switch(m_LineState)
    {
    case MEDIA_NAME:
        {
            Field = &m_Name;
        }

        break;

    case MEDIA_PORT:
        {
            Field = &m_StartPort;
        }

       break;

    case MEDIA_PORT_NUM_PORTS:
        {
            Field = &m_StartPort;
        }

       break;

    case MEDIA_NUM_PORTS:
        {
            Field = &m_NumPorts;
        }

        break;

    case MEDIA_PROTOCOL:
        {
            Field = &m_TransportProtocol;
        }

        break;

    case MEDIA_FORMAT_CODE:
    case MEDIA_FORMAT_CODE_END:
        {
            if ( m_FormatCodeList.GetSize() > 0 )
            {
                AddToArray = FALSE;
            }

            Field = &m_FormatCodeList;
        }

        break;

    default:
        {
            SetLastError(m_ErrorCode);
            return FALSE;
        }

        break;
    };

    return TRUE;
}


HRESULT 
SDP_MEDIA::SetPortInfo(
	IN	USHORT StartPort, 
	IN	USHORT NumPorts
	)
{
	ASSERT(IsValid());

	// validate parameters
	// num ports or start port cannot be 0
	if ( (0 == StartPort) || (0 == NumPorts) )
	{
		return E_INVALIDARG;
	}

	// set member variables to the start port
	m_StartPort.SetValue(StartPort);

	// if the number of ports field is already valid, then 
	if ( m_NumPorts.IsValid() )
	{
		// set the value and return, no changes required in the 
		// field/separator arrays
		m_NumPorts.SetValue(NumPorts);
		return S_OK;
	}
	else	// ports field is not in the field array
	{
		// if the number of ports is 1, no changes are required
		if ( 1 == NumPorts )
		{
			return S_OK;
		}
	
		// set the value and flag for the num ports field
		m_NumPorts.SetValueAndFlag(NumPorts);

		// insert the num ports field/separator after the the 
		// media name and port fields/separators
        // the new port separator must be CHAR_BACK_SLASH
		ASSERT(m_FieldArray.GetSize() == m_SeparatorCharArray.GetSize());
		
		m_SeparatorCharArray.SetAt(1, CHAR_BACK_SLASH);
		m_FieldArray.InsertAt(2, &m_NumPorts);
		m_SeparatorCharArray.InsertAt(2, CHAR_BLANK);
	}

	return S_OK;
}


SDP_VALUE    *
SDP_MEDIA_LIST::CreateElement(
    )
{
    SDP_MEDIA   *SdpMedia;
    
    try
    {
        SdpMedia = new SDP_MEDIA();
    }
    catch(...)
    {
        SdpMedia = NULL;
    }

    if( NULL == SdpMedia )
    {
        return NULL;
    }

    SdpMedia->GetTitle().GetBstring().SetCharacterSet(m_CharacterSet);

    return SdpMedia;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpsadj.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#include "sdppch.h"

#include <afxdisp.h>
#include <winerror.h>
#include <oleauto.h>

#include "sdpsadj.h"
#include "sdptime.h"


SDP_ADJUSTMENT_SAFEARRAY::SDP_ADJUSTMENT_SAFEARRAY(
    IN      SDP_ADJUSTMENT  &SdpAdjustment
    )
    : SDP_TIME_PERIOD_SAFEARRAY(SdpAdjustment.GetOffsets()),
      SDP_ULONG_SAFEARRAY(SdpAdjustment.GetAdjustmentTimes())
{
    m_VarType[0] = VT_UI4;
    m_VarType[1] = VT_BOOL;
    m_VarType[2] = VT_I1;
    m_VarType[3] = VT_I4;
    m_VarType[4] = VT_I4;
}


HRESULT
SDP_ADJUSTMENT_SAFEARRAY::GetSafeArray(
		OUT VARIANT   *AdjustmentTimesVariant,
		OUT VARIANT   *IsCompactVariant,
		OUT VARIANT   *UnitVariant,
		OUT VARIANT   *CompactValueVariant,
		OUT VARIANT   *PeriodValueVariant
    )
{
    ASSERT(SDP_ULONG_SAFEARRAY::m_TList.GetSize() == SDP_TIME_PERIOD_SAFEARRAY::m_TList.GetSize());

    VARIANT   *VariantArray[] = {
            AdjustmentTimesVariant,
            IsCompactVariant, UnitVariant,
            CompactValueVariant, PeriodValueVariant
            };

    // SDP_ULONG_SAFEARRAY:: prefix merely resolves the GetSafeArrays method
    // the get and set methods are over-ridden to account for the adjustment as well as the other
    // time period elements
    return SDP_ULONG_SAFEARRAY::GetSafeArrays(
        (DWORD)SDP_ULONG_SAFEARRAY::m_TList.GetSize(),
        sizeof(VariantArray)/sizeof(VARIANT *),
        m_VarType,
        VariantArray
        );
}

BOOL
SDP_ADJUSTMENT_SAFEARRAY::GetElement(
    IN      ULONG   Index,
    IN      ULONG   NumEntries,
    IN      void    **Element,
        OUT HRESULT &HResult
    )
{
    ASSERT(5 == NumEntries);

    SDP_ULONG   *AdjustmentTime = SDP_ULONG_SAFEARRAY::GetListMember(Index, HResult);
    if ( NULL == AdjustmentTime )
    {
        return FALSE;
    }

    SDP_TIME_PERIOD   *Offset = SDP_TIME_PERIOD_SAFEARRAY::GetListMember(Index, HResult);
    if ( NULL == Offset )
    {
        return FALSE;
    }

    ASSERT(AdjustmentTime->IsValid());
    ASSERT(Offset->IsValid());

    if ( !SDP_ULONG_SAFEARRAY::Get(*AdjustmentTime, 1, Element, HResult)            ||
         !SDP_TIME_PERIOD_SAFEARRAY::Get(*Offset, 4, &Element[1], HResult)   )
    {
        return FALSE;
    }

    return TRUE;
}


BOOL
SDP_ADJUSTMENT_SAFEARRAY::SetElement(
    IN      ULONG   Index,
    IN      ULONG   NumEntries,
    IN      void    ***Element,
        OUT HRESULT &HResult
    )
{
    ASSERT(5 == NumEntries);

    SDP_ULONG   *AdjustmentTime = SDP_ULONG_SAFEARRAY::CreateListMemberIfRequired(Index, HResult);
    if ( NULL == AdjustmentTime )
    {
        return FALSE;
    }

    SDP_TIME_PERIOD   *Offset = SDP_TIME_PERIOD_SAFEARRAY::CreateListMemberIfRequired(Index, HResult);
    if ( NULL == Offset )
    {
        return FALSE;
    }

    VERIFY(SDP_ULONG_SAFEARRAY::Set(*AdjustmentTime, 1, Element, HResult));
    VERIFY(SDP_TIME_PERIOD_SAFEARRAY::Set(*Offset, 4, &Element[1], HResult));

    ASSERT(AdjustmentTime->IsValid());
    ASSERT(Offset->IsValid());

    // if its a newly created instance, make it valid and add it to the list at the appropriate
    // index
    ASSERT(SDP_ULONG_SAFEARRAY::m_TList.GetSize() == SDP_TIME_PERIOD_SAFEARRAY::m_TList.GetSize());
    if ( Index >= (ULONG)SDP_ULONG_SAFEARRAY::m_TList.GetSize() )
    {
        try
        {
            SDP_ULONG_SAFEARRAY::m_TList.SetAtGrow(Index, AdjustmentTime);            
        }
        catch(...)
        {
            delete AdjustmentTime;
            delete Offset;

            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

        try
        {
            SDP_TIME_PERIOD_SAFEARRAY::m_TList.SetAtGrow(Index, Offset);
        }
        catch(...)
        {
            SDP_ULONG_SAFEARRAY::m_TList.RemoveAt(Index);      

            delete AdjustmentTime;
            delete Offset;

            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }
    }

    return TRUE;
}


void
SDP_ADJUSTMENT_SAFEARRAY::RemoveExcessElements(
    IN      ULONG   StartIndex
    )
{
    SDP_ULONG_SAFEARRAY::RemoveExcessElements(StartIndex);
    SDP_TIME_PERIOD_SAFEARRAY::RemoveExcessElements(StartIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpsadt.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#include "sdppch.h"

#include <afxdisp.h>
#include <winerror.h>
#include <oleauto.h>

#include "sdpsadt.h"
#include "sdpadtex.h"


HRESULT
SDP_ADDRESS_TEXT_SAFEARRAY::GetSafeArray(
        OUT VARIANT   *AddressVariant,
        OUT VARIANT   *TextVariant
    )
{
    VARIANT   *VariantArray[] = {AddressVariant, TextVariant};

    return GetSafeArrays(
        (DWORD)m_TList.GetSize(),
        sizeof(VariantArray)/sizeof(VARIANT *),
        m_VarType,
        VariantArray
        );
}


BOOL
SDP_ADDRESS_TEXT_SAFEARRAY::Get(
    IN      SDP_ADDRESS_TEXT    &ListMember,
    IN      ULONG               NumEntries,
    IN      void                **Element,
        OUT HRESULT             &HResult
    )
{
    ASSERT(2 == NumEntries);

    Element[0] = NULL;
    HResult = ListMember.GetAddress().GetBstr((BSTR *)&Element[0]);
    if ( FAILED(HResult) )
    {
        return FALSE;
    }

    Element[1] = NULL;
    HResult = ListMember.GetText().GetBstr((BSTR *)&Element[1]);

    return SUCCEEDED(HResult);
}


BOOL
SDP_ADDRESS_TEXT_SAFEARRAY::Set(
    IN      SDP_ADDRESS_TEXT    &ListMember,
    IN      ULONG               NumEntries,
    IN      void                ***Element,
        OUT HRESULT             &HResult
    )
{
    ASSERT(2 == NumEntries);

    // a null element in the FIRST safearray means that no more entries are present
    if ( (NULL == Element[0]) || (NULL == *(Element[0])) )
    {
        HResult = S_OK;
        return FALSE;
    }

    HResult = ListMember.SetAddressTextValues(*((BSTR *)Element[0]), *((BSTR *)Element[1]));

    return SUCCEEDED(HResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdporigi.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#include "sdppch.h"

#include "sdporigi.h"
#include "sdpltran.h"


// line transition states
enum ORIGIN_TRANSITION_STATES
{
    ORIGIN_START,
    ORIGIN_USER_NAME,
    ORIGIN_SESSION_ID,
    ORIGIN_SESSION_VERSION,
    ORIGIN_NETWORK_TYPE,
    ORIGIN_ADDRESS_TYPE,
    ORIGIN_ADDRESS
};


// table for origin line transitions

const LINE_TRANSITION g_OriginStartTransitions[]    =       {
    {CHAR_BLANK, ORIGIN_USER_NAME}
};

const LINE_TRANSITION g_OriginUserNameTransitions[] =       {
    {CHAR_BLANK, ORIGIN_SESSION_ID}
};

const LINE_TRANSITION g_OriginSessionIdTransitions[]=       {
    {CHAR_BLANK, ORIGIN_SESSION_VERSION}
};

const LINE_TRANSITION g_OriginSessionVersionTransitions[]=  {
    {CHAR_BLANK, ORIGIN_NETWORK_TYPE}
};

const LINE_TRANSITION g_OriginNetworkTypeTransitions[]=     {
    {CHAR_BLANK, ORIGIN_ADDRESS_TYPE}
};

const LINE_TRANSITION g_OriginAddressTypeTransitions[]=     {
    {CHAR_NEWLINE, ORIGIN_ADDRESS}
};


/* no transitions */
const LINE_TRANSITION *g_OriginAddressTransitions   =   NULL;  
      


LINE_TRANSITION_INFO g_OriginTransitionInfo[] = {
    LINE_TRANSITION_ENTRY(ORIGIN_START,         g_OriginStartTransitions),

    LINE_TRANSITION_ENTRY(ORIGIN_USER_NAME,     g_OriginUserNameTransitions),

    LINE_TRANSITION_ENTRY(ORIGIN_SESSION_ID,    g_OriginSessionIdTransitions),

    LINE_TRANSITION_ENTRY(ORIGIN_SESSION_VERSION,g_OriginSessionVersionTransitions),

    LINE_TRANSITION_ENTRY(ORIGIN_NETWORK_TYPE,  g_OriginNetworkTypeTransitions),

    LINE_TRANSITION_ENTRY(ORIGIN_ADDRESS_TYPE,  g_OriginAddressTypeTransitions),

    LINE_TRANSITION_ENTRY(ORIGIN_ADDRESS,       g_OriginAddressTransitions)
};




SDP_LINE_TRANSITION g_OriginTransition(
                        g_OriginTransitionInfo, 
                        sizeof(g_OriginTransitionInfo)/sizeof(LINE_TRANSITION_INFO)
                        );




SDP_ORIGIN::SDP_ORIGIN(
    )
    : SDP_VALUE(SDP_INVALID_ORIGIN_FIELD, ORIGIN_STRING, &g_OriginTransition),
      m_NetworkType(LIMITED_NETWORK_TYPES, NUM_NETWORK_TYPES),
      m_AddressType(LIMITED_ADDRESS_TYPES, NUM_ADDRESS_TYPES)
{
}


void
SDP_ORIGIN::InternalReset(
    )
{
	m_UserName.Reset();
	m_SessionId.Reset();
    m_SessionVersion.Reset();
    m_NetworkType.Reset();
    m_AddressType.Reset();
    m_Address.Reset();
}


BOOL
SDP_ORIGIN::GetField(
        OUT SDP_FIELD   *&Field,
        OUT BOOL        &AddToArray
    )
{
    // add in all cases by default
    AddToArray = TRUE;

    switch(m_LineState)
    {
    case ORIGIN_USER_NAME:
        {
            Field = &m_UserName;
        }

        break;

   case ORIGIN_SESSION_ID:
        {
            Field = &m_SessionId;
        }

        break;

    case ORIGIN_SESSION_VERSION:
        {
            Field = &m_SessionVersion;
        }

        break;

    case ORIGIN_NETWORK_TYPE:
        {
            Field = &m_NetworkType;
        }

        break;

    case ORIGIN_ADDRESS_TYPE:
        {
            Field = &m_AddressType;
        }

        break;

    case ORIGIN_ADDRESS:
        {
            Field = &m_Address;
        }

        break;

    default:
        {
            SetLastError(m_ErrorCode);
            return FALSE;
        }

        break;
    };

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpsarr.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#include "sdppch.h"

#include "sdpsarr.h"


inline void
IncrementIndices(
    IN      ULONG   NumSafeArrays,
    IN  OUT LONG    *Index
    )
{
    for (ULONG i=0; i < NumSafeArrays; i++)
    {
        Index[i]++;
    }
}


inline ULONG
MinSize(
    IN      const   ULONG	NumSafeArrays,
    IN              VARIANT	*Variant[]
    )
{
    ULONG   ReturnValue = 0;
    for (UINT i=0; i < NumSafeArrays; i++)
    {
        if ( ReturnValue < V_ARRAY(Variant[i])->rgsabound[0].cElements )
        {
            ReturnValue = V_ARRAY(Variant[i])->rgsabound[0].cElements;
        }
    }

    return ReturnValue;
}


BOOL
SDP_SAFEARRAY::CreateAndAttach(
    IN          ULONG       MinSize,
    IN          VARTYPE     VarType,
    IN  OUT     VARIANT     &Variant,
        OUT     HRESULT     &HResult
    )
{
    // create a 1 based 1 dimensional safearray
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 1;
    rgsabound[0].cElements = MinSize;
    SAFEARRAY *SafeArray = SafeArrayCreate(VarType, 1, rgsabound);
    if ( NULL == SafeArray )
    {
        HResult = E_OUTOFMEMORY;
        return FALSE;
    }

    // set the variant type
    V_VT(&Variant) = VT_ARRAY | VarType;
    V_ARRAY(&Variant) = SafeArray;

    // attach the variant to the instance
    Attach(Variant);

    HResult = S_OK;
    return TRUE;
}



HRESULT 
SDP_SAFEARRAY_WRAP::GetSafeArrays(
    IN      const   ULONG       NumElements,                                        
    IN      const   ULONG       NumSafeArrays,
    IN              VARTYPE     VarType[],
        OUT         VARIANT		*Variant[]
    )
{
    if ( 0 == NumElements )
    {
        return HRESULT_FROM_ERROR_CODE(ERROR_INVALID_DATA);
    }

	// clear each of the variants (it may not be a safearray)
	for(ULONG Index=0; Index < NumSafeArrays; Index++)
	{
		BAIL_IF_NULL(Variant[Index], E_INVALIDARG);
        BAIL_ON_FAILURE(VariantClear(Variant[Index]));
	}

    try
    {
        DYNAMIC_POINTER_ARRAY<SDP_SAFEARRAY>   SdpSafeArray(NumSafeArrays);
        for (ULONG j=0; j < NumSafeArrays; j++)
        {
            HRESULT HResult;

            // create 1 based one-dimensional safearrays
            if ( !SdpSafeArray[j].CreateAndAttach(NumElements, VarType[j], *(Variant[j]), HResult) )
            {
                for (ULONG k=0; k < j; k++)
                {
                    HRESULT FreeResult;
                    if ( !SdpSafeArray[k].Free(FreeResult) )
                    {
                        return FreeResult;
                    }
                }

                return HResult;
            }
        }

        // for each element in the attribute list, add the bstr
        // to the safe array
        // the indexing begins at 1 (1 based one-dimensional array)
        LONG Index = 1;
        DYNAMIC_ARRAY<void *>   Element(NumSafeArrays);
        for( ULONG i= 0; i < NumElements; i++, Index++ )
        {
            HRESULT HResult;

            if ( !GetElement(i, NumSafeArrays, Element(), HResult) )
            {
                return HResult;
            }
            
            // assign the list element to the ith safe array element
            for (j=0; j < NumSafeArrays; j++)
            {
                SdpSafeArray[j].PutElement(&Index, Element[j]);
            }
        }
    }
    catch(COleException *pOleException)
    {
        // *** convert the SCODE to HRESULT
        HRESULT hr = ResultFromScode(pOleException->Process(pOleException));
        pOleException->Delete();
        return hr;
    }

    return S_OK;
}


HRESULT 
SDP_SAFEARRAY_WRAP::SetSafeArrays(
    IN      const   ULONG       NumSafeArrays,
    IN              VARTYPE     VarType[],
    IN              VARIANT		*Variant[]
    )
{
    // validate parameter
    for ( ULONG j=0; j < NumSafeArrays; j++ )
    {
        if ( !ValidateSafeArray(VarType[j], Variant[j]) )
        {
            return E_INVALIDARG;
        }
    }

    try
    {
        DYNAMIC_POINTER_ARRAY<SDP_SAFEARRAY>   SdpSafeArray(NumSafeArrays);
        for (j=0; j < NumSafeArrays; j++)
        {
            SdpSafeArray[j].Attach(*(Variant[j]));
        }

        // while there are elements in the list, set bstrs
        // if no corresponding element in the list, create and add a new one
        DYNAMIC_ARRAY<LONG>   Index(NumSafeArrays);
        for (j=0; j < NumSafeArrays; j++)
        {
            Index[j] = V_ARRAY(Variant[j])->rgsabound[0].lLbound;
        }

        DYNAMIC_ARRAY<void **>   Element(NumSafeArrays);

        // need only consider the number of items in the smallest sized safearray
        ULONG   MinSafeArraySize = MinSize(NumSafeArrays, Variant);

        // *** currently not checking that all safe arrays have the same number of non-null
        // elements
        for ( ULONG i = 0; 
              i < MinSafeArraySize; 
              i++, IncrementIndices(NumSafeArrays, Index())
            )
        {
            for (j=0; j < NumSafeArrays; j++)
            {
                SdpSafeArray[j].PtrOfIndex(&Index[j], (void **)&Element[j]);
            }          

            HRESULT HResult;

            // grow the list if required
            if ( !SetElement(i, NumSafeArrays, Element(), HResult) )
            {
                // success means that there are no more elements in the safe array
                if ( SUCCEEDED(HResult) )
                {
                    break;
                }
                else
                {
                    return HResult;
                }
            }
        } 

        // get rid of  each list element that is in excess of the safearray members
        RemoveExcessElements(i);
    }
    catch(COleException *pOleException)
    {
        // *** convert the SCODE to HRESULT
        HRESULT hr = ResultFromScode(pOleException->Process(pOleException));
        pOleException->Delete();
        return hr;
    }

    return S_OK;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpsobst.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#include "sdppch.h"

#include <afxdisp.h>
#include <winerror.h>
#include <oleauto.h>

#include "sdpbstrl.h"
#include "sdpsobst.h"


SDP_FIELD   *
SDP_OPT_BSTRING_LIST::CreateElement(
    )
{
    SDP_OPTIONAL_BSTRING *SdpOptionalBString;

    try
    {
        SdpOptionalBString = new SDP_OPTIONAL_BSTRING();
    }
    catch(...)
    {
        SdpOptionalBString = NULL;
    }

    return SdpOptionalBString;
}


HRESULT
SDP_OPT_BSTRING_SAFEARRAY::GetSafeArray(
        OUT VARIANT   *OptBstringVariant
    )
{
    VARIANT   *VariantArray[] = {OptBstringVariant};

    return GetSafeArrays(
        (ULONG) m_TList.GetSize(),
        sizeof(VariantArray)/sizeof(VARIANT *),
        m_VarType,
        VariantArray
        );
}


BOOL
SDP_OPT_BSTRING_SAFEARRAY::Get(
    IN      SDP_OPTIONAL_BSTRING    &ListMember,
    IN      ULONG                   NumEntries,
    IN      void                    **Element,
        OUT HRESULT                 &HResult
    )
{
    ASSERT(1 == NumEntries);

    Element[0] = NULL;
    HResult = ListMember.GetBstr((BSTR *)&Element[0]);
    return SUCCEEDED(HResult);
}


BOOL
SDP_OPT_BSTRING_SAFEARRAY::Set(
    IN      SDP_OPTIONAL_BSTRING    &ListMember,
    IN      ULONG                   NumEntries,
    IN      void                    ***Element,
        OUT HRESULT                 &HResult
    )
{
    ASSERT(1 == NumEntries);

    HResult = ListMember.SetBstr(*((BSTR *)Element[0]));

    return SUCCEEDED(HResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpstp.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#include "sdppch.h"

#include <afxdisp.h>
#include <winerror.h>
#include <oleauto.h>

#include "sdpstp.h"
#include "sdptime.h"

HRESULT
SDP_TIME_PERIOD_SAFEARRAY::GetSafeArray(
		OUT VARIANT	*IsCompactVariant,
		OUT VARIANT	*UnitVariant,
		OUT VARIANT	*CompactValueVariant,
		OUT VARIANT	*PeriodValueVariant
    )
{
    VARIANT   *VariantArray[] = {
            IsCompactVariant, UnitVariant,
            CompactValueVariant, PeriodValueVariant
            };

    return GetSafeArrays(
        (ULONG)m_TList.GetSize(),
        sizeof(VariantArray)/sizeof(VARIANT *),
        m_VarType,
        VariantArray
        );
}


BOOL
SDP_TIME_PERIOD_SAFEARRAY::Get(
    IN      SDP_TIME_PERIOD &ListMember,
    IN      ULONG           NumEntries,
    IN      void            **Element,
        OUT HRESULT         &HResult
    )
{
    ASSERT(4 == NumEntries);

    BOOL    IsCompact;
    ListMember.Get(IsCompact, m_Unit, m_CompactValue, m_PeriodValue);
    m_IsCompact = (IsCompact) ? VARIANT_TRUE: VARIANT_FALSE;

    Element[0] = &m_IsCompact;
    Element[1] = &m_Unit;
    Element[2] = &m_CompactValue;
    Element[3] = &m_PeriodValue;

    HResult = S_OK;

    return TRUE;
}


BOOL
SDP_TIME_PERIOD_SAFEARRAY::Set(
    IN      SDP_TIME_PERIOD &ListMember,
    IN      ULONG           NumEntries,
    IN      void            ***Element,
        OUT HRESULT         &HResult
    )
{
    ASSERT(4 == NumEntries);

    BOOL    IsCompact = (VARIANT_FALSE == (VARIANT_BOOL)*(Element[0])) ? FALSE : TRUE;
    ListMember.Set(
        IsCompact,
        *((CHAR *)Element[1]),
        *((LONG *)Element[2]),
        *((LONG *)Element[3])
        );

    return SUCCEEDED(HResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpsatt.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#include "sdppch.h"

#include "sdpbstrl.h"
#include <oleauto.h>

#include "sdpsatt.h"
#include "sdpatt.h"




HRESULT
SDP_ATTRIBUTE_SAFEARRAY::GetSafeArray(
        OUT VARIANT	*Variant
    )
{
    return SDP_SAFEARRAY_WRAP::GetSafeArrays((DWORD)m_TList.GetSize(), 1, m_VarType, &Variant);
}




BOOL
SDP_ATTRIBUTE_SAFEARRAY::Get(
    IN      SDP_CHAR_STRING_LINE    &ListMember,
    IN      ULONG                   NumEntries,
    IN      void                    **Element,
        OUT HRESULT                 &HResult
    )
{
    ASSERT(1 == NumEntries);

    Element[0] = NULL;
    HResult = ListMember.GetBstring().GetBstr((BSTR *)&Element[0]);

    return SUCCEEDED(HResult);
}


BOOL
SDP_ATTRIBUTE_SAFEARRAY::Set(
    IN      SDP_CHAR_STRING_LINE    &ListMember,
    IN      ULONG                   NumEntries,
    IN      void                    ***Element,
        OUT HRESULT                 &HResult
    )
{
    ASSERT(1 == NumEntries);

    // a null element in the FIRST safearray means that no more entries are present
    if ( (NULL == Element[0]) || (NULL == *(Element[0])) )
    {
        HResult = S_OK;
        return FALSE;
    }

    HResult = ListMember.SetBstr(*((BSTR *)Element[0]));

    return SUCCEEDED(HResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpstran.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#ifndef __SDP_STATE_TRANSITIONS__
#define __SDP_STATE_TRANSITIONS__




#define STATE_TRANSITION_ENTRY(State, TransitionsArray)   \
{State,  sizeof(TransitionsArray)/sizeof(STATE_TRANSITION), TransitionsArray }



struct STATE_TRANSITION
{
    CHAR        m_Type;
    PARSE_STATE m_NewParseState;
};



struct TRANSITION_INFO
{
    PARSE_STATE                 m_ParseState;
    BYTE                        m_NumTransitions;
    const STATE_TRANSITION      *m_Transitions;  // array of state transitions
};



// macro for parsing a line into a member field of a list element
// this cannot be done using a template because several members of the
// list element may have the same type
    /* get the current element in the list */                           
    /* get the member in the element */                                 
    /* parse the line into the member */                                    
#define ParseMember(ELEMENT_TYPE, List, MEMBER_TYPE, MemberFunction, Line, Result)    \
{                                                                       \
    ELEMENT_TYPE *Element = (ELEMENT_TYPE *)List.GetCurrentElement();                   \
                                                                        \
    MEMBER_TYPE &Member = Element->MemberFunction();                    \
                                                                        \
    Result = Member.ParseLine(Line);                                   \
}                                                                       



#endif // __SDP_STATE_TRANSITIONS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdptime.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#include "sdppch.h"

#include <strstrea.h>

#include "sdptime.h"
#include "sdpltran.h"




// line transition states
enum TIME_TRANSITION_STATES
{
    TIME_START,
    TIME_START_TIME,
    TIME_STOP_TIME
};


// table for time line transitions

const LINE_TRANSITION g_TimeStartTransitions[]      =   {
    {CHAR_BLANK,    TIME_START_TIME}
};

const LINE_TRANSITION g_TimeStartTimeTransitions[]  =   {
    {CHAR_NEWLINE,  TIME_STOP_TIME}
};


/* no transitions */
const LINE_TRANSITION *g_TimeStopTimeTransitions    =   NULL;


LINE_TRANSITION_INFO g_TimeTransitionInfo[] = {
    LINE_TRANSITION_ENTRY(TIME_START,       g_TimeStartTransitions),

    LINE_TRANSITION_ENTRY(TIME_START_TIME,  g_TimeStartTimeTransitions),

    LINE_TRANSITION_ENTRY(TIME_STOP_TIME,   g_TimeStopTimeTransitions)
};



SDP_LINE_TRANSITION g_TimeTransition(
                        g_TimeTransitionInfo,
                        sizeof(g_TimeTransitionInfo)/sizeof(LINE_TRANSITION_INFO)
                        );




// line transition states
enum REPEAT_TRANSITION_STATES
{
    REPEAT_START,
    REPEAT_INTERVAL,
    REPEAT_DURATION,
    REPEAT_OFFSET,
    REPEAT_OFFSET_END
};




// table for repeat time line transitions

const LINE_TRANSITION g_RepeatStartTransitions[]    =   {
    {CHAR_BLANK,    REPEAT_INTERVAL}
};

const LINE_TRANSITION g_RepeatIntervalTransitions[] =   {
    {CHAR_BLANK,    REPEAT_DURATION}
};

const LINE_TRANSITION g_RepeatDurationTransitions[] =   {
    {CHAR_BLANK,    REPEAT_OFFSET},
    {CHAR_NEWLINE,  REPEAT_OFFSET_END}
};

const LINE_TRANSITION g_RepeatOffsetTransitions[]   =   {
    {CHAR_BLANK,    REPEAT_OFFSET},
    {CHAR_NEWLINE,  REPEAT_OFFSET_END}
};

/* no transitions */
const LINE_TRANSITION *g_RepeatOffsetEndTransitions =   NULL;


LINE_TRANSITION_INFO g_RepeatTransitionInfo[] = {
    LINE_TRANSITION_ENTRY(REPEAT_START,         g_RepeatStartTransitions),

    LINE_TRANSITION_ENTRY(REPEAT_INTERVAL,      g_RepeatIntervalTransitions),

    LINE_TRANSITION_ENTRY(REPEAT_DURATION,      g_RepeatDurationTransitions),

    LINE_TRANSITION_ENTRY(REPEAT_OFFSET,        g_RepeatOffsetTransitions),

    LINE_TRANSITION_ENTRY(REPEAT_OFFSET_END,    g_RepeatOffsetEndTransitions)
};




SDP_LINE_TRANSITION g_RepeatTransition(
                        g_RepeatTransitionInfo,
                        sizeof(g_RepeatTransitionInfo)/sizeof(LINE_TRANSITION_INFO)
                        );



// line transition states
enum ADJUSTMENT_TRANSITION_STATES
{
    ADJUSTMENT_START,
    ADJUSTMENT_TIME,
    ADJUSTMENT_OFFSET,
    ADJUSTMENT_OFFSET_END
};



// table for adjustment time line transitions

const LINE_TRANSITION g_AdjustmentStartTransitions[]        =   {
    {CHAR_BLANK,    ADJUSTMENT_TIME}
};

const LINE_TRANSITION g_AdjustmentTimeTransitions[]         =   {
    {CHAR_BLANK,    ADJUSTMENT_OFFSET},
    {CHAR_NEWLINE,  ADJUSTMENT_OFFSET_END}
};

const LINE_TRANSITION g_AdjustmentOffsetTransitions[]       =   {
    {CHAR_BLANK,    ADJUSTMENT_TIME},
    {CHAR_NEWLINE,  ADJUSTMENT_OFFSET_END}
};


/* no transitions */
const LINE_TRANSITION *g_AdjustmentOffsetEndTransitions     =   NULL;



LINE_TRANSITION_INFO g_AdjustmentTransitionInfo[] = {
    LINE_TRANSITION_ENTRY(ADJUSTMENT_START,         g_AdjustmentStartTransitions),

    LINE_TRANSITION_ENTRY(ADJUSTMENT_TIME,          g_AdjustmentTimeTransitions),

    LINE_TRANSITION_ENTRY(ADJUSTMENT_OFFSET,        g_AdjustmentOffsetTransitions),

    LINE_TRANSITION_ENTRY(ADJUSTMENT_OFFSET_END,    g_AdjustmentOffsetEndTransitions)
};




SDP_LINE_TRANSITION g_AdjustmentTransition(
                        g_AdjustmentTransitionInfo,
                        sizeof(g_AdjustmentTransitionInfo)/sizeof(LINE_TRANSITION_INFO)
                        );


// time units
const   CHAR    TIME_UNITS[]                    = {'d', 'h', 'm', 's', 'Y', 'M'};
const   BYTE    NUM_TIME_UNITS                  = sizeof(TIME_UNITS)/sizeof(CHAR);




BOOL
SDP_TIME_PERIOD::PrintData(
        OUT ostrstream  &OutputStream
        )
{
    if ( m_IsCompact )
    {
        OutputStream << (LONG)m_CompactValue;
        if ( OutputStream.fail() )
        {
            SetLastError(SDP_OUTPUT_ERROR);
            return FALSE;
        }

        OutputStream << (CHAR)m_Unit;
        if ( OutputStream.fail() )
        {
            SetLastError(SDP_OUTPUT_ERROR);
            return FALSE;
        }
    }
    else
    {
        OutputStream << (LONG)m_PeriodValue;
        if ( OutputStream.fail() )
        {
            SetLastError(SDP_OUTPUT_ERROR);
            return FALSE;
        }
    }

    return TRUE;
}



// parse the time period field
// of the form [-]LONG[time_unit]
BOOL
SDP_TIME_PERIOD::InternalParseToken(
    IN      CHAR        *Token
    )
{
    // remove the white spaces
    RemoveWhiteSpaces(Token);

    // convert the leading characters to a long value
    CHAR *RestOfString = NULL;
    LONG LongValue = strtol(Token, &RestOfString, 10);

    // if not successful
    if ( (LONG_MAX == LongValue) || (LONG_MIN == LongValue) )
    {
        SetLastError(SDP_INVALID_TIME_PERIOD);
        return FALSE;
    }

    // if the next character is EOS, we are done as it is a non-compact representation
    if ( EOS == *RestOfString )
    {
        m_IsCompact     = FALSE;
        m_PeriodValue   = LongValue;

        return TRUE;
    }

    // it might be a compact representation
    for ( UINT i=0; i < NUM_TIME_UNITS; i++ )
    {
        // check if the time unit is acceptable
        if ( TIME_UNITS[i] == *RestOfString )
        {
            // check that the next character is EOS - the token should
            // only be of the form [-]LONG[time_unit]
            if ( EOS != *(RestOfString+1) )
            {
                SetLastError(SDP_INVALID_TIME_PERIOD);
                return FALSE;
            }

            // set the member variables
            m_IsCompact     = TRUE;
            m_Unit          = TIME_UNITS[i];
            m_CompactValue  = LongValue;

            return TRUE;
        }
    }

    // not a valid time period
    SetLastError(SDP_INVALID_TIME_PERIOD);
    return FALSE;
}



SDP_FIELD *
SDP_TIME_PERIOD_LIST::CreateElement(
    )
{
    // create and return a new time period
    SDP_TIME_PERIOD *SdpTimePeriod;

    try
    {
        SdpTimePeriod = new SDP_TIME_PERIOD;
    }
    catch(...)
    {
        SdpTimePeriod = NULL;
    }

    return SdpTimePeriod;
}





SDP_REPEAT::SDP_REPEAT(
    )
    : SDP_VALUE(SDP_INVALID_REPEAT_FIELD, REPEAT_STRING, &g_RepeatTransition)
{}



void
SDP_REPEAT::InternalReset(
    )
{
	m_Interval.Reset();
	m_Duration.Reset();
    m_Offsets.Reset();
}



BOOL
SDP_REPEAT::GetField(
        OUT SDP_FIELD   *&Field,
        OUT BOOL        &AddToArray
    )
{
    // add in all cases by default
    AddToArray = TRUE;

    switch(m_LineState)
    {
    case REPEAT_INTERVAL:
        {
            Field = &m_Interval;
        }

        break;

   case REPEAT_DURATION:
        {
            Field = &m_Duration;
        }

        break;

    case REPEAT_OFFSET:
    case REPEAT_OFFSET_END:
        {
            if ( m_Offsets.GetSize() > 0 )
            {
                AddToArray = FALSE;
            }

            Field = &m_Offsets;
        }

        break;

    default:
        {
            SetLastError(m_ErrorCode);
            return FALSE;
        }

        break;
    };

    return TRUE;
}


// this is a workaround/hack for reusing the base class SDP_VALUE code for PrintValue().
// it replaces the separator char for the last read field with a newline, so that when
// PrintValue() executes and prints the time period list, it puts the newline character at
// the end of the list (rather than CHAR_BLANK)
BOOL
SDP_REPEAT::InternalParseLine(
    IN  OUT         CHAR    *&Line
    )
{
    if ( !SDP_VALUE::InternalParseLine(Line) )
    {
        return FALSE;
    }

    m_SeparatorCharArray[m_SeparatorCharArray.GetSize()-1] = CHAR_NEWLINE;
    return TRUE;
}



SDP_VALUE *
SDP_REPEAT_LIST::CreateElement(
    )
{
    SDP_REPEAT *SdpRepeat;

    try
    {
        SdpRepeat = new SDP_REPEAT();
    }
    catch(...)
    {
        SdpRepeat = NULL;
    }

    return SdpRepeat;
}




SDP_ADJUSTMENT::SDP_ADJUSTMENT(
    )
    : SDP_VALUE(SDP_INVALID_ADJUSTMENT_FIELD, ADJUSTMENT_STRING, &g_AdjustmentTransition),
      SDP_ADJUSTMENT_SAFEARRAY(*this)
{}



void
SDP_ADJUSTMENT::InternalReset(
    )
{
    m_AdjustmentTimes.Reset();
    m_Offsets.Reset();
}



BOOL
SDP_ADJUSTMENT::CalcIsModified(
    ) const
{
    ASSERT(IsValid());
    return ( m_AdjustmentTimes.IsModified() || m_Offsets.IsModified() );
}



DWORD
SDP_ADJUSTMENT::CalcCharacterStringSize(
    )
{
    ASSERT(IsValid());

    if ( m_AdjustmentTimes.IsModified() || m_Offsets.IsModified() )
    {
        // this copy should not fail as the buffer size should be sufficient for
        // all forseeable situations
        ASSERT(NULL != m_PrintBuffer);
        ostrstream  OutputStream(m_PrintBuffer, sizeof(m_PrintBuffer));

        BOOL    Success = PrintData(OutputStream);
        ASSERT(Success);

        m_PrintLength = OutputStream.pcount();
        m_PrintBuffer[m_PrintLength] = EOS;
    }

    return m_PrintLength;
}


BOOL
SDP_ADJUSTMENT::PrintElement(
    IN      DWORD       Index,
        OUT ostrstream  &OutputStream
    )
{
    ASSERT(IsValid());

    // this method must be called before PrintField is called
    m_AdjustmentTimes[Index]->GetCharacterStringSize();
    if ( !m_AdjustmentTimes[Index]->PrintField(OutputStream) )
    {
        return FALSE;
    }

    OutputStream << CHAR_BLANK;
    if ( OutputStream.fail() )
    {
        SetLastError(SDP_OUTPUT_ERROR);
        return FALSE;
    }

    // this method must be called before PrintField is called
    m_Offsets[Index]->GetCharacterStringSize();
    if ( !m_Offsets[Index]->PrintField(OutputStream) )
    {
        return FALSE;
    }

    return TRUE;
}


BOOL
SDP_ADJUSTMENT::PrintData(
        OUT     ostrstream  &OutputStream
    )
{
    ASSERT(m_AdjustmentTimes.GetSize() == m_Offsets.GetSize());

    // copy the prefix onto the output stream
    OutputStream << (CHAR *)m_TypePrefixString;
    if ( OutputStream.fail() )
    {
        SetLastError(SDP_OUTPUT_ERROR);
        return FALSE;
    }

    int    NumElements = (int)m_AdjustmentTimes.GetSize();

    // write into the buffer as AdjustmentValue blank OffsetValue (blank AdjustmentValue blank OffsetValue)*

    // write the first element
    if ( !PrintElement(0, OutputStream) )
    {
        return FALSE;
    }

    for ( int i=1; i < NumElements; i++ )
    {
        OutputStream << CHAR_BLANK;
        if ( OutputStream.fail() )
        {
            SetLastError(SDP_OUTPUT_ERROR);
            return FALSE;
        }

        if ( !PrintElement(i, OutputStream) )
        {
            return FALSE;
        }
    }

    // copy the newline character onto the stream to terminate the type value line
    OutputStream << CHAR_NEWLINE;
    if ( OutputStream.fail() )
    {
        SetLastError(SDP_OUTPUT_ERROR);
        return FALSE;
    }

    return TRUE;
}



BOOL
SDP_ADJUSTMENT::CopyValue(
        OUT         ostrstream  &OutputStream
    )
{
    ASSERT(IsValid());

    ASSERT(NULL != m_PrintBuffer);

    OutputStream << (CHAR *)m_PrintBuffer;
    if ( OutputStream.fail() )
    {
        SetLastError(SDP_OUTPUT_ERROR);
        return FALSE;
    }

    return TRUE;
}



BOOL
SDP_ADJUSTMENT::GetField(
        OUT SDP_FIELD   *&Field,
        OUT BOOL        &AddToArray
    )
{
    // NOT added in all cases by default
    AddToArray = FALSE;

    switch(m_LineState)
    {
    case ADJUSTMENT_TIME:
        {
            // check that the number of adjustment times are same as the offset times
            ASSERT(m_AdjustmentTimes.GetSize() == m_Offsets.GetSize());
            if ( m_AdjustmentTimes.GetSize() != m_Offsets.GetSize() )
            {
                SetLastError(SDP_INTERNAL_ERROR);
                return FALSE;
            }

            Field = &m_AdjustmentTimes;
        }

        break;

    case ADJUSTMENT_OFFSET:
    case ADJUSTMENT_OFFSET_END:
        {
            Field = &m_Offsets;
        }

        break;

    default:
        {
            SetLastError(m_ErrorCode);
            return FALSE;
        }

        break;
    };

    return TRUE;
}




SDP_TIME::SDP_TIME(
    )
    : SDP_VALUE(SDP_INVALID_TIME_FIELD, TIME_STRING, &g_TimeTransition)
{}


void
SDP_TIME::InternalReset(
    )
{
    m_StartTime.Reset();
    m_StopTime.Reset();
    m_RepeatList.Reset();
}


BOOL
SDP_TIME::CalcIsModified(
    ) const
{
    ASSERT(IsValid());

    return
        SDP_VALUE::CalcIsModified()     ||
        m_RepeatList.IsModified();
}


DWORD
SDP_TIME::CalcCharacterStringSize(
    )
{
    ASSERT(IsValid());

    return
        SDP_VALUE::CalcCharacterStringSize()        +
        m_RepeatList.GetCharacterStringSize();
}


BOOL
SDP_TIME::CopyValue(
        OUT         ostrstream  &OutputStream
    )
{
    ASSERT(IsValid());

    return
        SDP_VALUE::CopyValue(OutputStream)          &&
        m_RepeatList.PrintValue(OutputStream);
}



BOOL
SDP_TIME::GetField(
        OUT SDP_FIELD   *&Field,
        OUT BOOL        &AddToArray
    )
{
    // add in all cases by default
    AddToArray = TRUE;

    switch(m_LineState)
    {
    case TIME_START_TIME:
        {
            Field = &m_StartTime;
        }

        break;

    case TIME_STOP_TIME:
        {
            Field = &m_StopTime;
        }

        break;

    default:
        {
            SetLastError(m_ErrorCode);
            return FALSE;
        }

        break;
    };

    return TRUE;
}




BOOL
SDP_TIME_LIST::IsModified(
    ) const
{
    return
        m_Adjustment.IsModified() ||
        SDP_VALUE_LIST::IsModified();
}


DWORD
SDP_TIME_LIST::GetCharacterStringSize(
    )
{
    return
        m_Adjustment.GetCharacterStringSize() +
        SDP_VALUE_LIST::GetCharacterStringSize();
}



BOOL
SDP_TIME_LIST::PrintValue(
        OUT         ostrstream  &OutputStream
    )
{
    // the time list must be printed before the adjustment value line
    return
        SDP_VALUE_LIST::PrintValue(OutputStream) &&
        m_Adjustment.PrintValue(OutputStream);
}


void
SDP_TIME_LIST::Reset(
    )
{
    m_Adjustment.Reset();
    SDP_VALUE_LIST::Reset();
}



SDP_VALUE    *
SDP_TIME_LIST::CreateElement(
    )
{
    SDP_TIME *SdpTime;

    try 
    {
        SdpTime = new SDP_TIME();
    }
    catch(...)
    {
        SdpTime = NULL;
    }

    return SdpTime;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpval.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#include "sdppch.h"

#include <strstrea.h>

#include "sdpgen.h"
#include "sdpfld.h"
#include "sdpval.h"
#include "sdpltran.h"



// check if each of the fields in the field array is valid
BOOL
SDP_VALUE::IsValid(
    ) const
{
    // if there are no members in the field array, then the instance is invalid
    int    NumFields = (int)m_FieldArray.GetSize();
    if ( 0 >= NumFields )
    {
        return FALSE;
    }

    // check each of the members in the list for validity
    for (int i = 0; i < NumFields; i++)
    {
        SDP_FIELD *Field = m_FieldArray[i];

        // only the last field can be null
        ASSERT((i >= (NumFields-1)) || (NULL != Field));

        if ( NULL != Field )
        {
            // if even one member is invalid, return FALSE
            if ( !Field->IsValid() )
            {
                return FALSE;
            }
        }
    }

    // all members are valid
    return TRUE;
}



BOOL
SDP_VALUE::CalcIsModified(
    ) const
{
    ASSERT(IsValid());

    int    NumFields = (int)m_FieldArray.GetSize();
    for (int i = 0; i < NumFields; i++)
    {
        SDP_FIELD *Field = m_FieldArray[i];

        // only the last field can be null
        ASSERT((i >= (NumFields-1)) || (NULL != Field));

        if ( (NULL != Field) && Field->IsModified() )
        {
            return TRUE;
        }
    }

    return FALSE;
}


DWORD
SDP_VALUE::CalcCharacterStringSize(
    )
{
    ASSERT(IsValid());

    // since the cost of checking if any of the constituent fields have
    // changed since last time is almost as much as actually computing the size,
    // the size is computed afresh each time this method is called
    DWORD   m_CharacterStringSize = 0;

    int    NumFields = (int)m_FieldArray.GetSize();
    for (int i = 0; i < NumFields; i++)
    {
        SDP_FIELD *Field = m_FieldArray[i];

        // only the last field can be null
        ASSERT((i >= (NumFields-1)) || (NULL != Field));

        if ( NULL != Field )
        {
            // add field string length
            m_CharacterStringSize += Field->GetCharacterStringSize();
        }

        // add separator character length
        m_CharacterStringSize++;
    }

    // if there is a line, add the prefix string length
    if ( 0 < NumFields )
    {
        m_CharacterStringSize += strlen( m_TypePrefixString );
    }

    return m_CharacterStringSize;
}


// this method should only be called after having called GetCharacterStringSize()
// should only be called if valid
BOOL
SDP_VALUE::CopyValue(
        OUT         ostrstream  &OutputStream
    )
{
    // should be valid
    ASSERT(IsValid());

    // copy the prefix onto the buffer ptr
    OutputStream << (CHAR *)m_TypePrefixString;
    if ( OutputStream.fail() )
    {
        SetLastError(SDP_OUTPUT_ERROR);
        return FALSE;
    }

    int   NumFields = (int)m_FieldArray.GetSize();

    // the assumption here is that atleast one field must have been parsed in
    // if the value is valid
    ASSERT(0 != NumFields);

    for (int i = 0; i < NumFields; i++)
    {
        SDP_FIELD *Field = m_FieldArray[i];

        // only the last field can be null
        ASSERT((i >= (NumFields-1)) || (NULL != Field));

        if ( NULL != Field )
        {
            if ( !Field->PrintField(OutputStream) )
            {
                return FALSE;
            }
        }

        OutputStream << m_SeparatorCharArray[i];
    }

    // newline is presumably the last character parsed and entered into the array
    ASSERT(CHAR_NEWLINE == m_SeparatorCharArray[i-1]);
    return TRUE;
}



BOOL
SDP_VALUE::InternalParseLine(
    IN  OUT CHAR    *&Line
    )
{
    ASSERT(NULL != m_SdpLineTransition);

    BOOL Finished;

    // parse fields until there are no more fields to parse or an error occurs
    do
    {
        // check if the line state value is consistent with the corresponding entry
        const LINE_TRANSITION_INFO * const LineTransitionInfo =
            m_SdpLineTransition->GetAt(m_LineState);

        if ( NULL == LineTransitionInfo )
        {
            return FALSE;
        }

        CHAR        SeparatorChar = '\0';
        SDP_FIELD   *Field;
        CHAR        *SeparatorString;

        // identify the token. if one of the the separator characters is found, replace
        // it by EOS and return the separator char. if none of the separator characters are
        // found, return NULL (ex. if EOS found first, return NULL)
        CHAR *Token = GetToken(
                        Line,
                        LineTransitionInfo->m_NumTransitions,
                        LineTransitionInfo->m_SeparatorChars,
                        SeparatorChar
                        );

        //
        // Eliminate also the '\r' 
        // from the token
        //
        if( Token )
        {
            int nStrLen = strlen( Token );
            for( int c = 0; c < nStrLen; c++)
            {
                CHAR& chElement = Token[c];
                if( chElement == '\r' )
                {
                    chElement = '\0';
                }
            }
        }

        // when the block goes out of scope,
        // set the EOS character to the token separator character
        LINE_TERMINATOR LineTerminator(Token, SeparatorChar);

        // if there is no such token
        if ( !LineTerminator.IsLegal() )
        {
            SetLastError(m_ErrorCode);
            return FALSE;
        }

        // advance the line to the start of the next token
        Line += (LineTerminator.GetLength() + 1);

        BOOL        AddToArray;

        // check if there was such a state transition
        // it returns a field if it needs to be parsed and a separate
        // finished flag to indicate end of line parsing
        if ( !GetFieldToParse(SeparatorChar, LineTransitionInfo, Field, Finished, AddToArray) )
        {
            return FALSE;
        }

        // add the separator character and the field to the array
        if ( AddToArray )
        {
            ASSERT(m_FieldArray.GetSize() == m_SeparatorCharArray.GetSize());

            INT_PTR Index;

            try
            {
                Index = m_SeparatorCharArray.Add(SeparatorChar);
            }
            catch(...)
            {
                SetLastError(ERROR_OUTOFMEMORY);
                return FALSE;
            }

            try
            {
                m_FieldArray.Add(Field);
            }
            catch(...)
            {
                m_SeparatorCharArray.RemoveAt(Index);

                SetLastError(ERROR_OUTOFMEMORY);
                return FALSE;
            }
        }

        // check if any more fields need to be parsed
        if ( NULL == Field )
        {
            ASSERT(TRUE == Finished);
            break;
        }

        // parse the field
        if ( !Field->ParseToken(Token) )
        {
            return FALSE;
        }
    }
    while (!Finished);

    return TRUE;
}



BOOL
SDP_VALUE::GetFieldToParse(
    IN      const   CHAR                    SeparatorChar,
    IN      const   LINE_TRANSITION_INFO    *LineTransitionInfo,
        OUT         SDP_FIELD               *&Field,
        OUT         BOOL                    &Finished,
        OUT         BOOL                    &AddToArray
    )
{
    // no need for an if ( NULL != ...) because the caller ParseLine method must have verified
    // this before calling this method
    ASSERT(NULL != LineTransitionInfo);

    const LINE_TRANSITION * const LineTransitions = LineTransitionInfo->m_Transitions;

    if ( NULL == LineTransitions )
    {
        SetLastError(SDP_INTERNAL_ERROR);
        return FALSE;
    }

    // check if there is such a triggering separator
    for( UINT i=0; i < LineTransitionInfo->m_NumTransitions; i++ )
    {
        // check the separator for the transition
        if ( SeparatorChar == LineTransitions[i].m_SeparatorChar )
        {
            // perform the state transition - this is needed to determine the field to
            // parse. ideally the transition should occur after the action (ParseField),
            // but it doesn't matter here
            m_LineState = LineTransitions[i].m_NewLineState;

            // check if this transition was only meant to consume the separator character
            // and no fields need to be parsed
            if ( LINE_END == m_LineState )
            {
                // currently only a newline brings the state to LINE_END
                ASSERT(CHAR_NEWLINE == SeparatorChar);

                Field       = NULL;
                Finished    = TRUE;
                return TRUE;
            }

            // get the field to parse for the current state
            if ( !GetField(Field, AddToArray) )
            {
                ASSERT(FALSE);
                return FALSE;
            }

            // if the separator character was a newline, we are finished
            Finished = (CHAR_NEWLINE == SeparatorChar)? TRUE: FALSE;

            // success
            return TRUE;
        }
    }

    // no valid transition for the separator
    SetLastError(m_ErrorCode);
    return FALSE;
}




BOOL
SDP_VALUE_LIST::IsModified(
    ) const
{
    int NumElements = (int)GetSize();

    for ( int i = 0; i < NumElements; i++ )
    {
        if ( GetAt(i)->IsModified() )
        {
            return TRUE;
        }
    }

    return FALSE;
}


DWORD
SDP_VALUE_LIST::GetCharacterStringSize(
    )
{
    DWORD   ReturnValue = 0;
    int NumElements = (int)GetSize();

    for ( int i = 0; i < NumElements; i++ )
    {
        ReturnValue += GetAt(i)->GetCharacterStringSize();
    }

    return ReturnValue;
}



BOOL
SDP_VALUE_LIST::PrintValue(
        OUT         ostrstream  &OutputStream
    )
{
    // should not be modified
    ASSERT(!IsModified());

    int NumElements = (int)GetSize();

    for ( int i = 0; i < NumElements; i++ )
    {
        if ( !GetAt(i)->PrintValue(OutputStream) )
        {
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\dlldatax.h ===
/*

    Copyright (c) 1997-1999  Microsoft Corporation

*/

#if !defined(AFX_DLLDATAX_H__15705AA0_5090_11D1_8F40_00C04FB6809F__INCLUDED_)
#define AFX_DLLDATAX_H__15705AA0_5090_11D1_8F40_00C04FB6809F__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__15705AA0_5090_11D1_8F40_00C04FB6809F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\dlldatax.c ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    dlldatax.c

Abstract:

    wrapper for dlldata.c

Author:

*/



#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

//#define _WIN32_WINNT 0x0500	//for WinNT 5.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "rend_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\parser\sdpver.cpp ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

*/

#include "sdppch.h"

#include "sdpgen.h"
#include "sdpver.h"


// maximum value in a ushort variable
const   USHORT  USHORT_MAX = -1;


// no transition table for the base class
// no need to set the start state as the parse engine is not used
SDP_VERSION::SDP_VERSION(
    )
    : SDP_VALUE(SDP_INVALID_VERSION_FIELD, VERSION_STRING)
{

}


void
SDP_VERSION::InternalReset(
    )
{
    m_Version.Reset();
}


BOOL
SDP_VERSION::InternalParseLine(
    IN  OUT CHAR    *&Line
    )
{
    CHAR    SeparatorChar = '\0';

    // identify the token. if one of the the separator characters is found, replace
    // it by EOS and return the separator char. if none of the separator characters are
    // found, return NULL (ex. if EOS found first, return NULL)
    CHAR *Token = GetToken(Line, 1, NEWLINE_STRING, SeparatorChar);

    // when the block goes out of scope, 
    // set the EOS character to the token separator character
    LINE_TERMINATOR LineTerminator(Token, SeparatorChar);

    // if there is no such token
    if ( !LineTerminator.IsLegal() )
    {
        SetLastError(m_ErrorCode);
        return FALSE;
    }

    // advance the line to the start of the next token
    Line += (LineTerminator.GetLength() + 1);

    // get the session id decimal value
    if ( !m_Version.ParseToken(Token) )
    {
        SetLastError(SDP_INVALID_VERSION_FIELD);
        return FALSE;
    }

    // check if the value is legal 
    if ( (USHORT_MAX            ==  m_Version.GetValue())  ||
         (CURRENT_SDP_VERSION   <   m_Version.GetValue())   )
    {
        SetLastError(SDP_INVALID_VERSION_FIELD);
        return FALSE;
    }

    INT_PTR Index;

    // fill in the field and separator char arrays
    try
    {   
        Index = m_SeparatorCharArray.Add(CHAR_NEWLINE);
    }
    catch(...)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    try
    {
        m_FieldArray.Add(&m_Version);
    }
    catch(...)
    {
        m_SeparatorCharArray.RemoveAt(Index);

        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\resource.h ===
/*

    Copyright (c) 1997-1999  Microsoft Corporation

    Module Name:
        resource.h

*/

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rend.rc
//
#define IDS_PROJNAME                    100
#define IDS_RENDEZVOUS_DESC             102
#define IDR_Rendezvous                  103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndcnf.cpp ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    rndcnf.cpp

Abstract:

    This module contains implementation of CConference object.

--*/

#include "stdafx.h"
#include <winsock2.h>

#include "rndcnf.h"

// These are the attribute names according to the schema in NTDS.
const WCHAR *const MeetingAttributeNames[] = 
{
    L"meetingAdvertisingScope",
    L"meetingBlob",
    L"meetingDescription",
    L"meetingIsEncrypted",
    L"meetingName",
    L"meetingOriginator",
    L"meetingProtocol",
    L"meetingStartTime",
    L"meetingStopTime",
    L"meetingType",
    L"meetingURL"
};

#define INC_ACCESS_ACL_SIZE(_SIZE_, _SID_)	\
		_SIZE_ += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid(_SID_));

#define BAIL_ON_BOOLFAIL(_FN_) \
		if ( !_FN_ )									\
		{												\
			hr = HRESULT_FROM_WIN32(GetLastError());	\
			goto failed;								\
		}

#define ACCESS_READ		0x10
#define ACCESS_WRITE	0x20
#define ACCESS_MODIFY   (ACCESS_WRITE | WRITE_DAC)
#define ACCESS_DELETE   DELETE

#define ACCESS_ALL		(ACCESS_READ | ACCESS_MODIFY | ACCESS_DELETE)



HRESULT
ConvertStringToSid(
    IN  PWSTR       string,
    OUT PSID       *sid,
    OUT PDWORD     pdwSidSize,
    OUT PWSTR      *end
    );

HRESULT
ConvertACLToVariant(
    PACL pACL,
    LPVARIANT pvarACL
    );


/////////////////////////////////////////////////////////////////////////////
// non-interface class methods
/////////////////////////////////////////////////////////////////////////////


HRESULT 
CConference::FinalConstruct()
/*++

Routine Description:

    Create the SDPBlob object that is aggregated with the conference object.
    Also query my own Notification interface which will be given to the 
    SDPBlob object. To avoid circlar ref count, this interface is realeased
    as soon as it is queried.

Arguments:

Return Value:

    HRESULT.

--*/
{
    // Create the conference Blob
    CComPtr <IUnknown> pIUnkConfBlob;

    HRESULT hr = CoCreateInstance(
        CLSID_SdpConferenceBlob,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IUnknown,
        (void **)&pIUnkConfBlob
        );
    BAIL_IF_FAIL(hr, "Create SdpConferenceBlob");


    // Get the ITConfBlobPrivate interface from the Blob object.
    CComPtr <ITConfBlobPrivate> pITConfBlobPrivate;

    hr = pIUnkConfBlob->QueryInterface(
        IID_ITConfBlobPrivate, 
        (void **)&pITConfBlobPrivate
        );

    BAIL_IF_FAIL(hr, "Query ITConfBlobPrivate interface");


    // query the conf blob instance for the conf blob i/f
    CComPtr <ITConferenceBlob> pITConfBlob;

    hr = pIUnkConfBlob->QueryInterface(
        IID_ITConferenceBlob, 
        (void **)&pITConfBlob
        );

    BAIL_IF_FAIL(hr, "Query ITConferenceBlob");
    
    // keep the interface pointers.
    m_pIUnkConfBlob = pIUnkConfBlob;
    m_pIUnkConfBlob->AddRef();

    m_pITConfBlob = pITConfBlob;
    m_pITConfBlob->AddRef();

    m_pITConfBlobPrivate = pITConfBlobPrivate;
    m_pITConfBlobPrivate->AddRef();

    return S_OK;

}


HRESULT CConference::Init(BSTR bName)
/*++

Routine Description:

    Init this conference with only a name. This is called when an empty
    conference is created. A default SDP blob will be created. The format
    is in the registry. See sdpblb code.

Arguments:

    bName   - The name of the conference.

Return Value:

    HRESULT.

--*/
{
    HRESULT hr;

    hr = SetDefaultValue(
        g_ConfInstInfoArray,
        g_ContInstInfoArraySize
        );
	BAIL_IF_FAIL(hr, "set default attribute value");

    hr = SetSingleValue(MA_MEETINGNAME, bName);
    BAIL_IF_FAIL(hr, "can't set meeting name");

    hr = m_pITConfBlob->Init(bName, BCS_UTF8, NULL);
    BAIL_IF_FAIL(hr, "Init the conference Blob");

    hr = SetDefaultSD();
    BAIL_IF_FAIL(hr, "Init the security descriptor");

    return hr;
}


HRESULT CConference::Init(BSTR bName, BSTR bProtocol, BSTR bBlob)
/*++

Routine Description:

    Init this conference with only the conference name and also a conference
    blob whose protocol should be IP conference. The blob is parsed by the
    SDP Blob object and the information in the blob will be notified back
    to this conference object through the notification interface.

Arguments:

    bName       - The name of the conference.

    bProtocol   - The protocol used by the blob. should be SDP now.

    bBlob       - The opaque data blob that describes this conference.

Return Value:

    HRESULT.

--*/
{
    HRESULT hr;

    hr = SetSingleValue(MA_MEETINGNAME, bName);
    BAIL_IF_FAIL(hr, "can't set meeting name");

    // Check to make sure protocol is IP Conference
    if ( wcscmp(bProtocol, L"IP Conference" ))
    {
        LOG((MSP_ERROR, "Protocol must be IP Conference"));
        return E_INVALIDARG;
    }

    hr = SetSingleValue(MA_PROTOCOL, bProtocol);
    BAIL_IF_FAIL(hr, "can't set meeting protocol");

    hr = SetSingleValue(MA_CONFERENCE_BLOB, bBlob);
    BAIL_IF_FAIL(hr, "can't set meeting blob");

    hr = m_pITConfBlob->Init(NULL, BCS_UTF8, bBlob);
    BAIL_IF_FAIL(hr, "Init the conference Blob object");

    return hr;
}


void 
CConference::FinalRelease()
/*++

Routine Description:

    Clean up the SDP blob contained in this object.
    clean up the security object for this object.
    clean up all the attributes.

Arguments:

Return Value:


--*/
{
    CLock Lock(m_lock);

    // do base class first
    CDirectoryObject::FinalRelease();

    if ( NULL != m_pIUnkConfBlob )
    {
        m_pIUnkConfBlob->Release();
        m_pIUnkConfBlob = NULL;
    }

    if ( NULL != m_pITConfBlobPrivate )
    {
        m_pITConfBlobPrivate->Release();
        m_pITConfBlobPrivate = NULL;
    }

    if ( NULL != m_pITConfBlob )
    {
        m_pITConfBlob->Release();
        m_pITConfBlob = NULL;
    }

    // MuHan + ZoltanS fix 3-19-98 -- these are member smart pointers,
    // should not be deleted!!!
    // for (DWORD i = 0; i < NUM_MEETING_ATTRIBUTES; i ++)
    // {
    //     delete m_Attributes[i];
    // }

    // the interface pointer to this instance's ITNotification i/f is NOT 
    // released because it was already released in FinalConstruct but the 
    // pointer was held to be passed onto the aggregated conf blob instance
}


HRESULT
CConference::UpdateConferenceBlob(
    IN  IUnknown    *pIUnkConfBlob                         
    )
/*++

Routine Description:
    
    update the blob attribute if the blob object has been changed.
    
Arguments:

    pIUnkConfBlob   - pointer to the SDPBlob object.

Return Value:

    HRESULT.

--*/
{
    // check if the sdp blob has been modified since the component was created
    VARIANT_BOOL    BlobIsModified;
    BAIL_IF_FAIL(m_pITConfBlobPrivate->get_IsModified(&BlobIsModified),
        "UpdateConferenceBlob.get_IsModified");
    
    // if not, return
    if ( BlobIsModified == VARIANT_FALSE )
    {
        return S_OK;
    }

    // get the blob and 
    CBstr SdpBlobBstr;
    BAIL_IF_FAIL(m_pITConfBlob->get_ConferenceBlob(&SdpBlobBstr),
        "UpdateConferenceBlob.get_ConfrenceBlob");

    // set the conference blob attribute for the conference
    BAIL_IF_FAIL(SetSingleValue(MA_CONFERENCE_BLOB, SdpBlobBstr), 
        "UpdateConferenceBlob.Setblob");

    return S_OK;
}
    

HRESULT	
CConference::SetDefaultValue(
	IN  REG_INFO    RegInfo[],
    IN  DWORD       dwItems
	)
/*++

Routine Description:
    
    Set attributes to the default value got from the registry.
    
Arguments:

	RegInfo - {attribute, value} array.

    dwItems - The number of items in the array.

Return Value:

    HRESULT.

--*/
{
	for (DWORD i=0; i < dwItems ; i++)
	{
        HRESULT hr;
        hr = SetSingleValue(RegInfo[i].Attribute, RegInfo[i].wstrValue);
        BAIL_IF_FAIL(hr, "set value");
	}
	return S_OK;
}

/*++

Routine Description:
    
    Set the right security descriptor for the conference.
    
Arguments:

Return Value:

    HRESULT.

--*/
HRESULT 
CConference::SetDefaultSD()
{
    LOG((MSP_INFO, "CConference::SetDefaultSD - entered"));

    //
    // The security descriptor
    //

  	IADsSecurityDescriptor* pSecDesc = NULL;

   	HRESULT hr = S_OK;
	bool bOwner = false, bWorld = false;
	PACL pACL = NULL;
	PSID pSidWorld = NULL;
	DWORD dwAclSize = sizeof(ACL), dwTemp;
	BSTR bstrTemp = NULL;
	LPWSTR pszTemp = NULL;

    HANDLE hToken;
    UCHAR *pInfoBuffer = NULL;
    DWORD cbInfoBuffer = 512;

    //
    // Try to get the thread or process token
    //

	if( !OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken) )
	{
        //
        // If there was a sever error we exit
        //

    	if( GetLastError() != ERROR_NO_TOKEN )
		{
            LOG((MSP_ERROR, "CConference::SetDefaultSD - exit E_FAIL "
                "OpenThreadToken failed!"));
            return E_FAIL;
        }

        //
		// Attempt to open the process token, since no thread token exists
        //

		if( !OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken) )
        {
            LOG((MSP_ERROR, "CConference::SetDefaultSD - exit E_FAIL "
                "OpenProcessToken failed"));
			return E_FAIL;
        }
	}

    //
	// Loop until we have a large enough structure
    //

	while ( (pInfoBuffer = new UCHAR[cbInfoBuffer]) != NULL )
	{
		if ( !GetTokenInformation(hToken, TokenUser, pInfoBuffer, cbInfoBuffer, &cbInfoBuffer) )
		{
			delete pInfoBuffer;
			pInfoBuffer = NULL;

			if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
				return E_FAIL;
		}
		else
		{
			break;
		}
	}

	CloseHandle(hToken);

    //
	// Did we get the owner ACL?
    //

	if ( pInfoBuffer )
	{
		INC_ACCESS_ACL_SIZE( dwAclSize, ((PTOKEN_USER) pInfoBuffer)->User.Sid );
		bOwner = true;
	}

    //
	// Make SID for "Everyone"
    //

	SysReAllocString( &bstrTemp, L"S-1-1-0" );
	hr = ConvertStringToSid( bstrTemp, &pSidWorld, &dwTemp, &pszTemp );
	if ( SUCCEEDED(hr) )
	{
		INC_ACCESS_ACL_SIZE( dwAclSize, pSidWorld );
		bWorld = true;
	}

    //
    // Create a security descriptor
    //

    hr = CoCreateInstance(
                CLSID_SecurityDescriptor,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsSecurityDescriptor,
                (void **)&pSecDesc
                );
    if( FAILED(hr) )
    {

        LOG((MSP_ERROR, "CConference::SetDefaultSD - exit 0x%08x "
            "Create security descriptor failed!", hr));

        goto failed;

    }


	//
	// Create the ACL containing the Owner and World ACEs
    //

	pACL = (PACL) new BYTE[dwAclSize];
	if ( pACL )
	{
		BAIL_ON_BOOLFAIL( InitializeAcl(pACL, dwAclSize, ACL_REVISION) );

		// Add World Rights
		if ( bWorld )
		{
			if ( bOwner )
			{
				BAIL_ON_BOOLFAIL( AddAccessAllowedAce(pACL, ACL_REVISION, ACCESS_READ, pSidWorld) );
			}
			else
			{
				BAIL_ON_BOOLFAIL( AddAccessAllowedAce(pACL, ACL_REVISION, ACCESS_ALL , pSidWorld) );
			}
		}

		// Add Creator rights
		if ( bOwner )
			BAIL_ON_BOOLFAIL( AddAccessAllowedAce(pACL, ACL_REVISION, ACCESS_ALL, ((PTOKEN_USER) pInfoBuffer)->User.Sid) );


		// Set the DACL onto our security descriptor
		VARIANT varDACL;
		VariantInit( &varDACL );
		if ( SUCCEEDED(hr = ConvertACLToVariant((PACL) pACL, &varDACL)) )
		{
			if ( SUCCEEDED(hr = pSecDesc->put_DaclDefaulted(FALSE)) )
            {
				hr = pSecDesc->put_DiscretionaryAcl( V_DISPATCH(&varDACL) );
                if( SUCCEEDED(hr) )
                {
                    hr = put_SecurityDescriptor((IDispatch*)pSecDesc);
                    if( SUCCEEDED(hr) )
                    {
                        hr = this->put_SecurityDescriptorIsModified(TRUE);
                    }
                }

            }
		}
		VariantClear( &varDACL );
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

// Clean up
failed:
	SysFreeString( bstrTemp );
	if ( pACL ) delete pACL;
	if ( pSidWorld ) delete pSidWorld;
	if ( pInfoBuffer ) delete pInfoBuffer;
    if( pSecDesc ) pSecDesc->Release();

    LOG((MSP_INFO, "CConference::SetDefaultSD - exit 0x%08x", hr));
	return hr;
}


HRESULT    
CConference::GetSingleValueBstr(
    IN  OBJECT_ATTRIBUTE    Attribute,
    OUT BSTR    *           AttributeValue
    )
/*++

Routine Description:
    
    Get the value of an attribute and create a BSTR to return.
    
Arguments:

    Attribute       - the attribute id as defined in rend.idl

    AttributeValue  - a pointer to a BSTR that points to the returned value.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_INFO, "CConference::GetSingleValueBstr - entered"));

    BAIL_IF_BAD_WRITE_PTR(AttributeValue, E_POINTER);

    // Check to see if the attribute is valid.
    if (!ValidMeetingAttribute(Attribute))
    {
        LOG((MSP_ERROR, "Invalid Attribute, %d", Attribute));
        return E_FAIL;
    }

    CLock Lock(m_lock);

    // check to see if I have this attribute.
    if(!m_Attributes[MeetingAttrIndex(Attribute)])
    {
        LOG((MSP_ERROR, "Attribute %S is not found", 
            MeetingAttributeName(Attribute)));
        return E_FAIL;
    }

    // allocate a BSTR to return.
    *AttributeValue = 
        SysAllocString(m_Attributes[MeetingAttrIndex(Attribute)]);
    if (*AttributeValue == NULL)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}


HRESULT    
CConference::GetSingleValueWstr(
    IN  OBJECT_ATTRIBUTE    Attribute,
    IN  DWORD               dwSize,
    OUT WCHAR    *          AttributeValue
    )
/*++

Routine Description:
    
    Get the value of an attribute. copy the value to the buffer provided.
    
Arguments:

    Attribute       - the attribute id as defined in rend.idl

    AttributeValue  - a pointer to a buffer where the value will be copied to.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_INFO, "CConference::GetSingleValueWstr - entered"));
    
    _ASSERTE(NULL != AttributeValue);
    _ASSERTE(ValidMeetingAttribute(Attribute));

    CLock Lock(m_lock);
    if(!m_Attributes[MeetingAttrIndex(Attribute)])
    {
        LOG((MSP_ERROR, "Attribute %S is not found", 
            MeetingAttributeName(Attribute)));
        return E_FAIL;
    }

    // copy the attribute value
    lstrcpynW(
        AttributeValue, 
        m_Attributes[MeetingAttrIndex(Attribute)], 
        dwSize
        );

    return S_OK;
}


HRESULT    
CConference::SetSingleValue(
    IN  OBJECT_ATTRIBUTE    Attribute,
    IN  WCHAR *             AttributeValue
    )
/*++

Routine Description:
    
    Set the attribute value to a new string.

Arguments:

    Attribute       - the attribute id as defined in rend.idl

    AttributeValue  - the new value. If it is null, the value is deleted.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_INFO, "CConference::SetSingleValue - entered"));

    if (!ValidMeetingAttribute(Attribute))
    {
        LOG((MSP_ERROR, "Invalid Attribute, %d", Attribute));
        return E_FAIL;
    }

    if (AttributeValue != NULL) 
    {
        BAIL_IF_BAD_READ_PTR(AttributeValue, E_POINTER);
    }

    CLock Lock(m_lock);
    // if AttributeValue is NULL, the attribute is deleted.
    if (!m_Attributes[MeetingAttrIndex(Attribute)].set(AttributeValue))
    {
        LOG((MSP_ERROR, "Can not add attribute %S",
            MeetingAttributeName(Attribute)));
        return E_OUTOFMEMORY;
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// ITConference interface
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CConference::get_Name(BSTR * ppVal)
{
    return m_pITConfBlobPrivate->GetName(ppVal);
}

STDMETHODIMP CConference::put_Name(BSTR pVal)
{
    return m_pITConfBlobPrivate->SetName(pVal);
}

STDMETHODIMP CConference::get_Protocol(BSTR * ppVal)
{
    return GetSingleValueBstr(MA_PROTOCOL, ppVal);
}

/*

  *
  * I've removed the following method from the interface because I don't plan
  * to ever implement it.
  *

STDMETHODIMP CConference::put_Protocol(BSTR newVal)
{
    // currently not allowed to change this
    // only IP Conference is supported
    return E_NOTIMPL;
}

  *
  * The following are implemented but don't work. Again these are useless
  * methods! Removed from the interface.
  *

STDMETHODIMP CConference::get_ConferenceType(BSTR * ppVal)
{
    return GetSingleValueBstr(MA_TYPE, ppVal);
}

STDMETHODIMP CConference::put_ConferenceType(BSTR newVal)
{
    return SetSingleValue(MA_TYPE, newVal);
}

*/

STDMETHODIMP CConference::get_Originator(BSTR * ppVal)
{
    return m_pITConfBlobPrivate->GetOriginator(ppVal);
}

STDMETHODIMP CConference::put_Originator(BSTR newVal)
{
    return m_pITConfBlobPrivate->SetOriginator(newVal);
}

STDMETHODIMP CConference::get_AdvertisingScope(
    RND_ADVERTISING_SCOPE *pAdvertisingScope
    )
{
    return m_pITConfBlobPrivate->GetAdvertisingScope(pAdvertisingScope);
}

STDMETHODIMP CConference::put_AdvertisingScope(
    RND_ADVERTISING_SCOPE AdvertisingScope
    )
{
    return m_pITConfBlobPrivate->SetAdvertisingScope(AdvertisingScope);
}

STDMETHODIMP CConference::get_Url(BSTR * ppVal)
{
    return m_pITConfBlobPrivate->GetUrl(ppVal);
}

STDMETHODIMP CConference::put_Url(BSTR newVal)
{
    return m_pITConfBlobPrivate->SetUrl(newVal);
}

STDMETHODIMP CConference::get_Description(BSTR * ppVal)
{
    return m_pITConfBlobPrivate->GetDescription(ppVal);
}

STDMETHODIMP CConference::put_Description(BSTR newVal)
{
    return m_pITConfBlobPrivate->SetDescription(newVal);
}

STDMETHODIMP CConference::get_IsEncrypted(VARIANT_BOOL *pfEncrypted)
{
    if ( IsBadWritePtr(pfEncrypted, sizeof(VARIANT_BOOL)) )
    {
        LOG((MSP_ERROR, "CConference::get_IsEncrypted : bad pointer passed in"));
        return E_POINTER;
    }

    // We don't support encrypted streaming at all.

    *pfEncrypted = VARIANT_FALSE;

    return S_OK;

// ILS server (NT 5 beta 1) has IsEncrypted as a dword, this will be modified
// to a string afterwards at that time the code below should replace 
// the current implementation
//    return GetSingleValueBstr(MA_IS_ENCRYPTED, pVal);
}

STDMETHODIMP CConference::put_IsEncrypted(VARIANT_BOOL fEncrypted)
{
    // We don't allow changes to this. See get_IsEncrypted.

    return E_NOTIMPL;

// ILS server (NT 5 beta 1) has IsEncrypted as a dword, this will be modified
// to a string afterwards at that time the code below should replace the 
// current implementation no need to notify the conference blob of the change
//    return SetSingleValue(MA_IS_ENCRYPTED, newVal);
}


inline 
DWORD_PTR TimetToNtpTime(IN  time_t  TimetVal)
{
    return TimetVal + NTP_OFFSET;
}


inline 
time_t NtpTimeToTimet(IN  DWORD_PTR   NtpTime)
{
    return NtpTime - NTP_OFFSET;
}


inline HRESULT
SystemTimeToNtpTime(
    IN  SYSTEMTIME  &Time,
    OUT DWORD       &NtpDword
    )
{
    _ASSERTE(FIRST_POSSIBLE_YEAR <= Time.wYear);

    // fill in a tm struct with the values
    tm  NtpTmStruct;
    NtpTmStruct.tm_isdst    = -1;   // no info available about daylight savings time
    NtpTmStruct.tm_year     = (int)Time.wYear - 1900;
    NtpTmStruct.tm_mon      = (int)Time.wMonth - 1;    // months since january
    NtpTmStruct.tm_mday     = (int)Time.wDay;
    NtpTmStruct.tm_wday     = (int)Time.wDayOfWeek;
    NtpTmStruct.tm_hour     = (int)Time.wHour;
    NtpTmStruct.tm_min      = (int)Time.wMinute;
    NtpTmStruct.tm_sec      = (int)Time.wSecond;

    // try to convert into a time_t value
    time_t TimetVal = mktime(&NtpTmStruct);
    if ( -1 == TimetVal )
    {
        return HRESULT_FROM_ERROR_CODE(RND_INVALID_TIME);
    }

    // convert the time_t value into an NTP value
    NtpDword = (DWORD) TimetToNtpTime(TimetVal);
    return S_OK;
}


inline
HRESULT
NtpTimeToSystemTime(
    IN  DWORD       dwNtpTime,
    OUT SYSTEMTIME &Time
    )
{
    // if the gen time is WSTR_GEN_TIME_ZERO then, 
    // all the out parameters should be set to 0
    if (dwNtpTime == 0)
    {
        memset(&Time, 0, sizeof(SYSTEMTIME));
        return S_OK;
    }

    time_t  Timet = NtpTimeToTimet(dwNtpTime);

    // get the local tm struct for this time value
    tm* pTimet = localtime(&Timet);
    if( IsBadReadPtr(pTimet, sizeof(tm) ))
    {
        return E_FAIL;
    }

    tm LocalTm = *pTimet;

    //
    // win64: added casts below
    //

    // set the ref parameters to the tm struct values
    Time.wYear         = (WORD) ( LocalTm.tm_year + 1900 ); // years since 1900
    Time.wMonth        = (WORD) ( LocalTm.tm_mon + 1 );     // months SINCE january (0,11)
    Time.wDay          = (WORD)   LocalTm.tm_mday;
    Time.wDayOfWeek    = (WORD)   LocalTm.tm_wday;
    Time.wHour         = (WORD)   LocalTm.tm_hour;
    Time.wMinute       = (WORD)   LocalTm.tm_min;
    Time.wSecond       = (WORD)   LocalTm.tm_sec;
    Time.wMilliseconds = (WORD)   0;

    return S_OK;
}


STDMETHODIMP CConference::get_StartTime(DATE *pDate)
{
    LOG((MSP_INFO, "CConference::get_StartTime - enter"));

    BAIL_IF_BAD_WRITE_PTR(pDate, E_POINTER);

    DWORD dwStartTime;

    HRESULT hr = m_pITConfBlobPrivate->GetStartTime(&dwStartTime);

    BAIL_IF_FAIL(hr, "GetStartTime from blob");

    // special case for permanent / unbounded conferences
    // return the variant time zero. In the put_ methods this
    // is also considered a special value. We will never
    // actually use zero as a valid time because it is so
    // far in the past.

    if ( dwStartTime == 0 )
    {
        *pDate = 0; // special "unbounded" value
        
        LOG((MSP_INFO, "CConference::get_StartTime - unbounded/permanent "
            "- exit S_OK"));

        return S_OK;
    }

    // break the generalized time entry into the year, 
    // month, day, hour and minute (local values)
    SYSTEMTIME Time;
    hr = NtpTimeToSystemTime(dwStartTime, Time);
    if( FAILED(hr) )
    {
        return HRESULT_FROM_ERROR_CODE(RND_INVALID_TIME);
    }

    DOUBLE vtime;
    if (SystemTimeToVariantTime(&Time, &vtime) == FALSE)
    {
        return HRESULT_FROM_ERROR_CODE(RND_INVALID_TIME);
    }

    *pDate = vtime;

    LOG((MSP_INFO, "CConference::get_StartTime - exit S_OK"));
    
    return S_OK;
}


STDMETHODIMP CConference::put_StartTime(DATE Date)
{
    SYSTEMTIME Time;
    if (VariantTimeToSystemTime(Date, &Time) == FALSE)
    {
        return HRESULT_FROM_ERROR_CODE(RND_INVALID_TIME);
    }

    DWORD dwNtpStartTime;
    if (Date == 0)
    {
        // unbounded start time
        dwNtpStartTime = 0;
    }
    else if ( FIRST_POSSIBLE_YEAR > Time.wYear ) 
    {
        // cannot handle years less than FIRST_POSSIBLE_YEAR
        return HRESULT_FROM_ERROR_CODE(RND_INVALID_TIME);
    }
    else
    {
        BAIL_IF_FAIL(
            SystemTimeToNtpTime(Time, dwNtpStartTime),
            "getNtpDword"
            );
    }

    // notify the conference blob of the change
    HRESULT hr = m_pITConfBlobPrivate->SetStartTime(dwNtpStartTime);
    BAIL_IF_FAIL(hr, "SetStartTime from to blob");

    return S_OK;
}


STDMETHODIMP CConference::get_StopTime(DATE *pDate)
{
    LOG((MSP_INFO, "CConference::get_StopTime - enter"));

    BAIL_IF_BAD_WRITE_PTR(pDate, E_POINTER);

    DWORD dwStopTime;

    HRESULT hr = m_pITConfBlobPrivate->GetStopTime(&dwStopTime);

    BAIL_IF_FAIL(hr, "GetStopTime from blob");

    // special case for permanent / unbounded conferences
    // return the variant time zero. In the put_ methods this
    // is also considered a special value. We will never
    // actually use zero as a valid time because it is so
    // far in the past.

    if ( dwStopTime == 0 )
    {
        *pDate = 0; // special "unbounded" value
        
        LOG((MSP_INFO, "CConference::get_StopTime - unbounded/permanent "
            "- exit S_OK"));

        return S_OK;
    }
    
    // break the generalized time entry into the year, 
    // month, day, hour and minute (local values)
    SYSTEMTIME Time;
    hr =NtpTimeToSystemTime(dwStopTime, Time);
    if( FAILED(hr) )
    {
        return HRESULT_FROM_ERROR_CODE(RND_INVALID_TIME);
    }

    DOUBLE vtime;
    if (SystemTimeToVariantTime(&Time, &vtime) == FALSE)
    {
        return HRESULT_FROM_ERROR_CODE(RND_INVALID_TIME);
    }

    *pDate = vtime;

    LOG((MSP_INFO, "CConference::get_StopTime - exit S_OK"));

    return S_OK;
}


STDMETHODIMP CConference::put_StopTime(DATE Date)
{
    SYSTEMTIME Time;
    if (VariantTimeToSystemTime(Date, &Time) == FALSE)
    {
        return HRESULT_FROM_ERROR_CODE(RND_INVALID_TIME);
    }

    DWORD dwNtpStopTime;
    if (Date == 0)
    {
        // unbounded start time
        dwNtpStopTime = 0;
    }
    else if ( FIRST_POSSIBLE_YEAR > Time.wYear ) 
    {
        // cannot handle years less than FIRST_POSSIBLE_YEAR
        return HRESULT_FROM_ERROR_CODE(RND_INVALID_TIME);
    }
    else
    {
        BAIL_IF_FAIL(
            SystemTimeToNtpTime(Time, dwNtpStopTime),
            "getNtpDword"
            );

        // determine current time
        time_t CurrentTime = time(NULL);
        if (dwNtpStopTime <= TimetToNtpTime(CurrentTime))
        {
            return HRESULT_FROM_ERROR_CODE(RND_INVALID_TIME);
        }
    }

    // notify the conference blob of the change
    HRESULT hr = m_pITConfBlobPrivate->SetStopTime(dwNtpStopTime);
    BAIL_IF_FAIL(hr, "SetStopTime from to blob");

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// ITDirectoryObject
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CConference::get_DialableAddrs(
    IN  long        dwAddressTypes,   //defined in tapi.h
    OUT VARIANT *   pVariant
    )
{
    BAIL_IF_BAD_WRITE_PTR(pVariant, E_POINTER);

    BSTR *Addresses = new BSTR[1];    // only one for now.
    BAIL_IF_NULL(Addresses, E_OUTOFMEMORY);

    HRESULT hr;

    switch (dwAddressTypes) // ZoltanS fix
    {
    case LINEADDRESSTYPE_SDP:

        hr = UpdateConferenceBlob(m_pIUnkConfBlob);

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CConference::get_DialableAddrs - "
                "failed to update blob attribute from the blob object"));
        }
        else
        {
            hr = GetSingleValueBstr(MA_CONFERENCE_BLOB, &Addresses[0]);
        }
        break;

    default:
        hr = E_FAIL; // just return 0 addresses
        break;
    }

    DWORD dwCount = (FAILED(hr)) ? 0 : 1;
    
    hr = ::CreateBstrCollection(dwCount,                 // count
                                &Addresses[0],           // begin pointer
                                &Addresses[dwCount],     // end pointer
                                pVariant,                // return value
                                AtlFlagTakeOwnership);   // flags

    // the collection will destroy the Addresses array eventually.
    // no need to free anything here. Even if we tell it to hand
    // out zero objects, it will delete the array on construction.
    // (ZoltanS verified.)

    return hr;
}


STDMETHODIMP CConference::EnumerateDialableAddrs(
    IN  DWORD                   dwAddressTypes, //defined in tapi.h
    OUT IEnumDialableAddrs **   ppEnumDialableAddrs
    )
{
    BAIL_IF_BAD_WRITE_PTR(ppEnumDialableAddrs, E_POINTER);

    BSTR *Addresses = new BSTR[1];    // only one for now.
    BAIL_IF_NULL(Addresses, E_OUTOFMEMORY);

    HRESULT hr;

    switch (dwAddressTypes) // ZoltanS fix
    {
    case LINEADDRESSTYPE_SDP:

        hr = UpdateConferenceBlob(m_pIUnkConfBlob);

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CConference::EnumerateDialableAddrs - "
                "failed to update blob attribute from the blob object"));
        }
        else
        {
            hr = GetSingleValueBstr(MA_CONFERENCE_BLOB, &Addresses[0]);
        }
        break;

    default:
        hr = E_FAIL; // just return 0 addresses
        break;
    }
    
    DWORD dwCount = (FAILED(hr)) ? 0 : 1;
    
    hr = ::CreateDialableAddressEnumerator(
        &Addresses[0], 
        &Addresses[dwCount],
        ppEnumDialableAddrs
        );
    
    // the enumerator will destroy the Addresses array eventually,
    // so no need to free anything here. Even if we tell it to hand
    // out zero objects, it will delete the array on destruction.
    // (ZoltanS verified.)

    return hr;
}


STDMETHODIMP CConference::GetAttribute(
    IN  OBJECT_ATTRIBUTE    Attribute,
    OUT BSTR *              ppAttributeValue
    )
{
    if (Attribute == MA_CONFERENCE_BLOB)
    {
        BAIL_IF_FAIL(
            UpdateConferenceBlob(m_pIUnkConfBlob), 
            "update blob attribute from the blob object"
            );
    }
    return GetSingleValueBstr(Attribute, ppAttributeValue);
}

STDMETHODIMP CConference::SetAttribute(
    IN  OBJECT_ATTRIBUTE    Attribute,
    IN  BSTR                pAttributeValue
    )
{
    // this function is never called in the current implementation.
    // However, it might be useful in the future.
    return SetSingleValue(Attribute, pAttributeValue);
}

STDMETHODIMP CConference::GetTTL(
    OUT DWORD *    pdwTTL
    )
{
    LOG((MSP_INFO, "CConference::GetTTL - enter"));

    //
    // Check arguments.
    //

    BAIL_IF_BAD_WRITE_PTR(pdwTTL, E_POINTER);

    //
    // Get the stop time from the conference blob.
    //

    DWORD dwStopTime;
    HRESULT hr = m_pITConfBlobPrivate->GetStopTime(&dwStopTime);

    BAIL_IF_FAIL(hr, "GetStopTime from blob");

    //
    // If the blob has zero as the stop time, then this conference does not
    // have an explicit end time. The RFC calls this an "unbounded" session
    // (or a "permanent" session if the start time is also zero. In this
    // case we use some very large value (MAX_TTL) as the TTL.
    //

    if ( dwStopTime == 0 )
    {
        *pdwTTL = MAX_TTL;

        LOG((MSP_INFO, "CConference::GetTTL - unbounded or permanent "
            "conference - exit S_OK"));

        return S_OK;
    }

    //
    // Determine the current NTP time.
    //
    
    time_t CurrentTime   = time(NULL);
    DWORD  dwCurrentTime = (DWORD) TimetToNtpTime(CurrentTime);

    //
    // Error if the current time is later than the conference stop time.
    //

    if ( dwStopTime <= dwCurrentTime )
    {
        LOG((MSP_ERROR, "CConference::GetTTL - bounded conference - "
            "current time is later than start time - "
            "exit RND_INVALID_TIME"));

        return HRESULT_FROM_ERROR_CODE(RND_INVALID_TIME);
    }

    //
    // Return how much time from now until the conference expires.
    //

    *pdwTTL = dwStopTime - (DWORD) TimetToNtpTime(CurrentTime);

    LOG((MSP_INFO, "CConference::GetTTL - bounded conference - "
        "exit S_OK"));

    return S_OK;
}

typedef IDispatchImpl<ITDirectoryObjectConferenceVtbl<CConference>, &IID_ITDirectoryObjectConference, &LIBID_RENDLib>    CTDirObjConference;

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CConference::GetIDsOfNames
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP CConference::GetIDsOfNames(REFIID riid,
                                      LPOLESTR* rgszNames, 
                                      UINT cNames, 
                                      LCID lcid, 
                                      DISPID* rgdispid
                                      ) 
{ 
    LOG((MSP_TRACE, "CConference::GetIDsOfNames[%p] - enter. Name [%S]",this, *rgszNames));


    HRESULT hr = DISP_E_UNKNOWNNAME;



    //
    // See if the requsted method belongs to the default interface
    //

    hr = CTDirObjConference::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((MSP_TRACE, "CConference:GetIDsOfNames - found %S on CTDirObjConference", *rgszNames));
        rgdispid[0] |= IDISPDIROBJCONFERENCE;
        return hr;
    }

    
    //
    // If not, then try the CDirectoryObject base class
    //

    hr = CDirectoryObject::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((MSP_TRACE, "CConference::GetIDsOfNames - found %S on CDirectoryObject", *rgszNames));
        rgdispid[0] |= IDISPDIROBJECT;
        return hr;
    }

    LOG((MSP_ERROR, "CConference::GetIDsOfNames[%p] - finish. didn't find %S on our iterfaces",*rgszNames));

    return hr; 
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CConference::Invoke
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP CConference::Invoke(DISPID dispidMember, 
                              REFIID riid, 
                              LCID lcid, 
                              WORD wFlags, 
                              DISPPARAMS* pdispparams, 
                              VARIANT* pvarResult, 
                              EXCEPINFO* pexcepinfo, 
                              UINT* puArgErr
                             )
{
    LOG((MSP_TRACE, "CConference::Invoke[%p] - enter. dispidMember %lx",this, dispidMember));

    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    DWORD   dwInterface = (dispidMember & INTERFACEMASK);
   
   
    //
    // Call invoke for the required interface
    //

    switch (dwInterface)
    {
        case IDISPDIROBJCONFERENCE:
        {
            hr = CTDirObjConference::Invoke(dispidMember, 
                                    riid, 
                                    lcid, 
                                    wFlags, 
                                    pdispparams,
                                    pvarResult, 
                                    pexcepinfo, 
                                    puArgErr
                                   );
        
            LOG((MSP_TRACE, "CConference::Invoke - ITDirectoryObjectConference"));

            break;
        }

        case IDISPDIROBJECT:
        {
            hr = CDirectoryObject::Invoke(dispidMember, 
                                        riid, 
                                        lcid, 
                                        wFlags, 
                                        pdispparams,
                                        pvarResult, 
                                        pexcepinfo, 
                                        puArgErr
                                       );

            LOG((MSP_TRACE, "CConference::Invoke - ITDirectoryObject"));

            break;
        }

    } // end switch (dwInterface)

    
    LOG((MSP_TRACE, "CConference::Invoke[%p] - finish. hr = %lx", hr));

    return hr;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rend.cpp ===
/*

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    rend.cpp

Abstract:

    Implementation of DLL Exports.

Author:

*/


// Note: Proxy/Stub Information
//        To merge the proxy/stub code into the object DLL, add the file 
//        dlldatax.c to the project.  Make sure precompiled headers 
//        are turned off for this file, and add _MERGE_PROXYSTUB to the 
//        defines for the project.  
//
//        If you are not running WinNT4.0 or Win95 with DCOM, then you
//        need to remove the following define from dlldatax.c
//        #define _WIN32_WINNT 0x0400
//
//        Further, if you are running MIDL without /Oicf switch, you also 
//        need to remove the following define from dlldatax.c.
//        #define USE_STUBLESS_PROXY
//
//        Modify the custom build rule for rend.idl by adding the following 
//        files to the Outputs.
//            rend_p.c
//            dlldata.c
//        To build a separate proxy/stub DLL, 
//        run nmake -f rendps.mk in the project directory.

#include "stdafx.h"

#include "initguid.h"
#include "rndcommc.h"
#include "rndrend.h"
#include "rndreg.h"
#include "thread.h"

#ifdef _MERGE_PROXYSTUB
#include "dlldatax.h"
extern "C" HINSTANCE hProxyDll;
#endif

// Include the ATL
#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#ifdef DEBUG_HEAPS
// ZoltanS: for heap debugging
#include <crtdbg.h>
#endif // DEBUG_HEAPS

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_Rendezvous, CRendezvous)          
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
#ifdef DEBUG_HEAPS
    // ZoltanS: turn on leak detection
    _CrtSetDbgFlag( _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) | _CRTDBG_LEAK_CHECK_DF );

    // ZoltanS: force a memory leak
    char * leak = new char [ 1977 ];
        sprintf(leak, "rend.dll NORMAL leak");
        leak = NULL;
#endif // DEBUG_HEAPS


        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);

        // Randomize for any subsequent calls to rand().
        srand( (unsigned) time( NULL ) );

#ifdef MSPLOG
        // Register for trace output.
        MSPLOGREGISTER(_T("rend"));
#endif // MSPLOG
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
#ifdef MSPLOG
        // Deregister for trace output.
        MSPLOGDEREGISTER();
#endif //MSPLOG

        //
        // The DLL_PROCESS_DETACH have been called by FreeLibrary
        // if is not NULL then the other libraries are already
        // unload so we shouldn't have to call them
        //
        if( lpReserved == NULL )
        {
            g_RendThread.Shutdown();
        }

        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rnddo.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    rnddo.cpp

Abstract:

    This module contains implementation of CDirectoryObject object.

--*/

#include "stdafx.h"

#include "rnddo.h"

/////////////////////////////////////////////////////////////////////////////
// ITDirectoryObject
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDirectoryObject::get_ObjectType(
    OUT DIRECTORY_OBJECT_TYPE *   pObjectType
    )
{
    if ( IsBadWritePtr(pObjectType, sizeof(DIRECTORY_OBJECT_TYPE) ) )
    {
        LOG((MSP_ERROR, "CDirectoryObject.get_ObjectType, invalid pointer"));
        return E_POINTER;
    }

    CLock Lock(m_lock);

    *pObjectType = m_Type;

    return S_OK;
}

STDMETHODIMP CDirectoryObject::get_SecurityDescriptor(
    OUT IDispatch ** ppSecDes
    )
{
    LOG((MSP_INFO, "CDirectoryObject::get_SecurityDescriptor - enter"));

    //
    // Check parameters.
    //

    BAIL_IF_BAD_WRITE_PTR(ppSecDes, E_POINTER);

    //
    // Do the rest in our lock.
    //

    CLock Lock(m_lock);

    //
    // If we don't have an IDispatch security descriptor, convert it. This
    // will happen if PutConvertedSecurityDescriptor was called on object
    // creation but neither get_SecurityDescriptor nor
    // put_SecurityDescriptor have ever been called before on this object.
    //

    if ( ( m_pIDispatchSecurity == NULL ) && ( m_pSecDesData != NULL ) )
    {
        HRESULT hr;

        hr = ConvertSDToIDispatch( (PSECURITY_DESCRIPTOR) m_pSecDesData,
                                   &m_pIDispatchSecurity);

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CDirectoryObject::get_SecurityDescriptor - "
                "invalid security descriptor - exit 0x%08x", hr));
            
            // make sure we don't return something
            *ppSecDes = NULL;
            m_pIDispatchSecurity = NULL;

            return hr;
        }

        //
        // We keep our own reference to the IDispatch. (ie ref = 1 now)
        //
    }

    //
    // Return our IDispatch pointer, (possibly NULL if the object has no
    // security descriptor), AddRefing if not NULL.
    //

    *ppSecDes =  m_pIDispatchSecurity;

    if (m_pIDispatchSecurity)
    {
        m_pIDispatchSecurity->AddRef();
    }

    LOG((MSP_INFO, "CDirectoryObject::get_SecurityDescriptor - exit S_OK"));

    return S_OK;
}

STDMETHODIMP CDirectoryObject::put_SecurityDescriptor(
    IN  IDispatch * pSecDes
    )
{
    LOG((MSP_INFO, "CDirectoryObject::put_SecurityDescriptor - enter"));

    //
    // Make sure we are setting a valid interface pointer.
    // (We've always done it this way -- it also means that
    // you can't put a null security descriptor. The way to
    // "turn off" the security descriptor is to construct an
    // "empty" one or one granting everyone all access, and put_
    // that here.)
    //

    BAIL_IF_BAD_READ_PTR(pSecDes, E_POINTER);

    //
    // Do the rest in our critical section.
    //

    CLock Lock(m_lock);

    PSECURITY_DESCRIPTOR pSecDesData;
    DWORD                dwSecDesSize;

    //
    // Convert the new security descriptor to a SECURITY_DESCRIPTOR.
    //

    HRESULT              hr;

    hr = ConvertObjectToSDDispatch(pSecDes, &pSecDesData, &dwSecDesSize);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CDirectoryObject::put_SecurityDescriptor - "
            "ConvertObjectToSDDispatch failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // Check if the new security descriptor's contents differ from the
    // old security descriptor's contents.
    //

    m_fSecurityDescriptorChanged =
        CheckIfSecurityDescriptorsDiffer(m_pSecDesData, m_dwSecDesSize,
                                         pSecDesData,   dwSecDesSize);

    if (m_pIDispatchSecurity) // need this check because it's initially NULL
    {
        m_pIDispatchSecurity->Release();

        // this was newed on previous ConvertObjectToSDDispatch
        // or before PutConvertedSecurityDescriptor        
        
        delete m_pSecDesData; 
    }

    m_pIDispatchSecurity = pSecDes;
    m_pSecDesData        = pSecDesData;
    m_dwSecDesSize       = dwSecDesSize;

    m_pIDispatchSecurity->AddRef();

    LOG((MSP_INFO, "CDirectoryObject::put_SecurityDescriptor - exit S_OK"));

    return S_OK;
}

/* currently not exposed publicly, but nothing's stopping us from exposing it */
STDMETHODIMP CDirectoryObject::get_SecurityDescriptorIsModified(
    OUT   VARIANT_BOOL *      pfIsModified
    )
{
    LOG((MSP_INFO, "CDirectoryObject::get_SecurityDescriptorIsModified - "
        "enter"));

    //
    // Check parameters.
    //

    if ( IsBadWritePtr(pfIsModified, sizeof(VARIANT_BOOL) ) )
    {
        LOG((MSP_ERROR, "CDirectoryObject::get_SecurityDescriptorIsModified - "
            "enter"));

        return E_POINTER;
    }

    if ( m_fSecurityDescriptorChanged )
    {
        *pfIsModified = VARIANT_TRUE;
    }
    else
    {
        *pfIsModified = VARIANT_FALSE;
    }

    LOG((MSP_INFO, "CDirectoryObject::get_SecurityDescriptorIsModified - "
        "exit S_OK"));

    return S_OK;
}

// to keep the logic consistent this is not exposed publicly
// this overrules our comparison... it's normally called with VARIANT_FALSE
// to inform us that the object has been successfully written to the server
// or that the previous put_SecurityDescriptor was the one from the server
// rather than from the app.

STDMETHODIMP CDirectoryObject::put_SecurityDescriptorIsModified(
    IN   VARIANT_BOOL         fIsModified
    )
{
    LOG((MSP_INFO, "CDirectoryObject::put_SecurityDescriptorIsModified - "
        "enter"));

    if ( fIsModified )
    {
        m_fSecurityDescriptorChanged = TRUE;
    }
    else
    {
        m_fSecurityDescriptorChanged = FALSE;
    }

    LOG((MSP_INFO, "CDirectoryObject::put_SecurityDescriptorIsModified - "
        "exit S_OK"));

    return S_OK;
}


HRESULT CDirectoryObject::PutConvertedSecurityDescriptor(
    IN char *                 pSD,
    IN DWORD                  dwSize
    )
{
    LOG((MSP_INFO, "CDirectoryObject::PutConvertedSecurityDescriptor - "
        "enter"));

    //
    // Return our data. We retain ownership of the pointer;
    // the caller must not delete it. (We may delete it later so the caller
    // must have newed it.)
    //

    m_pSecDesData  = pSD;
    m_dwSecDesSize = dwSize;

    LOG((MSP_INFO, "CDirectoryObject::PutConvertedSecurityDescriptor - "
        "exit S_OK"));

    return S_OK;
}

HRESULT CDirectoryObject::GetConvertedSecurityDescriptor(
    OUT char **                 ppSD,
    OUT DWORD *                 pdwSize
    )
{
    LOG((MSP_INFO, "CDirectoryObject::GetConvertedSecurityDescriptor - "
        "enter"));

    //
    // Return our data. We retain ownership of the pointer;
    // the caller must not delete it.
    //

    *ppSD = (char *)m_pSecDesData;
    *pdwSize = m_dwSecDesSize;

    LOG((MSP_INFO, "CDirectoryObject::GetConvertedSecurityDescriptor - "
        "exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////

void CDirectoryObject::FinalRelease(void)
{
    LOG((MSP_INFO, "CDirectoryObject::FinalRelease - "
        "enter"));

    if ( NULL != m_pIDispatchSecurity )
    {
        m_pIDispatchSecurity->Release();
        m_pIDispatchSecurity = NULL;
    }

    if ( NULL != m_pSecDesData )
    {
        delete m_pSecDesData; // newed on last ConvertObjectToSDDispatch
    }

    if ( m_pFTM )
    {
        m_pFTM->Release();
    }

    LOG((MSP_INFO, "CDirectoryObject::FinalRelease - "
        "exit S_OK"));
}

HRESULT CDirectoryObject::FinalConstruct(void)
{
    LOG((MSP_INFO, "CDirectoryObject::FinalConstruct - enter"));

    HRESULT hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                & m_pFTM );

    if ( FAILED(hr) )
    {
        LOG((MSP_INFO, "CDirectoryObject::FinalConstruct - "
            "create FTM returned 0x%08x; exit", hr));

        return hr;
    }

    LOG((MSP_INFO, "CDirectoryObject::FinalConstruct - exit S_OK"));

    return S_OK;
}


// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndcnf.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    rndcnf.h

Abstract:

    Definitions for CConference class.

--*/

#ifndef __RNDCNF_H
#define __RNDCNF_H

#include "sdpblb.h"

#include "rnddo.h"

#pragma once

/////////////////////////////////////////////////////////////////////////////
// CConference
/////////////////////////////////////////////////////////////////////////////

const DWORD     NTP_OFFSET  = 0x83aa7e80;
const SHORT     FIRST_POSSIBLE_YEAR = 1970;

//                                       123456789012Z
const WCHAR     WSTR_GEN_TIME_ZERO[] = L"000000000000Z";

//                        1234567890
const DWORD     MAX_TTL = 2000000000;

const DWORD NUM_MEETING_ATTRIBUTES = 
    MEETING_ATTRIBUTES_END - MEETING_ATTRIBUTES_BEGIN - 1;

template <class T>
class  ITDirectoryObjectConferenceVtbl : public ITDirectoryObjectConference
{
};

class CConference :
    public CDirectoryObject,
    public CComDualImpl<ITDirectoryObjectConferenceVtbl<CConference>, &IID_ITDirectoryObjectConference, &LIBID_RENDLib>
{
// Add the following line to your object if you get a message about
// GetControllingUnknown() being undefined
// DECLARE_GET_CONTROLLING_UNKNOWN()

public:

BEGIN_COM_MAP(CConference)
    COM_INTERFACE_ENTRY(ITDirectoryObjectConference)
    COM_INTERFACE_ENTRY_CHAIN(CDirectoryObject)
    COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_pIUnkConfBlob)
END_COM_MAP()

//DECLARE_NOT_AGGREGATABLE(CConference) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

//
// ITDirectoryObject overrides (not implemented by CDirectoryObject)
//

    STDMETHOD (get_Name) (
        OUT BSTR *ppName
        );

    STDMETHOD (put_Name) (
        IN BSTR Val
        );

    STDMETHOD (get_DialableAddrs) (
        IN  long        AddressTypes,   //defined in tapi.h
        OUT VARIANT *   pVariant
        );

    STDMETHOD (EnumerateDialableAddrs) (
        IN  DWORD                   dwAddressTypes, //defined in tapi.h
        OUT IEnumDialableAddrs **   pEnumDialableAddrs
        );

    STDMETHOD (GetTTL)(
        OUT DWORD *    pdwTTL
        );

//
// ITDirectoryObjectPrivate overrides (not implemented by CDirectoryObject)
//

    STDMETHOD (GetAttribute)(
        IN  OBJECT_ATTRIBUTE    Attribute,
        OUT BSTR *              ppAttributeValue
        );

    STDMETHOD (SetAttribute)(
        IN  OBJECT_ATTRIBUTE    Attribute,
        IN  BSTR                pAttributeValue
        );

//
// ITDirectoryObjectConference
//

    STDMETHOD(get_StartTime)(OUT DATE *pDate);
    STDMETHOD(put_StartTime)(IN DATE Date);

    STDMETHOD(get_StopTime)(OUT DATE *pDate);
    STDMETHOD(put_StopTime)(IN DATE Date);

    STDMETHOD(get_IsEncrypted)(OUT VARIANT_BOOL *pfEncrypted);
    STDMETHOD(put_IsEncrypted)(IN VARIANT_BOOL fEncrypted);

    STDMETHOD(get_Description)(OUT BSTR *ppDescription);
    STDMETHOD(put_Description)(IN BSTR pDescription);

    STDMETHOD(get_Url)(OUT BSTR *ppUrl);
    STDMETHOD(put_Url)(IN BSTR pUrl);

    STDMETHOD(get_AdvertisingScope)(
        OUT RND_ADVERTISING_SCOPE *pAdvertisingScope
        );

    STDMETHOD(put_AdvertisingScope)(
        IN RND_ADVERTISING_SCOPE AdvertisingScope
        );

    STDMETHOD(get_Originator)(OUT BSTR *ppOriginator);
    STDMETHOD(put_Originator)(IN BSTR pOriginator);

    STDMETHOD(get_Protocol)(OUT BSTR *ppProtocol);

    /* removed from interface (was not implemented and never will be) */
    /* STDMETHOD(put_Protocol)(IN BSTR pProtocol); */

    /* also removed because they were simultaneously useless and buggy */
    /* STDMETHOD(get_ConferenceType)(OUT BSTR *ppType); */
    /* STDMETHOD(put_ConferenceType)(IN BSTR pType); */

    //
    // IDispatch  methods
    //

    STDMETHOD(GetIDsOfNames)(REFIID riid, 
                             LPOLESTR* rgszNames,
                             UINT cNames, 
                             LCID lcid, 
                             DISPID* rgdispid
                            );

    STDMETHOD(Invoke)(DISPID dispidMember, 
                      REFIID riid, 
                      LCID lcid,
                      WORD wFlags, 
                      DISPPARAMS* pdispparams, 
                      VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, 
                      UINT* puArgErr
                      );

protected:
    HRESULT UpdateConferenceBlob(
        IN  IUnknown        *pIUnkConfBlob                         
        );

    HRESULT WriteAdvertisingScope(
        IN  DWORD   AdvertisingScope
        );

    HRESULT GetSingleValueBstr(
        IN  OBJECT_ATTRIBUTE    Attribute,
        OUT BSTR    *           AttributeValue
        );

    HRESULT GetSingleValueWstr(
        IN  OBJECT_ATTRIBUTE    Attribute,
        IN  DWORD               dwSize,
        OUT WCHAR   *           AttributeValue
        );

    HRESULT SetSingleValue(
        IN  OBJECT_ATTRIBUTE    Attribute,
        IN  WCHAR   *           AttributeValue
        );

    HRESULT GetStartTime();

    HRESULT GetStopTime();
   
    HRESULT WriteStartTime(
        IN  DWORD   NtpStartTime
        );

    HRESULT WriteStopTime(
        IN  DWORD   NtpStopTime
        );

    HRESULT	
    SetDefaultValue(
        IN  REG_INFO    RegInfo[],
        IN  DWORD       dwItems
        );

    HRESULT SetDefaultSD();

public:
    CConference::CConference()
        : m_pIUnkConfBlob(NULL),
          m_pITConfBlob(NULL),
          m_pITConfBlobPrivate(NULL)
    {
        m_Type = OT_CONFERENCE;
    }

    HRESULT Init(BSTR pName);

    HRESULT Init(BSTR pName, BSTR pProtocol, BSTR pBlob);

    HRESULT FinalConstruct();

    virtual void FinalRelease();

protected:

    IUnknown                *m_pIUnkConfBlob;
    ITConferenceBlob        *m_pITConfBlob;
    ITConfBlobPrivate       *m_pITConfBlobPrivate;

    CTstr                   m_Attributes[NUM_MEETING_ATTRIBUTES];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndcoll.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    rndcoll.h

Abstract:

    Definitions for CRendezvous collection template class.
--*/

#ifndef __RENDCOLL_H
#define __RENDCOLL_H

#include "tapi3if.h"
#include "rndobjsf.h"

EXTERN_C const IID LIBID_TAPI3Lib;

template <class T>
class ATL_NO_VTABLE TInterfaceCollection :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<ITCollection, &IID_ITCollection, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl

{
public:
    TInterfaceCollection()
        : m_Var(NULL), m_nSize(0), m_pFTM(NULL) {}

    ~TInterfaceCollection() 
    {
        delete [] m_Var;

        if ( m_pFTM )
        {
            m_pFTM->Release();
        }
    }

typedef TInterfaceCollection<T> _TCollection;

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(_TCollection)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ITCollection)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
    END_COM_MAP()

private:
    // Array of Dispatch pointers.
    CComVariant*    m_Var ;
    long            m_nSize;
    IUnknown      * m_pFTM;          // pointer to the free threaded marshaler

public:

    HRESULT Initialize (long nSize, T* begin, T* end);

// ICollection methods
    STDMETHOD (get_Count) (OUT long* retval);
    STDMETHOD (get_Item) (IN long Index, OUT VARIANT* retval);
    STDMETHOD (get__NewEnum)(IUnknown** retval);
};

template <class T>
HRESULT 
TInterfaceCollection<T>::Initialize (long nSize, T* begin, T* end)
{
    if ( nSize < 0 )
    {
        return E_INVALIDARG;
    }


    HRESULT hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                & m_pFTM );

    if ( FAILED(hr) )
    {
        LOG((MSP_INFO, "CTInterfaceCollection::Initialize - "
            "create FTM returned 0x%08x; exit", hr));

        return hr;
    }

    if (NULL == (m_Var = new CComVariant[nSize]))
    {
        return E_OUTOFMEMORY;
    }

    m_nSize = nSize;

    DWORD i = 0;

    for (T *iter = begin; iter != end; iter ++, i ++)
    {
        // get IDispatch pointer
        IDispatch * pDisp;

        hr = (*iter)->QueryInterface(IID_IDispatch, (void**)&pDisp);
        if (S_OK != hr) return hr;

        V_VT(&m_Var[i])         = VT_DISPATCH;
        V_DISPATCH(&m_Var[i])   = pDisp;
    }

    return S_OK;    
}

template <class T>
STDMETHODIMP 
TInterfaceCollection<T>::get_Count(OUT long* retval)
{
    if ( IsBadWritePtr(retval, sizeof(long) ) )
    {
        return E_POINTER;
    }

    *retval = m_nSize;

    return S_OK;
}

template <class T>
STDMETHODIMP 
TInterfaceCollection<T>::get_Item(IN long Index, OUT VARIANT* retval)
{
    if ( IsBadWritePtr(retval, sizeof(VARIANT) ) )
    {
        return E_POINTER;
    }

    retval->vt = VT_UNKNOWN;
    retval->punkVal = NULL;

    // use 1-based index, VB like
    if ((Index < 1) || (Index > m_nSize))
    {
        return E_INVALIDARG;
    }

    VariantCopy(retval, &m_Var[Index-1]);

    return S_OK;    
}

template <class T>
STDMETHODIMP 
TInterfaceCollection<T>::get__NewEnum(IUnknown** retval)
{
    if ( IsBadWritePtr(retval, sizeof( IUnknown * ) ) )
    {
        return E_POINTER;
    }

    *retval = NULL;

    typedef CComObject<CSafeComEnum<IEnumVARIANT, 
        &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT> > > enumvar;

    enumvar* p; // = new enumvar;
    enumvar::CreateInstance( &p );

    if (p == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = p->Init(&m_Var[0], &m_Var[m_nSize], NULL, AtlFlagCopy);

    if (SUCCEEDED(hr))
    {
        hr = p->QueryInterface(IID_IEnumVARIANT, (void**)retval);
    }
    else
    {
        delete p;
    }

    return hr;
}

class ATL_NO_VTABLE TBstrCollection :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<ITCollection, &IID_ITCollection, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:
    TBstrCollection()
        : m_Var(NULL), m_nSize(0), m_pFTM(NULL) {}

    ~TBstrCollection()
    {
        delete [] m_Var;

        if ( m_pFTM )
        {
            m_pFTM->Release();
        }
    }

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(TBstrCollection)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ITCollection)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
    END_COM_MAP()

private:
    // Array of Dispatch pointers.
    CComVariant*    m_Var ;
    long            m_nSize;
    IUnknown      * m_pFTM;          // pointer to the free threaded marshaler

public:

    inline HRESULT Initialize (long nSize, BSTR* begin, BSTR* end, CComEnumFlags flags);

// ITCollection methods
    inline STDMETHOD (get_Count) (OUT long* retval);
    inline STDMETHOD (get_Item) (IN long Index, OUT VARIANT* retval);
    inline STDMETHOD (get__NewEnum)(IUnknown** retval);
};

inline
HRESULT 
TBstrCollection::Initialize (long nSize, BSTR * begin, BSTR * end, CComEnumFlags flags)
{
    if ( nSize < 0 )
    {
        return E_INVALIDARG;
    }

    HRESULT hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                & m_pFTM );

    if ( FAILED(hr) )
    {
        LOG((MSP_INFO, "TCollectionCollection::Initialize - "
            "create FTM returned 0x%08x; exit", hr));

        return hr;
    }

    if (NULL == (m_Var = new CComVariant[nSize]))
    {
        return E_OUTOFMEMORY;
    }

    m_nSize = nSize;

    DWORD i = 0;

    for (BSTR * iter = begin; iter != end; iter ++, i ++)
    {
        m_Var[i].vt         = VT_BSTR;
        switch (flags)
        {
        case AtlFlagNoCopy: 
        case AtlFlagTakeOwnership :
            m_Var[i].bstrVal    = (*iter);
            break;

        case AtlFlagCopy: 
            m_Var[i].bstrVal    = SysAllocString(*iter);
            if (m_Var[i].bstrVal == NULL)
            {
                return E_OUTOFMEMORY;
            }
            break;
        }
    }

    if (AtlFlagTakeOwnership) delete begin;

    return S_OK;    
}

inline 
STDMETHODIMP 
TBstrCollection::get_Count(OUT long* retval)
{
    if ( IsBadWritePtr(retval, sizeof(long) ) )
    {
        return E_POINTER;
    }
    
    *retval = m_nSize;

    return S_OK;
}

inline
STDMETHODIMP 
TBstrCollection::get_Item(IN long Index, OUT VARIANT* retval)
{
    if ( IsBadWritePtr(retval, sizeof(VARIANT) ) )
    {
        return E_POINTER;
    }

    retval->vt = VT_UNKNOWN;
    retval->punkVal = NULL;

    // use 1-based index, VB like
    if ((Index < 1) || (Index > m_nSize))
    {
        return E_INVALIDARG;
    }

    VariantCopy(retval, &m_Var[Index-1]);

    return S_OK;    
}

inline 
STDMETHODIMP 
TBstrCollection::get__NewEnum(IUnknown** retval)
{
    if ( IsBadWritePtr(retval, sizeof( IUnknown * ) ) )
    {
        return E_POINTER;
    }

    *retval = NULL;

    typedef CComObject<CSafeComEnum<IEnumVARIANT, 
        &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT> > > enumvar;

    enumvar* p; // = new enumvar;
    enumvar::CreateInstance( &p );

    if (p == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = p->Init(&m_Var[0], &m_Var[m_nSize], NULL, AtlFlagCopy);

    if (SUCCEEDED(hr))
    {
        hr = p->QueryInterface(IID_IEnumVARIANT, (void**)retval);
    }
    else
    {
        delete p;
    }

    return hr;
}

template <class T>
HRESULT CreateInterfaceCollection(
    IN  long        nSize,
    IN  T *         begin,
    IN  T *         end,
    OUT VARIANT *   pVariant              
    )
{
    // create the collection object
    typedef TInterfaceCollection<T> CCollection;

    CComObject<CCollection> * p;
    HRESULT hr = CComObject<CCollection>::CreateInstance( &p );

    if (NULL == p)
    {
        LOG((MSP_ERROR, "Could not create Collection object, %x",hr));
        return hr;
    }

    hr = p->Initialize(nSize, begin, end);

    if (S_OK != hr)
    {
        LOG((MSP_ERROR, "Could not initialize Collection object, %x", hr));
        delete p;
        return hr;
    }

    IDispatch *pDisp;

    // get the IDispatch interface
    hr = p->_InternalQueryInterface(IID_IDispatch, (void **)&pDisp);

    if (S_OK != hr)
    {
        LOG((MSP_ERROR, "QI for IDispatch in CreateCollection, %x", hr));
        delete p;
        return hr;
    }

    // put it in the variant
    VariantInit(pVariant);
    V_VT(pVariant)       = VT_DISPATCH;
    V_DISPATCH(pVariant) = pDisp;

    return S_OK;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndcommc.h ===
/*++

    Copyright (c) 1997-2000 Microsoft Corporation

  Module Name:

    rndcommc.h

  Abstract:

    This module provides common definitions used in rendezvous control.

  --*/
  
#ifndef __REND_COMMON_C__
#define __REND_COMMON_C__

#include "rend.h"
#include "rendp.h"

#define WINSOCKVERSION     0x0200

typedef ITDirectory * PDIRECTORY;
typedef ITDirectoryObject * PDIRECTORYOBJECT;

#define MeetingAttrIndex(a) ((a) - MEETING_ATTRIBUTES_BEGIN - 1)

#define UserAttrIndex(a) ((a) - USER_ATTRIBUTES_BEGIN - 1)

#define ValidMeetingAttribute(a) \
    (((a) > MEETING_ATTRIBUTES_BEGIN) && ((a) < MEETING_ATTRIBUTES_END))

#define ValidUserAttribute(a) \
    (((a) > USER_ATTRIBUTES_BEGIN) && ((a) < USER_ATTRIBUTES_END))

extern const WCHAR * const MeetingAttributeNames[];
extern const WCHAR * const UserAttributeNames[];

#define UserAttributeName(a) (UserAttributeNames[UserAttrIndex(a)])

#define MeetingAttributeName(a) (MeetingAttributeNames[MeetingAttrIndex(a)])

// sets the first bit to indicate error
// sets the win32 facility code
// this is used instead of the HRESULT_FROM_WIN32 macro 
// because that clears the customer flag
inline long
HRESULT_FROM_ERROR_CODE(IN long ErrorCode)
{
    LOG((MSP_ERROR, "HRESULT_FROM_ERROR_CODE - error %x", 
        (0x80070000 | (0xa000ffff & ErrorCode))));
    return ( 0x80070000 | (0xa000ffff & ErrorCode) );
}

inline BOOL
CUSTOMER_FLAG_ON(IN long ErrorValue)
{
    return (0x20000000 & ErrorValue);
}

template <class T>
inline BOOL BadReadPtr(T* p, DWORD dwSize = 1)
{
    return IsBadReadPtr(p, dwSize * sizeof(T));
}

template <class T>
inline BOOL BadWritePtr(T* p, DWORD dwSize = 1)
{
    return IsBadWritePtr(p, dwSize * sizeof(T));
}

#define BAIL_IF_FAIL(HResultExpr, msg)    \
{                                                               \
    HRESULT MacroHResult = HResultExpr;                         \
    if (FAILED(MacroHResult))      \
    {                                                           \
        LOG((MSP_ERROR, "%s - error %x", msg, MacroHResult)); \
        return MacroHResult;                                    \
    }                                                           \
}

#define BAIL_IF_NULL(Ptr, ReturnValue)  \
{                                       \
    if ( NULL == Ptr )                    \
    {                                   \
        LOG((MSP_ERROR, "NULL_PTR - ret value %x", ReturnValue));   \
        return ReturnValue;             \
    }                                   \
}

#define BAIL_IF_BAD_READ_PTR(Ptr, ReturnValue)  \
{                                       \
    if ( BadReadPtr(Ptr) )                    \
    {                                   \
        LOG((MSP_ERROR, "BAD_READ_PTR - ret value %x", ReturnValue));\
        return ReturnValue;             \
    }                                   \
}

#define BAIL_IF_BAD_WRITE_PTR(Ptr, ReturnValue)  \
{                                       \
    if ( BadWritePtr(Ptr) )                    \
    {                                   \
        LOG((MSP_ERROR, "BAD_WRITE_PTR - ret value %x", ReturnValue));   \
        return ReturnValue;             \
    }                                   \
}

#endif  // __REND_COMMON_C__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rnddo.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    rnddo.h

Abstract:

    Definitions for CDirectoryObject class.

--*/

#ifndef __RNDDO_H
#define __RNDDO_H

#pragma once

#include "rndobjsf.h"
#include "rndcommc.h"
#include "rndutil.h"
#include "rndsec.h"
#include "rndreg.h"

/////////////////////////////////////////////////////////////////////////////
// CDirectoryObject
/////////////////////////////////////////////////////////////////////////////

class CDirectoryObject :
    public CComDualImpl<
                ITDirectoryObject, 
                &IID_ITDirectoryObject, 
                &LIBID_RENDLib
                >,
    public ITDirectoryObjectPrivate,
    public CComObjectRootEx<CComObjectThreadModel>,
    public CObjectSafeImpl
{
public:

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDirectoryObject)
        COM_INTERFACE_ENTRY2(IDispatch, ITDirectoryObject)
        COM_INTERFACE_ENTRY(ITDirectoryObject)
        COM_INTERFACE_ENTRY(ITDirectoryObjectPrivate)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
        COM_INTERFACE_ENTRY(IObjectSafety)
    END_COM_MAP()

//
// ITDirectoryObject
//

    STDMETHOD (get_ObjectType) (
        OUT DIRECTORY_OBJECT_TYPE *   pObjectType
        );

    STDMETHOD (get_Name) (
        OUT BSTR *pVal
        ) = 0;

    STDMETHOD (put_Name) (
        IN BSTR Val
        ) = 0;

    STDMETHOD (get_DialableAddrs) (
        IN  long        dwAddressTypes,   //defined in tapi.h
        OUT VARIANT *   pVariant
        ) = 0;

    STDMETHOD (EnumerateDialableAddrs) (
        IN  DWORD                   dwAddressTypes, //defined in tapi.h
        OUT IEnumDialableAddrs **   pEnumDialableAddrs
        ) = 0;

    STDMETHOD (GetTTL)(
        OUT DWORD *    pdwTTL
        ) = 0;

    STDMETHOD (get_SecurityDescriptor) (
        OUT IDispatch ** ppSecDes
        );

    STDMETHOD (put_SecurityDescriptor) (
        IN  IDispatch * pSecDes
        );

//
// ITDirectoryObjectPrivate
//

    STDMETHOD (GetAttribute)(
        IN  OBJECT_ATTRIBUTE    Attribute,
        OUT BSTR *              ppAttributeValue
        ) = 0;

    STDMETHOD (SetAttribute)(
        IN  OBJECT_ATTRIBUTE    Attribute,
        IN  BSTR                pAttributeValue
        ) = 0;

    STDMETHOD (get_SecurityDescriptorIsModified) (
        OUT   VARIANT_BOOL *      pfIsModified
        );

    STDMETHOD (put_SecurityDescriptorIsModified) (
        IN   VARIANT_BOOL         fIsModified
        );

    STDMETHOD (PutConvertedSecurityDescriptor) (
        IN char *                 pSD,
        IN DWORD                  dwSize
        );

    STDMETHOD (GetConvertedSecurityDescriptor) (
        OUT char **                 ppSD,
        OUT DWORD *                 pdwSize
        );
    
public:

    CDirectoryObject() 
        : m_pIDispatchSecurity(NULL),
          m_fSecurityDescriptorChanged(FALSE),
          m_pSecDesData(NULL),
          m_dwSecDesSize(0),
          m_pFTM(NULL)

    {}

    virtual ~CDirectoryObject() {}

    virtual void FinalRelease(void);

    virtual HRESULT FinalConstruct(void);

protected:
    CCritSection            m_lock;

    DIRECTORY_OBJECT_TYPE   m_Type;

    IDispatch *             m_pIDispatchSecurity;
    BOOL                    m_fSecurityDescriptorChanged;
    PSECURITY_DESCRIPTOR    m_pSecDesData;
    DWORD                   m_dwSecDesSize;

    IUnknown      * m_pFTM;          // pointer to the free threaded marshaler
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndils.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    rndils.cpp

Abstract:

    This module contains implementation of CILSDirectory.


--*/

#include "stdafx.h"
#include <limits.h>

#include "rndcommc.h"
#include "rndils.h"
#include "rndldap.h"
#include "rndcnf.h"
#include "rndcoll.h"

//
// These are the names of the attributes we have to work with
// in the ILS schema.
//

const WCHAR * const CILSDirectory::s_RTConferenceAttributes[] = 
{
    L"advertisingScope",
    L"conferenceBlob",
    L"generalDescription",
    L"isEncrypted",
    L"uid",
    L"originator",
    L"protocolId",
    L"startTime",
    L"stopTime",
    L"subType",
    L"URL"
};

//
// The following are the attributes we make use of natively for
// ILS user objects. (perhaps not all though?)
//

const WCHAR * const CILSDirectory::s_RTPersonAttributes[] = 
{
    L"cn",
    L"telephoneNumber",
    L"ipAddress"
};

// The following definitions are for NetMeeting compatibility only.

const WCHAR * const g_NMAttributeNames[] = 
{
    L"applicationID",
    L"mimetype",
    L"GUID",
    L"protocolID",
    L"ProtocolMimeType",
    L"port",
	L"ILSA39321630",
    L"ILSA26214430",
    L"ILSA32964638",
    L"ILSA32833566"
};

const DWORD NUM_NM_ATTRIBUTES = 
    (sizeof g_NMAttributeNames)/(sizeof (WCHAR *));

const WCHAR * const g_NMAttributeValues[] = 
{
    L"ms-netmeeting", NULL,
    L"text/iuls", NULL,
    L"008aff194794cf118796444553540000", NULL,
    L"H323", NULL,
    L"text/h323", NULL,
    L"1720", NULL,
    L"4", NULL,
    L"0", NULL,
    L"1", NULL,
    L"1", NULL
};

const WCHAR * const g_NMRTPersonAttributeNames[] = 
{
    // ZoltanS: moved this out so we can make it look nicer: L"givenName",
    L"surname", // vocabulary word: this means "last name"
    L"location",
    L"sflags",
    L"c",
    L"comment",
    L"ssecurity",
    L"smodop",
    L"mimetype",
    L"GUID",
    L"ProtocolMimeType",
    L"port",
	L"ILSA39321630",
    L"ILSA26214430",
    L"ILSA32964638",
    L"ILSA32833566"
};

const DWORD NUM_NM_RTPERSON_ATTRIBUTES = 
    (sizeof g_NMRTPersonAttributeNames)/(sizeof (WCHAR *));

const WCHAR * const g_NMRTPersonAttributeValues[] = 
{
    // ZoltanS: we used to have this here: L"N/A", NULL,
    L" ", NULL,         // ZoltanS was N/A. Need the space to avoid having nothing set.
    L"N/A", NULL,
    L"1", NULL,
    L"US", NULL,
    L"Generated by TAPI3", NULL,
    L"1508109", NULL,
    L"0", NULL,
    L"text/iuls", NULL,
    L"008aff194794cf118796444553540000", NULL,
    L"H323", NULL,
    L"1720", NULL,
    L"4", NULL,
    L"0", NULL,
    L"1", NULL,
    L"1", NULL
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT CILSDirectory::FinalConstruct(void)
{
    LOG((MSP_TRACE, "CILSDirectory::FinalConstruct - enter"));

    HRESULT hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                & m_pFTM );

    if ( FAILED(hr) )
    {
        LOG((MSP_INFO, "CILSDirectory::FinalConstruct - "
            "create FTM returned 0x%08x; exit", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CILSDirectory::FinalConstruct - exit S_OK"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// ldap helper functions
/////////////////////////////////////////////////////////////////////////////

HRESULT ValidateILSServer(IN LDAP *hLdap, IN TCHAR * org)
/*++

Routine Description:

    send a search to check if the RTConference schema is supported

Arguments:
    
    hLdap   - The handle to the ldap connection.

    org     - The default naming context.

Return Value:

    HRESULT.

--*/
{
const WCHAR CN_WSTR[]         = L"cn";
const WCHAR CN_RTCONF_WSTR[]  = L"cn=RTConference";
const WCHAR SCHEMA[]          = L",ou=admin,cn=schema";

    LOG((MSP_INFO, "::ValidateILSServer - entering"));

    // send a search (one level, base dn = "o=ORG,ou=admin,cn=schema",
    // filter = "cn=RTConference") ask for the cn attribute without the value
    PTCHAR  Attributes[] = {(WCHAR *)CN_WSTR, NULL};

    // determine the organization - use the org portion of the directory path
    // string and the pre-cooked "ou=admin,cn=schema" string
    TCHAR  *SchemaDn = new TCHAR[lstrlen(org) + lstrlen(SCHEMA) + 1];
    BAIL_IF_NULL(SchemaDn, E_OUTOFMEMORY);

    lstrcpy(SchemaDn, org);
    lstrcat(SchemaDn, SCHEMA);

    // print the base dn
    LDAPMessage *SearchResult;

    ULONG res = DoLdapSearch(
                hLdap,                   // ldap handle
                SchemaDn,                // schema dn
                LDAP_SCOPE_ONELEVEL,     // one level search
                (WCHAR *)CN_RTCONF_WSTR, // common name is RTConference
                Attributes,              // array of attribute names
                TRUE,                    // don't return the attribute values
                &SearchResult            // search results
                );

    // free the schema dn string
    delete SchemaDn;

    // check result of the search operation
    BAIL_IF_LDAP_FAIL(res, "search for RTConference schema");

    CLdapMsgPtr MessageHolder(SearchResult);

    // check the number of entries returned to determine if OK
    HRESULT hr = (0==ldap_count_entries(hLdap, SearchResult)) ? E_FAIL : S_OK;

    LOG((MSP_INFO, "::ValidateILSServer - exiting %x", hr));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// private functions
/////////////////////////////////////////////////////////////////////////////

HRESULT CILSDirectory::Init(
    IN const TCHAR * const  strServerName,
    IN const WORD           wPort
    )
/*++

Routine Description:

    Connect to the ILS server on a given port.

Arguments:
    
    strServerName   - The ILS server name.

    wPort     - The port number.

Return Value:

    HRESULT.

--*/
{
    if (strServerName != NULL)
    {
        int cbServerName = lstrlen(strServerName);

        // Make sure the adding operation don't go over the limits
        if( (cbServerName+1) <= cbServerName )
        {
            return E_INVALIDARG;
        }

        m_pServerName = new TCHAR [cbServerName + 1];
        if (m_pServerName == NULL)
        {
            return E_OUTOFMEMORY;
        }
        
        // Strange +1, lstrcpyn copies also the NULL terminator
        lstrcpyn(m_pServerName, strServerName, cbServerName+1);
        _ASSERTE( lstrlen(m_pServerName) == cbServerName );
    }

    m_wPort = wPort;

    return S_OK;
}

HRESULT
CILSDirectory::TryServer(
    IN  WORD    Port
    )
/*++

Routine Description:

    Try to connect to the ILS server one the given port.

Arguments:
    
    wPort     - The port number.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_INFO, "trying %S at port %d", m_pServerName, Port));

    // associate the ldap handle with the handle holder. in case of an error
    // and subsequent return (without being reset), the ldap handle is closed
    CLdapPtr hLdap = ldap_init(m_pServerName, Port);
    BAIL_IF_NULL((LDAP*)hLdap, HRESULT_FROM_WIN32(ERROR_BAD_NETPATH));

    LDAP_TIMEVAL Timeout;
    Timeout.tv_sec = REND_LDAP_TIMELIMIT;
    Timeout.tv_usec = 0;

    DWORD res = ldap_connect((LDAP*)hLdap, &Timeout);
    BAIL_IF_LDAP_FAIL(res, "connect to the server.");

    DWORD LdapVersion = 3;
    res = ldap_set_option((LDAP*)hLdap, LDAP_OPT_VERSION, &LdapVersion);
    BAIL_IF_LDAP_FAIL(res, "set ldap version to 3");
	
    res = ldap_set_option((LDAP*)hLdap, LDAP_OPT_TIMELIMIT, &Timeout);
    BAIL_IF_LDAP_FAIL(res, "set ldap timelimit");

    ULONG ldapOptionOn = PtrToUlong(LDAP_OPT_ON);
    res = ldap_set_option((LDAP*)hLdap, LDAP_OPT_AREC_EXCLUSIVE, &ldapOptionOn);
    BAIL_IF_LDAP_FAIL(res, "set ldap arec exclusive");

    if (m_IsSsl)
    {
        res = ldap_set_option(hLdap, LDAP_OPT_SSL, LDAP_OPT_ON);
        BAIL_IF_LDAP_FAIL(res, "set ssl option");
    }

    // if no directory path is specified, query the server
    // to determine the correct path
    CTstr namingContext;
    BAIL_IF_FAIL(
        ::GetNamingContext(hLdap, &namingContext), 
        "read naming context"
        );

    // ZoltanS: this copies the namingContext string.
    BAIL_IF_FAIL(
        ValidateILSServer(hLdap, namingContext), 
        "ValidateILSServer"
        );

    m_pContainer = 
        new TCHAR[lstrlen(namingContext) + lstrlen(DYNAMIC_CONTAINER) + 1];

    BAIL_IF_NULL(m_pContainer, E_OUTOFMEMORY);

    m_pNMContainer = 
        new TCHAR[lstrlen(namingContext) + lstrlen(NETMEETING_CONTAINER) + 1];

    BAIL_IF_NULL(m_pNMContainer, E_OUTOFMEMORY);
    
    m_ldap          = hLdap;

    lstrcpy(m_pContainer, DYNAMIC_CONTAINER);
    lstrcat(m_pContainer, namingContext);

    lstrcpy(m_pNMContainer, NETMEETING_CONTAINER);
    lstrcat(m_pNMContainer, namingContext);

    // reset the holders so that they don't release anyting.
    hLdap   = NULL;

    // ZoltanS fix: We were leaking this string. It is copied
    // everywhere above, so we should NOT reset the holder here!
    // -->  namingContext     = NULL;

    LOG((MSP_INFO, "CILSDirectory::TryServer - exiting OK"));

    return S_OK;
}

HRESULT CILSDirectory::MakeConferenceDN(
    IN  TCHAR *             pName,
    OUT TCHAR **            ppDN
    )
/*++

Routine Description:

    Construct the DN for a conference based on the name of the conference.

Arguments:
    
    pName     - The name of the conference.

    ppDN     - The DN of the conference returned.

Return Value:

    HRESULT.

--*/
{
    DWORD dwLen = 
        lstrlen(m_pContainer) + lstrlen(ILS_CONF_DN_FORMAT) 
        + lstrlen(pName) + 1;

    *ppDN = new TCHAR [dwLen]; 

    BAIL_IF_NULL(*ppDN, E_OUTOFMEMORY);

    wsprintf(*ppDN, ILS_CONF_DN_FORMAT, pName, m_pContainer);

    return S_OK;
}

HRESULT CILSDirectory::MakeUserCN(
    IN  TCHAR *     pName,
    IN  TCHAR *     pAddress,
    OUT TCHAR **    ppCN,
    OUT DWORD *     pdwIP
    )
/*++

Routine Description:

    Construct a User's CN based on username and machine name. The machine
    name is resolved first the get the fully qualified DNS name. The CN is
    in the following format: email\DNSname. 

Arguments:
    
    pName   - The name of the user.

    pAddress - The machine name.

    ppCN    - The CN returned.

    pdwIP   - The resolved IP address of the machine. Used later 
              for Netmeeting. If this is NULL, then we don't care
              about the IP.

Return Value:

    HRESULT.

--*/
{
    char *pchFullDNSName;

    if ( pdwIP == NULL )
    {
        BAIL_IF_FAIL(ResolveHostName(0, pAddress, &pchFullDNSName, NULL),
            "can't resolve host name");
    }
    else
    {
        // we care about the IP, so we must be publishing a user object
        // as opposed to refreshing or deleting. Make sure we use the
        // same IP as the interface that's used to reach the ILS server.

        BAIL_IF_FAIL(ResolveHostName(m_dwInterfaceAddress, pAddress, &pchFullDNSName, pdwIP),
            "can't resolve host name (matching interface address)");
    }

    DWORD dwLen = lstrlen(DYNAMIC_USER_CN_FORMAT) 
        + lstrlen(pName) + lstrlenA(pchFullDNSName);

    *ppCN = new TCHAR [dwLen + 1];

    BAIL_IF_NULL(*ppCN, E_OUTOFMEMORY);

    wsprintf(*ppCN, DYNAMIC_USER_CN_FORMAT, pName, pchFullDNSName);

    return S_OK;
}

HRESULT CILSDirectory::MakeUserDN(
    IN  TCHAR *     pCN,
    OUT TCHAR **    ppDNRTPerson,
    OUT TCHAR **    ppDNNMPerson
    )
/*++

Routine Description:

    Construct the DNs for a user used in the Dynamic container and
    the Netmeeting's container. 

Arguments:
    
    pCN     - the CN of a user.

    ppDNRTPerson    - The DN of the user in the dynamic container.

    ppDNNMPerson    - The DN of the user in NetMeeting's container.

Return Value:

    HRESULT.

--*/
{
    // construct the DN for RTPerson.
    DWORD dwLen = lstrlen(m_pContainer) 
        + lstrlen(DYNAMIC_USER_DN_FORMAT) + lstrlen(pCN);

    *ppDNRTPerson = new TCHAR [dwLen + 1];

    BAIL_IF_NULL(*ppDNRTPerson, E_OUTOFMEMORY);

    wsprintf(*ppDNRTPerson, DYNAMIC_USER_DN_FORMAT, pCN, m_pContainer);

    // construct the DN for NetMeeting's RTApplicationUser.
    dwLen = lstrlen(m_pNMContainer) 
        + lstrlen(DYNAMIC_USER_DN_FORMAT) + lstrlen(pCN);

    *ppDNNMPerson = new TCHAR [dwLen + 1];

    if (*ppDNNMPerson == NULL)
    {
        delete *ppDNRTPerson;
        *ppDNRTPerson = NULL;
        return E_OUTOFMEMORY;
    }

    wsprintf(*ppDNNMPerson, DYNAMIC_USER_DN_FORMAT, pCN, m_pNMContainer);

    return S_OK;
}

HRESULT CILSDirectory::AddConferenceComplete(BOOL       fModify,
                                             LDAP     * ldap,
                                             TCHAR   ** ppDN,
                                             LDAPMod ** mods,
                                             DWORD      TTL1,
                                             DWORD      TTL2)
{
    if (fModify)
    {
        // Call the modify function to modify the object.
        BAIL_IF_LDAP_FAIL(DoLdapModify(FALSE, ldap, *ppDN, mods), 
            "modify conference");
    }
    else
    {
        // Call the add function to create the object.
        BAIL_IF_LDAP_FAIL(DoLdapAdd(ldap, *ppDN, mods), "add conference");

        // next set the TTL value for this object
        BAIL_IF_FAIL(::SetTTL(ldap, *ppDN, (TTL1 == 0) ? TTL2 : TTL1),
            "Set ttl for conference");
    }

    return S_OK;
}

HRESULT CILSDirectory::AddConference(
    IN  ITDirectoryObject *pDirectoryObject,
    IN  BOOL fModify
    )
/*++

Routine Description:
    
    Add a new conference to the ILS server.

Arguments:
    
    pDirectoryObject - a pointer to the conference.
    fModify          - true  if called by MofifyDirectoryObject
                       false if called by AddDirectoryObject

Return Values:

       Value               Where defined       What it means
       -----               -------------       -------------
       HRESULT from ATL QueryInterface
       HRESULT from pDirectoryObject->get_Name
       HRESULT from MakeConferenceDN
       HRESULT from pObjectPrivate->GetAttribute(MA_PROTOCOL)
       HRESULT from pObjectPrivate->GetAttribute(MA_CONFERENCE_BLOB)
       HRESULT from GetSecurityDescriptor
       HRESULT from 
    

--*/
{
    // first query the private interface for attributes.
    CComPtr <ITDirectoryObjectPrivate> pObjectPrivate;

    BAIL_IF_FAIL(
        pDirectoryObject->QueryInterface(
            IID_ITDirectoryObjectPrivate,
            (void **)&pObjectPrivate
            ),
        "can't get the private directory object interface");

    // Get the name of the conference.
    CBstr bName;
    BAIL_IF_FAIL(pDirectoryObject->get_Name(&bName), 
        "get conference name");

    // Construct the DN of the object.
    CTstr pDN;
    BAIL_IF_FAIL(
        MakeConferenceDN(bName, &pDN), "construct DN for conference"
        );

    // Get the protocol and the blob.
    CBstr bProtocol, bBlob;

    BAIL_IF_FAIL(pObjectPrivate->GetAttribute(MA_PROTOCOL, &bProtocol), 
        "get conference protocol");

    BAIL_IF_FAIL(pObjectPrivate->GetAttribute(MA_CONFERENCE_BLOB, &bBlob),
        "get conference Blob");

    // Get the Security Descriptor. The pointer pSD is just a copy of a pointer
    // in the Conference object; the conference object retains ownership of the
    // data and we must be careful not to delete or modify this data.

    char * pSD;
    DWORD dwSDSize;

    BAIL_IF_FAIL(pObjectPrivate->GetConvertedSecurityDescriptor(&pSD, &dwSDSize),
        "get conference security descriptor");

    // Get the TTL setting.
    DWORD dwTTL;
    BAIL_IF_FAIL(pObjectPrivate->GetTTL(&dwTTL), "get conference TTL");

    // 4 attributes needs to be published.
    static const DWORD DWATTRIBUTES = 4;

    // Fist fill the modify structures required by LDAP.
    LDAPMod     mod[DWATTRIBUTES];  
    LDAPMod*    mods[DWATTRIBUTES + 1];

    DWORD       dwCount = 0;

    // The objectclass attribute.
    TCHAR * objectClass[] = 
        {(WCHAR *)ILS_RTCONFERENCE, (WCHAR *)DYNAMICOBJECT, NULL};
    if (!fModify)
    {
        mod[dwCount].mod_values  = objectClass;
        mod[dwCount].mod_op      = LDAP_MOD_REPLACE;
        mod[dwCount].mod_type    = (WCHAR *)OBJECTCLASS;
        dwCount ++;
    }
    
    // The protocol attribute.
    TCHAR * protocol[] = {(WCHAR *)bProtocol, NULL};
    mod[dwCount].mod_values  = protocol;
    mod[dwCount].mod_op      = LDAP_MOD_REPLACE;
    mod[dwCount].mod_type    = (WCHAR *)RTConferenceAttributeName(MA_PROTOCOL);
    dwCount ++;
    
    // The blob attribute.
    TCHAR * blob[]     = {(WCHAR *)bBlob, NULL};
    mod[dwCount].mod_values  = blob;
    mod[dwCount].mod_op      = LDAP_MOD_REPLACE;
    mod[dwCount].mod_type    = 
        (WCHAR *)RTConferenceAttributeName(MA_CONFERENCE_BLOB);
    dwCount ++;

    // ZoltanS fix: these locals should not be within the "if" below... if
    // they are, they might be deallocated before the function returns.
    // This has been broken for a long, long time (unrelated to IsModified
    // stuff below).

    berval  BerVal;
    berval  *sd[] = {&BerVal, NULL};

    HRESULT hr;

    //
    // If there is a security descriptor on the local object, perhaps send it
    // to the server.
    //

    if ( (char*)pSD != NULL )
    {
        BOOL         fSendIt = FALSE;

        if ( ! fModify )
        {
            //
            // We are trying to add the conference, so we definitely need
            // to send the security descriptor. Note that we even want
            // to send it if it hasn't changed, as we may be sending it to
            // some new server other than where we got it (if this conference
            // object was retrieved from a server in the first place).
            //

            fSendIt = TRUE;
        }
        else
        {
            //
            // We are trying to modify the conference, so we send the
            // security descriptor if it has changed.
            //

            VARIANT_BOOL fChanged;

            hr = pObjectPrivate->get_SecurityDescriptorIsModified( &fChanged );

            if ( SUCCEEDED( hr ) && ( fChanged == VARIANT_TRUE ) )
            {
                fSendIt = TRUE;
            }
        }

        if ( fSendIt )
        {
            //
            // We've decided to send the ACL. Fail before adding / modifying
            // the conference if the ACL is unsafe (would prevent us from
            // later deleting or modifying our own conference).
            //

            hr = TestAclSafety(pSD, dwSDSize);

            if ( FAILED(hr) )
            {
                LOG((MSP_ERROR, "CILSDirectory::AddConference - "
                    "ACL appears unsafe -- exit 0x%08x", hr));

                return hr;
            }

            //
            // We know we want to send the ACL and we can safely send the ACL.
            // Fill in the mods to send it.
            //

            BerVal.bv_len = dwSDSize;
            BerVal.bv_val = (char*)pSD;

            mod[dwCount].mod_bvalues  = sd;
            mod[dwCount].mod_op       = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
            mod[dwCount].mod_type     = (WCHAR *)NT_SECURITY_DESCRIPTOR;
            dwCount ++;
        }
    }

    //
    // All done with the mods. Package them up and write to the server.
    //

    DWORD i;
    for (i = 0; i < dwCount; i ++)
    {
        mods[i] = &mod[i];
    }
    mods[i] = NULL;
        
    LOG((MSP_INFO, "%S %S", fModify ? _T("modifying") : _T("adding"), pDN));

    hr = AddConferenceComplete(fModify, m_ldap, &pDN, mods, dwTTL, m_TTL);

    if ( SUCCEEDED(hr) )
    {
        pObjectPrivate->put_SecurityDescriptorIsModified( VARIANT_FALSE );
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// This method tests if the given ACL (security descriptor) is "safe".
// "Safe" is defined as allowing the creator to modify and delete the
// object; modification is tested via the TTL field.
//
// This test is needed to prevent leaving "ghost" objects on the server
// when modifying the TTL of a newly-created conference fails because of
// insfufficient access rights. This will happen if a user messes up
// ACL creation or if the server does not understand the domain trustees
// in the ACL (e.g., server machine is not in a domain).
//
// The test is performed by creating a "dummy" test object with a random
// name in the container normally used for conferences. The object will
// not show up in a normal conference or user enumeration because it does
// not have the required attributes.
//
//

HRESULT CILSDirectory::TestAclSafety(
    IN  char  * pSD,
    IN  DWORD   dwSDSize
    )
{
    LOG((MSP_TRACE, "CILSDirectory::TestACLSafety - enter"));

    //
    // First fill in the modify structures required by LDAP.
    // We use only the object class and the security descriptor.
    // Therefore this will not show up as a valid conference
    // during an enumeration.
    //
    
    static const DWORD DWATTRIBUTES = 2;

    LDAPMod     mod[DWATTRIBUTES];  
    LDAPMod*    mods[DWATTRIBUTES + 1];

    DWORD       dwCount = 0;

    TCHAR * objectClass[] = 
        {(WCHAR *)ILS_RTCONFERENCE, (WCHAR *)DYNAMICOBJECT, NULL};

    mod[dwCount].mod_values  = objectClass;
    mod[dwCount].mod_op      = LDAP_MOD_REPLACE;
    mod[dwCount].mod_type    = (WCHAR *)OBJECTCLASS;
    dwCount ++;

    berval  BerVal;
    berval  *sd[] = {&BerVal, NULL};

    BerVal.bv_len = dwSDSize;
    BerVal.bv_val = (char*)pSD;

    mod[dwCount].mod_bvalues  = sd;
    mod[dwCount].mod_op       = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    mod[dwCount].mod_type     = (WCHAR *)NT_SECURITY_DESCRIPTOR;
    dwCount ++;

    DWORD i;
    for (i = 0; i < dwCount; i ++)
    {
        mods[i] = &mod[i];
    }
    mods[i] = NULL;

    //
    // Try to add an object in the dynamic container with the above mods.
    // Use a name composed of a random number printed to a string. If the
    // names happen to conflict with another such dummy conference, then
    // try again in a loop.
    //
    // Randomization is apparently per-DLL -- Sdpblb.dll does srand() but
    // it doesn't seem to affect rand() calls within rend.dll. We therefore do
    // srand( time( NULL ) ) on DLL_PROCESS_ATTACH.
    //

    HRESULT   hr;
    int       iRandomNumber;
    TCHAR     ptszRandomNumber[30];
    TCHAR   * pDN = NULL; 

    do
    {
        if ( pDN != NULL )
        {
            delete pDN;
        }

        iRandomNumber = rand();

        wsprintf(ptszRandomNumber, _T("%d"), iRandomNumber);

        hr = CILSDirectory::MakeConferenceDN(ptszRandomNumber, &pDN);

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CILSDirectory::TestACLSafety - "
                "test DN construction failed - exit 0x%08x", hr));

            return hr;
        }

        LOG((MSP_TRACE, "CILSDirectory::TestACLSafety - "
            "trying to create test object DN %S", pDN));

        hr = GetLdapHResultIfFailed( DoLdapAdd(m_ldap, pDN, mods) );
    }
    while ( hr == GetLdapHResultIfFailed( LDAP_ALREADY_EXISTS ) );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CILSDirectory::TestACLSafety - "
            "test addition failed and not duplicate - exit 0x%08x", hr));

        delete pDN;

        return hr;
    }

    //
    // Now that we have the test object, try modifying it.
    //

    LOG((MSP_TRACE, "CILSDirectory::TestACLSafety - "
        "trying to modify test object..."));

    HRESULT hrModify = ::SetTTL( m_ldap, pDN, MINIMUM_TTL );

    //
    // Now delete it. We do this even if we already know that the ACL is bad
    // because the modify failed; we want to get rid of the object if
    // possible.
    //

    LOG((MSP_TRACE, "CILSDirectory::TestACLSafety - "
        "trying to delete test object..."));

    hr = GetLdapHResultIfFailed( DoLdapDelete(m_ldap, pDN) );

    delete pDN;

    //
    // Now determine the verdict and return.
    //

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CILSDirectory::TestACLSafety - "
            "test deletion (+ modification?) failed - ACL unsafe - "
            "exit 0x%08x", hr));

        return hr;
    }

    if ( FAILED( hrModify ) )
    {
        LOG((MSP_ERROR, "CILSDirectory::TestACLSafety - "
            "test deletion ok; test modification failed - ACL unsafe - "
            "exit 0x%08x", hrModify));

        return hrModify;
    }

    LOG((MSP_TRACE, "CILSDirectory::TestACLSafety - exit S_OK"));

    return S_OK;
}


HRESULT CILSDirectory::PublishRTPerson(
    IN TCHAR *  pCN,
    IN TCHAR *  pDN,
    IN TCHAR *  pIPAddress,
    IN DWORD    dwTTL,
    IN BOOL     fModify,
    IN char  *  pSD,
    IN DWORD    dwSDSize
    )
/*++

Routine Description:
    
    Create a RTPerson object in the dynamic container.

Arguments:
    
    pCN - The cn of the user.
    
    pDN - The dn of the user.

    pIPAddress - The ip address of the machine.

    dwTTL - The ttl of this object.

    fModify - modify or add.

Return Value:

    HRESULT.

--*/
{
    // UPDATE THIS whenever you add an explicitly set attribute below
    // (ie, not one of those with default values in the array associated
    // with NUM_NM_RTPERSON_ATTRIBUTES).
    static const DWORD DWCOREATTRIBUTES = 5;

    // Fist create the object.
    LDAPMod     mod[NUM_NM_RTPERSON_ATTRIBUTES + DWCOREATTRIBUTES];
	DWORD		dwCount = 0;

    //
    // We are not allowed to modify the object class. Therefore we only mention
    // this if we are adding the object to the server, not modifying it.
    //

    // Fix: this is allocated on the stack, so we must do it here; if we stick
    // it inside the if below, it gets deallocated immediately.
    TCHAR * objectClass[]   = {(WCHAR *)ILS_RTPERSON, (WCHAR *)DYNAMICOBJECT, NULL}; 

    if ( ! fModify )
    {
        // Object class.
        // only need this attribute if not modifying.
	    mod[dwCount].mod_values       = objectClass;
        mod[dwCount].mod_op           = LDAP_MOD_REPLACE;
        mod[dwCount].mod_type         = (WCHAR *)OBJECTCLASS;
        dwCount ++;
    }

    // IP address.
    TCHAR * IPPhone[]   = {(WCHAR *)pIPAddress, NULL};
    mod[dwCount].mod_values   = IPPhone;
    mod[dwCount].mod_op       = LDAP_MOD_REPLACE;
    mod[dwCount].mod_type     = (WCHAR *)ILS_IPADDRESS;
	dwCount ++;

    //
    // Make pUserName the user portion of the CN (user]machine).
    //

    CTstr pUserName = new TCHAR[ lstrlen(pCN) + 1 ];

    if ( pUserName == NULL )
    {
        return E_OUTOFMEMORY;
    }

    lstrcpy( pUserName, pCN );

    WCHAR * pCloseBracket = wcschr( pUserName, CLOSE_BRACKET_CHARACTER );

    if ( pCloseBracket == NULL )
    {
        // this is not the format generated by us -- very strange indeed!
        return E_UNEXPECTED;
    }

    *pCloseBracket = NULL_CHARACTER;

    //
    // We now have pUserName containing just the user name.
    // No need to delete it explicitly, as it is contained in a smart pointer.
    //

    // email: the user name
    TCHAR * Email[]   = { (WCHAR *) ( (TCHAR *) pUserName ), NULL };

    mod[dwCount].mod_values   = Email;
    mod[dwCount].mod_op       = LDAP_MOD_REPLACE;
    mod[dwCount].mod_type     = (WCHAR *)EMAIL;
	dwCount ++;

    // given name: the same as email (surname is just a space)
    mod[dwCount].mod_values   = Email;
    mod[dwCount].mod_op       = LDAP_MOD_REPLACE;
    mod[dwCount].mod_type     = (WCHAR *)GIVEN_NAME;
	dwCount ++;

	DWORD i;
	for (i = 0; i < NUM_NM_RTPERSON_ATTRIBUTES; i ++)
	{
		mod[dwCount].mod_op     = LDAP_MOD_REPLACE;
		mod[dwCount].mod_type   = (WCHAR *)g_NMRTPersonAttributeNames[i];
		mod[dwCount].mod_values = (WCHAR **)&g_NMRTPersonAttributeValues[i * 2];
		dwCount ++;
	}


    // these locals should not be within the "if" below... if
    // they are, they might be deallocated before the function returns.

    berval  BerVal;
    berval  *sd[] = {&BerVal, NULL};

    // The security descriptor attribute.
    if ((char*)pSD != NULL)
    {
        BerVal.bv_len = dwSDSize;
        BerVal.bv_val = (char*)pSD;

        mod[dwCount].mod_bvalues  = sd;
        mod[dwCount].mod_op       = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
        mod[dwCount].mod_type     = (WCHAR *)NT_SECURITY_DESCRIPTOR;
        dwCount ++;
    }


    LDAPMod* mods[NUM_NM_RTPERSON_ATTRIBUTES + DWCOREATTRIBUTES + 1];
    
    for (i = 0; i < dwCount; i ++)
    {
        mods[i] = &mod[i];
    }
    mods[i] = NULL;

    if (fModify)
    {
        LOG((MSP_INFO, "modifying %S", pDN));

        // Call the modify function to modify the object.
        BAIL_IF_LDAP_FAIL(DoLdapModify(FALSE, m_ldap, pDN, mods), "modify RTPerson");
    }
    else
    {
        LOG((MSP_INFO, "adding %S", pDN));

        // Call the add function to create the object.
        BAIL_IF_LDAP_FAIL(DoLdapAdd(m_ldap, pDN, mods), "add RTPerson");

        // next set the TTL value for this object
        BAIL_IF_FAIL(::SetTTL(m_ldap, pDN, (dwTTL == 0) ? m_TTL : dwTTL),
            "Set ttl for RTPerson");
    }

    return S_OK;
}

HRESULT CILSDirectory::PublishNMPerson(
    IN TCHAR *  pCN,
    IN TCHAR *  pDN,
    IN TCHAR *  pDNRTPerson,
    IN DWORD    dwTTL,
    IN BOOL     fModify,
    IN char  *  pSD,
    IN DWORD    dwSDSize
    )
/*++

Routine Description:
    
    Create a applicationUser object in the netmeeting's container.

Arguments:
    
    pCN - The cn of the user.
    
    pDN - The dn of the applicationUser object.

    pDNRTPerson - The dn of the RTPerson object in the dynamic container.

    dwTTL - The ttl of this object.

    fModify - modify or add.

Return Value:

    HRESULT.

--*/
{
    // UPDATE THIS whenever you add an explicitly set attribute below
    // (ie, not one of those with default values in the array associated
    // with NUM_NM_ATTRIBUTES).
	static const DWORD DWCOREATTRIBUTES = 3;

    // Fist create the object.
    LDAPMod     mod[NUM_NM_ATTRIBUTES + DWCOREATTRIBUTES]; // The modify sturctures used by LDAP

	DWORD dwCount = 0;

    //
    // We are not allowed to modify the object class. Therefore we only mention
    // this if we are adding the object to the server, not modifying it.
    //

    // Fix: this is allocated on the stack, so we must do it here; if we stick
    // it inside the if below, it gets deallocated immediately.
    TCHAR * objectClass[]   = 
        {(WCHAR *)RTAPPLICATIONUSER, (WCHAR *)DYNAMICOBJECT, NULL}; 

    if ( ! fModify )
    {
        // Object class.
        mod[dwCount].mod_values       = objectClass;
        mod[dwCount].mod_op           = LDAP_MOD_REPLACE;
        mod[dwCount].mod_type         = (WCHAR *)OBJECTCLASS;
	    dwCount ++;
    }

    // IP address.
    TCHAR * rtPerson[]   = {(WCHAR *)pDNRTPerson, NULL};
    mod[dwCount].mod_values   = rtPerson;
    mod[dwCount].mod_op       = LDAP_MOD_REPLACE;
    mod[dwCount].mod_type     = (WCHAR *)USEROBJECT;
	dwCount ++;

    for (DWORD i = 0; i < NUM_NM_ATTRIBUTES; i ++)
    {
        mod[dwCount].mod_op       = LDAP_MOD_REPLACE;
        mod[dwCount].mod_type     = (WCHAR *)g_NMAttributeNames[i];
        mod[dwCount].mod_values   = (WCHAR **)&g_NMAttributeValues[i * 2];
		dwCount ++;
    }


    // these locals should not be within the "if" below... if
    // they are, they might be deallocated before the function returns.

    berval  BerVal;
    berval  *sd[] = {&BerVal, NULL};

    // The security descriptor attribute.
    if ((char*)pSD != NULL)
    {
        BerVal.bv_len = dwSDSize;
        BerVal.bv_val = (char*)pSD;

        mod[dwCount].mod_bvalues  = sd;
        mod[dwCount].mod_op       = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
        mod[dwCount].mod_type     = (WCHAR *)NT_SECURITY_DESCRIPTOR;
        dwCount ++;
    }


    LDAPMod* mods[NUM_NM_ATTRIBUTES + DWCOREATTRIBUTES + 1];
    
    for (i = 0; i < dwCount; i ++)
    {
        mods[i] = &mod[i];
    }
    mods[i] = NULL;

    if (fModify)
    {
        LOG((MSP_INFO, "modifying %S", pDN));

        // Call the modify function to modify the object.
        BAIL_IF_LDAP_FAIL(DoLdapModify(FALSE, m_ldap, pDN, mods), "modify NMPerson");
    }
    else
    {
        LOG((MSP_INFO, "adding %S", pDN));

        // Call the add function to create the object.
        BAIL_IF_LDAP_FAIL(DoLdapAdd(m_ldap, pDN, mods), "add NMPerson");

        // next set the TTL value for this object
        BAIL_IF_FAIL(::SetTTL(m_ldap, pDN, (dwTTL == 0) ? m_TTL : dwTTL),
            "Set ttl for NMPerson");
    }

    return S_OK;
}

HRESULT CILSDirectory::AddObjectToRefresh(
    IN  WCHAR *pDN,
    IN  long TTL
    )
{
    //
    // Add a refresh table entry to the refresh table. The refresh table's add
    // method does an element-by-element copy of the entry that it is given.
    // This just copies the string pointer, so we need to allocate and copy
    // the string here.
    //

    RefreshTableEntry entry;

    entry.dwTTL = TTL;

    entry.pDN = new WCHAR[ wcslen(pDN) + 1 ];
    
    if ( entry.pDN == NULL ) 
    {
        LOG((MSP_ERROR, "Cannot allocate string for adding to refresh table"));
        return E_OUTOFMEMORY;
    }

    wcscpy( entry.pDN, pDN );

    //
    // Now add it to the refresh table.
    //

    BOOL fSuccess = m_RefreshTable.add(entry);

    if ( ! fSuccess ) 
    {
        LOG((MSP_ERROR, "Cannot add object to the refresh table"));
        return E_OUTOFMEMORY;
    }
    
    return S_OK;
}

HRESULT CILSDirectory::RemoveObjectToRefresh(
    IN  WCHAR *pDN
    )
{
    //
    // For each item in our refresh table
    //

    for ( DWORD i = 0; i < m_RefreshTable.size(); i++ )
    {
        //
        // If the desired DN matches the one in this item
        // then remove it and return success
        // 

        if ( ! _wcsicmp( m_RefreshTable[i].pDN, pDN ) )
        {
            //
            // We new'ed the string when we added the entry.
            //

            delete m_RefreshTable[i].pDN;

            m_RefreshTable.removeAt(i);
            
            return S_OK;
        }
    }

    //
    // If we get here then there was no matching item
    //

    LOG((MSP_ERROR, "Cannot remove object from the refresh table"));
    return E_FAIL;
}

HRESULT CILSDirectory::AddUser(
    IN  ITDirectoryObject *pDirectoryObject,
    IN  BOOL fModify
    )
/*++

Routine Description:
    
    Publish a new user object.

Arguments:
    
    pDirectoryObject - The object to be published.
    

Return Value:

    HRESULT.

--*/
{
    // First find the interface for attributes.
    CComPtr <ITDirectoryObjectPrivate> pObjectPrivate;

    BAIL_IF_FAIL(
        pDirectoryObject->QueryInterface(
            IID_ITDirectoryObjectPrivate,
            (void **)&pObjectPrivate
            ),
        "can't get the private directory object interface");

    // Get the user name.
    CBstr bName;
    BAIL_IF_FAIL(pDirectoryObject->get_Name(&bName), 
        "get user name");

    // Get the user's machine name.
    CBstr bIPPhone;
    BAIL_IF_FAIL(pObjectPrivate->GetAttribute(UA_IPPHONE_PRIMARY, &bIPPhone), 
        "get IPPhone");

    // Resolve the machine name and construct the CN for the user.
    CTstr pCN;
    DWORD dwIP;

    BAIL_IF_FAIL(
        MakeUserCN(bName, bIPPhone, &pCN, &dwIP), 
        "construct CN for user"
        );

    // Construct the DNs for the RTPerson object and applicationuser object.
    CTstr pDNRTPerson, pDNNMPerson;
    BAIL_IF_FAIL(
        MakeUserDN(pCN, &pDNRTPerson, &pDNNMPerson), 
        "construct DN for user"
        );

    // convert the IP address to a string. 
    // This convertion is because of NetMeeting.
    TCHAR IPAddress[80];
    wsprintf(IPAddress, _T("%u"), dwIP);

    DWORD dwTTL;
    BAIL_IF_FAIL(pObjectPrivate->GetTTL(&dwTTL), "get User TTL");

    // Get the Security Descriptor. The pointer pSD is just a copy of a pointer
    // in the Conference object; the conference object retains ownership of the
    // data and we must be careful not to delete or modify this data.

    char * pSD;
    DWORD dwSDSize;

    BAIL_IF_FAIL(pObjectPrivate->GetConvertedSecurityDescriptor(&pSD, &dwSDSize),
        "get user object security descriptor");

    VARIANT_BOOL fChanged;

    if ( SUCCEEDED( pObjectPrivate->
            get_SecurityDescriptorIsModified( &fChanged ) ) )
    {
        if ( fChanged == VARIANT_FALSE )
        {
            pSD = NULL;   // do NOT delete the string (see above)
            dwSDSize = 0;
        }
    }

    // Create a rtApplicationUser under netmeeting's container. If we are adding
    // and this returns already exists, then bailing is fine.

    BAIL_IF_FAIL(PublishNMPerson(pCN, pDNNMPerson, pDNRTPerson, dwTTL, fModify, pSD, dwSDSize),
        "Can't publish a NMPerson");

    // Create the RTPerson in the dynamic container. According to Sun Shaw,
    // this succeeds even if the object already exists, due to NetMeeting's
    // requirements. (Yet another case of ILS being designed around NM.)
    // We don't depend on the existence of that bug, however.

    HRESULT hr = PublishRTPerson(pCN, pDNRTPerson, IPAddress, dwTTL, fModify, pSD, dwSDSize);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Can't publish a RTPerson, hr:%x", hr));

        if (!fModify)
        {
            // Call the delete function to delete the NMPerson object.
            // This is needed to avoid leaving a phantom NMPerson when
            // the NMPerson creation succeeds but we fail.

            DoLdapDelete(m_ldap, pDNNMPerson);
        }

        return hr;
    }

    if (m_fAutoRefresh)
    {
        AddObjectToRefresh(pDNRTPerson, m_TTL);
        AddObjectToRefresh(pDNNMPerson, m_TTL);
    }
    return S_OK;
}

HRESULT CILSDirectory::DeleteConference(
    IN  ITDirectoryObject *pDirectoryObject
    )
/*++

Routine Description:
    
    Delete a conference from the ILS server.

Arguments:
    
    pDirectoryObject - The object to be deleted.
    
Return Value:

    HRESULT.

--*/
{
    // Get the name.
    CBstr bName;
    BAIL_IF_FAIL(pDirectoryObject->get_Name(&bName), 
        "get conference name");

    // construct the DN
    CTstr pDN;
    BAIL_IF_FAIL(
        MakeConferenceDN(bName, &pDN), "construct DN for conference"
        );

    LOG((MSP_INFO, "deleting %S", pDN));

    // Call the add function to create the object.
    BAIL_IF_LDAP_FAIL(DoLdapDelete(m_ldap, pDN), "delete conference");

    return S_OK;
}

HRESULT CILSDirectory::DeleteUser(
    IN  ITDirectoryObject *pDirectoryObject
    )
/*++

Routine Description:
    
    Delete a user from the ILS server.

Arguments:
    
    pDirectoryObject - The object to be deleted.
    
Return Value:

    HRESULT.

--*/
{
    // First find the interface for attributes.
    CComPtr <ITDirectoryObjectPrivate> pObjectPrivate;

    BAIL_IF_FAIL(
        pDirectoryObject->QueryInterface(
            IID_ITDirectoryObjectPrivate,
            (void **)&pObjectPrivate
            ),
        "can't get the private directory object interface");

    // Get the user name.
    CBstr bName;
    BAIL_IF_FAIL(pDirectoryObject->get_Name(&bName), 
        "get user name");

    // Get the user's machine name.
    CBstr bIPPhone;
    BAIL_IF_FAIL(pObjectPrivate->GetAttribute(UA_IPPHONE_PRIMARY, &bIPPhone), 
        "get IPPhone");

    // Resolve the machine name and construct the CN for the user.
    CTstr pCN;

    BAIL_IF_FAIL(
        MakeUserCN(bName, bIPPhone, &pCN, NULL), 
        "construct CN for user"
        );

    // Construct the DNs for the RTPerson object and applicationuser object.
    CTstr pDNRTPerson, pDNNMPerson;
    BAIL_IF_FAIL(
        MakeUserDN(pCN, &pDNRTPerson, &pDNNMPerson), 
        "construct DN for user"
        );

    //
    // Now delete the TWO objects from the server.
    //

    HRESULT hrFinal = S_OK;
    HRESULT hr;
    ULONG   ulResult;

    // Call the delete function to delete the RTPerson object, but keep
    // going if it fails, noting the error code.

    LOG((MSP_INFO, "deleting %S", pDNRTPerson));
    ulResult = DoLdapDelete(m_ldap, pDNRTPerson);
    hr       = LogAndGetLdapHResult(ulResult, _T("delete RTPerson"));
    if (FAILED(hr)) { hrFinal = hr; }


    // Call the delete function to delete the applicationuser object, but
    // keep going if it fails, noting the error code.

    LOG((MSP_INFO, "deleting %S", pDNNMPerson));
    ulResult = DoLdapDelete(m_ldap, pDNNMPerson);
    hr       = LogAndGetLdapHResult(ulResult, _T("delete NMPerson"));
    if (FAILED(hr)) { hrFinal = hr; }


    // ZoltanS: we now always remove the refresh objects, even if removal failed.
    if (m_fAutoRefresh)
    {
        RemoveObjectToRefresh(pDNRTPerson);
        RemoveObjectToRefresh(pDNNMPerson);
    }

    return hrFinal;
}

HRESULT CILSDirectory::RefreshUser(
    IN  ITDirectoryObject *pDirectoryObject
    )
/*++

Routine Description:
    
    Refresh a user's TTL on the ILS server. 

Arguments:
    
    pDirectoryObject - The object to be refreshed.
    
Return Value:

    HRESULT.

--*/
{
    // First find the interface for attributes.
    CComPtr <ITDirectoryObjectPrivate> pObjectPrivate;

    BAIL_IF_FAIL(
        pDirectoryObject->QueryInterface(
            IID_ITDirectoryObjectPrivate,
            (void **)&pObjectPrivate
            ),
        "can't get the private directory object interface");

    // Get the user name.
    CBstr bName;
    BAIL_IF_FAIL(pDirectoryObject->get_Name(&bName), 
        "get user name");

    // Get the user's machine name.
    CBstr bIPPhone;
    BAIL_IF_FAIL(pObjectPrivate->GetAttribute(UA_IPPHONE_PRIMARY, &bIPPhone), 
        "get IPPhone");

    // Resolve the machine name and construct the CN for the user.
    CTstr pCN;

    BAIL_IF_FAIL(
        MakeUserCN(bName, bIPPhone, &pCN, NULL), 
        "construct CN for user"
        );

    // Construct the DNs for the RTPerson object and applicationuser object.
    CTstr pDNRTPerson, pDNNMPerson;
    BAIL_IF_FAIL(
        MakeUserDN(pCN, &pDNRTPerson, &pDNNMPerson), 
        "construct DN for user"
        );

    // ZoltanS: this is fine; if one of them doesn't exist, then we're in trouble,
    // so return the error.

    // set ttl for the RTPerson object.
    BAIL_IF_LDAP_FAIL(SetTTL(m_ldap, pDNRTPerson, m_TTL), "set ttl for RTPerson");

    // set ttl for the NMPerson object.
    BAIL_IF_LDAP_FAIL(SetTTL(m_ldap, pDNNMPerson, m_TTL), "set ttl for NMPerson");

    //
    // ZoltanS: If the app has enabled auto-refresh but does not add or modify its
    // user object, but rather, just refreshes it (because the object is still around
    // from a previous instance of the app, and "add" would fail), we still need to
    // autorefresh it, as that's what the app wants.
    //

    if (m_fAutoRefresh)
    {
        AddObjectToRefresh(pDNRTPerson, m_TTL);
        AddObjectToRefresh(pDNNMPerson, m_TTL);
    }

    return S_OK;
}

HRESULT CILSDirectory::CreateConference(
    IN  LDAPMessage *           pEntry,
    OUT ITDirectoryObject **    ppObject
    )
/*++

Routine Description:
    
    Create a conference object from the result of the LDAP search.

Arguments:
    
    pEntry  - The search result.

    ppObject - The object to be created.
    
Return Value:

    HRESULT.

--*/
{
    CBstr bName, bProtocol, bBlob;

    // Get the name of the conference.
    BAIL_IF_FAIL(
        ::GetAttributeValue(
            m_ldap,
            pEntry,
            RTConferenceAttributeName(MA_MEETINGNAME), 
            &bName
            ),
        "get the conference name"
        );

    // Get the protocol ID of the conference.
    BAIL_IF_FAIL(
        ::GetAttributeValue(
            m_ldap,
            pEntry, 
            RTConferenceAttributeName(MA_PROTOCOL), 
            &bProtocol
            ),
        "get the conference protocol"
        );

    // Get the conference blob of the conference.
    BAIL_IF_FAIL(
        ::GetAttributeValue(
            m_ldap,
            pEntry, 
            RTConferenceAttributeName(MA_CONFERENCE_BLOB),
            &bBlob
            ),
        "get the conference blob"
        );

    char * pSD = NULL;
    DWORD dwSDSize = 0;

    ::GetAttributeValueBer(
        m_ldap,
        pEntry, 
        NT_SECURITY_DESCRIPTOR,
        &pSD,
        &dwSDSize
        );

    // Create an empty conference.
    
    HRESULT hr = ::CreateConferenceWithBlob(bName,
                                            bProtocol,
                                            bBlob,
                                            pSD,
                                            dwSDSize,
                                            ppObject);
    
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CILSDirectory::CreateConference - "
            "CreateConferenceWithBlob failed 0x%08x", hr));

        delete pSD;

        return hr;
    }

    //
    // If the above succeeded then the conference object has taken ownership
    // of pSD.
    //

    return S_OK;
    
}

HRESULT CILSDirectory::CreateUser(
    IN  LDAPMessage *   pEntry,
    IN  ITDirectoryObject ** ppObject
    )
/*++

Routine Description:
    
    Create a user object from the result of the LDAP search.

Arguments:
    
    pEntry  - The search result.

    ppObject - The object to be created.
    
Return Value:

    HRESULT.

--*/
{
    CBstr bName;
    // Get the name of the user.
    BAIL_IF_FAIL(
        ::GetAttributeValue(
            m_ldap,
            pEntry, 
            RTPersonAttributeName(UA_USERNAME),
            &bName
            ),
        "get the user name"
        );


    CBstr bAddress;

    // Grab the machine name from the name of the object. This can fail if
    // we didn't publish the object (ie, it's a NetMeeting object). Also,
    // check if the hostname isn't resolvable. In that case we also have
    // to fall back on the IP address in the ipAddress attribute.

    HRESULT hr;
    
    hr = ParseUserName(bName, &bAddress);

    if ( SUCCEEDED(hr) )
    {
        // Make sure we can get an IP from this name, at least for the moment.
        // If not, release the name and indicate failure so we do our backup
        // plan.

        hr = ResolveHostName(0, bAddress, NULL, NULL);

        if ( FAILED(hr) )
        {
            SysFreeString(bAddress);    
        }
    }
    

    if ( FAILED(hr) )
    {
        // In order to compatible with NetMeeting, we have to use IP address field.
        CBstr bUglyIP;
        BAIL_IF_FAIL(
            ::GetAttributeValue(
                m_ldap,
                pEntry, 
                RTPersonAttributeName(UA_IPPHONE_PRIMARY),
                &bUglyIP
                ),
            "get the user's IP address"
            );

        // We have to use NM's ugly format for the IP address. The IP address 
        // we got from netmeeting is a decimal string whose value is the dword 
        // value of the IP address in network order.
        BAIL_IF_FAIL(UglyIPtoIP(bUglyIP, &bAddress), "Convert IP address");
    }

    // Create an empty user object.
    CComPtr<ITDirectoryObject> pObject;
    BAIL_IF_FAIL(::CreateEmptyUser(bName, &pObject), "CreateEmptyUser");


    CComPtr <ITDirectoryObjectPrivate> pObjectPrivate;

    BAIL_IF_FAIL(
        pObject->QueryInterface(
            IID_ITDirectoryObjectPrivate,
            (void **)&pObjectPrivate
            ),
        "can't get the private directory object interface");

    // Set the user attributes.
    BAIL_IF_FAIL(pObjectPrivate->SetAttribute(UA_IPPHONE_PRIMARY, bAddress),
        "set ipAddress");



    //
    // Set the security descriptor on the object.
    //

    char * pSD = NULL;
    DWORD dwSDSize = 0;

    ::GetAttributeValueBer(
        m_ldap,
        pEntry, 
        NT_SECURITY_DESCRIPTOR,
        &pSD,
        &dwSDSize
        );

    if ( pSD != NULL )
    {
        //
        // Set the security descriptor in its "converted" (server) form.
        //

        hr = pObjectPrivate->PutConvertedSecurityDescriptor(pSD,
                                                            dwSDSize);

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "PutConvertedSecurityDescriptor failed: %x", hr));
            return hr;
        }
    }

    *ppObject = pObject;
    (*ppObject)->AddRef();

    return S_OK;
}

HRESULT CILSDirectory::SearchObjects(
    IN  DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
    IN  BSTR                    pName,
    OUT ITDirectoryObject ***   pppDirectoryObject,
    OUT DWORD *                 pdwSize
    )
/*++

Routine Description:
    
    Search the ILS server for given type of objects.

Arguments:
    
    DirectoryObjectType - The type of the object.

    pName   - The name to search for.

    pppDirectoryObject - The returned array of objects.

    pdwSize - The size of the array.
    
Return Value:

    HRESULT.

--*/
{
    TCHAR *pRDN;
    TCHAR *Attributes[NUM_MEETING_ATTRIBUTES + 1]; // This is big enough now.

    // Fill the attributes want to be returned.
    switch (DirectoryObjectType)
    {
    case OT_CONFERENCE:

        pRDN = (WCHAR*)ILS_UIDEQUALS;
        Attributes[0] = (WCHAR *)RTConferenceAttributeName(MA_MEETINGNAME);
        Attributes[1] = (WCHAR *)RTConferenceAttributeName(MA_PROTOCOL);
        Attributes[2] = (WCHAR *)RTConferenceAttributeName(MA_CONFERENCE_BLOB);
        Attributes[3] = (WCHAR *)NT_SECURITY_DESCRIPTOR;
        Attributes[4] = NULL;

        break;

    case OT_USER:

        pRDN = (WCHAR*)CNEQUALS;
        Attributes[0] = (WCHAR *)RTPersonAttributeName(UA_USERNAME);
        Attributes[1] = (WCHAR *)RTPersonAttributeName(UA_IPPHONE_PRIMARY);
        Attributes[2] = (WCHAR *)NT_SECURITY_DESCRIPTOR;
        Attributes[3] = NULL;
        
        break;

    default:
        return E_FAIL;
    }

    // Construct the filter of the search.
    int cbRDN = lstrlen(pRDN);
    int cbName = lstrlen(pName);
    if( (( cbRDN + cbName + 2)<= cbRDN) ||
        ((cbRDN + cbName + 2) <= cbName) )
    {
        return E_FAIL;
    }

    CTstr pFilter = new TCHAR [cbRDN + cbName + 2];

    BAIL_IF_NULL((TCHAR*)pFilter, E_OUTOFMEMORY);

    lstrcpyn(pFilter, pRDN, cbRDN+1);
    _ASSERTE( lstrlen(pFilter) == cbRDN );
    lstrcpyn(pFilter+cbRDN, pName, cbName+1);
    _ASSERTE( lstrlen(pFilter) == cbRDN+cbName );
    if (pName[lstrlen(pName) - 1] != _T('*'))
    {
        lstrcat(pFilter, _T("*"));
    }

    // Search them.
    CLdapMsgPtr pLdapMsg; // auto release message.

    ULONG res = DoLdapSearch(
        m_ldap,              // ldap handle
        m_pContainer,        // schema dn
        LDAP_SCOPE_ONELEVEL, // one level search
        pFilter,             // cn=Name or uid=Name
        Attributes,          // array of attribute names
        FALSE,               // return the attribute values
        &pLdapMsg            // search results
        );

    BAIL_IF_LDAP_FAIL(res, "search for objects");

    // count the returned entries.
    DWORD dwEntries = ldap_count_entries(m_ldap, pLdapMsg);
    ITDirectoryObject ** pObjects = new PDIRECTORYOBJECT [dwEntries];

    BAIL_IF_NULL(pObjects, E_OUTOFMEMORY);

    // Create objects.
    DWORD dwCount = 0;
    LDAPMessage *pEntry = ldap_first_entry(m_ldap, pLdapMsg);
    
    while (pEntry != NULL)
    {
        HRESULT hr;
        
        switch (DirectoryObjectType)
        {
        case OT_CONFERENCE:
            hr = CreateConference(pEntry, &pObjects[dwCount]);
            break;
        case OT_USER:
            hr = CreateUser(pEntry, &pObjects[dwCount]);
            break;
        }

        if (SUCCEEDED(hr)) 
        {
            dwCount ++;
        }
          
        // Get next entry.
        pEntry = ldap_next_entry(m_ldap, pEntry);
    }

    *pppDirectoryObject = pObjects;
    *pdwSize = dwCount;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// ILS Directory implementation
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CILSDirectory::get_DirectoryType (
    OUT DIRECTORY_TYPE *  pDirectoryType
    )
// Get the type of the directory.
{
    if ( IsBadWritePtr(pDirectoryType, sizeof(DIRECTORY_TYPE) ) )
    {
        LOG((MSP_ERROR, "Directory.GetType, invalid pointer"));
        return E_POINTER;
    }

    CLock Lock(m_lock);

    *pDirectoryType = m_Type;

    return S_OK;
}

STDMETHODIMP CILSDirectory::get_DisplayName (
    OUT BSTR *ppServerName
    )
// Get the display name of the directory.
{
    BAIL_IF_BAD_WRITE_PTR(ppServerName, E_POINTER);

    CLock Lock(m_lock);

    if (m_pServerName == NULL)
    {
        *ppServerName = SysAllocString(L"");
    }
    else
    {
        *ppServerName = SysAllocString(m_pServerName);
    }

    if (*ppServerName == NULL)
    {
        LOG((MSP_ERROR, "get_DisplayName: out of memory."));
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

STDMETHODIMP CILSDirectory::get_IsDynamic(
    OUT VARIANT_BOOL *pfDynamic
    )
// find out if the directory is a dynamic one, meaning the object will be
// deleted after TTL runs out.
{
    if ( IsBadWritePtr( pfDynamic, sizeof(VARIANT_BOOL) ) )
    {
        LOG((MSP_ERROR, "Directory.get_IsDynamic, invalid pointer"));
        return E_POINTER;
    }

    *pfDynamic = VARIANT_TRUE;
    
    return S_OK;
}

STDMETHODIMP CILSDirectory::get_DefaultObjectTTL(
    OUT long *pTTL        // in seconds
    )
// The default TTL for object created. It is used when the object doesn't set
// a TTL. Conference object always has a TTL based on the stoptime.
{
    if ( IsBadWritePtr( pTTL, sizeof(long) ) )
    {
        LOG((MSP_ERROR, "Directory.get_default objec TTL, invalid pointer"));
        return E_POINTER;
    }

    CLock Lock(m_lock);

    *pTTL = m_TTL;
    
    return S_OK;
}

STDMETHODIMP CILSDirectory::put_DefaultObjectTTL(
    IN  long TTL          // in sechods
    )
// Change the default TTL, must be bigger then five minutes.
{
    CLock Lock(m_lock);

    if (TTL < MINIMUM_TTL)
    {
        return E_INVALIDARG;
    }

    m_TTL = TTL;
    
    return S_OK;
}

STDMETHODIMP CILSDirectory::EnableAutoRefresh(
    IN  VARIANT_BOOL fEnable
    )
// Enable auto refresh. Add this directory to the work threads that
// will notify the directory to update its objects.
{
    HRESULT hr;

    // ZoltanS: either VARIANT_TRUE or TRUE will work
    // in case the caller doesn't know better

    if (fEnable)
    {
        // Add this directory to the notify list of the work thread.
        if (FAILED(hr = g_RendThread.AddDirectory(this)))
        {
            LOG((MSP_ERROR, 
                "Can not add this directory to the thread, %x", hr));
            return hr;
        }
    }
    else
    {
        // Remove this directory from the notify list of the work thread.
        if (FAILED(hr = g_RendThread.RemoveDirectory(this)))
        {
            LOG((MSP_ERROR, 
                "Can not remove this directory from the thread, %x", hr));
            return hr;
        }
    }

    // ZoltanS: either VARIANT_TRUE or TRUE will work
    // in case the caller doesn't know better

    m_lock.Lock();
    m_fAutoRefresh = ( fEnable ? VARIANT_TRUE : VARIANT_FALSE );
    m_lock.Unlock();

    return S_OK;
}

STDMETHODIMP CILSDirectory::Connect(
    IN  VARIANT_BOOL fSecure
    )
// Connect to the server, using secure port or normal port.
{
    CLock Lock(m_lock);

    if (m_ldap != NULL)
    {
        LOG((MSP_ERROR, "already connected."));
        return RND_ALREADY_CONNECTED;
    }

    if (m_pServerName == NULL)
    {
        LOG((MSP_ERROR, "No server specified."));
        return RND_NULL_SERVER_NAME;
    }

    // ZoltanS: either VARIANT_TRUE or TRUE will work
    // in case the caller doesn't know better

    if (fSecure)
    {
        // the port is flipped from regular port to ssl port.
        m_wPort = GetOtherPort(m_wPort);
        m_IsSsl = TRUE;
    }


    HRESULT hr = TryServer(m_wPort);

    // We support legacy servers by also trying the normal LDAP port if
    // the normal ILS port fails. If the user specified a special port,
    // then we don't do anything behind their back!

    if ( FAILED(hr) && (hr != E_OUTOFMEMORY) && (m_wPort == ILS_PORT))
    {
        m_wPort = LDAP_PORT;
        hr = TryServer(m_wPort);
    }

    if ( SUCCEEDED(hr) )
    {
        // find out which interface we use to reach this server, to make sure
        // we use that interface whenever we publish our own IP address
        // If this fails we will not be able to publish anything, so fail!

        hr = DiscoverInterface();
    }

    if( FAILED(hr))
    {
        if( m_ldap)
        {
            ldap_unbind(m_ldap);
            m_ldap = NULL;
        }

        if( fSecure == VARIANT_TRUE )
        {
            hr = E_INVALIDARG;
        }
    }

    return hr;
}

HRESULT CILSDirectory::DiscoverInterface(void)
{
    LOG((MSP_INFO, "CILSDirectory::DiscoverInterface - enter"));

    //
    // Winsock must be initialized at this point.
    //

    //
    // Get the IP address of the server we're using
    //

    DWORD dwIP; // The IP address of the destination ILS server

    HRESULT hr = ResolveHostName(0, m_pServerName, NULL, &dwIP);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CILSDirectory::DiscoverInterface - "
            "can't resolve host name - "
            "strange, because we could connect! - exit 0x%08x", hr));

        return hr;
    }

    //
    // allocate a "fake" control socket
    //

    SOCKET hSocket = WSASocket(AF_INET,            // af
                              SOCK_DGRAM,         // type
                              IPPROTO_IP,         // protocol
                              NULL,               // lpProtocolInfo
                              0,                  // g
                              0                   // dwFlags
                              );

    if ( hSocket == INVALID_SOCKET )
    {
        hr = HRESULT_FROM_ERROR_CODE(WSAGetLastError());

        LOG((MSP_ERROR, "CILSDirectory::DiscoverInterface - "
            "WSASocket gave an invalid socket - exit 0x%08x", hr));

        return hr;
    }

    //
    // Query for the interface address based on destination.
    //

    SOCKADDR_IN DestAddr;
    DestAddr.sin_family         = AF_INET;
    DestAddr.sin_port           = 0;
    DestAddr.sin_addr.s_addr    = dwIP;

    SOCKADDR_IN LocAddr;

    DWORD dwStatus;
    DWORD dwLocAddrSize = sizeof(SOCKADDR_IN);
    DWORD dwNumBytesReturned = 0;

    dwStatus = WSAIoctl(
            hSocket,                     // SOCKET s
            SIO_ROUTING_INTERFACE_QUERY, // DWORD dwIoControlCode
            &DestAddr,                   // LPVOID lpvInBuffer
            sizeof(SOCKADDR_IN),         // DWORD cbInBuffer
            &LocAddr,                    // LPVOID lpvOUTBuffer
            dwLocAddrSize,               // DWORD cbOUTBuffer
            &dwNumBytesReturned,         // LPDWORD lpcbBytesReturned
            NULL,                        // LPWSAOVERLAPPED lpOverlapped
            NULL                         // LPWSAOVERLAPPED_COMPLETION_ROUTINE lpComplROUTINE
            );

    //
    // Don't close the socket yet, because the closesocket() call will
    // overwrite the WSAGetLastError value in the failure case!
    //
    // Check for error and then close the socket.
    //

    if ( dwStatus == SOCKET_ERROR )
    {
	    hr = HRESULT_FROM_ERROR_CODE(WSAGetLastError());

        LOG((MSP_ERROR, "CILSDirectory::DiscoverInterface - "
            "WSAIoctl failed - exit 0x%08x", hr));

        closesocket(hSocket);

        return hr;
    } 

    closesocket(hSocket);

    //
    // Success - save the returned address in our member variable.
    // Stored in network byte order.
    //

    m_dwInterfaceAddress = LocAddr.sin_addr.s_addr;

    LOG((MSP_INFO, "CILSDirectory::DiscoverInterface - exit S_OK"));
    return S_OK;
}


//
// ITDirectory::Bind
//
// Bind to the server.
//
// Currently recognized flags:
//
//    RENDBIND_AUTHENTICATE       0x00000001
//    RENDBIND_DEFAULTDOMAINNAME  0x00000002
//    RENDBIND_DEFAULTUSERNAME    0x00000004
//    RENDBIND_DEFAULTPASSWORD    0x00000008
//
// "Meta-flags" for convenience:
//    RENDBIND_DEFAULTCREDENTIALS 0x0000000e
//
//
// All of this together means that the following three
// forms are all equivalent:
//
// BSTR es = SysAllocString(L"");
// hr = pITDirectory->Bind(es, es, es, RENDBIND_AUTHENTICATE |
//                                     RENDBIND_DEFAULTCREDENTIALS);
// SysFreeString(es);
//
//
// BSTR es = SysAllocString(L"");
// hr = pITDirectory->Bind(es, es, es, RENDBIND_AUTHENTICATE      |
//                                     RENDBIND_DEFAULTDOMAINNAME |
//                                     RENDBIND_DEFAULTUSERNAME   |
//                                     RENDBIND_DEFAULTPASSWORD);
// SysFreeString(es);
//
//
// hr = pITDirectory->Bind(NULL, NULL, NULL, RENDBIND_AUTHENTICATE);
//
//

STDMETHODIMP CILSDirectory::Bind (
    IN  BSTR pDomainName,
    IN  BSTR pUserName,
    IN  BSTR pPassword,
    IN  long lFlags
    )
{
    LOG((MSP_TRACE, "CILSDirectory Bind - enter"));

    //
    // Determine if we should authenticate.
    //

    BOOL fAuthenticate = FALSE;

    if ( lFlags & RENDBIND_AUTHENTICATE )
    {
        fAuthenticate = TRUE;
    }

    //
    // For scripting compatibility, force string parameters to NULL based
    // on flags.
    //

    if ( lFlags & RENDBIND_DEFAULTDOMAINNAME )
    {
        pDomainName = NULL;
    }
       
    if ( lFlags & RENDBIND_DEFAULTUSERNAME )
    {
        pUserName = NULL;
    }

    if ( lFlags & RENDBIND_DEFAULTPASSWORD )
    {
        pPassword = NULL;
    }

    LOG((MSP_INFO, "Bind parameters: domain: `%S' user: `%S' "
                  "authenticate: %S)",
        (pDomainName)   ? pDomainName : L"<null>",
        (pUserName)     ? pUserName   : L"<null>",
        (fAuthenticate) ? L"yes"      : L"no"));

    //
    // All flags processed -- lock and proceed with bind if connected.
    //

    CLock Lock(m_lock);

    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "not connected."));
        return RND_NOT_CONNECTED;
    }

    //
    // ZoltanS: check the arguments. NULL has meaning in each case, so they are
    // OK for now. In each case we want to check any length string, so we
    // specify (UINT) -1 as the length.
    //

    if ( (pDomainName != NULL) && IsBadStringPtr(pDomainName, (UINT) -1 ) )
    {
        LOG((MSP_ERROR, "CNTDirectory::Bind: bad non-NULL pDomainName argument"));
        return E_POINTER;
    }
    
    if ( (pUserName != NULL) && IsBadStringPtr(pUserName, (UINT) -1 ) )
    {
        LOG((MSP_ERROR, "CNTDirectory::Bind: bad non-NULL pUserName argument"));
        return E_POINTER;
    }

    if ( (pPassword != NULL) && IsBadStringPtr(pPassword, (UINT) -1 ) )
    {
        LOG((MSP_ERROR, "CNTDirectory::Bind: bad non-NULL pPassword argument"));
        return E_POINTER;
    }

    ULONG res;

    if ( m_IsSsl || (!fAuthenticate) )
    {
        // if encrypted or no secure authentication is required,
        // simple bind is sufficient

        // ldap_simple_bind_s does not use sspi to get default credentials. We are
        // just specifying what we will actually pass on the wire.

        if (pPassword == NULL)
        {
            LOG((MSP_ERROR, "invalid Bind parameters: no password specified"));
            return E_INVALIDARG;
        }

        WCHAR * wszFullName;

        if ( (pDomainName == NULL) && (pUserName == NULL) )
        {
            // No domain / user doesn't make sense.
            LOG((MSP_ERROR, "invalid Bind paramters: domain and user not specified"));
            return E_INVALIDARG;
        }
        else if (pDomainName == NULL)
        {
            // username only is okay
            wszFullName = pUserName;
        }
        else if (pUserName == NULL)
        {
            // It doesn't make sense to specify domain but not user...
            LOG((MSP_ERROR, "invalid Bind paramters: domain specified but not user"));
            return E_INVALIDARG;
        }
        else
        {
            // We need domain\user. Allocate a string and sprintf into it.
            // The + 2 is for the "\" and for the null termination.

            wszFullName = new WCHAR[wcslen(pDomainName) + wcslen(pUserName) + 2];
            BAIL_IF_NULL(wszFullName, E_OUTOFMEMORY);
        
            wsprintf(wszFullName, L"%s\\%s", pDomainName, pUserName);
        }

        //
        // Do the simple bind.
        //

        res = ldap_simple_bind_s(m_ldap, wszFullName, pPassword);

        //
        // If we constructed the full name string, we now need to delete it.
        //

        if (wszFullName != pUserName)
        {
            delete wszFullName;
        }

        //
        // Bail if the simple bind failed.
        //

        BAIL_IF_LDAP_FAIL(res, "ldap simple bind");
    }
    else    // try an SSPI bind
    {
        // if the domain name, user name or the password is non-null
        if ( pDomainName || pUserName || pPassword )
        {
            // fill the credential structure
            SEC_WINNT_AUTH_IDENTITY AuthI;

            AuthI.User = (PTCHAR)pUserName;
            AuthI.UserLength = (pUserName == NULL)? 0: wcslen(pUserName);
            AuthI.Domain = (PTCHAR)pDomainName;
            AuthI.DomainLength = (pDomainName == NULL)? 0: wcslen(pDomainName);
            AuthI.Password = (PTCHAR)pPassword;
            AuthI.PasswordLength = (pPassword == NULL)? 0: wcslen(pPassword);
            AuthI.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

            res = ldap_bind_s(m_ldap, NULL, (TCHAR*)(&AuthI), LDAP_AUTH_NTLM);

            BAIL_IF_LDAP_FAIL(res, "bind with authtication");
        }
        else
        {
            // Otherwise we've come in with NULL, NULL, NULL - 
            // pass in NULL, NULL. The reason do this is that ldap bind code
            // does not process NULL, NULL, NULL in the
            // SEC_WINNT_AUTH_IDENTITY blob !!!
            ULONG res = ldap_bind_s(m_ldap, NULL, NULL, LDAP_AUTH_NTLM);

            BAIL_IF_LDAP_FAIL(res, "bind with NULL NULL NULL");
        }
    }

    LOG((MSP_TRACE, "CILSDirectory::Bind - exiting OK"));
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// ITDirectory::AddDirectoryObject
//
// Return values:
//      Value               Where defined       What it means
//      -----               -------------       -------------
//      RND_NOT_CONNECTED   .\rnderr.h          ::Connect not yet called
//      E_POINTER           sdk\inc\winerror.h  pDirectoryObject is a bad pointer
//      other from AddConference
//      other from AddUser
//

STDMETHODIMP CILSDirectory::AddDirectoryObject (
    IN  ITDirectoryObject *pDirectoryObject
    )
// publish a new object to the server.
{
    if ( IsBadReadPtr(pDirectoryObject, sizeof(ITDirectoryObject) ) )
    {
        LOG((MSP_ERROR, "CILSDirectory::AddDirectoryObject - "
            "bad directory object pointer - returning E_POINTER"));

        return E_POINTER;
    }

    CLock Lock(m_lock);
    
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "CILSDirectory::AddDirectoryObject - not connected."));

        return RND_NOT_CONNECTED;
    }

    HRESULT hr;
    DIRECTORY_OBJECT_TYPE type;

    hr = pDirectoryObject->get_ObjectType(&type);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CILSDirectory::AddDirectoryObject - "
            "can't get object type; returning 0x%08x", hr));

        return hr;
    }

    switch (type)
    {
    case OT_CONFERENCE:
        hr = AddConference(pDirectoryObject, FALSE);
        break;

    case OT_USER:
        hr = AddUser(pDirectoryObject, FALSE);
        break;
    }
    return hr;
}

STDMETHODIMP CILSDirectory::ModifyDirectoryObject (
    IN  ITDirectoryObject *pDirectoryObject
    )
// modify an object on the server.
{
    if ( IsBadReadPtr(pDirectoryObject, sizeof(ITDirectoryObject) ) )
    {
        LOG((MSP_ERROR, "CILSDirectory::ModifyDirectoryObject - "
            "bad directory object pointer - returning E_POINTER"));

        return E_POINTER;
    }

    CLock Lock(m_lock);
    
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "CILSDirectory::ModifyDirectoryObject - not connected."));

        return RND_NOT_CONNECTED;
    }

    HRESULT hr;
    DIRECTORY_OBJECT_TYPE type;

    hr = pDirectoryObject->get_ObjectType(&type);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CILSDirectory::ModifyDirectoryObject - "
            "can't get object type; returning 0x%08x", hr));

        return hr;
    }

    switch (type)
    {
    case OT_CONFERENCE:
        hr = AddConference(pDirectoryObject, TRUE);
        break;

    case OT_USER:
        hr = AddUser(pDirectoryObject, TRUE);
        break;
    }
    return hr;
}

STDMETHODIMP CILSDirectory::RefreshDirectoryObject (
    IN  ITDirectoryObject *pDirectoryObject
    )
// Refresh the TTL for the object and add the object to the refresh list
// if the autorefresh is enabled.
{
    if ( IsBadReadPtr(pDirectoryObject, sizeof(ITDirectoryObject) ) )
    {
        LOG((MSP_ERROR, "CILSDirectory::RefreshDirectoryObject - "
            "bad directory object pointer - returning E_POINTER"));

        return E_POINTER;
    }

    CLock Lock(m_lock);
    
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "CILSDirectory::RefreshDirectoryObject - not connected."));

        return RND_NOT_CONNECTED;
    }

    HRESULT hr;
    DIRECTORY_OBJECT_TYPE type;

    hr = pDirectoryObject->get_ObjectType(&type);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CILSDirectory::RefreshDirectoryObject - "
            "can't get object type; returning 0x%08x", hr));

        return hr;
    }

    switch (type)
    {
    case OT_CONFERENCE:
        return S_OK;  // conferences do not need refresh.

    case OT_USER:
        hr = RefreshUser(pDirectoryObject);
        break;
    }
    return hr;
}

STDMETHODIMP CILSDirectory::DeleteDirectoryObject (
    IN  ITDirectoryObject *pDirectoryObject
    )
// delete an object on the server.
{
    if ( IsBadReadPtr(pDirectoryObject, sizeof(ITDirectoryObject) ) )
    {
        LOG((MSP_ERROR, "CILSDirectory::DeleteDirectoryObject - "
            "bad directory object pointer - returning E_POINTER"));

        return E_POINTER;
    }

    CLock Lock(m_lock);
    
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "CILSDirectory::DeleteDirectoryObject - not connected."));

        return RND_NOT_CONNECTED;
    }

    HRESULT hr;
    DIRECTORY_OBJECT_TYPE type;

    hr = pDirectoryObject->get_ObjectType(&type);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CILSDirectory::DeleteDirectoryObject - "
            "can't get object type; returning 0x%08x", hr));

        return hr;
    }

    switch (type)
    {
    case OT_CONFERENCE:
        hr = DeleteConference(pDirectoryObject);
        break;

    case OT_USER:
        hr = DeleteUser(pDirectoryObject);
        break;
    }
    return hr;
}

STDMETHODIMP CILSDirectory::get_DirectoryObjects (
    IN  DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
    IN  BSTR                    pName,
    OUT VARIANT *               pVariant
    )
// search for objects on the server.
{
    BAIL_IF_BAD_READ_PTR(pName, E_POINTER);
    BAIL_IF_BAD_WRITE_PTR(pVariant, E_POINTER);

    CLock Lock(m_lock);
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "not connected."));
        return RND_NOT_CONNECTED;
    }

    HRESULT hr;

    ITDirectoryObject **pObjects;
    DWORD dwSize;
    
    // search and create objects.
    hr = SearchObjects(DirectoryObjectType, pName, &pObjects, &dwSize);
    BAIL_IF_FAIL(hr, "Search for objects");

    // create a collection object that contains the objects.
    hr = CreateInterfaceCollection(dwSize,            // count
                                   &pObjects[0],      // begin ptr
                                   &pObjects[dwSize], // end ptr
                                   pVariant);         // return value

    for (DWORD i = 0; i < dwSize; i ++)
    {
        pObjects[i]->Release();
    }

    delete pObjects;

    BAIL_IF_FAIL(hr, "Create collection of directory objects");

    return hr;
}

STDMETHODIMP CILSDirectory::EnumerateDirectoryObjects (
    IN  DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
    IN  BSTR                    pName,
    OUT IEnumDirectoryObject ** ppEnumObject
    )
// search for the objects on the server.
{
    BAIL_IF_BAD_READ_PTR(pName, E_POINTER);
    BAIL_IF_BAD_WRITE_PTR(ppEnumObject, E_POINTER);

    CLock Lock(m_lock);
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "not connected."));
        return RND_NOT_CONNECTED;
    }

    HRESULT hr;

    ITDirectoryObject **pObjects;
    DWORD dwSize;
    
    // search and create objects.
    hr = SearchObjects(DirectoryObjectType, pName, &pObjects, &dwSize);
    BAIL_IF_FAIL(hr, "Search for objects");

    // create a enumerator object that contains the objects.
    hr = ::CreateDirectoryObjectEnumerator(
        &pObjects[0],
        &pObjects[dwSize],
        ppEnumObject
        );

    for (DWORD i = 0; i < dwSize; i ++)
    {
        pObjects[i]->Release();
    }

    delete pObjects;

    BAIL_IF_FAIL(hr, "Create enumerator of directory objects");

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// ILSConfig implementation
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CILSDirectory::get_Port (
    OUT long *pPort
    )
// get the current port used in Ldap connection.
{
    if ( IsBadWritePtr(pPort, sizeof(long) ) )
    {
        LOG((MSP_ERROR, "Directory.get_Port, invalid pointer"));
    
        return E_POINTER;
    }

    CLock Lock(m_lock);

    *pPort = (long)m_wPort;

    return S_OK;
}

STDMETHODIMP CILSDirectory::put_Port (
    IN  long   Port
    )
// set the port the user wants to use.
{
    CLock Lock(m_lock);
    
    if (m_ldap != NULL)
    {
        LOG((MSP_ERROR, "already connected."));
        return RND_ALREADY_CONNECTED;
    }

    if (Port <= USHRT_MAX)
    {
        m_wPort = (WORD)Port;
        return S_OK;
    }
    return E_INVALIDARG;
}

/////////////////////////////////////////////////////////////////////////////
// ITDynamic interface
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CILSDirectory::Update(DWORD dwSecondsPassed)
// Update the TTL for object created in this directory. The worker thread
// sends a tick every minute.
{
    if ( ! m_lock.TryLock() )
    {
        return S_OK;
    }

    LOG((MSP_TRACE, "CILSDirectory::Update is called, delta: %d", dwSecondsPassed));

    //
    // Go through the table to see if anyone needs refresh.
    //

    for ( DWORD i = 0; i < m_RefreshTable.size(); i++ )
    {
        WCHAR * pDN   = m_RefreshTable[i].pDN;
        DWORD   dwTTL = m_RefreshTable[i].dwTTL;

        LOG((MSP_TRACE, "\tExamining user object: %S", pDN   ));
        LOG((MSP_TRACE, "\t\tTime remaining: %d",      dwTTL ));

        if ( dwTTL <= ( 2 * dwSecondsPassed ) )
        {
            //
            // refresh it if the TTL is going to expire within the next
            // two clicks
            //
        
            LOG((MSP_TRACE, "\t\t\tREFRESHING"));

            if ( SUCCEEDED( SetTTL( m_ldap, pDN, m_TTL) ) )
            {
                m_RefreshTable[i].dwTTL = m_TTL;
            }
            else
            {
                LOG((MSP_WARN, "\t\t\t\tRefresh failed; will try again next time"));
            }
        }
        else
        {
            //
            // Not about to expire right now so just keep track of the time before
            // it expires
            //

            LOG((MSP_TRACE, "\t\t\tdecrementing"));

            m_RefreshTable[i].dwTTL -= dwSecondsPassed;
        }
    }

    m_lock.Unlock();

    LOG((MSP_TRACE, "CILSDirectory::Update exit S_OK"));

    return S_OK;
}

typedef IDispatchImpl<ITDirectoryVtbl<CILSDirectory>, &IID_ITDirectory, &LIBID_RENDLib>    CTDirectory;
typedef IDispatchImpl<ITILSConfigVtbl<CILSDirectory>, &IID_ITILSConfig, &LIBID_RENDLib>    CTILSConfig;
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CILSDirectory::GetIDsOfNames
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP CILSDirectory::GetIDsOfNames(REFIID riid,
                                      LPOLESTR* rgszNames, 
                                      UINT cNames, 
                                      LCID lcid, 
                                      DISPID* rgdispid
                                      ) 
{ 
    LOG((MSP_TRACE, "CILSDirectory::GetIDsOfNames[%p] - enter. Name [%S]",this, *rgszNames));


    HRESULT hr = DISP_E_UNKNOWNNAME;



    //
    // See if the requsted method belongs to the default interface
    //

    hr = CTDirectory::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((MSP_TRACE, "CILSDirectory::GetIDsOfNames - found %S on CTDirectory", *rgszNames));
        rgdispid[0] |= IDISPDIRECTORY;
        return hr;
    }

    
    //
    // If not, then try the ITILSConfig base class
    //

    hr = CTILSConfig::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((MSP_TRACE, "CILSDirectory::GetIDsOfNames - found %S on CTILSConfig", *rgszNames));
        rgdispid[0] |= IDISPILSCONFIG;
        return hr;
    }

    LOG((MSP_ERROR, "CILSDirectory::GetIDsOfNames[%p] - finish. didn't find %S on our iterfaces",*rgszNames));

    return hr; 
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CILSDirectory::Invoke
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP CILSDirectory::Invoke(DISPID dispidMember, 
                              REFIID riid, 
                              LCID lcid, 
                              WORD wFlags, 
                              DISPPARAMS* pdispparams, 
                              VARIANT* pvarResult, 
                              EXCEPINFO* pexcepinfo, 
                              UINT* puArgErr
                             )
{
    LOG((MSP_TRACE, "CILSDirectory::Invoke[%p] - enter. dispidMember %lx",this, dispidMember));

    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    DWORD   dwInterface = (dispidMember & INTERFACEMASK);
   
   
    //
    // Call invoke for the required interface
    //

    switch (dwInterface)
    {
        case IDISPDIRECTORY:
        {
            hr = CTDirectory::Invoke(dispidMember, 
                                    riid, 
                                    lcid, 
                                    wFlags, 
                                    pdispparams,
                                    pvarResult, 
                                    pexcepinfo, 
                                    puArgErr
                                   );
        
            LOG((MSP_TRACE, "CILSDirectory::Invoke - ITDirectory"));

            break;
        }

        case IDISPILSCONFIG:
        {
            hr = CTILSConfig::Invoke(dispidMember, 
                                        riid, 
                                        lcid, 
                                        wFlags, 
                                        pdispparams,
                                        pvarResult, 
                                        pexcepinfo, 
                                        puArgErr
                                       );

            LOG((MSP_TRACE, "CILSDirectory::Invoke - ITILSConfig"));

            break;
        }

    } // end switch (dwInterface)

    
    LOG((MSP_TRACE, "CILSDirectory::Invoke[%p] - finish. hr = %lx", hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndils.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    rndils.h

Abstract:

    Definitions for CILSDirectory class that handles ILS access.

--*/

#ifndef __RNDILS_H
#define __RNDILS_H

#pragma once

#include "thread.h"
#include "rndobjsf.h"

//
// Some constants.
//

const WCHAR ILS_IPADDRESS[]            = L"ipAddress";
const WCHAR ILS_UIDEQUALS[]            = L"uid=";
const WCHAR ILS_CONF_DN_FORMAT[]       = L"uid=%s,%s";
const WCHAR ILS_RTCONFERENCE[]         = L"RTConference";
const WCHAR ILS_RTPERSON[]             = L"RTPerson";
const WCHAR NETMEETING_CONTAINER[]     = L"appName=MS-NetMeeting,ou=applications,";
const WCHAR RTAPPLICATIONUSER[]        = L"RTApplicationUser";
const WCHAR EMAIL[]                    = L"rfc822mailbox";
const WCHAR GIVEN_NAME[]               = L"givenName"; // vocabulary word: this means "first name"

/////////////////////////////////////////////////////////////////////////////
//  CILSDirectory
/////////////////////////////////////////////////////////////////////////////

template <class T>
class  ITDirectoryVtbl : public ITDirectory
{
};

template <class T>
class  ITILSConfigVtbl : public ITILSConfig
{
};


class CILSDirectory :
    public CComDualImpl<ITDirectoryVtbl<CILSDirectory>, &IID_ITDirectory, &LIBID_RENDLib>, 
    public CComDualImpl<ITILSConfigVtbl<CILSDirectory>, &IID_ITILSConfig, &LIBID_RENDLib>, 
    public ITDynamicDirectory,
    public CComObjectRootEx<CComObjectThreadModel>,
    public CObjectSafeImpl
{

/* ZoltanS debugging... */
private:
    HRESULT AddConferenceComplete(BOOL       fModify,
                                  LDAP     * ldap,
                                  TCHAR   ** ppDN,
                                  LDAPMod ** mods,
                                  DWORD      TTL1,
                                  DWORD      TTL2);

public:

    BEGIN_COM_MAP(CILSDirectory)
        COM_INTERFACE_ENTRY2(IDispatch, ITDirectory)
        COM_INTERFACE_ENTRY(ITILSConfig)
        COM_INTERFACE_ENTRY(ITDirectory)
        COM_INTERFACE_ENTRY(ITDynamicDirectory)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CILSDirectory) 
    DECLARE_GET_CONTROLLING_UNKNOWN()

public:

// ITILSConfig
    STDMETHOD (get_Port) (
        OUT  long *Port
        );

    STDMETHOD (put_Port) (
        IN  long Port
        );

// ITDirectory
    STDMETHOD (get_DirectoryType) (
        OUT DIRECTORY_TYPE *  pDirectoryType
        );

    STDMETHOD (get_DisplayName) (
        OUT BSTR *ppName
        );

    STDMETHOD (get_IsDynamic) (
        OUT VARIANT_BOOL *pfDynamic
        );

    STDMETHOD (get_DefaultObjectTTL) (
        OUT long *pTTL   // in seconds
        );

    STDMETHOD (put_DefaultObjectTTL) (
        IN  long TTL     // in sechods
        );

    STDMETHOD (EnableAutoRefresh) (
        IN  VARIANT_BOOL fEnable
        );

    STDMETHOD (Connect)(
        IN  VARIANT_BOOL fSecure
        );

    STDMETHOD (Bind) (
        IN  BSTR pDomainName,
        IN  BSTR pUserName,
        IN  BSTR pPassword,
        IN  long lFlags
        );

    STDMETHOD (AddDirectoryObject) (
        IN  ITDirectoryObject *pDirectoryObject
        );

    STDMETHOD (ModifyDirectoryObject) (
        IN  ITDirectoryObject *pDirectoryObject
        );

    STDMETHOD (RefreshDirectoryObject) (
        IN  ITDirectoryObject *pDirectoryObject
        );

    STDMETHOD (DeleteDirectoryObject) (
        IN  ITDirectoryObject *pDirectoryObject
        );

    STDMETHOD (get_DirectoryObjects) (
        IN  DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
        IN  BSTR                    pName,
        OUT VARIANT *               pVariant
        );

    STDMETHOD (EnumerateDirectoryObjects) (
        IN  DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
        IN  BSTR                    pName,
        OUT IEnumDirectoryObject ** ppEnumObject
        );

    //
    // IDispatch  methods
    //

    STDMETHOD(GetIDsOfNames)(REFIID riid, 
                             LPOLESTR* rgszNames,
                             UINT cNames, 
                             LCID lcid, 
                             DISPID* rgdispid
                            );

    STDMETHOD(Invoke)(DISPID dispidMember, 
                      REFIID riid, 
                      LCID lcid,
                      WORD wFlags, 
                      DISPPARAMS* pdispparams, 
                      VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, 
                      UINT* puArgErr
                      );


// ITDynamicDirectory
    STDMETHOD(Update)(DWORD dwSecondsPassed);

public:
    CILSDirectory()
        : m_Type(DT_ILS),
          m_pServerName(NULL),
          m_ldap(NULL),
          m_pContainer(NULL),
          m_pNMContainer(NULL),
          m_IsSsl(FALSE),
          m_TTL(ILS_UPDATE_INTERVAL),
          m_fAutoRefresh(FALSE),
          m_dwInterfaceAddress(0),
          m_pFTM(NULL)
    {}

    virtual HRESULT FinalConstruct(void);

    ~CILSDirectory()
    {
        if ( m_pFTM )
        {
            m_pFTM->Release();
        }

        if (m_ldap)
        {
            ldap_unbind(m_ldap);
        }

        delete m_pServerName;
        delete m_pContainer;
        delete m_pNMContainer;

        //
        // We new'ed the DN strings in the refresh table. The destructor for
        // the table will be called after this destructor and will delete
        // the array itself.
        //

        for ( DWORD i = 0; i < m_RefreshTable.size(); i++ )
        {
            delete m_RefreshTable[i].pDN;
        }
    }

    HRESULT Init(
        IN const TCHAR * const  strServerName,
        IN const WORD           wPort
        );

    static const WCHAR * RTConferenceAttributeName(int attribute)
    { return s_RTConferenceAttributes[MeetingAttrIndex(attribute)]; }

    static const WCHAR * RTPersonAttributeName(int attribute)
    { return s_RTPersonAttributes[UserAttrIndex(attribute)]; }

private:

    HRESULT TryServer(
        IN  WORD    Port
        );

    HRESULT MakeConferenceDN(
        IN  TCHAR *             pName,
        OUT TCHAR **            ppDN
        );

    HRESULT MakeUserCN(
        IN  TCHAR *     pName,
        IN  TCHAR *     pAddress,
        OUT TCHAR **    ppCN,
        OUT DWORD *     pdwIP
        );

    HRESULT MakeUserDN(
        IN  TCHAR *     pCN,
        OUT TCHAR **    ppDNRTPerson,
        OUT TCHAR **    ppDNNMPerson
        );

    HRESULT PublishRTPerson(
        IN TCHAR *  pCN,
        IN TCHAR *  pDN,
        IN TCHAR *  pIPAddress,
        IN DWORD    dwTTL,
        IN  BOOL fModify,
        IN char *   pSD,
        IN DWORD    dwSDSize
        );

    HRESULT PublishNMPerson(
        IN TCHAR *  pCN,
        IN TCHAR *  pDN,
        IN TCHAR *  pDNRTPerson,
        IN DWORD    dwTTL,
        IN BOOL     fModify,
        IN char *   pSD,
        IN DWORD    dwSDSize
        );

    HRESULT AddConference(
        IN  ITDirectoryObject *pDirectoryObject,
        IN  BOOL fModify
        );

    HRESULT TestAclSafety(
        IN  char  * pSD,
        IN  DWORD   dwSDSize
        );

    HRESULT AddUser(
        IN  ITDirectoryObject *pDirectoryObject,
        IN  BOOL fModify
        );

    HRESULT DeleteConference(
        IN  ITDirectoryObject *pDirectoryObject
        );

    HRESULT DeleteUser(
        IN  ITDirectoryObject *pDirectoryObject
        );

    HRESULT RefreshUser(
        IN  ITDirectoryObject *pDirectoryObject
        );

    HRESULT CreateConference(
        IN  LDAPMessage *           pEntry,
        OUT ITDirectoryObject **    ppObject
        );

    HRESULT CreateUser(
        IN  LDAPMessage *           pEntry,
        IN  ITDirectoryObject **    ppObject
        );

    HRESULT SearchObjects(
        IN  DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
        IN  BSTR                    pName,
        OUT ITDirectoryObject ***   pppDirectoryObject,
        OUT DWORD *                 dwSize
        );

    HRESULT AddObjectToRefresh(
        IN  WCHAR *pDN,
        IN  long TTL
        );

    HRESULT RemoveObjectToRefresh(
        IN  WCHAR *pDN
        );

    HRESULT DiscoverInterface(void);

private:
    static const WCHAR * const s_RTConferenceAttributes[];
    static const WCHAR * const s_RTPersonAttributes[];

    CCritSection    m_lock;

    DIRECTORY_TYPE  m_Type;
    TCHAR *         m_pServerName;
    WORD            m_wPort;

    LDAP *          m_ldap;
    TCHAR *         m_pContainer;
    TCHAR *         m_pNMContainer;
    BOOL            m_IsSsl;

    long            m_TTL;
    BOOL            m_fAutoRefresh;
    RefreshTable    m_RefreshTable;

    // the local IP we should use when publishing on this server
    // Stored in network byte order.
    DWORD           m_dwInterfaceAddress; 

    IUnknown      * m_pFTM;          // pointer to the free threaded marshaler
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndilslk.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    rndilslk.cpp

Abstract:

    This module contains code to look up ILS in NTDS.


--*/

#include "stdafx.h"
#include <initguid.h>

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global constants                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// {C9F17940-79A7-11d1-B008-00C04FC31FEE}
DEFINE_GUID(CLSID_ILSServicClass, 
0xc9f17940, 0x79a7, 0x11d1, 0xb0, 0x8, 0x0, 0xc0, 0x4f, 0xc3, 0x1f, 0xee);

#define BUFFSIZE                3000

int LookupILSServiceBegin(
    HANDLE *    pHandle
    )
/*++

Routine Description:

    Begin ILS service enumeration.

Arguments:
    
    pHandle - the handle of the enumerator.

Return Value:

    Wisock error codes.
--*/
{
    WSAVERSION          Version;
    AFPROTOCOLS         lpAfpProtocols[1];
    WSAQUERYSET Query;

    if (IsBadWritePtr(pHandle, sizeof(HANDLE *)))
    {
        return ERROR_INVALID_PARAMETER;
    }

    ZeroMemory(&Query, sizeof(WSAQUERYSET));

    Query.dwNumberOfProtocols = 1;
    lpAfpProtocols[0].iAddressFamily = AF_INET;
    lpAfpProtocols[0].iProtocol = PF_INET;
    
    Query.lpafpProtocols = lpAfpProtocols;

    Query.lpszServiceInstanceName = L"*";
    Query.dwNameSpace = NS_NTDS;
    Query.dwSize = sizeof(Query);
    Query.lpServiceClassId = (GUID *)&CLSID_ILSServicClass;

    if (WSALookupServiceBegin(
            &Query,
            LUP_RETURN_ALL,
            pHandle ) == SOCKET_ERROR )
    {
        return WSAGetLastError();
    }
    return NOERROR;
}

int LookupILSServiceNext(
    HANDLE      Handle,
    TCHAR *     pBuf,
    DWORD *     pdwBufSize,
    WORD *      pwPort
    )
/*++

Routine Description:

    look up the next ILS server.

Arguments:
    
    Handle       - The handle of the enumeration.

    pBuf         - A pointer to a buffer of TCHARs that will store the DNS
                   name of the ILS server.

    pdwBufSize   - The size of the buffer.

    pwPort       - The port that the ILS server is using.

Return Value:

    Wisock error codes.
--*/
{
    TCHAR            buffer[BUFFSIZE];
    DWORD            dwSize = BUFFSIZE;
    LPWSAQUERYSET    lpResult = (LPWSAQUERYSET)buffer;
    LPCSADDR_INFO    lpCSAddrInfo;
    LPSOCKADDR       lpSocketAddress;

    if (WSALookupServiceNext(Handle, 0, &dwSize, lpResult) == SOCKET_ERROR)
    {
        return WSAGetLastError();
    }

    lpCSAddrInfo = lpResult->lpcsaBuffer;
    if (IsBadReadPtr(lpCSAddrInfo, sizeof(CSADDR_INFO)))
    {
        return ERROR_BAD_FORMAT;
    }

    lpSocketAddress = lpCSAddrInfo->RemoteAddr.lpSockaddr;
    if (IsBadReadPtr(lpSocketAddress, sizeof(SOCKADDR)))
    {
        return ERROR_BAD_FORMAT;
    }
    *pwPort  = ((struct sockaddr_in*) lpSocketAddress->sa_data)->sin_port;

    lstrcpyn(pBuf, lpResult->lpszServiceInstanceName, *pdwBufSize);

    *pdwBufSize = lstrlen(pBuf);

    return NOERROR;
}

int LookupILSServiceEnd(
    HANDLE      Handle
    )
/*++

Routine Description:

    Finish the ils service enumerator.

Arguments:
    
    Handle - the handle of the enumerator.

Return Value:

    Wisock error codes.
--*/
{
    if (WSALookupServiceEnd(Handle) == SOCKET_ERROR)
    {
        return WSAGetLastError();
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndldap.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    rndldap.h

Abstract:

    Some ldap definitions and functions.

--*/

//
// Some constants.
//

#ifndef __RNDLDAP_H_
#define __RNDLDAP_H_

#pragma once

#include "rndcommc.h"

const WCHAR DYNAMIC_USER_CN_FORMAT[]   = L"%s]%hs";
const WCHAR DYNAMIC_USER_DN_FORMAT[]   = L"cn=%s,%s";
const WCHAR DYNAMIC_CONTAINER[]        = L"ou=dynamic,";
const WCHAR DYNAMICOBJECT[]            = L"DynamicObject";
const WCHAR OBJECTCLASS[]              = L"ObjectClass";
const WCHAR USEROBJECT[]               = L"userObject";
const WCHAR NT_SECURITY_DESCRIPTOR[]   = L"ntSecurityDescriptor";
const WCHAR AT_CHARACTER               = L'@';
const WCHAR ANY_OBJECT_CLASS[]         = L"ObjectClass=*";
const WCHAR DEFAULT_NAMING_CONTEXT[]   = L"defaultNamingContext";
const WCHAR CNEQUALS[]                 = L"cn=";
const WCHAR ENTRYTTL[]                 = L"EntryTTL";
const WCHAR CLOSE_BRACKET_CHARACTER    = L']';
const WCHAR NULL_CHARACTER             = L'\0';

// decimal values for the following ports
const   WORD    ILS_PORT        = 1002;
const   WORD    ILS_SSL_PORT    = 637; // ZoltanS changed from 4999

const   WORD    MINIMUM_TTL     = 300;
const   DWORD   REND_LDAP_TIMELIMIT = 60; // 60 seconds

/////////////////////////////////////////////////////////////////////////////
// CLdapPtr is a smart pointer for a ldap connection.
/////////////////////////////////////////////////////////////////////////////
class CLdapPtr
{
public:
    CLdapPtr() : m_hLdap(NULL) {}
    CLdapPtr(LDAP *hLdap) : m_hLdap(hLdap) {}
    ~CLdapPtr() { if (m_hLdap) ldap_unbind(m_hLdap);}

    CLdapPtr &operator= (LDAP *hLdap)   { m_hLdap = hLdap; return *this;}
    operator LDAP* ()                   { return m_hLdap; }

private:
    LDAP   *m_hLdap;
};

/////////////////////////////////////////////////////////////////////////////
// CLdapMsgPtr is a smart pointer for a ldap message.
/////////////////////////////////////////////////////////////////////////////
class CLdapMsgPtr
{
public:
    CLdapMsgPtr() : m_pLdapMsg(NULL) {}
    CLdapMsgPtr(IN LDAPMessage *LdapMessage) : m_pLdapMsg(LdapMessage) {}
    ~CLdapMsgPtr() { ldap_msgfree(m_pLdapMsg); }

    LDAPMessage **operator& ()  { return &m_pLdapMsg; }
    operator LDAPMessage * ()   { return m_pLdapMsg; }
    CLdapMsgPtr& operator=(LDAPMessage *p) { m_pLdapMsg = p; return *this; }

private:
    LDAPMessage *m_pLdapMsg;
};

/////////////////////////////////////////////////////////////////////////////
// CLdapValuePtr is a smart pointer for a ldap value.
/////////////////////////////////////////////////////////////////////////////
class CLdapValuePtr
{
public:
    CLdapValuePtr(IN  TCHAR   **Value) : m_Value(Value) {}
    ~CLdapValuePtr() { ldap_value_free(m_Value); }

protected:
    TCHAR   **m_Value;
};


/////////////////////////////////////////////////////////////////////////////
// other functions
/////////////////////////////////////////////////////////////////////////////

inline HRESULT
HResultFromErrorCodeWithoutLogging(IN long ErrorCode)
{
    return ( 0x80070000 | (0xa000ffff & ErrorCode) );
}

inline HRESULT
GetLdapHResult(
    IN  ULONG   LdapResult
    )
{
    return HRESULT_FROM_ERROR_CODE((long)LdapMapErrorToWin32(LdapResult));
}

inline BOOL
CompareLdapHResult(
    IN      HRESULT hr,
    IN      ULONG   LdapErrorCode
    )
{
    return ( hr == GetLdapHResult(LdapErrorCode));
}

#define BAIL_IF_LDAP_FAIL(Result, msg)    \
{                                       \
    ULONG _res_ = Result;                 \
    if ( LDAP_SUCCESS != _res_ )          \
    {                                   \
        LOG((MSP_ERROR, "%S - %d:%S", msg, _res_, ldap_err2string(_res_)));\
        return GetLdapHResult(_res_);     \
    }                                   \
}

// ZoltanS: For when we want to note an LDAP error and find the HR, but not bail.
inline HRESULT
LogAndGetLdapHResult(ULONG Result, TCHAR * msg)
{
    BAIL_IF_LDAP_FAIL(Result, msg);
    return S_OK;
}

// ZoltanS: For when we want to find the HR, but not bail or log
inline HRESULT
GetLdapHResultIfFailed(ULONG Result)
{
    if ( Result != LDAP_SUCCESS )
    {
        return HResultFromErrorCodeWithoutLogging(
            (long) LdapMapErrorToWin32( Result ) );
    }

    return S_OK;
}


inline WORD
GetOtherPort(IN  WORD   CurrentPort)
{
    switch (CurrentPort)
    {
    case LDAP_PORT:     return LDAP_SSL_PORT;
    case LDAP_SSL_PORT: return LDAP_PORT;
    case ILS_PORT:      return ILS_SSL_PORT;
    case ILS_SSL_PORT:  return ILS_PORT;
    }

    // We don't support SSL unless the server is using a well-known
    // non-SSL port. Basically we would otherwise have to also publish
    // SSL ports in the DS in addition to non-SSL ports.

    _ASSERTE(FALSE);
    return CurrentPort; // was LDAP_PORT
}

HRESULT GetAttributeValue(
    IN  LDAP *          pLdap,
    IN  LDAPMessage *   pEntry,
    IN  const WCHAR *   pName,
    OUT BSTR *          pValue
    );

HRESULT GetAttributeValueBer(
    IN  LDAP *          pLdap,
    IN  LDAPMessage *   pEntry,
    IN  const WCHAR *   pName,
    OUT char **         pValue,
    OUT DWORD *         pdwSize
    );

HRESULT GetNamingContext(
    LDAP *hLdap, 
    TCHAR **ppNamingContext
    );

ULONG
DoLdapSearch (
        LDAP            *ld,
        PWCHAR          base,
        ULONG           scope,
        PWCHAR          filter,
        PWCHAR          attrs[],
        ULONG           attrsonly,
        LDAPMessage     **res,
        BOOL		    bSACL = TRUE
        );

ULONG 
DoLdapAdd (
           LDAP *ld,
           PWCHAR dn,
           LDAPModW *attrs[]
          );

ULONG 
DoLdapModify (
              BOOL fChase,
              LDAP *ld,
              PWCHAR dn,
              LDAPModW *attrs[],
              BOOL		    bSACL = TRUE
             );

ULONG 
DoLdapDelete (
           LDAP *ld,
           PWCHAR dn
          );

HRESULT SetTTL(
    IN LDAP *   pLdap, 
    IN const WCHAR *  pDN, 
    IN DWORD    dwTTL
    );

HRESULT UglyIPtoIP(
    BSTR    pUglyIP,
    BSTR *  pIP
    );
    
HRESULT ParseUserName(
    BSTR    pName,
    BSTR *  ppAddress
    );


#endif // __RNDLDAP_H_

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndndnc.cpp ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    rndndnc.cpp

Abstract:

    Implementation for CNDNCDirectory class that handles
    Non-Domain NC (Whistler ILS) access.

--*/

#include "stdafx.h"
#include <limits.h>
#include <ntdsapi.h>

#include "rndcommc.h"
#include "rndndnc.h"
#include "rndldap.h"
#include "rndcnf.h"
#include "rndcoll.h"

//
// These are the names of the attributes in the schema.
//

const WCHAR * const CNDNCDirectory::s_RTConferenceAttributes[] = 
{
    L"advertisingScope",      // not used for NDNCs
    L"msTAPI-ConferenceBlob",
    L"generalDescription",    // not used for NDNCs
    L"isEncrypted",           // not used for NDNCs
    L"msTAPI-uid",
    L"originator",            // not used for NDNCs
    L"msTAPI-ProtocolId",
    L"startTime",
    L"stopTime",
    L"subType",               // not used for NDNCs
    L"URL"                    // not used for NDNCs
};

const WCHAR * const CNDNCDirectory::s_RTPersonAttributes[] = 
{
    L"cn",
    L"telephoneNumber",       // not used for NDNCs
    L"msTAPI-IpAddress",
    L"msTAPI-uid"
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HRESULT CNDNCDirectory::FinalConstruct(void)
{
    LOG((MSP_TRACE, "CNDNCDirectory::FinalConstruct - enter"));

    HRESULT hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                & m_pFTM );

    if ( FAILED(hr) )
    {
        LOG((MSP_INFO, "CNDNCDirectory::FinalConstruct - "
            "create FTM returned 0x%08x; exit", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CNDNCDirectory::FinalConstruct - exit S_OK"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// private functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// CrackDnsName()
// private helper method
//
// This method converts a string from DNS format to DC format. This method
// allocates the output string using "new" and the caller
// is responsible for freeing the output string using "delete".
//
// input example:  "ntdsdc3.ntdev.microsoft.com"
// output example: "DC=ntdsdc3,DC=ntdev,DC=microsoft,DC=com"
//

HRESULT CNDNCDirectory::CrackDnsName(
    IN  WCHAR  * pDnsName,
    OUT WCHAR ** ppDcName
    )
{
    LOG((MSP_INFO, "CrackDnsName: enter"));

    _ASSERTE( ! IsBadStringPtr( pDnsName, (UINT) -1 ) );
    _ASSERTE( ! IsBadWritePtr( pDnsName, sizeof(WCHAR *) ) );

    //
    // Construct a copy of the DNS name with a slash ('/') appended to it.
    //

    WCHAR          * pCanonicalDnsName;

    pCanonicalDnsName = new WCHAR[lstrlenW(pDnsName) + 2];

    if ( pCanonicalDnsName == NULL )
    {
        LOG((MSP_ERROR, "CrackDnsName: "
                "cannot allocate canonical DNS name - "
                "exit E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    wsprintf(pCanonicalDnsName, L"%s/", pDnsName);

    //
    // Call DsCrackNames to do the conversion.
    // Afterwards, we no longer need the intermediate string.
    //

    LOG((MSP_INFO, "CrackDnsName: "
            "Attempting to crack server name: \"%S\"",
            pCanonicalDnsName));

    DWORD            dwRet;
    DS_NAME_RESULT * pdsNameRes;

    dwRet = DsCrackNamesW(
        NULL,                          // no old bind handle
        DS_NAME_FLAG_SYNTACTICAL_ONLY, // flag: please do locally
        DS_CANONICAL_NAME,             // have dns name
        DS_FQDN_1779_NAME,             // want dn
        1,                             // how many to convert
        &pCanonicalDnsName,            // the name to convert
        &pdsNameRes                    // result of conversion
        );

    delete pCanonicalDnsName;

    //
    // Check if the conversion succeeded.
    //

    if ( dwRet != ERROR_SUCCESS )
    {
        HRESULT hr = HRESULT_FROM_ERROR_CODE( dwRet );
    
        LOG((MSP_ERROR, "CrackDnsName: "
                "DsCrackNames returned 0x%08x; exit 0x%08x", dwRet, hr));

        return hr;
    }

    if ((pdsNameRes->cItems < 1) ||
        (pdsNameRes->rItems == NULL) ||
        (pdsNameRes->rItems[0].status != DS_NAME_NO_ERROR))
    {
        DsFreeNameResult( pdsNameRes );

        LOG((MSP_ERROR, "CrackDnsName: "
                "DsCrackNames succeeded but did not return data; "
                "exit E_FAIL"));

        return E_FAIL;
    }

    //
    // Succeeded; return the resulting string and free the name result.
    //

    *ppDcName = new WCHAR [ lstrlenW( pdsNameRes->rItems[0].pName ) + 1];

    if ( (*ppDcName) == NULL )
    {
        DsFreeNameResult( pdsNameRes );

        LOG((MSP_ERROR, "CrackDnsName: "
                "failed to allocate result string - "
                "exit E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    lstrcpyW( *ppDcName, pdsNameRes->rItems[0].pName );

    DsFreeNameResult( pdsNameRes );
    
    LOG((MSP_INFO, "CrackDnsName: "
            "DsCrackNames returned %S; exit S_OK",
            *ppDcName));

    return S_OK;
}

HRESULT CNDNCDirectory::NDNCSetTTL(
    IN LDAP        * pLdap, 
    IN const WCHAR * pDN, 
    IN DWORD         dwTTL
    )
/*++

Routine Description:

    This function sets the TTL on a dynamic object, while enforcing
    the maximum settable TTL for NDNCs.

Arguments:
    
    pLdap - Pointer to the LDAP connection structure.
    pDN   - Pointer to a wide-character string specifying the DN of the object
            to be mofified.
    dwTTL - The TTL to set, in seconds.

Return Value:

    HRESULT.

--*/
{
    if ( dwTTL > NDNC_MAX_TTL )
    {
        dwTTL = NDNC_MAX_TTL;
    }

    return ::SetTTL(pLdap, pDN, dwTTL);
}

HRESULT CNDNCDirectory::Init(
    IN const TCHAR * const  strServerName,
    IN const WORD           wPort
    )
/*++

Routine Description:

    Initialize this object, specifying the server name and port to use.
    This method fails if there is no default TAPI NDNC on this server.

Arguments:
    
    strServerName   - The NDNC server name.

    wPort     - The port number.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CNDNCDirectory::Init - enter"));
    
    if ( strServerName != NULL )
    {
        //
        // Set the server name.
        //

        int cbServerName = lstrlen(strServerName);
        if( (cbServerName+1) <= cbServerName )
        {
            return E_FAIL;
        }

        m_pServerName = new TCHAR [cbServerName + 1];

        if (m_pServerName == NULL)
        {
            LOG((MSP_ERROR, "CNDNCDirectory::Init - "
                    "could not allocate server name - "
                    "exit E_OUTOFMEMORY"));
                    
            return E_OUTOFMEMORY;
        }

        // Copy also with null terminator
        lstrcpyn(m_pServerName, strServerName, cbServerName+1);
        _ASSERTE( lstrlen(m_pServerName)== cbServerName );

        //
        // Look around on the server and find out where the NDNC
        // is. This will fail if there is no NDNC. It sets
        // m_pServiceDnsName, which is then used on Connect.
        //

        HRESULT hr = GetNDNCLocationFromServer( m_pServerName );

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CNDNCDirectory::Init - "
                    "GetNDNCLocationFromServer failed - "
                    "exit 0x%08x", hr));
                    
            return hr;
        }
    }

    m_wPort = wPort;

    LOG((MSP_TRACE, "CNDNCDirectory::Init - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CNDNCDirectory::GetNDNCLocationFromServer
// private helper method
//
// Look around on a server and discover the default TAPI NDNC. The resulting
// location is saved in m_pServiceDnsName which is then used on Connect
// to go to the right place on the server.
//
// Parameters:
//  pDcServerDnsName - the DNS name that can be used to connect to the
//                     desired DC server machine.
//
// Returns: HRESULT
//

HRESULT CNDNCDirectory::GetNDNCLocationFromServer(
    IN WCHAR * pDcServerDnsName
    )
{
    LOG((MSP_INFO, "CNDNCDirectory::GetNDNCLocationFromServer - "
            "enter"));

    //
    // Connect to the DC whose name we were given.
    // NOTE pDcServerDnsName can be NULL, and that's ok --
    // it means go to the nearest DC.
    //

    HRESULT hr;

    LDAP * hLdap;

    hr = OpenLdapConnection(
        pDcServerDnsName,
        LDAP_PORT,
        & hLdap
        );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::GetNDNCLocationFromServer - "
                "OpenLdapConnection failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // Bind. Without bindwe cannot discover the SCP
    //
    ULONG res = ldap_bind_s(hLdap, NULL, NULL, LDAP_AUTH_NEGOTIATE);
    if( LDAP_SUCCESS != res )
    {
        ldap_unbind( hLdap );

        LOG((MSP_ERROR, "CNDNCDirectory::GetNDNCLocationFromServer - "
                "init BIND failed - exit %d", res));
        return GetLdapHResult(res);
    }

    //
    // Find the DN for this DC's domain.
    //

    WCHAR * pDomainDN;

    hr = GetNamingContext(
        hLdap,
        &pDomainDN
        );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::GetNDNCLocationFromServer - "
                "GetNamingContext failed - exit 0x%08x", hr));

        ldap_unbind( hLdap );
        return hr;
    }

    //
    // Search for the service connection point object telling us the
    // DNS name of the service we care about.
    //
    // First, construct the search location string. This consists of a well-known
    // prefix prepended to the DN obtained above.
    //

    WCHAR * pSearchLocation = new WCHAR[
                                    lstrlenW(NDNC_SERVICE_PUBLICATION_LOCATION) +
                                    lstrlenW( pDomainDN ) + 1];

    if ( pSearchLocation == NULL )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::GetNDNCLocationFromServer - "
                "canot allocate search location string - "
                "exit E_OUTOFMEMORY"));

        ldap_unbind( hLdap );
        delete pDomainDN;
        return E_OUTOFMEMORY;
    }

    wsprintf(pSearchLocation, L"%s%s", NDNC_SERVICE_PUBLICATION_LOCATION, pDomainDN);

    delete pDomainDN;

    //
    // Now do the actual search.
    //

    LDAPMessage * pSearchResult;
    PTCHAR        Attributes[] = {
                                   (WCHAR *) SERVICE_DNS_NAME_ATTRIBUTE,
                                   NULL
                                 };
    
    res = DoLdapSearch (
        hLdap,                        // handle to connection structure
        pSearchLocation,              // where to search
        LDAP_SCOPE_BASE,              // scope of the search
        (WCHAR *) ANY_OBJECT_CLASS,   // filter
        Attributes,                   // array of attribute names
        FALSE,                        // also return the attribute values
        &pSearchResult                // search results
        );

    hr = GetLdapHResultIfFailed( res );

    delete pSearchLocation;
    
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::GetNDNCLocationFromServer - "
                "connection point search failed - exit 0x%08x", hr));

        ldap_unbind( hLdap );

        return hr;
    }

    //
    // Parse search results and get the value of serviceDnsName.
    //
    // Step 1: Get the first object in the result set.
    // Note: Result of ldap_first_entry must not be explicitly freed.
    // Note: We ignore objects past the first one, which is fine because
    //       we did a base-level search on just the object that we need.
    //
    
    LDAPMessage * pEntry;
    
    pEntry = ldap_first_entry(
        hLdap,
        pSearchResult
        );

    if ( pEntry == NULL )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::GetNDNCLocationFromServer - "
                "failed to get first entry in search result - "
                "exit E_FAIL"));

        ldap_msgfree( pSearchResult );
        ldap_unbind( hLdap );

        return E_FAIL;
    }

    //
    // Step 2: Get the values of the desired attribute for the object.
    // 
    // Some attributes are multivalued so we get back an array of strings.
    // We only look at the first value returned for the serviceDnsName
    // attribute.
    //

    WCHAR       ** ppServiceDnsName;

    ppServiceDnsName = ldap_get_values(
        hLdap, 
        pEntry, 
        (WCHAR *) SERVICE_DNS_NAME_ATTRIBUTE
        );

    ldap_unbind( hLdap );

    ldap_msgfree( pSearchResult );

    if ( ( ppServiceDnsName == NULL ) || ( ppServiceDnsName[0] == NULL ) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::GetNDNCLocationFromServer - "
                "failed to get name from search result - "
                "exit E_FAIL"));

        return E_FAIL;
    }

    //
    // Set the service DNS name as a member variable with a nicer format.
    // When the app calls ITDirectory::Connect, we will try the real
    // connection, and during that process we will use this to determine
    // what container we go to for accessing the NDNC.
    //

    m_pServiceDnsName = new WCHAR [ lstrlenW(ppServiceDnsName[0]) + 1];

    if ( m_pServiceDnsName == NULL )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::GetNDNCLocationFromServer - "
                "failed to allocate service DNS name member string - "
                "exit E_OUTOFMEMORY"));

        ldap_value_free( ppServiceDnsName );

        return E_OUTOFMEMORY;
    }

    lstrcpyW( m_pServiceDnsName, ppServiceDnsName[0] );        

    ldap_value_free( ppServiceDnsName );

    LOG((MSP_INFO, "CNDNCDirectory::GetNDNCLocationFromServer - "
            "exit S_OK"));

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
// CNDNCDirectory::OpenLdapConnection
// private helper method
//
// Initiate an LDAP connection to the given port on the given server, and
// return a handle to the LDAP connection context structure. This also
// configures all necessary options for the connection, such as the LDAP
// version and the timeout.
//
// Parameters:
//  pServerName - [in]  the DNS name of the machine to connect to.
//  wPort       - [in]  the port number to use.
//  phLdap      - [out] on success, returns a handle to the LDAP connection
//                      context structure
//
// Returns: HRESULT
//

HRESULT CNDNCDirectory::OpenLdapConnection(
    IN  WCHAR  * pServerName,
    IN  WORD     wPort,
    OUT LDAP  ** phLdap
    )
{
    CLdapPtr hLdap = ldap_init(pServerName, wPort);
    BAIL_IF_NULL((LDAP*)hLdap, HRESULT_FROM_WIN32(ERROR_BAD_NETPATH));

    LDAP_TIMEVAL Timeout;
    Timeout.tv_sec = REND_LDAP_TIMELIMIT;
    Timeout.tv_usec = 0;

    DWORD res = ldap_connect((LDAP*)hLdap, &Timeout);
    BAIL_IF_LDAP_FAIL(res, "connect to the server.");

    DWORD LdapVersion = 3;
    res = ldap_set_option((LDAP*)hLdap, LDAP_OPT_VERSION, &LdapVersion);
    BAIL_IF_LDAP_FAIL(res, "set ldap version to 3");
	
    res = ldap_set_option((LDAP*)hLdap, LDAP_OPT_TIMELIMIT, &Timeout);
    BAIL_IF_LDAP_FAIL(res, "set ldap timelimit");

    ULONG ldapOptionOn = PtrToUlong(LDAP_OPT_ON);
    res = ldap_set_option((LDAP*)hLdap, LDAP_OPT_AREC_EXCLUSIVE, &ldapOptionOn);
    BAIL_IF_LDAP_FAIL(res, "set ldap arec exclusive");

    //
    // Successful; return the ldap connection handle.
    // reset the holder so that it doesn't release anything.
    //

    *phLdap = hLdap;
    hLdap   = NULL;

    return S_OK;
}

HRESULT CNDNCDirectory::TryServer(
    IN  WORD    Port,
    IN  WCHAR * pServiceDnsName
    )
/*++

Routine Description:

    Try to connect to the NDNC server on the given port and construct
    the container used for subsequent operations based on the ServiceDnsName
    found during Init.

Arguments:
    
    wPort           - The port number.
    pServiceDnsName - DNS name of NDNC service. This is used to find the
                      location in the tree to use for subsequent operations.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_INFO, "CNDNCDirectory::TryServer - "
            "trying %S at port %d; service DNS name = %S",
            m_pServerName, Port, pServiceDnsName));

    //
    // Try an LDAP collection and set various options for the connection.
    // associate the ldap handle with the handle holder. in case of an error
    // and subsequent return (without being reset), the ldap handle is closed
    //

    CLdapPtr hLdap;
    HRESULT  hr;

    hr = OpenLdapConnection( m_pServerName, Port, (LDAP **) & hLdap );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::TryServer - "
                "OpenLdapConnection failed - "
                "exit 0x%08x", hr));
            
        return hr;
    }

    if (m_IsSsl)
    {
        DWORD res = ldap_set_option(hLdap, LDAP_OPT_SSL, LDAP_OPT_ON);
        BAIL_IF_LDAP_FAIL(res, "set ssl option");
    }

    //
    // Determine the Root DN for the NDNC.
    //

    WCHAR   * pNdncRootDn;

    hr = CrackDnsName(pServiceDnsName, &pNdncRootDn);

    if ( FAILED(hr ) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::TryServer - "
                "could not crack service DNS name - exiting 0x%08x", hr));

        return hr;
    }

    //
    // Use the root DN for the NDNC to construct the DN for the
    // dynamic container.
    //

    m_pContainer = 
        new TCHAR[
                   lstrlen(DYNAMIC_CONTAINER) +
                   lstrlen(pNdncRootDn) + 1
                 ];

    if (m_pContainer == NULL)
    {
        LOG((MSP_ERROR, "CNDNCDirectory::TryServer - "
                "could not allocate container string - "
                "exit E_OUTOFMEMORY"));

        delete pNdncRootDn;

        return E_OUTOFMEMORY;
    }

    lstrcpy(m_pContainer, DYNAMIC_CONTAINER);
    lstrcat(m_pContainer, pNdncRootDn);

    delete pNdncRootDn;

    //
    // All done; save the connection handle.
    // reset the holder so that it doesn't release anything.
    //

    m_ldap  = hLdap;
    hLdap   = NULL;

    LOG((MSP_INFO, "CNDNCDirectory::TryServer - exiting OK"));

    return S_OK;
}

HRESULT CNDNCDirectory::MakeConferenceDN(
    IN  TCHAR *             pName,
    OUT TCHAR **            ppDN
    )
/*++

Routine Description:

    Construct the DN for a conference based on the name of the conference.

Arguments:
    
    pName     - The name of the conference.

    ppDN     - The DN of the conference returned.

Return Value:

    HRESULT.

--*/
{
    DWORD dwLen = 
        lstrlen(m_pContainer) + lstrlen(NDNC_CONF_DN_FORMAT) 
        + lstrlen(pName) + 1;

    *ppDN = new TCHAR [dwLen]; 

    BAIL_IF_NULL(*ppDN, E_OUTOFMEMORY);

    wsprintf(*ppDN, NDNC_CONF_DN_FORMAT, pName, m_pContainer);

    return S_OK;
}

HRESULT CNDNCDirectory::MakeUserCN(
    IN  TCHAR *     pName,
    IN  TCHAR *     pAddress,
    OUT TCHAR **    ppCN,
    OUT DWORD *     pdwIP
    )
/*++

Routine Description:

    Construct a User's CN based on username and machine name. The machine
    name is resolved first the get the fully qualified DNS name. The CN is
    in the following format: email\DNSname. 

Arguments:
    
    pName   - The name of the user.

    pAddress - The machine name.

    ppCN    - The CN returned.

    pdwIP   - The resolved IP address of the machine. Used later 
              for Netmeeting. If this is NULL, then we don't care
              about the IP.

Return Value:

    HRESULT.

--*/
{
    char *pchFullDNSName;

    if ( pdwIP == NULL )
    {
        BAIL_IF_FAIL(ResolveHostName(0, pAddress, &pchFullDNSName, NULL),
            "can't resolve host name");
    }
    else
    {
        // we care about the IP, so we must be publishing a user object
        // as opposed to refreshing or deleting. Make sure we use the
        // same IP as the interface that's used to reach the NDNC server.

        BAIL_IF_FAIL(ResolveHostName(m_dwInterfaceAddress, pAddress, &pchFullDNSName, pdwIP),
            "can't resolve host name (matching interface address)");
    }

    DWORD dwLen = lstrlen(DYNAMIC_USER_CN_FORMAT) 
        + lstrlen(pName) + lstrlenA(pchFullDNSName);

    *ppCN = new TCHAR [dwLen + 1];

    BAIL_IF_NULL(*ppCN, E_OUTOFMEMORY);

    wsprintf(*ppCN, DYNAMIC_USER_CN_FORMAT, pName, pchFullDNSName);

    return S_OK;
}

HRESULT CNDNCDirectory::MakeUserDN(
    IN  TCHAR *     pCN,
    IN  DWORD       dwIP,
    OUT TCHAR **    ppDNRTPerson
    )
/*++

Routine Description:

    Construct the DN for a user used in the Dynamic container. 

Arguments:
    
    pCN     - the CN of a user.

    ppDNRTPerson    - The DN of the user in the dynamic container.

Return Value:

    HRESULT.

--*/
{
	//
    // Make pUserName the user portion of the CN (user]machine).
    //

    CTstr pUserName = new TCHAR[ lstrlen(pCN) + 1 ];
    if ( pUserName == NULL )
    {
        BAIL_IF_FAIL(E_OUTOFMEMORY, "new TCAR");
    }

    lstrcpy( pUserName, pCN );

    WCHAR * pCloseBracket = wcschr( pUserName, CLOSE_BRACKET_CHARACTER );

    if ( pCloseBracket == NULL )
    {
        // this is not the format generated by us -- very strange indeed!
        BAIL_IF_FAIL(E_UNEXPECTED, "Strange format");
    }

    *pCloseBracket = NULL_CHARACTER;

	//
	// We'll use the IPAddress in cn
	//

	TCHAR szIPAddress[80];
	wsprintf( szIPAddress, _T("%u"), dwIP);

	//
	// Prepare the new DN
	//

	CTstr pCNIPAddress = new TCHAR[wcslen(pUserName)+1+wcslen(szIPAddress)+1];

	if( pCNIPAddress == NULL )
	{
        BAIL_IF_FAIL(E_OUTOFMEMORY, "new TCAR");
	}

	swprintf( pCNIPAddress, L"%s%C%s", 
		pUserName, 
		CLOSE_BRACKET_CHARACTER, 
		szIPAddress
		);

    // construct the DN for RTPerson.
    DWORD dwLen = lstrlen(m_pContainer) 
        + lstrlen(DYNAMIC_USER_DN_FORMAT) + lstrlen(pCNIPAddress);

    *ppDNRTPerson = new TCHAR [dwLen + 1];

    BAIL_IF_NULL(*ppDNRTPerson, E_OUTOFMEMORY);

    wsprintf(*ppDNRTPerson, DYNAMIC_USER_DN_FORMAT, pCNIPAddress, m_pContainer);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CNDNCDirectory::AddConferenceComplete
// private helper method
//
// This method simply calls the appropriate LDAP operation used to send a new
// or modified conference to the server.
//
// Parameters:
//  fModify - [in] TRUE if modifying, FALSE if adding
//  ldap    - [in] handle to LDAP connection context
//  ppDn    - [in] pointer to pointer to string specifying DN of the object
//                 (no real reason for extra indirection here)
//  mods    - [in] array of modifiers containing attribute values to be set
//
// Returns: HRESULT
//

HRESULT CNDNCDirectory::AddConferenceComplete(BOOL       fModify,
                                              LDAP     * ldap,
                                              TCHAR   ** ppDN,
                                              LDAPMod ** mods)
{
    if (fModify)
    {
        // Call the modify function to modify the object.
        BAIL_IF_LDAP_FAIL(DoLdapModify(FALSE, ldap, *ppDN, mods, FALSE), 
            "modify conference");
    }
    else
    {
        // Call the add function to create the object.
        BAIL_IF_LDAP_FAIL(DoLdapAdd(ldap, *ppDN, mods), "add conference");
    }

    return S_OK;
}

HRESULT CNDNCDirectory::AddConference(
    IN  ITDirectoryObject *pDirectoryObject,
    IN  BOOL fModify
    )
/*++

Routine Description:
    
    Add a new conference to the NDNC server.

Arguments:
    
    pDirectoryObject - a pointer to the conference.
    fModify          - true  if called by MofifyDirectoryObject
                       false if called by AddDirectoryObject

--*/
{
    // first query the private interface for attributes.
    CComPtr <ITDirectoryObjectPrivate> pObjectPrivate;

    BAIL_IF_FAIL(
        pDirectoryObject->QueryInterface(
            IID_ITDirectoryObjectPrivate,
            (void **)&pObjectPrivate
            ),
        "can't get the private directory object interface");

    // Get the name of the conference.
    CBstr bName;
    BAIL_IF_FAIL(pDirectoryObject->get_Name(&bName), 
        "get conference name");

    // Construct the DN of the object.
    CTstr pDN;
    BAIL_IF_FAIL(
        MakeConferenceDN(bName, &pDN), "construct DN for conference"
        );

    // Get the protocol and the blob.
    CBstr bProtocol, bBlob;

    BAIL_IF_FAIL(pObjectPrivate->GetAttribute(MA_PROTOCOL, &bProtocol), 
        "get conference protocol");

    BAIL_IF_FAIL(pObjectPrivate->GetAttribute(MA_CONFERENCE_BLOB, &bBlob),
        "get conference Blob");

    // Get the Security Descriptor. The pointer pSD is just a copy of a pointer
    // in the Conference object; the conference object retains ownership of the
    // data and we must be careful not to delete or modify this data.

    char * pSD;
    DWORD dwSDSize;

    BAIL_IF_FAIL(pObjectPrivate->GetConvertedSecurityDescriptor(&pSD, &dwSDSize),
        "get conference security descriptor");

    // Get the TTL setting.
    DWORD dwTTL;
    BAIL_IF_FAIL(pObjectPrivate->GetTTL(&dwTTL), "get conference TTL");

    //
    // Adjust the TTL setting to what we're really going to send.
    //

    if ( dwTTL == 0 )
    {
        dwTTL = m_TTL;
    }

    if ( dwTTL > NDNC_MAX_TTL )
    {
        dwTTL = NDNC_MAX_TTL;
    }

    // 5 attributes need to be published.
    static const DWORD DWATTRIBUTES = 5;

    // Fist fill the modify structures required by LDAP.
    LDAPMod     mod[DWATTRIBUTES];  
    LDAPMod*    mods[DWATTRIBUTES + 1];

    DWORD       dwCount = 0;

    // The objectclass attribute.
    TCHAR * objectClass[] = 
        {(WCHAR *)NDNC_RTCONFERENCE, (WCHAR *)DYNAMICOBJECT, NULL};
    if (!fModify)
    {
        mod[dwCount].mod_values  = objectClass;
        mod[dwCount].mod_op      = LDAP_MOD_REPLACE;
        mod[dwCount].mod_type    = (WCHAR *)OBJECTCLASS;
        dwCount ++;
    }
    
    // The protocol attribute.
    TCHAR * protocol[] = {(WCHAR *)bProtocol, NULL};
    mod[dwCount].mod_values  = protocol;
    mod[dwCount].mod_op      = LDAP_MOD_REPLACE;
    mod[dwCount].mod_type    = (WCHAR *)RTConferenceAttributeName(MA_PROTOCOL);
    dwCount ++;
    
    // The blob attribute.
    TCHAR * blob[]     = {(WCHAR *)bBlob, NULL};
    mod[dwCount].mod_values  = blob;
    mod[dwCount].mod_op      = LDAP_MOD_REPLACE;
    mod[dwCount].mod_type    =
        (WCHAR *)RTConferenceAttributeName(MA_CONFERENCE_BLOB);
    dwCount ++;

    // The TTL attribute. The attribute value is a DWORD in string.
    TCHAR   strTTL[32];
    TCHAR * ttl[]           = {strTTL, NULL};
    wsprintf(strTTL, _T("%d"), dwTTL );
    mod[dwCount].mod_values = ttl;
    mod[dwCount].mod_op     = LDAP_MOD_REPLACE;
    mod[dwCount].mod_type   = (WCHAR *)ENTRYTTL;
    dwCount ++;
    
    //
    // These locals should not be within the "if" below... if
    // they are, they will be deallocated before the function returns.
    //

    berval  BerVal;
    berval  *sd[] = {&BerVal, NULL};

    HRESULT hr;

    //
    // If there is a security descriptor on the local object, perhaps send it
    // to the server.
    //

    if ( (char*)pSD != NULL )
    {
        BOOL         fSendIt = FALSE;

        if ( ! fModify )
        {
            //
            // We are trying to add the conference, so we definitely need
            // to send the security descriptor. Note that we even want
            // to send it if it hasn't changed, as we may be sending it to
            // some new server other than where we got it (if this conference
            // object was retrieved from a server in the first place).
            //

            fSendIt = TRUE;
        }
        else
        {
            //
            // We are trying to modify the conference, so we send the
            // security descriptor if it has changed.
            //

            VARIANT_BOOL fChanged;

            hr = pObjectPrivate->get_SecurityDescriptorIsModified( &fChanged );

            if ( SUCCEEDED( hr ) && ( fChanged == VARIANT_TRUE ) )
            {
                fSendIt = TRUE;
            }
        }

        if ( fSendIt )
        {
            BerVal.bv_len = dwSDSize;
            BerVal.bv_val = (char*)pSD;

            mod[dwCount].mod_bvalues  = sd;
            mod[dwCount].mod_op       = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
            mod[dwCount].mod_type     = (WCHAR *)NT_SECURITY_DESCRIPTOR;
            dwCount ++;
        }
    }

    //
    // All done with the mods. Package them up and write to the server.
    //

    DWORD i;
    for (i = 0; i < dwCount; i ++)
    {
        mods[i] = &mod[i];
    }
    mods[i] = NULL;
        
    LOG((MSP_INFO, "%S %S", fModify ? _T("modifying") : _T("adding"), pDN));

    hr = AddConferenceComplete(fModify, m_ldap, &pDN, mods);

    if ( SUCCEEDED(hr) )
    {
        pObjectPrivate->put_SecurityDescriptorIsModified( VARIANT_FALSE );
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
// This method tests if the given ACL (security descriptor) is "safe".
// "Safe" is defined as allowing the creator to modify and delete the
// object; modification is tested via the TTL field.
//
// This test is needed to prevent leaving "ghost" objects on the server
// when modifying the TTL of a newly-created conference fails because of
// insfufficient access rights. This will happen if a user messes up
// ACL creation or if the server does not understand the domain trustees
// in the ACL (e.g., server machine is not in a domain).
//
// The test is performed by creating a "dummy" test object with a random
// name in the container normally used for conferences. The object will
// not show up in a normal conference or user enumeration because it does
// not have the required attributes.
//
//

HRESULT CNDNCDirectory::TestAclSafety(
    IN  char  * pSD,
    IN  DWORD   dwSDSize
    )
{
    LOG((MSP_TRACE, "CNDNCDirectory::TestACLSafety - enter"));

    //
    // First fill in the modify structures required by LDAP.
    // We use only the object class and the security descriptor.
    // Therefore this will not show up as a valid conference
    // during an enumeration.
    //
    
    static const DWORD DWATTRIBUTES = 2;

    LDAPMod     mod[DWATTRIBUTES];  
    LDAPMod*    mods[DWATTRIBUTES + 1];

    DWORD       dwCount = 0;

    TCHAR * objectClass[] = 
        {(WCHAR *)NDNC_RTCONFERENCE, (WCHAR *)DYNAMICOBJECT, NULL};

    mod[dwCount].mod_values  = objectClass;
    mod[dwCount].mod_op      = LDAP_MOD_REPLACE;
    mod[dwCount].mod_type    = (WCHAR *)OBJECTCLASS;
    dwCount ++;

    berval  BerVal;
    berval  *sd[] = {&BerVal, NULL};

    BerVal.bv_len = dwSDSize;
    BerVal.bv_val = (char*)pSD;

    mod[dwCount].mod_bvalues  = sd;
    mod[dwCount].mod_op       = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    mod[dwCount].mod_type     = (WCHAR *)NT_SECURITY_DESCRIPTOR;
    dwCount ++;

    DWORD i;
    for (i = 0; i < dwCount; i ++)
    {
        mods[i] = &mod[i];
    }
    mods[i] = NULL;

    //
    // Try to add an object in the dynamic container with the above mods.
    // Use a name composed of a random number printed to a string. If the
    // names happen to conflict with another such dummy conference, then
    // try again in a loop.
    //
    // Randomization is apparently per-DLL -- Sdpblb.dll does srand() but
    // it doesn't seem to affect rand() calls within rend.dll. We therefore do
    // srand( time( NULL ) ) on DLL_PROCESS_ATTACH.
    //

    HRESULT   hr;
    int       iRandomNumber;
    TCHAR     ptszRandomNumber[30];
    TCHAR   * pDN = NULL; 

    do
    {
        if ( pDN != NULL )
        {
            delete pDN;
        }

        iRandomNumber = rand();

        wsprintf(ptszRandomNumber, _T("%d"), iRandomNumber);

        hr = CNDNCDirectory::MakeConferenceDN(ptszRandomNumber, &pDN);

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "CNDNCDirectory::TestACLSafety - "
                "test DN construction failed - exit 0x%08x", hr));

            return hr;
        }

        LOG((MSP_TRACE, "CNDNCDirectory::TestACLSafety - "
            "trying to create test object DN %S", pDN));

        hr = GetLdapHResultIfFailed( DoLdapAdd(m_ldap, pDN, mods) );
    }
    while ( hr == GetLdapHResultIfFailed( LDAP_ALREADY_EXISTS ) );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::TestACLSafety - "
            "test addition failed and not duplicate - exit 0x%08x", hr));

        delete pDN;

        return hr;
    }

    //
    // Now that we have the test object, try modifying it.
    //

    LOG((MSP_TRACE, "CNDNCDirectory::TestACLSafety - "
        "trying to modify test object..."));

    HRESULT hrModify = NDNCSetTTL( m_ldap, pDN, MINIMUM_TTL );

    //
    // Now delete it. We do this even if we already know that the ACL is bad
    // because the modify failed; we want to get rid of the object if
    // possible.
    //

    LOG((MSP_TRACE, "CNDNCDirectory::TestACLSafety - "
        "trying to delete test object..."));

    hr = GetLdapHResultIfFailed( DoLdapDelete(m_ldap, pDN) );

    delete pDN;

    //
    // Now determine the verdict and return.
    //

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::TestACLSafety - "
            "test deletion (+ modification?) failed - ACL unsafe - "
            "exit 0x%08x", hr));

        return hr;
    }

    if ( FAILED( hrModify ) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::TestACLSafety - "
            "test deletion ok; test modification failed - ACL unsafe - "
            "exit 0x%08x", hrModify));

        return hrModify;
    }

    LOG((MSP_TRACE, "CNDNCDirectory::TestACLSafety - exit S_OK"));

    return S_OK;
}


HRESULT CNDNCDirectory::PublishRTPerson(
    IN TCHAR *  pCN,
    IN TCHAR *  pDN,
    IN TCHAR *  pIPAddress,
    IN DWORD    dwTTL,
    IN BOOL     fModify,
    IN char  *  pSD,
    IN DWORD    dwSDSize
    )
/*++

Routine Description:
    
    Create a RTPerson object in the dynamic container.

Arguments:
    
    pCN - The cn of the user.
    
    pDN - The dn of the user.

    pIPAddress - The ip address of the machine.

    dwTTL - The ttl of this object.

    fModify - modify or add.

Return Value:

    HRESULT.

--*/
{
    //
    // UPDATE THIS CONSTANT whenever you add an attribute below
    //
    
    static const DWORD DWATTRIBUTES = 4;

    // First create the object.
    LDAPMod     mod[DWATTRIBUTES];
	DWORD		dwCount = 0;

    //
    // We are not allowed to modify the object class. Therefore we only mention
    // this if we are adding the object to the server, not modifying it.
    //

    // Fix: this is allocated on the stack, so we must do it here; if we stick
    // it inside the if below, it gets deallocated immediately.
    TCHAR * objectClass[]   = {(WCHAR *)NDNC_RTPERSON, (WCHAR *)DYNAMICOBJECT, NULL}; 

    if ( ! fModify )
    {
        // Object class.
        // only need this attribute if not modifying.
	    mod[dwCount].mod_values       = objectClass;
        mod[dwCount].mod_op           = LDAP_MOD_REPLACE;
        mod[dwCount].mod_type         = (WCHAR *)OBJECTCLASS;
        dwCount ++;
    }

    // msTAPI-uid
    TCHAR* TAPIUid[] = {(WCHAR*)pCN, NULL};
    mod[dwCount].mod_values   = TAPIUid;
    mod[dwCount].mod_op       = LDAP_MOD_REPLACE;
    mod[dwCount].mod_type     = (WCHAR *)TAPIUID_NDNC;
	dwCount ++;

    // IP address.
    TCHAR * IPPhone[]   = {(WCHAR *)pIPAddress, NULL};
    mod[dwCount].mod_values   = IPPhone;
    mod[dwCount].mod_op       = LDAP_MOD_REPLACE;
    mod[dwCount].mod_type     = (WCHAR *)IPADDRESS_NDNC;
	dwCount ++;

    // these locals should not be within the "if" below... if
    // they are, they might be deallocated before the function returns.

    berval  BerVal;
    berval  *sd[] = {&BerVal, NULL};

    // The security descriptor attribute.
    if ((char*)pSD != NULL)
    {
        BerVal.bv_len = dwSDSize;
        BerVal.bv_val = (char*)pSD;

        mod[dwCount].mod_bvalues  = sd;
        mod[dwCount].mod_op       = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
        mod[dwCount].mod_type     = (WCHAR *)NT_SECURITY_DESCRIPTOR;
        dwCount ++;
    }


    LDAPMod* mods[DWATTRIBUTES + 1];

    DWORD i;
    
    for (i = 0; i < dwCount; i ++)
    {
        mods[i] = &mod[i];
    }
    mods[i] = NULL;

    if (fModify)
    {
        LOG((MSP_INFO, "modifying %S", pDN));

        // Call the modify function to modify the object.
        BAIL_IF_LDAP_FAIL(DoLdapModify(FALSE, m_ldap, pDN, mods), "modify RTPerson");
    }
    else
    {
        LOG((MSP_INFO, "adding %S", pDN));

        // Call the add function to create the object.
        BAIL_IF_LDAP_FAIL(DoLdapAdd(m_ldap, pDN, mods), "add RTPerson");

        // next set the TTL value for this object
        BAIL_IF_FAIL(NDNCSetTTL(m_ldap, pDN, (dwTTL == 0) ? m_TTL : dwTTL),
            "Set ttl for RTPerson");
    }

    return S_OK;
}

HRESULT CNDNCDirectory::AddObjectToRefresh(
    IN  WCHAR *pDN,
    IN  long TTL
    )
{
    //
    // Add a refresh table entry to the refresh table. The refresh table's add
    // method does an element-by-element copy of the entry that it is given.
    // This just copies the string pointer, so we need to allocate and copy
    // the string here.
    //

    RefreshTableEntry entry;

    entry.dwTTL = TTL;

    entry.pDN = new WCHAR[ wcslen(pDN) + 1 ];
    
    if ( entry.pDN == NULL ) 
    {
        LOG((MSP_ERROR, "Cannot allocate string for adding to refresh table"));
        return E_OUTOFMEMORY;
    }

    wcscpy( entry.pDN, pDN );

    //
    // Now add it to the refresh table.
    //

    BOOL fSuccess = m_RefreshTable.add(entry);

    if ( ! fSuccess ) 
    {
        LOG((MSP_ERROR, "Cannot add object to the refresh table"));
        return E_OUTOFMEMORY;
    }
    
    return S_OK;
}

HRESULT CNDNCDirectory::RemoveObjectToRefresh(
    IN  WCHAR *pDN
    )
{
    //
    // For each item in our refresh table
    //

    for ( DWORD i = 0; i < m_RefreshTable.size(); i++ )
    {
        //
        // If the desired DN matches the one in this item
        // then remove it and return success
        // 

        if ( ! _wcsicmp( m_RefreshTable[i].pDN, pDN ) )
        {
            //
            // We new'ed the string when we added the entry.
            //

            delete m_RefreshTable[i].pDN;

            m_RefreshTable.removeAt(i);
            
            return S_OK;
        }
    }

    //
    // If we get here then there was no matching item
    //

    LOG((MSP_ERROR, "Cannot remove object from the refresh table"));
    return E_FAIL;
}

HRESULT CNDNCDirectory::AddUser(
    IN  ITDirectoryObject *pDirectoryObject,
    IN  BOOL fModify
    )
/*++

Routine Description:
    
    Publish a new user object.

Arguments:
    
    pDirectoryObject - The object to be published.
    

Return Value:

    HRESULT.

--*/
{
    // First find the interface for attributes.
    CComPtr <ITDirectoryObjectPrivate> pObjectPrivate;

    BAIL_IF_FAIL(
        pDirectoryObject->QueryInterface(
            IID_ITDirectoryObjectPrivate,
            (void **)&pObjectPrivate
            ),
        "can't get the private directory object interface");

    // Get the user name.
    CBstr bName;
    BAIL_IF_FAIL(pDirectoryObject->get_Name(&bName), 
        "get user name");

    // Get the user's machine name.
    CBstr bIPPhone;
    BAIL_IF_FAIL(pObjectPrivate->GetAttribute(UA_IPPHONE_PRIMARY, &bIPPhone), 
        "get IPPhone");

    // Resolve the machine name and construct the CN for the user.
    CTstr pCN;
    DWORD dwIP;

    BAIL_IF_FAIL(
        MakeUserCN(bName, bIPPhone, &pCN, &dwIP), 
        "construct CN for user"
        );

    // Construct the DN for the RTPerson object.
    CTstr pDNRTPerson;
    BAIL_IF_FAIL(
        MakeUserDN(pCN, dwIP, &pDNRTPerson), 
        "construct DN for user"
        );

    // convert the IP address to a string. 
    // This convertion is because of NetMeeting.
    TCHAR IPAddress[80];
    wsprintf(IPAddress, _T("%u"), dwIP);

    DWORD dwTTL;
    BAIL_IF_FAIL(pObjectPrivate->GetTTL(&dwTTL), "get User TTL");

    // Get the Security Descriptor. The pointer pSD is just a copy of a pointer
    // in the Conference object; the conference object retains ownership of the
    // data and we must be careful not to delete or modify this data.

    char * pSD;
    DWORD dwSDSize;

    BAIL_IF_FAIL(pObjectPrivate->GetConvertedSecurityDescriptor(&pSD, &dwSDSize),
        "get user object security descriptor");

    VARIANT_BOOL fChanged;

    if ( SUCCEEDED( pObjectPrivate->
            get_SecurityDescriptorIsModified( &fChanged ) ) )
    {
        if ( fChanged == VARIANT_FALSE )
        {
            pSD = NULL;   // do NOT delete the string (see above)
            dwSDSize = 0;
        }
    }

    //
    // NDNCs, unlike ILS, should return LDAP_ALREADY_EXISTS if the user object
    // already exists. In ILS, this bug was a special hack for NetMeeting, but
    // NetMeeting is no longer a factor with an NDNC.
    //

    HRESULT hr = PublishRTPerson(pCN, pDNRTPerson, IPAddress, dwTTL, fModify, pSD, dwSDSize);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "Can't publish a RTPerson, hr:%x", hr));

        return hr;
    }

    //
    // Add the RTPerson to the refresh list.
    //

    if (m_fAutoRefresh)
    {
        AddObjectToRefresh(pDNRTPerson, m_TTL);
    }

    return S_OK;
}

HRESULT CNDNCDirectory::DeleteConference(
    IN  ITDirectoryObject *pDirectoryObject
    )
/*++

Routine Description:
    
    Delete a conference from the NDNC server.

Arguments:
    
    pDirectoryObject - The object to be deleted.
    
Return Value:

    HRESULT.

--*/
{
    // Get the name.
    CBstr bName;
    BAIL_IF_FAIL(pDirectoryObject->get_Name(&bName), 
        "get conference name");

    // construct the DN
    CTstr pDN;
    BAIL_IF_FAIL(
        MakeConferenceDN(bName, &pDN), "construct DN for conference"
        );

    LOG((MSP_INFO, "deleting %S", pDN));

    // Call the add function to create the object.
    BAIL_IF_LDAP_FAIL(DoLdapDelete(m_ldap, pDN), "delete conference");

    return S_OK;
}

HRESULT CNDNCDirectory::DeleteUser(
    IN  ITDirectoryObject *pDirectoryObject
    )
/*++

Routine Description:
    
    Delete a user from the NDNC server.

Arguments:
    
    pDirectoryObject - The object to be deleted.
    
Return Value:

    HRESULT.

--*/
{
    // First find the interface for attributes.
    CComPtr <ITDirectoryObjectPrivate> pObjectPrivate;

    BAIL_IF_FAIL(
        pDirectoryObject->QueryInterface(
            IID_ITDirectoryObjectPrivate,
            (void **)&pObjectPrivate
            ),
        "can't get the private directory object interface");

    // Get the user name.
    CBstr bName;
    BAIL_IF_FAIL(pDirectoryObject->get_Name(&bName), 
        "get user name");

    // Get the user's machine name.
    CBstr bIPPhone;
    BAIL_IF_FAIL(pObjectPrivate->GetAttribute(UA_IPPHONE_PRIMARY, &bIPPhone), 
        "get IPPhone");

    // Resolve the machine name and construct the CN for the user.
    CTstr pCN;
    DWORD dwIP;

    BAIL_IF_FAIL(
        MakeUserCN(bName, bIPPhone, &pCN, &dwIP), 
        "construct CN for user"
        );

    // Construct the DN for the RTPerson object.
    CTstr pDNRTPerson;
    BAIL_IF_FAIL(
        MakeUserDN(pCN, dwIP, &pDNRTPerson), 
        "construct DN for user"
        );

    //
    // Now delete the object from the server.
    //

    HRESULT hrFinal = S_OK;
    HRESULT hr;
    ULONG   ulResult;

    // Call the delete function to delete the RTPerson object, but keep
    // going if it fails, noting the error code.

    LOG((MSP_INFO, "deleting %S", pDNRTPerson));
    ulResult = DoLdapDelete(m_ldap, pDNRTPerson);
    hr       = LogAndGetLdapHResult(ulResult, _T("delete RTPerson"));
    if (FAILED(hr)) { hrFinal = hr; }


    // we always remove the refresh objects, even if removal failed.
    if (m_fAutoRefresh)
    {
        RemoveObjectToRefresh(pDNRTPerson);
    }

    return hrFinal;
}

HRESULT CNDNCDirectory::RefreshUser(
    IN  ITDirectoryObject *pDirectoryObject
    )
/*++

Routine Description:
    
    Refresh a user's TTL on the NDNC server. 

Arguments:
    
    pDirectoryObject - The object to be refreshed.
    
Return Value:

    HRESULT.

--*/
{
    // First find the interface for attributes.
    CComPtr <ITDirectoryObjectPrivate> pObjectPrivate;

    BAIL_IF_FAIL(
        pDirectoryObject->QueryInterface(
            IID_ITDirectoryObjectPrivate,
            (void **)&pObjectPrivate
            ),
        "can't get the private directory object interface");

    // Get the user name.
    CBstr bName;
    BAIL_IF_FAIL(pDirectoryObject->get_Name(&bName), 
        "get user name");

    // Get the user's machine name.
    CBstr bIPPhone;
    BAIL_IF_FAIL(pObjectPrivate->GetAttribute(UA_IPPHONE_PRIMARY, &bIPPhone), 
        "get IPPhone");

    // Resolve the machine name and construct the CN for the user.
    CTstr pCN;
    DWORD dwIP;

    BAIL_IF_FAIL(
        MakeUserCN(bName, bIPPhone, &pCN, &dwIP), 
        "construct CN for user"
        );

    // Construct the DN for the RTPerson object.
    CTstr pDNRTPerson;
    BAIL_IF_FAIL(
        MakeUserDN(pCN, dwIP, &pDNRTPerson), 
        "construct DN for user"
        );

    // set ttl for the RTPerson object.
    BAIL_IF_LDAP_FAIL(NDNCSetTTL(m_ldap, pDNRTPerson, m_TTL), "set ttl for RTPerson");

    //
    // If the app has enabled auto-refresh but does not add or modify its
    // user object, but rather, just refreshes it (because the object is still around
    // from a previous instance of the app, and "add" would fail), we still need to
    // autorefresh it, as that's what the app wants.
    //

    if (m_fAutoRefresh)
    {
        AddObjectToRefresh(pDNRTPerson, m_TTL);
    }

    return S_OK;
}

HRESULT CNDNCDirectory::CreateConference(
    IN  LDAPMessage *           pEntry,
    OUT ITDirectoryObject **    ppObject
    )
/*++

Routine Description:
    
    Create a conference object from the result of the LDAP search.

Arguments:
    
    pEntry  - The search result.

    ppObject - The object to be created.
    
Return Value:

    HRESULT.

--*/
{
    CBstr bName, bProtocol, bBlob;

    // Get the name of the conference.
    BAIL_IF_FAIL(
        ::GetAttributeValue(
            m_ldap,
            pEntry,
            RTConferenceAttributeName(MA_MEETINGNAME), 
            &bName
            ),
        "get the conference name"
        );

    // Get the protocol ID of the conference.
    BAIL_IF_FAIL(
        ::GetAttributeValue(
            m_ldap,
            pEntry, 
            RTConferenceAttributeName(MA_PROTOCOL), 
            &bProtocol
            ),
        "get the conference protocol"
        );

    // Get the conference blob of the conference.
    BAIL_IF_FAIL(
        ::GetAttributeValue(
            m_ldap,
            pEntry, 
            RTConferenceAttributeName(MA_CONFERENCE_BLOB),
            &bBlob
            ),
        "get the conference blob"
        );

    char * pSD = NULL;
    DWORD dwSDSize = 0;

    ::GetAttributeValueBer(
        m_ldap,
        pEntry, 
        NT_SECURITY_DESCRIPTOR,
        &pSD,
        &dwSDSize
        );

    // Create an empty conference.
    
    HRESULT hr = ::CreateConferenceWithBlob(bName,
                                            bProtocol,
                                            bBlob,
                                            pSD,
                                            dwSDSize,
                                            ppObject);
    
    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::CreateConference - "
            "CreateConferenceWithBlob failed 0x%08x", hr));

        delete pSD;

        return hr;
    }

    //
    // If the above succeeded then the conference object has taken ownership
    // of pSD.
    //

    return S_OK;
    
}

HRESULT CNDNCDirectory::CreateUser(
    IN  LDAPMessage *   pEntry,
    IN  ITDirectoryObject ** ppObject
    )
/*++

Routine Description:
    
    Create a user object from the result of the LDAP search.

Arguments:
    
    pEntry  - The search result.

    ppObject - The object to be created.
    
Return Value:

    HRESULT.

--*/
{
    CBstr bName;
    // Get the name of the user.
    BAIL_IF_FAIL(
        ::GetAttributeValue(
            m_ldap,
            pEntry, 
            RTPersonAttributeName(UA_TAPIUID),
            &bName
            ),
        "get the user name"
        );


    CBstr bAddress;

    // Grab the machine name from the name of the object. This can fail if
    // we didn't publish the object (ie, it's a NetMeeting object). Also,
    // check if the hostname isn't resolvable. In that case we also have
    // to fall back on the IP address in the ipAddress attribute.

    HRESULT hr;
    
    hr = ParseUserName(bName, &bAddress);

    if ( SUCCEEDED(hr) )
    {
        // Make sure we can get an IP from this name, at least for the moment.
        // If not, release the name and indicate failure so we do our backup
        // plan.

        hr = ResolveHostName(0, bAddress, NULL, NULL);

        if ( FAILED(hr) )
        {
            SysFreeString(bAddress);    
        }
    }
    

    if ( FAILED(hr) )
    {
        // In order to compatible with NetMeeting, we have to use IP address field.
        CBstr bUglyIP;
        BAIL_IF_FAIL(
            ::GetAttributeValue(
                m_ldap,
                pEntry, 
                RTPersonAttributeName(UA_IPPHONE_PRIMARY),
                &bUglyIP
                ),
            "get the user's IP address"
            );

        // We have to use NM's ugly format for the IP address. The IP address 
        // we got from netmeeting is a decimal string whose value is the dword 
        // value of the IP address in network order.
        BAIL_IF_FAIL(UglyIPtoIP(bUglyIP, &bAddress), "Convert IP address");
    }

    // Create an empty user object.
    CComPtr<ITDirectoryObject> pObject;
    BAIL_IF_FAIL(::CreateEmptyUser(bName, &pObject), "CreateEmptyUser");


    CComPtr <ITDirectoryObjectPrivate> pObjectPrivate;

    BAIL_IF_FAIL(
        pObject->QueryInterface(
            IID_ITDirectoryObjectPrivate,
            (void **)&pObjectPrivate
            ),
        "can't get the private directory object interface");

    // Set the user attributes.
    BAIL_IF_FAIL(pObjectPrivate->SetAttribute(UA_IPPHONE_PRIMARY, bAddress),
        "set ipAddress");



    //
    // Set the security descriptor on the object.
    //

    char * pSD = NULL;
    DWORD dwSDSize = 0;

    ::GetAttributeValueBer(
        m_ldap,
        pEntry, 
        NT_SECURITY_DESCRIPTOR,
        &pSD,
        &dwSDSize
        );

    if ( pSD != NULL )
    {
        //
        // Set the security descriptor in its "converted" (server) form.
        //

        hr = pObjectPrivate->PutConvertedSecurityDescriptor(pSD,
                                                            dwSDSize);

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "PutConvertedSecurityDescriptor failed: %x", hr));
            return hr;
        }
    }

    *ppObject = pObject;
    (*ppObject)->AddRef();

    return S_OK;
}

HRESULT CNDNCDirectory::SearchObjects(
    IN  DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
    IN  BSTR                    pName,
    OUT ITDirectoryObject ***   pppDirectoryObject,
    OUT DWORD *                 pdwSize
    )
/*++

Routine Description:
    
    Search the NDNC server for given type of objects.

Arguments:
    
    DirectoryObjectType - The type of the object.

    pName   - The name to search for.

    pppDirectoryObject - The returned array of objects.

    pdwSize - The size of the array.
    
Return Value:

    HRESULT.

--*/
{
    TCHAR *pRDN;
    TCHAR *pObjectClass;
    TCHAR *Attributes[NUM_MEETING_ATTRIBUTES + 1]; // This is big enough now.

    //
    // Fill the attributes want to be returned, and construct the
    // filter that we need.
    //
    
    switch (DirectoryObjectType)
    {
    case OT_CONFERENCE:

        pRDN          = (WCHAR *)UIDEQUALS_NDNC;
        pObjectClass  = (WCHAR *)NDNC_RTCONFERENCE;

        Attributes[0] = (WCHAR *)RTConferenceAttributeName(MA_MEETINGNAME);
        Attributes[1] = (WCHAR *)RTConferenceAttributeName(MA_PROTOCOL);
        Attributes[2] = (WCHAR *)RTConferenceAttributeName(MA_CONFERENCE_BLOB);
        Attributes[3] = (WCHAR *)NT_SECURITY_DESCRIPTOR;
        Attributes[4] = NULL;

        break;

    case OT_USER:

        pRDN          = (WCHAR *)CNEQUALS;
        pObjectClass  = (WCHAR *)NDNC_RTPERSON;

        Attributes[0] = (WCHAR *)RTPersonAttributeName(UA_USERNAME);
        Attributes[1] = (WCHAR *)RTPersonAttributeName(UA_IPPHONE_PRIMARY);
        Attributes[2] = (WCHAR *)RTPersonAttributeName(UA_TAPIUID);
        Attributes[3] = (WCHAR *)NT_SECURITY_DESCRIPTOR;
        Attributes[4] = NULL;
        
        break;

    default:
        return E_FAIL;
    }

    //
    // Construct the filter of the search.
    // Finished strings should look like this:
    // (&(entryTTL>=1)(objectCategory=msTAPI-RtConference)(uid=Name))
    // (&(entryTTL>=1)(objectCategory=msTAPI-RtPerson)(cn=Name))
    // We put out entryTTL, so from:
    // (&(entryTTL>=1)(objectCategory=%s)(%s%s%s)) became
    // (&(objectCategory=%s)(%s%s%s))
    //

    TCHAR NDNC_SEARCH_FILTER_FORMAT[] =
       _T("(&(objectCategory=%s)(%s%s%s))");

    CTstr pFilter = new TCHAR [lstrlen(NDNC_SEARCH_FILTER_FORMAT) +
                               lstrlen(pObjectClass) +
                               lstrlen(pRDN) +
                               lstrlen(pName) + 1];

    BAIL_IF_NULL((TCHAR*)pFilter, E_OUTOFMEMORY);

    TCHAR * pStar;

    if (pName[lstrlen(pName) - 1] != _T('*'))
    {
        pStar = _T("*");
    }
    else
    {
        pStar = _T("");
    }
    
    wsprintf(pFilter, NDNC_SEARCH_FILTER_FORMAT, 
             pObjectClass, pRDN, pName, pStar);

    // Search them.
    CLdapMsgPtr pLdapMsg; // auto release message.

    ULONG res = DoLdapSearch(
        m_ldap,              // ldap handle
        m_pContainer,        // schema dn
        LDAP_SCOPE_ONELEVEL, // one level search
        pFilter,             // filter -- see above
        Attributes,          // array of attribute names
        FALSE,               // return the attribute values
        &pLdapMsg,           // search results
        FALSE
        );

    BAIL_IF_LDAP_FAIL(res, "search for objects");

    // count the returned entries.
    DWORD dwEntries = ldap_count_entries(m_ldap, pLdapMsg);
    ITDirectoryObject ** pObjects = new PDIRECTORYOBJECT [dwEntries];

    BAIL_IF_NULL(pObjects, E_OUTOFMEMORY);

    // Create objects.
    DWORD dwCount = 0;
    LDAPMessage *pEntry = ldap_first_entry(m_ldap, pLdapMsg);
    
    while (pEntry != NULL)
    {
        HRESULT hr;
        
        switch (DirectoryObjectType)
        {
        case OT_CONFERENCE:
            hr = CreateConference(pEntry, &pObjects[dwCount]);
            break;
        case OT_USER:
            hr = CreateUser(pEntry, &pObjects[dwCount]);
            break;
        }

        if (SUCCEEDED(hr)) 
        {
            dwCount ++;
        }
          
        // Get next entry.
        pEntry = ldap_next_entry(m_ldap, pEntry);
    }

    *pppDirectoryObject = pObjects;
    *pdwSize = dwCount;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// NDNC Directory implementation
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CNDNCDirectory::get_DirectoryType (
    OUT DIRECTORY_TYPE *  pDirectoryType
    )
// Get the type of the directory.
{
    if ( IsBadWritePtr(pDirectoryType, sizeof(DIRECTORY_TYPE) ) )
    {
        LOG((MSP_ERROR, "Directory.GetType, invalid pointer"));
        return E_POINTER;
    }

    CLock Lock(m_lock);

    *pDirectoryType = m_Type;

    return S_OK;
}

STDMETHODIMP CNDNCDirectory::get_DisplayName (
    OUT BSTR *ppServerName
    )
// Get the display name of the directory.
{
    BAIL_IF_BAD_WRITE_PTR(ppServerName, E_POINTER);

    CLock Lock(m_lock);

    //
    // Rather m_pServerName, we'll use
    // m_pServiceDnsName
    //

    if (m_pServiceDnsName == NULL)
    {
        *ppServerName = SysAllocString(L"");
    }
    else
    {
        *ppServerName = SysAllocString(m_pServiceDnsName);
    }

    if (*ppServerName == NULL)
    {
        LOG((MSP_ERROR, "get_DisplayName: out of memory."));
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

STDMETHODIMP CNDNCDirectory::get_IsDynamic(
    OUT VARIANT_BOOL *pfDynamic
    )
// find out if the directory is a dynamic one, meaning the object will be
// deleted after TTL runs out.
{
    if ( IsBadWritePtr( pfDynamic, sizeof(VARIANT_BOOL) ) )
    {
        LOG((MSP_ERROR, "Directory.get_IsDynamic, invalid pointer"));
        return E_POINTER;
    }

    *pfDynamic = VARIANT_TRUE;
    
    return S_OK;
}

STDMETHODIMP CNDNCDirectory::get_DefaultObjectTTL(
    OUT long *pTTL        // in seconds
    )
// The default TTL for object created. It is used when the object doesn't set
// a TTL. Conference object always has a TTL based on the stoptime.
{
    if ( IsBadWritePtr( pTTL, sizeof(long) ) )
    {
        LOG((MSP_ERROR, "Directory.get_default objec TTL, invalid pointer"));
        return E_POINTER;
    }

    CLock Lock(m_lock);

    *pTTL = m_TTL;
    
    return S_OK;
}

STDMETHODIMP CNDNCDirectory::put_DefaultObjectTTL(
    IN  long TTL          // in sechods
    )
// Change the default TTL, must be bigger then five minutes.
{
    CLock Lock(m_lock);

    if (TTL < MINIMUM_TTL)
    {
        return E_INVALIDARG;
    }

    m_TTL = TTL;
    
    return S_OK;
}

STDMETHODIMP CNDNCDirectory::EnableAutoRefresh(
    IN  VARIANT_BOOL fEnable
    )
// Enable auto refresh. Add this directory to the work threads that
// will notify the directory to update its objects.
{
    HRESULT hr;

    // ZoltanS: either VARIANT_TRUE or TRUE will work
    // in case the caller doesn't know better

    if (fEnable)
    {
        // Add this directory to the notify list of the work thread.
        if (FAILED(hr = g_RendThread.AddDirectory(this)))
        {
            LOG((MSP_ERROR, 
                "Can not add this directory to the thread, %x", hr));
            return hr;
        }
    }
    else
    {
        // Remove this directory from the notify list of the work thread.
        if (FAILED(hr = g_RendThread.RemoveDirectory(this)))
        {
            LOG((MSP_ERROR, 
                "Can not remove this directory from the thread, %x", hr));
            return hr;
        }
    }

    // ZoltanS: either VARIANT_TRUE or TRUE will work
    // in case the caller doesn't know better

    m_lock.Lock();
    m_fAutoRefresh = ( fEnable ? VARIANT_TRUE : VARIANT_FALSE );
    m_lock.Unlock();

    return S_OK;
}

STDMETHODIMP CNDNCDirectory::Connect(
    IN  VARIANT_BOOL fSecure
    )
// Connect to the server, using secure port or normal port.
{
    LOG((MSP_TRACE, "CNDNCDirectory::Connect - enter"));

    CLock Lock(m_lock);

    if ( m_ldap != NULL )
    {
        LOG((MSP_ERROR, "already connected."));

        return RND_ALREADY_CONNECTED;
    }

    if ( m_pServerName == NULL )
    {
        LOG((MSP_ERROR, "No server specified."));

        return RND_NULL_SERVER_NAME;
    }

    if ( m_pServiceDnsName == NULL )
    {
        LOG((MSP_ERROR, "No serviceDnsName available; "
                      "Init should have failed and this object "
                      "should not exist."));        
    
        return E_UNEXPECTED;
    }

    // ZoltanS: either VARIANT_TRUE or TRUE will work
    // in case the caller doesn't know better

    if (fSecure)
    {
        // the port is flipped from regular port to ssl port.
        m_wPort = GetOtherPort(m_wPort);
        m_IsSsl = TRUE;
    }


    HRESULT hr = TryServer( m_wPort, m_pServiceDnsName );

    if ( FAILED(hr) )
    {
        if( fSecure == VARIANT_TRUE )
        {
            hr = E_INVALIDARG;
        }

        LOG((MSP_ERROR, "CNDNCDirectory::Connect - "
                "TryServer failed - exit 0x%08x", hr));

        return hr;
    }

    //
    // find out which interface we use to reach this server, to make sure
    // we use that interface whenever we publish our own IP address
    // If this fails we will not be able to publish anything, so fail!
    //

    hr = DiscoverInterface();

    if ( FAILED(hr) )
    {
        if( m_ldap)
        {
            ldap_unbind(m_ldap);
            m_ldap = NULL;
        }

        if( fSecure == VARIANT_TRUE )
        {
            hr = E_INVALIDARG;
        }

        LOG((MSP_ERROR, "CNDNCDirectory::Connect - "
                "DiscoverInterface failed - exit 0x%08x", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CNDNCDirectory::Connect - exit S_OK"));

    return S_OK;
}

HRESULT CNDNCDirectory::DiscoverInterface(void)
{
    LOG((MSP_INFO, "CNDNCDirectory::DiscoverInterface - enter"));

    //
    // Winsock must be initialized at this point.
    //

    //
    // Get the IP address of the server we're using
    //

    DWORD dwIP; // The IP address of the destination ILS server

    HRESULT hr = ResolveHostName(0, m_pServerName, NULL, &dwIP);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::DiscoverInterface - "
            "can't resolve host name - "
            "strange, because we could connect! - exit 0x%08x", hr));

        return hr;
    }

    //
    // allocate a "fake" control socket
    //

    SOCKET hSocket = WSASocket(AF_INET,            // af
                              SOCK_DGRAM,         // type
                              IPPROTO_IP,         // protocol
                              NULL,               // lpProtocolInfo
                              0,                  // g
                              0                   // dwFlags
                              );

    if ( hSocket == INVALID_SOCKET )
    {
        hr = HRESULT_FROM_ERROR_CODE(WSAGetLastError());

        LOG((MSP_ERROR, "CNDNCDirectory::DiscoverInterface - "
            "WSASocket gave an invalid socket - exit 0x%08x", hr));

        return hr;
    }

    //
    // Query for the interface address based on destination.
    //

    SOCKADDR_IN DestAddr;
    DestAddr.sin_family         = AF_INET;
    DestAddr.sin_port           = 0;
    DestAddr.sin_addr.s_addr    = dwIP;

    SOCKADDR_IN LocAddr;

    DWORD dwStatus;
    DWORD dwLocAddrSize = sizeof(SOCKADDR_IN);
    DWORD dwNumBytesReturned = 0;

    dwStatus = WSAIoctl(
            hSocket,                     // SOCKET s
            SIO_ROUTING_INTERFACE_QUERY, // DWORD dwIoControlCode
            &DestAddr,                   // LPVOID lpvInBuffer
            sizeof(SOCKADDR_IN),         // DWORD cbInBuffer
            &LocAddr,                    // LPVOID lpvOUTBuffer
            dwLocAddrSize,               // DWORD cbOUTBuffer
            &dwNumBytesReturned,         // LPDWORD lpcbBytesReturned
            NULL,                        // LPWSAOVERLAPPED lpOverlapped
            NULL                         // LPWSAOVERLAPPED_COMPLETION_ROUTINE lpComplROUTINE
            );

    //
    // Don't close the socket yet, because the closesocket() call will
    // overwrite the WSAGetLastError value in the failure case!
    //
    // Check for error and then close the socket.
    //

    if ( dwStatus == SOCKET_ERROR )
    {
	    hr = HRESULT_FROM_ERROR_CODE(WSAGetLastError());

        LOG((MSP_ERROR, "CNDNCDirectory::DiscoverInterface - "
            "WSAIoctl failed - exit 0x%08x", hr));

        closesocket(hSocket);

        return hr;
    } 

    closesocket(hSocket);

    //
    // Success - save the returned address in our member variable.
    // Stored in network byte order.
    //

    m_dwInterfaceAddress = LocAddr.sin_addr.s_addr;

    LOG((MSP_INFO, "CNDNCDirectory::DiscoverInterface - exit S_OK"));
    return S_OK;
}


//
// ITDirectory::Bind
//
// Bind to the server.
//
// Currently recognized flags:
//
//    RENDBIND_AUTHENTICATE       0x00000001
//    RENDBIND_DEFAULTDOMAINNAME  0x00000002
//    RENDBIND_DEFAULTUSERNAME    0x00000004
//    RENDBIND_DEFAULTPASSWORD    0x00000008
//
// "Meta-flags" for convenience:
//    RENDBIND_DEFAULTCREDENTIALS 0x0000000e
//
//
// All of this together means that the following three
// forms are all equivalent:
//
// BSTR es = SysAllocString(L"");
// hr = pITDirectory->Bind(es, es, es, RENDBIND_AUTHENTICATE |
//                                     RENDBIND_DEFAULTCREDENTIALS);
// SysFreeString(es);
//
//
// BSTR es = SysAllocString(L"");
// hr = pITDirectory->Bind(es, es, es, RENDBIND_AUTHENTICATE      |
//                                     RENDBIND_DEFAULTDOMAINNAME |
//                                     RENDBIND_DEFAULTUSERNAME   |
//                                     RENDBIND_DEFAULTPASSWORD);
// SysFreeString(es);
//
//
// hr = pITDirectory->Bind(NULL, NULL, NULL, RENDBIND_AUTHENTICATE);
//
//

STDMETHODIMP CNDNCDirectory::Bind (
    IN  BSTR pDomainName,
    IN  BSTR pUserName,
    IN  BSTR pPassword,
    IN  long lFlags
    )
{
    LOG((MSP_TRACE, "CNDNCDirectory Bind - enter"));

    //
    // Determine if we should authenticate.
    //

    BOOL fAuthenticate = FALSE;

    if ( lFlags & RENDBIND_AUTHENTICATE )
    {
        fAuthenticate = TRUE;
    }

    //
    // For scripting compatibility, force string parameters to NULL based
    // on flags.
    //

    if ( lFlags & RENDBIND_DEFAULTDOMAINNAME )
    {
        pDomainName = NULL;
    }
       
    if ( lFlags & RENDBIND_DEFAULTUSERNAME )
    {
        pUserName = NULL;
    }

    if ( lFlags & RENDBIND_DEFAULTPASSWORD )
    {
        pPassword = NULL;
    }

    LOG((MSP_INFO, "Bind parameters: domain: `%S' user: `%S' "
                  "authenticate: %S)",
        (pDomainName)   ? pDomainName : L"<null>",
        (pUserName)     ? pUserName   : L"<null>",
        (fAuthenticate) ? L"yes"      : L"no"));

    //
    // All flags processed -- lock and proceed with bind if connected.
    //
    
    CLock Lock(m_lock);

    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "not connected."));
        return RND_NOT_CONNECTED;
    }

    //
    // ZoltanS: check the arguments. NULL has meaning in each case, so they are
    // OK for now. In each case we want to check any length string, so we
    // specify (UINT) -1 as the length.
    //

    if ( (pDomainName != NULL) && IsBadStringPtr(pDomainName, (UINT) -1 ) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::Bind: bad non-NULL pDomainName argument"));
        return E_POINTER;
    }
    
    if ( (pUserName != NULL) && IsBadStringPtr(pUserName, (UINT) -1 ) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::Bind: bad non-NULL pUserName argument"));
        return E_POINTER;
    }

    if ( (pPassword != NULL) && IsBadStringPtr(pPassword, (UINT) -1 ) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::Bind: bad non-NULL pPassword argument"));
        return E_POINTER;
    }

    ULONG res;

    if ( m_IsSsl || (!fAuthenticate) )
    {
        // if encrypted or no secure authentication is required,
        // simple bind is sufficient

        // ldap_simple_bind_s does not use sspi to get default credentials. We are
        // just specifying what we will actually pass on the wire.

        if (pPassword == NULL)
        {
            LOG((MSP_ERROR, "invalid Bind parameters: no password specified"));
            return E_INVALIDARG;
        }

        WCHAR * wszFullName;

        if ( (pDomainName == NULL) && (pUserName == NULL) )
        {
            // No domain / user doesn't make sense.
            LOG((MSP_ERROR, "invalid Bind paramters: domain and user not specified"));
            return E_INVALIDARG;
        }
        else if (pDomainName == NULL)
        {
            // username only is okay
            wszFullName = pUserName;
        }
        else if (pUserName == NULL)
        {
            // It doesn't make sense to specify domain but not user...
            LOG((MSP_ERROR, "invalid Bind paramters: domain specified but not user"));
            return E_INVALIDARG;
        }
        else
        {
            // We need domain\user. Allocate a string and sprintf into it.
            // The + 2 is for the "\" and for the null termination.

            wszFullName = new WCHAR[wcslen(pDomainName) + wcslen(pUserName) + 2];
            BAIL_IF_NULL(wszFullName, E_OUTOFMEMORY);
        
            wsprintf(wszFullName, L"%s\\%s", pDomainName, pUserName);
        }

        //
        // Do the simple bind.
        //

        res = ldap_simple_bind_s(m_ldap, wszFullName, pPassword);

        //
        // If we constructed the full name string, we now need to delete it.
        //

        if (wszFullName != pUserName)
        {
            delete wszFullName;
        }

        //
        // Bail if the simple bind failed.
        //

        BAIL_IF_LDAP_FAIL(res, "ldap simple bind");
    }
    else    // try an SSPI bind
    {
        // ZoltanS Note: the ldap bind code does not process NULL, NULL, NULL
        // in the SEC_WINNT_AUTH_IDENTITY blob, therefore it is special-cased.

        // ZoltanS: We used to use LDAP_AUTH_NTLM; now we use
        // LDAP_AUTH_NEGOTIATE to make sure we use the right domain for the
        // bind.

        if ( pDomainName || pUserName || pPassword )
        {
            // fill the credential structure
            SEC_WINNT_AUTH_IDENTITY AuthI;

            AuthI.User = (PTCHAR)pUserName;
            AuthI.UserLength = (pUserName == NULL)? 0: wcslen(pUserName);
            AuthI.Domain = (PTCHAR)pDomainName;
            AuthI.DomainLength = (pDomainName == NULL)? 0: wcslen(pDomainName);
            AuthI.Password = (PTCHAR)pPassword;
            AuthI.PasswordLength = (pPassword == NULL)? 0: wcslen(pPassword);
            AuthI.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

            res = ldap_bind_s(m_ldap, NULL, (TCHAR*)(&AuthI), LDAP_AUTH_NEGOTIATE);
            BAIL_IF_LDAP_FAIL(res, "bind with authentication");
        }
        else
        {
            // Otherwise we've come in with NULL, NULL, NULL - 
            // pass in NULL, NULL. The reason do this is that ldap bind code 
            // does not process NULL, NULL, NULL in the
            // SEC_WINNT_AUTH_IDENTITY blob !!!
            ULONG res = ldap_bind_s(m_ldap, NULL, NULL, LDAP_AUTH_NEGOTIATE);
            BAIL_IF_LDAP_FAIL(res, "bind with NULL NULL NULL");
        }
    }

    LOG((MSP_TRACE, "CNDNCDirectory::Bind - exiting OK"));
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// ITDirectory::AddDirectoryObject
//
// Return values:
//      Value               Where defined       What it means
//      -----               -------------       -------------
//      RND_NOT_CONNECTED   .\rnderr.h          ::Connect not yet called
//      E_POINTER           sdk\inc\winerror.h  pDirectoryObject is a bad pointer
//      other from AddConference
//      other from AddUser
//

STDMETHODIMP CNDNCDirectory::AddDirectoryObject (
    IN  ITDirectoryObject *pDirectoryObject
    )
// publish a new object to the server.
{
    if ( IsBadReadPtr(pDirectoryObject, sizeof(ITDirectoryObject) ) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::AddDirectoryObject - "
            "bad directory object pointer - returning E_POINTER"));

        return E_POINTER;
    }

    CLock Lock(m_lock);
    
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "CNDNCDirectory::AddDirectoryObject - not connected."));

        return RND_NOT_CONNECTED;
    }

    HRESULT hr;
    DIRECTORY_OBJECT_TYPE type;

    hr = pDirectoryObject->get_ObjectType(&type);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::AddDirectoryObject - "
            "can't get object type; returning 0x%08x", hr));

        return hr;
    }

    switch (type)
    {
    case OT_CONFERENCE:
        hr = AddConference(pDirectoryObject, FALSE);
        break;

    case OT_USER:
        hr = AddUser(pDirectoryObject, FALSE);
        break;
    }
    return hr;
}

STDMETHODIMP CNDNCDirectory::ModifyDirectoryObject (
    IN  ITDirectoryObject *pDirectoryObject
    )
// modify an object on the server.
{
    if ( IsBadReadPtr(pDirectoryObject, sizeof(ITDirectoryObject) ) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::ModifyDirectoryObject - "
            "bad directory object pointer - returning E_POINTER"));

        return E_POINTER;
    }

    CLock Lock(m_lock);
    
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "CNDNCDirectory::ModifyDirectoryObject - not connected."));

        return RND_NOT_CONNECTED;
    }

    HRESULT hr;
    DIRECTORY_OBJECT_TYPE type;

    hr = pDirectoryObject->get_ObjectType(&type);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::ModifyDirectoryObject - "
            "can't get object type; returning 0x%08x", hr));

        return hr;
    }

    switch (type)
    {
    case OT_CONFERENCE:
        hr = AddConference(pDirectoryObject, TRUE);
        break;

    case OT_USER:
        hr = AddUser(pDirectoryObject, TRUE);
        break;
    }
    return hr;
}

STDMETHODIMP CNDNCDirectory::RefreshDirectoryObject (
    IN  ITDirectoryObject *pDirectoryObject
    )
// Refresh the TTL for the object and add the object to the refresh list
// if the autorefresh is enabled.
{
    if ( IsBadReadPtr(pDirectoryObject, sizeof(ITDirectoryObject) ) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::RefreshDirectoryObject - "
            "bad directory object pointer - returning E_POINTER"));

        return E_POINTER;
    }

    CLock Lock(m_lock);
    
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "CNDNCDirectory::RefreshDirectoryObject - not connected."));

        return RND_NOT_CONNECTED;
    }

    HRESULT hr;
    DIRECTORY_OBJECT_TYPE type;

    hr = pDirectoryObject->get_ObjectType(&type);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::RefreshDirectoryObject - "
            "can't get object type; returning 0x%08x", hr));

        return hr;
    }

    switch (type)
    {
    case OT_CONFERENCE:
        return S_OK;  // conferences do not need refresh.

    case OT_USER:
        hr = RefreshUser(pDirectoryObject);
        break;
    }
    return hr;
}

STDMETHODIMP CNDNCDirectory::DeleteDirectoryObject (
    IN  ITDirectoryObject *pDirectoryObject
    )
// delete an object on the server.
{
    if ( IsBadReadPtr(pDirectoryObject, sizeof(ITDirectoryObject) ) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::DeleteDirectoryObject - "
            "bad directory object pointer - returning E_POINTER"));

        return E_POINTER;
    }

    CLock Lock(m_lock);
    
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "CNDNCDirectory::DeleteDirectoryObject - not connected."));

        return RND_NOT_CONNECTED;
    }

    HRESULT hr;
    DIRECTORY_OBJECT_TYPE type;

    hr = pDirectoryObject->get_ObjectType(&type);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CNDNCDirectory::DeleteDirectoryObject - "
            "can't get object type; returning 0x%08x", hr));

        return hr;
    }

    switch (type)
    {
    case OT_CONFERENCE:
        hr = DeleteConference(pDirectoryObject);
        break;

    case OT_USER:
        hr = DeleteUser(pDirectoryObject);
        break;
    }
    return hr;
}

STDMETHODIMP CNDNCDirectory::get_DirectoryObjects (
    IN  DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
    IN  BSTR                    pName,
    OUT VARIANT *               pVariant
    )
// search for objects on the server.
{
    BAIL_IF_BAD_READ_PTR(pName, E_POINTER);
    BAIL_IF_BAD_WRITE_PTR(pVariant, E_POINTER);

    CLock Lock(m_lock);
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "not connected."));
        return RND_NOT_CONNECTED;
    }

    HRESULT hr;

    ITDirectoryObject **pObjects;
    DWORD dwSize;
    
    // search and create objects.
    hr = SearchObjects(DirectoryObjectType, pName, &pObjects, &dwSize);
    BAIL_IF_FAIL(hr, "Search for objects");

    // create a collection object that contains the objects.
    hr = CreateInterfaceCollection(dwSize,            // count
                                   &pObjects[0],      // begin ptr
                                   &pObjects[dwSize], // end ptr
                                   pVariant);         // return value

    for (DWORD i = 0; i < dwSize; i ++)
    {
        pObjects[i]->Release();
    }

    delete pObjects;

    BAIL_IF_FAIL(hr, "Create collection of directory objects");

    return hr;
}

STDMETHODIMP CNDNCDirectory::EnumerateDirectoryObjects (
    IN  DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
    IN  BSTR                    pName,
    OUT IEnumDirectoryObject ** ppEnumObject
    )
// search for the objects on the server.
{
    BAIL_IF_BAD_READ_PTR(pName, E_POINTER);
    BAIL_IF_BAD_WRITE_PTR(ppEnumObject, E_POINTER);

    CLock Lock(m_lock);
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "not connected."));
        return RND_NOT_CONNECTED;
    }

    HRESULT hr;

    ITDirectoryObject **pObjects;
    DWORD dwSize;
    
    // search and create objects.
    hr = SearchObjects(DirectoryObjectType, pName, &pObjects, &dwSize);
    BAIL_IF_FAIL(hr, "Search for objects");

    // create a enumerator object that contains the objects.
    hr = ::CreateDirectoryObjectEnumerator(
        &pObjects[0],
        &pObjects[dwSize],
        ppEnumObject
        );

    for (DWORD i = 0; i < dwSize; i ++)
    {
        pObjects[i]->Release();
    }

    delete pObjects;

    BAIL_IF_FAIL(hr, "Create enumerator of directory objects");

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// ILSConfig implementation
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNDNCDirectory::get_Port (
    OUT long *pPort
    )
// get the current port used in Ldap connection.
{
    if ( IsBadWritePtr(pPort, sizeof(long) ) )
    {
        LOG((MSP_ERROR, "Directory.get_Port, invalid pointer"));
    
        return E_POINTER;
    }

    CLock Lock(m_lock);

    *pPort = (long)m_wPort;

    return S_OK;
}

STDMETHODIMP CNDNCDirectory::put_Port (
    IN  long   Port
    )
// set the port the user wants to use.
{
    CLock Lock(m_lock);
    
    if (m_ldap != NULL)
    {
        LOG((MSP_ERROR, "already connected."));
        return RND_ALREADY_CONNECTED;
    }

    if (Port <= USHRT_MAX)
    {
        m_wPort = (WORD)Port;
        return S_OK;
    }
    return E_INVALIDARG;
}

/////////////////////////////////////////////////////////////////////////////
// ITDynamic interface
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CNDNCDirectory::Update(DWORD dwSecondsPassed)
// Update the TTL for object created in this directory. The worker thread
// sends a tick every minute.
{
    if ( ! m_lock.TryLock() )
    {
        return S_OK;
    }

    LOG((MSP_TRACE, "CNDNCDirectory::Update is called, delta: %d", dwSecondsPassed));

    //
    // Go through the table to see if anyone needs refresh.
    //

    for ( DWORD i = 0; i < m_RefreshTable.size(); i++ )
    {
        WCHAR * pDN   = m_RefreshTable[i].pDN;
        DWORD   dwTTL = m_RefreshTable[i].dwTTL;

        LOG((MSP_TRACE, "\tExamining user object: %S", pDN   ));
        LOG((MSP_TRACE, "\t\tTime remaining: %d",      dwTTL ));

        if ( dwTTL <= ( 2 * dwSecondsPassed ) )
        {
            //
            // refresh it if the TTL is going to expire within the next
            // two clicks
            //
        
            LOG((MSP_TRACE, "\t\t\tREFRESHING"));

            if ( SUCCEEDED( NDNCSetTTL( m_ldap, pDN, m_TTL) ) )
            {
                m_RefreshTable[i].dwTTL = m_TTL;
            }
            else
            {
                LOG((MSP_WARN, "\t\t\t\tRefresh failed; will try again next time"));
            }
        }
        else
        {
            //
            // Not about to expire right now so just keep track of the time before
            // it expires
            //

            LOG((MSP_TRACE, "\t\t\tdecrementing"));

            m_RefreshTable[i].dwTTL -= dwSecondsPassed;
        }
    }

    m_lock.Unlock();

    LOG((MSP_TRACE, "CNDNCDirectory::Update exit S_OK"));

    return S_OK;
}

typedef IDispatchImpl<ITNDNCDirectoryVtbl<CNDNCDirectory>, &IID_ITDirectory, &LIBID_RENDLib>    CTNDNCDirectory;
typedef IDispatchImpl<ITNDNCILSConfigVtbl<CNDNCDirectory>, &IID_ITILSConfig, &LIBID_RENDLib>    CTNDNCILSConfig;
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CNDNCDirectory::GetIDsOfNames
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP CNDNCDirectory::GetIDsOfNames(REFIID riid,
                                      LPOLESTR* rgszNames, 
                                      UINT cNames, 
                                      LCID lcid, 
                                      DISPID* rgdispid
                                      ) 
{ 
    LOG((MSP_TRACE, "CNDNCDirectory::GetIDsOfNames[%p] - enter. Name [%S]",this, *rgszNames));


    HRESULT hr = DISP_E_UNKNOWNNAME;



    //
    // See if the requsted method belongs to the default interface
    //

    hr = CTNDNCDirectory::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((MSP_TRACE, "CNDNCDirectory::GetIDsOfNames - found %S on CTNDNCDirectory", *rgszNames));
        rgdispid[0] |= IDISPDIRECTORY;
        return hr;
    }

    
    //
    // If not, then try the ITILSConfig base class
    //

    hr = CTNDNCILSConfig::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((MSP_TRACE, "CNDNCDirectory::GetIDsOfNames - found %S on CTNDNCILSConfig", *rgszNames));
        rgdispid[0] |= IDISPILSCONFIG;
        return hr;
    }

    LOG((MSP_ERROR, "CNDNCDirectory::GetIDsOfNames[%p] - finish. didn't find %S on our iterfaces",*rgszNames));

    return hr; 
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CNDNCDirectory::Invoke
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP CNDNCDirectory::Invoke(DISPID dispidMember, 
                              REFIID riid, 
                              LCID lcid, 
                              WORD wFlags, 
                              DISPPARAMS* pdispparams, 
                              VARIANT* pvarResult, 
                              EXCEPINFO* pexcepinfo, 
                              UINT* puArgErr
                             )
{
    LOG((MSP_TRACE, "CNDNCDirectory::Invoke[%p] - enter. dispidMember %lx",this, dispidMember));

    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    DWORD   dwInterface = (dispidMember & INTERFACEMASK);
   
   
    //
    // Call invoke for the required interface
    //

    switch (dwInterface)
    {
        case IDISPDIRECTORY:
        {
            hr = CTNDNCDirectory::Invoke(dispidMember, 
                                    riid, 
                                    lcid, 
                                    wFlags, 
                                    pdispparams,
                                    pvarResult, 
                                    pexcepinfo, 
                                    puArgErr
                                   );
        
            LOG((MSP_TRACE, "CNDNCDirectory::Invoke - ITDirectory"));

            break;
        }

        case IDISPILSCONFIG:
        {
            hr = CTNDNCILSConfig::Invoke(dispidMember, 
                                        riid, 
                                        lcid, 
                                        wFlags, 
                                        pdispparams,
                                        pvarResult, 
                                        pexcepinfo, 
                                        puArgErr
                                       );

            LOG((MSP_TRACE, "CNDNCDirectory::Invoke - ITILSConfig"));

            break;
        }

    } // end switch (dwInterface)

    
    LOG((MSP_TRACE, "CNDNCDirectory::Invoke[%p] - finish. hr = %lx", hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndldap.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    rndldap.cpp

Abstract:

    This module contains implementation of ldap helper functions.


--*/

#include "stdafx.h"

#include "rndldap.h"
#include "ntldap.h"


HRESULT GetAttributeValue(
    IN  LDAP *          pLdap,
    IN  LDAPMessage *   pEntry,
    IN  const WCHAR *   pName,
    OUT BSTR *          pValue
    )
{
    *pValue = NULL;

    TCHAR **p = ldap_get_values(pLdap, pEntry, (WCHAR *)pName);
    if (p != NULL)
    {
        if (p[0] != NULL)
        {
            *pValue = SysAllocString(p[0]);
        }
        ldap_value_free(p);
    }

    return (*pValue == NULL) ? E_FAIL : S_OK;
}

HRESULT GetAttributeValueBer(
    IN  LDAP *          pLdap,
    IN  LDAPMessage *   pEntry,
    IN  const WCHAR *   pName,
    OUT char **         pValue,
    OUT DWORD *         pdwSize
    )
{
    *pValue = NULL;

    struct berval **p = ldap_get_values_len(pLdap, pEntry, (WCHAR *)pName);
    if (p != NULL)
    {
        if (p[0] != NULL)
        {
            *pValue = new CHAR[p[0]->bv_len];
            if (*pValue == NULL)
            {
                return E_OUTOFMEMORY;
            }
            memcpy(*pValue, p[0]->bv_val, p[0]->bv_len);
            *pdwSize = p[0]->bv_len;
        }
        ldap_value_free_len(p);
    }
    return (*pValue == NULL) ? E_FAIL : S_OK;
}

HRESULT GetNamingContext(LDAP *hLdap, TCHAR **ppNamingContext)
{
    // send a search (base level, base dn = "", filter = "objectclass=*")
    // ask only for the defaultNamingContext attribute
    PTCHAR  Attributes[] = {(WCHAR *)DEFAULT_NAMING_CONTEXT, NULL};

    LDAPMessage *SearchResult;

    ULONG res = DoLdapSearch(
                hLdap,              // ldap handle
                L"",                // empty base dn
                LDAP_SCOPE_BASE,    // base level search
                (WCHAR *)ANY_OBJECT_CLASS,   // instance of any object class
                Attributes,         // array of attribute names
                FALSE,              // also return the attribute values
                &SearchResult       // search results
                );

    BAIL_IF_LDAP_FAIL(res, "Search for oganization");

    // associate the ldap handle with the search message holder, so that the
    // search message may be released when the instance goes out of scope
    CLdapMsgPtr MessageHolder(SearchResult);

    TCHAR **NamingContext;

    LDAPMessage    *EntryMessage = ldap_first_entry(hLdap, SearchResult);
    while ( NULL != EntryMessage )
    {
        // look for the value for the namingContexts attribute
        NamingContext = ldap_get_values(
            hLdap, 
            EntryMessage, 
            (WCHAR *)DEFAULT_NAMING_CONTEXT
            );

        // the first entry contains the naming context and its a single
        // value(null terminated) if a value is found, create memory for
        // the directory path, set the dir path length
        if ( (NULL != NamingContext)    &&
             (NULL != NamingContext[0]) &&
             (NULL == NamingContext[1])  )
        {
            // the naming context value is released when the ValueHolder
            // instance goes out of scope
            CLdapValuePtr  ValueHolder(NamingContext);

            *ppNamingContext = new TCHAR [lstrlen(NamingContext[0]) + 1];

            BAIL_IF_NULL(*ppNamingContext, E_OUTOFMEMORY);

            lstrcpy(*ppNamingContext, NamingContext[0]);

            // return success
            return S_OK;
        }

        // Get next entry.
        EntryMessage = ldap_next_entry(hLdap, EntryMessage);
    }

    // none found, return error
    return HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
}

ULONG
DoLdapSearch (
        LDAP            *ld,
        PWCHAR          base,
        ULONG           scope,
        PWCHAR          filter,
        PWCHAR          attrs[],
        ULONG           attrsonly,
        LDAPMessage     **res,
		BOOL			bSACL /*=TRUE */
        )
{
    LDAP_TIMEVAL Timeout;
    Timeout.tv_sec = REND_LDAP_TIMELIMIT;
    Timeout.tv_usec = 0;

	//
	// Without SACLs
	//
	SECURITY_INFORMATION seInfo = 
		DACL_SECURITY_INFORMATION |
		OWNER_SECURITY_INFORMATION |
		GROUP_SECURITY_INFORMATION;

	//
	// Ber val
	//
	BYTE berValue[2*sizeof(ULONG)];
	berValue[0] = 0x30;
	berValue[1] = 0x03;
	berValue[2] = 0x02;
	berValue[3] = 0x01;
	berValue[4] = (BYTE)(seInfo & 0xF);

	//
	// LDAP server control
	//
	LDAPControlW seInfoControl = {
		LDAP_SERVER_SD_FLAGS_OID_W,
		{5, (PCHAR)berValue},
		TRUE
		};

	//
	// LDAP Server controls list
	//
	PLDAPControlW	serverControls[2] = { &seInfoControl, NULL};
	PLDAPControlW*  pServerControls = NULL;
	if( !bSACL )
	{
		pServerControls = serverControls;
	}

    ULONG ulRes = ldap_search_ext_sW(ld,
                                     base,
                                     scope,
                                     filter,
                                     attrs,
                                     attrsonly,
                                     pServerControls, // server controls
                                     NULL,      // client controls
                                     &Timeout,  // timeout value
                                     0,         // maximum size
                                     res);

    //
    // The ldap_search* APIs are quirky in that they require you to free the
    // result even if the call fails. ldap_msgfree() checks its argument, so
    // this also doesn't break if the result *wasn't* left around. This is
    // inconsistent with pretty much all other Windows system APIs; to keep
    // from obfuscating the callers of DoLdapSearch, we free the result here
    // in the failure case. That way, callers can treat DoLdapSearch like any
    // other function that cleans up after itself on failure.
    //
    // Some callers use smart pointers that would free the message on destruction,
    // and some do not. Therefore we set *res to NULL after freeing *res, to
    // protect ourselves in either case. Any subsequent ldap_msgfree(NULL) will
    // do nothing (and will not fault).
    //

    if ( ulRes != LDAP_SUCCESS )
    {
        ldap_msgfree( *res );
        *res = NULL;
    }

    return ulRes;
}

//
// Translates the result of an ldap_result call to an ldap error code.
//

ULONG LdapErrorFromLdapResult(ULONG res, LDAPMessage * pResultMessage)
{
    ULONG ulCode;

    if ( res == 0 )
    {
        ulCode = LDAP_TIMEOUT;
    }
    else if ( res == (ULONG) -1 )
    {
        ulCode = LDAP_LOCAL_ERROR;
    }
    else
    {
        // ulCode = LDAP_SUCCESS;
        ulCode = pResultMessage->lm_returncode;
    }

    ldap_msgfree( pResultMessage );

    return ulCode;
}

ULONG 
DoLdapAdd (
           LDAP *ld,
           PWCHAR dn,
           LDAPModW *attrs[]
          )
{
    //
    // Ask to add an object.We get back an error/success code and a
    // message number so that we can refer to this pending message.
    //

    ULONG ulMessageNumber;
    
    ULONG res1 = ldap_add_extW(ld,
                               dn,
                               attrs,
                               NULL, // server controls
                               NULL, // client controls
                               &ulMessageNumber);

    BAIL_IF_LDAP_FAIL(res1, "ldap_add_extW");

    //
    // Wait for the result, specifying a timeout. We get
    // back an error/success code and a result message.
    //

    LDAP_TIMEVAL Timeout;
	Timeout.tv_sec = REND_LDAP_TIMELIMIT;
	Timeout.tv_usec = 0;

    LDAPMessage * pResultMessage;

    ULONG res2 = ldap_result(ld,
                             ulMessageNumber,
                             LDAP_MSG_ALL,
                             &Timeout,
                             &pResultMessage);

    //
    // Extract return code and free message.
    //

    return LdapErrorFromLdapResult(res2, pResultMessage);
}

ULONG 
DoLdapModify (
              BOOL fChase,
              LDAP *ld,
              PWCHAR dn,
              LDAPModW *attrs[],
              BOOL			bSACL /*=TRUE */
             )
{
    //
    // Chase referrals. These is only used if fChase is set, but we must not
    // stick them in an "if" block or they will not have appropriate scope.
    //

    LDAPControlW control;
    LDAPControlW * controls [] = {&control, NULL};
    ULONG ulValue = LDAP_CHASE_EXTERNAL_REFERRALS | LDAP_CHASE_SUBORDINATE_REFERRALS;

    if ( fChase )
    {
        control.ldctl_iscritical = 1;
        control.ldctl_oid          = LDAP_CONTROL_REFERRALS_W;
        control.ldctl_value.bv_len = sizeof(ULONG);
        control.ldctl_value.bv_val = (char *) &ulValue;
    }

  	//
	// Without SACLs
	//
	SECURITY_INFORMATION seInfo = DACL_SECURITY_INFORMATION ;

	//
	// Ber val
	//
	BYTE berValue[2*sizeof(ULONG)];
	berValue[0] = 0x30;
	berValue[1] = 0x03;
	berValue[2] = 0x02;
	berValue[3] = 0x01;
	berValue[4] = (BYTE)(seInfo & 0xF);

	//
	// LDAP server control
	//
	LDAPControlW seInfoControl = {
		LDAP_SERVER_SD_FLAGS_OID_W,
		{5, (PCHAR)berValue},
		TRUE
		};

	//
	// LDAP Server controls list
	//
	PLDAPControlW	serverControls[2] = { &seInfoControl, NULL};
	PLDAPControlW*  pServerControls = NULL;
	if( !bSACL )
	{
		pServerControls = serverControls;
	}


    //
    // Ask to modify an object.We get back an error/success code and a
    // message number so that we can refer to this pending message.
    //

    ULONG ulMessageNumber;
    
    ULONG res1 = ldap_modify_extW(ld,
                                  dn,
                                  attrs,
                                  pServerControls, // server controls
                                  fChase ? controls : NULL, // client controls
                                  &ulMessageNumber);

    BAIL_IF_LDAP_FAIL(res1, "ldap_modify_extW");

    //
    // Wait for the result, specifying a timeout. We get
    // back an error/success code and a result message.
    //

    LDAP_TIMEVAL Timeout;
	Timeout.tv_sec = REND_LDAP_TIMELIMIT;
	Timeout.tv_usec = 0;

    LDAPMessage * pResultMessage;

    ULONG res2 = ldap_result(ld,
                             ulMessageNumber,
                             LDAP_MSG_ALL,
                             &Timeout,
                             &pResultMessage);

    //
    // Extract return code and free message.
    //

    return LdapErrorFromLdapResult(res2, pResultMessage);
}

ULONG 
DoLdapDelete (
           LDAP *ld,
           PWCHAR dn
          )
{
    //
    // Ask to delete an object.We get back an error/success code and a
    // message number so that we can refer to this pending message.
    //

    ULONG ulMessageNumber;
    
    ULONG res1 = ldap_delete_extW(ld,
                                  dn,
                                  NULL, // server controls
                                  NULL, // client controls
                                  &ulMessageNumber);

    BAIL_IF_LDAP_FAIL(res1, "ldap_delete_extW");

    //
    // Wait for the result, specifying a timeout. We get
    // back an error/success code and a result message.
    //

    LDAP_TIMEVAL Timeout;
	Timeout.tv_sec = REND_LDAP_TIMELIMIT;
	Timeout.tv_usec = 0;

    LDAPMessage * pResultMessage;

    ULONG res2 = ldap_result(ld,
                             ulMessageNumber,
                             LDAP_MSG_ALL,
                             &Timeout,
                             &pResultMessage);

    //
    // Extract return code and free message.
    //

    return LdapErrorFromLdapResult(res2, pResultMessage);
}

HRESULT SetTTL(
    IN LDAP *   pLdap, 
    IN const WCHAR *  pDN, 
    IN DWORD    dwTTL
    )
/*++

Routine Description:

    Set the TTL of a dynamic object for either ILS or NDNC.

Arguments:
    
    pLdap - The Ldap connection.

    pDN    - The DN of a object on the ILS server.

    dwTTL  - The time to live value.

Return Value:

    HRESULT.

--*/
{
    TCHAR       strTTL[32];     // The attribute value is a DWORD in string.
    wsprintf(strTTL, _T("%d"), dwTTL);
    
    TCHAR * ttl[] = {strTTL, NULL};

    LDAPMod     mod;         // The modify sturctures used by LDAP
    mod.mod_values   = ttl;
    mod.mod_op       = LDAP_MOD_REPLACE;
    mod.mod_type     = (WCHAR *)ENTRYTTL;

    LDAPMod* mods[] = {&mod, NULL};  // only one attribute is modified.
    
    LOG((MSP_INFO, "setting TTL for %S", pDN));

    BAIL_IF_LDAP_FAIL(DoLdapModify(FALSE, pLdap, (WCHAR *)pDN, mods), "set TTL");

    return S_OK;
}

HRESULT UglyIPtoIP(
    BSTR    pUglyIP,
    BSTR *  pIP
    )
// This function converts NM's IP address format to the right format.
{
#define IPADDRLEN   16
    WCHAR buffer[IPADDRLEN + 1];
    DWORD dwIP;

    dwIP = _wtoi(pUglyIP);
    if (dwIP == 0)
    {
        return E_FAIL;
    }

    dwIP = ntohl(dwIP);

    // format the four bytes in the dword into an ip address string
    swprintf(buffer, L"%d.%d.%d.%d",
            HIBYTE(HIWORD(dwIP)),
            LOBYTE(HIWORD(dwIP)),
            HIBYTE(LOWORD(dwIP)),
            LOBYTE(LOWORD(dwIP))
            );

    *pIP = SysAllocString(buffer);

    BAIL_IF_NULL(*pIP, E_OUTOFMEMORY);

    return S_OK;
}

HRESULT ParseUserName(
    BSTR    pName,
    BSTR *  ppAddress
    )
{
    WCHAR * pCloseBracket = wcschr(pName, CLOSE_BRACKET_CHARACTER);

    if ( pCloseBracket == NULL )
    {
        // this is not the format generated by us.
        return S_FALSE;
    }

    *ppAddress = SysAllocString(pCloseBracket + 1);

    BAIL_IF_NULL(*ppAddress, E_OUTOFMEMORY);

    *pCloseBracket = NULL_CHARACTER;

    return S_OK;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndobjsf.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    rndobjsf.cpp

Abstract:

--*/

#include <stdafx.h>
#include "rndobjsf.h"

CComAutoCriticalSection CObjectWithSite::s_ObjectWithSiteCritSection;
CObjectWithSite::EnValidation CObjectWithSite::s_enValidation = CObjectWithSite::UNVALIDATED;

CComAutoCriticalSection CObjectSafeImpl::s_CritSection;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndnt.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    rndnt.h

Abstract:

    Definitions for CNTDirectory class that handles NTDS access.

Author:

    Mu Han (muhan)   12-5-1997

--*/

#ifndef __RNDNT_H
#define __RNDNT_H

#pragma once

#include "rndcommc.h"
#include "rndobjsf.h"
#include "rndutil.h"

/////////////////////////////////////////////////////////////////////////////
//  CNTDirectory
/////////////////////////////////////////////////////////////////////////////
const WCHAR DEFAULT_DS_SERVER[]      = L"";
const WCHAR DS_USER_FILTER_FORMAT[]  = L"(&(SamAccountName=%s)(objectclass=user)(!(objectclass=computer)))";

// The following are no longer used:
// const WCHAR USERS_CONTAINER[]        = L"cn=Users,";
// const WCHAR MEETINGSS_CONTAINER[]    = L"cn=Meetings,cn=System,";
// const WCHAR DS_CONF_DN_FORMAT[]      = L"cn=%s,cn=Meetings,cn=system,%s";

const WORD GLOBAL_CATALOG_PORT = 3268;

class CNTDirectory : 
    public CComDualImpl<ITDirectory, &IID_ITDirectory, &LIBID_RENDLib>, 
    public CComObjectRootEx<CComObjectThreadModel>,
    public CObjectSafeImpl
{

    DECLARE_GET_CONTROLLING_UNKNOWN()

public:

    BEGIN_COM_MAP(CNTDirectory)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ITDirectory)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
    END_COM_MAP()

    //DECLARE_NOT_AGGREGATABLE(CNTDirectory) 
    // Remove the comment from the line above if you don't want your object to 
    // support aggregation. 

// ITDirectory
    STDMETHOD (get_DirectoryType) (
        OUT DIRECTORY_TYPE *  pDirectoryType
        );

    STDMETHOD (get_DisplayName) (
        OUT BSTR *ppName
        );

    STDMETHOD (get_IsDynamic) (
        OUT VARIANT_BOOL *pfDynamic
        );

    STDMETHOD (get_DefaultObjectTTL) (
        OUT long *pTTL   // in seconds
        );

    STDMETHOD (put_DefaultObjectTTL) (
        IN  long TTL     // in sechods
        );

    STDMETHOD (EnableAutoRefresh) (
        IN  VARIANT_BOOL fEnable
        );

    STDMETHOD (Connect) (
        IN  VARIANT_BOOL fSecure
        );

    STDMETHOD (Bind) (
        IN  BSTR pDomainName,
        IN  BSTR pUserName,
        IN  BSTR pPassword,
        IN  long lFlags
        );

    STDMETHOD (AddDirectoryObject) (
        IN  ITDirectoryObject *pDirectoryObject
        );

    STDMETHOD (ModifyDirectoryObject) (
        IN  ITDirectoryObject *pDirectoryObject
        );

    STDMETHOD (RefreshDirectoryObject) (
        IN  ITDirectoryObject *pDirectoryObject
        );

    STDMETHOD (DeleteDirectoryObject) (
        IN  ITDirectoryObject *pDirectoryObject
        );

    STDMETHOD (get_DirectoryObjects) (
        IN  DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
        IN  BSTR                    pName,
        OUT VARIANT *               pVariant
        );

    STDMETHOD (EnumerateDirectoryObjects) (
        IN  DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
        IN  BSTR                    pName,
        OUT IEnumDirectoryObject ** ppEnumObject
        );

public:
    CNTDirectory()
        : m_Type(DT_NTDS),
          m_ldap(NULL),
          m_ldapNonGC(NULL),
          m_NamingContext(NULL),
          m_IsSsl(FALSE),
          m_wPort(GLOBAL_CATALOG_PORT),
          m_pFTM(NULL)
    {}

    ~CNTDirectory()
    {
        if ( m_ldap )
        {
            ldap_unbind(m_ldap);
        }

        if ( m_ldapNonGC )
        {
            ldap_unbind(m_ldapNonGC);
        }

        if ( m_pFTM )
        {
            m_pFTM->Release();
        }

        delete m_NamingContext;
    }

    HRESULT FinalConstruct(void);

protected:
    HRESULT LdapSearchUser(
        IN  TCHAR *         pName,
        OUT LDAPMessage **  ppLdapMsg
        );

    HRESULT MakeUserDNs(
        IN  TCHAR *             pName,
        OUT TCHAR ***           pppDNs,
        OUT DWORD *             pdwNumDNs
        );

    HRESULT AddUserIPPhone(
        IN  ITDirectoryObject *     pDirectoryObject
        );

    HRESULT DeleteUserIPPhone(
        IN  ITDirectoryObject *     pDirectoryObject
        );

    HRESULT CreateUser(
        IN  LDAPMessage *           pEntry,
        IN  ITDirectoryObject **    ppObject
        );

    HRESULT SearchUser(
        IN  BSTR                    pName,
        OUT ITDirectoryObject ***   pppDirectoryObject,
        OUT DWORD *                 pdwSize
        );

private:

    CCritSection    m_lock;

    DIRECTORY_TYPE  m_Type;
    
    LDAP *          m_ldap;
    LDAP *          m_ldapNonGC;

    TCHAR *         m_NamingContext;

    BOOL            m_IsSsl;
    WORD            m_wPort;

    IUnknown      * m_pFTM;          // pointer to the free threaded marshaler
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndndnc.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    rndndnc.h

Abstract:

    Definitions for CNDNCDirectory class that handles
    Non-Domain NC (Whistler ILS) access.

--*/

#ifndef __RNDNDNC_H
#define __RNDNDNC_H

#pragma once

#include "thread.h"
#include "rndobjsf.h"

//
// Constants.
//
// NDNCs only allow up to one "true year" for the TTL, thanks to the RFC.
//

const DWORD NDNC_MAX_TTL                 = 31557600;
const WCHAR NDNC_RTCONFERENCE[]          = L"msTAPI-RtConference";
const WCHAR NDNC_RTPERSON[]              = L"msTAPI-RtPerson";
const WCHAR NDNC_CONF_DN_FORMAT[]        = L"msTAPI-uid=%s,%s";
const WCHAR IPADDRESS_NDNC[]             = L"msTAPI-IpAddress";
const WCHAR TAPIUID_NDNC[]               = L"msTAPI-uid";
const WCHAR UIDEQUALS_NDNC[]             = L"msTAPI-uid=";

const WCHAR SERVICE_DNS_NAME_ATTRIBUTE[] = L"serviceDNSName";
const WCHAR NDNC_SERVICE_PUBLICATION_LOCATION[] =
                    L"CN=DefaultTAPIDirectory,CN=MicrosoftTAPI,CN=System,";

/////////////////////////////////////////////////////////////////////////////
//  CNDNCDirectory
/////////////////////////////////////////////////////////////////////////////

template <class T>
class  ITNDNCDirectoryVtbl : public ITDirectory
{
};

template <class T>
class  ITNDNCILSConfigVtbl : public ITILSConfig
{
};


class CNDNCDirectory :
    public CComDualImpl<ITNDNCDirectoryVtbl<CNDNCDirectory>, &IID_ITDirectory, &LIBID_RENDLib>, 
    public CComDualImpl<ITNDNCILSConfigVtbl<CNDNCDirectory>, &IID_ITILSConfig, &LIBID_RENDLib>, 
    public ITDynamicDirectory,
    public CComObjectRootEx<CComObjectThreadModel>,
    public CObjectSafeImpl
{

private:
    HRESULT AddConferenceComplete(
        IN BOOL       fModify,
        IN LDAP     * ldap,
        IN TCHAR   ** ppDN,
        IN LDAPMod ** mods
        );

public:

    BEGIN_COM_MAP(CNDNCDirectory)
        COM_INTERFACE_ENTRY2(IDispatch, ITDirectory)
        COM_INTERFACE_ENTRY(ITILSConfig)
        COM_INTERFACE_ENTRY(ITDirectory)
        COM_INTERFACE_ENTRY(ITDynamicDirectory)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CNDNCDirectory) 
    DECLARE_GET_CONTROLLING_UNKNOWN()

public:

// ITILSConfig
    STDMETHOD (get_Port) (
        OUT  long *Port
        );

    STDMETHOD (put_Port) (
        IN  long Port
        );

// ITDirectory
    STDMETHOD (get_DirectoryType) (
        OUT DIRECTORY_TYPE *  pDirectoryType
        );

    STDMETHOD (get_DisplayName) (
        OUT BSTR *ppName
        );

    STDMETHOD (get_IsDynamic) (
        OUT VARIANT_BOOL *pfDynamic
        );

    STDMETHOD (get_DefaultObjectTTL) (
        OUT long *pTTL   // in seconds
        );

    STDMETHOD (put_DefaultObjectTTL) (
        IN  long TTL     // in sechods
        );

    STDMETHOD (EnableAutoRefresh) (
        IN  VARIANT_BOOL fEnable
        );

    STDMETHOD (Connect)(
        IN  VARIANT_BOOL fSecure
        );

    STDMETHOD (Bind) (
        IN  BSTR pDomainName,
        IN  BSTR pUserName,
        IN  BSTR pPassword,
        IN  long lFlags
        );

    STDMETHOD (AddDirectoryObject) (
        IN  ITDirectoryObject *pDirectoryObject
        );

    STDMETHOD (ModifyDirectoryObject) (
        IN  ITDirectoryObject *pDirectoryObject
        );

    STDMETHOD (RefreshDirectoryObject) (
        IN  ITDirectoryObject *pDirectoryObject
        );

    STDMETHOD (DeleteDirectoryObject) (
        IN  ITDirectoryObject *pDirectoryObject
        );

    STDMETHOD (get_DirectoryObjects) (
        IN  DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
        IN  BSTR                    pName,
        OUT VARIANT *               pVariant
        );

    STDMETHOD (EnumerateDirectoryObjects) (
        IN  DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
        IN  BSTR                    pName,
        OUT IEnumDirectoryObject ** ppEnumObject
        );

    //
    // IDispatch  methods
    //

    STDMETHOD(GetIDsOfNames)(REFIID riid, 
                             LPOLESTR* rgszNames,
                             UINT cNames, 
                             LCID lcid, 
                             DISPID* rgdispid
                            );

    STDMETHOD(Invoke)(DISPID dispidMember, 
                      REFIID riid, 
                      LCID lcid,
                      WORD wFlags, 
                      DISPPARAMS* pdispparams, 
                      VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, 
                      UINT* puArgErr
                      );

// ITDynamicDirectory
    STDMETHOD(Update)(DWORD dwSecondsPassed);

public:
    CNDNCDirectory()
        : m_Type(DT_ILS),
          m_pServerName(NULL),
          m_pServiceDnsName(NULL),
          m_ldap(NULL),
          m_pContainer(NULL),
          m_IsSsl(FALSE),
          m_TTL(ILS_UPDATE_INTERVAL),
          m_fAutoRefresh(FALSE),
          m_dwInterfaceAddress(0),
          m_pFTM(NULL)
    {}

    virtual HRESULT FinalConstruct(void);

    ~CNDNCDirectory()
    {
        if ( m_pFTM )
        {
            m_pFTM->Release();
        }

        if (m_ldap)
        {
            ldap_unbind(m_ldap);
        }

        delete m_pServerName;
        delete m_pServiceDnsName;
        delete m_pContainer;

        //
        // We new'ed the DN strings in the refresh table. The destructor for
        // the table will be called after this destructor and will delete
        // the array itself.
        //

        for ( DWORD i = 0; i < m_RefreshTable.size(); i++ )
        {
            delete m_RefreshTable[i].pDN;
        }
    }

    HRESULT Init(
        IN const TCHAR * const  strServerName,
        IN const WORD           wPort
        );

    static const WCHAR * RTConferenceAttributeName(int attribute)
    { return s_RTConferenceAttributes[MeetingAttrIndex(attribute)]; }

    static const WCHAR * RTPersonAttributeName(int attribute)
    { return s_RTPersonAttributes[UserAttrIndex(attribute)]; }

private:
    HRESULT CrackDnsName(
        IN  WCHAR  * pDnsName,
        OUT WCHAR ** ppDcName
        );

    HRESULT OpenLdapConnection(
        IN  WCHAR  * pServerName,
        IN  WORD     wPort,
        OUT LDAP  ** phLdap
        );
        
    HRESULT GetNDNCLocationFromServer(
        IN WCHAR * pDcServerDnsName
        );
        
    HRESULT TryServer(
        IN  WORD    Port,
        IN  WCHAR * pServiceDnsName
        );

    HRESULT MakeConferenceDN(
        IN  TCHAR *             pName,
        OUT TCHAR **            ppDN
        );

    HRESULT MakeUserCN(
        IN  TCHAR *     pName,
        IN  TCHAR *     pAddress,
        OUT TCHAR **    ppCN,
        OUT DWORD *     pdwIP
        );

    HRESULT MakeUserDN(
        IN  TCHAR *     pCN,
        IN  DWORD       dwIP,
        OUT TCHAR **    ppDNRTPerson
        );

    HRESULT PublishRTPerson(
        IN TCHAR *  pCN,
        IN TCHAR *  pDN,
        IN TCHAR *  pIPAddress,
        IN DWORD    dwTTL,
        IN  BOOL fModify,
        IN char *   pSD,
        IN DWORD    dwSDSize
        );

    HRESULT AddConference(
        IN  ITDirectoryObject *pDirectoryObject,
        IN  BOOL fModify
        );

    HRESULT TestAclSafety(
        IN  char  * pSD,
        IN  DWORD   dwSDSize
        );

    HRESULT AddUser(
        IN  ITDirectoryObject *pDirectoryObject,
        IN  BOOL fModify
        );

    HRESULT DeleteConference(
        IN  ITDirectoryObject *pDirectoryObject
        );

    HRESULT DeleteUser(
        IN  ITDirectoryObject *pDirectoryObject
        );

    HRESULT RefreshUser(
        IN  ITDirectoryObject *pDirectoryObject
        );

    HRESULT CreateConference(
        IN  LDAPMessage *           pEntry,
        OUT ITDirectoryObject **    ppObject
        );

    HRESULT CreateUser(
        IN  LDAPMessage *           pEntry,
        IN  ITDirectoryObject **    ppObject
        );

    HRESULT SearchObjects(
        IN  DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
        IN  BSTR                    pName,
        OUT ITDirectoryObject ***   pppDirectoryObject,
        OUT DWORD *                 dwSize
        );

    HRESULT AddObjectToRefresh(
        IN  WCHAR *pDN,
        IN  long TTL
        );

    HRESULT RemoveObjectToRefresh(
        IN  WCHAR *pDN
        );

    HRESULT DiscoverInterface(void);

    HRESULT NDNCSetTTL(
        IN LDAP *   pLdap, 
        IN const WCHAR *  pDN, 
        IN DWORD    dwTTL
        );


private:
    static const WCHAR * const s_RTConferenceAttributes[];
    static const WCHAR * const s_RTPersonAttributes[];

    CCritSection    m_lock;

    DIRECTORY_TYPE  m_Type;
    TCHAR *         m_pServerName;
    WCHAR *         m_pServiceDnsName;
    WORD            m_wPort;

    LDAP *          m_ldap;
    TCHAR *         m_pContainer;
    BOOL            m_IsSsl;

    long            m_TTL;
    BOOL            m_fAutoRefresh;
    RefreshTable    m_RefreshTable;

    // the local IP we should use when publishing on this server
    // Stored in network byte order.
    DWORD           m_dwInterfaceAddress; 

    IUnknown      * m_pFTM;          // pointer to the free threaded marshaler
};

#endif // __RNDNDNC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndobjsf.h ===
/*++
Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    rndobjsf.h

Abstract:

    Definitions for CRendObjectSafety class.
--*/


#ifndef _REND_OBJECT_SAFETY_
#define _REND_OBJECT_SAFETY_

#define IDD_TAPI_SECURITY_DIALOG        500
#define IDC_SECURITY_WARNING_TEXT       502
#define IDC_DONOT_PROMPT_IN_THE_FUTURE  503
#define ID_YES                          505
#define ID_NO                           506
#define ID_YES_DONT_ASK_AGAIN           557

#define IDS_REND_SEC_PROMPT             91

#include <PromptedObjectSafety.h>
#include <ScrpScrtDlg.h>
#include <ObjectWithSite.h>

static const TCHAR gszCookieName[] = _T("rend");

class CRendObjectSafety : public CPromptedObjectSafety, public CObjectWithSite
{


public:

    //
    // call CObjectWithSite's constructor and pass in the cookie name
    //

    CRendObjectSafety()
        :CObjectWithSite(gszCookieName)
    {
    }


    //
    // implementing CPromptedObjectSafety's pure virtual method
    // if the page is not in the safe list, and this is the first 
    // time we are asking, prompt the user. act accordingly.
    // if the user chooses, mark the page safe for scripting (persistently)
    //
    
    virtual BOOL Ask()
    {

        //
        // if the object does not have a site pointer. we should not consider 
        // it to be safe. Do not prompt the user.
        //

        if ( !HaveSite() )
        {

          return FALSE;
        }


        EnValidation enCurrentValidation = GetValidation();
        
        //
        // if the page has not been validated, try to validate it.
        //

        if (UNVALIDATED == enCurrentValidation)
        {
            if( IsIntranet())
            {
                Validate(VALIDATED_SAFE);
                enCurrentValidation = GetValidation();
                return TRUE;
            }

           CScriptSecurityDialog *pDialog = new CScriptSecurityDialog;
       
           //
           // if succeeded displaying the dialog
           // validate the page based on user's input
           //
           
           if ( NULL != pDialog )
           {

               switch (pDialog->DoModalWithText(IDS_REND_SEC_PROMPT))
               {

                case ID_YES:

                    Validate(VALIDATED_SAFE);
                    break;

                case ID_NO:

                    Validate(VALIDATED_UNSAFE);
                    break;

                case ID_YES_DONT_ASK_AGAIN:

                    Validate(VALIDATED_SAFE_PERMANENT);
                    break;

                default:

                    break;

               }

               delete pDialog;

                // 
                // get the new validation.
                //

                enCurrentValidation = GetValidation();

           } // if (NULL != pDialog) 

        }

        //
        // by now we either got the validation data or validation did not change
        //
        // return true if the page is validated as safe
        //

        return (VALIDATED_SAFE == enCurrentValidation) ;
    }
};

#endif // _REND_OBJECT_SAFETY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndreg.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    rndreg.cpp

Abstract:

    This module contains implementation of registry operations used
    in the Rendezvous control.

--*/

#include "stdafx.h"

#include "rndreg.h"
#include "rndils.h"

const WCHAR gsz_RendezvousRoot[] =
        L"Software\\Microsoft\\Windows\\CurrentVersion\\Dynamic Directory";

const WCHAR gsz_ConfInstRelRoot[] = L"Conference";

DWORD    CRegistry::ms_ErrorCode = ERROR_SUCCESS;

WCHAR    CRegistry::ms_ServerName[MAX_REG_WSTR_SIZE];

WCHAR    CRegistry::ms_ProtocolId[MAX_REG_WSTR_SIZE];
WCHAR    CRegistry::ms_SubType[MAX_REG_WSTR_SIZE];
WCHAR    CRegistry::ms_AdvertisingScope[MAX_REG_WSTR_SIZE];
WCHAR    CRegistry::ms_IsEncrypted[MAX_REG_WSTR_SIZE];
    
REG_INFO g_ConfInstInfoArray[] = 
{
    {MA_PROTOCOL,           CRegistry::ms_ProtocolId}
//    {MA_ADVERTISING_SCOPE,  CRegistry::ms_AdvertisingScope},
//    {MA_ISENCRYPTED,        CRegistry::ms_IsEncrypted}
};

DWORD g_ContInstInfoArraySize = 
    (sizeof g_ConfInstInfoArray) / (sizeof REG_INFO);

// re-read the registry entry for server name
BOOL
CRegistry::NotifyServerNameChange(
    )
{
    // read the server name under the rendezvous key
    return ReadRegValue(
            m_RendezvousKey, 
            REG_SERVER_NAME,
            CRegistry::ms_ServerName
            );
}

BOOL
CRegistry::ReadRegValue(
    IN  HKEY            Key,
    IN  const WCHAR *   pName,
    IN  WCHAR *         pValue
    )
{
    DWORD ValueType = REG_SZ;
    DWORD BufferSize = 0;

    // determine the size of the buffer 
    ms_ErrorCode = RegQueryValueExW(
                    Key,
                    pName,
                    0,
                    &ValueType,
                    NULL,
                    &BufferSize
                   );
    if ( ERROR_SUCCESS != ms_ErrorCode )
    {
        return FALSE;
    }

    // check if the reqd buffer is bigger than the pre-allocated buffer size
    if ( (MAX_REG_WSTR_SIZE < BufferSize) )
    {
        ms_ErrorCode = ERROR_OUTOFMEMORY;
        return FALSE;
    }

    // retrieve the value into the allocated buffer
    ms_ErrorCode = RegQueryValueExW(
                    Key,
                    pName,
                    0,
                    &ValueType,
                    (BYTE *)pValue,
                    &BufferSize
                   );

    return (ERROR_SUCCESS == ms_ErrorCode);
}


BOOL
CRegistry::ReadConfInstValues(
    IN    HKEY ConfInstKey
    )
{
    for ( DWORD i = 0; i < g_ContInstInfoArraySize; i ++)
    {
        if ( !ReadRegValue(
                ConfInstKey, 
                CILSDirectory::RTConferenceAttributeName(
                    g_ConfInstInfoArray[i].Attribute
                    ),
                g_ConfInstInfoArray[i].wstrValue
                ))
        {
            return FALSE;
        }
    }
    return TRUE;
}



CRegistry::CRegistry(
    )
//    : m_Event(FALSE, FALSE, NULL, NULL)
{
    // open rendezvous key
    ms_ErrorCode = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    gsz_RendezvousRoot,
                    0,
                    KEY_READ,
                    &m_RendezvousKey
                    );
    if ( ERROR_SUCCESS != ms_ErrorCode )
    {
        return;
    }

    // ZoltanS note: The key is closed in the destructor.

#ifdef SEARCH_REGISTRY_FOR_ILS_SERVER_NAME
    // read the server info (only wstr values) under the rendezvous key
    if ( !ReadRegValue(
            m_RendezvousKey, 
            REG_SERVER_NAME,
            CRegistry::ms_ServerName
            ))
    {
        DBGOUT((ERROR, _T("CRegistry::CRegistry : could not read servername from registry")));
    }
#endif

    // open conference instance key root
    HKEY ConfInstKey;
    ms_ErrorCode = RegOpenKeyExW(
                    m_RendezvousKey,
                    gsz_ConfInstRelRoot,
                    0,
                    KEY_READ,
                    &ConfInstKey
                    );
    if ( ERROR_SUCCESS != ms_ErrorCode )
    {
        return;
    }

    KEY_WRAP ConfInstKeyWrap(ConfInstKey);

    if ( !ReadConfInstValues(ConfInstKey) )
    {
        return;
    }
/*
    // register for a notification when the values under the rendezvous key change
    // are added or deleted. since the server name value exists under the key,
    // any change in its value will cause the event handle to be signaled, other changes
    // will be harmless (other than deletion of the server name value)
    ms_ErrorCode = RegNotifyChangeKeyValue(
                    m_RendezvousKey,              // key to be registered for notification
                    FALSE,                      // only the key, no subkeys
                    REG_NOTIFY_CHANGE_LAST_SET, // only modifications, addition/deletion of values
                    (HANDLE)m_Event,            // handle to be signaled
                    TRUE                        // async
                    );
    if ( ERROR_SUCCESS != ms_ErrorCode )
    {
        return;
    }
*/
    // success
    ms_ErrorCode = ERROR_SUCCESS;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndnt.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    rndnt.cpp

Abstract:

    This module contains implementation of CNTDirectory.

--*/

#include "stdafx.h"

#include "rndnt.h"
#include "rndldap.h"
#include "rndcoll.h"

HRESULT CNTDirectory::FinalConstruct(void)
{
    LOG((MSP_TRACE, "CNTDirectory::FinalConstruct - enter"));

    HRESULT hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                & m_pFTM );

    if ( FAILED(hr) )
    {
        LOG((MSP_INFO, "CNTDirectory::FinalConstruct - "
            "create FTM returned 0x%08x; exit", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CNTDirectory::FinalConstruct - exit S_OK"));

    return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
// ldap helper functions
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// GetGlobalCatalogName (local helper funcion)
//
// This function asks the domain controller for the name of a server with a
// Global Catalog. That's the server we actually do ldap_open() on below
// in CNTDirectory::Connect().
//
// Argument: receives a pointer to a new'ed string containing the name
//           of the global catalog. This is a fully qualified domain name in
//           the format "foo.bar.com.", NOT "\\foo.bar.com.".
//
// Returns an HRESULT:
//      S_OK          : it worked
//      E_OUTOFMEMORY : not enough memory to allocate the string
//      other         : reason for failure of ::DsGetDcName()
//
//////////////////////////////////////////////////////////////////////////////

HRESULT GetGlobalCatalogName(WCHAR ** ppszGlobalCatalogName)
{
    return GetDomainControllerName(DS_GC_SERVER_REQUIRED,
                                   ppszGlobalCatalogName);
}

/////////////////////////////////////////////////////////////////////////////
// private functions
/////////////////////////////////////////////////////////////////////////////

HRESULT CNTDirectory::LdapSearchUser(
    IN  TCHAR *         pName,
    OUT LDAPMessage **  ppLdapMsg
    )
/*++

Routine Description:
    
    Search a user in the Global Catalog.
    
Arguments:
    
    pName   - the user name.
    
    ppLdapMsg - the result of the search.

Return Value:

    HRESULT.

--*/
{
    CTstr pFilter = 
        new TCHAR [lstrlen(DS_USER_FILTER_FORMAT) + lstrlen(pName) + 1];

    BAIL_IF_NULL((TCHAR*)pFilter, E_OUTOFMEMORY);

    wsprintf(pFilter, DS_USER_FILTER_FORMAT, pName);

    // attribute to look for.
    TCHAR *Attributes[] = 
    {
        (WCHAR *)UserAttributeName(UA_USERNAME),
        (WCHAR *)UserAttributeName(UA_TELEPHONE_NUMBER),
        (WCHAR *)UserAttributeName(UA_IPPHONE_PRIMARY),
        NULL
    };
        
    // do the search.
    ULONG res = DoLdapSearch(
        m_ldap,             // ldap handle
        L"",                // base dn is root, because it is Global catalog.
        LDAP_SCOPE_SUBTREE, // subtree search
        pFilter,            // filter; see rndnt.h for the format
        Attributes,         // array of attribute names
        FALSE,              // return the attribute values
        ppLdapMsg           // search results
        );

    BAIL_IF_LDAP_FAIL(res, "search for objects");

    return S_OK;
}

HRESULT CNTDirectory::MakeUserDNs(
    IN  TCHAR *             pName,
    OUT TCHAR ***           pppDNs,
    OUT DWORD *             pdwNumDNs
    )
/*++

Routine Description:
    
    Look for the DN of a user in the DS.
    
Arguments:
    
    pName - the user name.
    
    ppDN - the user's DN.

Return Value:

    HRESULT.

--*/
{
    LOG((MSP_INFO, "DS: MakeUserDNs: enter"));
    
    CLdapMsgPtr pLdapMsg; // auto release message.
    *pppDNs    = NULL;
    *pdwNumDNs = 0;

    //
    // First find the desired user via the Global Catalog.
    //

    BAIL_IF_FAIL(LdapSearchUser(pName, &pLdapMsg), 
        "DS: MakeUserDNs: Ldap Search User failed");

    //
    // Make sure we got the right number of entries. If we get 0, we're stuck.
    // The DS enforces domain-wide uniqueness on the samAccountName attribute,
    // so if we get more than one it means the same username is present in
    // more than one domain in our enterprise.
    //

    DWORD dwEntries = ldap_count_entries(m_ldap, pLdapMsg);

    if (dwEntries == 0)
    {
        LOG((MSP_ERROR, "DS: MakeUserDNs: entry count is 0 - no match"));
        return E_FAIL;
    }

    //
    // Allocate an array of pointers in which to return the DNs.
    //

    *pppDNs = new PTCHAR [ dwEntries ];

    if ( (*pppDNs) == NULL )
    {
        LOG((MSP_ERROR, "DS: MakeUserDNs: Not enough memory to allocate array of pointers"));
        return E_OUTOFMEMORY;
    }

    //
    // For each DN returned, allocate space for a private copy of the DN and
    // stick a pointer to that space in the array of pointers allocated
    // above.
    //

    //
    // Note that dwEntries is the number of entries in the ldap
    // message. *pdwNumDNs is the number of DNs we are able to
    // extract. For various reasons it is possible for
    // *pdwNumDNs to eventually become < dwEntries.
    //

    LDAPMessage * pEntry = NULL;
    
    for ( DWORD i = 0; i < dwEntries; i++ )
    {
        //
        // Get the entry from the ldap message.
        //

        if ( i == 0 )
        {
            pEntry = ldap_first_entry(m_ldap, pLdapMsg);
        }
        else
        {
            pEntry = ldap_next_entry(m_ldap, pEntry);
        }

        //
        // Get the DN from the message.
        //

        TCHAR * p = ldap_get_dn(m_ldap, pEntry);

        if ( p == NULL )
        {
            LOG((MSP_ERROR, "DS: MakeUserDNs: could not get DN - skipping"));
            continue;
        }

        LOG((MSP_INFO, "DS: MakeUserDNs: found user DN: %S", p));

        //
        // Allocate space for a copy of the DN.
        //

        TCHAR * pDN = new TCHAR [ lstrlen(p) + 1 ];
        
        if ( pDN == NULL )
        {
            ldap_memfree( p );

            LOG((MSP_ERROR, "DS: MakeUserDNs: could not allocate copy of "
                          "DN - skipping"));
            continue;
        }

        //
        // Copy the DN and free the one ldap constructed.
        //

        lstrcpy( pDN, p );
        ldap_memfree( p );

        //
        // Save the DN in our array of DNs and update the size of the array.
        //

        (*pppDNs)[ *pdwNumDNs ] = pDN;

        (*pdwNumDNs) ++;
    }

    //
    // Check if we have anything to return.
    //

    if ( (*pdwNumDNs) == 0 )
    {
        LOG((MSP_ERROR, "DS: MakeUserDNs: had entries but could not "
                      "retrieve any DNs - returning E_FAIL"));

        delete (*pppDNs);
        *pppDNs = NULL;

        return E_FAIL;
    }

    LOG((MSP_INFO, "DS: MakeUserDNs: exit S_OK"));

    return S_OK;
}

HRESULT CNTDirectory::AddUserIPPhone(
    IN  ITDirectoryObject *pDirectoryObject
    )
/*++

Routine Description:
    
    Modify the user's IPPhone-Primary attribute.
    
Arguments:
    
    pDirectoryObject - the object that has the user name and IP phone.
    
Return Value:

    HRESULT.

--*/
{
    HRESULT hr;

    //
    // First get the private interface for attributes.
    //

    ITDirectoryObjectPrivate * pObjectPrivate;

    hr = pDirectoryObject->QueryInterface(
            IID_ITDirectoryObjectPrivate,
            (void **)&pObjectPrivate
            );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CNTDirectory::AddUserIPPhone - can't get the "
                "private directory object interface - exit 0x%08x", hr));

        return hr;
    }

    //
    // Get the user name.
    //

    BSTR bName;

    hr = pDirectoryObject->get_Name( & bName );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CNTDirectory::AddUserIPPhone - "
                "can't get user name - exit 0x%08x", hr));

        pObjectPrivate->Release();

        return hr;
    }

    //
    // Get the IP phone(machine name).
    //

    BSTR bIPPhone;

    hr = pObjectPrivate->GetAttribute( UA_IPPHONE_PRIMARY, &bIPPhone );

    pObjectPrivate->Release();

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CNTDirectory::AddUserIPPhone - "
                "can't get IPPhone attribute - exit 0x%08x", hr));

        SysFreeString( bName );

        return hr;
    }

    //
    // resolve the machine name and get the fully qualified DNS name.
    // this is a pointer into a static hostp structure so we do not
    // need to free it
    //

    char * pchFullDNSName;

    hr = ResolveHostName(0, bIPPhone, &pchFullDNSName, NULL);

    SysFreeString(bIPPhone);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CNTDirectory::AddUserIPPhone - "
                "can't resolve hostname - exit 0x%08x", hr));

        SysFreeString( bName );

        return hr;
    }

    //
    // Convert the ASCII string into unicode string.
    // conversion memory allocates memory on stack
    //

    USES_CONVERSION;
    TCHAR * pFullDNSName = A2T(pchFullDNSName);
 
    if ( pFullDNSName == NULL)
    {
        LOG((MSP_ERROR, "CNTDirectory::AddUserIPPhone - "
                "can't convert to tchar - exit E_FAIL"));

        SysFreeString( bName );

        return E_FAIL;
    }

    //
    // Find the DNs of the user in DS.
    //

    TCHAR ** ppDNs;
    DWORD    dwNumDNs;

    hr = MakeUserDNs( bName, & ppDNs, & dwNumDNs );

    SysFreeString( bName );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CNTDirectory::AddUserIPPhone - "
                "can't construct any DNs for user - exit 0x%08x", hr));

        return hr;
    }

    LOG((MSP_INFO, "%d DNs to try", dwNumDNs ));

    hr = E_FAIL;

    for ( DWORD i = 0; i < dwNumDNs; i++ )
    {
        //
        // If one of them worked, then don't bother with any more.
        // But we still need to delete the leftover DN strings.
        //

        if ( SUCCEEDED(hr) )
        {
            LOG((MSP_INFO, "skipping extra DN %S", ppDNs[i]));
        }
        else
        {
            //
            // Modify the user object.
            //

            LDAPMod     mod[1];         // The modify sturctures used by LDAP

            //
            // the IPPhone-Primary attribute.
            //

            TCHAR *     IPPhone[2] = {pFullDNSName, NULL};
            mod[0].mod_values = IPPhone;
            mod[0].mod_op     = LDAP_MOD_REPLACE;
            mod[0].mod_type   = (WCHAR *)UserAttributeName(UA_IPPHONE_PRIMARY);
    
            LDAPMod* mods[] = {&mod[0], NULL};

            LOG((MSP_INFO, "modifying %S", ppDNs[i] ));

            //
            // Call the modify function to modify the object.
            //

            hr = GetLdapHResultIfFailed(DoLdapModify(TRUE,
                                                     m_ldapNonGC,
                                                     ppDNs[i],
                                                     mods));

            if ( SUCCEEDED(hr) )
            {
                LOG((MSP_INFO, "modifying %S succeeded; done", ppDNs[i] ));
            }
            else
            {
                LOG((MSP_INFO, "modifying %S failed 0x%08x; trying next",
                        ppDNs[i], hr ));
            }
        }

        //
        // Skipping or not, we need to delete the string.
        //

        delete ppDNs[i];
    }

    //
    // Delete the array that holds the DNs.
    //

    delete ppDNs;

    return hr;
}

HRESULT CNTDirectory::DeleteUserIPPhone(
    IN  ITDirectoryObject *pDirectoryObject
    )
/*++

Routine Description:
    
    Remove the user's IPPhone-Primary attribute.
    
Arguments:
    
    pDirectoryObject - the object that has the user name.
    
Return Value:

    HRESULT.

--*/
{
    //
    // Get the name of the user.
    //

    HRESULT hr;

    BSTR bName;

    hr = pDirectoryObject->get_Name(&bName);

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CNTDirectory::DeleteUserIPPHone - "
                "can't get user name - exit 0x%08x", hr));

        return hr;
    }

    //
    // Get an array of DNs for this user name.
    //

    TCHAR ** ppDNs;
    DWORD    dwNumDNs;

    hr = MakeUserDNs( bName, & ppDNs, & dwNumDNs );

    SysFreeString( bName );

    if ( FAILED(hr) )
    {
        LOG((MSP_ERROR, "CNTDirectory::DeleteUserIPPHone - "
                "can't get any DNs - exit 0x%08x", hr));

        return hr;
    }

    LOG((MSP_INFO, "CNTDirectory::DeleteUserIPPhone - "
            "%d DNs to try", dwNumDNs ));

    //
    // Loop through all the available DNs. Try each one
    // until one succeeds, then continue looping just
    // to delete the strings.
    //

    hr = E_FAIL;

    for ( DWORD i = 0; i < dwNumDNs; i++ )
    {
        //
        // If one of them worked, then don't bother with any more.
        // But we still need to delete the leftover DN strings.
        //

        if ( SUCCEEDED(hr) )
        {
            LOG((MSP_INFO, "skipping extra DN %S", ppDNs[i]));
        }
        else
        {
            LDAPMod     mod;   // The modify sturctures used by LDAP
            
            mod.mod_values = NULL;
            mod.mod_op     = LDAP_MOD_DELETE;
            mod.mod_type   = (WCHAR *)UserAttributeName(UA_IPPHONE_PRIMARY);
    
            LDAPMod*    mods[] = {&mod, NULL};

            LOG((MSP_INFO, "modifying %S", ppDNs[i] ));

            //
            // Call the modify function to remove the attribute.
            //

            hr = GetLdapHResultIfFailed(DoLdapModify(TRUE,
                                                     m_ldapNonGC,
                                                     ppDNs[i],
                                                     mods));

            if ( SUCCEEDED(hr) )
            {
                LOG((MSP_INFO, "modifying %S succeeded; done", ppDNs[i] ));
            }
            else
            {
                LOG((MSP_INFO, "modifying %S failed 0x%08x; trying next",
                        ppDNs[i], hr ));
            }
        }

        //
        // Skipping or not, we need to delete the string.
        //

        delete ppDNs[i];
    }

    //
    // Delete the array that holds the DNs.
    //

    delete ppDNs;

    return hr;
}

HRESULT CNTDirectory::CreateUser(
    IN  LDAPMessage *   pEntry,
    IN  ITDirectoryObject ** ppObject
    )
/*++

Routine Description:
    
    Create a user object based on the info in DS.
    
Arguments:
    
    pEntry  - the returned entry from DS.

    pObject - the created object that has the user name and IP phone.
    
Return Value:

    HRESULT.

--*/
{
    // Get the name of the user.
    CBstr bName;
    BAIL_IF_FAIL(
        ::GetAttributeValue(
            m_ldap,
            pEntry, 
            UserAttributeName(UA_USERNAME), 
            &bName
            ),
        "get the user name"
        );

    // Create an empty user object.
    CComPtr<ITDirectoryObject> pObject;
    BAIL_IF_FAIL(::CreateEmptyUser(bName, &pObject), "CreateEmptyUser");

    // get the private interface for attributes.
    CComPtr <ITDirectoryObjectPrivate> pObjectPrivate;

    BAIL_IF_FAIL(
        pObject->QueryInterface(
            IID_ITDirectoryObjectPrivate,
            (void **)&pObjectPrivate
            ),
        "can't get the private directory object interface");

    // Get the machine name of the user.
    CBstr bAddress;
    if (SUCCEEDED(::GetAttributeValue(
            m_ldap,
            pEntry, 
            UserAttributeName(UA_IPPHONE_PRIMARY),
            &bAddress
            )))
    {
        // Set the ipphone attribute.
        BAIL_IF_FAIL(pObjectPrivate->SetAttribute(UA_IPPHONE_PRIMARY, bAddress),
            "set ipPhone attribute");
    }

    // Get and set the phonenumber of the user. (optional)
    CBstr bPhone;
    if (SUCCEEDED(::GetAttributeValue(
            m_ldap,
            pEntry, 
            UserAttributeName(UA_TELEPHONE_NUMBER),
            &bPhone
            )))
    {
        // Set the telephone attribute.
        BAIL_IF_FAIL(pObjectPrivate->SetAttribute(UA_TELEPHONE_NUMBER, bPhone),
            "set phone number");
    }

    *ppObject = pObject;
    (*ppObject)->AddRef();

    return S_OK;
}

HRESULT CNTDirectory::SearchUser(
    IN  BSTR                    pName,
    OUT ITDirectoryObject ***   pppDirectoryObject,
    OUT DWORD *                 pdwSize
    )
/*++

Routine Description:
    
    Search user and create an array of user object to return.
    
Arguments:
    
    pName  - the user name.

    pppDirectoryObject - the created array of user objects that have 
                the user name and IP phone.

    pdwSize - the size of the array.
    
Return Value:

    HRESULT.

--*/
{
    CLdapMsgPtr pLdapMsg; // auto release message.

    BAIL_IF_FAIL(LdapSearchUser(pName, &pLdapMsg), 
        "Ldap Search User failed");

    DWORD dwEntries = ldap_count_entries(m_ldap, pLdapMsg);
    ITDirectoryObject ** pObjects = new PDIRECTORYOBJECT [dwEntries];

    BAIL_IF_NULL(pObjects, E_OUTOFMEMORY);

    DWORD dwCount = 0;
    LDAPMessage *pEntry = ldap_first_entry(m_ldap, pLdapMsg);
    
    while (pEntry != NULL)
    {
        HRESULT hr;
        
        hr = CreateUser(pEntry, &pObjects[dwCount]);

        if (SUCCEEDED(hr)) 
        {
            dwCount ++;
        }
          
        // Get next entry.
        pEntry = ldap_next_entry(m_ldap, pEntry);
    }

    *pppDirectoryObject = pObjects;
    *pdwSize = dwCount;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// NT Directory implementation
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CNTDirectory::get_DirectoryType (
    OUT DIRECTORY_TYPE *  pDirectoryType
    )
// get the type of the directory.
{
    if ( IsBadWritePtr(pDirectoryType, sizeof(DIRECTORY_TYPE) ) )
    {
        LOG((MSP_ERROR, "Directory.get_DirectoryType, invalid pointer"));
        return E_POINTER;
    }

    *pDirectoryType = m_Type;

    return S_OK;
}

STDMETHODIMP CNTDirectory::get_DisplayName (
    OUT BSTR *ppName
    )
// get the display name of the directory.
{
    BAIL_IF_BAD_WRITE_PTR(ppName, E_POINTER);

    *ppName = SysAllocString(L"NTDS");

    if (*ppName == NULL)
    {
        LOG((MSP_ERROR, "get_DisplayName: out of memory."));
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

STDMETHODIMP CNTDirectory::get_IsDynamic(
    OUT VARIANT_BOOL *pfDynamic
    )
// find out if the directory requires refresh. For NTDS, it is FALSE.
{
    if ( IsBadWritePtr(pfDynamic, sizeof(VARIANT_BOOL) ) )
    {
        LOG((MSP_ERROR, "Directory.get_IsDynamic, invalid pointer"));
        return E_POINTER;
    }

    *pfDynamic = VARIANT_FALSE;

    return S_OK;
}

STDMETHODIMP CNTDirectory::get_DefaultObjectTTL(
    OUT long *pTTL        // in seconds
    )
// Since NTDS is not dynamic, this shouldn't be called.
{
    return E_FAIL; // ZoltanS changed from E_UNEXPECTED
}

STDMETHODIMP CNTDirectory::put_DefaultObjectTTL(
    IN  long TTL          // in sechods
    )
// Since NTDS is not dynamic, this shouldn't be called.
{
    return E_FAIL; // ZoltanS changed from E_UNEXPECTED
}

STDMETHODIMP CNTDirectory::EnableAutoRefresh(
    IN  VARIANT_BOOL fEnable
    )
// Since NTDS is not dynamic, this shouldn't be called.
{
    return E_FAIL; // ZoltanS changed from E_UNEXPECTED
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNTDirectory::Connect(
    IN  VARIANT_BOOL fSecure
    )
// make ldap connection. Use ssl port or normal port.
{
    CLock Lock(m_lock);
    if (m_ldap != NULL)
    {
        LOG((MSP_ERROR, "already connected."));
        return RND_ALREADY_CONNECTED;
    }

    // ZoltanS: either VARIANT_TRUE or TRUE will work
    // in case the caller doesn't know better

    if (fSecure)
    {
        // the port is flipped from regular port to ssl port.
        m_wPort = GetOtherPort(m_wPort);
        m_IsSsl = TRUE;
    }

    //
    // ZoltanS: Get the name of the global catalog. If there is not at least
    // one global catalog in this enterprise then we are toast.
    //

    HRESULT hr;
    WCHAR * pszGlobalCatalogName;
    // this allocates pszGlobalCatalogName
    BAIL_IF_FAIL(::GetGlobalCatalogName( &pszGlobalCatalogName ),
        "GetGlobalCatalogName failed");

    //
    // associate the ldap handle with the handle holder. in case of an error
    // and subsequent return (without being reset), the ldap handle is closed
    // ZoltanS: changed to use GC instead of NULL
    //

    CLdapPtr hLdap = ldap_init(pszGlobalCatalogName, m_wPort);

    if (hLdap == NULL)
    {
        LOG((MSP_ERROR, "ldap_init error: %d", GetLastError()));
    }

    //
    // ZoltanS: Deallocate the string that holds the name of the global
    // catalog; we are sure we won't need it anymore.
    //

    delete pszGlobalCatalogName;

    //
    // Now back to our regularly scheduled programming...
    //

    BAIL_IF_NULL((LDAP*)hLdap, HRESULT_FROM_WIN32(ERROR_BAD_NETPATH));

    LDAP_TIMEVAL Timeout;
    Timeout.tv_sec = REND_LDAP_TIMELIMIT;
    Timeout.tv_usec = 0;

    DWORD res = ldap_connect((LDAP*)hLdap, &Timeout);
    BAIL_IF_LDAP_FAIL(res, "connect to the server.");

    DWORD LdapVersion = 3;
    res = ldap_set_option((LDAP*)hLdap, LDAP_OPT_VERSION, &LdapVersion);
    BAIL_IF_LDAP_FAIL(res, "set ldap version to 3");
	
    res = ldap_set_option((LDAP*)hLdap, LDAP_OPT_TIMELIMIT, &Timeout);
    BAIL_IF_LDAP_FAIL(res, "set ldap timelimit");

    ULONG ldapOptionOn = PtrToUlong(LDAP_OPT_ON);
    res = ldap_set_option((LDAP*)hLdap, LDAP_OPT_AREC_EXCLUSIVE, &ldapOptionOn);
    BAIL_IF_LDAP_FAIL(res, "set ldap arec exclusive");

    if (m_IsSsl)
    {
        res = ldap_set_option(hLdap, LDAP_OPT_SSL, LDAP_OPT_ON);
        if( fSecure )
        {
            if( res != LDAP_SUCCESS )
            {
                LOG((MSP_ERROR, "Invalid Secure flag"));
                return E_INVALIDARG;
            }
        }
        else
        {
            BAIL_IF_LDAP_FAIL(res, "set ssl option");
        }
    }

    // if no directory path is specified, query the server
    // to determine the correct path
    BAIL_IF_FAIL(
        ::GetNamingContext(hLdap, &m_NamingContext), 
        "can't get default naming context"
        );

    m_ldap          = hLdap;

    // reset the holders so that they don't release anyting.
    hLdap   = NULL;



    
    CLdapPtr hLdapNonGC = ldap_init(NULL, LDAP_PORT);

    if (hLdapNonGC == NULL)
    {
        LOG((MSP_ERROR, "ldap_init non-GC error: %d", GetLastError()));
    }

    BAIL_IF_NULL((LDAP*)hLdapNonGC, HRESULT_FROM_WIN32(ERROR_BAD_NETPATH));

    res = ldap_connect((LDAP*)hLdapNonGC, &Timeout);
    BAIL_IF_LDAP_FAIL(res, "connect to the server.");

    res = ldap_set_option((LDAP*)hLdapNonGC, LDAP_OPT_VERSION, &LdapVersion);
    BAIL_IF_LDAP_FAIL(res, "set ldap version to 3");
	
    res = ldap_set_option((LDAP*)hLdapNonGC, LDAP_OPT_TIMELIMIT, &Timeout);
    BAIL_IF_LDAP_FAIL(res, "set ldap timelimit");

    res = ldap_set_option((LDAP*)hLdapNonGC, LDAP_OPT_AREC_EXCLUSIVE, &ldapOptionOn);
    BAIL_IF_LDAP_FAIL(res, "set ldap arec exclusive");

//    res = ldap_set_option((LDAP*)hLdapNonGC, LDAP_OPT_REFERRALS, LDAP_OPT_ON);
//    BAIL_IF_LDAP_FAIL(res, "set chase referrals to on");

    if (m_IsSsl)
    {
        res = ldap_set_option(hLdapNonGC, LDAP_OPT_SSL, LDAP_OPT_ON);
        BAIL_IF_LDAP_FAIL(res, "set ssl option");
    }

    m_ldapNonGC          = hLdapNonGC;

    // reset the holders so that they don't release anyting.
    hLdapNonGC   = NULL;




    return S_OK;
}

//
// ITDirectory::Bind
//
// Bind to the server.
//
// Currently recognized flags:
//
//    RENDBIND_AUTHENTICATE       0x00000001
//    RENDBIND_DEFAULTDOMAINNAME  0x00000002
//    RENDBIND_DEFAULTUSERNAME    0x00000004
//    RENDBIND_DEFAULTPASSWORD    0x00000008
//
// "Meta-flags" for convenience:
//    RENDBIND_DEFAULTCREDENTIALS 0x0000000e
//
//
// All of this together means that the following three
// forms are all equivalent:
//
// BSTR es = SysAllocString(L"");
// hr = pITDirectory->Bind(es, es, es, RENDBIND_AUTHENTICATE |
//                                     RENDBIND_DEFAULTCREDENTIALS);
// SysFreeString(es);
//
//
// BSTR es = SysAllocString(L"");
// hr = pITDirectory->Bind(es, es, es, RENDBIND_AUTHENTICATE      |
//                                     RENDBIND_DEFAULTDOMAINNAME |
//                                     RENDBIND_DEFAULTUSERNAME   |
//                                     RENDBIND_DEFAULTPASSWORD);
// SysFreeString(es);
//
//
// hr = pITDirectory->Bind(NULL, NULL, NULL, RENDBIND_AUTHENTICATE);
//
//


STDMETHODIMP CNTDirectory::Bind (
    IN  BSTR pDomainName,
    IN  BSTR pUserName,
    IN  BSTR pPassword,
    IN  long lFlags
    )
{
    LOG((MSP_TRACE, "CNTDirectory Bind - enter"));

    //
    // Determine if we should authenticate.
    //

    BOOL fAuthenticate = FALSE;

    if ( lFlags & RENDBIND_AUTHENTICATE )
    {
        fAuthenticate = TRUE;
    }

    //
    // For scripting compatibility, force string parameters to NULL based
    // on flags.
    //

    if ( lFlags & RENDBIND_DEFAULTDOMAINNAME )
    {
        pDomainName = NULL;
    }
       
    if ( lFlags & RENDBIND_DEFAULTUSERNAME )
    {
        pUserName = NULL;
    }

    if ( lFlags & RENDBIND_DEFAULTPASSWORD )
    {
        pPassword = NULL;
    }

    LOG((MSP_INFO, "Bind parameters: domain: `%S' user: `%S' "
                  "authenticate: %S)",
        (pDomainName)   ? pDomainName : L"<null>",
        (pUserName)     ? pUserName   : L"<null>",
        (fAuthenticate) ? L"yes"      : L"no"));

    //
    // All flags processed -- lock and proceed with bind if connected.
    //
    
    CLock Lock(m_lock);

    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "not connected."));
        return RND_NOT_CONNECTED;
    }

    //
    // ZoltanS: check the arguments. NULL has meaning in each case, so they are
    // OK for now. In each case we want to check any length string, so we
    // specify (UINT) -1 as the length.
    //

    if ( (pDomainName != NULL) && IsBadStringPtr(pDomainName, (UINT) -1 ) )
    {
        LOG((MSP_ERROR, "CNTDirectory::Bind: bad non-NULL pDomainName argument"));
        return E_POINTER;
    }
    
    if ( (pUserName != NULL) && IsBadStringPtr(pUserName, (UINT) -1 ) )
    {
        LOG((MSP_ERROR, "CNTDirectory::Bind: bad non-NULL pUserName argument"));
        return E_POINTER;
    }

    if ( (pPassword != NULL) && IsBadStringPtr(pPassword, (UINT) -1 ) )
    {
        LOG((MSP_ERROR, "CNTDirectory::Bind: bad non-NULL pPassword argument"));
        return E_POINTER;
    }

    ULONG res;

    if ( m_IsSsl || (!fAuthenticate) )
    {
        // if encrypted or no secure authentication is required,
        // simple bind is sufficient

        // ldap_simple_bind_s does not use sspi to get default credentials. We are
        // just specifying what we will actually pass on the wire.

        if (pPassword == NULL)
        {
            LOG((MSP_ERROR, "invalid Bind parameters: no password specified"));
            return E_INVALIDARG;
        }

        WCHAR * wszFullName;

        if ( (pDomainName == NULL) && (pUserName == NULL) )
        {
            // No domain / user doesn't make sense.
            LOG((MSP_ERROR, "invalid Bind paramters: domain and user not specified"));
            return E_INVALIDARG;
        }
        else if (pDomainName == NULL)
        {
            // username only is okay
            wszFullName = pUserName;
        }
        else if (pUserName == NULL)
        {
            // It doesn't make sense to specify domain but not user...
            LOG((MSP_ERROR, "invalid Bind paramters: domain specified but not user"));
            return E_INVALIDARG;
        }
        else
        {
            // We need domain\user. Allocate a string and sprintf into it.
            // The + 2 is for the "\" and for the null termination.

            wszFullName = new WCHAR[wcslen(pDomainName) + wcslen(pUserName) + 2];
            BAIL_IF_NULL(wszFullName, E_OUTOFMEMORY);
        
            wsprintf(wszFullName, L"%s\\%s", pDomainName, pUserName);
        }

        //
        // Do the simple bind.
        //

        res = ldap_simple_bind_s(m_ldap, wszFullName, pPassword);

        ULONG res2 = ldap_simple_bind_s(m_ldapNonGC, wszFullName, pPassword);

        //
        // If we constructed the full name string, we now need to delete it.
        //

        if (wszFullName != pUserName)
        {
            delete wszFullName;
        }

        //
        // Bail if the simple bind failed.
        //

        BAIL_IF_LDAP_FAIL(res, "ldap simple bind");

        BAIL_IF_LDAP_FAIL(res2, "ldap simple bind - non gc");

    }
    else    // try an SSPI bind
    {
        // ZoltanS Note: the ldap bind code does not process NULL, NULL, NULL
        // in the SEC_WINNT_AUTH_IDENTITY blob, therefore it is special-cased.

        // ZoltanS: We used to use LDAP_AUTH_NTLM; now we use
        // LDAP_AUTH_NEGOTIATE to make sure we use the right domain for the
        // bind.

        if ( pDomainName || pUserName || pPassword )
        {
            // fill the credential structure
            SEC_WINNT_AUTH_IDENTITY AuthI;

            AuthI.User = (PTCHAR)pUserName;
            AuthI.UserLength = (pUserName == NULL)? 0: wcslen(pUserName);
            AuthI.Domain = (PTCHAR)pDomainName;
            AuthI.DomainLength = (pDomainName == NULL)? 0: wcslen(pDomainName);
            AuthI.Password = (PTCHAR)pPassword;
            AuthI.PasswordLength = (pPassword == NULL)? 0: wcslen(pPassword);
            AuthI.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

            res = ldap_bind_s(m_ldap, NULL, (TCHAR*)(&AuthI), LDAP_AUTH_NEGOTIATE);
            BAIL_IF_LDAP_FAIL(res, "bind with authentication");

            res = ldap_bind_s(m_ldapNonGC, NULL, (TCHAR*)(&AuthI), LDAP_AUTH_NEGOTIATE);
            BAIL_IF_LDAP_FAIL(res, "bind with authentication - non gc");

        }
        else
        {
            // Otherwise we've come in with NULL, NULL, NULL - 
            // pass in NULL, NULL. The reason do this is that ldap bind code 
            // does not process NULL, NULL, NULL in the
            // SEC_WINNT_AUTH_IDENTITY blob !!!
            ULONG res = ldap_bind_s(m_ldap, NULL, NULL, LDAP_AUTH_NEGOTIATE);
            BAIL_IF_LDAP_FAIL(res, "bind with NULL NULL NULL");

            res = ldap_bind_s(m_ldapNonGC, NULL, NULL, LDAP_AUTH_NEGOTIATE);
            BAIL_IF_LDAP_FAIL(res, "bind with NULL NULL NULL - non gc");
        }
    }

    LOG((MSP_TRACE, "CNTDirectory::Bind - exiting OK"));
    return S_OK;
}

STDMETHODIMP CNTDirectory::AddDirectoryObject (
    IN  ITDirectoryObject *pDirectoryObject
    )
// add an object to the DS. 
{
    BAIL_IF_BAD_READ_PTR(pDirectoryObject, E_POINTER);

    CLock Lock(m_lock);
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "not connected."));
        return RND_NOT_CONNECTED;
    }

    HRESULT hr;
    DIRECTORY_OBJECT_TYPE type;

    if (FAILED(hr = pDirectoryObject->get_ObjectType(&type)))
    {
        return hr;
    }

    switch (type)
    {
    case OT_CONFERENCE:
        hr = E_NOTIMPL;
        break;

    case OT_USER:
        hr = AddUserIPPhone(pDirectoryObject);
        break;
    }
    return hr;
}

STDMETHODIMP CNTDirectory::ModifyDirectoryObject (
    IN  ITDirectoryObject *pDirectoryObject
    )
// modify an object in the DS
{
    BAIL_IF_BAD_READ_PTR(pDirectoryObject, E_POINTER);

    CLock Lock(m_lock);
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "not connected."));
        return RND_NOT_CONNECTED;
    }

    HRESULT hr;
    DIRECTORY_OBJECT_TYPE type;

    if (FAILED(hr = pDirectoryObject->get_ObjectType(&type)))
    {
        return hr;
    }

    switch (type)
    {
    case OT_CONFERENCE:
        hr = E_NOTIMPL;
        break;

    case OT_USER:
        hr = AddUserIPPhone(pDirectoryObject);
        break;
    }
    return hr;
}

STDMETHODIMP CNTDirectory::RefreshDirectoryObject (
    IN  ITDirectoryObject *pDirectoryObject
    )
// no refresh is necessary.
{
    return S_OK;
}

STDMETHODIMP CNTDirectory::DeleteDirectoryObject (
    IN  ITDirectoryObject *pDirectoryObject
    )
// delete an object in the DS.
{
    BAIL_IF_BAD_READ_PTR(pDirectoryObject, E_POINTER);

    CLock Lock(m_lock);
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "not connected."));
        return RND_NOT_CONNECTED;
    }

    HRESULT hr;
    DIRECTORY_OBJECT_TYPE type;

    if (FAILED(hr = pDirectoryObject->get_ObjectType(&type)))
    {
        return hr;
    }

    switch (type)
    {
    case OT_CONFERENCE:
        hr = E_NOTIMPL;
        break;

    case OT_USER:
        hr = DeleteUserIPPhone(pDirectoryObject);
        break;
    }
    return hr;
}

STDMETHODIMP CNTDirectory::get_DirectoryObjects (
    IN  DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
    IN  BSTR                    pName,
    OUT VARIANT *               pVariant
    )
// look for objects in the ds. returns a collection used in VB.
{
    BAIL_IF_BAD_READ_PTR(pName, E_POINTER);
    BAIL_IF_BAD_WRITE_PTR(pVariant, E_POINTER);

    CLock Lock(m_lock);
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "not connected."));
        return RND_NOT_CONNECTED;
    }

    HRESULT hr;

    ITDirectoryObject **pObjects;
    DWORD dwSize;
    
    switch (DirectoryObjectType)
    {
    case OT_CONFERENCE:
        hr = E_NOTIMPL;
        break;
    case OT_USER:
        hr = SearchUser(pName, &pObjects, &dwSize);
        break;
    }

    BAIL_IF_FAIL(hr, "Search for objects");

    hr = CreateInterfaceCollection(dwSize,            // count
                                   &pObjects[0],      // begin ptr
                                   &pObjects[dwSize], // end ptr
                                   pVariant);         // return value

    for (DWORD i = 0; i < dwSize; i ++)
    {
        pObjects[i]->Release();
    }

    delete pObjects;

    BAIL_IF_FAIL(hr, "Create collection of directory objects");

    return hr;
}

STDMETHODIMP CNTDirectory::EnumerateDirectoryObjects (
    IN  DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
    IN  BSTR                    pName,
    OUT IEnumDirectoryObject ** ppEnumObject
    )
// Enumerated object in ds.
{
    BAIL_IF_BAD_READ_PTR(pName, E_POINTER);
    BAIL_IF_BAD_WRITE_PTR(ppEnumObject, E_POINTER);

    CLock Lock(m_lock);
    if (m_ldap == NULL)
    {
        LOG((MSP_ERROR, "not connected."));
        return RND_NOT_CONNECTED;
    }

    HRESULT hr;

    ITDirectoryObject **pObjects;
    DWORD dwSize;
    
    switch (DirectoryObjectType)
    {
    case OT_CONFERENCE:
        hr = E_NOTIMPL;
        break;
    case OT_USER:
        hr = SearchUser(pName, &pObjects, &dwSize);
        break;
    }

    BAIL_IF_FAIL(hr, "Search for objects");

    hr = ::CreateDirectoryObjectEnumerator(
        &pObjects[0],
        &pObjects[dwSize],
        ppEnumObject
        );

    for (DWORD i = 0; i < dwSize; i ++)
    {
        pObjects[i]->Release();
    }

    delete pObjects;

    BAIL_IF_FAIL(hr, "Create enumerator of directory objects");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndrend.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    rndrend.h

Abstract:

    Definitions for CRendezvous class.

--*/

#ifndef __RNDREND_H
#define __RNDREND_H

#pragma once

#include "RndObjSf.h"
#include "rndutil.h"

#define RENDWINSOCKVERSION     (MAKEWORD(1, 1))

/////////////////////////////////////////////////////////////////////////////
// CRendezvous
/////////////////////////////////////////////////////////////////////////////

class CRendezvous : 
    public CComDualImpl<ITRendezvous, &IID_ITRendezvous, &LIBID_RENDLib>, 
    public CComObjectRootEx<CComObjectThreadModel>,
    public CComCoClass<CRendezvous, &CLSID_Rendezvous>,
    public CRendObjectSafety
{

    DECLARE_GET_CONTROLLING_UNKNOWN()

public:
    CRendezvous() : m_fWinsockReady(FALSE), m_dwSafety(0), m_pFTM(NULL) {}
    HRESULT FinalConstruct(void);
    virtual ~CRendezvous();

    BEGIN_COM_MAP(CRendezvous)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(ITRendezvous)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
    END_COM_MAP()

    //DECLARE_NOT_AGGREGATABLE(CRendezvous) 
    // Remove the comment from the line above if you don't want your object to 
    // support aggregation. 

    DECLARE_REGISTRY_RESOURCEID(IDR_Rendezvous)
    
    //
    // ITRendezvous
    //

    STDMETHOD (get_DefaultDirectories) (
        OUT     VARIANT * pVariant
        );

    STDMETHOD (EnumerateDefaultDirectories) (
        OUT     IEnumDirectory ** ppEnumDirectory
        );

    STDMETHOD (CreateDirectory) (
        IN      DIRECTORY_TYPE  DirectoryType,
        IN      BSTR            pName,
        OUT     ITDirectory **  ppDir
        );

    STDMETHOD (CreateDirectoryObject) (
        IN      DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
        IN      BSTR                    pName,
        OUT     ITDirectoryObject **    ppDirectoryObject
        );

protected:

    HRESULT InitWinsock();

    HRESULT CreateDirectoryEnumerator(
        IN  ITDirectory **      begin,
        IN  ITDirectory **      end,
        OUT IEnumDirectory **   ppIEnum
        );

    HRESULT CreateNTDirectory(
        OUT ITDirectory **ppDirectory
        );

    HRESULT CreateILSDirectory(
        IN  const WCHAR * const wstrName,
        IN  const WORD          wPort,
        OUT ITDirectory **      ppDirectory
        );

    HRESULT CreateNDNCDirectory(
        IN  const WCHAR * const wstrName,
        IN  const WORD          wPort,
        OUT ITDirectory **      ppDirectory
        );

    HRESULT CreateDirectories(
        SimpleVector <ITDirectory *> &VDirectory
        );

    HRESULT CreateConference(
        OUT ITDirectoryObject **ppDirectoryObject
        );

    HRESULT CreateUser(
        OUT ITDirectoryObject **ppDirectoryObject
        );
private:

    BOOL            m_fWinsockReady;
    DWORD           m_dwSafety;
    IUnknown      * m_pFTM;          // pointer to the free threaded marshaler
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndreg.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    rndreg.h

Abstract:

    Definitions for registry operation classes.

--*/

#ifndef __RENDEZVOUS_REGISTRY__
#define __RENDEZVOUS_REGISTRY__

#pragma once

#include "rndcommc.h"

const DWORD MAX_REG_WSTR_SIZE = 100;
const DWORD MAX_BLOB_TEMPLATE_SIZE = 2000;

const WCHAR REG_SERVER_NAME[]   = L"ServerName";

typedef struct 
{
    OBJECT_ATTRIBUTE    Attribute;
    WCHAR   *           wstrValue;

} REG_INFO;
    
extern REG_INFO g_ConfInstInfoArray[];
extern DWORD    g_ContInstInfoArraySize;

class KEY_WRAP
{
public:

    KEY_WRAP(IN HKEY Key) : m_Key(Key) {}
    ~KEY_WRAP() { if (m_Key) RegCloseKey(m_Key); m_Key = NULL; }

protected:
    HKEY m_Key;
};

class CRegistry
{
public:

    static WCHAR ms_ServerName[MAX_REG_WSTR_SIZE];

    static WCHAR ms_ProtocolId[MAX_REG_WSTR_SIZE];
    static WCHAR ms_SubType[MAX_REG_WSTR_SIZE];
    static WCHAR ms_AdvertisingScope[MAX_REG_WSTR_SIZE];
    static WCHAR ms_IsEncrypted[MAX_REG_WSTR_SIZE];

    static DWORD ms_StartTimeOffset;
    static DWORD ms_StopTimeOffset;

    CRegistry();

    ~CRegistry() { if (m_RendezvousKey)  RegCloseKey(m_RendezvousKey); }

//    inline  CCriticalSection &GetCriticalSection();

//    inline  CEvent &GetEvent();

    BOOL NotifyServerNameChange();

    static BOOL     IsValid()       { return (ERROR_SUCCESS == ms_ErrorCode); }
    static DWORD    GetErrorCode()  { return ms_ErrorCode; }
    static WCHAR *  GetServerName() { return ms_ServerName; }
    static WCHAR *  GetProtocolId() { return ms_ProtocolId; }
    static WCHAR *  GetSubType()    { return ms_SubType; }
    static WCHAR *  GetAdvertizingScope() { return ms_AdvertisingScope; }
    static WCHAR *  GetIsEncrypted() { return ms_IsEncrypted; }

protected:

    static DWORD    ms_ErrorCode;

    // the key is open throughout the lifetime of the CRegistry instance, 
    // so that any modifications to values under the key may be monitored
    HKEY    m_RendezvousKey;

    // the critical section and the event (in particular) have been declared
    // as instance members (rather than static) because the order of 
    // initialization of static variables is undefined and the event is used
    // in the CRegistry constructor 
    // CCriticalSection m_CriticalSection;
    // CEvent           m_Event;
    
    static BOOL    ReadConfInstValues(
        IN    HKEY ConfInstKey
        );

    static BOOL ReadRegValue(
        IN  HKEY            Key,
        IN  const WCHAR *   pName,
        IN  WCHAR *         pValue
        );
};

/*
inline  CCriticalSection &
CRegistry::GetCriticalSection(
    )
{
    return m_CriticalSection;
}
   
inline  CEvent &
CRegistry::GetEvent(
    )
{
    return m_Event;
}
*/




#endif // __RENDEZVOUS_REGISTRY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndsec.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    rndsec.h

Abstract:

    Security utilities for Rendezvous Control.

Environment:

    User Mode - Win32

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#include <iads.h>

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT
ConvertSDToVariant(
    IN  PSECURITY_DESCRIPTOR pSecurityDescriptor,
    OUT VARIANT * pVarSec
    );

HRESULT
ConvertSDToIDispatch(
    IN  PSECURITY_DESCRIPTOR pSecurityDescriptor,
    OUT IDispatch ** ppIDispatch
    );

HRESULT
ConvertObjectToSD(
    IN  IADsSecurityDescriptor FAR * pSecDes,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor,
    OUT PDWORD pdwSDLength
    );

HRESULT
ConvertObjectToSDDispatch(
    IN  IDispatch * pDisp,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor,
    OUT PDWORD pdwSDLength
    );

// Returns FALSE if these two security descriptors are identical.
// Returns TRUE if they differ, or if there is any error parsing either of them
BOOL CheckIfSecurityDescriptorsDiffer(PSECURITY_DESCRIPTOR pSD1,
                                      DWORD dwSDSize1,
                                      PSECURITY_DESCRIPTOR pSD2,
                                      DWORD dwSDSize2);
// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndsec.cpp ===
/*++

Copyright (c) 1995-1999  Microsoft Corporation

Module Name:

    rndsec.cpp

Abstract:

    Security utilities for Rendezvous Control.

Author:

    KrishnaG (from OLEDS team)

Environment:

    User Mode - Win32

Revision History:

    12-Dec-1997 DonRyan
        Munged KrishnaG's code to work with Rendezvous Control.

--*/


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <security.h>

#include <initguid.h>
#include <iads.h>
#include <ntlsa.h>

#include <stdlib.h>
#include <limits.h>

#include <io.h>
#include <wchar.h>
#include <tchar.h>
#include "rndsec.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private macros                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) { goto error; }

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) { continue; }


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private procedures                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


LPWSTR
AllocADsStr(
    LPWSTR pStr
)
{
   LPWSTR pMem;

   if (!pStr)
      return NULL;

   if (pMem = new WCHAR[wcslen(pStr) + 1])
      wcscpy(pMem, pStr);

   return pMem;
}


HRESULT
ConvertSidToString(
    PSID pSid,
    LPWSTR   String
    )

/*++

Routine Description:


    This function generates a printable unicode string representation
    of a SID.

    The resulting string will take one of two forms.  If the
    IdentifierAuthority value is not greater than 2^32, then
    the SID will be in the form:


        S-1-281736-12-72-9-110
              ^    ^^ ^^ ^ ^^^
              |     |  | |  |
              +-----+--+-+--+---- Decimal



    Otherwise it will take the form:


        S-1-0x173495281736-12-72-9-110
            ^^^^^^^^^^^^^^ ^^ ^^ ^ ^^^
             Hexidecimal    |  | |  |
                            +--+-+--+---- Decimal


Arguments:

    pSid - opaque pointer that supplies the SID that is to be
    converted to Unicode.

Return Value:

    If the Sid is successfully converted to a Unicode string, a
    pointer to the Unicode string is returned, else NULL is
    returned.

--*/

{
    WCHAR Buffer[256];
    UCHAR   i;
    ULONG   Tmp;
    HRESULT hr = S_OK;

    SID_IDENTIFIER_AUTHORITY    *pSidIdentifierAuthority;
    PUCHAR                      pSidSubAuthorityCount;

    //
    // IsValidSid fiers an AV is pSid == NULL
    //

    if( NULL == pSid )
    {
        *String= L'\0';
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        return(hr);
    }

    if (!IsValidSid( pSid )) {
        *String= L'\0';
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        return(hr);
    }

    wsprintf(Buffer, L"S-%u-", (USHORT)(((PISID)pSid)->Revision ));
    wcscpy(String, Buffer);

    pSidIdentifierAuthority = GetSidIdentifierAuthority(pSid);

    if (  (pSidIdentifierAuthority->Value[0] != 0)  ||
          (pSidIdentifierAuthority->Value[1] != 0)     ){
        wsprintf(Buffer, L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)pSidIdentifierAuthority->Value[0],
                    (USHORT)pSidIdentifierAuthority->Value[1],
                    (USHORT)pSidIdentifierAuthority->Value[2],
                    (USHORT)pSidIdentifierAuthority->Value[3],
                    (USHORT)pSidIdentifierAuthority->Value[4],
                    (USHORT)pSidIdentifierAuthority->Value[5] );
        wcscat(String, Buffer);

    } else {

        Tmp = (ULONG)pSidIdentifierAuthority->Value[5]          +
              (ULONG)(pSidIdentifierAuthority->Value[4] <<  8)  +
              (ULONG)(pSidIdentifierAuthority->Value[3] << 16)  +
              (ULONG)(pSidIdentifierAuthority->Value[2] << 24);
        wsprintf(Buffer, L"%lu", Tmp);
        wcscat(String, Buffer);
    }

    pSidSubAuthorityCount = GetSidSubAuthorityCount(pSid);

    for (i=0;i< *(pSidSubAuthorityCount);i++ ) {
        wsprintf(Buffer, L"-%lu", *(GetSidSubAuthority(pSid, i)));
        wcscat(String, Buffer);
    }

    return(S_OK);
}


HRESULT
ConvertSidToFriendlyName(
    PSID pSid,
    LPWSTR * ppszAccountName
    )
{
    HRESULT hr = S_OK;
    SID_NAME_USE eUse;
    WCHAR szAccountName[MAX_PATH];
    WCHAR szDomainName[MAX_PATH];
    DWORD dwLen = 0;
    DWORD dwRet = 0;

    LPWSTR pszAccountName = NULL;

    DWORD dwAcctLen = 0;
    DWORD dwDomainLen = 0;
    
    dwAcctLen = sizeof(szAccountName);
    dwDomainLen = sizeof(szDomainName);

    dwRet = LookupAccountSid(
                NULL,
                pSid,
                szAccountName,
                &dwAcctLen,
                szDomainName,
                &dwDomainLen,
                (PSID_NAME_USE)&eUse
                );
    if (!dwRet) {

        hr = ConvertSidToString(
                    pSid,
                    szAccountName
                    );
        BAIL_ON_FAILURE(hr);

        pszAccountName = AllocADsStr(szAccountName);
        if (!pszAccountName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        *ppszAccountName = pszAccountName;

    }else {

        dwLen = wcslen(szAccountName) + wcslen(szDomainName) + 1 + 1;

        pszAccountName = new WCHAR [dwLen];
        if (!pszAccountName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        if (szDomainName[0] && szAccountName[0]) {
            wsprintf(pszAccountName,L"%s\\%s",szDomainName, szAccountName);
        }else if (szAccountName[0]) {
            wsprintf(pszAccountName,L"%s", szAccountName);
        }

        *ppszAccountName = pszAccountName;

    }

error:

    return(hr);
}


//
// Converts an ACE to a variant, but leaves the trustee name unset.
// Instead it returns a pointer to the SID in this ACE, so that 
// we can go back and convert all the SIDs to trustee names at once
// and set them on the ACEs later.
//

HRESULT
ConvertAceToVariant(
    PBYTE     pAce,
    LPVARIANT pvarAce,
    PSID *    ppSid
    )
{
    IADsAccessControlEntry * pAccessControlEntry = NULL;
    IDispatch * pDispatch = NULL;

    DWORD dwAceType = 0;
    DWORD dwAceFlags = 0;
    DWORD dwAccessMask = 0;
    PACE_HEADER pAceHeader = NULL;
    LPBYTE pSidAddress = NULL;
    LPBYTE pOffset = NULL;
    DWORD dwFlags = 0;

    GUID ObjectGUID;
    GUID InheritedObjectGUID;
    WCHAR szObjectGUID[MAX_PATH];
    WCHAR szInheritedObjectGUID[MAX_PATH];

    HRESULT hr = S_OK;

    szObjectGUID[0] = L'\0';
    szInheritedObjectGUID[0] = L'\0';


    VariantInit(pvarAce);

    hr = CoCreateInstance(
                CLSID_AccessControlEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlEntry,
                (void **)&pAccessControlEntry
                );
    BAIL_ON_FAILURE(hr);

    pAceHeader = (ACE_HEADER *)pAce;


    dwAceType = pAceHeader->AceType;
    dwAceFlags = pAceHeader->AceFlags;
    dwAccessMask = *(PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

    switch (dwAceType) {

    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
        pSidAddress =  (LPBYTE)pAceHeader + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK);
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        pOffset = (LPBYTE)((LPBYTE)pAceHeader +  sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
        dwFlags = (DWORD)(*(PDWORD)pOffset);

        //
        // Now advance by the size of the flags
        //
        pOffset += sizeof(ULONG);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

            memcpy(&ObjectGUID, pOffset, sizeof(GUID));

            StringFromGUID2(ObjectGUID, szObjectGUID, MAX_PATH);

            pOffset += sizeof (GUID);

        }

        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {
            memcpy(&InheritedObjectGUID, pOffset, sizeof(GUID));

            StringFromGUID2(InheritedObjectGUID, szInheritedObjectGUID, MAX_PATH);

            pOffset += sizeof (GUID);

        }

        pSidAddress = pOffset;
        break;

    default:
        break;

    }

    //
    // return a pointer to the SID for this ACE, rather than converting the
    // SID to a trustee name (and taking forever for a large ACL)
    //

    *ppSid = (PSID) pSidAddress;

    //
    // Now set all the information in the Access Control Entry
    //

    hr = pAccessControlEntry->put_AccessMask(dwAccessMask);
    hr = pAccessControlEntry->put_AceFlags(dwAceFlags);
    hr = pAccessControlEntry->put_AceType(dwAceType);

    //
    // Extended ACE information
    //
    hr = pAccessControlEntry->put_Flags(dwFlags);

    if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

        //
        // Add in the Object Type GUID
        //
        hr = pAccessControlEntry->put_ObjectType(szObjectGUID);

    }

    if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {

        //
        // Add in the Inherited Object Type GUID
        //

        hr = pAccessControlEntry->put_InheritedObjectType(szInheritedObjectGUID);

    }

    hr = pAccessControlEntry->QueryInterface(
                IID_IDispatch,
                (void **)&pDispatch
                );
    BAIL_ON_FAILURE(hr);

    V_DISPATCH(pvarAce) =  pDispatch;
    V_VT(pvarAce) = VT_DISPATCH;

cleanup:

    if (pAccessControlEntry) {

        pAccessControlEntry->Release();
    }

    return(hr);


error:

    if (pDispatch) {

        pDispatch->Release();

    }

    goto cleanup;
}



BOOL
APIENTRY
LookupArrayOfSids(
    DWORD                         dwCount,
    PSID                        * ppSids,
    LSA_REFERENCED_DOMAIN_LIST ** ppDomains,
    LSA_TRANSLATED_NAME        ** ppTrustees
    )
{

    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains;
    PLSA_TRANSLATED_NAME Names;

    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE PolicyHandle;

    NTSTATUS Status;
    NTSTATUS TmpStatus;

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    //
    // The InitializeObjectAttributes macro presently stores NULL for
    // the SecurityQualityOfService field, so we must manually copy that
    // structure for now.
    //

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    Status = LsaOpenPolicy(
                 NULL,
                 &ObjectAttributes,
                 POLICY_LOOKUP_NAMES,
                 &PolicyHandle
                 );

    if ( !NT_SUCCESS( Status )) {

        // BaseSetLastNTError( Status );
        return( FALSE );
    }

    Status = LsaLookupSids(
                 PolicyHandle,
                 dwCount,
                 ppSids,
                 ppDomains,
                 ppTrustees
                 );

    TmpStatus = LsaClose( PolicyHandle );


    //
    // If an error was returned, check specifically for STATUS_NONE_MAPPED.
    // In this case, we may need to dispose of the returned Referenced Domain
    // List and Names structures.  For all other errors, LsaLookupSids()
    // frees these structures prior to exit.
    //

    if ( !NT_SUCCESS( Status ))
    {
        if (Status == STATUS_NONE_MAPPED)
        {

            if ( *ppDomains != NULL)
            {

                TmpStatus = LsaFreeMemory( *ppDomains );
                _ASSERTE( NT_SUCCESS( TmpStatus ));
                *ppDomains = NULL;
            }

            if ( *ppTrustees != NULL) {

                TmpStatus = LsaFreeMemory( *ppTrustees );
                _ASSERTE( NT_SUCCESS( TmpStatus ));
                *ppTrustees = NULL;
            }
        }

        // BaseSetLastNTError( Status );
        return( FALSE );
    }

    //
    // The Sids were successfully translated.
    //

    return TRUE;
}

//
// ZoltanS
//

HRESULT SetTrusteeOnACE(
            VARIANT * pVarAce,
            PLSA_REFERENCED_DOMAIN_LIST pDomains,
            PLSA_TRANSLATED_NAME        pName
            )
{
    //
    // Make sure pName is valid
    //

    if ((pName->Use == SidTypeInvalid) ||
        (pName->Use == SidTypeUnknown))
    {
        return E_INVALIDARG;
    }

    //
    // Find the domain and account names.
    //

    DWORD   dwAccountNameSize = pName->Name.Length / 2;
    WCHAR * szAccountName = pName->Name.Buffer;

    DWORD   dwDomainNameSize  =
        (pDomains->Domains + pName->DomainIndex)->Name.Length / 2;
    WCHAR * szDomainName  =
        (pDomains->Domains + pName->DomainIndex)->Name.Buffer;


    //
    // Allocate space for the compound name
    //

    DWORD dwLen = dwAccountNameSize + dwDomainNameSize + 1 + 1;
    if( (dwLen <= dwAccountNameSize) || (dwLen<=dwDomainNameSize) )
    {
        return E_FAIL;
    }

    WCHAR * pszAccountName = new WCHAR [dwLen];

    if (!pszAccountName)
    {
       return E_OUTOFMEMORY;
    }

    //
    // Copy in the domain and user name
    // to get the trustee name
    //

    if ( dwDomainNameSize != 0 )
    {
        // strange +1 needed because it will also put in a NULL terminator
        lstrcpynW(pszAccountName, szDomainName, dwDomainNameSize+1);

        lstrcatW(pszAccountName, L"\\");
    }
    else
    {
        pszAccountName[0] = L'\0';
    }

    wcsncat(pszAccountName, szAccountName, dwAccountNameSize);

    //
    // Set the trustee name on the ACE
    //

    IDispatch * pDispatch = V_DISPATCH(pVarAce);

    IADsAccessControlEntry * pACE;

    HRESULT hr;

    hr = pDispatch->QueryInterface(IID_IADsAccessControlEntry,
                                   (void **) & pACE);

    hr = pACE->put_Trustee(pszAccountName);

    pACE->Release();

    delete [] pszAccountName;

    return hr;
}



//
// ZoltanS optimized version of ConvertACLToVariant
//

HRESULT
ConvertACLToVariant(
    PACL pACL,
    LPVARIANT pvarACL
    )
{
    IADsAccessControlList * pAccessControlList = NULL;
    IDispatch * pDispatch = NULL;

    DWORD dwAclSize = 0;
    DWORD dwAclRevision = 0;
    DWORD dwAceCount = 0;

    ACL_SIZE_INFORMATION AclSize;
    ACL_REVISION_INFORMATION AclRevision;
    DWORD dwStatus = 0;

    DWORD i = 0;
    DWORD dwNewAceCount = 0;

    HRESULT hr = S_OK;
    LPBYTE pAceAddress = NULL;


    memset(&AclSize, 0, sizeof(ACL_SIZE_INFORMATION));
    memset(&AclRevision, 0, sizeof(ACL_REVISION_INFORMATION));


    dwStatus = GetAclInformation(
                        pACL,
                        &AclSize,
                        sizeof(ACL_SIZE_INFORMATION),
                        AclSizeInformation
                        );


    dwStatus = GetAclInformation(
                        pACL,
                        &AclRevision,
                        sizeof(ACL_REVISION_INFORMATION),
                        AclRevisionInformation
                        );

    dwAceCount = AclSize.AceCount;
    dwAclRevision = AclRevision.AclRevision;

    VariantInit(pvarACL);

    hr = CoCreateInstance(
                CLSID_AccessControlList,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlList,
                (void **)&pAccessControlList
                );

    if ( FAILED(hr) )
    {
        return hr;
    }

    PSID * apSids = new PSID[ dwAceCount ];

    if ( apSids == NULL )
    {
        pAccessControlList->Release();
        return E_OUTOFMEMORY;
    }

    VARIANT * aVarAces = new VARIANT[ dwAceCount ];

    if ( aVarAces == NULL )
    {
        pAccessControlList->Release();
        delete apSids;
        return E_OUTOFMEMORY;
    }

    for (i = 0; i < dwAceCount; i++)
    {
        dwStatus = GetAce(pACL, i, (void **)&pAceAddress);

        hr = ConvertAceToVariant(
                    pAceAddress,
                    aVarAces + i,
                    apSids   + i );
    }

    //
    // Above, ConvertAceToVariant did not set the trustee names on the ACEs.
    // Instead we have an array (apSids) of dwNewAceCount valid PSIDs.
    // Convert all of these to trustees now.
    //

    PLSA_REFERENCED_DOMAIN_LIST pDomains  = NULL;
    PLSA_TRANSLATED_NAME        pTrustees = NULL;

    BOOL fStatus = LookupArrayOfSids(
                        dwAceCount,       // IN  count
                        apSids,           // IN  array of sid pointers
                        &pDomains,        // OUT referenced domain list
                        &pTrustees);      // OUT translated name list

    delete apSids;


    if ( fStatus == FALSE )
    {
        // LookupArrayOfSids failed
        hr = E_FAIL;
    }
    else
    {
        //
        // Set the trustees on the ACEs here
        //

        for ( i = 0; i < dwAceCount; i++ )
        {
            VARIANT * pVarAce = aVarAces + i;

            hr = SetTrusteeOnACE(
                        pVarAce,
                        pDomains,
                        pTrustees + i
                        );

            hr = pAccessControlList->AddAce( V_DISPATCH ( pVarAce ) );
        
            VariantClear( pVarAce );

            if ( SUCCEEDED(hr) )
            {
               dwNewAceCount++;
            }

        }

        //
        // Free output buffers returned by LsaLookupSids
        //

        DWORD Status;

        Status = LsaFreeMemory( pTrustees );
        _ASSERTE( NT_SUCCESS( Status ));

        Status = LsaFreeMemory( pDomains );
        _ASSERTE( NT_SUCCESS( Status ));

        pAccessControlList->put_AclRevision(dwAclRevision);

        pAccessControlList->put_AceCount(dwNewAceCount);

        hr = pAccessControlList->QueryInterface(
                            IID_IDispatch,
                            (void **)&pDispatch
                            );
        V_VT(pvarACL) = VT_DISPATCH;
        V_DISPATCH(pvarACL) = pDispatch;
    }

    pAccessControlList->Release();

    //
    // aVarAces was dynamic allocated
    // aVarAces should be deallocated
    //
    
    delete aVarAces;

    return(hr);
}


HRESULT
SecCreateSidFromArray (
    OUT PSID                        *PPSid,
    IN  PSID_IDENTIFIER_AUTHORITY   PSidAuthority,
    IN  UCHAR                       SubAuthorityCount,
    IN  ULONG                       SubAuthorities[],
    OUT PDWORD                      pdwSidSize
    )
/*++

Routine Description:

    Creates a SID with desired authority and sub authorities.

    NOTE:  This routine allocates memory for the SID.  When finished
           the caller should free memory using SEC_FREE (PSid).

Arguments:

    PPSid -- addr of ptr to SID to be created
        Note: if SID creation fails ptr set to NULL

    PSidAuthority -- desired value for SID authority

    SubAuthorityCount -- number of sub authorities desired

    SubAuthorities -- sub-authority values, MUST SPECIFY contain
        at least SubAuthorityCount number of values

Return Value:

    STATUS_SUCCESS if SID created.
    STATUS_UNSUCCESSFUL otherwise.

--*/
{
    USHORT  iSub;           /*  sub-authority index */
    DWORD dwSidSize = 0;
    HRESULT hr = S_OK;

    /*  allocate memory for SID */

    dwSidSize = RtlLengthRequiredSid(SubAuthorityCount);
    *PPSid = (PSID) new BYTE[dwSidSize];
    if (! *PPSid){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    *pdwSidSize = dwSidSize;


    /*  initialize SID with top level SID identifier authority */
    RtlInitializeSid( *PPSid, PSidAuthority, SubAuthorityCount);

    /*  fill in sub authorities */
    for (iSub=0; iSub < SubAuthorityCount; iSub++)
        * RtlSubAuthoritySid( *PPSid, iSub) = SubAuthorities[iSub];

    /*  sanity check */

    if ( ! RtlValidSid( *PPSid) ) {
        delete (*PPSid);
        *PPSid = NULL;
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        BAIL_ON_FAILURE(hr);
    }

error:


    return(hr);
}


HRESULT
ConvertStringToSid(
    IN  PWSTR       string,
    OUT PSID       *sid,
    OUT PDWORD     pdwSidSize,
    OUT PWSTR      *end
    )
{
    HRESULT                     hr = S_OK;
    UCHAR                       revision;
    UCHAR                       sub_authority_count;
    SID_IDENTIFIER_AUTHORITY    authority;
    ULONG                       sub_authority[SID_MAX_SUB_AUTHORITIES];
    PWSTR                       end_list;
    PWSTR                       current;
    PWSTR                       next;
    ULONG                       x;

    *sid = NULL;

    if ( string == NULL )
    {
        return E_POINTER;
    }

    if (((*string != L'S') && (*string != L's')) || (*(string + 1) != L'-'))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        BAIL_ON_FAILURE(hr);
    }

    current = string + 2;

    revision = (UCHAR)wcstol(current, &end_list, 10);

    current = end_list + 1;

    //
    // Count the number of characters in the indentifer authority...
    //

    next = wcschr(current, L'-');

    if((next != NULL) &&
        (next - current == 6))
    {
        for(x = 0; x < 6; x++)
        {
            authority.Value[x] = (UCHAR)next[x];
        }

        current +=6;
    }
    else
    {
         ULONG Auto = wcstoul(current, &end_list, 10);
         authority.Value[0] = authority.Value[1] = 0;
         authority.Value[5] = (UCHAR)Auto & 0xF;
         authority.Value[4] = (UCHAR)((Auto >> 8) & 0xFF);
         authority.Value[3] = (UCHAR)((Auto >> 16) & 0xFF);
         authority.Value[2] = (UCHAR)((Auto >> 24) & 0xFF);
         current = end_list;
    }

    //
    // Now, count the number of sub auths
    //
    sub_authority_count = 0;

    //
    // Initialize sub_authority array
    //

    memset( sub_authority, 0, sizeof(ULONG) * SID_MAX_SUB_AUTHORITIES );

    next = current;

    //
    // We'll have to count our sub authoritys one character at a time,
    // since there are several deliminators that we can have...
    //
    while(next)
    {
        next++;

        if(*next == L'-')
        {
            //
            // We've found one!
            //
            sub_authority_count++;
        }
        else if(*next == L';' || *next  == L'\0')
        {
            *end = next;
            sub_authority_count++;
            break;
        }
    }

    if(sub_authority_count != 0)
    {
        current++;

        for(x = 0; x < sub_authority_count; x++)
        {
            sub_authority[x] = wcstoul(current, &end_list, 10);
            current = end_list + 1;
        }
    }

    //
    // Now, create the SID
    //

    hr = SecCreateSidFromArray(
                    sid,
                    &authority,
                    sub_authority_count,
                    sub_authority,
                    pdwSidSize
                    );

    if (SUCCEEDED(hr))
    {
        /* Set the revision to what was specified in the string, in case, our
           system creates one with newer revision */

        ((SID *)(*sid))->Revision = revision;
    }

error:

    return(hr);
}


HRESULT
ConvertTrusteeToSid(
    BSTR bstrTrustee,
    PSID * ppSid,
    PDWORD pdwSidSize
    )
{
    HRESULT hr = S_OK;
    BYTE Sid[MAX_PATH];
    ZeroMemory(Sid, MAX_PATH*sizeof(BYTE));
    DWORD dwSidSize = sizeof(Sid);
    DWORD dwRet = 0;
    WCHAR szDomainName[MAX_PATH];
    DWORD dwDomainSize = sizeof(szDomainName)/sizeof(WCHAR);
    SID_NAME_USE eUse;

    PSID pSid = NULL;
    LPWSTR pszEnd = NULL;
    BOOL fNTDSType = FALSE;

    
    dwSidSize = sizeof(Sid);

    dwRet = LookupAccountName(
                NULL,
                bstrTrustee,
                Sid,
                &dwSidSize,
                szDomainName,
                &dwDomainSize,
                (PSID_NAME_USE)&eUse
                );
    if (!dwRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // If neither the NTDS nor the U2 conversion
    // worked, then try a textual translation
    //

    if (FAILED(hr)) {

        hr = ConvertStringToSid(
                   bstrTrustee,
                    &pSid,
                    &dwSidSize,
                    &pszEnd
                    );
        BAIL_ON_FAILURE(hr);

        memcpy(Sid,pSid, dwSidSize);

        if (pSid) {
            delete pSid;
        }

    }

    pSid = (PSID) new BYTE[dwSidSize];
    if (!pSid) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memcpy(pSid, Sid, dwSidSize);

    *pdwSidSize = dwSidSize;

    *ppSid = pSid;

error:

    return(hr);
}


HRESULT
GetOwnerSecurityIdentifier(
    IADsSecurityDescriptor FAR * pSecDes,
    PSID * ppSid,
    PBOOL pfOwnerDefaulted
    )
{
    BSTR bstrOwner = NULL;
    DWORD dwSidSize = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_Owner(
                    &bstrOwner
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_OwnerDefaulted(
                      &varBool
                      );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {

        if (bstrOwner && *bstrOwner) {

          hr = ConvertTrusteeToSid(
                    bstrOwner,
                    ppSid,
                    &dwSidSize
                    );
          BAIL_ON_FAILURE(hr);
          *pfOwnerDefaulted = FALSE;
        }else {

            *ppSid = NULL;
            *pfOwnerDefaulted = FALSE;
        }

    }else {
        *ppSid = NULL;
        dwSidSize = 0;
        *pfOwnerDefaulted = TRUE;
    }

error:

    if (bstrOwner) {
        SysFreeString(bstrOwner);
    }

    return(hr);
}


HRESULT
ComputeTotalAclSize(
    PACE_HEADER * ppAceHdr,
    DWORD dwAceCount,
    PDWORD pdwAclSize
    )
{
    DWORD i = 0;
    PACE_HEADER pAceHdr = NULL;
    DWORD dwAceSize = 0;
    DWORD dwAclSize = 0;

    for (i = 0; i < dwAceCount; i++) {

        pAceHdr = *(ppAceHdr + i);
        dwAceSize = pAceHdr->AceSize;
        dwAclSize += dwAceSize;
    }

    dwAclSize += sizeof(ACL);

    *pdwAclSize = dwAclSize;

    return(S_OK);

}


HRESULT
ConvertAccessControlEntryToAce(
    IADsAccessControlEntry * pAccessControlEntry,
    LPBYTE * ppAce
    )
{

    DWORD dwAceType = 0;
    HRESULT hr = S_OK;
    BSTR bstrTrustee = NULL;
    PSID pSid = NULL;
    DWORD dwSidSize = 0;

    DWORD dwAceFlags = 0;
    DWORD dwAccessMask = 0;
    DWORD dwAceSize = 0;
    LPBYTE pAce = NULL;
    PACCESS_MASK pAccessMask = NULL;
    PSID pSidAddress = NULL;

    PUSHORT pCompoundAceType = NULL;
    DWORD dwCompoundAceType = 0;

    PACE_HEADER pAceHeader = NULL;

    LPBYTE pOffset = NULL;

    BSTR bstrObjectTypeClsid = NULL;
    BSTR bstrInheritedObjectTypeClsid = NULL;

    GUID ObjectTypeGUID;
    GUID InheritedObjectTypeGUID;
    PULONG pFlags;
    DWORD dwFlags = 0;


    hr = pAccessControlEntry->get_AceType((LONG *)&dwAceType);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_Trustee(&bstrTrustee);
    BAIL_ON_FAILURE(hr);

    hr = ConvertTrusteeToSid(
                bstrTrustee,
                &pSid,
                &dwSidSize
                );
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_AceFlags((long *)&dwAceFlags);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_AccessMask((long *)&dwAccessMask);
    BAIL_ON_FAILURE(hr);

    if( pSid )
    {
        PSID_IDENTIFIER_AUTHORITY pSIA = GetSidIdentifierAuthority( pSid );

		if( pSIA )
		{
			SID_IDENTIFIER_AUTHORITY sidEveryone = SECURITY_WORLD_SID_AUTHORITY;
			if( memcmp(pSIA, &sidEveryone, sizeof(SID_IDENTIFIER_AUTHORITY))== 0)
			{
				// It is an Everyone user
				dwAccessMask |= ADS_RIGHT_READ_CONTROL;
			}
		}
    }

    //
    // we will compensateby adding the entire ACE size
    //

    dwAceSize = dwSidSize - sizeof(ULONG);

    switch (dwAceType) {

    case ACCESS_ALLOWED_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = new BYTE[dwAceSize];
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case ACCESS_DENIED_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = new BYTE[dwAceSize];
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;


        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;


        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case SYSTEM_AUDIT_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = new BYTE[dwAceSize];
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;


        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;


        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;

    case SYSTEM_ALARM_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = new BYTE[dwAceSize];
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        dwAceSize += sizeof(COMPOUND_ACCESS_ALLOWED_ACE);
        pAce = new BYTE[dwAceSize];
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

         pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pCompoundAceType = (PUSHORT)(pAccessMask + sizeof(ACCESS_MASK));
        *pCompoundAceType = (USHORT)dwCompoundAceType;

        //
        // Fill in the reserved field here.
        //

        pSidAddress = (PSID)((LPBYTE)pCompoundAceType + sizeof(DWORD));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:

    case ACCESS_DENIED_OBJECT_ACE_TYPE:

    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:

    case SYSTEM_ALARM_OBJECT_ACE_TYPE:


        hr = pAccessControlEntry->get_AceFlags((LONG *)&dwAceFlags);
        BAIL_ON_FAILURE(hr);

        hr = pAccessControlEntry->get_Flags((LONG *)&dwFlags);
        BAIL_ON_FAILURE(hr);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {
            dwAceSize += sizeof(GUID);
        }

        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {
            dwAceSize += sizeof(GUID);
        }

        hr = pAccessControlEntry->get_ObjectType(&bstrObjectTypeClsid);
        BAIL_ON_FAILURE(hr);

        hr = CLSIDFromString(bstrObjectTypeClsid, &ObjectTypeGUID);
        BAIL_ON_FAILURE(hr);

        hr = pAccessControlEntry->get_InheritedObjectType(&bstrInheritedObjectTypeClsid);
        BAIL_ON_FAILURE(hr);

        hr = CLSIDFromString(bstrInheritedObjectTypeClsid, &InheritedObjectTypeGUID);
        BAIL_ON_FAILURE(hr);



        dwAceSize += sizeof(ACCESS_ALLOWED_OBJECT_ACE);
        pAce = new BYTE[dwAceSize];
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        //
        // Fill in Flags
        //

        pOffset = (LPBYTE)((LPBYTE)pAceHeader +  sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));

        pFlags = (PULONG)(pOffset);

        *pFlags = dwFlags;

        pOffset += sizeof(ULONG);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

            memcpy(pOffset, &ObjectTypeGUID, sizeof(GUID));

            pOffset += sizeof(GUID);

        }


        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {

            memcpy(pOffset, &InheritedObjectTypeGUID, sizeof(GUID));

            pOffset += sizeof(GUID);
        }

        pSidAddress = (PSID)((LPBYTE)pOffset);
        memcpy(pSidAddress, pSid, dwSidSize);
        break;

    }

    *ppAce = pAce;

error:

    if (bstrTrustee) {
        SysFreeString(bstrTrustee);
    }

    if (pSid) {
        delete (pSid);
    }

    return(hr);
}


HRESULT AddACEEveryone(
    IADsAccessControlList FAR * pAccessList
	)
{
	// Declarations
	DWORD dwAceCount = 0;
	HRESULT hr = S_OK;
    IUnknown * pUnknown = NULL;
    IEnumVARIANT * pEnumerator  = NULL;
    DWORD i = 0;
    DWORD cReturned = 0;
    VARIANT varAce;
	BOOL bEveryone = FALSE;
	IADsAccessControlEntry FAR * pAccessControlEntry = NULL;
	IDispatch* pACEDispatch = NULL;
    PSID pSid = NULL;
    DWORD dwSidSize = 0;
	BSTR bstrTrustee = NULL;


	// Get the ACE count
	hr = pAccessList->get_AceCount((long*)&dwAceCount);
	BAIL_ON_FAILURE(hr);

	// Get the ACE enumeration
    hr = pAccessList->get__NewEnum( &pUnknown );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(
		    IID_IEnumVARIANT,
            (void FAR * FAR *)&pEnumerator);
    BAIL_ON_FAILURE(hr);

	// Browse the enumeration
	for (i = 0; i < dwAceCount; i++)
	{
        VariantInit(&varAce);
        hr = pEnumerator->Next(
                    1,
                    &varAce,
                    &cReturned
                    );

        CONTINUE_ON_FAILURE(hr);

        hr = (V_DISPATCH(&varAce))->QueryInterface(
                    IID_IADsAccessControlEntry,
                    (void **)&pAccessControlEntry
                    );
        CONTINUE_ON_FAILURE(hr);

		//
		// Get the user
		//
	    hr = pAccessControlEntry->get_Trustee(&bstrTrustee);
        if( FAILED(hr) )
        {
            // Clean-up
            VariantClear(&varAce);
            pAccessControlEntry->Release();
            pAccessControlEntry = NULL;

            continue;
        }

        //
        // Get the SID
        //
        hr = ConvertTrusteeToSid(
                    bstrTrustee,
                    &pSid,
                    &dwSidSize
                    );

        if( FAILED(hr) )
        {
            // Clean-up
			if( bstrTrustee )
			{
				SysFreeString( bstrTrustee );
				bstrTrustee = NULL;
			}
            VariantClear(&varAce);
            pAccessControlEntry->Release();
            pAccessControlEntry = NULL;

            continue;
        }

        //
        // Validate if is the Everyone SID
        //

        if( pSid )
        {
            PSID_IDENTIFIER_AUTHORITY pSIA = GetSidIdentifierAuthority( pSid );

			if( pSIA )
			{
				SID_IDENTIFIER_AUTHORITY sidEveryone = SECURITY_WORLD_SID_AUTHORITY;
				if( memcmp(pSIA, &sidEveryone, sizeof(SID_IDENTIFIER_AUTHORITY))== 0)
				{
					// It is an Everyone user
					bEveryone = TRUE;

					// Clean-up
					VariantClear(&varAce);
					pAccessControlEntry->Release();
					pAccessControlEntry = NULL;

					// Break the loop
					break;
				}
			}
        }
       
        VariantClear(&varAce);
        if (pAccessControlEntry)
		{
            pAccessControlEntry->Release();
            pAccessControlEntry = NULL;
        }

        if( bstrTrustee )
        {
            SysFreeString( bstrTrustee );
            bstrTrustee = NULL;
        }
    }

	if( !bEveryone)
	{
		// We have to add an everyone entry
		hr = CoCreateInstance( 
			CLSID_AccessControlEntry,
			NULL,
			CLSCTX_INPROC_SERVER,
			IID_IADsAccessControlEntry,
			(void**)&pAccessControlEntry);

		BAIL_ON_FAILURE(hr);

		// Access mask
		hr = pAccessControlEntry->put_AccessMask( ADS_RIGHT_READ_CONTROL );
		BAIL_ON_FAILURE(hr);

		// Ace type
		hr = pAccessControlEntry->put_AceType( 0 );
		BAIL_ON_FAILURE(hr);

		// Ace flags
		hr = pAccessControlEntry->put_AceFlags( 0 );
		BAIL_ON_FAILURE(hr);

		// Get the SID for everyone
	    WCHAR Trustee[256];
	    PSID pSidEveryone = NULL;
		SID_IDENTIFIER_AUTHORITY siaEveryone = SECURITY_WORLD_SID_AUTHORITY;
		BOOL bAllocate = AllocateAndInitializeSid(
			&siaEveryone,
			1,0,0,0,0,0,0,0,0,
			&pSidEveryone);
		if( !bAllocate )
		{
			BAIL_ON_FAILURE(E_OUTOFMEMORY);
		}
		
		// Get the trustee for everyone
		hr = ConvertSidToString( pSidEveryone, Trustee );
		FreeSid( pSidEveryone);
		BAIL_ON_FAILURE(hr);
		bstrTrustee = SysAllocString( Trustee );
		if( bstrTrustee == NULL)
		{
			BAIL_ON_FAILURE(E_OUTOFMEMORY);
		}
		
		// Add trustee
		hr = pAccessControlEntry->put_Trustee( bstrTrustee );
		BAIL_ON_FAILURE(hr);

		// Get the IDispatch
		hr = pAccessControlEntry->QueryInterface(
			IID_IDispatch,
			(void**)&pACEDispatch);
		BAIL_ON_FAILURE(hr);

		// Add ACE to the ACL
		hr = pAccessList->AddAce( pACEDispatch );
		BAIL_ON_FAILURE(hr);
	}

error:
    if (pUnknown) {
        pUnknown->Release();
    }

    if (pEnumerator) {
        pEnumerator->Release();
    }

	if( pACEDispatch )
	{
		pACEDispatch->Release();
	}

	if(pAccessControlEntry)
	{
		pAccessControlEntry->Release();
	}

	if( bstrTrustee )
	{
		SysFreeString( bstrTrustee );
	}

    if (pSid)
    {
        delete (pSid);
    }

    return(hr);
}


HRESULT
ConvertAccessControlListToAcl(
    IADsAccessControlList FAR * pAccessList,
    PACL * ppAcl
    )
{
    IUnknown * pUnknown = NULL;
    IEnumVARIANT * pEnumerator  = NULL;
    HRESULT hr = S_OK;
    DWORD i = 0;
    DWORD cReturned = 0;
    VARIANT varAce;

    DWORD dwAceCount = 0;

    IADsAccessControlEntry FAR * pAccessControlEntry = NULL;

    LPBYTE pTempAce = NULL;
    DWORD dwCount = 0;

    PACL pAcl = NULL;
    DWORD dwAclSize = 0;
    PACE_HEADER * ppAceHdr = NULL;

    DWORD dwRet = 0;
    DWORD dwAclRevision = 0;
    DWORD dwStatus = 0;
    DWORD dwError = 0;

	hr = AddACEEveryone( pAccessList );
	BAIL_ON_FAILURE(hr);

    hr = pAccessList->get_AceCount((long *)&dwAceCount);
    BAIL_ON_FAILURE(hr);


    hr = pAccessList->get__NewEnum(
                    &pUnknown
                    );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(
                        IID_IEnumVARIANT,
                        (void FAR * FAR *)&pEnumerator
                        );
    BAIL_ON_FAILURE(hr);



    ppAceHdr = new PACE_HEADER [dwAceCount];
    if (!ppAceHdr) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwAceCount; i++) {

        VariantInit(&varAce);

        hr = pEnumerator->Next(
                    1,
                    &varAce,
                    &cReturned
                    );

        CONTINUE_ON_FAILURE(hr);


        hr = (V_DISPATCH(&varAce))->QueryInterface(
                    IID_IADsAccessControlEntry,
                    (void **)&pAccessControlEntry
                    );
        CONTINUE_ON_FAILURE(hr);


        hr = ConvertAccessControlEntryToAce(
                    pAccessControlEntry,
                    &(pTempAce)
                    );

        // ZoltanS: Rather than CONTINUE_ON_FAILURE, let's bail so that we
        // know if the Ace we set is invalid.
        BAIL_ON_FAILURE(hr);



        *(ppAceHdr + dwCount) = (PACE_HEADER)pTempAce;

        VariantClear(&varAce);
        if (pAccessControlEntry) {
            pAccessControlEntry->Release();
            pAccessControlEntry = NULL;
        }

        dwCount++;
    }

    hr = ComputeTotalAclSize(ppAceHdr, dwCount, &dwAclSize);
    BAIL_ON_FAILURE(hr);

    pAcl = (PACL)new BYTE[dwAclSize];
    if (!pAcl) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = pAccessList->get_AclRevision((long *)&dwAclRevision);

    //
    // we have to deallocate memory
    //
    if( FAILED(hr) && (NULL != pAcl) )
       delete( pAcl );

    BAIL_ON_FAILURE(hr);


    dwRet  = InitializeAcl(
                    pAcl,
                    dwAclSize,
                    dwAclRevision
                    );
    if (!dwRet) {
        hr  = HRESULT_FROM_WIN32(GetLastError());

        //
        // we have to deallocate memory
        //
        if( FAILED(hr) && (NULL != pAcl) )
           delete( pAcl );

        BAIL_ON_FAILURE(hr);
    }



    for (i = 0; i < dwCount; i++) {

        dwStatus = AddAce(
                        pAcl,
                        dwAclRevision,
                        i,
                        (LPBYTE)*(ppAceHdr + i),
                        (*(ppAceHdr + i))->AceSize
                        );
        if (!dwStatus) {

            dwError = GetLastError();
        }
    }

    *ppAcl = pAcl;
    


error:

    if (ppAceHdr) {
        for (i = 0; i < dwCount; i++) {
            if (*(ppAceHdr + i)) {

                delete (*(ppAceHdr + i));
            }
        }

        delete (ppAceHdr);
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pEnumerator) {
        pEnumerator->Release();
    }

    return(hr);
}


HRESULT
GetGroupSecurityIdentifier(
    IADsSecurityDescriptor FAR * pSecDes,
    PSID * ppSid,
    PBOOL pfGroupDefaulted
    )
{
    BSTR bstrGroup = NULL;
    DWORD dwSidSize = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_Group(
                    &bstrGroup
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_GroupDefaulted(
                      &varBool
                      );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {

        if (bstrGroup && *bstrGroup) {

            hr = ConvertTrusteeToSid(
                    bstrGroup,
                    ppSid,
                    &dwSidSize
                    );
            BAIL_ON_FAILURE(hr);
            *pfGroupDefaulted = FALSE;
        }else {
            *ppSid = NULL;
            *pfGroupDefaulted = FALSE;
        }

    }else {
        *ppSid = NULL;
        dwSidSize = 0;
        *pfGroupDefaulted = TRUE;
    }

error:

    if (bstrGroup) {
        SysFreeString(bstrGroup);
    }

    return(hr);

}


HRESULT
GetDacl(
    IADsSecurityDescriptor FAR * pSecDes,
    PACL * ppDacl,
    PBOOL pfDaclDefaulted
    )
{
    IADsAccessControlList FAR * pDiscAcl = NULL;
    IDispatch FAR * pDispatch = NULL;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_DaclDefaulted(
                        &varBool
                        );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {
        *pfDaclDefaulted = FALSE;
    }else {
        *pfDaclDefaulted = TRUE;
    }

    hr = pSecDes->get_DiscretionaryAcl(
                    &pDispatch
                    );
    BAIL_ON_FAILURE(hr);

    if (!pDispatch) {
        *ppDacl = NULL;
        goto error;
    }

    hr = pDispatch->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&pDiscAcl
                    );
    BAIL_ON_FAILURE(hr);


    hr = ConvertAccessControlListToAcl(
                pDiscAcl,
                ppDacl
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pDiscAcl) {
        pDiscAcl->Release();
    }

    return(hr);
}


HRESULT
GetSacl(
    IADsSecurityDescriptor FAR * pSecDes,
    PACL * ppSacl,
    PBOOL pfSaclDefaulted
    )
{
    IADsAccessControlList FAR * pSystemAcl = NULL;
    IDispatch FAR * pDispatch = NULL;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_SaclDefaulted(
                        &varBool
                        );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {
        *pfSaclDefaulted = FALSE;
    }else {
        *pfSaclDefaulted = TRUE;
    }

    hr = pSecDes->get_SystemAcl(
                    &pDispatch
                    );
    BAIL_ON_FAILURE(hr);

    if (!pDispatch) {
        *ppSacl = NULL;
        goto error;
    }

    hr = pDispatch->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&pSystemAcl
                    );
    BAIL_ON_FAILURE(hr);


    hr = ConvertAccessControlListToAcl(
                pSystemAcl,
                ppSacl
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pSystemAcl) {
        pSystemAcl->Release();
    }

    return(hr);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public procedures                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT
ConvertSDToIDispatch(
    IN  PSECURITY_DESCRIPTOR pSecurityDescriptor,
    OUT IDispatch ** ppIDispatch
    )
{
    IADsSecurityDescriptor * pSecDes = NULL;
    IDispatch * pDispatch = NULL;
    LPWSTR pszGroup = NULL;
    LPWSTR pszOwner = NULL;

    BOOL fOwnerDefaulted = 0;
    BOOL fGroupDefaulted = 0;
    BOOL fDaclDefaulted = 0;
    BOOL fSaclDefaulted = 0;

    BOOL fSaclPresent = 0;
    BOOL fDaclPresent = 0;

    LPBYTE pOwnerSidAddress = NULL;
    LPBYTE pGroupSidAddress = NULL;
    LPBYTE pDACLAddress = NULL;
    LPBYTE pSACLAddress = NULL;

    DWORD dwRet = 0;

    VARIANT varDACL;
    VARIANT varSACL;

    HRESULT hr = S_OK;

    DWORD dwRevision = 0;
    WORD  wControl = 0;

    memset(&varSACL, 0, sizeof(VARIANT));
    memset(&varDACL, 0, sizeof(VARIANT));

    if (!pSecurityDescriptor) {
        return(E_FAIL);
    }


    dwRet = GetSecurityDescriptorControl(
                        pSecurityDescriptor,
                        &wControl,
                        &dwRevision
                        );
    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwRet = GetSecurityDescriptorOwner(
                        pSecurityDescriptor,
                        (PSID *)&pOwnerSidAddress,
                        &fOwnerDefaulted
                        );

    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    hr = ConvertSidToFriendlyName(
                pOwnerSidAddress,
                &pszOwner
                );
    BAIL_ON_FAILURE(hr);


    dwRet = GetSecurityDescriptorGroup(
                        pSecurityDescriptor,
                        (PSID *)&pGroupSidAddress,
                        &fOwnerDefaulted
                        );
    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = ConvertSidToFriendlyName(
                pGroupSidAddress,
                &pszGroup
                );
    BAIL_ON_FAILURE(hr);


    dwRet = GetSecurityDescriptorDacl(
                        pSecurityDescriptor,
                        &fDaclPresent,
                        (PACL*)&pDACLAddress,
                        &fDaclDefaulted
                        );
    if (pDACLAddress) {

        hr = ConvertACLToVariant(
                (PACL)pDACLAddress,
                &varDACL
                );
        BAIL_ON_FAILURE(hr);
    }



    dwRet = GetSecurityDescriptorSacl(
                        pSecurityDescriptor,
                        &fSaclPresent,
                        (PACL *)&pSACLAddress,
                        &fSaclDefaulted
                        );

    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    if (pSACLAddress) {

        hr = ConvertACLToVariant(
                (PACL)pSACLAddress,
                &varSACL
                );
        BAIL_ON_FAILURE(hr);
    }

    hr = CoCreateInstance(
                CLSID_SecurityDescriptor,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsSecurityDescriptor,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Owner(pszOwner);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Group(pszGroup);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Revision(dwRevision);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Control((DWORD)wControl);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_DiscretionaryAcl(V_DISPATCH(&varDACL));
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_SystemAcl(V_DISPATCH(&varSACL));
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    *ppIDispatch = pDispatch;

error:
    VariantClear(&varSACL);
    VariantClear(&varDACL);

    if (pszOwner) {
        delete (pszOwner);
    }

    if (pszGroup) {
        delete (pszGroup);
    }


    if (pSecDes) {
        pSecDes->Release();
    }

    return(hr);
}

HRESULT
ConvertSDToVariant(
    IN  PSECURITY_DESCRIPTOR pSecurityDescriptor,
    OUT VARIANT * pVarSec
    )
{
    IDispatch *pIDispatch;

    HRESULT hr = ConvertSDToIDispatch(pSecurityDescriptor, &pIDispatch);

    if (FAILED(hr))
    {
        return hr;
    }

    VariantInit(pVarSec);
    V_VT(pVarSec)       = VT_DISPATCH;
    V_DISPATCH(pVarSec) = pIDispatch;

    return S_OK;
}


HRESULT
ConvertObjectToSD(
    IN  IADsSecurityDescriptor FAR * pSecDes,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor,
    OUT PDWORD pdwSDLength
    )
{
    HRESULT hr = S_OK;

    SECURITY_DESCRIPTOR AbsoluteSD;
    PSECURITY_DESCRIPTOR pRelative = NULL;
    BOOL Defaulted = FALSE;
    BOOL DaclPresent = FALSE;
    BOOL SaclPresent = FALSE;

    BOOL fDaclDefaulted = FALSE;
    BOOL fSaclDefaulted = FALSE;
    BOOL fOwnerDefaulted = FALSE;
    BOOL fGroupDefaulted = FALSE;

    PSID pOwnerSid = NULL;
    PSID pGroupSid = NULL;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    DWORD   dwSDLength = 0;
    DWORD dwRet = 0;
    BOOL dwStatus = 0;


    //
    // Initialize *pSizeSD = 0;
    //

    dwRet = InitializeSecurityDescriptor (
                &AbsoluteSD,
                SECURITY_DESCRIPTOR_REVISION1
                );
    if (!dwRet) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    hr = GetOwnerSecurityIdentifier(
                pSecDes,
                &pOwnerSid,
                &fOwnerDefaulted
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = SetSecurityDescriptorOwner(
                    &AbsoluteSD,
                    pOwnerSid,
                    fOwnerDefaulted
                    );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = GetGroupSecurityIdentifier(
                pSecDes,
                &pGroupSid,
                &fGroupDefaulted
                );
    BAIL_ON_FAILURE(hr);


    dwStatus = SetSecurityDescriptorGroup(
                    &AbsoluteSD,
                    pGroupSid,
                    fGroupDefaulted
                    );

    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = GetDacl(
            pSecDes,
            &pDacl,
            &fDaclDefaulted
            );
    BAIL_ON_FAILURE(hr);


    if (pDacl || fDaclDefaulted) {
        DaclPresent = TRUE;
    }

    dwStatus = SetSecurityDescriptorDacl(
                    &AbsoluteSD,
                    DaclPresent,
                    pDacl,
                    fDaclDefaulted
                    );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }



    hr = GetSacl(
            pSecDes,
            &pSacl,
            &fSaclDefaulted
            );
    BAIL_ON_FAILURE(hr);


    if (pSacl || fSaclDefaulted) {
        SaclPresent = TRUE;
    }

    dwStatus = SetSecurityDescriptorSacl(
                    &AbsoluteSD,
                    SaclPresent,
                    pSacl,
                    fSaclDefaulted
                    );

    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    dwSDLength = GetSecurityDescriptorLength(
                        &AbsoluteSD
                        );

    pRelative = new BYTE[dwSDLength];
    if (!pRelative) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    if (!MakeSelfRelativeSD (&AbsoluteSD, pRelative, &dwSDLength)) {
        delete (pRelative);

        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    *ppSecurityDescriptor = pRelative;
    *pdwSDLength = dwSDLength;

cleanup:

    if (pDacl) {
        delete (pDacl);
    }

    if (pSacl) {
        delete (pSacl);
    }

    if (pOwnerSid) {
        delete (pOwnerSid);
    }

    if (pGroupSid) {
        delete (pGroupSid);
    }

    return(hr);

error:
    if (pRelative) {
        delete (pRelative);
    }

    *ppSecurityDescriptor = NULL;
    *pdwSDLength = 0;

    goto cleanup;

}

HRESULT
ConvertObjectToSDDispatch(
    IN  IDispatch * pDisp,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor,
    OUT PDWORD pdwSDLength
    )
{
    HRESULT hr;
    IADsSecurityDescriptor * pSecDes;

    hr = pDisp->QueryInterface(
        IID_IADsSecurityDescriptor,
        (VOID **)&pSecDes
        );

    if (FAILED(hr))
    {
        return hr;
    }

    hr = ConvertObjectToSD(pSecDes, ppSecurityDescriptor, pdwSDLength);

    //
    // Release the reference to the pSecSes
    //

    pSecDes->Release();

    return hr;
}

// Returns FALSE if these two security descriptors are identical.
// Returns TRUE if they differ, or if there is any error parsing either of them
BOOL CheckIfSecurityDescriptorsDiffer(PSECURITY_DESCRIPTOR pSD1,
                                      DWORD dwSDSize1,
                                      PSECURITY_DESCRIPTOR pSD2,
                                      DWORD dwSDSize2)
{
    //
    // If one of them is null, then they differ. (It should be impossible for them
    // to both be null, but if they are, they had better both have size 0, which
    // would just make us return TRUE below, so that's ok.)
    //

    if ( ( pSD1 == NULL ) || ( pSD2 == NULL ) )
    {
        return TRUE;
    }

    // if they converted to different sized structures then they are different
    if ( dwSDSize1 != dwSDSize2 )
    {
        return TRUE;
    }

    // we know both succeeded conversion and converted to the same sized structures
    // if the structures contain the same bytes then they are identical
    if ( 0 == memcmp(pSD1, pSD2, dwSDSize1) )
    {
        return FALSE;
    }

    // else they differ
    return TRUE;
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndrend.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    rndrend.cpp

Abstract:

    This module contains implementation of CRendezvous control.
    
--*/

#include "stdafx.h"

#include "rndrend.h"
#include "rndcoll.h"
#include "rndreg.h"
#include "rndnt.h"
#include "rndils.h"
#include "rndndnc.h"
#include "rndldap.h"

#include <atlwin.cpp>


CRegistry   g_RregistryInfo;

CRendezvous::~CRendezvous() 
{
    if (m_fWinsockReady)
    {
        WSACleanup();
    }

    if ( m_pFTM )
    {
        m_pFTM->Release();
    }
}

HRESULT CRendezvous::FinalConstruct(void)
{
    LOG((MSP_TRACE, "CRendezvous::FinalConstruct - enter"));

    HRESULT hr = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                & m_pFTM );

    if ( FAILED(hr) )
    {
        LOG((MSP_INFO, "CRendezvous::FinalConstruct - "
            "create FTM returned 0x%08x; exit", hr));

        return hr;
    }

    LOG((MSP_TRACE, "CRendezvous::FinalConstruct - exit S_OK"));

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Private functions
/////////////////////////////////////////////////////////////////////////////
HRESULT CRendezvous::InitWinsock()
{
    Lock();

    if (!m_fWinsockReady)
    {
        WSADATA wsaData; 
        int err;
    
        // initialize winsock
        if (err = WSAStartup(RENDWINSOCKVERSION, &wsaData)) 
        {
            Unlock();
            return HRESULT_FROM_ERROR_CODE(err);
        }
        m_fWinsockReady = TRUE;
    }

    Unlock();
    return S_OK;
}

HRESULT CRendezvous::CreateNTDirectory(
    OUT ITDirectory **ppDirectory
    )
/*++

Routine Description:
    
    Create a object that uses NTDS to support the ITDirectory.
    
Arguments:
    
    ppDirectory - the object being created.
    
Return Value:

    HRESULT.

--*/
{
    HRESULT hr;

    // create the NTDS directory, if NTDS exists.
    CComObject<CNTDirectory> * pNTDirectory;
    hr = CComObject<CNTDirectory>::CreateInstance(&pNTDirectory);

    if (NULL == pNTDirectory)
    {
        LOG((MSP_ERROR, "can't create NT Directory Object."));
        return hr;
    }

    hr = pNTDirectory->_InternalQueryInterface(
        IID_ITDirectory,
        (void **)ppDirectory
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateNTDirectory:QueryInterface failed: %x", hr));
        delete pNTDirectory;
        return hr;
    }    

    return S_OK;
}

HRESULT CRendezvous::CreateILSDirectory(
    IN  const WCHAR * const wstrName,
    IN  const WORD          wPort,
    OUT ITDirectory **      ppDirectory
    )
/*++

Routine Description:
    
    Create a object that uses ILS to support the ITDirectory.
    
Arguments:
    
    wstrName    - The ILS server name.

    wPort       - The port that the server is listening on.

    ppDirectory - the object being created.
    
Return Value:

    HRESULT.

--*/
{
    HRESULT hr;

    // create the com object.
    CComObject<CILSDirectory> * pILSDirectory;
    hr = CComObject<CILSDirectory>::CreateInstance(&pILSDirectory);

    if (NULL == pILSDirectory)
    {
        LOG((MSP_ERROR, "can't create ILS Directory Object."));
        return hr;
    }

    // init the object with the server name and port.
    hr = pILSDirectory->Init(wstrName, wPort);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateILSDirectory:Init failed: %x", hr));
        delete pILSDirectory;
        return hr;
    }    

    // get the ITDirectory interface.
    hr = pILSDirectory->_InternalQueryInterface(
        IID_ITDirectory,
        (void **)ppDirectory
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateILSDirectory:QueryInterface failed: %x", hr));
        delete pILSDirectory;
        return hr;
    }    

    return S_OK;
}

HRESULT CRendezvous::CreateNDNCDirectory(
    IN  const WCHAR * const wstrName,
    IN  const WORD          wPort,
    OUT ITDirectory **      ppDirectory
    )
/*++

Routine Description:
    
    Create a object that uses an NDNC to support the ITDirectory.
    
Arguments:
    
    wstrName    - The NDNC server name.

    wPort       - The port that the server is listening on.

    ppDirectory - the object being created.
    
Return Value:

    HRESULT.

--*/
{
    LOG((MSP_TRACE, "CRendezvous::CreateNDNCDirectory - enter"));

    HRESULT hr;

    //
    // create the com object.
    //
    
    CComObject<CNDNCDirectory> * pNDNCDirectory;
    hr = CComObject<CNDNCDirectory>::CreateInstance(&pNDNCDirectory);

    if ( NULL == pNDNCDirectory )
    {
        LOG((MSP_ERROR, "CreateNDNCDirectory - "
               "can't create NDNC Directory Object - exit 0x%08x", hr));

        return hr;
    }

    //
    // get the ITDirectory interface.
    //
    
    hr = pNDNCDirectory->_InternalQueryInterface(
        IID_ITDirectory,
        (void **)ppDirectory
        );

    if ( FAILED( hr ) )
    {
        LOG((MSP_ERROR, "CreateNDNCDirectory - "
               "QueryInterface failed - exit 0x%08x", hr));

        delete pNDNCDirectory;

        return hr;
    }    

    //
    // init the object with the server name and port.
    // For NDNCs, this also looks around on the server and tries to
    // see where on the server the NDNC is supposed to live. If there
    // is no TAPI NDNC in the domain, this will fail. Therefore, when
    // enumerating default directories, the local DC won't show up as
    // an NDNC if there is no NDNC accessible from the local DC.
    //
    
    hr = pNDNCDirectory->Init(wstrName, wPort);

    if ( FAILED( hr ) )
    {
        LOG((MSP_ERROR, "CreateNDNCDirectory - "
                "Init failed - exit 0x%08x", hr));

        (*ppDirectory)->Release();
        *ppDirectory = NULL;
        
        return hr;
    }    

    LOG((MSP_TRACE, "CRendezvous::CreateNDNCDirectory - exit S_OK"));
    return S_OK;
}

HRESULT CRendezvous::CreateDirectories(
    SimpleVector <ITDirectory *> &VDirectory
    )
/*++

Routine Description:
    
    Find out all the direcories that are available.
    
Arguments:

    pppDirectory - the array of directories being created.

    dwCount - The number of directories.
    
Return Value:

    HRESULT.

--*/
{

    HRESULT hr;

    LOG((MSP_TRACE, "CreateDirectories: "));

    ITDirectory * pDirectory;

    //
    // First, create the NTDS non-dynamic directory object.
    //
    
    if (SUCCEEDED(hr = CreateNTDirectory(&pDirectory)))
    {
        if (!VDirectory.add(pDirectory))
        {
            pDirectory->Release();
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((MSP_WARN, "Cannot create NT directory: 0x%08x", hr));
    }

    //
    // Second, create the NDNC directory object.
    //

    WCHAR * pDomainControllerName;

    //
    // The first argument (=0) means we find out all
    // objects
    //

    hr = GetDomainControllerName(0, &pDomainControllerName);

    if ( SUCCEEDED(hr) )
    {
        hr = CreateNDNCDirectory(
            pDomainControllerName,
            LDAP_PORT,
            &pDirectory
            );

        delete pDomainControllerName;

        if ( SUCCEEDED( hr ) )
        {
            if (!VDirectory.add(pDirectory))
            {
                pDirectory->Release();
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            LOG((MSP_WARN, "Cannot create NDNC directory: 0x%08x", hr));
        }
    }
    else
    {
        LOG((MSP_WARN, "Cannot get DC name: 0x%08x", hr));
    }

    //
    // Third, find out if there are any ILS servers published in the NTDS.
    //
    
    HANDLE hLookup;
    int ret = ::LookupILSServiceBegin(&hLookup);

    if (ret != NOERROR)
    {
        LOG((MSP_WARN, "Lookup ILSservice failed: 0x%08x", ret));
    }
    else
    {
        const   DWORD MAX_HOST_NAME_LEN = 511;
        WCHAR   HostName[MAX_HOST_NAME_LEN + 1];
        DWORD   dwLen = MAX_HOST_NAME_LEN;
        WORD    wPort;

        while (::LookupILSServiceNext(
                hLookup,
                HostName,
                &dwLen,
                &wPort
                ) == NOERROR)
        {
            LOG((MSP_INFO, "ILS server in NTDS: %S, Port:%d", 
                HostName, wPort));
     
            hr = CreateILSDirectory(HostName, wPort, &pDirectory);

            if (SUCCEEDED(hr))
            {
                if (!VDirectory.add(pDirectory))
                {
                    pDirectory->Release();
                    return E_OUTOFMEMORY;
                }
            }
            else
            {
                LOG((MSP_WARN, "Cannot create ILS directory: 0x%08x", hr));
            }

            dwLen = MAX_HOST_NAME_LEN;
        }
        ::LookupILSServiceEnd(hLookup);    
    }

    return S_OK;
}

HRESULT CRendezvous::CreateDirectoryEnumerator(
    IN  ITDirectory **      begin,
    IN  ITDirectory **      end,
    OUT IEnumDirectory **   ppIEnum
    )
/*++

Routine Description:
    
    Create a enumerator of directories.
    
Arguments:

    begin   - The start iterator.

    end     - The end iterator.

    ppIEnum - The enumerator being created.
    
Return Value:

    HRESULT.

--*/
{
    typedef _CopyInterface<ITDirectory> CCopy;
    typedef CSafeComEnum<IEnumDirectory, &IID_IEnumDirectory,
        ITDirectory *, CCopy> CEnumerator;

    HRESULT hr;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = CComObject<CEnumerator>::CreateInstance(&pEnum);
    if (pEnum == NULL)
    {
        LOG((MSP_ERROR, "Could not create enumerator object, %x", hr));
        return hr;
    }

    hr = pEnum->Init(begin, end, NULL, AtlFlagCopy);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "init enumerator object failed, %x", hr));
        delete pEnum;
        return hr;
    }

    // query for the IID_IEnumDirectory i/f
    hr = pEnum->_InternalQueryInterface(IID_IEnumDirectory, (void**)ppIEnum);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "query enum interface failed, %x", hr));
        delete pEnum;
        return hr;
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// ITRendezvous
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRendezvous::get_DefaultDirectories(
    OUT     VARIANT * pVariant
    )
{
    if (BadWritePtr(pVariant))
    {
        LOG((MSP_ERROR, "bad variant pointer in get_DefaultDirectories"));
        return E_POINTER;
    }

    BAIL_IF_FAIL(InitWinsock(), "Init winsock");

    // create the default directories.
    SimpleVector <ITDirectory *> VDirectory;
    CreateDirectories(VDirectory);

    // create the collection.
    HRESULT hr = ::CreateInterfaceCollection(VDirectory.size(),
                                             &VDirectory[0],
                                             &VDirectory[VDirectory.size()],
                                             pVariant);

    // the collection has its ref count, so release local ones.
    for (DWORD i = 0; i < VDirectory.size(); i ++)
    {
        VDirectory[i]->Release();
    }

    return hr;
}

STDMETHODIMP CRendezvous::EnumerateDefaultDirectories(
    OUT     IEnumDirectory ** ppEnumDirectory
    )
{
    if (BadWritePtr(ppEnumDirectory))
    {
        LOG((MSP_ERROR, "bad pointer in EnumerateDefaultDirectories"));
        return E_POINTER;
    }

    BAIL_IF_FAIL(InitWinsock(), "Init winsock");

    // create the default directories.
    SimpleVector <ITDirectory *> VDirectory;
    CreateDirectories(VDirectory);

    // create the enumerator
    HRESULT hr = CreateDirectoryEnumerator(
        &VDirectory[0], 
        &VDirectory[VDirectory.size()],
        ppEnumDirectory
        );

    for (DWORD i = 0; i < VDirectory.size(); i ++)
    {
        VDirectory[i]->Release();
    }

    return hr;
}

STDMETHODIMP CRendezvous::CreateDirectory(
    IN      DIRECTORY_TYPE  DirectoryType,
    IN      BSTR            pName,
    OUT     ITDirectory **  ppDir
    )
{
    if (BadWritePtr(ppDir))
    {
        LOG((MSP_ERROR, "bad pointer in CreateDirectory"));
        return E_POINTER;
    }

    //
    // We should validate the pName
    // If is NULL we should return E_INVALIDARG
    //

    if( IsBadStringPtr( pName, (UINT)-1))
    {
        LOG((MSP_ERROR, "bad Name pointer in CreateDirectory"));
        return E_INVALIDARG;
    }

    BAIL_IF_FAIL(InitWinsock(), "Init winsock");

    HRESULT hr;

    switch (DirectoryType)
    {
    case DT_NTDS:
        hr = CreateNTDirectory(ppDir);
        break;
    
    case DT_ILS:

        //
        // Try NDNC first, as ILS is legacy. The CreateNDNCDirectory actually
        // goes on the wire and checks if it looks like an NDNC server; the
        // CreateILSDirectory does no such thing. This maintains the ability
        // to use custom ports with ILS, and it also preserves the semantics
        // of not getting a failure returned for a bad server name until you
        // call ITDirectory::Connect.
        //

        hr = CreateNDNCDirectory(pName, LDAP_PORT, ppDir);

        if ( FAILED(hr) )
        {
            hr = CreateILSDirectory(pName, ILS_PORT, ppDir);
        }
        
        break;

    default:
        LOG((MSP_ERROR, "unknown directory type, %x", DirectoryType));
        hr = E_INVALIDARG;
    }

    return hr;
}


STDMETHODIMP CRendezvous::CreateDirectoryObject(
    IN      DIRECTORY_OBJECT_TYPE   DirectoryObjectType,
    IN      BSTR                    pName,
    OUT     ITDirectoryObject **    ppDirectoryObject
    )
{
    if (BadWritePtr(ppDirectoryObject))
    {
        LOG((MSP_ERROR, "bad pointer in CreateDirectoryObject"));
        return E_POINTER;
    }

    BAIL_IF_FAIL(InitWinsock(), "Init winsock");

    HRESULT hr;

    switch (DirectoryObjectType)
    {
    case OT_CONFERENCE:
        hr = ::CreateEmptyConference(pName, ppDirectoryObject);
        break;
    
    case OT_USER:
        hr = ::CreateEmptyUser(pName, ppDirectoryObject);
        break;

    default:
        LOG((MSP_ERROR, "unknown directory type, %x", DirectoryObjectType));
        hr = E_INVALIDARG;
    }

    return hr; // ZoltanS fix 6-1-98
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rnduser.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    rnduser.h

Abstract:

    Definitions for CUser class.

Author:

    Mu Han (muhan)   12-5-1997

--*/

#ifndef __RNDUSER_H
#define __RNDUSER_H

#pragma once

#include "rnddo.h"

/////////////////////////////////////////////////////////////////////////////
// CUser
/////////////////////////////////////////////////////////////////////////////

const DWORD NUM_USER_ATTRIBUTES = 
        USER_ATTRIBUTES_END - USER_ATTRIBUTES_BEGIN - 1;

template <class T>
class  ITDirectoryObjectUserVtbl : public ITDirectoryObjectUser
{
};

class CUser : 
    public CDirectoryObject,
    public CComDualImpl<
                ITDirectoryObjectUserVtbl<CUser>, 
                &IID_ITDirectoryObjectUser, 
                &LIBID_RENDLib
                >
{
public:

BEGIN_COM_MAP(CUser)
    COM_INTERFACE_ENTRY(ITDirectoryObjectUser)
    COM_INTERFACE_ENTRY_CHAIN(CDirectoryObject)
END_COM_MAP()

//
// ITDirectoryObject overrides (not implemented by CDirectoryObject)
//

    STDMETHOD (get_Name) (
        OUT BSTR *pVal
        );

    STDMETHOD (put_Name) (
        IN BSTR Val
        );

    STDMETHOD (get_DialableAddrs) (
        IN  long        dwAddressTypes,   //defined in tapi.h
        OUT VARIANT *   pVariant
        );

    STDMETHOD (EnumerateDialableAddrs) (
        IN  DWORD                   dwAddressTypes, //defined in tapi.h
        OUT IEnumDialableAddrs **   pEnumDialableAddrs
        );

    STDMETHOD (GetTTL)(
        OUT DWORD *    pdwTTL
        );

//
// ITDirectoryObjectPrivate overrides (not implemented by CDirectoryObject)
//

    STDMETHOD (GetAttribute)(
        IN  OBJECT_ATTRIBUTE    Attribute,
        OUT BSTR *              ppAttributeValue
        );

    STDMETHOD (SetAttribute)(
        IN  OBJECT_ATTRIBUTE    Attribute,
        IN  BSTR                pAttributeValue
        );

//    
// ITDirectoryObjectUser
//

    STDMETHOD (get_IPPhonePrimary) (
        OUT BSTR *ppName
        );

    STDMETHOD (put_IPPhonePrimary) (
        IN  BSTR newVal
        );

    //
    // IDispatch  methods
    //

    STDMETHOD(GetIDsOfNames)(REFIID riid, 
                             LPOLESTR* rgszNames,
                             UINT cNames, 
                             LCID lcid, 
                             DISPID* rgdispid
                            );

    STDMETHOD(Invoke)(DISPID dispidMember, 
                      REFIID riid, 
                      LCID lcid,
                      WORD wFlags, 
                      DISPPARAMS* pdispparams, 
                      VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, 
                      UINT* puArgErr
                      );

public:

    CUser() 
    {
        m_Type = OT_USER;
    }

    HRESULT Init(BSTR bName);

    virtual ~CUser() {}

protected:

    HRESULT GetSingleValueBstr(
        IN  OBJECT_ATTRIBUTE    Attribute,
        OUT BSTR    *           AttributeValue
        );

    HRESULT SetSingleValue(
        IN  OBJECT_ATTRIBUTE    Attribute,
        IN  WCHAR   *           AttributeValue
        );

    HRESULT SetDefaultSD();


protected:
    CTstr                   m_Attributes[NUM_USER_ATTRIBUTES];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rnduser.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    rnduser.cpp

Abstract:

    This module contains implementation of CUser object.

Author:

    Rajeevb,

Modification history:

    Mu Han (muhan)   12-5-1997

--*/

#include "stdafx.h"

#include "rnduser.h"

const WCHAR * const UserAttributeNames[] = 
{
    L"SamAccountName",   // ZoltanS: was "cn" -- we need SamAccountName for ntds.
    L"telephoneNumber",
    L"IPPhone"
};

#define INC_ACCESS_ACL_SIZE(_SIZE_, _SID_)	\
		_SIZE_ += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid(_SID_));

#define BAIL_ON_BOOLFAIL(_FN_) \
		if ( !_FN_ )									\
		{												\
			hr = HRESULT_FROM_WIN32(GetLastError());	\
			goto failed;								\
		}

#define ACCESS_READ		0x10
#define ACCESS_WRITE	0x20
#define ACCESS_MODIFY   (ACCESS_WRITE | WRITE_DAC)
#define ACCESS_DELETE   DELETE

#define ACCESS_ALL		(ACCESS_READ | ACCESS_MODIFY | ACCESS_DELETE)



HRESULT
ConvertStringToSid(
    IN  PWSTR       string,
    OUT PSID       *sid,
    OUT PDWORD     pdwSidSize,
    OUT PWSTR      *end
    );

HRESULT
ConvertACLToVariant(
    PACL pACL,
    LPVARIANT pvarACL
    );



/////////////////////////////////////////////////////////////////////////////
// non-interface class methods
/////////////////////////////////////////////////////////////////////////////
HRESULT CUser::Init(BSTR bName)
{
    HRESULT hr;

    hr = SetSingleValue(UA_USERNAME, bName);
    BAIL_IF_FAIL(hr, "can't set user name");

    hr = SetDefaultSD();
    BAIL_IF_FAIL(hr, "Init the security descriptor");

    return hr;
}

HRESULT    
CUser::GetSingleValueBstr(
    IN  OBJECT_ATTRIBUTE    Attribute,
    OUT BSTR    *           AttributeValue
    )
{
    LOG((MSP_INFO, "CUser::GetSingleValueBstr - entered"));

    BAIL_IF_BAD_WRITE_PTR(AttributeValue, E_POINTER);

    if (!ValidUserAttribute(Attribute))
    {
        LOG((MSP_ERROR, "Invalid Attribute, %d", Attribute));
        return E_FAIL;
    }

    CLock Lock(m_lock);
    if(!m_Attributes[UserAttrIndex(Attribute)])
    {
        LOG((MSP_ERROR, "Attribute %S is not found", 
            UserAttributeName(Attribute)));
        return E_FAIL;
    }

    *AttributeValue = SysAllocString(m_Attributes[UserAttrIndex(Attribute)]);
    if (*AttributeValue == NULL)
    {
        return E_OUTOFMEMORY;
    }

    LOG((MSP_INFO, "CUser::get %S: %S", 
        UserAttributeName(Attribute), *AttributeValue));
    return S_OK;
}


HRESULT    
CUser::SetSingleValue(
    IN  OBJECT_ATTRIBUTE    Attribute,
    IN  WCHAR *             AttributeValue
    )
{
    LOG((MSP_INFO, "CUser::SetSingleValue - entered"));

    if (!ValidUserAttribute(Attribute))
    {
        LOG((MSP_ERROR, "Invalid Attribute, %d", Attribute));
        return E_FAIL;
    }

    if (AttributeValue != NULL) 
    {
        BAIL_IF_BAD_READ_PTR(AttributeValue, E_POINTER);
    }

    CLock Lock(m_lock);
    if (!m_Attributes[UserAttrIndex(Attribute)].set(AttributeValue))
    {
        LOG((MSP_ERROR, "Can not add attribute %S",
            UserAttributeName(Attribute)));
        return E_OUTOFMEMORY;
    }

    LOG((MSP_INFO, "CUser::set %S to %S", 
        UserAttributeName(Attribute), AttributeValue));
    return S_OK;
}

/*++

Routine Description:
    
    Set the right security descriptor for the conference.
    
Arguments:

Return Value:

    HRESULT.

--*/
HRESULT 
CUser::SetDefaultSD()
{
    LOG((MSP_INFO, "CConference::SetDefaultSD - entered"));

    //
    // The security descriptor
    //

  	IADsSecurityDescriptor* pSecDesc = NULL;

   	HRESULT hr = S_OK;
	bool bOwner = false, bWorld = false;
	PACL pACL = NULL;
	PSID pSidWorld = NULL;
	DWORD dwAclSize = sizeof(ACL), dwTemp;
	BSTR bstrTemp = NULL;
	LPWSTR pszTemp = NULL;

    HANDLE hToken;
    UCHAR *pInfoBuffer = NULL;
    DWORD cbInfoBuffer = 512;

    //
    // Try to get the thread or process token
    //

	if( !OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken) )
	{
        //
        // If there was a sever error we exit
        //

    	if( GetLastError() != ERROR_NO_TOKEN )
		{
            LOG((MSP_ERROR, "CConference::SetDefaultSD - exit E_FAIL "
                "OpenThreadToken failed!"));
            return E_FAIL;
        }

        //
		// Attempt to open the process token, since no thread token exists
        //

		if( !OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken) )
        {
            LOG((MSP_ERROR, "CConference::SetDefaultSD - exit E_FAIL "
                "OpenProcessToken failed"));
			return E_FAIL;
        }
	}

    //
	// Loop until we have a large enough structure
    //

	while ( (pInfoBuffer = new UCHAR[cbInfoBuffer]) != NULL )
	{
		if ( !GetTokenInformation(hToken, TokenUser, pInfoBuffer, cbInfoBuffer, &cbInfoBuffer) )
		{
			delete pInfoBuffer;
			pInfoBuffer = NULL;

			if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
				return E_FAIL;
		}
		else
		{
			break;
		}
	}

	CloseHandle(hToken);

    //
	// Did we get the owner ACL?
    //

	if ( pInfoBuffer )
	{
		INC_ACCESS_ACL_SIZE( dwAclSize, ((PTOKEN_USER) pInfoBuffer)->User.Sid );
		bOwner = true;
	}

    //
	// Make SID for "Everyone"
    //

	SysReAllocString( &bstrTemp, L"S-1-1-0" );
	hr = ConvertStringToSid( bstrTemp, &pSidWorld, &dwTemp, &pszTemp );
	if ( SUCCEEDED(hr) )
	{
		INC_ACCESS_ACL_SIZE( dwAclSize, pSidWorld );
		bWorld = true;
	}

    //
    // Create a security descriptor
    //

    hr = CoCreateInstance(
                CLSID_SecurityDescriptor,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsSecurityDescriptor,
                (void **)&pSecDesc
                );
    if( FAILED(hr) )
    {

        LOG((MSP_ERROR, "CConference::SetDefaultSD - exit 0x%08x "
            "Create security descriptor failed!", hr));

        goto failed;

    }


	//
	// Create the ACL containing the Owner and World ACEs
    //

	pACL = (PACL) new BYTE[dwAclSize];
	if ( pACL )
	{
		BAIL_ON_BOOLFAIL( InitializeAcl(pACL, dwAclSize, ACL_REVISION) );

		// Add World Rights
		if ( bWorld )
		{
			if ( bOwner )
			{
				BAIL_ON_BOOLFAIL( AddAccessAllowedAce(pACL, ACL_REVISION, ACCESS_READ, pSidWorld) );
			}
			else
			{
				BAIL_ON_BOOLFAIL( AddAccessAllowedAce(pACL, ACL_REVISION, ACCESS_ALL , pSidWorld) );
			}
		}

		// Add Creator rights
		if ( bOwner )
			BAIL_ON_BOOLFAIL( AddAccessAllowedAce(pACL, ACL_REVISION, ACCESS_ALL, ((PTOKEN_USER) pInfoBuffer)->User.Sid) );


		// Set the DACL onto our security descriptor
		VARIANT varDACL;
		VariantInit( &varDACL );
		if ( SUCCEEDED(hr = ConvertACLToVariant((PACL) pACL, &varDACL)) )
		{
			if ( SUCCEEDED(hr = pSecDesc->put_DaclDefaulted(FALSE)) )
            {
				hr = pSecDesc->put_DiscretionaryAcl( V_DISPATCH(&varDACL) );
                if( SUCCEEDED(hr) )
                {
                    hr = put_SecurityDescriptor((IDispatch*)pSecDesc);
                    if( SUCCEEDED(hr) )
                    {
                        hr = this->put_SecurityDescriptorIsModified(TRUE);
                    }
                }

            }
		}
		VariantClear( &varDACL );
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

// Clean up
failed:
	SysFreeString( bstrTemp );
	if ( pACL ) delete pACL;
	if ( pSidWorld ) delete pSidWorld;
	if ( pInfoBuffer ) delete pInfoBuffer;
    if( pSecDesc ) pSecDesc->Release();

    LOG((MSP_INFO, "CConference::SetDefaultSD - exit 0x%08x", hr));
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// ITDirectoryObject
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CUser::get_Name(BSTR * ppVal)
{
    return GetSingleValueBstr(UA_USERNAME, ppVal);
}

STDMETHODIMP CUser::put_Name(BSTR pVal)
{
    return SetSingleValue(UA_USERNAME, pVal);
}

STDMETHODIMP CUser::get_DialableAddrs(
    IN  long        dwAddressTypes,   //defined in tapi.h
    OUT VARIANT *   pVariant
    )
{
    BAIL_IF_BAD_WRITE_PTR(pVariant, E_POINTER);
    
    HRESULT hr;

    BSTR *Addresses = new BSTR[1];    // only one for now.
    BAIL_IF_NULL(Addresses, E_OUTOFMEMORY);

    switch (dwAddressTypes)
    {
    case LINEADDRESSTYPE_DOMAINNAME:
        hr = GetSingleValueBstr(UA_IPPHONE_PRIMARY, &Addresses[0]);
        break;

    case LINEADDRESSTYPE_IPADDRESS:
        {
            BSTR  pDomainName;
            DWORD dwIP;    

            hr = GetSingleValueBstr(UA_IPPHONE_PRIMARY, &pDomainName);

            if ( SUCCEEDED(hr) )
            {
                hr = ResolveHostName(0, pDomainName, NULL, &dwIP);

                SysFreeString(pDomainName);

                if ( SUCCEEDED(hr) )
                {
                    WCHAR wszIP[20];

                    ipAddressToStringW(wszIP, dwIP);

                    Addresses[0] = SysAllocString(wszIP);

                    if ( Addresses[0] == NULL )
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
        break;
    
    case LINEADDRESSTYPE_PHONENUMBER:
        hr = GetSingleValueBstr(UA_TELEPHONE_NUMBER, &Addresses[0]);
        break;

    default:
        hr = E_FAIL;
        break;
    }

    DWORD dwCount = (FAILED(hr)) ? 0 : 1;
    
    hr = ::CreateBstrCollection(dwCount,                 // count
                                &Addresses[0],           // begin pointer
                                &Addresses[dwCount],     // end pointer
                                pVariant,                // return value
                                AtlFlagTakeOwnership);   // flags

    // the collection will destroy the Addresses array eventually.
    // no need to free anything here. Even if we tell it to hand
    // out zero objects, it will delete the array on construction.
    // (ZoltanS verified.)

    return hr;
}

STDMETHODIMP CUser::EnumerateDialableAddrs(
    IN  DWORD                   dwAddressTypes, //defined in tapi.h
    OUT IEnumDialableAddrs **   ppEnumDialableAddrs
    )
{
    BAIL_IF_BAD_WRITE_PTR(ppEnumDialableAddrs, E_POINTER);

    HRESULT hr;

    BSTR *Addresses = new BSTR[1];    // only one for now.
    BAIL_IF_NULL(Addresses, E_OUTOFMEMORY);

    switch (dwAddressTypes)
    {
    case LINEADDRESSTYPE_IPADDRESS:
        {
            BSTR  pDomainName;
            DWORD dwIP;    

            hr = GetSingleValueBstr(UA_IPPHONE_PRIMARY, &pDomainName);

            if ( SUCCEEDED(hr) )
            {
                hr = ResolveHostName(0, pDomainName, NULL, &dwIP);

                SysFreeString(pDomainName);

                if ( SUCCEEDED(hr) )
                {
                    WCHAR wszIP[20];

                    ipAddressToStringW(wszIP, dwIP);

                    Addresses[0] = SysAllocString(wszIP);

                    if ( Addresses[0] == NULL )
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
        break;

    case LINEADDRESSTYPE_DOMAINNAME:
        hr = GetSingleValueBstr(UA_IPPHONE_PRIMARY, &Addresses[0]);
        break;
    
    case LINEADDRESSTYPE_PHONENUMBER:
        hr = GetSingleValueBstr(UA_TELEPHONE_NUMBER, &Addresses[0]);
        break;

    default:
        hr = E_FAIL;
        break;
    }

    DWORD dwCount = (FAILED(hr)) ? 0 : 1;
    hr = ::CreateDialableAddressEnumerator(
        &Addresses[0], 
        &Addresses[dwCount],
        ppEnumDialableAddrs
        );
    
    // the enumerator will destroy the Addresses array eventually,
    // so no need to free anything here. Even if we tell it to hand
    // out zero objects, it will delete the array on destruction.
    // (ZoltanS verified.)

    return hr;
}

STDMETHODIMP CUser::GetAttribute(
    IN  OBJECT_ATTRIBUTE    Attribute,
    OUT BSTR *              ppAttributeValue
    )
{
    return GetSingleValueBstr(Attribute, ppAttributeValue);
}

STDMETHODIMP CUser::SetAttribute(
    IN  OBJECT_ATTRIBUTE    Attribute,
    IN  BSTR                pAttributeValue
    )
{
    return SetSingleValue(Attribute, pAttributeValue);
}

STDMETHODIMP CUser::GetTTL(
    OUT DWORD *    pdwTTL
    )
{
    BAIL_IF_BAD_WRITE_PTR(pdwTTL, E_POINTER);

    *pdwTTL = 0;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// ITDirectoryObjectUser
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUser::get_IPPhonePrimary(
    OUT BSTR *pVal
    )
{
    return GetSingleValueBstr(UA_IPPHONE_PRIMARY, pVal);
}

STDMETHODIMP CUser::put_IPPhonePrimary(
    IN  BSTR newVal
    )
{
    // ZoltanS: we now need to check the BSTR, as the ResolveHostName
    // call below doesn't check it before using it.
    // Second argument is the maximum length of string to check -- we want
    // to check the whole thing, so we say (UINT) -1, which is about 2^32.

    if ( IsBadStringPtr(newVal, (UINT) -1) )
    {
        LOG((MSP_ERROR, "CUser::put_IPPhonePrimary: bad BSTR"));
        return E_POINTER;
    }
        
    // ZoltanS: We shouldn't let the user set an IPPhonePrimary value that
    // doesn't resolve to a known host / IP. Check here.
    char  * pchFullDNSName = NULL; // we don't really care what we get
    DWORD   dwIp           = 0;    // we don't really care what we get

    // This is our utility function from rndutil.cpp.
    HRESULT hr = ResolveHostName(0, newVal, &pchFullDNSName, &dwIp);
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CUser::put_IPPhonePrimary: unresolvable name"));
        return hr;
    }
   
    // Now actually set it.
    return SetSingleValue(UA_IPPHONE_PRIMARY, newVal);
}

typedef IDispatchImpl<ITDirectoryObjectUserVtbl<CUser>, &IID_ITDirectoryObjectUser, &LIBID_RENDLib>    CTDirObjUser;

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CUser::GetIDsOfNames
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP CUser::GetIDsOfNames(REFIID riid,
                                      LPOLESTR* rgszNames, 
                                      UINT cNames, 
                                      LCID lcid, 
                                      DISPID* rgdispid
                                      ) 
{ 
    LOG((MSP_TRACE, "CUser::GetIDsOfNames[%p] - enter. Name [%S]",this, *rgszNames));


    HRESULT hr = DISP_E_UNKNOWNNAME;



    //
    // See if the requsted method belongs to the default interface
    //

    hr = CTDirObjUser::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((MSP_TRACE, "CUser::GetIDsOfNames - found %S on CTDirObjUser", *rgszNames));
        rgdispid[0] |= IDISPDIROBJUSER;
        return hr;
    }

    
    //
    // If not, then try the CDirectoryObject base class
    //

    hr = CDirectoryObject::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((MSP_TRACE, "CUser::GetIDsOfNames - found %S on CDirectoryObject", *rgszNames));
        rgdispid[0] |= IDISPDIROBJECT;
        return hr;
    }

    LOG((MSP_ERROR, "CUser::GetIDsOfNames[%p] - finish. didn't find %S on our iterfaces",*rgszNames));

    return hr; 
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CUser::Invoke
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP CUser::Invoke(DISPID dispidMember, 
                              REFIID riid, 
                              LCID lcid, 
                              WORD wFlags, 
                              DISPPARAMS* pdispparams, 
                              VARIANT* pvarResult, 
                              EXCEPINFO* pexcepinfo, 
                              UINT* puArgErr
                             )
{
    LOG((MSP_TRACE, "CUser::Invoke[%p] - enter. dispidMember %lx",this, dispidMember));

    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    DWORD   dwInterface = (dispidMember & INTERFACEMASK);
   
   
    //
    // Call invoke for the required interface
    //

    switch (dwInterface)
    {
        case IDISPDIROBJUSER:
        {
            hr = CTDirObjUser::Invoke(dispidMember, 
                                    riid, 
                                    lcid, 
                                    wFlags, 
                                    pdispparams,
                                    pvarResult, 
                                    pexcepinfo, 
                                    puArgErr
                                   );
        
            LOG((MSP_TRACE, "CUser::Invoke - ITDirectoryObjectUser"));

            break;
        }

        case IDISPDIROBJECT:
        {
            hr = CDirectoryObject::Invoke(dispidMember, 
                                        riid, 
                                        lcid, 
                                        wFlags, 
                                        pdispparams,
                                        pvarResult, 
                                        pexcepinfo, 
                                        puArgErr
                                       );

            LOG((MSP_TRACE, "CUser::Invoke - ITDirectoryObject"));

            break;
        }

    } // end switch (dwInterface)

    
    LOG((MSP_TRACE, "CUser::Invoke[%p] - finish. hr = %lx", hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\stdafx.h ===
/*

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently

*/


#if !defined(AFX_STDAFX_H__F1029E51_CB5B_11D0_8D59_00C04FD91AC0__INCLUDED_)
#define AFX_STDAFX_H__F1029E51_CB5B_11D0_8D59_00C04FD91AC0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT
#define SECURITY_WIN32

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <windef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <tapi3.h>
    
#undef ASSERT

#ifdef __cplusplus
}
#endif

#define _ATL_FREE_THREADED

#include <oleauto.h>
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <time.h>
#include <winsock2.h>
#include <winldap.h>

// the real template name is longer that the limit of debug information.
// we got a lot of this warning. 
#pragma warning (disable:4786)

#include <mspenum.h> // for CSafeComEnum

#include "rnderr.h"
#include "resource.h"
#include "rndsec.h"

#include <msplog.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F1029E51_CB5B_11D0_8D59_00C04FD91AC0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\thread.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    thread.cpp 

Abstract:

    This module contains implementation of MSP thread management.

Author:
    
    Mu Han (muhan)   1-11-1998

--*/
#include "stdafx.h"
#include <objbase.h>

#include "rndcommc.h"
#include "rndutil.h"
#include "thread.h"
#include "rendp.h"

CRendThread g_RendThread;

extern "C" DWORD WINAPI gfThreadProc(LPVOID p)
{
    return ((CRendThread *)p)->ThreadProc();
}

CRendThread::~CRendThread()
{
    // all code moved from here to CRendThread::Shutdown
}

//
// Since this class is instantiated above as a global object, and
// _Module.Term() is called in DLL_PROCESS_DETACH before this
// global object is destroyed, we must release all our COM references
// in DLL_PROCESS_DETACH before the _Module.Term(). This is because
// the _Module.Term() deletes a critical section that must be
// acquired whenever a COM object is released. Therefore we have this
// shutdown method, which we call explicitly in the DLL_PROCESS_DETACH
// handling code before we call _Module.Term().
// 

void CRendThread::Shutdown(void)
{
    CLock Lock(m_lock);

    if (m_hThread) 
    {
        Stop();
    }

    for (DWORD i = 0; i < m_Directories.size(); i ++)
    {
        m_Directories[i]->Release();
    }

    if (m_hEvents[EVENT_TIMER]) 
    {
        CloseHandle(m_hEvents[EVENT_TIMER]);
        m_hEvents[EVENT_TIMER] = NULL;
    }

    if (m_hEvents[EVENT_STOP]) 
    {
        CloseHandle(m_hEvents[EVENT_STOP]);
        m_hEvents[EVENT_STOP] = NULL;
    }

}

HRESULT CRendThread::Start()
/*++

Routine Description:

    Create the thread.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    HRESULT hr = E_FAIL;

    while (TRUE)  // break if fail, for clean up purpose.
    {
        if ((m_hEvents[EVENT_STOP] = ::CreateEvent(
            NULL, 
            FALSE,      // flag for manual-reset event 
            FALSE,      // initial state is not set.
            NULL        // No name.
            )) == NULL)
        {
            LOG((MSP_ERROR, ("Can't create the signal event")));
            hr = HRESULT_FROM_ERROR_CODE(GetLastError());
            break;
        }

        if ((m_hEvents[EVENT_TIMER] = ::CreateWaitableTimer(
            NULL,    // lpTimerAttributes
            FALSE,   // bManualReset
            NULL     // lpTimerName
            )) == NULL)
        {
            LOG((MSP_ERROR, ("Can't create timer. Error: %d"), GetLastError()));
            hr = HRESULT_FROM_ERROR_CODE(GetLastError());
            break;
        }

        DWORD dwThreadID;
        m_hThread = ::CreateThread(NULL, 0, gfThreadProc, this, 0, &dwThreadID);

        if (m_hThread == NULL)
        {
            LOG((MSP_ERROR, ("Can't create thread. Error: %d"), GetLastError()));
            hr = HRESULT_FROM_ERROR_CODE(GetLastError());
            break;
        }

        return S_OK;
    }

    if (m_hEvents[EVENT_TIMER]) 
    {
        CloseHandle(m_hEvents[EVENT_TIMER]);
        m_hEvents[EVENT_TIMER] = NULL;
    }

    if (m_hEvents[EVENT_STOP]) 
    {
        CloseHandle(m_hEvents[EVENT_STOP]);
        m_hEvents[EVENT_STOP] = NULL;
    }

    return hr;
}

HRESULT CRendThread::Stop()
/*++

Routine Description:

    Stop the thread.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    if (!StopThread())
    {
        LOG((MSP_ERROR, ("can't stop the thread. %d"), GetLastError()));
        return HRESULT_FROM_ERROR_CODE(GetLastError());
    }

    // Wait until the thread stops
    if (::WaitForSingleObject(m_hThread, INFINITE) != WAIT_OBJECT_0)
    {
        LOG((MSP_ERROR, ("waiting for the thread to stop, %d"), GetLastError()));
        return HRESULT_FROM_ERROR_CODE(GetLastError());
    }
    else
    {
        ::CloseHandle(m_hThread);
        m_hThread   = NULL;
    }
    return S_OK;
}

HRESULT CRendThread::AddDirectory(ITDirectory *pITDirectory)
/*++

Routine Description:

    Add a new directory to the list. The directory will be notified to 
    update its objects when the timer goes out.

Arguments:
    
    pITDirectory    - A pointer to a ITDirectory Interface.

Return Value:

--*/
{
    ITDynamicDirectory * pDir;

    HRESULT hr = pITDirectory->QueryInterface(
        IID_ITDynamicDirectory, 
        (void **)&pDir
        );

    if (FAILED(hr))
    {
        return hr;
    }

    CLock Lock(m_lock);
    
    if (m_hThread == NULL)
    {
        hr = Start();
        if (FAILED(hr))
        {
            pDir->Release();
            return hr;
        }
    }

    for (DWORD i = 0; i < m_Directories.size(); i ++)
    {
        if (m_Directories[i] == pDir)
        {
            //
            // It was already in the list, so don't keep a second reference
            // to it.
            //

            pDir->Release();
            return S_OK;
        }
    }

    if (!m_Directories.add(pDir))
    {
        pDir->Release();
        return E_OUTOFMEMORY;
    }

    //
    // We have successfully added the directory to the list and
    // kept a reference to it. It is released on Remove or on destruction of
    // the thread class.
    //

    return S_OK;
}

HRESULT CRendThread::RemoveDirectory(ITDirectory *pITDirectory)
/*++

Routine Description:

    Remove a directory from the list. 

Arguments:
    
    pITDirectory    - A pointer to a ITDirectory Interface.

Return Value:

--*/
{
    CComPtr<ITDynamicDirectory> pDir;

    HRESULT hr = pITDirectory->QueryInterface(
        IID_ITDynamicDirectory, 
        (void **)&pDir
        );

    if (FAILED(hr))
    {
        return hr;
    }

    CLock Lock(m_lock);
    
    if (m_hThread == NULL)
    {
        hr = Start();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    for (DWORD i = 0; i < m_Directories.size(); i ++)
    {
        if (m_Directories[i] == pDir)
        {
            //
            // We kept a reference to the directory when we added it for
            // autorefresh. Release it now.
            //

            m_Directories[i]->Release();
            
            //
            // Copy the last array element to the removed element and shrink
            // the array by one. Can do this because order does not matter.
            //

            m_Directories[i] = m_Directories[m_Directories.size() - 1];
            m_Directories.shrink();

            return S_OK;
        }
    }

    return S_OK;
}

VOID CRendThread::UpdateDirectories()
/*++

Routine Description:

    Notify all the directories to update the objects.

Arguments:
    
Return Value:

--*/
{
    if (m_lock.TryLock())
    {
        for (DWORD i = 0; i < m_Directories.size(); i ++)
        {
            m_Directories[i]->Update(TIMER_PERIOD);
        }
        m_lock.Unlock();
    }
}

HRESULT CRendThread::ThreadProc()
/*++

Routine Description:

    the main loop of this thread.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    HRESULT hr;
    LARGE_INTEGER liDueTime;

    const long UNIT_IN_SECOND = (long)1e7;  

    // initialize update timer due time, negative mean relative.
    liDueTime.QuadPart = Int32x32To64(-(long)TIMER_PERIOD, UNIT_IN_SECOND);

    if (!SetWaitableTimer(
            m_hEvents[EVENT_TIMER], // hTimer
            &liDueTime,             // DueTime in 100 nanonsecond units
            (long)(TIMER_PERIOD * 1e3),     // miliseconds
            NULL,                   // pfnCompletionRoutine
            NULL,                   // lpArgToCompletionRoutine
            FALSE                   // fResume
            ))
    {
        LOG((MSP_ERROR, ("Can't enable timer. Error: %d"), GetLastError()));
        return HRESULT_FROM_ERROR_CODE(GetLastError());
    }
    
    if (FAILED(hr = ::CoInitializeEx(NULL, COINIT_MULTITHREADED)))
    {
        LOG((MSP_ERROR, ("CRendThread:ConinitialzeEx failed:%x"), hr));
        return hr;
    }

    LOG((MSP_TRACE, ("thread proc started")));

    BOOL bExitFlag = FALSE;
    while (!bExitFlag)
    {
        DWORD dwResult = ::WaitForMultipleObjects(
            NUM_EVENTS,  // wait for all the events.
            m_hEvents,
            FALSE,       // return if any of them is set
            INFINITE     // wait forever.
            );

        switch (dwResult)
        {
        case WAIT_OBJECT_0 + EVENT_STOP:
            bExitFlag = TRUE;
            break;

        case WAIT_OBJECT_0 + EVENT_TIMER:
            UpdateDirectories();
            break;
        }

    }

    ::CoUninitialize();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndutil.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    rndutil.h

Abstract:

    Definitions for some utility classes and functions.
--*/

#ifndef __RENDEZVOUS_GENERAL__
#define __RENDEZVOUS_GENERAL__

#include "rndcommc.h"

// extra includes for new GetDomainControllerName function.
#include <dsgetdc.h>
#include <objbase.h>
#include <lmcons.h>
#include <lmapibuf.h>

/////////////////////////////////////////////////////////////////////////////
// CBstr is a smart pointer for a BSTR.
/////////////////////////////////////////////////////////////////////////////
class CBstr
{
public:

    CBstr() : m_Bstr(NULL) {}
    ~CBstr()      { if (m_Bstr) SysFreeString(m_Bstr); }

    BSTR &GetBstr()     { return m_Bstr; }
    operator BSTR()     { return m_Bstr; }
    BSTR *operator&()   { return &m_Bstr; }

    HRESULT SetBstr(const TCHAR * const wStr)
    {
        if (NULL == m_Bstr)
        {
            m_Bstr = SysAllocString(wStr);
            return (NULL == m_Bstr) ? E_OUTOFMEMORY : S_OK;
        }
        else 
            return (!SysReAllocString(&m_Bstr, wStr)) ? E_OUTOFMEMORY : S_OK;
    }

protected:
    BSTR    m_Bstr;
};

/////////////////////////////////////////////////////////////////////////////
// CTstr is a smart pointer for a TSTR.
/////////////////////////////////////////////////////////////////////////////
class CTstr
{
public:
    CTstr() : m_p(NULL){}
    CTstr(TCHAR *p) : m_p(p){}
    ~CTstr() { delete m_p; }

    operator TCHAR * ()     { return m_p; }
    TCHAR ** operator& ()   { return &m_p; }
    BOOL operator! ()   { return (m_p == NULL); }
    BOOL set (TCHAR *p)
    { 
        if (p == NULL)
        {
            delete m_p;
            m_p = NULL;
            return TRUE;
        }
        
        TCHAR *t = new TCHAR [lstrlen(p) + 1];
        if (t == NULL) return FALSE;
        delete m_p;
        m_p = t;
        lstrcpy(m_p, p);
        return TRUE;
    }

private:
    TCHAR   *m_p;
};

/////////////////////////////////////////////////////////////////////////////
// CTstr is a smart pointer for a TSTR.
/////////////////////////////////////////////////////////////////////////////
template <class T>
class CSmartPointer
{
public:
    CSmartPointer() : m_p(NULL){}
    CSmartPointer(T *p) : m_p(p){}
    ~CSmartPointer() { delete m_p; }

    operator T * ()     { return m_p; }
    T ** operator& ()   { return &m_p; }
    BOOL operator! ()   { return (m_p == NULL); }

private:
    T   *m_p;
};

/////////////////////////////////////////////////////////////////////////////
// _CopyBSTR is used in creating BSTR enumerators.
/////////////////////////////////////////////////////////////////////////////
class _CopyBSTR
{
public:
#if _ATL_VER >= 0x0203
    static HRESULT copy(BSTR *p1, BSTR *p2)
    {
            (*p1) = SysAllocString(*p2);
            if (*p1)
                return S_OK;
            else
                return E_OUTOFMEMORY;
    }
#else
    static void copy(BSTR *p1, BSTR *p2)
    {
            (*p1) = SysAllocString(*p2);
    }
#endif
    static void init(BSTR* p) {*p = NULL;}
    static void destroy(BSTR* p) { SysFreeString(*p);}
};

/////////////////////////////////////////////////////////////////////////////
// my critical section
/////////////////////////////////////////////////////////////////////////////
class CCritSection
{
private:
    CRITICAL_SECTION m_CritSec;

public:
    CCritSection()
    {
        InitializeCriticalSection(&m_CritSec);
    }

    ~CCritSection()
    {
        DeleteCriticalSection(&m_CritSec);
    }

    void Lock() 
    {
        EnterCriticalSection(&m_CritSec);
    }

    BOOL TryLock() 
    {
        return TryEnterCriticalSection(&m_CritSec);
    }

    void Unlock() 
    {
        LeaveCriticalSection(&m_CritSec);
    }
};

/////////////////////////////////////////////////////////////////////////////
// an auto lock that uses my critical section
/////////////////////////////////////////////////////////////////////////////
class CLock
{
private:
    CCritSection &m_CriticalSection;

public:
    CLock(CCritSection &CriticalSection)
        : m_CriticalSection(CriticalSection)
    {
        m_CriticalSection.Lock();
    }

    ~CLock()
    {
        m_CriticalSection.Unlock();
    }
};

/////////////////////////////////////////////////////////////////////////////
// an simple vector implementation
/////////////////////////////////////////////////////////////////////////////
const DWORD DELTA = 8;

template <class T, DWORD delta = DELTA>
class SimpleVector
{
public:
    SimpleVector() : m_dwSize(0), m_dwCapacity(0), m_Elements(NULL) {};
    ~SimpleVector() {if (m_Elements) free(m_Elements); }

    BOOL add(T& elem)
    {
        return grow(1) ? (m_Elements[m_dwSize ++] = elem, TRUE) : FALSE;
    }

    BOOL add()
    {
        return grow(1) ? (m_dwSize ++, TRUE) : FALSE;
    }

    DWORD shrink(DWORD i = 1)
    {
        return m_dwSize -= i;
    }

    void removeAt(DWORD i)
    {
        m_Elements[ i ] = m_Elements[ --m_dwSize ];
    }

    void reset()
    {
        m_dwSize = 0;
        m_dwCapacity = 0;
        if (m_Elements) free(m_Elements);
        m_Elements = NULL;
    }

    DWORD size() const { return m_dwSize; }
    T& operator [] (DWORD index) { return m_Elements[index]; }
    const T* elements() const { return m_Elements; };

protected:
    BOOL grow(DWORD i)
    {
        // grow by one element. If it is out of capacity, allocate more.
        if (m_dwSize + i>= m_dwCapacity)
        {
            DWORD dwInc = ((m_dwSize + i - m_dwCapacity) / delta + 1) * delta;
            T *p = (T*)realloc(m_Elements, (sizeof T)*(m_dwCapacity + dwInc));
            if (p == NULL)
            {
                return FALSE;
            }
            m_Elements = p;
            m_dwCapacity += delta;
        }
        return TRUE;
    }

protected:
    DWORD m_dwSize;
    DWORD m_dwCapacity;
    T *   m_Elements;
};

/////////////////////////////////////////////////////////////////////////////
// other inline functions
/////////////////////////////////////////////////////////////////////////////

HRESULT GetDomainControllerName(
    IN  ULONG    ulFlags,
    OUT WCHAR ** ppszName
    );

HRESULT CreateDialableAddressEnumerator(
    IN  BSTR *                  begin,
    IN  BSTR *                  end,
    OUT IEnumDialableAddrs **   ppIEnum
    );

HRESULT CreateBstrCollection(
    IN  long        nSize,
    IN  BSTR *      begin,
    IN  BSTR *      end,
    OUT VARIANT *   pVariant,
    CComEnumFlags   flags    
    );

HRESULT CreateDirectoryObjectEnumerator(
    IN  ITDirectoryObject **    begin,
    IN  ITDirectoryObject **    end,
    OUT IEnumDirectoryObject ** ppIEnum
    );

HRESULT CreateEmptyUser(
    IN  BSTR                    pName,
    OUT ITDirectoryObject **    ppDirectoryObject
    );

HRESULT CreateEmptyConference(
    IN  BSTR                    pName,
    OUT ITDirectoryObject **    ppDirectoryObject
    );

HRESULT CreateConferenceWithBlob(
    IN  BSTR                    pName,
    IN  BSTR                    pProtocol,
    IN  BSTR                    pBlob,
    IN  CHAR *                  pSecurityDescriptor,
    IN  DWORD                   dwSDSize,
    OUT ITDirectoryObject **    ppDirectoryObject
    );

HRESULT ResolveHostName(
    DWORD       dwInterface,
    TCHAR *     pHost, 
    char **     pFullName, 
    DWORD *     pdwIP
    );

int LookupILSServiceBegin(
    HANDLE *    pHandle
    );

int LookupILSServiceNext(
    HANDLE      Handle,
    TCHAR *     pBuf,
    DWORD *     pdwBufSize,
    WORD *      pwPort
    );

int LookupILSServiceEnd(
    HANDLE      Handle
    );

void ipAddressToStringW(
    WCHAR * wszDest,
    DWORD dwAddress
    );

#endif // __RENDEZVOUS_GENERAL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\rndutil.cpp ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    rndutil.cpp

Abstract:

    This module contains implementation of rend helper functions.

--*/

#include "stdafx.h"

#include "rndcommc.h"
#include "rndils.h"
#include "rndsec.h"
#include "rndcoll.h"
#include "rnduser.h"
#include "rndldap.h"
#include "rndcnf.h"

//////////////////////////////////////////////////////////////////////////////
// GetDomainControllerName (helper funcion)
//
// This function retrieves the name of the nearest domain controller for the
// machine's domain. It allows the caller to specify flags to indicate if a
// domain controller is desired, etc.
//
// Argument: receives a pointer to a new'ed string containing the name
//           of the DC. This is a fully qualified domain name in
//           the format "foo.bar.com.", NOT "\\foo.bar.com.".
//
// Returns an HRESULT:
//      S_OK          : it worked
//      E_OUTOFMEMORY : not enough memory to allocate the string
//      other         : reason for failure of ::DsGetDcName()
//
//////////////////////////////////////////////////////////////////////////////

HRESULT GetDomainControllerName(
    IN  ULONG    ulFlags,
    OUT WCHAR ** ppszName
    )
{
    // We are a helper function, so we only assert...
    _ASSERTE( ! IsBadWritePtr( ppszName, sizeof(WCHAR *) ) );

    LOG((MSP_TRACE, "GetDomainControllerName: Querying DS..."));

    //
    // Ask the system for the location of the GC (Global Catalog).
    //

    DWORD dwCode;
    DOMAIN_CONTROLLER_INFO * pDcInfo = NULL;
    dwCode = DsGetDcName(
            NULL,    // LPCWSTR computername, (default: this one)
            NULL,    // LPCWSTR domainname,   (default: this one)
            NULL,    // guid * domainguid,    (default: this one)
            NULL,    // LPCWSTR sitename,     (default: this one)
            ulFlags, // ULONG Flags, (what do we want)
            &pDcInfo // receives pointer to output structure
        );

    if ( (dwCode != NO_ERROR) || (pDcInfo == NULL) )
    {
        LOG((MSP_ERROR, "GetDomainControllerName: "
                "DsGetDcName failed; returned %d.\n", dwCode));

        return HRESULT_FROM_ERROR_CODE(dwCode);
    }

    //
    // Do a quick sanity check in debug builds. If we get the wrong name we
    // will fail right after this, so this is only useful for debugging.
    //

    // In case we find we need to use the address instead of the name:
    // _ASSERTE( pDcInfo->DomainControllerAddressType == DS_INET_ADDRESS );

    _ASSERTE( pDcInfo->Flags & DS_GC_FLAG );

    //
    // If we've got something like "\\foo.bar.com.", skip the "\\".
    //

    WCHAR * pszName = pDcInfo->DomainControllerName;

    while (pszName[0] == '\\')
    {
        pszName++;
    }

    LOG((MSP_TRACE, "GetDomainControllerName: DC name is %S", pszName));

    //
    // Allocate and copy the output string.
    //

    *ppszName = new WCHAR[lstrlenW(pszName) + 1];
 
    if ( (*ppszName) == NULL)
    {
        LOG((MSP_ERROR, "GetDomainControllerName: "
                "out of memory in string allocation"));

        NetApiBufferFree(pDcInfo);

        return E_OUTOFMEMORY;
    }

    lstrcpyW(*ppszName, pszName);

    //
    // Release the DOMAIN_CONTROLLER_INFO structure.
    //

    NetApiBufferFree(pDcInfo);

    //
    // All done.
    //

    LOG((MSP_TRACE, "GetDomainControllerName: exit S_OK"));
    return S_OK;
}

HRESULT CreateDialableAddressEnumerator(
    IN  BSTR *                  begin,
    IN  BSTR *                  end,
    OUT IEnumDialableAddrs **   ppIEnum
    )
{
    typedef CSafeComEnum<IEnumDialableAddrs, &IID_IEnumDialableAddrs, 
        BSTR, _CopyBSTR> CEnumerator;

    HRESULT hr;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = CComObject<CEnumerator>::CreateInstance(&pEnum);
    if (pEnum == NULL)
    {
        LOG((MSP_ERROR, "Could not create enumerator object, %x", hr));
        return hr;
    }

    hr = pEnum->Init(begin, end, NULL, AtlFlagTakeOwnership); 

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "init enumerator object failed, %x", hr));
        delete pEnum;
        return hr;
    }

    // query for the IID_IEnumDirectory i/f
    hr = pEnum->_InternalQueryInterface(
        IID_IEnumDialableAddrs, 
        (void**)ppIEnum
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "query enum interface failed, %x", hr));
        delete pEnum;
        return hr;
    }

    return hr;
}


HRESULT CreateBstrCollection(
    IN  long        nSize,
    IN  BSTR *      begin,
    IN  BSTR *      end,
    OUT VARIANT *   pVariant,
    CComEnumFlags   flags    
    )
{
    // create the collection object
    typedef TBstrCollection CCollection;

    CComObject<CCollection> * p;
    HRESULT hr = CComObject<CCollection>::CreateInstance( &p );

    if (NULL == p)
    {
        LOG((MSP_ERROR, "Could not create Collection object, %x",hr));
        return hr;
    }

    hr = p->Initialize(nSize, begin, end, flags);

    if (S_OK != hr)
    {
        LOG((MSP_ERROR, "Could not initialize Collection object, %x", hr));
        delete p;
        return hr;
    }

    IDispatch *pDisp;

    // get the IDispatch interface
    hr = p->_InternalQueryInterface(IID_IDispatch, (void **)&pDisp);

    if (S_OK != hr)
    {
        LOG((MSP_ERROR, "QI for IDispatch in CreateCollection, %x", hr));
        delete p;
        return hr;
    }

    // put it in the variant
    VariantInit(pVariant);

    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDisp;

    return S_OK;
}

HRESULT CreateDirectoryObjectEnumerator(
    IN  ITDirectoryObject **    begin,
    IN  ITDirectoryObject **    end,
    OUT IEnumDirectoryObject ** ppIEnum
    )
{
    typedef _CopyInterface<ITDirectoryObject> CCopy;
    typedef CSafeComEnum<IEnumDirectoryObject, &IID_IEnumDirectoryObject,
        ITDirectoryObject *, CCopy> CEnumerator;

    HRESULT hr;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = CComObject<CEnumerator>::CreateInstance(&pEnum);
    if (pEnum == NULL)
    {
        LOG((MSP_ERROR, "Could not create enumerator object, %x", hr));
        return hr;
    }

    hr = pEnum->Init(begin, end, NULL, AtlFlagCopy);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "init enumerator object failed, %x", hr));
        delete pEnum;
        return hr;
    }

    // query for the IID_IEnumDirectory i/f
    hr = pEnum->_InternalQueryInterface(
        IID_IEnumDirectoryObject, 
        (void**)ppIEnum
        );
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "query enum interface failed, %x", hr));
        delete pEnum;
        return hr;
    }

    return hr;
}

HRESULT CreateEmptyUser(
    IN  BSTR                    pName,
    OUT ITDirectoryObject **    ppDirectoryObject
    )
{
    HRESULT hr;

    CComObject<CUser> * pDirectoryObject;
    hr = CComObject<CUser>::CreateInstance(&pDirectoryObject);

    if (NULL == pDirectoryObject)
    {
        LOG((MSP_ERROR, "can't create  DirectoryObject user."));
        return hr;
    }

    WCHAR *pCloseBracket = wcschr(pName, CLOSE_BRACKET_CHARACTER);
    if ( pCloseBracket != NULL )
    {
        *pCloseBracket = L'\0';
    }

    hr = pDirectoryObject->Init(pName);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateUser:init failed: %x", hr));
        delete pDirectoryObject;
        return hr;
    }    

    hr = pDirectoryObject->_InternalQueryInterface(
        IID_ITDirectoryObject,
        (void **)ppDirectoryObject
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateEmptyUser:QueryInterface failed: %x", hr));
        delete pDirectoryObject;
        return hr;
    }    

    return S_OK;
}

HRESULT CreateEmptyConference(
    IN  BSTR                    pName,
    OUT ITDirectoryObject **    ppDirectoryObject
    )
{
    HRESULT hr;

    CComObject<CConference> * pDirectoryObject;
    hr = CComObject<CConference>::CreateInstance(&pDirectoryObject);

    if (NULL == pDirectoryObject)
    {
        LOG((MSP_ERROR, "CreateEmptyConference: can't create DirectoryObject conference."));
        return hr;
    }

    hr = pDirectoryObject->Init(pName);
    
    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateEmptyConference: init failed: %x", hr));
        delete pDirectoryObject;
        return hr;
    }    

    hr = pDirectoryObject->_InternalQueryInterface(
        IID_ITDirectoryObject,
        (void **)ppDirectoryObject
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateEmptyConference: QueryInterface failed: %x", hr));
        delete pDirectoryObject;
        return hr;
    }    

    return S_OK;
}

HRESULT CreateConferenceWithBlob(
    IN  BSTR                    pName,
    IN  BSTR                    pProtocol,
    IN  BSTR                    pBlob,
    IN  CHAR *                  pSecurityDescriptor,
    IN  DWORD                   dwSDSize,
    OUT ITDirectoryObject **    ppDirectoryObject
    )
{
    //
    // This is a helper function; assumes that passed-in pointers are valid.
    //

    //
    // Create a conference object.
    //

    HRESULT hr;

    CComObject<CConference> * pDirectoryObject;
    
    hr = CComObject<CConference>::CreateInstance(&pDirectoryObject);

    if (NULL == pDirectoryObject)
    {
        LOG((MSP_ERROR, "can't create  DirectoryObject conference."));

        return hr;
    }

    //
    // Get the ITDirectoryObject interface.
    //

    hr = pDirectoryObject->_InternalQueryInterface(
        IID_ITDirectoryObject,
        (void **)ppDirectoryObject
        );

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateConference:QueryInterface failed: %x", hr));
        
        delete pDirectoryObject;
        *ppDirectoryObject = NULL;
        
        return hr;
    }    

    //
    // Init the object.
    //
    
    hr = pDirectoryObject->Init(pName, pProtocol, pBlob);

    if (FAILED(hr))
    {
        LOG((MSP_ERROR, "CreateConferenceWithBlob:init failed: %x", hr));
        
        (*ppDirectoryObject)->Release();
        *ppDirectoryObject = NULL;
        
        return hr;
    }    

    //
    // Set the security descriptor on the object.
    //

    if (pSecurityDescriptor != NULL)
    {
        //
        // first query the private interface for attributes.
        //

        ITDirectoryObjectPrivate * pObjectPrivate;

        hr = pDirectoryObject->QueryInterface(
            IID_ITDirectoryObjectPrivate,
            (void **)&pObjectPrivate
            );

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "can't get the private directory object "
                "interface: 0x%08x", hr));

            (*ppDirectoryObject)->Release();
            *ppDirectoryObject = NULL;

            return hr;
        }

        //
        // Now set the security descriptor in its "converted" (server) form.
        //

        hr = pObjectPrivate->PutConvertedSecurityDescriptor(
                pSecurityDescriptor,
                dwSDSize);

        pObjectPrivate->Release();

        if ( FAILED(hr) )
        {
            LOG((MSP_ERROR, "PutConvertedSecurityDescriptor failed: %x", hr));
            
            (*ppDirectoryObject)->Release();
            *ppDirectoryObject = NULL;

            return hr;
        }
    }

    return S_OK;
}


//
// GetCorrectAddressFromHostent
//
// in parameters:
//
//     dwInterface -- When picking the IP address from the array of addrs,
//                    pick the one that is reachable via this local interface.
//                    If this parameter equals 0, then just pick the first
//                    one. Network byte order.
//     hostp       -- pointer to hostent structure to extract from
//

DWORD GetCorrectAddressFromHostent(
                                   DWORD dwInterface,
                                   struct hostent * hostp
                                  )
{
    DWORD ** ppAddrs = (DWORD **) hostp->h_addr_list;

    if ( dwInterface == 0 )
    {
        return * ppAddrs[0];
    }


    for ( int i = 0; ppAddrs[i] != NULL; i++ )
    {
        if ( dwInterface == ( * ppAddrs[i] ) )
        {
            return dwInterface;
        }
    }

    //
    // If we get here then none of the addresses in the hostent structure
    // matched our interface address. This means that we are looking at
    // some machine besides the local host. In this case it shouldn't
    // matter which address we use.
    //

    LOG((MSP_WARN, "using first address for multihomed remote machine IP"));

    return * ppAddrs[0];
}

//
// ResolveHostName
//
// in parameters:
//
//     dwInterface -- When disconvering IP address based on host name, pick
//                    the one that is reachable via this local interface. If
//                    this parameter equals 0, then just pick the first one.
//                    Network byte order.
//     pHost       -- Must be a valid string pointer. Points to the hostname
//                    to resolve.
//
// out parameters:
//
//     pFullName   -- If non-NULL, returns the hostname as returned from DNS.
//     pdwIP       -- If non-NULL, returns the IP address as returned from
//                    DNS. Network byte order.
//

HRESULT ResolveHostName(
                        IN  DWORD    dwInterface,
                        IN  TCHAR  * pHost,
                        OUT char  ** pFullName,
                        OUT DWORD  * pdwIP
                       )
{
    struct hostent *hostp = NULL;
    DWORD  inaddr;

    if(lstrcmpW(pHost, L"255.255.255.255") == 0)
    {
        return E_FAIL;
    }

    //
    // Convert hostname to an ANSI string.
    //

    USES_CONVERSION;
    char *name = T2A(pHost);
    BAIL_IF_NULL(name, E_UNEXPECTED);

    //
    // Check if the string is in dot-quad notation.
    //

    if ((inaddr = inet_addr(name)) == -1L) 
    {
        //
        // String is not in "dot quad" notation
        // So try to get the IP address from DNS.
        //

        hostp = gethostbyname(name);
        if (hostp) 
        {
            //
            // If we find a host entry, set up the internet address
            //
            inaddr = GetCorrectAddressFromHostent(dwInterface, hostp);
            // inaddr = *(DWORD *)hostp->h_addr;
        } 
        else 
        {
            // error: the input was neither a valid dot-quad nor hostname
            return HRESULT_FROM_ERROR_CODE(WSAGetLastError());
        }
    } 
    else 
    {
        //
        // String is in "dot quad" notation
        // So try to get the host name from the IP address.
        //

        //
        // If we don't care about the host name, we're done resolving.
        // Otherwise make sure this IP maps to a hostname.
        //

        if ( pFullName != NULL )
        {
            hostp = gethostbyaddr((char *)&inaddr,sizeof(inaddr),AF_INET);
            if (!hostp) 
            {
                // error: the input was neither a valid dot-quad nor hostname
                return HRESULT_FROM_ERROR_CODE(WSAGetLastError());
            }

            //[vlade] Changes for the multihomed
            inaddr = GetCorrectAddressFromHostent(dwInterface, hostp);
        }
    }

    //
    // All succeeded; return what was asked for.
    //

    if ( pFullName != NULL )
    {
        *pFullName = hostp->h_name;
    }

    if ( pdwIP != NULL )
    {
        *pdwIP = inaddr;
        if( inaddr == 0)
        {
            return E_FAIL;
        }
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// This is a small helper function to print an IP address to a Unicode string.
// We can't use inet_ntoa because we need Unicode.

void ipAddressToStringW(WCHAR * wszDest, DWORD dwAddress)
{
    // The IP address is always stored in NETWORK byte order
    // So we need to take something like 0x0100007f and produce a string like
    // "127.0.0.1".

    wsprintf(wszDest, L"%d.%d.%d.%d",
             dwAddress        & 0xff,
            (dwAddress >> 8)  & 0xff,
            (dwAddress >> 16) & 0xff,
             dwAddress >> 24          );
}

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\rend\thread.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    Thread.h

Abstract:

    Definitions for autorefresh thread management class.

--*/

#ifndef __THREAD_H
#define __THREAD_H

#include "rndcommc.h"
#include "rndutil.h"

//
// Refresh table defs.
//

const long ILS_UPDATE_INTERVAL = 1800;  // 30 minutes

typedef struct
{
    WCHAR * pDN;
    DWORD   dwTTL;

} RefreshTableEntry;

typedef SimpleVector<RefreshTableEntry> RefreshTable;

const DWORD TIMER_PERIOD = 60;   // 60 seconds

enum { EVENT_STOP = 0, EVENT_TIMER, NUM_EVENTS };

class CRendThread
{
public:
    CRendThread()
        : m_hThread(NULL)
    {
        m_hEvents[EVENT_STOP] = NULL;
        m_hEvents[EVENT_TIMER] = NULL;
    }

    ~CRendThread();
    void Shutdown(void);

    HRESULT ThreadProc();

    HRESULT AddDirectory(ITDirectory *pdir);
    HRESULT RemoveDirectory(ITDirectory *pdir);

private:
    void UpdateDirectories();
    BOOL StopThread() { return SetEvent(m_hEvents[EVENT_STOP]); }
    HRESULT Start();
    HRESULT Stop();

private:
    CCritSection    m_lock;
    HANDLE          m_hThread;
    HANDLE          m_hEvents[NUM_EVENTS];

    SimpleVector<ITDynamicDirectory*>  m_Directories;
};

extern CRendThread g_RendThread;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\addrgen.cpp ===
/*++

    Copyright (c) 1997-1999 Microsoft Corporation

  Module Name:

    addrgen.cpp

  Abstract:

    This module provides the definitions for the PORT allocation and release APIs.
    (Address allocation stuff removed by ZoltanS 6-1-98.)

  Author:

    B. Rajeev (rajeevb) 17-mar-1997

  Revision History:

  --*/

#include "stdafx.h"
#include <windows.h>
#include <wtypes.h>
#include <winsock2.h>
#include "addrgen.h"
#include "blbdbg.h"

extern "C"
{
#include <wincrypt.h>
#include <sclogon.h>
#include <dhcpcapi.h>
}


// these constants represent the port range for corresponding media
const WORD    BASE_AUDIO_PORT         = 16384;
const WORD    AUDIO_PORT_MASK         = 0x3fff;

const WORD    BASE_WHITEBOARD_PORT    = 32768;
const WORD    WHITEBOARD_PORT_MASK    = 0x3fff;

const WORD    BASE_VIDEO_PORT         = 49152;
const WORD    VIDEO_PORT_MASK         = 0x3ffe;

/*++

  Routine Description:

    This routine is used to reserve as well as renew local ports.

  Arguments:

    lpScope                - Supplies a pointer to structure describing the port group.
    IsRenewal            - Supplies a boolean value that describes whether the allocation call
                            is a renewal attempt or a new allocation request.
    NumberOfPorts        - Supplies the number of ports requested.
    lpFirstPort            - Supplies the first port to be renewed in case of renewal
                            (strictly an IN parameter).
                          Returns the first port allocated otherwise
                            (strictly an OUT parameter).


  Return Value:

    BOOL    - TRUE if successful, FALSE otherwise. Further error information can be obtained by
                calling GetLastError(). These error codes are -

                  NO_ERROR                    - The call was successful.
                  MSA_INVALID_PORT_GROUP    - The port group information is invalid (either if the PortType is
                                                invalid or the port range is unacceptable)
                  MSA_RENEWAL_FAILED        - System unable to renew the given ports.
                  ERROR_INVALID_PARAMETER    - One or more parameters is invalid.
                  MSA_INVALID_DATA            - One or more parameters has an invalid value.

  Remarks:

    All values are in host byte order

--*/
ADDRGEN_LIB_API    BOOL    WINAPI
MSAAllocatePorts(
     IN     LPMSA_PORT_GROUP    lpPortGroup,
     IN     BOOL                IsRenewal,
     IN     WORD                NumberOfPorts,
     IN OUT LPWORD              lpFirstPort
     )
{
    // check if parameters are valid
    // if lpPortGroup or lpFirstPort is NULL - fail
    if ( (NULL == lpPortGroup)        ||
         (NULL == lpFirstPort)     )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // check if renewal - fail
    if ( IsRenewal )
    {
        SetLastError(MSA_INVALID_DATA);
        return FALSE;
    }

    //
    // PREFIXBUG 49741, 49742 - VLADE
    // We should initialize the variables
    //

    WORD    BasePort = 0;
    WORD    Mask = 0;

    // determine port range
    switch(lpPortGroup->PortType)
    {
    case AUDIO_PORT:
        {
            BasePort    = BASE_AUDIO_PORT;
            Mask        = AUDIO_PORT_MASK;
        }

        break;

    case WHITEBOARD_PORT:
        {
            BasePort    = BASE_WHITEBOARD_PORT;
            Mask        = WHITEBOARD_PORT_MASK;
        }

        break;

    case VIDEO_PORT:
        {
            BasePort    = BASE_VIDEO_PORT;
            Mask        = VIDEO_PORT_MASK;
        }

        break;

    case OTHER_PORT:
        {

            WORD    StartPort;
            WORD    EndPort;
        }

        break;

    default:
        {
            SetLastError(MSA_INVALID_PORT_GROUP);
            return FALSE;
        }
    };


    // if the desired number of ports are more than the range allows
    if ( NumberOfPorts > Mask )
    {
        SetLastError(MSA_NOT_AVAILABLE);
        return FALSE;
    }

    // choose random port in the range as the start
    *lpFirstPort = BasePort + (rand() & (Mask - NumberOfPorts));

    SetLastError(NO_ERROR);
    return TRUE;
}



/*++

  Routine Description:

    This routine is used to release previously allocated multicast ports.

  Arguments:

    NumberOfPorts    - Supplies the number of ports to be released.
    StartPort        - Supplies the starting port of the port range to be released.

  Return Value:

    BOOL    - TRUE if successful, FALSE otherwise. Further error information can be obtained by
                calling GetLastError(). These error codes are -

                  NO_ERROR                    - The call was successful.
                  MSA_NO_SUCH_RESERVATION    - There is no such reservation.
                  ERROR_INVALID_PARAMETER    - One or more parameters is invalid.
                  MSA_INVALID_DATA            - One or more parameters has an invalid value.

  Remarks:

    if range [a..c] is reserved and the release is attempted on [a..d], the call fails with
    MSA_NO_SUCH_RESERVATION without releasing [a..c].

    All values are in host byte order

++*/
ADDRGEN_LIB_API    BOOL    WINAPI
MSAReleasePorts(
     IN WORD                NumberOfPorts,
     IN WORD                StartPort
     )
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\blbconn.cpp ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    blbconn.cpp

Abstract:

Author:

*/

#include "stdafx.h"

#include "blbgen.h"
#include "blbconn.h"
#include "sdpblob.h"


STDMETHODIMP ITConnectionImpl::get_StartAddress(BSTR * pVal)
{
    CLock Lock(g_DllLock);
    
    return m_SdpConnection->GetStartAddress().GetBstrCopy(pVal);
}


STDMETHODIMP ITConnectionImpl::get_NumAddresses(LONG * pVal)
{
    BAIL_IF_NULL(pVal, E_INVALIDARG);

    CLock Lock(g_DllLock);
    
    // if the entry isn't valid, it means its one (by default)
    SDP_ULONG   &NumAddresses = m_SdpConnection->GetNumAddresses();

    // vb doesn't take ulong values. this will only affect us if half or more of all the IP addresses
    // (not just multicast) are being used

    if( (LONG)(NumAddresses.IsValid()) )
    {
        *pVal = NumAddresses.GetValue();
    }
    else
    {
        //
        // TTL is a good flag if it is a ral address
        // 0: we don't have address
        // >0 we have an address
        //
        BYTE nTTL = 0;
        m_SdpConnection->GetTtl().GetValue(nTTL);
        *pVal = nTTL ? 1 : 0;
    }

    //*pVal = (LONG)(NumAddresses.IsValid()) ? NumAddresses.GetValue() : 0;

    return S_OK;
}


STDMETHODIMP ITConnectionImpl::get_Ttl(BYTE * pVal)
{
    BAIL_IF_NULL(pVal, E_INVALIDARG);

    CLock Lock(g_DllLock);
    
    return m_SdpConnection->GetTtl().GetValue(*pVal);
}


STDMETHODIMP ITConnectionImpl::get_BandwidthModifier(BSTR * pVal)
{
    CLock Lock(g_DllLock);
    
    return m_SdpBandwidth->GetModifier().GetBstrCopy(pVal);
}

STDMETHODIMP ITConnectionImpl::get_Bandwidth(DOUBLE * pVal)
{
    BAIL_IF_NULL(pVal, E_INVALIDARG);

    CLock Lock(g_DllLock);
    
    ULONG BandwidthValue;
    BAIL_ON_FAILURE(m_SdpBandwidth->GetBandwidthValue().GetValue(BandwidthValue));

    // vb doesn't take a ulong value, so use the next bigger type
    *pVal = (DOUBLE)BandwidthValue;
    return S_OK;
}



STDMETHODIMP ITConnectionImpl::SetAddressInfo(BSTR StartAddress, LONG NumAddresses, BYTE Ttl)
{
    if ( 0 > NumAddresses )
    {
        return E_INVALIDARG;
    }

    CLock Lock(g_DllLock);
    
    if ( !m_IsMain && ((NULL == StartAddress) || (WCHAR_EOS == StartAddress[0])) )
    {
        m_SdpConnection->Reset();
        return S_OK;
    }

    HRESULT HResult = m_SdpConnection->SetConnection(StartAddress, NumAddresses, Ttl);
    BAIL_ON_FAILURE(HResult);

    return S_OK;
}


STDMETHODIMP ITConnectionImpl::SetBandwidthInfo(BSTR Modifier, DOUBLE Bandwidth)
{
    // the bandwidth value must be a valid ULONG value (vb restrictions)
    if ( !((0 <= Bandwidth) && (ULONG(-1) > Bandwidth)) )
    {
        return E_INVALIDARG;
    }

    // check if there is any fractional part, this check is valid as it is a valid ULONG value
    if ( Bandwidth != (ULONG)Bandwidth )
    {
        return E_INVALIDARG;
    }

    CLock Lock(g_DllLock);
    
    if ( (NULL == Modifier) || (WCHAR_EOS == Modifier[0]) )
    {
        m_SdpBandwidth->Reset();
        return S_OK;
    }

    return m_SdpBandwidth->SetBandwidth(Modifier, (ULONG)Bandwidth);
}



STDMETHODIMP ITConnectionImpl::SetEncryptionKey(BSTR KeyType, BSTR * KeyData)
{
    CLock Lock(g_DllLock);
    
    if ( (NULL == KeyType) || (WCHAR_EOS == KeyType[0]) )
    {
        m_SdpKey->Reset();
        return S_OK;
    }

    return m_SdpKey->SetKey(KeyType, KeyData);
}


STDMETHODIMP ITConnectionImpl::GetEncryptionKey(BSTR * KeyType, VARIANT_BOOL * ValidKeyData, BSTR * KeyData)
{
    BAIL_IF_NULL(KeyType, E_INVALIDARG);
    BAIL_IF_NULL(ValidKeyData, E_INVALIDARG);
    BAIL_IF_NULL(KeyData, E_INVALIDARG);

    CLock Lock(g_DllLock);
    
    HRESULT HResult = m_SdpKey->GetKeyType().GetBstrCopy(KeyType);
    BAIL_ON_FAILURE(HResult);

    if ( !m_SdpKey->GetKeyData().IsValid() )
    {
        *ValidKeyData = VARIANT_FALSE;
        return S_OK;
    }
    
    HResult = m_SdpKey->GetKeyData().GetBstrCopy(KeyData);
    *ValidKeyData = (SUCCEEDED(HResult))? VARIANT_TRUE : VARIANT_FALSE;
    if ( VARIANT_FALSE == *ValidKeyData )
    {
        SysFreeString(*KeyType);
        return HResult;
    }

    return S_OK;
}


STDMETHODIMP ITConnectionImpl::get_NetworkType(BSTR * pVal)
{
    CLock Lock(g_DllLock);
    
    return m_SdpConnection->GetNetworkType().GetBstrCopy(pVal);
}

STDMETHODIMP ITConnectionImpl::put_NetworkType(BSTR newVal)
{
    CLock Lock(g_DllLock);
    
    return m_SdpConnection->GetNetworkType().SetBstr(newVal);
}


STDMETHODIMP ITConnectionImpl::get_AddressType(BSTR * pVal)
{
    CLock Lock(g_DllLock);
    
    return m_SdpConnection->GetAddressType().GetBstrCopy(pVal);
}


STDMETHODIMP ITConnectionImpl::put_AddressType(BSTR newVal)
{
    CLock Lock(g_DllLock);
    
    return m_SdpConnection->GetAddressType().SetBstr(newVal);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\addrgen.h ===
/*++

    Copyright (c) 1997-1999 Microsoft Corporation

  Module Name:

    addrgen.h

  Abstract:

    This module provides the APIs for allocation and release of multicast addresses and ports.

  Author:

    B. Rajeev (rajeevb) 17-mar-1997

  Revision History:

  --*/

#ifndef __ADDRESS_GENERATION__
#define __ADDRESS_GENERATION__

#ifndef __ADDRGEN_LIB__
#define ADDRGEN_LIB_API //__declspec(dllimport)
#else
#define ADDRGEN_LIB_API // __declspec(dllexport)
#endif

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

/*++

  These values are a short representation for well known port ranges (port type). 
  
++*/

#define OTHER_PORT        0        // none of the well-known ranges, uses MSA_PORT_GROUP to specify the range
#define AUDIO_PORT        1        // port range [16384..32767) - note: 32767 is NOT included
#define WHITEBOARD_PORT    2        // port range [32768..49152)
#define VIDEO_PORT        3        // port range [49152.. 65535) - note: 65535 is NOT included


/*++

  Type Description:

    Represents a multicast address scope. 
    Multicast addresses may be allocated within such a scope

  Members:

    ScopeType    - One of the well-known multicast scope types. In such a case, the value
                    of other members is predefined and is not interpreted. If not, it takes
                    the value OTHER_MULTICAST_SCOPE. 
    BaseAddress    - A 32 bit value, when ORed with the NetworkMask, provides the 
                  prefix of all multicast addresses allocated within the scope.
    NetworkMask    - A 32 bit value that specifies which bits in the the BaseAddress remain on.
    NameString    - Points to a human readable string.
    Infosize    - Size of the Info field.
    Info        - Points to more information about the address scope.

  Remarks:

    All values are in host byte order

--*/
typedef struct _MSA_MULTICAST_ADDRESS_SCOPE 
{
     DWORD        ScopeType;
     DWORD        BaseAddress;
     DWORD        NetworkMask;
     BSTR        NameString;
     DWORD        Infosize;
     LPVOID        Info;
}  MSA_MULTICAST_ADDRESS_SCOPE, *LPMSA_MULTICAST_ADDRESS_SCOPE;                



/*++

  Type Description:

    Represents a range of ports within which ([StartPort..EndPort]) a port must be allocated.

  Members:

    PortType    - One of the well-known port types (audio, video etc.). In such a case, the value
                    of other members is predefined and is not interpreted. If not, it takes the
                    value OTHER_PORT.
    StartPort    - First port of the range that may be allocated.
    EndPort        - Last port of the range that may be allocated.

  Remarks:

    All values are in host byte order

--*/
typedef struct _MSA_PORT_GROUP
{
    DWORD    PortType;
    WORD    StartPort;
    WORD    EndPort;
}    MSA_PORT_GROUP, *LPMSA_PORT_GROUP;




/*++

  Routine Description:

    This routine is used to reserve as well as renew local ports. 

  Arguments:

    lpScope                - Supplies a pointer to structure describing the port group.
    IsRenewal            - Supplies a boolean value that describes whether the allocation call
                            is a renewal attempt or a new allocation request.
    NumberOfPorts        - Supplies the number of ports requested.
    lpFirstPort            - Supplies the first port to be renewed in case of renewal 
                            (strictly an IN parameter).
                          Returns the first port allocated otherwise
                            (strictly an OUT parameter).


  Return Value:

    BOOL    - TRUE if successful, FALSE otherwise. Further error information can be obtained by
                calling GetLastError(). These error codes are -
                
                  NO_ERROR                    - The call was successful.
                  MSA_INVALID_PORT_GROUP    - The port group information is invalid (either if the PortType is
                                                invalid or the port range is unacceptable)
                  MSA_RENEWAL_FAILED        - System unable to renew the given ports.
                  ERROR_INVALID_PARAMETER    - One or more parameters is invalid. 
                  MSA_INVALID_DATA            - One or more parameters has an invalid value.

  Remarks:

    All values are in host byte order

--*/
ADDRGEN_LIB_API    BOOL    WINAPI
MSAAllocatePorts(
     IN     LPMSA_PORT_GROUP                        lpPortGroup,
     IN        BOOL                                    IsRenewal,
     IN     WORD                                    NumberOfPorts,
     IN OUT LPWORD                                    lpFirstPort
     ); 



/*++

  Routine Description:

    This routine is used to release previously allocated multicast ports.
    
  Arguments:

    NumberOfPorts    - Supplies the number of ports to be released.
    StartPort        - Supplies the starting port of the port range to be released.

  Return Value:

    BOOL    - TRUE if successful, FALSE otherwise. Further error information can be obtained by
                calling GetLastError(). These error codes are -
                
                  NO_ERROR                    - The call was successful.
                  MSA_NO_SUCH_RESERVATION    - There is no such reservation.
                  ERROR_INVALID_PARAMETER    - One or more parameters is invalid. 
                  MSA_INVALID_DATA            - One or more parameters has an invalid value.

  Remarks:

    if range [a..c] is reserved and the release is attempted on [a..d], the call fails with
    MSA_NO_SUCH_RESERVATION without releasing [a..c].

    All values are in host byte order

++*/
ADDRGEN_LIB_API    BOOL    WINAPI
MSAReleasePorts(
     IN WORD                NumberOfPorts,
     IN WORD                StartPort
     ); 


// error codes

#define MSA_INVALID_DATA        1        // value of one or more parameters is invalid
#define MSA_NOT_AVAILABLE       2        // resources unavailable
#define MSA_INVALID_PORT_GROUP  3        // the specified port group is invalid

#ifdef __cplusplus
}
#endif // __cplusplus



#endif // __ADDRESS_GENERATION__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\blbatt.cpp ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    blbatt.cpp

Abstract:

Author:

*/

#include "stdafx.h"

#include "blbgen.h"
#include "blbatt.h"

// variants are validated in the get/set safearray methods

// bstrs are validated in the GetBstrCopy and SetBstr methods. they may also
// be optionally validated before taking any action, if there is a possibility
// of having to roll back some of the work done on finding them invalid



STDMETHODIMP ITAttributeListImpl::get_Count(LONG * pVal)
{
    BAIL_IF_NULL(pVal, E_INVALIDARG);
    
    CLock Lock(g_DllLock);
    
    ASSERT(NULL != m_SdpAttributeList);

    *pVal = (LONG)m_SdpAttributeList->GetSize();

    return S_OK;
}


STDMETHODIMP ITAttributeListImpl::get_Item(LONG Index, BSTR * pVal)
{
    CLock Lock(g_DllLock);
    
    ASSERT(NULL != m_SdpAttributeList);

    // vb indices are in the range [1..GetSize()]
    if ( !((1 <= Index) && (Index <= m_SdpAttributeList->GetSize())) )
    {
        return E_INVALIDARG;
    }

    // adjust the index to the range [0..(GetSize()-1)]
    return ((SDP_REQD_BSTRING_LINE   *)m_SdpAttributeList->GetAt(Index-1))->GetBstrCopy(pVal);
}


STDMETHODIMP ITAttributeListImpl::Add(LONG Index, BSTR Attribute)
{
    BAIL_IF_NULL(Attribute, E_INVALIDARG);

    CLock Lock(g_DllLock);
    
    ASSERT(NULL != m_SdpAttributeList);

    // index should be in the range [1..GetSize()+1]
    if ( !((1 <= Index) && (Index <= (m_SdpAttributeList->GetSize()+1))) )
    {
        return E_INVALIDARG;
    }
    
    // create an attribute line
    SDP_REQD_BSTRING_LINE   *AttributeLine = 
        (SDP_REQD_BSTRING_LINE   *)m_SdpAttributeList->CreateElement();

    if( NULL == AttributeLine )
    {
        return E_OUTOFMEMORY;
    }

    // set the passed in attribute in the attribute line
    HRESULT ToReturn = AttributeLine->SetBstr(Attribute);
    if ( FAILED(ToReturn) )
    {
        delete AttributeLine;
        return ToReturn;
    }

    // insert the attribute line, shift elements with equal or higher indices forwards
    m_SdpAttributeList->InsertAt(Index-1, AttributeLine);
    return S_OK;
}


STDMETHODIMP ITAttributeListImpl::Delete(LONG Index)
{
    CLock Lock(g_DllLock);
    
    ASSERT(NULL != m_SdpAttributeList);

    // vb indices are in the range [1..GetSize()]
    if ( !((1 <= Index) && (Index <= m_SdpAttributeList->GetSize())) )
    {
        return E_INVALIDARG;
    }

    // adjust the index to the range [0..(GetSize()-1)]
    // delete the attribute line, remove the ptr from the array; shifting elements with higher
    // index lower
    delete m_SdpAttributeList->GetAt(Index-1);
    m_SdpAttributeList->RemoveAt(Index-1);

    return S_OK;
}


STDMETHODIMP ITAttributeListImpl::get_AttributeList(VARIANT /*SAFEARRAY(BSTR)*/ * pVal)
{
    CLock Lock(g_DllLock);
    
    ASSERT(NULL != m_SdpAttributeList);

    return m_SdpAttributeList->GetSafeArray(pVal);
}


STDMETHODIMP ITAttributeListImpl::put_AttributeList(VARIANT /*SAFEARRAY(BSTR)*/ newVal)
{
    CLock Lock(g_DllLock);
    
    ASSERT(NULL != m_SdpAttributeList);

    if ( NULL == V_ARRAY(&newVal) )
    {
        m_SdpAttributeList->Reset();
        return S_OK;
    }

    return m_SdpAttributeList->SetSafeArray(newVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\blbatt.h ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    blbatt.h

Abstract:

Author:

*/


#ifndef __SDP_ATTRIBUTE_IMPLEMENTATION_
#define __SDP_ATTRIBUTE_IMPLEMENTATION_

#include "resource.h"       // main symbols
#include "sdpblb.h"
#include "sdp.h"


class ATL_NO_VTABLE ITAttributeListImpl : 
    public IDispatchImpl<ITAttributeList, &IID_ITAttributeList, &LIBID_SDPBLBLib>
{
public:

    inline ITAttributeListImpl();

    inline void SuccessInit(
        IN      SDP_ATTRIBUTE_LIST  &SdpAttributeList
        );
    STDMETHOD(get_AttributeList)(/*[out, retval]*/ VARIANT /*SAFEARRAY(BSTR)*/ * pVal);
    STDMETHOD(put_AttributeList)(/*[in]*/ VARIANT /*SAFEARRAY(BSTR)*/ newVal);
    STDMETHOD(Delete)(/*[in]*/ LONG Index);
    STDMETHOD(Add)(/*[in]*/ LONG Index, /*[in]*/ BSTR pAttribute);
    STDMETHOD(get_Item)(/*[in]*/ LONG Index, /*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Count)(/*[out, retval]*/ LONG *pVal);

protected:

    SDP_ATTRIBUTE_LIST  *m_SdpAttributeList;
};


inline 
ITAttributeListImpl::ITAttributeListImpl(
    )
    : m_SdpAttributeList(NULL)
{
}


inline void
ITAttributeListImpl::SuccessInit(
    IN      SDP_ATTRIBUTE_LIST  &SdpAttributeList
    )
{
    ASSERT(NULL == m_SdpAttributeList);

    m_SdpAttributeList = &SdpAttributeList;
}


#endif // __SDP_ATTRIBUTE_IMPLEMENTATION_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\blbconn.h ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    blbconn.h

Abstract:
    Implementation of ITConnection interface

Author:

*/

#ifndef __SDP_CONNECTION_IMPLEMENTATION_
#define __SDP_CONNECTION_IMPLEMENTATION_

#include "resource.h"       // main symbols
#include "sdpblb.h"
#include "sdp.h"

class CSdpConferenceBlob;

class ATL_NO_VTABLE ITConnectionImpl : 
    public IDispatchImpl<ITConnection, &IID_ITConnection, &LIBID_SDPBLBLib>
{
public:
    
    inline ITConnectionImpl();

    inline void SuccessInit(
        IN      SDP            &Sdp
        );

    inline void SuccessInit(
        IN      SDP_MEDIA    &SdpMedia
        );

    STDMETHOD(get_NumAddresses)(/*[out, retval]*/ LONG *pNumAddresses);
    STDMETHOD(get_StartAddress)(/*[out, retval]*/ BSTR *ppStartAddress);
    STDMETHOD(get_Ttl)(/*[out, retval]*/ BYTE *pTtl);
    STDMETHOD(SetAddressInfo)(/*[in]*/ BSTR pStartAddress, /*[in]*/ LONG NumAddresses, /*[in]*/ BYTE Ttl);
    STDMETHOD(get_Bandwidth)(/*[out, retval]*/ DOUBLE *pBandwidth);
    STDMETHOD(get_BandwidthModifier)(/*[out, retval]*/ BSTR *ppModifier);
    STDMETHOD(SetBandwidthInfo)(/*[in]*/ BSTR pModifier, /*[in]*/ DOUBLE Bandwidth);
    STDMETHOD(GetEncryptionKey)(/*[out]*/ BSTR *ppKeyType, /*[out]*/ VARIANT_BOOL *pfValidKeyData, /*[out]*/ BSTR *ppKeyData);
    STDMETHOD(SetEncryptionKey)(/*[in]*/ BSTR pKeyType, /*[in]*/ BSTR *ppKeyData);
    STDMETHOD(get_AddressType)(/*[out, retval]*/ BSTR *ppAddressType);
    STDMETHOD(put_AddressType)(/*[in]*/ BSTR pAddressType);
    STDMETHOD(get_NetworkType)(/*[out, retval]*/ BSTR *ppNetworkType);
    STDMETHOD(put_NetworkType)(/*[in]*/ BSTR pNetworkType);

protected:

    BOOL                m_IsMain;
    SDP_CONNECTION      *m_SdpConnection;
    SDP_BANDWIDTH       *m_SdpBandwidth;
    SDP_ENCRYPTION_KEY  *m_SdpKey;

    // virtual fn to retrieve the conference blob
    // this is virtual so that another reference to the conference blob need not be maintained in this
    // class. this is important because all refs to the conf blob may be cleared by the deriving class
    // and it is easier to control access to a single reference in it
    virtual CSdpConferenceBlob  *GetConfBlob() = 0;
};


inline 
ITConnectionImpl::ITConnectionImpl(
    )
    : m_SdpConnection(NULL),
      m_SdpBandwidth(NULL),
      m_SdpKey(NULL)
{
}


inline void
ITConnectionImpl::SuccessInit(
    IN      SDP            &Sdp
    )
{
    m_IsMain        = TRUE;
    m_SdpConnection    = &Sdp.GetConnection();
    m_SdpBandwidth    = &Sdp.GetBandwidth();
    m_SdpKey        = &Sdp.GetEncryptionKey();
}


inline void
ITConnectionImpl::SuccessInit(
    IN      SDP_MEDIA    &SdpMedia
    )
{
    m_IsMain        = FALSE;
    m_SdpConnection    = &SdpMedia.GetConnection();
    m_SdpBandwidth    = &SdpMedia.GetBandwidth();
    m_SdpKey        = &SdpMedia.GetEncryptionKey();
}


#endif // __SDP_CONNECTION_IMPLEMENTATION_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\blbcoen.h ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    blbcoen.h

Abstract:

Author:

*/

#ifndef __BLB_COLLECTION_ENUMERATION_IMPL__
#define __BLB_COLLECTION_ENUMERATION_IMPL__

#include "resource.h"

#include <afxtempl.h>
#include "blberr.h"
#include "blbgen.h"
#include "sdp.h"

// forward declaration
class CSdpConferenceBlob;


template <class T>
class ENUM_ELEMENT
{
public:
    
    inline ENUM_ELEMENT();
    
    inline void SuccessInit(
        IN      T            &Element,
        IN        BOOL        DestroyElementOnDestruction = FALSE
        );

    inline T    &GetElement();

    inline T    &GetContent();

    inline void SetDestroyElementFlag();

    virtual ~ENUM_ELEMENT();
    
protected:

    T            *m_Element;
    BOOL        m_DestroyElementOnDestruction;
};



template <class T>
inline 
ENUM_ELEMENT<T>::ENUM_ELEMENT(
    )
    : m_Element(NULL),
      m_DestroyElementOnDestruction(FALSE)
      
{
}


template <class T>
inline void
ENUM_ELEMENT<T>::SuccessInit(
        IN      T            &Element,
        IN        BOOL        DestroyElementOnDestruction /* = FALSE */
    )
{
    ASSERT(NULL == m_Element);

    m_Element = &Element;
    m_DestroyElementOnDestruction = DestroyElementOnDestruction;
}


template <class T>
inline T &
ENUM_ELEMENT<T>::GetElement(
    )
{
    ASSERT(NULL != m_Element);

    return *m_Element;
}

template <class T>
inline void 
ENUM_ELEMENT<T>::SetDestroyElementFlag(
    )
{
    ASSERT(NULL != m_Element);

    m_DestroyElementOnDestruction = TRUE;
}


template <class T>
inline T   &
ENUM_ELEMENT<T>::GetContent(
           )
{
    ASSERT(NULL != m_Element);

    return *m_Element;
}


template <class T>
/* virtual */
ENUM_ELEMENT<T>::~ENUM_ELEMENT(
    )
{
    if ( m_DestroyElementOnDestruction )
    {
        ASSERT(NULL != m_Element);

        delete m_Element;
    }
}



template <class T>
class IF_ARRAY : public CArray<VARIANT, VARIANT &>
{
protected:
        typedef typename T::SDP_LIST		SDP_LIST;
        typedef typename T::ELEM_IF		ELEM_IF;
        typedef CArray<VARIANT, VARIANT &>	BASE;

public:

    inline IF_ARRAY();

    HRESULT Init(
        IN      CSdpConferenceBlob  &ConfBlob,        
        IN      SDP_LIST    &SdpList
        );

    inline ELEM_IF  *GetAt(
        IN      UINT    Index
        );

    HRESULT Add(
        IN      UINT    Index,
        IN      ELEM_IF *ElemIf
        );

    inline void Delete(
        IN      UINT    Index
        );

    inline UINT GetSize();

    inline SDP_LIST *GetSdpList();

    inline VARIANT *GetData();

    inline ELEM_IF **GetElemIfArrayData();
        
    inline CSdpConferenceBlob   *GetSdpBlob();

    inline void ClearSdpBlobRefs();

    ~IF_ARRAY();

protected:

    CSdpConferenceBlob  *m_ConfBlob;
    SDP_LIST            *m_SdpList;

    CArray<ELEM_IF *, ELEM_IF *>  m_ElemIfArray;
};



template <class T>
inline 
IF_ARRAY<T>::IF_ARRAY(
    )
    : m_ConfBlob(NULL),
      m_SdpList(NULL)
      
{
}


template <class T>
HRESULT
IF_ARRAY<T>::Init(
    IN      CSdpConferenceBlob  &ConfBlob,
    IN      SDP_LIST            &SdpList
    )
{
    ASSERT(NULL == m_ConfBlob);
    ASSERT(NULL == m_SdpList);

    // create the array in 3 steps -
    // i) create each of the instances and insert into the list
    // ii) set the sdp list destroy members flag to FALSE
    // iii) set the destroy element flag to TRUE for each of the created instances
    // this order is needed to ensure that only one of (sdp list, T instance) is responsible
    // for deleting the sdp instance

    // for each sdp specific data structure, create and initialize a COM component,
    // set the corresponding element in the interface array to the queried interface ptr
    for (UINT i=0; (int)i < SdpList.GetSize(); i++)
    {
        // create an instance of the component supporting the elem if
        CComObject<T>    *CompInstance;
        HRESULT HResult = CComObject<T>::CreateInstance(&CompInstance);
        BAIL_ON_FAILURE(HResult);

        // initialize the instance with the sdp specific data structure
        CompInstance->SuccessInit(ConfBlob, *((T::SDP_TYPE *)SdpList.GetAt(i)));

        // query for the elem interface
        T::ELEM_IF    *ElemIf;
            
        // query for the element interface and return it
        HResult = CompInstance->_InternalQueryInterface(T::ELEM_IF_ID, (void**)&ElemIf);
        if ( FAILED(HResult) )
        {
            delete CompInstance;
            return HResult;
        }

        // initialize the variant wrapper
        VARIANT ElemVariant;
        V_VT(&ElemVariant) = VT_DISPATCH;
        V_DISPATCH(&ElemVariant) = ElemIf;

        // the ElemIf is stored twice (although it was incremented once in _InternalQueryInterface
        // need to keep this in mind when releasing the interfaces

        INT_PTR Index;
        
        try
        {
            Index = m_ElemIfArray.Add(ElemIf);
        }
        catch(...)
        {
            delete CompInstance;
            return E_OUTOFMEMORY;
        }

        try
        {
            BASE::Add(ElemVariant);
        }
        catch(...)
        {
            m_ElemIfArray.RemoveAt(Index);
            delete CompInstance;
            return E_OUTOFMEMORY;
        }
    }

    // inform the sdp list that there is no need to destroy the members on destruction
    SdpList.ClearDestroyMembersFlag();

    // for each of the inserted instances, set the destroy element flag to true
    for (i=0; (int)i < BASE::GetSize(); i++)
    {
        ((T *)m_ElemIfArray.GetAt(i))->SetDestroyElementFlag();
    }

    m_ConfBlob  = &ConfBlob;
    m_SdpList   = &SdpList;
    return S_OK;
}


template <class T>
inline typename IF_ARRAY<T>::ELEM_IF  * 
IF_ARRAY<T>::GetAt(
    IN      UINT    Index
    )
{
    ASSERT(Index < (UINT)BASE::GetSize());

    return m_ElemIfArray.GetAt(Index);
}


template <class T>
HRESULT  
IF_ARRAY<T>::Add(
    IN      UINT    Index,
    IN      ELEM_IF *ElemIf
    )
{
    ASSERT(NULL != m_SdpList);
    ASSERT(BASE::GetSize() == m_SdpList->GetSize());
    ASSERT(Index <= (UINT)BASE::GetSize());
    ASSERT(NULL != ElemIf);

    // shift elements with equal or higher indices forwards
    // cheat COM here, and get the sdp specific class instance for the elem if
    
    // initialize the variant wrapper
    VARIANT ElemVariant;
    V_VT(&ElemVariant) = VT_DISPATCH;
    V_DISPATCH(&ElemVariant) = ElemIf;

    // insert into the arrays
    try
    {
        m_ElemIfArray.InsertAt(Index, ElemIf);
    }
    catch(...)
    {
        return E_OUTOFMEMORY;
    }

    try
    {
        BASE::InsertAt(Index, ElemVariant);
    }
    catch(...)
    {
        m_ElemIfArray.RemoveAt(Index);
        return E_OUTOFMEMORY;
    }

    try
    {
        m_SdpList->InsertAt(Index, &(((T *)ElemIf)->GetContent()));
    }
    catch(...)
    {
        BASE::RemoveAt(Index);
        m_ElemIfArray.RemoveAt(Index);
        return E_OUTOFMEMORY;
    }

    return S_OK;
}       



template <class T>
inline void  
IF_ARRAY<T>::Delete(
    IN      UINT    Index
    )
{
    ASSERT(NULL != m_SdpList);
    ASSERT(BASE::GetSize() == m_SdpList->GetSize());
    ASSERT(Index < (UINT)BASE::GetSize());

    // inform the instance that a reference to the blob is no longer needed
    ((T *)m_ElemIfArray.GetAt(Index))->ClearSdpBlobRefs();

    m_ElemIfArray.GetAt(Index)->Release();

    // move other members backwards
    m_ElemIfArray.RemoveAt(Index);
    BASE::RemoveAt(Index);
    m_SdpList->RemoveAt(Index);
}



template <class T>
inline UINT 
IF_ARRAY<T>::GetSize(
    )
{
    ASSERT(0 <= BASE::GetSize());

    return (UINT)BASE::GetSize();
}


template <class T>
inline VARIANT  * 
IF_ARRAY<T>::GetData(
    )
{
    return BASE::GetData();
}


template <class T>
inline typename IF_ARRAY<T>::ELEM_IF  **
IF_ARRAY<T>::GetElemIfArrayData(
    )
{
    return m_ElemIfArray.GetData();
}

        
template <class T>
inline CSdpConferenceBlob   *
IF_ARRAY<T>::GetSdpBlob(
    )
{
    return m_ConfBlob;
}


template <class T>
inline void 
IF_ARRAY<T>::ClearSdpBlobRefs(
    )
{
    m_ConfBlob = NULL;

    // clear sdp blob references in each of the inserted instances
    for(UINT i=0; (int)i < BASE::GetSize(); i++)
    {
        // inform the inserted instance that a reference to the blob is no longer needed
        ((T *)m_ElemIfArray.GetAt(i))->ClearSdpBlobRefs();
    }

    // keep the list (m_SdpList) around, it is already disassociated from the conf blob instance
}


template <class T>
inline typename IF_ARRAY<T>::SDP_LIST *
IF_ARRAY<T>::GetSdpList(
    )
{
    return m_SdpList;
}


template <class T>
IF_ARRAY<T>::~IF_ARRAY(
    )
{
    for(UINT i=0; (int)i < BASE::GetSize(); i++)
    {
        if ( NULL != m_ElemIfArray.GetAt(i) )
        {
            // inform the instance that a reference to the blob is no longer needed
            // NOTE: the Remove... call may already have been made, but since it is an
            // inline fn, no need to check that before calling
            ((T *)m_ElemIfArray.GetAt(i))->ClearSdpBlobRefs();

            // NOTE: since the interface is stored twice - in the elem if array as well
            // as the base variant array but AddRef is only done once (by _InternalQuery..)
            // Release is also done only once
            m_ElemIfArray.GetAt(i)->Release();
        }
    }
}




template <class T>
class ATL_NO_VTABLE MY_COLL_IMPL : 
    public T::COLL_IF
{
protected:

    typedef typename T::SDP_LIST                   SDP_LIST;
    typedef typename T::ELEM_IF                    ELEM_IF;

    typedef CComObject<CSafeComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT> > > ENUM_VARIANT;

    typedef typename T::ENUM_IF                    ENUM_IF;
    typedef _CopyInterface<typename T::ELEM_IF>    COPY_ELEM_IF;

public:

    inline MY_COLL_IMPL();

    inline HRESULT Init(
        IN      CSdpConferenceBlob  &ConfBlob,
        IN      SDP_LIST            &SdpList
        );

    STDMETHOD(Create)(/*[in]*/ LONG Index, /*[out, retval]*/ ELEM_IF **Interface);
    STDMETHOD(Delete)(/*[in]*/ LONG Index);
    STDMETHOD(get__NewEnum)(/*[out, retval]*/ IUnknown * *pVal);
    STDMETHOD(get_EnumerationIf)(/*[out, retval]*/ ENUM_IF **pVal) = 0;
    STDMETHOD(get_Item)(/*[in]*/ LONG Index, /*[out, retval]*/ ELEM_IF **pVal);
    STDMETHOD(get_Count)(/*[out, retval]*/ LONG *pVal);

    inline void ClearSdpBlobRefs();

    virtual ~MY_COLL_IMPL();

protected:

    IF_ARRAY<T>    *m_IfArray;
};



template <class T>
inline
MY_COLL_IMPL<T>::MY_COLL_IMPL(
    )
    : m_IfArray(NULL)
{
}


template <class T>
inline HRESULT
MY_COLL_IMPL<T>::Init(
    IN      CSdpConferenceBlob  &ConfBlob,
    IN      SDP_LIST            &SdpList
    )
{
    if ( NULL != m_IfArray )
    {
        delete m_IfArray;
    }

    // create an interface array
    try
    {
        m_IfArray = new IF_ARRAY<T>;
    }
    catch(...)
    {
        m_IfArray = NULL;
    }

    BAIL_IF_NULL(m_IfArray, E_OUTOFMEMORY);

    // initialize the interface array
    HRESULT HResult = m_IfArray->Init(ConfBlob, SdpList);
    BAIL_ON_FAILURE(HResult);

    // successful
    return S_OK;
}


template <class T>    
STDMETHODIMP MY_COLL_IMPL<T>::Create(
    /*[in]*/ LONG Index, 
    /*[out, retval]*/ ELEM_IF **Interface
    )
{
    CLock Lock(g_DllLock);
    
    ASSERT(NULL != m_IfArray);
    BAIL_IF_NULL(m_IfArray, E_FAIL);

    // use 1-based index, VB like
    // can add at atmost 1 beyond the last element
    if ((Index < (LONG)1) || (Index > (LONG)(m_IfArray->GetSize()+1)))
    {
        return E_INVALIDARG;
    }

    BAIL_IF_NULL(Interface, E_INVALIDARG);

    // if the sdp blob doesn't exist, creation is not allowed
    if ( NULL == m_IfArray->GetSdpBlob() )
    {
        return HRESULT_FROM_ERROR_CODE(SDPBLB_CONF_BLOB_DESTROYED);
    }

    CComObject<T> *TComObject;
    HRESULT HResult = CComObject<T>::CreateInstance(&TComObject);
    BAIL_ON_FAILURE(HResult);

    HResult = TComObject->Init(*(m_IfArray->GetSdpBlob()));
    if ( FAILED(HResult) )
    {
        delete TComObject;
        return HResult;
    }

    HResult = TComObject->_InternalQueryInterface(T::ELEM_IF_ID, (void**)Interface);
    if (FAILED(HResult))
    {
        delete TComObject;
        return HResult;
    }

    // adjust index to c like index value
    HResult = m_IfArray->Add(Index-1, *Interface);
    if (FAILED(HResult))
    {
        delete TComObject;
        return HResult;
    }

    // add another reference count for the interface being returned
    (*Interface)->AddRef();

    return S_OK;
}



template <class T>
STDMETHODIMP MY_COLL_IMPL<T>::Delete(
    /*[in]*/ LONG Index
    )
{
    CLock Lock(g_DllLock);
    
    ASSERT(NULL != m_IfArray);
    BAIL_IF_NULL(m_IfArray, E_FAIL);

    // use 1-based index, VB like
    if ((Index < (LONG)1) || (Index > (LONG)m_IfArray->GetSize()))
    {
        return E_INVALIDARG;
    }

    // if the sdp blob doesn't exist, deletion is not allowed
    if ( NULL == m_IfArray->GetSdpBlob() )
    {
        return HRESULT_FROM_ERROR_CODE(SDPBLB_CONF_BLOB_DESTROYED);
    }

    // adjust index to c like index value, delete the instance
    m_IfArray->Delete(Index-1);

    return S_OK;
}


template <class T>
STDMETHODIMP MY_COLL_IMPL<T>::get__NewEnum(
    /*[out, retval]*/ IUnknown **pVal
    )
{
    CLock Lock(g_DllLock);
    
    ASSERT(NULL != m_IfArray);
    BAIL_IF_NULL(m_IfArray, E_FAIL);

    BAIL_IF_NULL(pVal, E_INVALIDARG);

    ENUM_VARIANT *EnumComObject;
    HRESULT HResult = ENUM_VARIANT::CreateInstance(&EnumComObject);
    BAIL_ON_FAILURE(HResult);

    HResult = EnumComObject->Init(
                    m_IfArray->GetData(), 
                    m_IfArray->GetData() + m_IfArray->GetSize(),
                    NULL,                        // no owner pUnk
                    AtlFlagCopy                    // copy the array data
                    );
    if ( FAILED(HResult) )
    {
        delete EnumComObject;
        return HResult;
    }

    // query for the IUnknown interface and return it
    HResult = EnumComObject->_InternalQueryInterface(IID_IUnknown, (void**)pVal);
    if ( FAILED(HResult) )
    {
        delete EnumComObject;
        return HResult;
    }

    return S_OK;
}


template <class T>
STDMETHODIMP MY_COLL_IMPL<T>::get_Item(
    /*[in]*/ LONG Index, 
    /*[out, retval]*/ ELEM_IF **pVal
    )
{
    CLock Lock(g_DllLock);
    
    ASSERT(NULL != m_IfArray);
    BAIL_IF_NULL(m_IfArray, E_FAIL);

    BAIL_IF_NULL(pVal, E_INVALIDARG);

    // use 1-based index, VB like
    if ((Index < (LONG)1) || (Index > (LONG)m_IfArray->GetSize()))
    {
        return E_INVALIDARG;
    }

    *pVal = m_IfArray->GetAt(Index-1);
    (*pVal)->AddRef();

    return S_OK;
}


template <class T>
STDMETHODIMP MY_COLL_IMPL<T>::get_Count(
    /*[out, retval]*/ LONG *pVal
    )
{
    CLock Lock(g_DllLock);
    
    ASSERT(NULL != m_IfArray);
    BAIL_IF_NULL(m_IfArray, E_FAIL);

    BAIL_IF_NULL(pVal, E_INVALIDARG);

    *pVal = m_IfArray->GetSize();

    return S_OK;
}


template <class T>
inline void 
MY_COLL_IMPL<T>::ClearSdpBlobRefs(
    )
{
    m_IfArray->ClearSdpBlobRefs();
}


template <class T>
/* virtual */ 
MY_COLL_IMPL<T>::~MY_COLL_IMPL(
    )
{
    // if an interface array exists, destroy it
    if ( NULL != m_IfArray )
    {
        if ( NULL != m_IfArray->GetSdpList() )
        {
            delete m_IfArray->GetSdpList();
        }

        delete m_IfArray;
    }
}


#endif // __BLB_COLLECTION_ENUMERATION_IMPL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\blbdbg.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    blbdbg.cpp

Abstract:

    This module contains the debugging support for the userdir dll.

Author:
    
    Mu Han (muhan)   1-May-1997

Changes:

    copied muhan's file from userdir and changed the key used to find out the debug level
    B.Rajeev (rajeevb) 10-Oct-1997

--*/
 
#include "stdafx.h"
#include "blbdbg.h"

#ifdef SDPDBG

#define MAXDEBUGSTRINGLENGTH 512

static DWORD   sg_dwTraceID = INVALID_TRACEID;

static char    sg_szTraceName[100];   // saves name of dll
static DWORD   sg_dwTracingToDebugger = 0;
static DWORD   sg_dwTracingToConsole  = 0;
static DWORD   sg_dwTracingToFile     = 0;
static DWORD   sg_dwDebuggerMask      = 0;

BOOL SDPLogRegister(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szDebuggerTracingEnableValue[] = "EnableDebuggerTracing";
    const char szConsoleTracingEnableValue[] = "EnableConsoleTracing";
    const char szFileTracingEnableValue[] = "EnableFileTracing";
    const char szTracingMaskValue[]   = "ConsoleTracingMask";

    sg_dwTracingToDebugger = 0;
    sg_dwTracingToConsole = 0;
    sg_dwTracingToFile = 0; 

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ,
                                        &hTracingKey) )
    {
        DWORD      dwDataSize = sizeof (DWORD);
        DWORD      dwDataType;

        RegQueryValueExA(hTracingKey,
                         szDebuggerTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToDebugger,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szConsoleTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToConsole,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szFileTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToFile,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szTracingMaskValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwDebuggerMask,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

#ifdef UNICODE
    wsprintfA(sg_szTraceName, "%ls", szName);
#else
    wsprintfA(sg_szTraceName, "%s", szName);
#endif

    sg_dwTraceID = TraceRegister(szName);

    return (sg_dwTraceID != INVALID_TRACEID);
}

void SDPLogDeRegister()
{
    sg_dwTracingToDebugger = 0;
    sg_dwTracingToConsole = 0;
    sg_dwTracingToFile = 0; 

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(sg_dwTraceID);
        sg_dwTraceID = INVALID_TRACEID;
    }
}

void DbgPrt(IN int dwDbgLevel, IN LPCTSTR lpszFormat, IN ...)
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:

--*/
{
    TCHAR buf[MAXDEBUGSTRINGLENGTH + 1];
    TCHAR *message[5] = 
    {
        _T("FAIL: "), 
        _T("WARN: "), 
        _T("INFO: "), 
        _T("TRCE: "), 
        _T("ELSE: ")
    };

    if ((sg_dwTracingToDebugger > 0) &&
        (((DWORD)dwDbgLevel) <= sg_dwDebuggerMask))
    {
        SYSTEMTIME SystemTime;

        // retrieve local time
        GetLocalTime(&SystemTime);

        va_list ap;

        if (dwDbgLevel > ELSE) 
        {
            dwDbgLevel = ELSE;
        }
        wsprintf(buf, _T("SDPBLB:[%02u:%02u:%02u.%03u,tid=%x:]%s"),
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond,
            SystemTime.wMilliseconds,
            GetCurrentThreadId(), 
            message[dwDbgLevel - 1]
            );

        va_start(ap, lpszFormat);
        _vsntprintf(&buf[lstrlen(buf)], 
            MAXDEBUGSTRINGLENGTH - lstrlen(buf), 
            lpszFormat, 
            ap
            );
        lstrcat(buf, _T("\n"));
        OutputDebugString(buf);
    }

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        if ( ( sg_dwTracingToConsole > 0 ) || ( sg_dwTracingToFile > 0 ) )
        {
            if (dwDbgLevel > ELSE) 
            {
                dwDbgLevel = ELSE;
            }

            wsprintf(buf, _T("[%s] %s"), message[dwDbgLevel-1], lpszFormat);

            va_list arglist;
            va_start(arglist, lpszFormat);
            TraceVprintfEx(sg_dwTraceID, dwDbgLevel, buf, arglist);
            va_end(arglist);
        }
    }

}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\blbdbg.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    blbdbg.h

Abstract:

    Definitions for some debugging support soutines.

Author:
    
    Mu Han (muhan) 1-May-1997

Changes:

    copied muhan's file from userdir and got rid of the read ptr/ write ptr methods
    B.Rajeev (rajeevb) 10-Oct-1997

--*/

#ifndef __REND_DEBUG__
#define __REND_DEBUG__

#define FAIL 1
#define WARN 2
#define INFO 3
#define TRCE 4
#define ELSE 5

#ifdef SDPDBG

#include <Rtutils.h>

#ifdef __cplusplus
extern "C" {
#endif

void DbgPrt(IN int dwDbgLevel, IN LPCTSTR DbgMessage, IN ...);
BOOL SDPLogRegister(LPCTSTR szName);
void SDPLogDeRegister();

#define DBGOUT(arg) DbgPrt arg

#ifdef __cplusplus
}
#endif

#define DBGOUT(arg) DbgPrt arg
#define SDPLOGREGISTER(arg) SDPLogRegister(arg)
#define SDPLOGDEREGISTER() SDPLogDeRegister()

#else // SDPDBG

#define DBGOUT(arg)
#define SDPLOGREGISTER(arg)
#define SDPLOGDEREGISTER()

#endif // SDPDBG


#endif // __REND_DEBUG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\blbgen.h ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    blbgen.h

Abstract:


Author:

*/

#ifndef __BLB_GEN__
#define __BLB_GEN__

#include "blbdbg.h"

#include <mspenum.h> // for CSafeComEnum

const WCHAR_EOS = '\0';
    
/////////////////////////////////////////////////////////////////////////////
// my critical section
/////////////////////////////////////////////////////////////////////////////
class CCritSection
{
private:
    CRITICAL_SECTION m_CritSec;

public:
    CCritSection()
    {
        InitializeCriticalSection(&m_CritSec);
    }

    ~CCritSection()
    {
        DeleteCriticalSection(&m_CritSec);
    }

    void Lock() 
    {
        EnterCriticalSection(&m_CritSec);
    }

    void Unlock() 
    {
        LeaveCriticalSection(&m_CritSec);
    }
};

/////////////////////////////////////////////////////////////////////////////
// an auto lock that uses my critical section
/////////////////////////////////////////////////////////////////////////////
class CLock
{
private:
    CCritSection &m_CriticalSection;

public:
    CLock(CCritSection &CriticalSection)
        : m_CriticalSection(CriticalSection)
    {
        m_CriticalSection.Lock();
    }

    ~CLock()
    {
        m_CriticalSection.Unlock();
    }
};

// This is the lock on this dll that simulate an apartment model.
// per sdp lock is much better but it requires a lot of code changes.
// Since this is not a time critical component, we can live with it.
extern CCritSection    g_DllLock;  

#endif // __BLB_GEN__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\blbmedia.h ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    blbmedia.h: 

Abstract:
    Definition of the MEDIA class


Author:

*/

#if !defined(AFX_MEDIA_H__0CC1F057_CAEB_11D0_8D58_00C04FD91AC0__INCLUDED_)
#define AFX_MEDIA_H__0CC1F057_CAEB_11D0_8D58_00C04FD91AC0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols
#include "blbcoen.h"
#include "blbsdp.h"
#include "blbconn.h"
#include "blbatt.h"

/////////////////////////////////////////////////////////////////////////////
// MEDIA

const USHORT MAX_PORT_STRLEN = 5;

template <class T>
class  ITMediaVtbl : public ITMedia
{
};


class ATL_NO_VTABLE MEDIA :
    public ENUM_ELEMENT<SDP_MEDIA>,
    public CComObjectRootEx<CComObjectThreadModel>,
    public CComDualImpl<ITMediaVtbl<MEDIA>, &IID_ITMedia, &LIBID_SDPBLBLib>, 
    public ITConnectionImpl, 
    public ITAttributeListImpl,
    public CObjectSafeImpl
{
protected:

    friend class MY_COLL_IMPL<MEDIA>;

public:
    typedef ITMedia             ELEM_IF;
    typedef IEnumMedia          ENUM_IF;
    typedef ITMediaCollection   COLL_IF;
    typedef SDP_MEDIA            SDP_TYPE;
    typedef SDP_MEDIA_LIST        SDP_LIST;

    static const IID &ELEM_IF_ID;

public:

    inline MEDIA();
    inline ~MEDIA();
    inline HRESULT FinalConstruct();

    HRESULT Init(
        IN      CSdpConferenceBlob  &ConfBlob
        );

    inline void SuccessInit(
        IN      CSdpConferenceBlob  &ConfBlob,
        IN      SDP_MEDIA   &SdpMedia
        );

    inline void ClearSdpBlobRefs();


BEGIN_COM_MAP(MEDIA)
    COM_INTERFACE_ENTRY2(IDispatch, ITMedia)
    COM_INTERFACE_ENTRY(ITMedia)
    COM_INTERFACE_ENTRY(ITConnection)
    COM_INTERFACE_ENTRY(ITAttributeList)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(MEDIA) 

DECLARE_GET_CONTROLLING_UNKNOWN()

// ITMedia
    STDMETHOD(get_MediaTitle)(/*[out, retval]*/ BSTR *ppMediaTitle);
    STDMETHOD(put_MediaTitle)(/*[in]*/ BSTR pMediaTitle);
    STDMETHOD(get_FormatCodes)(/*[out, retval]*/ VARIANT /*SAFEARRAY (BSTR)*/ *pVal);
    STDMETHOD(put_FormatCodes)(/*[in]*/ VARIANT /*SAFEARRAY (BSTR)*/ NewVal);
    STDMETHOD(get_TransportProtocol)(/*[out, retval]*/ BSTR *ppProtocol);
    STDMETHOD(put_TransportProtocol)(/*[in]*/ BSTR pProtocol);
    STDMETHOD(get_NumPorts)(/*[out, retval]*/ LONG *pNumPorts);
    STDMETHOD(get_StartPort)(/*[out, retval]*/ LONG *pStartPort);
    STDMETHOD(get_MediaName)(/*[out, retval]*/ BSTR *ppMediaName);
    STDMETHOD(put_MediaName)(/*[in]*/ BSTR pMediaName);
    STDMETHOD(SetPortInfo)(/*[in]*/ LONG StartPort, /*[in]*/ LONG NumPorts);

    //
    // IDispatch  methods
    //

    STDMETHOD(GetIDsOfNames)(REFIID riid, 
                             LPOLESTR* rgszNames,
                             UINT cNames, 
                             LCID lcid, 
                             DISPID* rgdispid
                            );

    STDMETHOD(Invoke)(DISPID dispidMember, 
                      REFIID riid, 
                      LCID lcid,
                      WORD wFlags, 
                      DISPPARAMS* pdispparams, 
                      VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, 
                      UINT* puArgErr
                      );

protected:

    CSdpConferenceBlob  * m_ConfBlob;
    IUnknown            * m_pFTM;  // pointer to the free threaded marshaler

    virtual CSdpConferenceBlob *GetConfBlob();
};  


inline 
MEDIA::MEDIA(
    )
    : m_ConfBlob(NULL),
      m_pFTM(NULL)
{
}

inline 
MEDIA::~MEDIA()
{
    if ( m_pFTM )
    {
        m_pFTM->Release();
    }
}

inline
HRESULT MEDIA::FinalConstruct()
{
    HRESULT HResult = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                     & m_pFTM );

    if ( FAILED(HResult) )
    {
        return HResult;
    }

    return S_OK;
}

inline void
MEDIA::SuccessInit(
    IN      CSdpConferenceBlob  &ConfBlob,
    IN      SDP_MEDIA           &SdpMedia
    )
{
    m_ConfBlob = &ConfBlob;
    ENUM_ELEMENT<SDP_MEDIA>::SuccessInit(SdpMedia, FALSE);
    ITConnectionImpl::SuccessInit(SdpMedia);
    ITAttributeListImpl::SuccessInit(SdpMedia.GetAttributeList());
}


inline void 
MEDIA::ClearSdpBlobRefs(
    )
{
    m_ConfBlob = NULL;
}



#endif // !defined(AFX_MEDIA_H__0CC1F057_CAEB_11D0_8D58_00C04FD91AC0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\blbmeco.h ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    blbmeco.h

Abstract:
    Definition of the MEDIA_COLLECTION class

Author:

*/

#if !defined(AFX_BLBMECO_H__0CC1F04D_CAEB_11D0_8D58_00C04FD91AC0__INCLUDED_)
#define AFX_BLBMECO_H__0CC1F04D_CAEB_11D0_8D58_00C04FD91AC0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols

#include "blbgen.h"
#include "blbsdp.h"
#include "blbcoen.h"
#include "blbmedia.h"

/////////////////////////////////////////////////////////////////////////////
// MEDIA_COLLECTION


typedef IDispatchImpl<MY_COLL_IMPL<MEDIA>, &IID_ITMediaCollection, &LIBID_SDPBLBLib>    MY_MEDIA_COLL_DISPATCH_IMPL;

class ATL_NO_VTABLE MEDIA_COLLECTION : 
    public MY_MEDIA_COLL_DISPATCH_IMPL, 
    public CComObjectRootEx<CComObjectThreadModel>,
    public CObjectSafeImpl

{
public:
    
BEGIN_COM_MAP(MEDIA_COLLECTION)
    COM_INTERFACE_ENTRY2(IDispatch, ITMediaCollection)
    COM_INTERFACE_ENTRY(ITMediaCollection)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(MEDIA_COLLECTION) 

DECLARE_GET_CONTROLLING_UNKNOWN()

    STDMETHODIMP get_EnumerationIf(
        /*[out, retval]*/ ENUM_IF **pVal
        )
    {
        CLock Lock(g_DllLock);
    
        ASSERT(NULL != m_IfArray);
        BAIL_IF_NULL(m_IfArray, E_FAIL);

        BAIL_IF_NULL(pVal, E_INVALIDARG);

        CComObject<CSafeComEnum<ENUM_IF, &IID_IEnumMedia , ELEM_IF *, COPY_ELEM_IF> > * EnumComObject;
        HRESULT HResult = CComObject<CSafeComEnum<ENUM_IF, &IID_IEnumMedia , ELEM_IF *, COPY_ELEM_IF> >::
            CreateInstance(&EnumComObject);
        BAIL_ON_FAILURE(HResult);

        HResult = EnumComObject->Init(
                        m_IfArray->GetElemIfArrayData(), 
                        m_IfArray->GetElemIfArrayData() + m_IfArray->GetSize(),
                        NULL,                        // no owner pUnk
                        AtlFlagCopy                    // copy the array data
                        );
        if ( FAILED(HResult) )
        {
            delete EnumComObject;
            return HResult;
        }

        // query for the ENUM_IF interface and return it
        HResult = EnumComObject->_InternalQueryInterface(IID_IEnumMedia, (void**)pVal);
        if ( FAILED(HResult) )
        {
            delete EnumComObject;
            return HResult;
        }

        return S_OK;
    }

    MEDIA_COLLECTION() : m_pFTM(NULL) { }
    ~MEDIA_COLLECTION() { if ( m_pFTM ) m_pFTM->Release(); }

    inline HRESULT FinalConstruct(void);

protected:
    IUnknown            * m_pFTM;  // pointer to the free threaded marshaler

};

inline
HRESULT MEDIA_COLLECTION::FinalConstruct(void)
{
    HRESULT HResult = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                     & m_pFTM );

    if ( FAILED(HResult) )
    {
        return HResult;
    }

    return S_OK;
}


#endif // !defined(AFX_BLBMECO_H__0CC1F04D_CAEB_11D0_8D58_00C04FD91AC0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\blbreg.h ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    blbreg.h

Abstract:


Author:

*/

#ifndef __SDP_BLOB_REGISTRY__
#define __SDP_BLOB_REGISTRY__


#include <windows.h>
#include <tchar.h>
#include <winreg.h>


// maximum length of a DNS host name
const BYTE    MAXHOSTNAME = 255;

const TCHAR TCHAR_EOS    = _T('\0');


const DWORD MAX_REG_TSTR_SIZE = 100;

const DWORD MAX_BLOB_TEMPLATE_SIZE = 2000;

const DWORD    NUM_DEF_ATTRIBUTES = 5;


#define TIME_TEMPLATE                _T("TimeTemplate")

#define MEDIA_TEMPLATE                _T("MediaTemplate")


#define CONFERENCE_BLOB_TEMPLATE    _T("SdpTemplate")


#define START_TIME_OFFSET            _T("startTimeOffset")

#define STOP_TIME_OFFSET            _T("stopTimeOffset")




typedef struct 
{
    TCHAR    *msz_ValueName;
    USHORT    m_MaxSize;
    USHORT    *m_TstrLen;
    TCHAR    *msz_Tstr;
} REG_INFO;
    

extern REG_INFO g_ConfInstInfoArray[];

class KEY_WRAP
{
public:

    inline KEY_WRAP(
        IN    HKEY Key
        );

    inline ~KEY_WRAP();

protected:

    HKEY m_Key;
};


inline 
KEY_WRAP::KEY_WRAP(
    IN    HKEY Key
    )
    : m_Key(Key)
{
}

    
inline 
KEY_WRAP::~KEY_WRAP(
    )
{
    RegCloseKey(m_Key);
}


class REG_READER
{
public:

    inline static DWORD GetErrorCode();

protected:

    static DWORD    ms_ErrorCode;

    static BOOL ReadRegValues(
        IN    HKEY    Key,
        IN    DWORD    NumValues,
        IN    REG_INFO const RegInfoArray[]
        );
};


inline DWORD 
REG_READER::GetErrorCode(
    )
{
    return ms_ErrorCode;
}




class IP_ADDRESS
{
public:

    inline IP_ADDRESS();

    inline IP_ADDRESS(
        IN        DWORD    HostOrderIpAddress
        );

    inline BOOL        IsValid() const;

    inline void        SetIpAddress(
        IN        DWORD    HostOrderIpAddress
        );

    inline TCHAR    *GetTstr() const;

    static BOOL        GetLocalIpAddress(
            OUT    DWORD    &LocalIpAddress
        );

protected:

    TCHAR    m_IpAddressTstr[16];
};


inline 
IP_ADDRESS::IP_ADDRESS(
    )
{
    // only needed for the static host ip address instance
}


inline 
IP_ADDRESS::IP_ADDRESS(
    IN    DWORD    HostOrderIpAddress
    )
{
    SetIpAddress(HostOrderIpAddress);
}


inline BOOL 
IP_ADDRESS::IsValid(
    ) const
{
    // if the ip address string is empty, the instance is invalid
    return (TCHAR_EOS != m_IpAddressTstr[0]);
}

inline void
IP_ADDRESS::SetIpAddress(
    IN    DWORD    HostOrderIpAddress
    )
{
    // format the four bytes in the dword into an ip address string
    // check for success (use verify)
    VERIFY(0 != _stprintf(m_IpAddressTstr, _T("%d.%d.%d.%d"),HIBYTE(HIWORD(HostOrderIpAddress)),LOBYTE(HIWORD(HostOrderIpAddress)),HIBYTE(LOWORD(HostOrderIpAddress)),LOBYTE(LOWORD(HostOrderIpAddress)) ) );
}


inline TCHAR    *
IP_ADDRESS::GetTstr(
    ) const
{
    ASSERT(IsValid());

    return (TCHAR *)m_IpAddressTstr;
}



class SDP_REG_READER : public REG_READER
{
public:

    static TCHAR    ms_TimeTemplate[MAX_REG_TSTR_SIZE];
    static TCHAR    ms_MediaTemplate[MAX_REG_TSTR_SIZE];
    static TCHAR    ms_ConfBlobTemplate[MAX_BLOB_TEMPLATE_SIZE];

    static USHORT   ms_TimeTemplateLen;
    static USHORT   ms_MediaTemplateLen;
    static USHORT   ms_ConfBlobTemplateLen;

    static DWORD    ms_StartTimeOffset;
    static DWORD    ms_StopTimeOffset;

    inline static TCHAR  *GetTimeTemplate();

    inline static USHORT GetTimeTemplateLen();

    inline static TCHAR  *GetMediaTemplate();

    inline static USHORT GetMediaTemplateLen();

    inline static TCHAR  *GetConfBlobTemplate();

    inline static USHORT GetConfBlobTemplateLen();

    inline static DWORD  GetStartTimeOffset();

    inline static DWORD  GetStopTimeOffset();

    inline static TCHAR  *GetHostIpAddress();

    static BOOL IsWinsockStarted() { return ms_fWinsockStarted; }

    inline static BOOL IsValid();

protected:

    static BOOL         ms_fInitCalled;

    static BOOL         ms_fWinsockStarted;

    static IP_ADDRESS   ms_HostIpAddress;

    static BOOL CheckIfCorrectVersion();

    static BOOL    ReadTimeValues(
        IN    HKEY ConfInstKey
        );

    static void Init();

    static void AddCharacterSetAttribute();
};



inline TCHAR *    
SDP_REG_READER::GetTimeTemplate(
    )
{
    if (!ms_fInitCalled)
    {
        Init();
    }
    return ms_TimeTemplate;
}

    
inline USHORT
SDP_REG_READER::GetTimeTemplateLen(
    )
{
    if (!ms_fInitCalled)
    {
        Init();
    }
    return ms_TimeTemplateLen;
}
    
    
inline TCHAR *
SDP_REG_READER::GetMediaTemplate(
    )
{
    if (!ms_fInitCalled)
    {
        Init();
    }
    return ms_MediaTemplate;
}

    
inline USHORT
SDP_REG_READER::GetMediaTemplateLen(
    )
{
    if (!ms_fInitCalled)
    {
        Init();
    }
    return ms_MediaTemplateLen;
}
    
inline TCHAR *
SDP_REG_READER::GetConfBlobTemplate(
    )
{
    if (!ms_fInitCalled)
    {
        Init();
    }
    return ms_ConfBlobTemplate;
}

    
inline USHORT
SDP_REG_READER::GetConfBlobTemplateLen(
    )
{
    if (!ms_fInitCalled)
    {
        Init();
    }
    return ms_ConfBlobTemplateLen;
}


inline DWORD    
SDP_REG_READER::GetStartTimeOffset(
    )
{
    if (!ms_fInitCalled)
    {
        Init();
    }
    return ms_StartTimeOffset;
}

    
inline DWORD
SDP_REG_READER::GetStopTimeOffset(
    )
{
    if (!ms_fInitCalled)
    {
        Init();
    }
    return ms_StopTimeOffset;
}


inline TCHAR *
SDP_REG_READER::GetHostIpAddress(
    )
{
    if (!ms_fInitCalled)
    {
        Init();
    }
    return ms_HostIpAddress.GetTstr();
}

inline BOOL    
SDP_REG_READER::IsValid(
    )
{
    if (!ms_fInitCalled)
    {
        Init();
    }
    return (ERROR_SUCCESS == ms_ErrorCode)? TRUE: FALSE;
}


#endif // __SDP_BLOB_REGISTRY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\blbmedia.cpp ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    blbmedia.cpp

Abstract:
    Implementation of CSdpblbApp and DLL registration.

Author:

*/



#include "stdafx.h"

#include "blbgen.h"
#include "sdpblb.h"
#include "blbmedia.h"
#include "blbreg.h"
#include "addrgen.h"

// audio string with a trailing blank for the audio media blob
const TCHAR     AUDIO_TSTR[] = _T("audio ");
const USHORT    AUDIO_TSTRLEN = (sizeof(AUDIO_TSTR)/sizeof(TCHAR) -1);

// static variables
const IID &MEDIA::ELEM_IF_ID        = IID_ITMedia;


// uses GetElement() to access the sdp media instance - calls ENUM_ELEMENT::GetElement()


CSdpConferenceBlob *
MEDIA::GetConfBlob(
    )
{
    return m_ConfBlob;
}


HRESULT
MEDIA::Init(
    IN      CSdpConferenceBlob  &ConfBlob
    )
{
    // check if the registry entries were read without errors
    if ( !SDP_REG_READER::IsValid() )
    {
        return HRESULT_FROM_ERROR_CODE(SDP_REG_READER::GetErrorCode());
    }

    // allocate an audio port
    // using random values for lease period since its not being interpreted
    MSA_PORT_GROUP    PortGroup;
    PortGroup.PortType    = AUDIO_PORT;
    WORD FirstAudioPort;

    // allocate video port
    if ( !MSAAllocatePorts(&PortGroup, FALSE, 1, &FirstAudioPort) )
    {
        return HRESULT_FROM_ERROR_CODE(GetLastError());
    }

    // create a defalt sdp media instance
    SDP_MEDIA    *SdpMedia;

    try
    {
        SdpMedia = new SDP_MEDIA();
    }
    catch(...)
    {
        SdpMedia = NULL;
    }

    BAIL_IF_NULL(SdpMedia, E_OUTOFMEMORY);

    // allocate memory for the audio media blob
    TCHAR *SdpMediaBlob;
      
    try
    {
        SdpMediaBlob = new TCHAR[
                            SDP_REG_READER::GetMediaTemplateLen() +
                            AUDIO_TSTRLEN +
                            MAX_PORT_STRLEN
                            ];
    }
    catch(...)
    {
        SdpMediaBlob = NULL;
    }

    if ( NULL == SdpMediaBlob )
    {
        delete SdpMedia;
        return E_OUTOFMEMORY;
    }


    // copy AUDIO_TSTR into the sdp media blob
    lstrcpy(SdpMediaBlob, AUDIO_TSTR);

    TCHAR   *BlobPtr = SdpMediaBlob;

    // use the media template to create a media blob
    // parse the media blob to initialize the sdp media instance
    // if not successful, delete the sdp media instance and return error
    if ( (0 == _stprintf(SdpMediaBlob+AUDIO_TSTRLEN, SDP_REG_READER::GetMediaTemplate(), FirstAudioPort)) ||
         (!SdpMedia->ParseLine(BlobPtr)) )
    {
        delete SdpMedia;
        delete SdpMediaBlob;
        return HRESULT_FROM_ERROR_CODE(GetLastError());
    }
        
    delete SdpMediaBlob;

    m_ConfBlob = &ConfBlob;

    ENUM_ELEMENT<SDP_MEDIA>::SuccessInit(*SdpMedia, TRUE);
    ITConnectionImpl::SuccessInit(*SdpMedia);
    ITAttributeListImpl::SuccessInit(SdpMedia->GetAttributeList());

    return S_OK;
}



STDMETHODIMP MEDIA::get_MediaName(BSTR * pVal)
{
    CLock Lock(g_DllLock);
    
    ASSERT(GetElement().IsValid());

    return GetElement().GetName().GetBstrCopy(pVal);
}

STDMETHODIMP MEDIA::put_MediaName(BSTR newVal)
{
    CLock Lock(g_DllLock);
    
    ASSERT(GetElement().IsValid());

    return GetElement().GetName().SetBstr(newVal);
}

STDMETHODIMP MEDIA::get_StartPort(LONG * pVal)
{
    BAIL_IF_NULL(pVal, E_INVALIDARG);

    CLock Lock(g_DllLock);
    
    ASSERT(GetElement().IsValid());

    // vb doesn't take a USHORT (16bit unsigned value)
    *pVal = (LONG)GetElement().GetStartPort().GetValue();
    return S_OK;
}

STDMETHODIMP MEDIA::get_NumPorts(LONG * pVal)
{
    BAIL_IF_NULL(pVal, E_INVALIDARG);

    CLock Lock(g_DllLock);
    
    ASSERT(GetElement().IsValid());

    // vb doesn't take a USHORT (16bit unsigned value)
    *pVal = (LONG)(GetElement().GetNumPorts().IsValid() ? GetElement().GetNumPorts().GetValue() : 1);
    return S_OK;
}


STDMETHODIMP MEDIA::SetPortInfo(LONG StartPort, LONG NumPorts)
{
    CLock Lock(g_DllLock);
    
    ASSERT(GetElement().IsValid());

    // validate the start port and num ports value - they should be USHORT values [0..2**16-1]
    if ( !((0 <= StartPort) && (USHORT(-1) > StartPort) && (0 <= NumPorts) && (USHORT(-1) > NumPorts)) )
    {
        return E_INVALIDARG;
    }

    return GetElement().SetPortInfo((USHORT)StartPort, (USHORT)NumPorts);
}


STDMETHODIMP MEDIA::get_TransportProtocol(BSTR * pVal)
{
    CLock Lock(g_DllLock);
    
    ASSERT(GetElement().IsValid());

    return GetElement().GetProtocol().GetBstrCopy(pVal);
}

STDMETHODIMP MEDIA::put_TransportProtocol(BSTR newVal)
{
    CLock Lock(g_DllLock);
    
    ASSERT(GetElement().IsValid());

    return GetElement().GetProtocol().SetBstr(newVal);
}

STDMETHODIMP MEDIA::get_FormatCodes(VARIANT /*SAFEARRAY (BSTR)*/ * pVal)
{
    CLock Lock(g_DllLock);
    
    ASSERT(GetElement().IsValid());

    return GetElement().GetFormatCodeList().GetSafeArray(pVal);
}

STDMETHODIMP MEDIA::put_FormatCodes(VARIANT /*SAFEARRAY (BSTR)*/ newVal)
{
    CLock Lock(g_DllLock);
    
    ASSERT(GetElement().IsValid());

    return GetElement().GetFormatCodeList().SetSafeArray(newVal);
}

STDMETHODIMP MEDIA::get_MediaTitle(BSTR * pVal)
{
    CLock Lock(g_DllLock);
    
    ASSERT(GetElement().IsValid());

    return GetElement().GetTitle().GetBstrCopy(pVal);
}

STDMETHODIMP MEDIA::put_MediaTitle(BSTR newVal)
{
    CLock Lock(g_DllLock);
    
    ASSERT(GetElement().IsValid());

    return GetElement().GetTitle().SetBstr(newVal);
}

#define INTERFACEMASK (0xff0000)
typedef IDispatchImpl<ITMediaVtbl<MEDIA>, &IID_ITMedia, &LIBID_SDPBLBLib>    CMedia;
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// MEDIA::GetIDsOfNames
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP MEDIA::GetIDsOfNames(REFIID riid,
                                      LPOLESTR* rgszNames, 
                                      UINT cNames, 
                                      LCID lcid, 
                                      DISPID* rgdispid
                                      ) 
{ 
    HRESULT hr = DISP_E_UNKNOWNNAME;



    //
    // See if the requsted method belongs to the default interface
    //

    hr = CMedia::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        rgdispid[0] |= IDISPMEDIA;
        return hr;
    }

    //
    // If not, then try the ITConnection base class
    //

    hr = ITConnectionImpl::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        rgdispid[0] |= IDISPCONNECTION;
        return hr;
    }

    //
    // If not, then try the ITAttributeList base class
    //

    hr = ITAttributeListImpl::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        rgdispid[0] |= IDISPATTRLIST;
        return hr;
    }


    return hr; 
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// MEDIA::Invoke
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP MEDIA::Invoke(DISPID dispidMember, 
                              REFIID riid, 
                              LCID lcid, 
                              WORD wFlags, 
                              DISPPARAMS* pdispparams, 
                              VARIANT* pvarResult, 
                              EXCEPINFO* pexcepinfo, 
                              UINT* puArgErr
                             )
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    DWORD   dwInterface = (dispidMember & INTERFACEMASK);
   
   
    //
    // Call invoke for the required interface
    //

    switch (dwInterface)
    {
        case IDISPMEDIA:
        {
            hr = CMedia::Invoke(dispidMember, 
                                    riid, 
                                    lcid, 
                                    wFlags, 
                                    pdispparams,
                                    pvarResult, 
                                    pexcepinfo, 
                                    puArgErr
                                   );
        
            break;
        }

        case IDISPCONNECTION:
        {
            hr = ITConnectionImpl::Invoke(dispidMember, 
                                        riid, 
                                        lcid, 
                                        wFlags, 
                                        pdispparams,
                                        pvarResult, 
                                        pexcepinfo, 
                                        puArgErr
                                       );

            break;
        }

        case IDISPATTRLIST:
        {
            hr = ITAttributeListImpl::Invoke(dispidMember, 
                                        riid, 
                                        lcid, 
                                        wFlags, 
                                        pdispparams,
                                        pvarResult, 
                                        pexcepinfo, 
                                        puArgErr
                                       );

            break;
        }

    } // end switch (dwInterface)


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\blbreg.cpp ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    blbreg.cpp

Abstract:


Author:

*/

#include "stdafx.h"
// #include <windows.h>
// #include <wtypes.h>
#include <winsock2.h>
#include "blbreg.h"


const TCHAR TCHAR_BLANK    = _T(' ');


const TCHAR gsz_SdpRoot[] =
        _T("Software\\Microsoft\\Windows\\CurrentVersion\\Dynamic Directory\\Conference\\Sdp");

const TCHAR gsz_ConfInstRoot[] =
        _T("Software\\Microsoft\\Windows\\CurrentVersion\\Dynamic Directory\\Conference");

const TCHAR gsz_CharNewLine = _T('\n');
const TCHAR gsz_CharRegNewLine = _T('#');


DWORD   REG_READER::ms_ErrorCode = ERROR_INTERNAL_ERROR;


TCHAR   SDP_REG_READER::ms_TimeTemplate[MAX_REG_TSTR_SIZE];
TCHAR   SDP_REG_READER::ms_MediaTemplate[MAX_REG_TSTR_SIZE];
TCHAR   SDP_REG_READER::ms_ConfBlobTemplate[MAX_BLOB_TEMPLATE_SIZE];

USHORT  SDP_REG_READER::ms_TimeTemplateLen;
USHORT  SDP_REG_READER::ms_MediaTemplateLen;
USHORT  SDP_REG_READER::ms_ConfBlobTemplateLen;

DWORD   SDP_REG_READER::ms_StartTimeOffset;
DWORD   SDP_REG_READER::ms_StopTimeOffset;

BOOL    SDP_REG_READER::ms_fInitCalled;
    
BOOL    SDP_REG_READER::ms_fWinsockStarted;

IP_ADDRESS  SDP_REG_READER::ms_HostIpAddress;

static REG_INFO const gs_SdpRegInfoArray[] = 
{
    {TIME_TEMPLATE,        
        sizeof(SDP_REG_READER::ms_TimeTemplate) - 1,    // -1 for the newline
        &SDP_REG_READER::ms_TimeTemplateLen,
        SDP_REG_READER::ms_TimeTemplate},
    {MEDIA_TEMPLATE,            
        sizeof(SDP_REG_READER::ms_MediaTemplate) - 1,    // -1 for the newline
        &SDP_REG_READER::ms_MediaTemplateLen,
        SDP_REG_READER::ms_MediaTemplate},
    {CONFERENCE_BLOB_TEMPLATE,    
        sizeof(SDP_REG_READER::ms_ConfBlobTemplate),    
        &SDP_REG_READER::ms_ConfBlobTemplateLen,
        SDP_REG_READER::ms_ConfBlobTemplate}
};
    
    
inline void
AppendTchar(
    IN  OUT TCHAR   *Tstr, 
    IN  OUT USHORT  &TstrLen, 
    IN      TCHAR   AppendChar
    )
{
    ASSERT(lstrlen(Tstr) == TstrLen);

    Tstr[TstrLen++] = AppendChar;
    Tstr[TstrLen] = TCHAR_EOS;
}


                                                                               

BOOL
REG_READER::ReadRegValues(
    IN    HKEY    Key,
    IN    DWORD    NumValues,
    IN    REG_INFO const RegInfoArray[]
    )
{
    DWORD ValueType = REG_SZ;
    DWORD BufferSize = 0;

    // for each value field, retrieve the value
    for (UINT i=0; i < NumValues; i++)
    {
        // determine the size of the buffer 
        ms_ErrorCode = RegQueryValueEx(
                        Key,
                        RegInfoArray[i].msz_ValueName,
                        0,
                        &ValueType,
                        NULL,
                        &BufferSize
                       );
        if ( ERROR_SUCCESS != ms_ErrorCode )
        {
            return FALSE;
        }

        // check if the reqd buffer is bigger than the max acceptable size
        if ( RegInfoArray[i].m_MaxSize < BufferSize )
        {
            ms_ErrorCode = ERROR_OUTOFMEMORY;
            return FALSE;
        }

        // retrieve the value into the allocated buffer
        ms_ErrorCode = RegQueryValueEx(
                        Key,
                        RegInfoArray[i].msz_ValueName,
                        0,
                        &ValueType,
                        (BYTE *)RegInfoArray[i].msz_Tstr,
                        &BufferSize
                       );
        if ( ERROR_SUCCESS != ms_ErrorCode )
        {
            return FALSE;
        }

        // the reqd buffer size is > 1
        ASSERT(1 > BufferSize );

        // jump over any trailing blank characters - start at the last but one char
        for(UINT j=BufferSize-2; (TCHAR_BLANK == RegInfoArray[i].msz_Tstr[j]); j--)
        {
        }

        // if trailing blank chars, set the EOS beyond the last non-blank char
        if ( j < (BufferSize-2) )
        {
            RegInfoArray[i].msz_Tstr[j+1] = TCHAR_EOS;
        }

        // set the length of the tstr
        *RegInfoArray[i].m_TstrLen = j+1;
    }

    // return success
    return TRUE;
}


// static method
BOOL    
IP_ADDRESS::GetLocalIpAddress(
        OUT    DWORD    &LocalIpAddress
    )
{
    CHAR        LocalHostName[MAXHOSTNAME];
    LPHOSTENT    Hostent;
    int            WsockErrorCode;

    // get the local host name
    WsockErrorCode = gethostname(LocalHostName, MAXHOSTNAME);
    if ( SOCKET_ERROR != WsockErrorCode)
    {
        // resolve host name for local address
        Hostent = gethostbyname((LPSTR)LocalHostName);
        if ( Hostent )
        {
            LocalIpAddress = ntohl(*((u_long *)Hostent->h_addr));
            return TRUE;
        }
    }

    const CHAR *LOOPBACK_ADDRESS_STRING = "127.0.0.1";

    SOCKADDR_IN    LocalAddress;
    SOCKADDR_IN    RemoteAddress;
        INT             AddressSize = sizeof(sockaddr_in);
    SOCKET        Socket;

    // initialize it to 0 to use it as a check later
    LocalIpAddress = 0;

    // initialize the local address to 0
    LocalAddress.sin_addr.s_addr = INADDR_ANY;

    // if still not resolved try the (horrible) second strategy
    Socket = socket(AF_INET, SOCK_DGRAM, 0);
    if ( INVALID_SOCKET != Socket )
    {
        // connect to arbitrary port and address (NOT loopback)
        // if connect is not performed, the provider may not return
        // a valid ip address
        RemoteAddress.sin_family    = AF_INET;
        RemoteAddress.sin_port        = htons(IPPORT_ECHO);

        // this address should ideally be an address that is outside the
        // intranet - but no harm if the address is inside
        RemoteAddress.sin_addr.s_addr = inet_addr(LOOPBACK_ADDRESS_STRING);
        WsockErrorCode = connect(Socket, (sockaddr *)&RemoteAddress, sizeof(sockaddr_in));

        if ( SOCKET_ERROR != WsockErrorCode )
        {
            // get local address
            getsockname(Socket, (sockaddr *)&LocalAddress, (int *)&AddressSize);
            LocalIpAddress = ntohl(LocalAddress.sin_addr.s_addr);
        }

        // close the socket
        closesocket(Socket);
    }

    if ( 0 == LocalIpAddress )
    {
        SetLastError(WSAGetLastError());
        return FALSE;
    }

    return TRUE;
}


BOOL
SDP_REG_READER::ReadTimeValues(
    IN    HKEY SdpKey
    )
{
    DWORD    ValueType = REG_DWORD;
    DWORD    BufferSize = sizeof(DWORD);

    // read the start and stop time offsets
    ms_ErrorCode = RegQueryValueEx(
                    SdpKey,
                    START_TIME_OFFSET,
                    0,
                    &ValueType,
                    (BYTE *)&ms_StartTimeOffset,
                    &BufferSize
                    );
    if ( ERROR_SUCCESS != ms_ErrorCode )
    {
        return FALSE;
    }

    ms_ErrorCode = RegQueryValueEx(
                    SdpKey,
                    STOP_TIME_OFFSET,
                    0,
                    &ValueType,
                    (BYTE *)&ms_StopTimeOffset,
                    &BufferSize
                    );
    if ( ERROR_SUCCESS != ms_ErrorCode )
    {
        return FALSE;
    }

    return TRUE;
}

                                                                                    
BOOL                                                                                
SDP_REG_READER::CheckIfCorrectVersion(                                                 
    )                                                                   
{                                                                                   
    WORD        wVersionRequested;                                                  
    WSADATA     WsaData;                                                            
                                                                                    
    wVersionRequested = MAKEWORD(2, 0);   
                                                                                    
    // call winsock startup                                                         
    int ms_ErrorCode = WSAStartup( wVersionRequested, &WsaData );                   
                                                                                   
    if ( 0 != ms_ErrorCode )                                                        
    {                                                                               
        return FALSE;                                                               
    }                                                                               

    // we'll take any version - no need to check if the requested version is supported
    ms_fWinsockStarted = TRUE;

    return TRUE;                                                                    
}    


void SDP_REG_READER::Init(
    )
{
    ms_fInitCalled = TRUE;

    if ( !CheckIfCorrectVersion() )
    {
        return;
    }

    // try to determine the host ip address
    // ignore, if failed (255.255.255.255)
    DWORD    LocalIpAddress;
    IP_ADDRESS::GetLocalIpAddress(LocalIpAddress);
    ms_HostIpAddress.SetIpAddress((0==LocalIpAddress)?(-1):LocalIpAddress);

    // open sdp key
    HKEY    SdpKey;
    ms_ErrorCode = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    gsz_SdpRoot,
                    0,
                    KEY_READ, // ZoltanS was: KEY_ALL_ACCESS
                    &SdpKey
                    );
    if ( ERROR_SUCCESS != ms_ErrorCode )
    {
        return;
    }

    // ZoltanS: NO NEED TO CLOSE THE ABOVE KEY because it is
    // wrapped in the class and closed "automatically."

    KEY_WRAP RendKeyWrap(SdpKey);

    // read the template registry info (tstr values) under the key
    if ( !ReadRegValues(
            SdpKey, 
            sizeof(gs_SdpRegInfoArray)/ sizeof(REG_INFO), 
            gs_SdpRegInfoArray 
            ) )
    {
        return;
    }

    // Insert the "a:charset:%s#" into the sdp conference template
    AddCharacterSetAttribute();

    // replace the registry newline with the real newline character
    // NOTE - this is being done because we don't know how to enter the newline character
    // into a registry string
    for (UINT i=0; TCHAR_EOS != ms_ConfBlobTemplate[i]; i++)
    {
        if ( gsz_CharRegNewLine == ms_ConfBlobTemplate[i] )
        {
            ms_ConfBlobTemplate[i] = gsz_CharNewLine;
        }
    }

    // append newline after the media and time templates
    AppendTchar(ms_MediaTemplate, ms_MediaTemplateLen, gsz_CharNewLine);
    AppendTchar(ms_TimeTemplate, ms_TimeTemplateLen, gsz_CharNewLine);

    if ( !ReadTimeValues(SdpKey) )
    {
        return;
    }

    // success
    ms_ErrorCode = ERROR_SUCCESS;

    return;
}

/*++
AddCharacterSetAttribute

  This methd it's called by SDP_REG_READER::Init
  Try to add the "a:charset:%s#" into ms_ConfBlobTemplate
  This atribute represents the character sets
--*/
void SDP_REG_READER::AddCharacterSetAttribute()
{
    if( _tcsstr( ms_ConfBlobTemplate, _T("a=charset:")))
    {
        // The attribute is already into the Blob template
        return;
    }

    // The attribute charset is not in Blob Template
    // Try to find aut the "m=" (media attribute)
    TCHAR* szMediaTemplate = _tcsstr( ms_ConfBlobTemplate, _T("m="));
    if( szMediaTemplate == NULL)
    {
        // Add at the end of the template
        _tcscat( ms_ConfBlobTemplate, _T("a=charset:%s#"));
        return;
    }

    // We have to insert the
    TCHAR szBuffer[2000];
    _tcscpy( szBuffer, szMediaTemplate );

    // We concatenate the charset attribute
    szMediaTemplate[0] = (TCHAR)0;
    _tcscat( ms_ConfBlobTemplate, _T("a=charset:%s#"));

    // We add the media atrributes
    _tcscat( ms_ConfBlobTemplate, szBuffer);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\blbsdp.cpp ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    blbsdp.cpp

Abstract:


Author:

*/

#include "stdafx.h"

#include "blbgen.h"
#include "blbsdp.h"

const CHAR g_CharSetString[] = "\na=charset:";


HRESULT 
SDP_BLOB::SetBstr(
    IN  BSTR    SdpPacketBstr
    )
{
    // convert string to ANSI using the optional bstr base class
    HRESULT HResult = SDP_BSTRING::SetBstr(SdpPacketBstr);
    BAIL_ON_FAILURE(HResult);

    // parse the ANSI character string
    if ( !ParseSdpPacket(
            SDP_BSTRING::GetCharacterString(),
            SDP_BSTRING::GetCharacterSet()
            ) )
    {
        return HRESULT_FROM_ERROR_CODE(GetLastError());
    }

    return S_OK;
}


HRESULT    
SDP_BLOB::SetTstr(
    IN        TCHAR    *SdpPacketTstr
    )
{
    ASSERT(NULL != SdpPacketTstr);

#ifdef _UNICODE    // TCHAR is WCHAR

    BSTR    SdpPacketBstr = SysAllocString(SdpPacketTstr);
    BAIL_IF_NULL(SdpPacketBstr, E_OUTOFMEMORY);

    HRESULT HResult = SetBstr(SdpPacketBstr);
    SysFreeString(SdpPacketBstr);
    return HResult;

#else    // TCHAR is CHAR

    // parse the ANSI character string
    if ( !ParseSdpPacket(SdpPacketTstr) )
    {
        return HRESULT_FROM_ERROR_CODE(GetLastError());
    }

    // associate the character string with the SDP_BSTRING base instance
    // *** need a SetCharacterStringByPtr for optimizing this copy
    if ( !SDP_BSTRING::SetCharacterStringByCopy(SdpPacketTstr) )
    {
        return HRESULT_FROM_ERROR_CODE(GetLastError());
    }

    return S_OK;

#endif // _UNICODE

    // should never reach here
    ASSERT(FALSE);
    return S_OK;
}


HRESULT  
SDP_BLOB::GetBstr(
        OUT BSTR    *SdpPacketBstr
    )
{
    if ( !SDP::IsValid() )
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    // keep track of the old SDP packet pointer for a check below because we may reallocate m_SdpPacket
    // in the call to GenerateSdpPacket, but we may have a pointer to the old SDP packet stored as a
    // string by reference. If this is the case we need to be sure to SetCharacterStringByReference(m_SdpPacket).
    CHAR * OldSdpPacket = m_SdpPacket;

    // generate the character string SDP packet
    if ( !SDP::GenerateSdpPacket() )
    {
        return HRESULT_FROM_ERROR_CODE(GetLastError());
    }

    // check if the sdp packet has changed since last time
    // ZoltanS: if the pointers are equal, we have no way of knowing
    // without doing Unicode-to-ASCII conversion; always reassociate.

    char * pszBstrVersion = SDP_BSTRING::GetCharacterString();
    if( NULL == pszBstrVersion )
    {
        return E_OUTOFMEMORY;
    }   
    
    if ( ( pszBstrVersion == m_SdpPacket ) || ( pszBstrVersion == OldSdpPacket ) || strcmp(pszBstrVersion, m_SdpPacket) )
    {
        // associate the optional bstr instance with the sdp packet character string
        SDP_BSTRING::SetCharacterStringByReference(m_SdpPacket);
    }

    return SDP_BSTRING::GetBstr(SdpPacketBstr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\blbsdp.h ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    blbsdp.h

Abstract:


Author:

*/
#ifndef __SDP_BLOB__
#define __SDP_BLOB__

#include "sdp.h"


class SDP_BLOB : public SDP,
                 public SDP_BSTRING
{
public:

    inline BOOL IsValid();

    HRESULT SetBstr(
        IN  BSTR    SdpPacketBstr
        );

    HRESULT    SetTstr(
        IN  TCHAR    *SdpPacketTstr
        );

    HRESULT GetBstr(
        OUT BSTR    *SdpPacketBstr
        );
};



inline BOOL 
SDP_BLOB::IsValid(
    )
{
    return SDP::IsValid();
}



#endif // __SDP_BLOB__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\blbtico.cpp ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    
      blbtico.cpp

Abstract:


Author:

*/
#include "stdafx.h"
#include "blbtico.h"
#include "sdpblob.h"


STDMETHODIMP MY_TIME_COLL_IMPL::Create(
    /*[in]*/ ULONG Index, 
    /*[out, retval]*/ ELEM_IF **Interface
    )
{
    CLock Lock(g_DllLock);
    
    BAIL_ON_FAILURE(MY_COLL_IMPL<TIME>::Create(Index, Interface));

    return S_OK;
}


STDMETHODIMP MY_TIME_COLL_IMPL::Delete(
    /*[in]*/ ULONG Index
    )
{
    CLock Lock(g_DllLock);
    
    BAIL_ON_FAILURE(MY_COLL_IMPL<TIME>::Delete(Index));

    return S_OK;
}


HRESULT 
MY_TIME_COLL_IMPL::Create(
    IN  ULONG Index, 
    IN  DWORD StartTime, 
    IN  DWORD StopTime
    )
{
    ASSERT(NULL != m_IfArray);
    BAIL_IF_NULL(m_IfArray, E_FAIL);

    // use 1-based index, VB like
    // can add at atmost 1 beyond the last element
    if ((Index < 1) || (Index > (m_IfArray->GetSize()+1)))
    {
        return E_INVALIDARG;
    }

    // if the sdp blob doesn't exist, creation is not allowed
    if ( NULL == m_IfArray->GetSdpBlob() )
    {
        return HRESULT_FROM_ERROR_CODE(SDPBLB_CONF_BLOB_DESTROYED);
    }

    CComObject<TIME> *TimeComObject;
    HRESULT HResult = CComObject<TIME>::CreateInstance(&TimeComObject);
    BAIL_ON_FAILURE(HResult);

    HResult = TimeComObject->Init(*(m_IfArray->GetSdpBlob()), StartTime, StopTime);
    if ( FAILED(HResult) )
    {
        delete TimeComObject;
        return HResult;
    }

    ELEM_IF *Interface;
    HResult = TimeComObject->_InternalQueryInterface(IID_ITTime, (void**)&Interface);
    if (FAILED(HResult))
    {
        delete TimeComObject;
        return HResult;
    }

    // adjust index to c like index value
    HResult = m_IfArray->Add(Index-1, Interface);
    if (FAILED(HResult))
    {
        delete TimeComObject;
        return HResult;
    }

    // no need to add another reference count as the interface is not being returned
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\blbtico.h ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    blbtico.h

Abstract:

    Definition of the TIME_COLLECTION class

  Author:

*/

#if !defined(AFX_BLBTICO_H__2E4F4A20_0ABD_11D1_976D_00C04FD91AC0__INCLUDED_)
#define AFX_BLBTICO_H__2E4F4A20_0ABD_11D1_976D_00C04FD91AC0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols
#include "blbsdp.h"
#include "blbcoen.h"
#include "blbtime.h"

/////////////////////////////////////////////////////////////////////////////
// TIME_COLLECTION



class MY_TIME_COLL_IMPL : public MY_COLL_IMPL<TIME>
{
public:
    STDMETHOD(Create)(/*[in]*/ ULONG Index, /*[out, retval]*/ ELEM_IF **Interface);
    STDMETHOD(Delete)(/*[in]*/ ULONG Index);

    HRESULT Create(
        IN  ULONG Index, 
        IN  DWORD StartTime, 
        IN  DWORD StopTime
        );
};



typedef IDispatchImpl<MY_TIME_COLL_IMPL, &IID_ITTimeCollection, &LIBID_SDPBLBLib>    MY_TIME_COLL_DISPATCH_IMPL;

class ATL_NO_VTABLE TIME_COLLECTION : 
    public MY_TIME_COLL_DISPATCH_IMPL, 
    public CComObjectRootEx<CComObjectThreadModel>,
    public CObjectSafeImpl
{
public:

BEGIN_COM_MAP(TIME_COLLECTION)
    COM_INTERFACE_ENTRY2(IDispatch, ITTimeCollection)
    COM_INTERFACE_ENTRY(ITTimeCollection)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(TIME_COLLECTION) 

DECLARE_GET_CONTROLLING_UNKNOWN()

    STDMETHODIMP get_EnumerationIf(
        /*[out, retval]*/ ENUM_IF **pVal
        )
    {
        CLock Lock(g_DllLock);
    
        ASSERT(NULL != m_IfArray);
        BAIL_IF_NULL(m_IfArray, E_FAIL);

        BAIL_IF_NULL(pVal, E_INVALIDARG);

        CComObject<CSafeComEnum<ENUM_IF, &IID_IEnumTime , ELEM_IF *, COPY_ELEM_IF> > * EnumComObject;
        HRESULT HResult = CComObject<CSafeComEnum<ENUM_IF, &IID_IEnumTime , ELEM_IF *, COPY_ELEM_IF> >::
            CreateInstance(&EnumComObject);
        BAIL_ON_FAILURE(HResult);

        HResult = EnumComObject->Init(
                        m_IfArray->GetElemIfArrayData(), 
                        m_IfArray->GetElemIfArrayData() + m_IfArray->GetSize(),
                        NULL,                        // no owner pUnk
                        AtlFlagCopy                    // copy the array data
                        );
        if ( FAILED(HResult) )
        {
            delete EnumComObject;
            return HResult;
        }

        // query for the ENUM_IF interface and return it
        HResult = EnumComObject->_InternalQueryInterface(IID_IEnumTime, (void**)pVal);
        if ( FAILED(HResult) )
        {
            delete EnumComObject;
            return HResult;
        }

        return S_OK;
    }

    TIME_COLLECTION() : m_pFTM(NULL) { }
    ~TIME_COLLECTION() { if ( m_pFTM ) m_pFTM->Release(); }

    inline HRESULT FinalConstruct(void);

protected:
    IUnknown            * m_pFTM;  // pointer to the free threaded marshaler

};

inline
HRESULT TIME_COLLECTION::FinalConstruct(void)
{
    HRESULT HResult = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                     & m_pFTM );

    if ( FAILED(HResult) )
    {
        return HResult;
    }

    return S_OK;
}


#endif // !defined(AFX_BLBTICO_H__2E4F4A20_0ABD_11D1_976D_00C04FD91AC0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\blbtime.h ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    blbtime.h


Abstract:
    Definition of the TIME class

Author:

*/

#if !defined(AFX_BLBTIME_H__0CC1F05A_CAEB_11D0_8D58_00C04FD91AC0__INCLUDED_)
#define AFX_BLBTIME_H__0CC1F05A_CAEB_11D0_8D58_00C04FD91AC0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols
#include "sdpblb.h"
#include "blbcoen.h"

/////////////////////////////////////////////////////////////////////////////
// Time

const USHORT    MAX_NTP_TIME_STRLEN = 10;
const SHORT     FIRST_POSSIBLE_YEAR = 1970;
const DWORD     NTP_OFFSET = 0x83aa7e80;


// return the current Ntp time
inline DWORD_PTR
GetCurrentNtpTime(
        )
{
    return (time(NULL) + NTP_OFFSET);
}



class ATL_NO_VTABLE TIME :
    public ENUM_ELEMENT<SDP_TIME>,
    public CComObjectRootEx<CComObjectThreadModel>,
    public CComDualImpl<ITTime, &IID_ITTime, &LIBID_SDPBLBLib>,
    public CObjectSafeImpl
{
        friend class MY_COLL_IMPL<TIME>;

public:
    typedef ITTime             ELEM_IF;
    typedef IEnumTime          ENUM_IF;
    typedef ITTimeCollection   COLL_IF;
    typedef SDP_TIME           SDP_TYPE;
    typedef SDP_TIME_LIST      SDP_LIST;

    static const IID &ELEM_IF_ID;

public:

    inline TIME();
    inline ~TIME();
    inline HRESULT FinalConstruct(void);

    HRESULT Init(
        IN      CSdpConferenceBlob  &ConfBlob
        );

    HRESULT Init(
        IN      CSdpConferenceBlob  &ConfBlob,
        IN      DWORD               StartTime,
        IN      DWORD               StopTime
        );

    inline void SuccessInit(
        IN      CSdpConferenceBlob  &ConfBlob,
        IN      SDP_TIME            &SdpTime
        );

    inline void ClearSdpBlobRefs();

BEGIN_COM_MAP(TIME)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITTime)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(TIME) 

DECLARE_GET_CONTROLLING_UNKNOWN()

// ITTime
public:
    STDMETHOD(get_StopTime)(/*[out, retval]*/ DOUBLE *pTime);
    STDMETHOD(put_StopTime)(/*[in]*/ DOUBLE Time);
    STDMETHOD(get_StartTime)(/*[out, retval]*/ DOUBLE *pTime);
    STDMETHOD(put_StartTime)(/*[in]*/ DOUBLE Time);

protected:

    CSdpConferenceBlob  * m_ConfBlob;
    IUnknown            * m_pFTM;  // pointer to the free threaded marshaler
};


inline 
TIME::TIME(
    )
    : m_ConfBlob(NULL),
      m_pFTM(NULL)
{
}

inline 
HRESULT TIME::FinalConstruct(void)
{
    HRESULT HResult = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                     & m_pFTM );

    if ( FAILED(HResult) )
    {
        return HResult;
    }

    return S_OK;
}

inline 
TIME::~TIME()
{
    if ( m_pFTM )
    {
        m_pFTM->Release();
    }
}

inline void
TIME::SuccessInit(
    IN      CSdpConferenceBlob  &ConfBlob,
    IN      SDP_TIME            &SdpTime
    )
    
{
    m_ConfBlob = &ConfBlob;

    // don't free the sdptime instance on destruction
    ENUM_ELEMENT<SDP_TIME>::SuccessInit(SdpTime, FALSE);
}


inline void 
TIME::ClearSdpBlobRefs(
    )
{
    m_ConfBlob = NULL;
}


#endif // !defined(AFX_BLBTIME_H__0CC1F05A_CAEB_11D0_8D58_00C04FD91AC0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\dlldatax.c ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    dlldatax.c

Abstract:
    wrapper for dlldata.c

Author:

*/


#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400    //for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY    //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "sdpblb_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\blbtime.cpp ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    blbtime.cpp

Abstract:
    Implementation of CSdpblbApp and DLL registration.

Author:

*/

#include "stdafx.h"

#include "blbgen.h"
#include "sdpblb.h"
#include "sdpblob.h"
#include "blbtime.h"
#include "blbreg.h"

// static variables
const IID &TIME::ELEM_IF_ID    = IID_ITTime;

// uses GetElement() to access the sdp time instance - calls ENUM_ELEMENT::GetElement()

HRESULT
TIME::Init(
    IN      CSdpConferenceBlob  &ConfBlob
    )
{
    // create a defalt sdp time instance
    SDP_TIME    *SdpTime;
    
    try
    {
        SdpTime = new SDP_TIME();
    }
    catch(...)
    {
        SdpTime = NULL;
    }

    BAIL_IF_NULL(SdpTime, E_OUTOFMEMORY);

    // allocate memory for the time blob
    TCHAR SdpTimeBlob[50];

    TCHAR   *BlobPtr = SdpTimeBlob;
    // use the Time template to create a Time blob
    // parse the Time blob to initialize the sdp Time instance
    // if not successful, delete the sdp Time instance and return error
    if ( (0 == _stprintf(
                    SdpTimeBlob, 
                    SDP_REG_READER::GetTimeTemplate(), 
                    GetCurrentNtpTime() + SDP_REG_READER::GetStartTimeOffset(), // start time - current time + start offset,
                    GetCurrentNtpTime() + SDP_REG_READER::GetStopTimeOffset() // stop time - current time + stop offset
                    ) ) ||
         (!SdpTime->ParseLine(BlobPtr)) )
    {
        delete SdpTime;
        return HRESULT_FROM_ERROR_CODE(GetLastError());
    }

    m_ConfBlob = &ConfBlob;

    // the init methods returns void
    ENUM_ELEMENT<SDP_TIME>::SuccessInit(*SdpTime, TRUE);

    return S_OK;
}


HRESULT 
TIME::Init(
    IN      CSdpConferenceBlob  &ConfBlob,
    IN      DWORD               StartTime,
    IN      DWORD               StopTime
    )
{
    // create a defalt sdp time instance
    SDP_TIME    *SdpTime;
    
    try
    {
        SdpTime = new SDP_TIME();
    }
    catch(...)
    {
        SdpTime = NULL;
    }

    BAIL_IF_NULL(SdpTime, E_OUTOFMEMORY);

    // set the time instance start/stop time (also make it valid)
    HRESULT hr = SdpTime->SetTimes(StartTime, StopTime);
    if ( FAILED(hr) || (S_FALSE==hr) )
    {	
        delete SdpTime;
        return hr;
    }

    m_ConfBlob = &ConfBlob;

    // the init methods returns void
    ENUM_ELEMENT<SDP_TIME>::SuccessInit(*SdpTime, TRUE);

    return S_OK;
}



inline 
DWORD_PTR TimetToNtpTime(IN  time_t  TimetVal)
{
    return TimetVal + NTP_OFFSET;
}


inline 
time_t NtpTimeToTimet(IN  DWORD_PTR   NtpTime)
{
    return NtpTime - NTP_OFFSET;
}


inline HRESULT
SystemTimeToNtpTime(
    IN  SYSTEMTIME  &Time,
    OUT DWORD_PTR   &NtpDword
    )
{
    _ASSERTE(FIRST_POSSIBLE_YEAR <= Time.wYear);

    // fill in a tm struct with the values
    tm  NtpTmStruct;
    NtpTmStruct.tm_isdst    = -1;   // no info available about daylight savings time
    NtpTmStruct.tm_year     = (int)Time.wYear - 1900;
    NtpTmStruct.tm_mon      = (int)Time.wMonth - 1;    // months since january
    NtpTmStruct.tm_mday     = (int)Time.wDay;
    NtpTmStruct.tm_wday     = (int)Time.wDayOfWeek;
    NtpTmStruct.tm_hour     = (int)Time.wHour;
    NtpTmStruct.tm_min      = (int)Time.wMinute;
    NtpTmStruct.tm_sec      = (int)Time.wSecond;

    // try to convert into a time_t value
    time_t TimetVal = mktime(&NtpTmStruct);
    if ( -1 == TimetVal )
    {
        return E_INVALIDARG;
    }

    // convert the time_t value into an NTP value
    NtpDword = TimetToNtpTime(TimetVal);
    return S_OK;
}


inline
HRESULT
NtpTimeToSystemTime(
    IN  DWORD       dwNtpTime,
    OUT SYSTEMTIME &Time
    )
{
    // if the gen time is WSTR_GEN_TIME_ZERO then, 
    // all the out parameters should be set to 0
    if (dwNtpTime == 0)
    {
        memset(&Time, 0, sizeof(SYSTEMTIME));
        return S_OK;
    }

    time_t  Timet = NtpTimeToTimet(dwNtpTime);

    // get the local tm struct for this time value
    tm* pLocalTm = localtime(&Timet);
    if( pLocalTm == NULL )
    {
        return E_FAIL;
    }

    //
    // win64: added casts below
    //

    // set the ref parameters to the tm struct values
    Time.wYear         = (WORD) ( pLocalTm->tm_year + 1900 ); // years since 1900
    Time.wMonth        = (WORD) ( pLocalTm->tm_mon + 1 );     // months SINCE january (0,11)
    Time.wDay          = (WORD)   pLocalTm->tm_mday;
    Time.wDayOfWeek    = (WORD)   pLocalTm->tm_wday;
    Time.wHour         = (WORD)   pLocalTm->tm_hour;
    Time.wMinute       = (WORD)   pLocalTm->tm_min;
    Time.wSecond       = (WORD)   pLocalTm->tm_sec;
    Time.wMilliseconds = (WORD)   0;

    return S_OK;
}

STDMETHODIMP TIME::get_StartTime(DOUBLE * pVal)
{
    BAIL_IF_NULL(pVal, E_INVALIDARG);

    CLock Lock(g_DllLock);
    
    ULONG StartTime;
    BAIL_ON_FAILURE(GetElement().GetStartTime(StartTime));

    SYSTEMTIME Time;
    HRESULT hr = NtpTimeToSystemTime(StartTime, Time);
    if( FAILED(hr) )
    {
        return hr;
    }

    DOUBLE vtime;
    if (SystemTimeToVariantTime(&Time, &vtime) == FALSE)
    {
        return E_INVALIDARG;
    }

    *pVal = vtime;
    return S_OK;
}

STDMETHODIMP TIME::put_StartTime(DOUBLE newVal)
{
    SYSTEMTIME Time;

    if (VariantTimeToSystemTime(newVal, &Time) == FALSE)
    {
        return E_INVALIDARG;
    }

    DWORD_PTR dwNtpStartTime;
    if (newVal == 0)
    {
        // unbounded start time
        dwNtpStartTime = 0;
    }
    else if ( FIRST_POSSIBLE_YEAR > Time.wYear ) 
    {
        // cannot handle years less than FIRST_POSSIBLE_YEAR
        return E_INVALIDARG;
    }
    else
    {
        BAIL_ON_FAILURE(SystemTimeToNtpTime(Time, dwNtpStartTime));
    }

    CLock Lock(g_DllLock);
    
    HRESULT HResult = GetElement().SetStartTime((ULONG) dwNtpStartTime);

    return HResult;
}

STDMETHODIMP TIME::get_StopTime(DOUBLE * pVal)
{
    BAIL_IF_NULL(pVal, E_INVALIDARG);

    CLock Lock(g_DllLock);
    
    ULONG StopTime;
    BAIL_ON_FAILURE(GetElement().GetStopTime(StopTime));

    SYSTEMTIME Time;
    HRESULT hr = NtpTimeToSystemTime(StopTime, Time);
    if( FAILED(hr) )
    {
        return hr;
    }

    DOUBLE vtime;
    if (SystemTimeToVariantTime(&Time, &vtime) == FALSE)
    {
        return E_INVALIDARG;
    }

    *pVal = vtime;
    return S_OK;
}

STDMETHODIMP TIME::put_StopTime(DOUBLE newVal)
{
    SYSTEMTIME Time;
    if (VariantTimeToSystemTime(newVal, &Time) == FALSE)
    {
        return E_INVALIDARG;
    }

    DWORD_PTR dwNtpStartTime;
    if (newVal == 0)
    {
        // unbounded start time
        dwNtpStartTime = 0;
    }
    else if ( FIRST_POSSIBLE_YEAR > Time.wYear ) 
    {
        // cannot handle years less than FIRST_POSSIBLE_YEAR
        return E_INVALIDARG;
    }
    else
    {
        BAIL_ON_FAILURE(SystemTimeToNtpTime(Time, dwNtpStartTime));
    }

    CLock Lock(g_DllLock);
    
    GetElement().SetStopTime((ULONG)dwNtpStartTime);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\dlldatax.h ===
/*

 Copyright (c) 1998-1999  Microsoft Corporation

 Module Name:
    dlldatax.c

 Abstract:

 Author:

*/

#if !defined(AFX_DLLDATAX_H__C17D4461_323C_11D1_9774_00C04FD91AC0__INCLUDED_)
#define AFX_DLLDATAX_H__C17D4461_323C_11D1_9774_00C04FD91AC0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
    LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__C17D4461_323C_11D1_9774_00C04FD91AC0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\resource.h ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    resource.h


Abstract:

Author:

*/
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sdpblb.rc
//
#define IDS_PROJNAME                    100
#define IDR_SDPCONFERENCEBLOB           104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           113
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\sdpblob.cpp ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    sdpblob.cpp 

Abstract:
    Implementation of CSdpConferenceBlob

Author:

*/

#include "stdafx.h"

#include "blbgen.h"
#include "sdpblb.h"
#include "sdpblob.h"

#include "blbreg.h"
#include "addrgen.h"
#include <time.h>
#include <winsock2.h>
#include "blbtico.h"
#include "blbmeco.h"

// ZoltanS: This is the multicast address we give by default. The app must then
// go and get a real address via MDHCP and explicitly set it to a meaningful
// value.

const long DUMMY_ADDRESS = 0xe0000000; // A dummy address that qualifies as Class D.

/////////////////////////////////////////////////////////////////////////////
// CSdpConferenceBlob
/////////////////////////////////////////////////////////////////////////////

//
// definition for the critical section needed by
// CObjectSafeImpl
//

CComAutoCriticalSection CObjectSafeImpl::s_CritSection;


CCritSection    g_DllLock;

const USHORT MAX_IP_ADDRESS_STRLEN = 15;
const USHORT NUM_CONF_BLOB_TEMPLATE_PARAMS = 9;

// static SDP_REG_READER    gs_SdpRegReader;

// a 1-1 mapping from the index (BLOB_CHARACTER_SET) to the SDP_CHAR_SET
// ASSUMPTION: BCS_UTF8 is the last value in the enumeration BLOB_CHARACTER_SET
SDP_CHARACTER_SET const CSdpConferenceBlob::gs_SdpCharSetMapping[BCS_UTF8] =
{
    CS_ASCII,
    CS_UTF7,
    CS_UTF8
};

CSdpConferenceBlob *
CSdpConferenceBlob::GetConfBlob(
    )
{
    return this;
}


HRESULT
CSdpConferenceBlob::WriteStartTime(
    IN  DWORD   MinStartTime
    )
{
    CLock Lock(g_DllLock);

    int NumEntries = (int)GetTimeList().GetSize();

    // set the first time entry to the MinStartTime
    if ( 0 < NumEntries )
    {
        // need to make sure that the stop time is after the start time or unbounded (0)
        HRESULT HResult = ((SDP_TIME *)GetTimeList().GetAt(0))->SetStartTime(MinStartTime);
        BAIL_ON_FAILURE(HResult);      
    }
    else    // create an entry
    {
        // create a new entry, use vb 1 based indices
        HRESULT HResult = ((MY_TIME_COLL_IMPL *)m_TimeCollection)->Create(1, MinStartTime, 0);
        BAIL_ON_FAILURE(HResult);
    }

    // iterate through the time list and for each other time entry
    // modify the start time (if the start time is before MinStartTime, change it to MinStartTime)
    for(UINT i = 1; (int)i < NumEntries; i++ )
    {
        ULONG StartTime;
        HRESULT HResult = ((SDP_TIME *)GetTimeList().GetAt(i))->GetStartTime(StartTime);

        // ignore invalid values and continue
        if ( FAILED(HResult) )
        {
            continue;
        }

        if ( StartTime < MinStartTime )
        {
            HRESULT HResult = ((SDP_TIME *)GetTimeList().GetAt(i))->SetStartTime(MinStartTime);

            // ignore invalid values and continue
            if ( FAILED(HResult) )
            {
                continue;
            }
        }
    }

    return S_OK;
}

HRESULT
CSdpConferenceBlob::WriteStopTime(
    IN  DWORD   MaxStopTime
    )
{
    CLock Lock(g_DllLock);

    int NumEntries = (int)GetTimeList().GetSize();

    // set the first time entry to the MaxStopTime
    if ( 0 < NumEntries )
    {
        // need to make sure that the stop time is after the start time or unbounded (0)
        ((SDP_TIME *)GetTimeList().GetAt(0))->SetStopTime(MaxStopTime);

    }
    else    // create an entry
    {
        // create a new entry, use vb 1 based indices
        HRESULT HResult = ((MY_TIME_COLL_IMPL *)m_TimeCollection)->Create(1, 0, MaxStopTime);
        BAIL_ON_FAILURE(HResult);
    }

    // iterate through the time list and for each other time entry
    // modify the stop time (if the stop time is after MaxStopTime, change it to MaxStopTime)
    for(UINT i = 1; (int)i < NumEntries; i++ )
    {
        ULONG StopTime;
        HRESULT HResult = ((SDP_TIME *)GetTimeList().GetAt(i))->GetStopTime(StopTime);

        // ignore invalid values and continue
        if ( FAILED(HResult) )
        {
            continue;
        }

        if ( StopTime > MaxStopTime )
        {
            ((SDP_TIME *)GetTimeList().GetAt(i))->SetStopTime(MaxStopTime);
        }
    }

    return S_OK;
}

/*
enum RND_ADVERTISING_SCOPE    // as per SDP recommendations
{
    RAS_LOCAL,  //    ttl   <=1        recommended ttl  1
    RAS_SITE,   //          <=15                        15
    RAS_REGION, //          <=63                        63
    RAS_WORLD   //          <=255                       127
}    RND_ADVERTISING_SCOPE;

modification in     target            action
ITConference        SDP_BLOB        for each connection line, the ttl is set to a max of the
                                    recommended ttl for the new advertising scope
ITConnection        CONFERENCE        the SDP_BLOB component determines the max ttl and notifies the
                                    CONFERENCE of the new advertising scope

this is similar to the     way start/stop time modifications are handled.
*/


HRESULT
CSdpConferenceBlob::WriteAdvertisingScope(
    IN  DWORD   MaxAdvertisingScope
    )
{
    CLock Lock(g_DllLock);

    // ZoltanS: bug # 191413: check for out of range advertising scopes
    if ( ( MaxAdvertisingScope > RAS_WORLD ) ||
         ( MaxAdvertisingScope < RAS_LOCAL ) )
    {
        return E_INVALIDARG;
    }

    BYTE    MaxTtl = GetTtl((RND_ADVERTISING_SCOPE)MaxAdvertisingScope);

    // set the default connection ttl to the max ttl
    if ( GetConnection().GetTtl().IsValid() )
    {
        GetConnection().GetTtl().SetValue(MaxTtl);
    }
    else    // hack** : using SetConnection method. instead, the ttl field should always be kept valid
    {
        // get the current address and the number of addresses value and use the SetConnection method
        // this puts the ttl field into the array of member fields
        BSTR    StartAddress = NULL;
        BAIL_ON_FAILURE(GetConnection().GetStartAddress().GetBstr(&StartAddress));
        HRESULT HResult = GetConnection().SetConnection(
                            StartAddress,
                            GetConnection().GetNumAddresses().GetValue(),
                            MaxTtl
                            );
        BAIL_ON_FAILURE(HResult);
    }

    // iterate through the sdp media list and for each connection entry, set the ttl
    // to maxttl if its more than it
    int NumEntries = (int)GetMediaList().GetSize();
    for(UINT i = 1; (int)i < NumEntries; i++ )
    {
        SDP_CONNECTION  &SdpConnection = ((SDP_MEDIA *)GetMediaList().GetAt(i))->GetConnection();
        if ( SdpConnection.GetTtl().IsValid() && (SdpConnection.GetTtl().GetValue() > MaxTtl) )
        {
            SdpConnection.GetTtl().SetValue(MaxTtl);
        }
    }

    return S_OK;
}


STDMETHODIMP CSdpConferenceBlob::Init(
    /*[in]*/ BSTR pName,
    /*[in]*/ BLOB_CHARACTER_SET CharacterSet,
    /*[in]*/ BSTR pBlob
    )
{
    CLock Lock(g_DllLock);

    // validate the parameters
    // the name cannot be null, if no blob has been specified (if a blob is specified then the name
    // is implicit in it
    if ( (NULL == pName) && (NULL == pBlob) )
    {
        return E_INVALIDARG;
    }

    // initialize the sdp
    if ( !SDP_BLOB::Init() )
    {
        return HRESULT_FROM_ERROR_CODE(GetLastError());
    }

    // create media/time collection, query for I*Collection i/f
    CComObject<MEDIA_COLLECTION>    *MediaCollection;
    
    try
    {
        MediaCollection = new CComObject<MEDIA_COLLECTION>;
    }
    catch(...)
    {
        MediaCollection = NULL;
    }

    BAIL_IF_NULL(MediaCollection, HRESULT_FROM_ERROR_CODE(ERROR_INVALID_DATA));

    HRESULT HResult = MediaCollection->Init(*this, GetMediaList());
    if ( FAILED(HResult) )
    {
        delete MediaCollection;
        return HResult;
    }

    // inform the sdp instance that it needn't delete the media list on destruction
    ClearDestroyMediaListFlag();

    // query for the ITMediaCollection i/f
    HResult = MediaCollection->_InternalQueryInterface(IID_ITMediaCollection, (void **)&m_MediaCollection);
    if ( FAILED(HResult) )
    {
        delete MediaCollection;
        return HResult;
    }

    // on failure, just delete the time collection and return
    // no need to delete the media collection as well since that's taken care of by the destructor
    CComObject<TIME_COLLECTION>    *TimeCollection;
    
    try
    {
        TimeCollection = new CComObject<TIME_COLLECTION>;
    }
    catch(...)
    {
        TimeCollection = NULL;
    }

    BAIL_IF_NULL(TimeCollection, HRESULT_FROM_ERROR_CODE(ERROR_INVALID_DATA));

    HResult = TimeCollection->Init(*this, GetTimeList());
    if ( FAILED(HResult) )
    {
        delete TimeCollection;
        return HResult;
    }

    // inform the sdp instance that it needn't delete the time list on destruction
    ClearDestroyTimeListFlag();

    // query for the ITTimeCollection i/f
    HResult = TimeCollection->_InternalQueryInterface(IID_ITTimeCollection, (void **)&m_TimeCollection);
    if ( FAILED(HResult) )
    {
        delete TimeCollection;
        return HResult;
    }


    // check if a default sdp needs to be created, else use the sdp provided by the user
    if ( NULL == pBlob )
    {
        BAIL_ON_FAILURE(
            CreateDefault(
                pName,
                gs_SdpCharSetMapping[CharacterSet-1])
                );
    }
    else
    {
        // we change the Character set from the CS_UTF8
        // if the blob containts the "a=charset:" attribute
        CharacterSet = GetBlobCharacterSet( pBlob);

        // HACK ** we don't want notifications of blob contents when the sdp blob is being passed in
        // (conference directory - enumeration scenario), so the notification owner is set after the
        // conference blob is processed
        BAIL_ON_FAILURE(SetConferenceBlob(CharacterSet, pBlob));

        // at this point, the sdp is either passed in by the non-dir-user or is obtained by enumerating
        // the directory.
        // clear the modified state on the sdp (parsing in an sdp sets the state to modified) so that
        // only true modifications are tracked
        ClearModifiedState();
    }
    return S_OK;
}


STDMETHODIMP CSdpConferenceBlob::get_IsModified(VARIANT_BOOL * pVal)
{
    BAIL_IF_NULL(pVal, E_INVALIDARG);

    CLock Lock(g_DllLock);

    *pVal = ( (GetWasModified() || SDP::IsModified()) ? VARIANT_TRUE : VARIANT_FALSE);

    return S_OK;
}


STDMETHODIMP CSdpConferenceBlob::get_TimeCollection(
    ITTimeCollection * *ppTimeCollection
    )
{
    BAIL_IF_NULL(ppTimeCollection, E_INVALIDARG);

    CLock Lock(g_DllLock);

    ASSERT(NULL != m_TimeCollection);
    if ( NULL == m_TimeCollection )
    {
        return HRESULT_FROM_ERROR_CODE(ERROR_INVALID_DATA);
    }

    // increase the ref count
    m_TimeCollection->AddRef();

    *ppTimeCollection = m_TimeCollection;
    return S_OK;
}


STDMETHODIMP CSdpConferenceBlob::get_MediaCollection(
    ITMediaCollection * *ppMediaCollection
    )
{
    BAIL_IF_NULL(ppMediaCollection, E_INVALIDARG);

    CLock Lock(g_DllLock);

    ASSERT(NULL != m_MediaCollection);
    if ( NULL == m_MediaCollection )
    {
        return HRESULT_FROM_ERROR_CODE(ERROR_INVALID_DATA);
    }

    // increase the ref count
    m_MediaCollection->AddRef();

    *ppMediaCollection = m_MediaCollection;
    return S_OK;
}

STDMETHODIMP CSdpConferenceBlob::get_IsValid(VARIANT_BOOL * pVal)
{
    BAIL_IF_NULL(pVal, E_INVALIDARG);

    CLock Lock(g_DllLock);

    *pVal = (IsValid() ? VARIANT_TRUE : VARIANT_FALSE);

    return S_OK;
}


STDMETHODIMP CSdpConferenceBlob::get_CharacterSet(BLOB_CHARACTER_SET *pCharacterSet)
{
    // map the sdp character set value for SDP_BLOB to the BLOB_CHARACTER_SET
    BAIL_IF_NULL(pCharacterSet, E_INVALIDARG);

    CLock Lock(g_DllLock);

    // check the sdp char set values corresponding to the blob character sets for a match
    // if a match is found, return the index as the blob character set
    // NOTE: the for loop is dependent upon the order of declaration of the BLOB_CHARACTER_SET
    // enum values
    for( UINT BlobCharSet = BCS_ASCII; BCS_UTF8 >= BlobCharSet; BlobCharSet++ )
    {
		// BCS_ASCII is 1, but the array starts with 0, so the index is BlobCharSet - 1.
        if ( gs_SdpCharSetMapping[BlobCharSet -1] == SDP::GetCharacterSet() )
        {
            *pCharacterSet = (BLOB_CHARACTER_SET)BlobCharSet;
            return S_OK;
        }
    }

    return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
}


STDMETHODIMP CSdpConferenceBlob::get_ConferenceBlob(BSTR * pVal)
{
    CLock Lock(g_DllLock);

    return GetBstrCopy(pVal);
}


HRESULT
CSdpConferenceBlob::WriteConferenceBlob(
    IN  SDP_CHARACTER_SET   SdpCharSet,
    IN  BSTR                newVal
    )
{
    // set the character set of the SDP_BSTRING
    VERIFY(SetCharacterSet(SdpCharSet));

    // set the bstr to the passed in value, this is converted to the ascii representation and parsed
    HRESULT HResult = SetBstr(newVal);
    BAIL_ON_FAILURE(HResult);

    HResult = ((MEDIA_COLLECTION *)m_MediaCollection)->Init(*this, GetMediaList());
    BAIL_ON_FAILURE(HResult);

    HResult = ((TIME_COLLECTION *)m_TimeCollection)->Init(*this, GetTimeList());
    BAIL_ON_FAILURE(HResult);

    return S_OK;
}


STDMETHODIMP CSdpConferenceBlob::SetConferenceBlob(BLOB_CHARACTER_SET CharacterSet, BSTR newVal)
{
    // validate the passed in character set value
    // although this is an enumeration, someone may try and pass in a different value
    // NOTE: Assumes BCS_ASCII is the first and BCS_UTF8 is the last enumerated value
    if ( !( (BCS_ASCII <= CharacterSet) && (BCS_UTF8 >= CharacterSet) ) )
    {
        return E_INVALIDARG;
    }

    CLock Lock(g_DllLock);

    // map the BLOB_CHARACTER_SET value to the sdp character set (since the BCS value start at 1,
    // subtract 1 from the blob character set to index into the array
    // write the conference blob, also send notifications for any modified dependent attributes
    HRESULT HResult = WriteConferenceBlob(gs_SdpCharSetMapping[CharacterSet-1], newVal);
    BAIL_ON_FAILURE(HResult);

    return S_OK;
}


STDMETHODIMP CSdpConferenceBlob::get_ProtocolVersion(BYTE * pVal)
{
    BAIL_IF_NULL(pVal, E_INVALIDARG);

    CLock Lock(g_DllLock);

    // cast the ulong value to a byte because vb doesn't take a ulong, this shouldn't be
    // a problem until version 256
    *pVal = (BYTE)GetProtocolVersion().GetVersionValue();

    return S_OK;
}



STDMETHODIMP CSdpConferenceBlob::get_SessionId(DOUBLE * pVal)
{
    BAIL_IF_NULL(pVal, E_INVALIDARG);

    CLock Lock(g_DllLock);

    // vb doesn't take ulong - cast the ulong value to a double, the next bigger type
    *pVal = (DOUBLE)GetOrigin().GetSessionId().GetValue();

    return S_OK;
}

STDMETHODIMP CSdpConferenceBlob::get_SessionVersion(DOUBLE * pVal)
{
    BAIL_IF_NULL(pVal, E_INVALIDARG);

    CLock Lock(g_DllLock);

    // vb doesn't take ulong - cast the ulong value to a double, the next bigger type
    *pVal = (DOUBLE)GetOrigin().GetSessionVersion().GetValue();

    return S_OK;
}

STDMETHODIMP CSdpConferenceBlob::put_SessionVersion(DOUBLE newVal)
{
    // the bandwidth value must be a valid ULONG value (vb restrictions)
    if ( !((0 <= newVal) && (ULONG(-1) > newVal)) )
    {
        return E_INVALIDARG;
    }

    // check if there is any fractional part, this check is valid as it is a valid ULONG value
    if ( newVal != (ULONG)newVal )
    {
        return E_INVALIDARG;
    }

    CLock Lock(g_DllLock);

    GetOrigin().GetSessionVersion().SetValue((ULONG)newVal);

    return S_OK;
}


STDMETHODIMP CSdpConferenceBlob::get_MachineAddress(BSTR * pVal)
{
    CLock Lock(g_DllLock);

    return GetOrigin().GetAddress().GetBstrCopy(pVal);
}


STDMETHODIMP CSdpConferenceBlob::put_MachineAddress(BSTR newVal)
{
    CLock Lock(g_DllLock);

    return GetOrigin().GetAddress().SetBstr(newVal);
}



STDMETHODIMP CSdpConferenceBlob::get_Name(BSTR * pVal)
{
    CLock Lock(g_DllLock);

    return GetSessionName().GetBstrCopy(pVal);
}


STDMETHODIMP CSdpConferenceBlob::put_Name(BSTR newVal)
{
    // write the new session name
    // acquire lock inside
    return WriteName(newVal);
}


STDMETHODIMP CSdpConferenceBlob::get_Description(BSTR * pVal)
{
    CLock Lock(g_DllLock);

    return GetSessionTitle().GetBstrCopy(pVal);
}

STDMETHODIMP CSdpConferenceBlob::put_Description(BSTR newVal)
{
    // write the new session title / description
    // acquire lock inside
    HRESULT HResult = WriteSessionTitle(newVal);
    BAIL_ON_FAILURE(HResult);

    return S_OK;
}

STDMETHODIMP CSdpConferenceBlob::get_Url(BSTR * pVal)
{
    CLock Lock(g_DllLock);

    return GetUri().GetBstrCopy(pVal);
}


STDMETHODIMP CSdpConferenceBlob::put_Url(BSTR newVal)
{
    // write the new Url
    // acquire lock inside
    HRESULT HResult = WriteUrl(newVal);
    BAIL_ON_FAILURE(HResult);

    return S_OK;
}



STDMETHODIMP CSdpConferenceBlob::GetEmailNames(
    VARIANT /*SAFEARRAY(BSTR)*/ *Addresses, VARIANT /*SAFEARRAY(BSTR)*/ *Names
    )
{
    CLock Lock(g_DllLock);

    return GetEmailList().GetSafeArray(Addresses, Names);
}

STDMETHODIMP CSdpConferenceBlob::SetEmailNames(
    VARIANT /*SAFEARRAY(BSTR)*/ Addresses, VARIANT /*SAFEARRAY(BSTR)*/ Names
    )
{
    CLock Lock(g_DllLock);

    return GetEmailList().SetSafeArray(Addresses, Names);
}

STDMETHODIMP CSdpConferenceBlob::GetPhoneNumbers(
    VARIANT /*SAFEARRAY(BSTR)*/ *Numbers, VARIANT /*SAFEARRAY(BSTR)*/ *Names
    )
{
    CLock Lock(g_DllLock);

    return GetPhoneList().GetSafeArray(Numbers, Names);
}

STDMETHODIMP CSdpConferenceBlob::SetPhoneNumbers(
    VARIANT /*SAFEARRAY(BSTR)*/ Numbers, VARIANT /*SAFEARRAY(BSTR)*/ Names
    )
{
    CLock Lock(g_DllLock);

    return GetPhoneList().SetSafeArray(Numbers, Names);
}


STDMETHODIMP CSdpConferenceBlob::get_Originator(BSTR * pVal)
{
    CLock Lock(g_DllLock);

    return GetOrigin().GetUserName().GetBstrCopy(pVal);
}

STDMETHODIMP CSdpConferenceBlob::put_Originator(BSTR newVal)
{
    // write the new user name
    // acquire lock inside
    HRESULT HResult = WriteOriginator(newVal);
    BAIL_ON_FAILURE(HResult);

    return S_OK;
}

inline WORD
GetEvenValue(
    IN  WORD Value
    )
{
    return (0 == (Value % 2))? Value : (Value - 1);
}


TCHAR *
CSdpConferenceBlob::GenerateSdpBlob(
    IN  BSTR    Name,
    IN  SDP_CHARACTER_SET CharacterSet
    )
{
    ASSERT(NULL != Name);

    //
    // Get multicast ports. We don't set addresses; that's the app's
    // responsibility via MDHCP.
    //

    MSA_PORT_GROUP    PortGroup;
    PortGroup.PortType    = VIDEO_PORT;

    WORD FirstVideoPort;

    // allocate video port
    if ( !MSAAllocatePorts(&PortGroup, FALSE, 2, &FirstVideoPort) )
    {
        return NULL;
    }

    PortGroup.PortType    = AUDIO_PORT;

    WORD FirstAudioPort;

    // allocate audio port
    if ( !MSAAllocatePorts(&PortGroup, FALSE, 2, &FirstAudioPort) )
    {
        return NULL;
    }

    // convert the returned ports to even values for RTP compliance
    // ASSUMPTION : the sdp template read from the registry uses RTP as the transport
    FirstAudioPort = GetEvenValue(FirstAudioPort);
    FirstVideoPort = GetEvenValue(FirstVideoPort);

    IP_ADDRESS    AudioIpAddress(DUMMY_ADDRESS);
    IP_ADDRESS    VideoIpAddress(DUMMY_ADDRESS);

    const DWORD MAX_USER_NAME_LEN = 100;
    DWORD OriginatorBufLen = MAX_USER_NAME_LEN+1;
    TCHAR Originator[MAX_USER_NAME_LEN+1];

    if ( !GetUserName(Originator, &OriginatorBufLen) )
    {
        return NULL;
    }

    // altconv.h - requires this declaration for W2T to work
    USES_CONVERSION;

    // convert the provided name to a tchar; the returned tchar string is
    // allocated on the stack - no need to delete it
    TCHAR *TcharName = W2T(Name);
    BAIL_IF_NULL(TcharName, NULL);

    // allocate enough memory for the sdp blob
    TCHAR *SdpBlob;
    
    try
    {
        SdpBlob = new TCHAR[
                SDP_REG_READER::GetConfBlobTemplateLen() +
                lstrlen(Originator) +
                lstrlen(TcharName) +
                MAXHOSTNAME +
                3*MAX_NTP_TIME_STRLEN +
                2*MAX_IP_ADDRESS_STRLEN +
                2*MAX_PORT_STRLEN -
                2*NUM_CONF_BLOB_TEMPLATE_PARAMS
                ];
    }
    catch(...)
    {
        SdpBlob = NULL;
    }

    if ( NULL == SdpBlob )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return NULL;
    }


    //
    // ZoltanS: get the local host name (replaces all this IP address nonsense)
    //

    char        szLocalHostName[MAXHOSTNAME + 1];
    char      * pszHost;
    int         WsockErrorCode;

    WsockErrorCode = gethostname(szLocalHostName, MAXHOSTNAME);

    if ( 0 == WsockErrorCode )
    {
        struct hostent *hostp = gethostbyname(szLocalHostName);

        if ( hostp )
        {
            pszHost = hostp->h_name;
        }
        else
        {
            // if we can't resolve our own hostname (yuck!) then we can
            // still do *something* (but it may be bad for l2tp scenarios).

            pszHost = SDP_REG_READER::GetHostIpAddress();
        }
    }
    else
    {
        // if we can't get a hostname (yuck!) then we can still do
        // *something* (but it may be bad for l2tp scenarios).

        pszHost = SDP_REG_READER::GetHostIpAddress();
    }

    // stprintf the string to create the conference blob
    // check if the stprintf operation succeeded

    CHAR* szCharacterSet = (CHAR*)UTF8_STRING;
    switch( CharacterSet )
    {
    case CS_ASCII:
        szCharacterSet = (CHAR*)ASCII_STRING;
        break;
    case CS_UTF7:
        szCharacterSet = (CHAR*)UTF7_STRING;
        break;
    }

    if ( 0 == _stprintf(SdpBlob,
                        SDP_REG_READER::GetConfBlobTemplate(),
                        Originator,
                        GetCurrentNtpTime(),
                        pszHost, // ZoltanS was: SDP_REG_READER::GetHostIpAddress(), // local machine ip address string,
                        TcharName,
                        AudioIpAddress.GetTstr(), // common c field
                        GetCurrentNtpTime() + SDP_REG_READER::GetStartTimeOffset(), // start time - current time + start offset,
                        GetCurrentNtpTime() + SDP_REG_READER::GetStopTimeOffset(), // stop time - current time + stop offset
                        szCharacterSet,
                        FirstAudioPort,
                        FirstVideoPort,
                        VideoIpAddress.GetTstr()
                        )  )
    {
        delete SdpBlob;
        return NULL;
    }

    return SdpBlob;
}


HRESULT
CSdpConferenceBlob::CreateDefault(
    IN  BSTR Name,
    IN  SDP_CHARACTER_SET CharacterSet
    )
{
    BAIL_IF_NULL(Name, E_INVALIDARG);

    // check if the registry entries were read without errors
    if ( !SDP_REG_READER::IsValid() )
    {
        return HRESULT_FROM_ERROR_CODE(SDP_REG_READER::GetErrorCode());
    }

    // check if a valid conference blob already exists, return error
    if ( SDP_BLOB::IsValid() )
    {
        return E_FAIL;
    }

    // use the registry values to generate the default sdp
    CHAR *SdpBlob = GenerateSdpBlob(Name, CharacterSet);
    BAIL_IF_NULL(SdpBlob, HRESULT_FROM_ERROR_CODE(GetLastError()));

    ASSERT(NULL != SdpBlob);

    // parse in the sdp
    HRESULT HResult = SetTstr(SdpBlob);
    delete SdpBlob;
    BAIL_ON_FAILURE(HResult);

    HResult = ((MEDIA_COLLECTION *)m_MediaCollection)->Init(*this, GetMediaList());
    BAIL_ON_FAILURE(HResult);

    HResult = ((TIME_COLLECTION *)m_TimeCollection)->Init(*this, GetTimeList());
    BAIL_ON_FAILURE(HResult);

    return S_OK;
}

typedef IDispatchImpl<ITConferenceBlobVtbl<CSdpConferenceBlob>, &IID_ITConferenceBlob, &LIBID_SDPBLBLib>    CTConferenceBlob;
typedef IDispatchImpl<ITSdpVtbl<CSdpConferenceBlob>, &IID_ITSdp, &LIBID_SDPBLBLib>    CTSdp;
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CSdpConferenceBlob::GetIDsOfNames
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP CSdpConferenceBlob::GetIDsOfNames(REFIID riid,
                                      LPOLESTR* rgszNames, 
                                      UINT cNames, 
                                      LCID lcid, 
                                      DISPID* rgdispid
                                      ) 
{ 
    HRESULT hr = DISP_E_UNKNOWNNAME;



    //
    // See if the requsted method belongs to the default interface
    //

    hr = CTConferenceBlob::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        rgdispid[0] |= IDISPCONFBLOB;
        return hr;
    }

    
    //
    // If not, then try the ITSdp base class
    //

    hr = CTSdp::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        rgdispid[0] |= IDISPSDP;
        return hr;
    }

    //
    // If not, then try the ITConnection base class
    //

    hr = ITConnectionImpl::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        rgdispid[0] |= IDISPCONNECTION;
        return hr;
    }

    //
    // If not, then try the ITAttributeList base class
    //

    hr = ITAttributeListImpl::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        rgdispid[0] |= IDISPATTRLIST;
        return hr;
    }


    return hr; 
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CSdpConferenceBlob::Invoke
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP CSdpConferenceBlob::Invoke(DISPID dispidMember, 
                              REFIID riid, 
                              LCID lcid, 
                              WORD wFlags, 
                              DISPPARAMS* pdispparams, 
                              VARIANT* pvarResult, 
                              EXCEPINFO* pexcepinfo, 
                              UINT* puArgErr
                             )
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    DWORD   dwInterface = (dispidMember & INTERFACEMASK);
   
   
    //
    // Call invoke for the required interface
    //

    switch (dwInterface)
    {
        case IDISPCONFBLOB:
        {
            hr = CTConferenceBlob::Invoke(dispidMember, 
                                    riid, 
                                    lcid, 
                                    wFlags, 
                                    pdispparams,
                                    pvarResult, 
                                    pexcepinfo, 
                                    puArgErr
                                   );
        
            break;
        }

        case IDISPSDP:
        {
            hr = CTSdp::Invoke(dispidMember, 
                                        riid, 
                                        lcid, 
                                        wFlags, 
                                        pdispparams,
                                        pvarResult, 
                                        pexcepinfo, 
                                        puArgErr
                                       );

            break;
        }

        case IDISPCONNECTION:
        {
            hr = ITConnectionImpl::Invoke(dispidMember, 
                                        riid, 
                                        lcid, 
                                        wFlags, 
                                        pdispparams,
                                        pvarResult, 
                                        pexcepinfo, 
                                        puArgErr
                                       );

            break;
        }

        case IDISPATTRLIST:
        {
            hr = ITAttributeListImpl::Invoke(dispidMember, 
                                        riid, 
                                        lcid, 
                                        wFlags, 
                                        pdispparams,
                                        pvarResult, 
                                        pexcepinfo, 
                                        puArgErr
                                       );

            break;
        }

    } // end switch (dwInterface)


    return hr;
}

BLOB_CHARACTER_SET CSdpConferenceBlob::GetBlobCharacterSet(
    IN  BSTR    bstrBlob
    )
{
    BLOB_CHARACTER_SET CharSet = BCS_ASCII;
    const WCHAR szCharacterSet[] = L"a=charset:";

    WCHAR* szCharacterSetAttribute = wcsstr( bstrBlob, szCharacterSet);

    if( szCharacterSetAttribute == NULL)
    {
        //We don't have the  attribute
        //We consider, for backward compability the default ASCII

        return CharSet;
    }

    // We have an attribute entry
    szCharacterSetAttribute += wcslen( szCharacterSet );
    if( wcsstr( szCharacterSetAttribute, L"unicode-1-1-utf8"))
    {
        CharSet = BCS_UTF8;
    }
    else if (wcsstr( szCharacterSetAttribute, L"unicode-1-1-utf7"))
    {
        CharSet = BCS_UTF7;
    }
    else if (wcsstr( szCharacterSetAttribute, L"ascii"))
    {
        CharSet = BCS_ASCII;
    }

    return CharSet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\sdpblob.h ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    sdpblob.h

Abstract:
    Declaration of the CSdpConferenceBlob

Author:

*/

#ifndef __SDPCONFERENCEBLOB_H_
#define __SDPCONFERENCEBLOB_H_

#include <atlctl.h>

#include "resource.h"       // main symbols
#include "blbcoen.h"
#include "blbmeco.h"
#include "blbtico.h"
#include "blbsdp.h"
#include "blbconn.h"
#include "blbatt.h"
#include "blbmedia.h"
#include "blbtime.h"
#include "rend.h"
#include "rendp.h"
#include "ObjectSafeImpl.h"


/////////////////////////////////////////////////////////////////////////////
// CSdpConferenceBlob
template <class T>
class  ITConferenceBlobVtbl : public ITConferenceBlob
{
};

template <class T>
class  ITSdpVtbl : public ITSdp
{
};

class ATL_NO_VTABLE CSdpConferenceBlob :
    public CComObjectRootEx<CComObjectThreadModel>,
    public CComCoClass<CSdpConferenceBlob, &CLSID_SdpConferenceBlob>,
    public IDispatchImpl<ITConferenceBlobVtbl<CSdpConferenceBlob>, &IID_ITConferenceBlob, &LIBID_SDPBLBLib>,
    public IDispatchImpl<ITSdpVtbl<CSdpConferenceBlob>, &IID_ITSdp, &LIBID_SDPBLBLib>,
    public ITConnectionImpl,
    public ITAttributeListImpl,
    public ITConfBlobPrivate,
    public SDP_BLOB,
    public CObjectSafeImpl
{
public:

    inline CSdpConferenceBlob();

    inline HRESULT FinalConstruct();

    inline ~CSdpConferenceBlob();

public:
    STDMETHOD(get_TimeCollection)(/*[out, retval]*/ ITTimeCollection * *ppTimeCollection);
    STDMETHOD(get_MediaCollection)(/*[out, retval]*/ ITMediaCollection * *ppMediaCollection);
    STDMETHOD(get_Originator)(/*[out, retval]*/ BSTR *ppOriginator);
    STDMETHOD(put_Originator)(/*[in]*/ BSTR pOriginator);
    STDMETHOD(SetPhoneNumbers)(VARIANT /*SAFEARRAY(BSTR)*/ Numbers, VARIANT /*SAFEARRAY(BSTR)*/ Names);
    STDMETHOD(GetPhoneNumbers)(VARIANT /*SAFEARRAY(BSTR)*/ *pNumbers, VARIANT /*SAFEARRAY(BSTR)*/ *pNames);
    STDMETHOD(SetEmailNames)(VARIANT /*SAFEARRAY(BSTR)*/ Addresses, VARIANT /*SAFEARRAY(BSTR)*/ Names);
    STDMETHOD(GetEmailNames)(VARIANT /*SAFEARRAY(BSTR)*/ *pAddresses, VARIANT /*SAFEARRAY(BSTR)*/ *pNames);
    STDMETHOD(get_IsValid)(/*[out, retval]*/ VARIANT_BOOL *pfIsValid);
    STDMETHOD(get_Url)(/*[out, retval]*/ BSTR *ppUrl);
    STDMETHOD(put_Url)(/*[in]*/ BSTR pUrl);
    STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *ppDescription);
    STDMETHOD(put_Description)(/*[in]*/ BSTR pDescription);
    STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *ppName);
    STDMETHOD(put_Name)(/*[in]*/ BSTR pName);
    STDMETHOD(get_MachineAddress)(/*[out, retval]*/ BSTR *ppMachineAddress);
    STDMETHOD(put_MachineAddress)(/*[in]*/ BSTR pMachineAddress);
    STDMETHOD(get_SessionVersion)(/*[out, retval]*/ DOUBLE *pSessionVersion);
    STDMETHOD(put_SessionVersion)(/*[in]*/ DOUBLE SessionVersion);
    STDMETHOD(get_SessionId)(/*[out, retval]*/ DOUBLE *pVal);
    STDMETHOD(get_ProtocolVersion)(/*[out, retval]*/ BYTE *pProtocolVersion);

// ITConferenceBlob
    STDMETHOD(Init)(
        /*[in]*/ BSTR pName,
        /*[in]*/ BLOB_CHARACTER_SET CharacterSet,
        /*[in]*/ BSTR pBlob
        );
    STDMETHOD(get_IsModified)(/*[out, retval]*/ VARIANT_BOOL *pfIsModified);
    STDMETHOD(get_CharacterSet)(/*[out, retval]*/ BLOB_CHARACTER_SET *pCharacterSet);
    STDMETHOD(get_ConferenceBlob)(/*[out, retval]*/ BSTR *ppBlob);
    STDMETHOD(SetConferenceBlob)(/*[in]*/ BLOB_CHARACTER_SET CharacterSet, /*[in]*/ BSTR pBlob);

//  ITConfBlobPrivate
    STDMETHOD(GetName)(OUT BSTR *pVal) { return get_Name(pVal); }
    STDMETHOD(SetName)(IN BSTR newVal) { return put_Name(newVal); }

    STDMETHOD(GetOriginator)(OUT BSTR *pVal) { return get_Originator(pVal); }
    STDMETHOD(SetOriginator)(IN BSTR newVal) { return put_Originator(newVal); }

    STDMETHOD(GetUrl)(OUT BSTR *pVal) { return get_Url(pVal); }
    STDMETHOD(SetUrl)(IN BSTR newVal) { return put_Url(newVal); }

    STDMETHOD(GetDescription)(OUT BSTR *pVal) { return get_Description(pVal); }
    STDMETHOD(SetDescription)(IN BSTR newVal) { return put_Description(newVal); }

    STDMETHOD(GetAdvertisingScope)(OUT RND_ADVERTISING_SCOPE *pVal)
    {
        // GetAdvertisingScope catches it, but it doesn't pass up an HRESULT.
        // Therefore we must check here as well.
        if ( IsBadWritePtr(pVal, sizeof(RND_ADVERTISING_SCOPE)) )
        {
            return E_POINTER;
        }

        // ZoltanS bugfix 5-4-98
        *pVal = GetAdvertisingScope(DetermineTtl());
        return S_OK;
    }

    STDMETHOD(SetAdvertisingScope)(IN RND_ADVERTISING_SCOPE newVal)
    { return WriteAdvertisingScope(newVal); }

    STDMETHOD(GetStartTime)(OUT DWORD *pVal)
    { return ((*pVal = DetermineStartTime()) != (DWORD)-1) ? S_OK : E_FAIL; }

    STDMETHOD(SetStartTime)(IN DWORD newVal) { return WriteStartTime(newVal); }

    STDMETHOD(GetStopTime)(OUT DWORD *pVal)
    { return ((*pVal = DetermineStopTime()) != (DWORD)-1) ? S_OK : E_FAIL; }

    STDMETHOD(SetStopTime)(IN DWORD newVal) { return WriteStopTime(newVal); }

DECLARE_REGISTRY_RESOURCEID(IDR_SDPCONFERENCEBLOB)

BEGIN_COM_MAP(CSdpConferenceBlob)
    COM_INTERFACE_ENTRY2(IDispatch, ITConferenceBlob)
    COM_INTERFACE_ENTRY(ITConferenceBlob)
    COM_INTERFACE_ENTRY(ITConfBlobPrivate)
    COM_INTERFACE_ENTRY(ITSdp)
    COM_INTERFACE_ENTRY(ITConnection)
    COM_INTERFACE_ENTRY(ITAttributeList)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_AGGREGATABLE(CSdpConferenceBlob)

    //
    // IDispatch  methods
    //

    STDMETHOD(GetIDsOfNames)(REFIID riid, 
                             LPOLESTR* rgszNames,
                             UINT cNames, 
                             LCID lcid, 
                             DISPID* rgdispid
                            );

    STDMETHOD(Invoke)(DISPID dispidMember, 
                      REFIID riid, 
                      LCID lcid,
                      WORD wFlags, 
                      DISPPARAMS* pdispparams, 
                      VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, 
                      UINT* puArgErr
                      );

protected:

    ITMediaCollection    *m_MediaCollection;
    ITTimeCollection     *m_TimeCollection;

    HRESULT CreateDefault(
        IN  BSTR    Name,
        IN  SDP_CHARACTER_SET CharacterSet
        );

    // generate an sdp blob tstr using the sdp template read from the registry
    TCHAR    *GenerateSdpBlob(
        IN  BSTR    Name,
        IN  SDP_CHARACTER_SET CharacterSet
        );

    HRESULT WriteConferenceBlob(
        IN  SDP_CHARACTER_SET   SdpCharSet,
        IN  BSTR                newVal
        );

    inline HRESULT  WriteName(
        IN  BSTR    newVal
        );

    inline HRESULT  WriteOriginator(
        IN  BSTR    newVal
        );

    inline HRESULT  WriteUrl(
        IN  BSTR    newVal
        );

    inline HRESULT  WriteSessionTitle(
        IN  BSTR    newVal
        );

    // notification from owner with a minimum start time
    // update start time for each of the entries
    HRESULT WriteStartTime(
        IN  DWORD   MinStartTime
        );

    // notification from owner with a minimum stop time
    // update stop time for each of the entries
    HRESULT WriteStopTime(
        IN  DWORD   MaxStopTime
        );

    inline DWORD   DetermineStartTime();

    inline DWORD   DetermineStopTime();

    // notification from owner with a max advertising scope
    // update ttl for each of the connection ttl fields
    HRESULT WriteAdvertisingScope(
        IN  DWORD   MaxAdvertisingScope
        );

    inline BYTE     GetTtl(
        IN  RND_ADVERTISING_SCOPE   AdvertisingScope
        );

    inline RND_ADVERTISING_SCOPE    GetAdvertisingScope(
        IN  BYTE    Ttl
        );

    inline BYTE    DetermineTtl();

    virtual CSdpConferenceBlob *GetConfBlob();

    HRESULT GetBlobCharSet(
        IN  BLOB_CHARACTER_SET *pCharacterSet
        );

    BLOB_CHARACTER_SET GetBlobCharacterSet(
        IN  BSTR    bstrBlob
        );

private :

    // BCS_UTF8 is the last value in the enumeration BLOB_CHARACTER_SET
    static SDP_CHARACTER_SET   const gs_SdpCharSetMapping[BCS_UTF8];

    IUnknown      * m_pFTM;          // pointer to the free threaded marshaler
};



inline
CSdpConferenceBlob::CSdpConferenceBlob(
    )
    : m_MediaCollection(NULL),
      m_TimeCollection(NULL),
      m_pFTM(NULL)
{
    ITConnectionImpl::SuccessInit(*this);
    ITAttributeListImpl::SuccessInit(GetAttributeList());
}


inline HRESULT CSdpConferenceBlob::FinalConstruct()
{
    HRESULT HResult = CoCreateFreeThreadedMarshaler( GetControllingUnknown(),
                                                     & m_pFTM );

    if ( FAILED(HResult) )
    {
        return HResult;
    }

    return S_OK;
}

inline
CSdpConferenceBlob::~CSdpConferenceBlob(
    )
{
    CLock Lock(g_DllLock);

    if ( NULL != m_MediaCollection )
    {
        ((MEDIA_COLLECTION *)m_MediaCollection)->ClearSdpBlobRefs();
        m_MediaCollection->Release();
    }

    if ( NULL != m_TimeCollection )
    {
        ((TIME_COLLECTION *)m_TimeCollection)->ClearSdpBlobRefs();
        m_TimeCollection->Release();
    }

    if ( m_pFTM )
    {
        m_pFTM->Release();
    }
}

inline HRESULT
CSdpConferenceBlob::WriteName(
    IN  BSTR    newVal
    )
{
    CLock Lock(g_DllLock);
    return GetSessionName().SetBstr(newVal);
}


inline HRESULT
CSdpConferenceBlob::WriteOriginator(
    IN  BSTR    newVal
    )
{
    CLock Lock(g_DllLock);
    return GetOrigin().GetUserName().SetBstr(newVal);
}


inline HRESULT
CSdpConferenceBlob::WriteUrl(
    IN  BSTR    newVal
    )
{
    CLock Lock(g_DllLock);
    if (NULL == newVal) // Zoltans removed: || (WCHAR_EOS == newVal[0]) )
    {
        GetUri().Reset();
        return S_OK;
    }

    return GetUri().SetBstr(newVal);
}



inline HRESULT
CSdpConferenceBlob::WriteSessionTitle(
    IN  BSTR    newVal
    )
{
    CLock Lock(g_DllLock);
    if (NULL == newVal) // ZoltanS removed: || (WCHAR_EOS == newVal[0]) )
    {
        GetSessionTitle().Reset();
        return S_OK;
    }

    return GetSessionTitle().SetBstr(newVal);
}


inline DWORD
CSdpConferenceBlob::DetermineStartTime(
    )
{
    CLock Lock(g_DllLock);
    // if there is no time entry, 0 indicates an unbounded start time
    if ( GetTimeList().GetSize() == 0 )
    {
        return 0;
    }

    DWORD   MinStartTime = DWORD(-1);

    // determine the minimum start time value
    for(UINT i = 0; (int)i < GetTimeList().GetSize(); i++ )
    {
        ULONG StartTime;
        HRESULT HResult = ((SDP_TIME *)GetTimeList().GetAt(i))->GetStartTime(StartTime);

        // ignore invalid values and continue
        if ( FAILED(HResult) )
        {
            continue;
        }

        if ( StartTime < MinStartTime )
        {
            MinStartTime = StartTime;
        }
    }

    return MinStartTime;
}


inline DWORD
CSdpConferenceBlob::DetermineStopTime(
    )
{
    CLock Lock(g_DllLock);
    // if there is no time entry, 0 indicates an unbounded stop time
    if ( GetTimeList().GetSize() == 0 )
    {
        return 0;
    }

    DWORD   MaxStopTime = 0;

    // determine the max stop time value
    for(UINT i = 0; (int)i < GetTimeList().GetSize(); i++ )
    {
        ULONG StopTime;
        HRESULT HResult = ((SDP_TIME *)GetTimeList().GetAt(i))->GetStopTime(StopTime);

        // ignore invalid values and continue
        if ( FAILED(HResult) )
        {
            continue;
        }

        if ( StopTime > MaxStopTime )
        {
            MaxStopTime = StopTime;
        }
    }

    return MaxStopTime;
}


inline BYTE
CSdpConferenceBlob::GetTtl(
    IN  RND_ADVERTISING_SCOPE   AdvertisingScope
    )
{
    switch(AdvertisingScope)
    {
    case RAS_LOCAL:
        {
            return 1;
        }
    case RAS_SITE:
        {
            return 15;
        }
    case RAS_REGION:
        {
            return 63;
        }
    case RAS_WORLD:
    default:
        {
            return 127;
        }
    };
}

inline RND_ADVERTISING_SCOPE
CSdpConferenceBlob::GetAdvertisingScope(
    IN  BYTE    Ttl
    )
{
    // check if its local
    if ( 1 >= Ttl )
    {
        return RAS_LOCAL;
    }
    else if ( 15 >= Ttl )
    {
        return RAS_SITE;
    }
    else if ( 63 >= Ttl )
    {
        return RAS_REGION;
    }

    // world
    return RAS_WORLD;
}

inline BYTE
CSdpConferenceBlob::DetermineTtl(
    )
{
    CLock Lock(g_DllLock);

    // there has to be a default connection field, if its not valid, it must be 1 by default
    // since, by default, a value of 1 is not written into the sdp
    BYTE    MaxTtl = (GetConnection().GetTtl().IsValid())? GetConnection().GetTtl().GetValue() : 1;

    // determine the maximum ttl value
    for(UINT i = 0; (int)i < GetMediaList().GetSize(); i++ )
    {
        // get the ttl field
        SDP_BYTE &SdpByte = ((SDP_MEDIA *)GetMediaList().GetAt(i))->GetConnection().GetTtl();

        // if the ttl field of the connection field is valid
        if ( SdpByte.IsValid() )
        {
            BYTE    Ttl = SdpByte.GetValue();
            if ( Ttl > MaxTtl )
            {
                MaxTtl = Ttl;
            }
        }
    }

    return MaxTtl;
}


#endif //__SDPCONFERENCEBLOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\sdpblb.cpp ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    sdpblb.cpp


Abstract:
    Implementation of DLL Exports.

Author:

*/


// Note: Proxy/Stub Information
//        To merge the proxy/stub code into the object DLL, add the file 
//        dlldatax.c to the project.  Make sure precompiled headers 
//        are turned off for this file, and add _MERGE_PROXYSTUB to the 
//        defines for the project.  
//
//        If you are not running WinNT4.0 or Win95 with DCOM, then you
//        need to remove the following define from dlldatax.c
//        #define _WIN32_WINNT 0x0400
//
//        Further, if you are running MIDL without /Oicf switch, you also 
//        need to remove the following define from dlldatax.c.
//        #define USE_STUBLESS_PROXY
//
//        Modify the custom build rule for sdpblb.idl by adding the following 
//        files to the Outputs.
//            sdpblb_p.c
//            dlldata.c
//        To build a separate proxy/stub DLL, 
//        run nmake -f sdpblbps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "sdpblb.h"
#include "blbreg.h"
#include "dlldatax.h"
#include <winsock2.h>

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

#include "sdpblob.h"
#include "blbmedia.h"
#include "blbtime.h"


// Include the ATL
#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_SdpConferenceBlob, CSdpConferenceBlob)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);

        /* Seed the random-number generator with current time so that
        * the numbers will be different every time we run.
        */
        srand( (unsigned)time( NULL ) );

#ifdef SDPDBG
        // Register for trace output.
        SDPLOGREGISTER(_T("sdpblb"));
#endif // SDPDBG
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
#ifdef SDPDBG
        // Deregister for trace output.
        SDPLOGDEREGISTER();
#endif // SDPDBG

        _Module.Term();
        if (SDP_REG_READER::IsWinsockStarted())
        {
            WSACleanup();
        }
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\stdafx.cpp ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    stdafx.cpp

Abstract:
    source file that includes just the standard includes
    stdafx.pch will be the pre-compiled header
    stdafx.obj will contain the pre-compiled type information

Author:

*/

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\sdpblb\stdafx.h ===
/*

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:
    stdafx.h

Abstract:
    include file for standard system include files,
    or project specific include files that are used frequently,
    but are changed infrequently

Author:

*/

#if !defined(AFX_STDAFX_H__C259D79E_C8AB_11D0_8D58_00C04FD91AC0__INCLUDED_)
#define AFX_STDAFX_H__C259D79E_C8AB_11D0_8D58_00C04FD91AC0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include "ObjectSafeImpl.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C259D79E_C8AB_11D0_8D58_00C04FD91AC0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\tapi3\acdgroup.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    ACDGroup.h

Abstract:

    Declaration of the CACDGroup
    
Author:

    Noela - 11/04/97

Notes:

Revision History:

--*/

#ifndef __ACDGROUP_H_
#define __ACDGROUP_H_

#include "resource.h"       // main symbols
#include "ObjectSafeImpl.h"


class CQueue;
class CAgentHandler;

/////////////////////////////////////////////////////////////////////////////
// CACDGroup
class ATL_NO_VTABLE CACDGroup : 
	public CTAPIComObjectRoot<CACDGroup>,
	public IDispatchImpl<ITACDGroup, &IID_ITACDGroup, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
private:
    PWSTR                   m_szName;
    GUID                    m_GroupHandle;
    BOOL                    m_bGroupHasBeenEnumerated;
    QueueArray              m_QueueArray;
    CAgentHandler         * m_pHandler;      
    BOOL                    m_bActive;

public:
	CACDGroup()
    	{
        }
	
	HRESULT UpdateQueueArray();
    GUID getID() {return m_GroupHandle;}
    void SetInactive();
    void SetActive();
    inline BOOL inactive() {return !m_bActive;}
    inline BOOL active()   {return m_bActive;}
    BOOL active(HRESULT * hr);
    CAgentHandler * GetAgentHandler() { return m_pHandler; }

    void FinalRelease();

DECLARE_DEBUG_ADDREF_RELEASE(CACDGroup)
DECLARE_QI()
DECLARE_MARSHALQI(CACDGroup)
DECLARE_TRACELOG_CLASS(CACDGroup)

BEGIN_COM_MAP(CACDGroup)
	COM_INTERFACE_ENTRY(ITACDGroup)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

// ITACDGroup
public:
	STDMETHOD(EnumerateQueues)(IEnumQueue ** ppEnumQueue);
    STDMETHOD(get_Queues)(VARIANT  * pVariant);

	STDMETHOD(get_Name)(BSTR * ppName);
    STDMETHOD(Initialize) 
        (
        PWSTR pszGroupName, 
        GUID GroupHandle,
        CAgentHandler * pHandler
        );



};




/////////////////////////////////////////////////////////////////////////////
// CACDGroupEvent
class ATL_NO_VTABLE CACDGroupEvent : 
    public CTAPIComObjectRoot<CACDGroupEvent>,
    public IDispatchImpl<ITACDGroupEvent, &IID_ITACDGroupEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
protected:
    ACDGROUP_EVENT         m_GroupEvent;
    ITACDGroup  *       m_pGroup;

public:
    CACDGroupEvent()
    {
    }

    static HRESULT FireEvent(
                             CACDGroup* pGroup,
                             ACDGROUP_EVENT Event
                            );

    void FinalRelease();

DECLARE_MARSHALQI(CACDGroupEvent)
DECLARE_TRACELOG_CLASS(CACDGroupEvent)

BEGIN_COM_MAP(CACDGroupEvent)
    COM_INTERFACE_ENTRY(ITACDGroupEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

// ITACDGroupEvent
public:
    STDMETHOD(get_Event)(ACDGROUP_EVENT * pEvent);
    STDMETHOD(get_Group)(ITACDGroup ** ppGroup);
};



#endif //__ACDGROUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\tapi3\acdgroup.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    acdgroup.cpp

Abstract:

    Implementation of the ACD Group object for TAPI 3.0.
    CACDGroup class 

Author:

    noela - 11/04/97

Notes:

    optional-notes

Revision History:

--*/



#include "stdafx.h"

HRESULT
WaitForReply(
             DWORD
            );



/////////////////////////////////////////////////////////////////////////////
// CACDGroup

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CACDGroup
// Method    : Initialize
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CACDGroup::Initialize
        (
        PWSTR pszGroupName, 
        GUID GroupHandle, 
        CAgentHandler * pHandler
        )
{
    HRESULT  hr = S_OK;


	LOG((TL_TRACE, "Initialize - enter" ));

    m_GroupHandle = GroupHandle;               
    
    m_pHandler = pHandler;      

    m_bActive = TRUE;

    // copy the destination address
    if (pszGroupName != NULL)
    {
        m_szName = (PWSTR) ClientAlloc((lstrlenW(pszGroupName) + 1) * sizeof (WCHAR));
        if (m_szName != NULL)
        {
            lstrcpyW(m_szName,pszGroupName);
        }
        else    
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szName failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_INFO, "Initialize - name is NULL" ));
        m_szName = NULL;
    }

    if ( SUCCEEDED(hr) )
    {
        // Fire event here
        CACDGroupEvent::FireEvent(this, ACDGE_NEW_GROUP);
    }


    LOG((TL_TRACE, hr, "Initialize - exit" ));
    return hr;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CACDGroup
// Method    : FinalRelease
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CACDGroup::FinalRelease()
{
    LOG(( TL_TRACE, "FinalRelease ACD Group - %S", m_szName ));
    if ( m_szName != NULL )
    {
         ClientFree(m_szName);
    }

    m_QueueArray.Shutdown();

    LOG((TL_TRACE, "FinalRelease ACD Group - exit"));
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CACDGroup
// Method    : SetActive
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CACDGroup::SetActive()
{
    if ( !m_bActive )
    {
        LOG((TL_INFO, "SetActive  - Set Group To Active"));
        m_bActive = TRUE;

        // Fire event here
        CACDGroupEvent::FireEvent(this, ACDGE_NEW_GROUP);
    }
    else
    {
        LOG((TL_INFO, "SetActive  - Already Active"));
    }

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CACDGroup
// Method    : SetInactive
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CACDGroup::SetInactive()
{
    if ( m_bActive )
    {
        LOG((TL_INFO, "SetInactive  - Set Group To Inactive"));
        m_bActive = FALSE;

        // Fire event here
        CACDGroupEvent::FireEvent(this, ACDGE_GROUP_REMOVED);

    }
    else
    {
        LOG((TL_INFO, "SetInactive  - Already Inactive"));
    }
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CACDGroup
// Method    : active
//             Overloaded function !
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
inline BOOL CACDGroup::active(HRESULT * hr)
{
    if(m_bActive)
    {
        *hr = S_OK;
    }
    else
    {
        LOG((TL_ERROR, "Group inactive" ));
        *hr = E_UNEXPECTED;
    }

    return m_bActive;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CACDGroup
// Method    : UpdateAgentHandlerList
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CACDGroup::UpdateQueueArray()
{
    HRESULT             hr = S_OK;
    DWORD               dwNumberOfEntries;
    LPLINEQUEUELIST     pQueueList = NULL;
    LPLINEQUEUEENTRY    pQueueEntry = NULL;
    PWSTR               pszQueueName;
    DWORD               dwQueueID, dwCount;
    int                 iCount;
    BOOL                foundIt;
    CQueue            * thisQueue = NULL;


    LOG((TL_TRACE, "UpdateQueueArray - enter"));

        
    // Call LineGetQueulist to get list of Queues
    hr = lineGetQueueList(
                     m_pHandler->getHLine(),
                     &m_GroupHandle, 
                     &pQueueList
                     );
    if( SUCCEEDED(hr) )
    {
        dwNumberOfEntries = pQueueList->dwNumEntries;
        
        // Find position of 1st LINEQUEUEENTRY structure in the LINEQUEUELIST
        pQueueEntry = (LPLINEQUEUEENTRY) ((BYTE*)(pQueueList) + pQueueList->dwListOffset);

        // Run though the received list
        for (dwCount = 0; dwCount < dwNumberOfEntries; dwCount++)
        {
            int             iCount;
            
            pszQueueName= (PWSTR)( (PBYTE)pQueueList + pQueueEntry->dwNameOffset);
            dwQueueID = pQueueEntry->dwQueueID;
            LOG((TL_INFO, "UpdateQueueArray - Queue Name   : %S", pszQueueName));
            LOG((TL_INFO, "UpdateQueueArray - Queue Handle : %d", dwQueueID));

            
        
            // Run through the list of Queues & see if we already have this one in the list
            // by comparing IDs
            foundIt = FALSE;

            Lock();

            for (iCount = 0; iCount < m_QueueArray.GetSize(); iCount++)
            {
                thisQueue = dynamic_cast<CComObject<CQueue>*>(m_QueueArray[iCount]);
                
                if (thisQueue != NULL)
                {
                    if ( dwQueueID == thisQueue->getID() )
                    {
                        foundIt = TRUE;
                        break;
                    }
                }
            }
            
            Unlock();
            
            if (foundIt == FALSE)
            {
                // Didn't match so lets add this Queue    
                LOG((TL_INFO, "UpdateQueueArray - create new Queue"));

                CComObject<CQueue> * pQueue;
                hr = CComObject<CQueue>::CreateInstance( &pQueue );
                if( SUCCEEDED(hr) )
                {
                    ITQueue * pITQueue;
                    hr = pQueue->QueryInterface(IID_ITQueue, (void **)&pITQueue);

                    if ( SUCCEEDED(hr) )
                    {
                        // initialize the Queue
                        hr = pQueue->Initialize(dwQueueID, pszQueueName, m_pHandler);
                        if( SUCCEEDED(hr) )
                        {
                            // add to list of CQueues
                            Lock();
                            m_QueueArray.Add(pITQueue);
                            Unlock();
                            pITQueue->Release();

                            LOG((TL_INFO, "UpdateQueueArray - Added Queue to list"));
                        }
                        else
                        {
                            LOG((TL_ERROR, "UpdateQueueArray - Initialize Queue failed" ));
                            delete pQueue;
                        }
                    }
                    else
                    {
                        LOG((TL_ERROR, "UpdateQueueArray - QueryInterface ITQueue failed" ));
                        delete pQueue;
                    }

                }
                else
                {
                    LOG((TL_ERROR, "UpdateQueueArray - Create Queue failed" ));
                }
            }
            else // foundIt == TRUE
            {
                LOG((TL_INFO, "UpdateQueueArray - Queue Object exists for this entry" ));
            }
            
        // next entry in list
        pQueueEntry ++;
        } //for(dwCount = 0......)

    }
    else  // LineGetQueuelist  failed
    {
        LOG((TL_ERROR, "UpdateQueueArray - LineGetQueuelist failed"));
    }




    // finished with memory block so release
    if ( pQueueList != NULL )
        ClientFree( pQueueList );


    LOG((TL_TRACE, hr, "UpdateQueueArray - exit"));
    return hr;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CACDGroup
// Interface : ITACDGroup
// Method    : EnumerateQueues
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CACDGroup::EnumerateQueues(IEnumQueue ** ppEnumQueue)
{
    HRESULT     hr = S_OK;
    
    LOG((TL_TRACE, "EnumerateQueues - enter"));
    
    
    if(!TAPIIsBadWritePtr( ppEnumQueue, sizeof(IEnumQueue *) ) )
    {
        Lock();
        
        UpdateQueueArray();
    
        //
        // create the enumerator
        //
        CComObject< CTapiEnum<IEnumQueue, ITQueue, &IID_IEnumQueue> > * pEnum;
        hr = CComObject< CTapiEnum<IEnumQueue, ITQueue, &IID_IEnumQueue> > ::CreateInstance( &pEnum );
    
        if ( SUCCEEDED(hr) )
        {
            //
            // initialize it with our queue list
            //
            hr = pEnum->Initialize( m_QueueArray );
            
            if ( SUCCEEDED(hr) )
            {
                // return it
                *ppEnumQueue = pEnum;
            }
            else  //  failed to initialize
            {
                LOG((TL_ERROR, "EnumerateQueues - could not initialize enum" ));
                pEnum->Release();
            }
        }
        else  // failed to create enum
        {
            LOG((TL_ERROR, "EnumerateQueues - could not create enum" ));
            hr = E_POINTER;
        }

        Unlock();
    }
    else
    {
        LOG((TL_ERROR, "EnumerateQueues - bad ppEnumQueue pointer"));
        hr = E_POINTER;
    }
    
    LOG((TL_TRACE, hr, "EnumerateQueues - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CACDGroup
// Interface : ITACDGroup
// Method    : get_Queues
//
// Return a collection of queues
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CACDGroup::get_Queues(VARIANT  * pVariant)
{
    HRESULT         hr = S_OK;
    IDispatch     * pDisp = NULL;


    LOG((TL_TRACE, "get_Queues - enter"));

    if (!TAPIIsBadWritePtr( pVariant, sizeof(VARIANT) ) )
    {
        UpdateQueueArray();
    
        //
        // create the collection
        //
        CComObject< CTapiCollection< ITQueue > > * p;
        hr = CComObject< CTapiCollection< ITQueue > >::CreateInstance( &p );
        
        if (SUCCEEDED(hr) )
        {
            // initialize it with our address list
            Lock();
            
            hr = p->Initialize( m_QueueArray );
            
            Unlock();
        
            if ( SUCCEEDED(hr) )
            {
                // get the IDispatch interface
                hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );
            
                if ( SUCCEEDED(hr) )
                {
                    // put it in the variant
                    VariantInit(pVariant);
                    pVariant->vt = VT_DISPATCH;
                    pVariant->pdispVal = pDisp;
                }
                else
                {
                    LOG((TL_ERROR, "get_Queues - could not get IDispatch interface" ));
                    delete p;
                }
            }
            else
            {
                LOG((TL_ERROR, "get_Queues - could not initialize collection" ));
                delete p;
            }
        }
        else
        {
            LOG((TL_ERROR, "get_Queues - could not create collection" ));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_Queues - bad pVariant pointer" ));
        hr = E_POINTER;
    }


    LOG((TL_TRACE, hr, "get_Queues - exit"));
    return hr;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CACDGroup
// Interface : ITACDGroup
// Method    : get_Name
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CACDGroup::get_Name(BSTR * Name)
{
    HRESULT hr = S_OK;

    LOG((TL_TRACE, "Name - enter" ));

    if(!TAPIIsBadWritePtr( Name, sizeof(BSTR) ) )
    {
        if ( active(&hr) )
        {
            Lock();
            
            *Name = SysAllocString(m_szName);
            
            if (*Name == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            
            Unlock();
        }
    }
    else
    {
        LOG((TL_ERROR, "Name - bad Name pointer" )); 
        hr = E_POINTER;
    }

    LOG((TL_TRACE, hr, "Name - exit" ));
    return hr;
}






/////////////////////////////////////////////////////////////////////////////
// CACDGroup



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CACDGroup
// Method    : FireEvent
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CACDGroupEvent::FireEvent(CACDGroup* pACDGroup, ACDGROUP_EVENT Event)
{
    HRESULT                    hr = S_OK;
    CComObject<CACDGroupEvent>    * pEvent;
    IDispatch                * pIDispatch;

    if ( IsBadReadPtr(pACDGroup, sizeof(CACDGroup)) )
    {
        STATICLOG((TL_ERROR, "FireEvent - pACDGroup is an invalid pointer"));

        _ASSERTE(FALSE);
        return E_POINTER;
    }

    //
    // create event
    //
    hr = CComObject<CACDGroupEvent>::CreateInstance( &pEvent );

    if ( SUCCEEDED(hr) )
    {
        //
        // initialize
        //
        pEvent->m_GroupEvent = Event;
        pEvent->m_pGroup= dynamic_cast<ITACDGroup *>(pACDGroup);
        pEvent->m_pGroup->AddRef();
    
        //
        // get idisp interface
        //
        hr = pEvent->QueryInterface( IID_IDispatch, (void **)&pIDispatch );

        if ( SUCCEEDED(hr) )
        {
            //
            // get callback & fire event

            //
            CTAPI *pTapi = (pACDGroup->GetAgentHandler() )->GetTapi();
            pTapi->Event( TE_ACDGROUP, pIDispatch );
        
            // release stuff
            //
            pIDispatch->Release();
            
        }
        else
        {
            STATICLOG((TL_ERROR, "FireEvent - Could not get disp interface of ACDGroupEvent object"));
            delete pEvent;
        }
    }
    else
    {
        STATICLOG((TL_ERROR, "FireEvent - Could not create ACDGroupEvent object"));
    }

   
    STATICLOG((TL_TRACE, hr, "FireEvent - exit"));
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CACDGroup
// Method    : FinalRelease
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CACDGroupEvent::FinalRelease()
{
    m_pGroup->Release();

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CACDGroup
// Interface : ITACDGroupEvent
// Method    : ACDGroup
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CACDGroupEvent::get_Group(ITACDGroup ** ppGroup)
{
    HRESULT hr = S_OK;


    LOG((TL_TRACE, "(Event)ACDGroup - enter" ));

    if(!TAPIIsBadWritePtr( ppGroup, sizeof(ITACDGroup *) ) )
    {
        *ppGroup = m_pGroup;
        m_pGroup->AddRef();
    }
    else
    {
        LOG((TL_ERROR, "(Event)ACDGroup -bad ppGroup pointer"));
        hr = E_POINTER;
    }

        
    LOG((TL_TRACE, hr, "(Event)ACDGroup - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CACDGroup
// Interface : ITACDGroupEvent
// Method    : Event
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CACDGroupEvent::get_Event(ACDGROUP_EVENT * pEvent)
{
    HRESULT hr = S_OK;

    
    LOG((TL_TRACE, "Event - enter" ));
    
    if(!TAPIIsBadWritePtr( pEvent, sizeof(ACDGROUP_EVENT) ) )
    {
        *pEvent = m_GroupEvent;
    }
    else
    {
        LOG((TL_TRACE, "Event - bad pEvent pointer"));
        hr = E_POINTER;
    }
  
    
    LOG((TL_TRACE, hr, "Event - exit"));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\tapi3\address.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    address.cpp

Abstract:

    Implementation of the Address object for TAPI 3.0.


Author:

    mquinton - 4/17/97

Notes:

    optional-notes

Revision History:

--*/

#include "stdafx.h"
#include "uuids.h"
#include "TermEvnt.h"
#include "tapievt.h"

const CLSID CLSID_WAVEMSP = {0x4DDB6D36,0x3BC1,0x11d2,{0x86,0xF2,0x00,0x60,0x08,0xB0,0xE5,0xD2}};

extern HRESULT mapTAPIErrorCode(long lErrorCode);

extern ULONG_PTR GenerateHandleAndAddToHashTable( ULONG_PTR Element);
extern void RemoveHandleFromHashTable(ULONG_PTR dwHandle);
extern CHashTable * gpHandleHashTable;
extern CRetryQueue * gpRetryQueue;
extern HANDLE ghAsyncRetryQueueEvent;


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
// WAITORTIMERCALLBACK
// CAddress::MSPEventCallback(
//                           PVOID pContext,
//                           BOOLEAN b
//                          )
//
// this is the callback that gets called when an msp
// sets it's message event
//
// queues a message to be handled in the callback thread
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
VOID
NTAPI
MSPEventCallback(
                 VOID * pContext,
                 BOOLEAN bFlag
                )
{
    CAddress  * pAddress;
    HRESULT     hr;

    gpHandleHashTable->Lock();
    hr = gpHandleHashTable->Find( (ULONG_PTR)pContext, (ULONG_PTR *)&pAddress );


    if ( SUCCEEDED(hr) )
    {
        LOG((TL_INFO, "MSPEventCallback - Matched handle %p to Address object %p", pContext, pAddress ));

        ASYNCEVENTMSG       msg;

        DWORD dwAddressHandle;
        
        pAddress->AddRef();
    
        gpHandleHashTable->Unlock();

        dwAddressHandle = CreateHandleTableEntry ((ULONG_PTR)pAddress);
        if (0 != dwAddressHandle)
        {
            ZeroMemory( &msg, sizeof(msg) );

            msg.TotalSize = sizeof(msg);
            msg.Msg = PRIVATE_MSPEVENT;
            msg.Param1 = dwAddressHandle;


            //
            // try to queue the event
            //

            BOOL bQueueEventSuccess = gpRetryQueue->QueueEvent(&msg);

            if (bQueueEventSuccess)
            {
                SetEvent(ghAsyncRetryQueueEvent);
            }
            else
            {
    
                //
                // RetryQueue is either no longer accepting entries or 
                // failed to allocate resources it needed.
                //
                // in any case, the event will not be processed. cleanup.
                //

                DeleteHandleTableEntry (dwAddressHandle);

                pAddress->Release();
                pAddress = NULL;

                LOG((TL_ERROR, "MSPEventCallback - Couldn't enqueue event"));
            }
        }
    }
    else
    {
        
        LOG((TL_ERROR, "MSPEventCallback - Couldn't match handle %p to Address object ", pContext));
        
        gpHandleHashTable->Unlock();
    }
    

}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// void HandlePrivateMSPEvent( PASYNCEVENTMSG pParams )
//
// actually handles the msp event.  this is called in the
// asynceventsthread
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
void HandlePrivateMSPEvent( PASYNCEVENTMSG pParams )
{
    CAddress                * pAddress;

    pAddress = (CAddress *) GetHandleTableEntry(pParams->Param1);

    DeleteHandleTableEntry (pParams->Param1);

    if (NULL != pAddress)
    {
        pAddress->MSPEvent();

        //
        // address is addref'd when event
        // is packaged.
        //
        pAddress->Release();
    }
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Class     : CEventMasks
// Method    : SetSubEventFlag
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CEventMasks::SetSubEventFlag(
    DWORD   dwEvent,        // The event 
    DWORD   dwFlag,         // The flag that should be set
    BOOL    bEnable
    )
{
    //
    // Enter critical section
    //
    //m_cs.Lock();

    //
    // Prepare the subevent flag
    //
    DWORD   dwSubEventFlag = 0;
    dwSubEventFlag = (dwFlag == EM_ALLSUBEVENTS ) ? 
            EM_ALLSUBEVENTS : 
            GET_SUBEVENT_FLAG( dwFlag );

    //
    // Set the mask for the events
    //
    switch( dwEvent )
    {
    case EM_ALLEVENTS:
    case TE_TAPIOBJECT:
            if( bEnable )
            {
                // Set the bit
                m_dwTapiObjectMask = m_dwTapiObjectMask | dwSubEventFlag;
            }
            else
            {
                // Reset the bit
                m_dwTapiObjectMask = m_dwTapiObjectMask & ( ~dwSubEventFlag );
            }
            if( dwEvent == TE_TAPIOBJECT)
            {
                break;
            }
    case TE_ADDRESS:
            if( bEnable )
            {
                // Set the bit
                m_dwAddressMask = m_dwAddressMask | dwSubEventFlag;
            }
            else
            {
                // Reset the bit
                m_dwAddressMask = m_dwAddressMask & ( ~dwSubEventFlag );
            }
            if( dwEvent == TE_ADDRESS)
            {
                break;
            }
    case TE_CALLNOTIFICATION:
            if( bEnable )
            {
                // Set the bit
                m_dwCallNotificationMask = m_dwCallNotificationMask | dwSubEventFlag;
            }
            else
            {
                // Reset the bit
                m_dwCallNotificationMask = m_dwCallNotificationMask & ( ~dwSubEventFlag );
            }
            if( dwEvent == TE_CALLNOTIFICATION)
            {
                break;
            }
    case TE_CALLSTATE:
            if( bEnable )
            {
                // Set the bit
                m_dwCallStateMask = m_dwCallStateMask | dwSubEventFlag;
            }
            else
            {
                // Reset the bit
                m_dwCallStateMask = m_dwCallStateMask & ( ~dwSubEventFlag );
            }
            if( dwEvent == TE_CALLSTATE)
            {
                break;
            }
    case TE_CALLMEDIA:
            if( bEnable )
            {
                // Set the bit
                m_dwCallMediaMask = m_dwCallMediaMask | dwSubEventFlag;
            }
            else
            {
                // Reset the bit
                m_dwCallMediaMask = m_dwCallMediaMask & ( ~dwSubEventFlag );
            }
            if( dwEvent == TE_CALLMEDIA)
            {
                break;
            }
    case TE_CALLHUB:
            if( bEnable )
            {
                // Set the bit
                m_dwCallHubMask = m_dwCallHubMask | dwSubEventFlag;
            }
            else
            {
                // Reset the bit
                m_dwCallHubMask = m_dwCallHubMask & ( ~dwSubEventFlag );
            }
            if( dwEvent == TE_CALLHUB)
            {
                break;
            }
    case TE_CALLINFOCHANGE:
            if( bEnable )
            {
                // Set the bit
                m_dwCallInfoChangeMask = m_dwCallInfoChangeMask | dwSubEventFlag;
            }
            else
            {
                // Reset the bit
                m_dwCallInfoChangeMask = m_dwCallInfoChangeMask & ( ~dwSubEventFlag );
            }
            if( dwEvent == TE_CALLINFOCHANGE)
            {
                break;
            }
    case TE_QOSEVENT:
            if( bEnable )
            {
                // Set the bit
                m_dwQOSEventMask = m_dwQOSEventMask | dwSubEventFlag;
            }
            else
            {
                // Reset the bit
                m_dwQOSEventMask = m_dwQOSEventMask & ( ~dwSubEventFlag );
            }
            if( dwEvent == TE_QOSEVENT)
            {
                break;
            }
    case TE_FILETERMINAL:
            if( bEnable )
            {
                // Set the bit
                m_dwFileTerminalMask = m_dwFileTerminalMask | dwSubEventFlag;
            }
            else
            {
                // Reset the bit
                m_dwFileTerminalMask = m_dwFileTerminalMask & ( ~dwSubEventFlag );
            }
            if( dwEvent == TE_FILETERMINAL)
            {
                break;
            }
    case TE_PRIVATE:
            if( bEnable )
            {
                // Set the entire mask
                m_dwPrivateMask = EM_ALLSUBEVENTS;
            }
            else
            {
                // Reset the entire mask
                m_dwPrivateMask = 0;
            }
            if( dwEvent == TE_PRIVATE)
            {
                break;
            }

    case TE_ADDRESSDEVSPECIFIC:
            if( bEnable )
            {
                // Set the bit
                m_dwAddressDevSpecificMask = m_dwAddressDevSpecificMask | dwSubEventFlag;
            }
            else
            {
                // Reset the bit
                m_dwAddressDevSpecificMask = m_dwAddressDevSpecificMask & ( ~dwSubEventFlag );
            }
            if( dwEvent == TE_ADDRESSDEVSPECIFIC)
            {
                break;
            }

    case TE_PHONEDEVSPECIFIC:
            if( bEnable )
            {
                // Set the bit
                m_dwPhoneDevSpecificMask = m_dwPhoneDevSpecificMask | dwSubEventFlag;
            }
            else
            {
                // Reset the bit
                m_dwPhoneDevSpecificMask = m_dwPhoneDevSpecificMask & ( ~dwSubEventFlag );
            }
            if( dwEvent == TE_PHONEDEVSPECIFIC)
            {
                break;
            }

    }

    //
    // Leave critical section
    //
    //m_cs.Unlock();

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Class     : CEventMasks
// Method    : GetSubEventFlag
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CEventMasks::GetSubEventFlag(
    DWORD   dwEvent,        // The event 
    DWORD   dwFlag,         // The flag that should be setted
    BOOL*   pEnable
    )
{
    //
    // Enter critical section
    //
    //m_cs.Lock();

    //
    // Prepare the subevent flag
    //
    DWORD   dwSubEventFlag = 0;
    dwSubEventFlag = GET_SUBEVENT_FLAG( dwFlag );

    //
    // Reset thre flag
    //
    *pEnable = FALSE;

    //
    // Get the flag for the events
    //
    switch( dwEvent )
    {
    case TE_TAPIOBJECT:
        *pEnable = ((m_dwTapiObjectMask & dwSubEventFlag) != 0);
         break;
    case TE_ADDRESS:
        *pEnable = ((m_dwAddressMask & dwSubEventFlag) != 0);
         break;
    case TE_CALLNOTIFICATION:
        *pEnable = ((m_dwCallNotificationMask & dwSubEventFlag) != 0);
         break;
    case TE_CALLSTATE:
        *pEnable = ((m_dwCallStateMask & dwSubEventFlag) != 0);
         break;
    case TE_CALLMEDIA:
        *pEnable = ((m_dwCallMediaMask & dwSubEventFlag) != 0);
         break;
    case TE_CALLHUB:
        *pEnable = ((m_dwCallHubMask & dwSubEventFlag) != 0);
         break;
    case TE_CALLINFOCHANGE:
        *pEnable = ((m_dwCallInfoChangeMask & dwSubEventFlag) != 0);
         break;
    case TE_QOSEVENT:
        *pEnable = ((m_dwQOSEventMask & dwSubEventFlag) != 0);
         break;
    case TE_FILETERMINAL:
        *pEnable = ((m_dwFileTerminalMask & dwSubEventFlag) != 0);
         break;
    case TE_PRIVATE:
        // We don't have subevents for private events
        *pEnable = ( m_dwPrivateMask != 0);
         break;
    case TE_ADDRESSDEVSPECIFIC:
        // We don't have subevents for TE_ADDRESSDEVSPECIFIC events
        *pEnable = ( m_dwAddressDevSpecificMask != 0);
         break;
    case TE_PHONEDEVSPECIFIC:
        // We don't have subevents for TE_PHONEDEVSPECIFIC events
        *pEnable = ( m_dwPhoneDevSpecificMask != 0);
         break;
    }

    //
    // Leave critical section
    //
    //m_cs.Unlock();

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Class     : CEventMasks
// Method    : GetSubEventMask
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

DWORD CEventMasks::GetSubEventMask(
    TAPI_EVENT  TapiEvent
    )
{
    //
    // Enter critical section
    //
    //m_cs.Lock();

    DWORD dwSubEventMask = EM_NOSUBEVENTS;

    switch( TapiEvent )
    {
    case TE_TAPIOBJECT:
        dwSubEventMask = m_dwTapiObjectMask;
        break;
    case TE_ADDRESS:
        dwSubEventMask = m_dwAddressMask;
        break;
    case TE_CALLNOTIFICATION:
        dwSubEventMask = m_dwCallNotificationMask;
        break;
    case TE_CALLSTATE:
        dwSubEventMask = m_dwCallStateMask;
        break;
    case TE_CALLMEDIA:
        dwSubEventMask = m_dwCallMediaMask;
        break;
    case TE_CALLHUB:
        dwSubEventMask = m_dwCallHubMask;
        break;
    case TE_CALLINFOCHANGE:
        dwSubEventMask = m_dwCallInfoChangeMask;
        break;
    case TE_QOSEVENT:
        dwSubEventMask = m_dwQOSEventMask;
        break;
    case TE_FILETERMINAL:
        dwSubEventMask = m_dwFileTerminalMask;
        break;
    case TE_PRIVATE:
        dwSubEventMask = m_dwPrivateMask;
        break;
    case TE_ADDRESSDEVSPECIFIC:
        dwSubEventMask = m_dwAddressDevSpecificMask;
        break;
    case TE_PHONEDEVSPECIFIC:
        dwSubEventMask = m_dwPhoneDevSpecificMask;
        break;
    default:
        dwSubEventMask = EM_NOSUBEVENTS;
        break;
    }

    //
    // Leave critical section
    //
    //m_cs.Unlock();

    return dwSubEventMask;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Class     : CEventMasks
// Method    : IsSubEventValid
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CEventMasks::IsSubEventValid(
    TAPI_EVENT  TapiEvent,
    DWORD       dwSubEvent,
    BOOL        bAcceptAllSubEvents,
    BOOL        bCallLevel
    )
{
    BOOL bValid = TRUE;

    switch( TapiEvent )
    {
    case TE_TAPIOBJECT:
        //
        // Just at the address level
        //
        if( bCallLevel)
        {
            bValid = FALSE;
            break;
        }
        //
        // ALLSUBEVENTS
        //
        if( bAcceptAllSubEvents )
        {
            //
            // We could accept 'ALLSUBEVENTS' flag
            // when we try to set for all subevents
            //
            if(dwSubEvent == EM_ALLSUBEVENTS)
            {
                break;
            }
        }

        //
        // In CTapiObjectEvent::get_Address we accept just
        // these three subevents
        //
        if( (dwSubEvent != TE_ADDRESSCREATE) && 
            (dwSubEvent != TE_ADDRESSREMOVE) &&
            (dwSubEvent != TE_ADDRESSCLOSE) )
        {

            bValid = FALSE;
        }
        break;

    case TE_ADDRESS:
        //
        // Just at the address level
        //
        if( bCallLevel)
        {
            bValid = FALSE;
            break;
        }
        //
        // ALLSUBEVENTS
        //
        if( bAcceptAllSubEvents )
        {
            //
            // We could accept 'ALLSUBEVENTS' flag
            // when we try to set for all subevents
            //
            if(dwSubEvent == EM_ALLSUBEVENTS)
            {
                break;
            }
        }
        if( AE_LASTITEM < dwSubEvent )
        {
            bValid = FALSE;
        }
        break;

    case TE_CALLNOTIFICATION:
        //
        // Just at the address level
        //
        if( bCallLevel )
        {
            bValid = FALSE;
            break;
        }

        //
        // Accept at address and call level
        // ALLSUBEVENTS
        //
        if( bAcceptAllSubEvents )
        {
            //
            // We could accept 'ALLSUBEVENTS' flag
            // when we try to set for all subevents
            //
            if(dwSubEvent == EM_ALLSUBEVENTS)
            {
                break;
            }
        }
        if( CNE_LASTITEM < dwSubEvent )
        {
            bValid = FALSE;
        }
        break;

    case TE_CALLSTATE:
        //
        // Accept at address and call level
        // ALLSUBEVENTS
        //
        if( bAcceptAllSubEvents )
        {
            //
            // We could accept 'ALLSUBEVENTS' flag
            // when we try to set for all subevents
            //
            if(dwSubEvent == EM_ALLSUBEVENTS)
            {
                break;
            }
        }
        if( CS_LASTITEM < dwSubEvent )
        {
            bValid = FALSE;
        }
        break;

    case TE_CALLMEDIA:
        //
        // Accept at address and call level
        // ALLSUBEVENTS
        //
        if( bAcceptAllSubEvents )
        {
            //
            // We could accept 'ALLSUBEVENTS' flag
            // when we try to set for all subevents
            //
            if(dwSubEvent == EM_ALLSUBEVENTS)
            {
                break;
            }
        }
        if( CME_LASTITEM < dwSubEvent )
        {
            bValid = FALSE;
        }
        break;

    case TE_CALLHUB:
        //
        // Accept at address and call level
        // ALLSUBEVENTS
        //
        if( bAcceptAllSubEvents )
        {
            //
            // We could accept 'ALLSUBEVENTS' flag
            // when we try to set for all subevents
            //
            if(dwSubEvent == EM_ALLSUBEVENTS)
            {
                break;
            }
        }
        if( CHE_LASTITEM < dwSubEvent )
        {
            bValid = FALSE;
        }
        break;

    case TE_CALLINFOCHANGE:
        //
        // Accept at address and call level
        // ALLSUBEVENTS
        //
        if( bAcceptAllSubEvents )
        {
            //
            // We could accept 'ALLSUBEVENTS' flag
            // when we try to set for all subevents
            //
            if(dwSubEvent == EM_ALLSUBEVENTS)
            {
                break;
            }
        }
        if( CIC_LASTITEM < dwSubEvent )
        {
            bValid = FALSE;
        }
        break;

    case TE_QOSEVENT:
        //
        // Accept at address and call level
        // ALLSUBEVENTS
        //
        if( bAcceptAllSubEvents )
        {
            //
            // We could accept 'ALLSUBEVENTS' flag
            // when we try to set for all subevents
            //
            if(dwSubEvent == EM_ALLSUBEVENTS)
            {
                break;
            }
        }
        if( QE_LASTITEM < dwSubEvent )
        {
            bValid = FALSE;
        }
        break;

    case TE_FILETERMINAL:
        //
        // Accept at address and call level
        // ALLSUBEVENTS
        //
        if( bAcceptAllSubEvents )
        {
            //
            // We could accept 'ALLSUBEVENTS' flag
            // when we try to set for all subevents
            //
            if(dwSubEvent == EM_ALLSUBEVENTS)
            {
                break;
            }
        }
        if( TMS_LASTITEM < dwSubEvent )
        {
            bValid = FALSE;
        }
        break;

    case TE_PRIVATE:
    case TE_ADDRESSDEVSPECIFIC:
    case TE_PHONEDEVSPECIFIC:
        //
        // Accept at address and call level
        // ALLSUBEVENTS
        //
        if( bAcceptAllSubEvents )
        {
            //
            // We could accept 'ALLSUBEVENTS' flag
            // when we try to set for all subevents
            //
            if(dwSubEvent == EM_ALLSUBEVENTS)
            {
                break;
            }
        }
        else
        {
            // we accept just all subevents because 
            // we don't have subevents
            bValid = TRUE;
            break;
        }

        break;
    default:
        //
        // Invalid event type
        //
        bValid = FALSE;
        break;
    }

    LOG((TL_TRACE, "IsSubEventValid - exit %d", bValid));
    return bValid;
}

HRESULT CEventMasks::CopyEventMasks(
    CEventMasks* pEventMasks
    )
{
    //
    // Enter critical section
    //
    //m_cs.Lock();

    pEventMasks->m_dwTapiObjectMask = m_dwTapiObjectMask;
    pEventMasks->m_dwAddressMask = m_dwAddressMask;
    pEventMasks->m_dwCallNotificationMask = m_dwCallNotificationMask;
    pEventMasks->m_dwCallStateMask = m_dwCallStateMask;
    pEventMasks->m_dwCallMediaMask = m_dwCallMediaMask;
    pEventMasks->m_dwCallHubMask = m_dwCallHubMask;
    pEventMasks->m_dwCallInfoChangeMask = m_dwCallInfoChangeMask;
    pEventMasks->m_dwQOSEventMask = m_dwQOSEventMask;
    pEventMasks->m_dwFileTerminalMask = m_dwFileTerminalMask;
    pEventMasks->m_dwPrivateMask = m_dwPrivateMask;
    pEventMasks->m_dwAddressDevSpecificMask = m_dwAddressDevSpecificMask;
    pEventMasks->m_dwPhoneDevSpecificMask = m_dwPhoneDevSpecificMask;

    //
    // Leave critical section
    //
    //m_cs.Unlock();

    return S_OK;
}

ULONG64 CEventMasks::GetTapiSrvEventMask(
    IN  BOOL    bCallLevel
    )
{
    //
    //  Convert flags to server side 64 bit masks
    //
    ULONG64     ulEventMask = EM_LINE_CALLSTATE |     // TE_CALLSTATE
                              EM_LINE_APPNEWCALL |    // TE_CALLNOTIFICATION 
                              EM_PHONE_CLOSE |        // TE_PHONEEVENT
                              EM_PHONE_STATE |        // TE_PHONEEVENT
                              EM_PHONE_BUTTONMODE |   // TE_PHONEEVENT
                              EM_PHONE_BUTTONSTATE |  // TE_PHONEVENT
                              EM_LINE_APPNEWCALLHUB | // TE_CALLHUB
                              EM_LINE_CALLHUBCLOSE |  // TE_CALLHUB
                              EM_LINE_CALLINFO;       // TE_CALLINFOCHAnGE




    BOOL bEnable = FALSE;

    if( !bCallLevel)
    {
        //
        // These flags will be not read if we
        // ask for call level
        //

        // TE_TAPIOBJECT - TE_ADDRESSCREATE
        // At address level
        GetSubEventFlag(TE_TAPIOBJECT, TE_ADDRESSCREATE, &bEnable);
        if( bEnable )
        {
            ulEventMask |= EM_LINE_CREATE;
        }

        // TE_TAPIOBJECT - TE_ADDRESSREMOVE
        // At address level
        GetSubEventFlag(TE_TAPIOBJECT, TE_ADDRESSREMOVE, &bEnable);
        if( bEnable )
        {
            ulEventMask |= EM_LINE_REMOVE;
        }

        // TE_TAPIOBJECT - TE_ADDRESSCLOSE
        // At address level
        GetSubEventFlag(TE_TAPIOBJECT, TE_ADDRESSCLOSE, &bEnable);
        if( bEnable )
        {
            ulEventMask |= EM_LINE_CLOSE;
        }

        // AE_NEWTERMINAL : ignore private MSP events
        // AE_REMOVETERMINAL : ignore private MSP events

        //
        // We read also the flags for call level,
        // so go ahead.
    }

    // TE_CALLNOTIFICATION - CNE_OWNER
    // At call level
    // We pass EM_LINE_APPNEWCALL for TE_CALLNOTIFICATION everytime because
    // we need this events for internal TAPI3 status
    // See ulEventMask declaration


    // TE_CALLSTATE - All the subevents
    // At call level
    // We always pass EM_LINE_CALLSTATE for TE_CALLSTATE because
    // we need this event for internal TAPI3 status
    // See ulEventMask declaration

    // TE_CALLHUB - CHE_CALLHUBNEW
    // At call level
    // We always pass EM_LINE_APPNEWCALLHUB,  EM_LINE_CALLHUBCLOSE
    // for TE_CALLHUB because
    // we need this event for internal TAPI3 status
    // See ulEventMask declaration

    // TE_CALLINFOCHANGE - All the subevents
    // At call level
    // We always pass EM_LINE_CALLINFO for TE_CALLINFOChANGE because
    // we need this event for internal TAPI3 status
    // See ulEventMask declaration

    // TE_QOSEVENT - All the subevents
    // At call level
    if ( m_dwQOSEventMask )
    {
        ulEventMask |= EM_LINE_QOSINFO;
    }

    if ( m_dwAddressDevSpecificMask )
    {
        ulEventMask |= EM_LINE_DEVSPECIFIC | EM_LINE_DEVSPECIFICEX;
    }

    if ( m_dwPhoneDevSpecificMask )
    {
        ulEventMask |= EM_PHONE_DEVSPECIFIC;
    }


    // TE_FILTETERMIAL it is an MSP stuff
    // TE_PRIVATE it is an SMP stuff
        
    return ulEventMask;
}

DWORD   CEventMasks::GetTapiSrvLineStateMask()
{
    //
    // These flags shuld be read just
    // at address level
    //

    DWORD       dwLineDevStateSubMasks = 0;
    BOOL bEnable = FALSE;

    // TE_ADDRESS - AE_STATE
    // At address level
    GetSubEventFlag(TE_ADDRESS, AE_STATE, &bEnable);
    if( bEnable )
    {
        dwLineDevStateSubMasks |= LINEDEVSTATE_CONNECTED | 
            LINEDEVSTATE_INSERVICE |
            LINEDEVSTATE_OUTOFSERVICE |
            LINEDEVSTATE_MAINTENANCE |
            LINEDEVSTATE_REMOVED |
            LINEDEVSTATE_DISCONNECTED |
            LINEDEVSTATE_LOCK |
            LINEDEVSTATE_MSGWAITON |
            LINEDEVSTATE_MSGWAITOFF ;
    }

    // TE_ADDRESS - AE_CAPSCHANGE
    // At address level
    GetSubEventFlag(TE_ADDRESS, AE_CAPSCHANGE, &bEnable);
    if( bEnable )
    {
        dwLineDevStateSubMasks |= LINEDEVSTATE_CAPSCHANGE;
    }

    // TE_ADDRESS - AE_RINGING
    // At address level
    GetSubEventFlag(TE_ADDRESS, AE_RINGING, &bEnable);
    if( bEnable )
    {
        dwLineDevStateSubMasks |= LINEDEVSTATE_RINGING;
    }

    // TE_ADDRESS - AE_CONFIGCHANGE
    // At address level
    GetSubEventFlag(TE_ADDRESS, AE_CONFIGCHANGE, &bEnable);
    if( bEnable )
    {
        dwLineDevStateSubMasks |= LINEDEVSTATE_CONFIGCHANGE;
    }

    return dwLineDevStateSubMasks;
}

DWORD   CEventMasks::GetTapiSrvAddrStateMask()
{
    //
    // These flags should be read just
    // at address level
    //

    DWORD       dwAddrStateSubMasks = 0;
    BOOL bEnable = FALSE;

    // TE_ADDRESS - AE_CAPSCHANGE
    // Address level
    GetSubEventFlag(TE_ADDRESS, AE_CAPSCHANGE, &bEnable);
    if( bEnable )
    {
        dwAddrStateSubMasks |= LINEADDRESSSTATE_CAPSCHANGE |
            LINEDEVSTATE_CAPSCHANGE;
    }

    // TE_ADDRESS - AE_FORWARD
    // Address level
    GetSubEventFlag(TE_ADDRESS, AE_FORWARD, &bEnable);
    if( bEnable )
    {
        dwAddrStateSubMasks |= LINEADDRESSSTATE_FORWARD;
    }

    return dwAddrStateSubMasks;
}

/*++
SetTapiSrvAddressEventMask

  Set the event mask to the TapiSrv level for an address
  It's called immediatly after we open a line
--*/
HRESULT CEventMasks::SetTapiSrvAddressEventMask(
    IN  HLINE   hLine
    )
{
    LOG((TL_TRACE, "SetTapiSrvAddressEventMask - Enter"));

    HRESULT hr = E_FAIL;

    //
    // Get the TapiSrvEvent masks
    //

    ULONG64 ulEventMasks = 0;
    DWORD   dwLineDevStateSubMasks = 0;
    DWORD   dwAddrStateSubMasks = 0;

    ulEventMasks  = GetTapiSrvEventMask(
        FALSE   // Address level
        );
    LOG((TL_INFO, "GetTapiSrvEventMask returns %x", 
        ulEventMasks));

    dwLineDevStateSubMasks = GetTapiSrvLineStateMask();
    LOG((TL_INFO, "GetTapiSrvLineStateMask returns %x", 
        dwLineDevStateSubMasks));

    dwAddrStateSubMasks = GetTapiSrvAddrStateMask();
    LOG((TL_INFO, "GetTapiSrvAddrStateMask returns %x", 
        dwAddrStateSubMasks));

    hr = tapiSetEventFilterMasks (
        TAPIOBJ_HLINE,
        hLine,
        ulEventMasks
        );
    if (hr == 0)
    {
        hr = tapiSetEventFilterSubMasks (
            TAPIOBJ_HLINE,
            hLine,
            EM_LINE_LINEDEVSTATE,
            dwLineDevStateSubMasks
            );
    }
    if (hr == 0)
    {
        hr = tapiSetEventFilterSubMasks (
            TAPIOBJ_HLINE,
            hLine,
            EM_LINE_ADDRESSSTATE,
            dwAddrStateSubMasks
            );
    }

    if (hr != 0)
    {
        hr = mapTAPIErrorCode(hr);
        LOG((TL_ERROR, 
            "CEventMasks::SetTapiSrvAddressEventMask - failed TapiSrv 0x%08x", hr));

        // Leave critical section
        return hr;
    }

    LOG((TL_TRACE, "SetTapiSrvAddressEventMask - Exit 0x%08x", hr));
    return hr;
}

HRESULT CEventMasks::SetTapiSrvCallEventMask(
    IN  HCALL   hCall
    )
{
    LOG((TL_TRACE, "SetTapiSrvCallEventMask - Enter. call handle[%lx]", hCall));

    HRESULT hr = E_FAIL;
    //
    // Get the TapiSrvEvent masks
    //
    ULONG64 ulEventMasks = 0;

    ulEventMasks  = GetTapiSrvEventMask(
        TRUE   // Call level
        );
    LOG((TL_INFO, "GetTapiSrvEventMask returns %x", 
        ulEventMasks));

    hr = tapiSetEventFilterMasks (
        TAPIOBJ_HCALL,
        hCall,
        ulEventMasks
        );

    if (hr != 0)
    {
        LOG((TL_ERROR, 
            "CEventMasks::SetTapiSrvCallEventMaskr - TapiSrv failed 0x%08x", hr));
        return hr;
    }

    LOG((TL_TRACE, "SetTapiSrvCallEventMask - Exit 0x%08x", hr));
    return hr;
}

//
// ITAddress methods
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// get_State
//
// retries the current ADDRESS_STATE of the address
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT 
STDMETHODCALLTYPE 
CAddress::get_State( 
    ADDRESS_STATE * pAddressState
    )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "get_State enter" ));

    if (TAPIIsBadWritePtr( pAddressState, sizeof( ADDRESS_STATE ) ) )
    {
        LOG((TL_ERROR, "get_State - bad pointer"));

        return E_POINTER;
    }
    
    Lock();
    
    *pAddressState = m_AddressState;

    Unlock();
    
    LOG((TL_TRACE, "get_State exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++    
//
// GetAddressName
//      Copy address name to ppName
//      The application must free the name returned through sysfreestirng.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT 
STDMETHODCALLTYPE 
CAddress::get_AddressName( 
    BSTR * ppName
    )
{
    HRESULT     hr = S_OK;
    
    LOG((TL_TRACE, "get_AddressName enter" ));
    LOG((TL_TRACE, "   ppName --------->%p", ppName ));

    if ( TAPIIsBadWritePtr( ppName, sizeof( BSTR ) ) )
    {
        LOG((TL_ERROR, "get_AddressName - bad pointer"));

        return E_POINTER;
    }
    
    Lock();

    if ( m_dwAddressFlags & ADDRESSFLAG_DEVCAPSCHANGE )
    {
        hr = UpdateLineDevCaps();

        if ( SUCCEEDED(hr) )
        {
            hr = SaveAddressName( m_pDevCaps );
        }

        m_dwAddressFlags &= ~ADDRESSFLAG_DEVCAPSCHANGE;
    }

    *ppName = SysAllocString(
                             m_szAddressName
                            );

    Unlock();
    
    if (NULL == *ppName)
    {
        LOG((TL_ERROR, "get_AddressName exit - return E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    LOG((TL_TRACE, "get_AddressName exit - return %lx", hr ));
    
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_ServiceProviderName
//      Get the name of the service provider that owns this line/
//      address.
//      Note that we don't get the name on startup - we only get
//      it if it is requested.  This shouldn't be used too often.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CAddress::get_ServiceProviderName( 
        BSTR * ppName
        )
{
    HRESULT                     hr = S_OK;
    LPVARSTRING                 pVarString = NULL;
    DWORD                       dwProviderID;
    LPLINEPROVIDERLIST          pProviderList = NULL;

    LOG((TL_TRACE, "get_ServiceProviderName enter" ));

    if (TAPIIsBadWritePtr( ppName, sizeof( BSTR ) ) )
    {
        LOG((TL_ERROR, "get_ServiceProviderName - bad pointer"));

        return E_POINTER;
    }
    
    Lock();
    
    //
    // if we have already determined the sp name,
    // just return it.
    //
    if (NULL != m_szProviderName)
    {
        *ppName = SysAllocString( m_szProviderName );

        Unlock();
        
        if (NULL == *ppName)
        {
            LOG((TL_ERROR, "get_ServiceProviderName - alloc ppName failed" ));

            return E_OUTOFMEMORY;
        }

        LOG((TL_TRACE, "get_ServiceProviderName - exit - return SUCCESS" ));
        
        return S_OK;
    }

    Unlock();


    //
    // get the provider list
    //
    hr = LineGetProviderList(
                             &pProviderList
                            );

    if (S_OK != hr)
    {
        if (NULL != pProviderList )
        {
            ClientFree( pProviderList );
        }

        LOG((TL_ERROR, "get_ServiceProvideName - LineGetProviderList returned %lx", hr ));
        
        return hr;
    }

    LPLINEPROVIDERENTRY     pProvEntry;
    PWSTR                   pszProviderName;
    DWORD                   dwCount;

    hr = S_OK;
    
    pProvEntry = (LPLINEPROVIDERENTRY)( ( (LPBYTE) pProviderList ) + pProviderList->dwProviderListOffset );



    Lock();


    //
    // make sure the name was not set by another thread while we were waiting 
    // for the lock. if it was, do nothing.
    //

    if (NULL == m_szProviderName)
    {
    
        //
        // search through the list for the provider id, until done with all 
        // providers or encounter an error
        //

        for ( dwCount = 0; dwCount < pProviderList->dwNumProviders; dwCount++ )
        {

            if (pProvEntry->dwPermanentProviderID == m_dwProviderID)
            {
                
                //
                // it's a match!  copy the name, if we can.
                //
            
                m_szProviderName = (PWSTR)ClientAlloc( pProvEntry->dwProviderFilenameSize + sizeof(WCHAR) );

                if (NULL == m_szProviderName)
                {

                    LOG((TL_ERROR, "get_ServiceProviderName - alloc m_szProviderName failed" ));

                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    
                    //
                    // save it in the object
                    //

                    memcpy(
                           m_szProviderName,
                           ((LPBYTE)pProviderList) + pProvEntry->dwProviderFilenameOffset,
                           pProvEntry->dwProviderFilenameSize
                          );

                }


                //
                // found a match. m_szProviderName contains the string, or hr 
                // contains the error if failed.
                //

                break;
            }

            pProvEntry++;
        }



        //
        // did we find it?
        //

        if (dwCount == pProviderList->dwNumProviders)
        {


            LOG((TL_ERROR, "get_ServiceProviderName - could not find provider in list" ));

            
            //
            // if we looped through the whole list but did not find a match, hr
            // should still be S_OK
            //
            // assert to protect from future code changes erroneously 
            // overwritingthe error code.
            //

            _ASSERTE(SUCCEEDED(hr));


            //
            // couldn't find the provider.
            //

            hr = TAPI_E_NODRIVER;
        }

    
    } // if (NULL == m_szProviderName)

    
    // 
    // if hr does not contain an error, the m_szProviderName must contain a
    // valid string
    // 

    if (SUCCEEDED(hr))
    {

        _ASSERTE( NULL != m_szProviderName );

        *ppName = SysAllocString( m_szProviderName );

        if (NULL == *ppName)
        {

            //
            // could not allocated string
            //

            LOG((TL_ERROR, 
                "get_ServiceProviderName - failed to allocate memory for provider name string" ));


            hr = E_OUTOFMEMORY;

        }
    }


    Unlock();


    ClientFree( pProviderList );

    
    LOG((TL_TRACE, "get_ServiceProviderName exit - return %lx", hr));

    return hr;
}
        

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_TAPIObject
//
// return the owning tapi object
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CAddress::get_TAPIObject( 
    ITTAPI ** ppTapiObject
    )
{
    HRESULT     hr = S_OK;

    LOG((TL_TRACE, "get_TAPIObject enter" ));

    if (TAPIIsBadWritePtr( ppTapiObject, sizeof( ITTAPI * ) ) )
    {
        LOG((TL_ERROR, "get_TAPIObject - bad pointer"));

        return E_POINTER;
    }
    
    *ppTapiObject = m_pTAPI;

    m_pTAPI->AddRef();

    LOG((TL_TRACE, "get_TAPIObject exit - return %lx", hr ));
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetTapi
//
// private method to get the tapi object
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CTAPI *
CAddress::GetTapi(BOOL bAddRefTapi)
{
    CTAPI * p = NULL;

    Lock();

    //
    // get a pointer to tapi object
    //

    if( m_pTAPI != NULL )
    {
        p = dynamic_cast<CTAPI *>(m_pTAPI);
    }


    //
    // addref tapi if needed and if possible
    //

    if ( (NULL != p) && bAddRefTapi)
    {
        //
        // we have an object and we need to addref it before returing
        //

        p->AddRef();
    }


    Unlock();

    LOG((TL_TRACE, "GetTapi - returning [%p]", p));

    return p;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// InternalCreateCall
//
//      called by a couple of places to create a call.
//
//      pszDestAddress
//          destaddress of the call
//
//      cp
//          current call privilege
//
//      hCall
//          tapi2 call handle
//
//      bExpose
//          is this a hidden call?
//
//      ppCall
//          return call object here
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::InternalCreateCall(
                             PWSTR pszDestAddress,
                             long lAddressType,
                             long lMediaType,
                             CALL_PRIVILEGE cp,
                             BOOL bNeedToNotify,
                             HCALL hCall,
                             BOOL bExpose,
                             CCall ** ppCall
                            )
{
    HRESULT         hr;

    LOG((TL_TRACE, "InternalCreateCall enter" ));
    

    //
    // create & initialize a new call object
    //
    
    CComObject<CCall> * pCall;

    hr = CComObject<CCall>::CreateInstance( &pCall );

    if (NULL == pCall)
    {
        LOG((TL_ERROR, "InternalCreateCall - could not create call instance" ));

        return E_OUTOFMEMORY;
    }


    //
    // initialize the call object. 
    //
    // note: getting address lock while initializing a 
    // call object can lead to deadlocks
    //

    hr = pCall->Initialize(
                           this,
                           pszDestAddress,
                           lAddressType,
                           lMediaType,
                           cp,
                           bNeedToNotify,
                           bExpose,
                           hCall,
                           &m_EventMasks
                          );

    if (S_OK != hr)
    {
        delete pCall;
        LOG((TL_ERROR, "InternalCreateCall failed - Call object failed init - %lx", hr ));

        return hr;
    }


    //
    // serialize call creation with call cleanup (which happens when tapi tells
    // us it is being shutdown).
    //

    Lock();


    //
    // tapi object already signaled shutdown?
    //

    if (m_bTapiSignaledShutdown)
    {
        Unlock();


        //
        // tapi object already notified us of its shutdown and we already did 
        // cleanup. no need to create any new calls
        //

        LOG((TL_ERROR, 
            "InternalCreateCall - tapi object shut down. cannot create call" ));

        //
        // we have no use for the call object
        //

        pCall->Release();

        if (bNeedToNotify)
        {
            //
            // compensate for the extra refcount added if bNeedToNotify is on
            //

            pCall->Release();
        }

        pCall = NULL;


        return TAPI_E_WRONG_STATE;
    }


    if (bExpose)
    {
        ITCallInfo          * pITCallInfo;

        pITCallInfo = dynamic_cast<ITCallInfo *>(pCall);

        //
        // save the call in this address's list
        //
        hr = AddCall( pITCallInfo );
    }


    //
    // the call was created and initialized, it is now safe for call cleanup 
    // logic to kick in if it was waiting for the lock
    //

    Unlock();


    //
    // return it
    //

    *ppCall = pCall;

    LOG((TL_TRACE, "InternalCreateCall exit - return S_OK" ));
    
    return S_OK;
    
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CreateCall
//
//      An application calls this method to create an outgoing call object
//
//  lpszDestAddress
//          DestAddress of the call
//
//  ppCall
//          return call object here
//
//
//  returns
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CAddress::CreateCall( 
    BSTR lpszDestAddress,
    long lAddressType,
    long lMediaType,
    ITBasicCallControl ** ppCall
    )
{
    HRESULT         hr;
    CCall *         pCall;


    LOG((TL_TRACE, "CreateCall enter" ));


    if (TAPIIsBadWritePtr( ppCall, sizeof(ITBasicCallControl *) ) )
    {
        LOG((TL_ERROR, "CreateCall - bad pointer"));

        return E_POINTER;
    }

    if ((lpszDestAddress != NULL) && IsBadStringPtrW( lpszDestAddress, -1 )) // NULL is ok
    {
        LOG((TL_ERROR, "CreateCall - bad string"));

        return E_POINTER;
    }

    //
    // use internal function
    //
    hr = InternalCreateCall(
                            lpszDestAddress,
                            lAddressType,
                            lMediaType,
                            CP_OWNER,
                            FALSE,
                            NULL,
                            TRUE,
                            &pCall
                           );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "CreateCall - InternalCreateCall failed hr = %lx", hr));
        
        return hr;
        
    }

    //
    // put result in out pointer - also
    // increments the ref count
    //
    hr = pCall->QueryInterface(
                               IID_ITBasicCallControl,
                               (void **) ppCall
                              );

    //
    // internalcreatecall has a reference - don't keep it
    //
    pCall->Release();
    
    if (S_OK != hr)
    {
        LOG((TL_ERROR, "CreateCall - saving call failed" ));
        
        return hr;
    }

    LOG((TL_TRACE, "CreateCall exit - return SUCCESS" ));
    
    return S_OK;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Calls
//      return a collection of calls that this address currently
//      owns
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CAddress::get_Calls(
          VARIANT * pVariant
         )
{
    HRESULT         hr;
    IDispatch *     pDisp;

    LOG((TL_TRACE, "get_Calls enter" ));

    if (TAPIIsBadWritePtr( pVariant, sizeof(VARIANT) ) )
    {
        LOG((TL_ERROR, "get_Calls - bad pointer"));

        return E_POINTER;
    }

    
    CComObject< CTapiCollection< ITCallInfo > > * p;
    CComObject< CTapiCollection< ITCallInfo > >::CreateInstance( &p );
    
    if (NULL == p)
    {
        LOG((TL_ERROR, "get_Calls - could not create collection" ));
        
        return E_OUTOFMEMORY;
    }

    Lock();
    
    // initialize
    hr = p->Initialize( m_CallArray );

    Unlock();

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_Calls - could not initialize collection" ));
        
        delete p;
        return hr;
    }

    // get the IDispatch interface
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_Calls - could not get IDispatch interface" ));
        
        delete p;
        return hr;
    }

    // put it in the variant

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDisp;
    

    LOG((TL_TRACE, "get_Calls - exit - return %lx", hr ));
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// EnumerateCalls
//      returns an enumeration of calls the this address currently owns
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
STDMETHODCALLTYPE
CAddress::EnumerateCalls(
    IEnumCall ** ppCallEnum
    )
{
    HRESULT     hr = S_OK;
    
    LOG((TL_TRACE, "EnumerateCalls enter" ));
    LOG((TL_TRACE, "   ppCallEnum----->%p", ppCallEnum ));

    if (TAPIIsBadWritePtr(ppCallEnum, sizeof( ppCallEnum ) ) )
    {
        LOG((TL_ERROR, "EnumerateCalls - bad pointer"));

        return E_POINTER;
    }
    
    //
    // create the enumerator
    //
    CComObject< CTapiEnum< IEnumCall, ITCallInfo, &IID_IEnumCall > > * p;
    hr = CComObject< CTapiEnum< IEnumCall, ITCallInfo, &IID_IEnumCall > >
         ::CreateInstance( &p );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "EnumerateCalls - could not create enum" ));
        
        return hr;
    }


    Lock();
    
    //
    // initialize it with our call list
    //
    p->Initialize( m_CallArray );

    Unlock();

    //
    // return it
    //
    *ppCallEnum = p;

    LOG((TL_TRACE, "EnumerateCalls exit - return %lx", hr ));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// FinalRelease
//      Clean up anything in the address object.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CAddress::FinalRelease()
{
    CTAPI  * pCTapi;

    LOG((TL_TRACE, "FinalRelease[%p] - enter", this));

    Lock();

    // remove from the handle hash table, so any more messages
    // from msp callback events are ignored
    //
    RemoveHandleFromHashTable(m_MSPContext);
    m_MSPContext = NULL;

    pCTapi = GetTapi();
        
    if( NULL == pCTapi )
    {
        LOG((TL_ERROR, "dynamic cast operation failed"));
    }
    else
    {
        pCTapi->InvalidateBuffer( BUFFERTYPE_LINEDEVCAP, (UINT_PTR)this );
        pCTapi->InvalidateBuffer( BUFFERTYPE_ADDRCAP,    (UINT_PTR)this );
    }

    if ( NULL != m_szAddress )
    {
        ClientFree( m_szAddress);
        m_szAddress = NULL;
    }

    if ( NULL != m_szAddressName)
    {
        LOG((TL_INFO, "FinalRelease - m_szAddressName is [%ls]", m_szAddressName ));
        ClientFree( m_szAddressName );
        m_szAddressName = NULL;
    }
    
    if ( NULL != m_szProviderName )
    {
        ClientFree( m_szProviderName );
        m_szProviderName = NULL;
    }
    
    //
    // release calls
    //
    m_CallArray.Shutdown();

    //
    // release terminals
    //
    m_TerminalArray.Shutdown();

    //
    // release addresslines
    //
    PtrList::iterator l;

    for (l = m_AddressLinesPtrList.begin(); l != m_AddressLinesPtrList.end(); l++)
    {
        HRESULT     hr;
        AddressLineStruct * pLine;

        pLine = (AddressLineStruct *)(*l);

        if (pLine == m_pCallHubTrackingLine)
        {
            // this line is used for call hub tracking
            // make sure we don't try and delete this again below
            m_pCallHubTrackingLine = NULL;
        }

        LineClose(
                  &(pLine->t3Line)
                 );

        ClientFree (pLine);
    }

    if (m_pCallHubTrackingLine != NULL)
    {
        LineClose( &(m_pCallHubTrackingLine->t3Line) );
    }
    
    //
    // free the msp
    //
    if ( NULL != m_pMSPAggAddress )
    {
        ITMSPAddress * pMSPAddress = GetMSPAddress();
        
        pMSPAddress->Shutdown();

        pMSPAddress->Release();
        
        m_pMSPAggAddress->Release();

        m_pMSPAggAddress = NULL;
    }


    //
    // unregister the msp wait
    // event in the thread pool
    //
    if ( NULL != m_hWaitEvent )
    {
        LOG((TL_TRACE, "FinalRelease - unregistering callback"));

        UnregisterWaitEx( m_hWaitEvent, INVALID_HANDLE_VALUE);
        m_hWaitEvent = NULL;
    }

    //
    // close the msp event
    //
    if ( NULL != m_hMSPEvent )
    {
        CloseHandle(m_hMSPEvent );
    }

    //
    // release the private object
    //
    if ( NULL != m_pPrivate )
    {
        m_pPrivate->Release();
    }

    m_pTAPI->Release();
    m_pTAPI = NULL;

    Unlock();

    LOG((TL_TRACE, "FinalRelease - exit"));
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CreateWaveMSPObject
//
// special case - creates the wavemsp object
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CreateWaveMSPObject(
                    IUnknown * pUnk,
                    IUnknown ** ppMSPAggAddress
                   )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "CreateWaveMSPObject - enter"));

    hr = CoCreateInstance(
                          CLSID_WAVEMSP,
                          pUnk,
                          CLSCTX_INPROC_SERVER,
                          IID_IUnknown,
                          (void **) ppMSPAggAddress
                         );

    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "CreateWaveMSPObject failed to CoCreate - %lx", hr));

        return hr;
    }

    LOG((TL_TRACE, "CreateWaveMSPObject - exit"));
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CreateWaveInfo
//
// for a wave device address, get the wave device IDs to give
// to the wavemsp
//
// First DWORD =	Command		Second DWORD	Third DWORD
// 0		Set wave IDs for call	WaveIn ID		WaveOut ID
// 1		Start streaming	<ignored>		<ignored>
// 2		Stop streaming	<ignored>		<ignored>
// 3        Set wave IDs for address WaveIn ID      WaveOut ID
// 4        Wave IDS for address not available
// 5        stop streaming because a blocking tapi functions was called
// 6
// 7
// 8        full duplex support
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CreateWaveInfo(
               HLINE hLine,
               DWORD dwAddressID,
               HCALL hCall,
               DWORD dwCallSelect,
               BOOL bFullDuplex,
               LPDWORD pdwIDs
              )
{
    LPVARSTRING         pVarString;
    HRESULT             hr;
    

    if ( bFullDuplex )
    {
        hr = LineGetID(
                       hLine,
                       dwAddressID,
                       hCall,
                       dwCallSelect,
                       &pVarString,
                       L"wave/in/out"
                      );

        if (!SUCCEEDED(hr))
        {
            if (NULL != pVarString)
            {
                ClientFree( pVarString );
            }

            LOG((TL_ERROR, "LineGetID failed for waveinout device - %lx", hr ));

            return hr;
        }
        
        pdwIDs[1] = ((LPDWORD)(pVarString+1))[0];
        pdwIDs[2] = ((LPDWORD)(pVarString+1))[1];
        
        ClientFree( pVarString );
    
        return S_OK;
    }
    
    //
    // get the wave/in id
    //
    hr = LineGetID(
                   hLine,
                   dwAddressID,
                   hCall,
                   dwCallSelect,
                   &pVarString,
                   L"wave/in"
                  );

    if (!SUCCEEDED(hr))
    {
        if (NULL != pVarString)
        {
            ClientFree( pVarString );
        }

        LOG((TL_ERROR, "LineGetID failed for wavein device - %lx", hr ));

        return hr;
    }

    //
    // saveit
    //
    pdwIDs[1] = *((LPDWORD)(pVarString+1));

    ClientFree( pVarString );

    //
    // get the waveout id
    //
    hr = LineGetID(
                   hLine,
                   dwAddressID,
                   hCall,
                   dwCallSelect,
                   &pVarString,
                   L"wave/out"
                  );

    if (!SUCCEEDED(hr))
    {
        if (NULL != pVarString)
        {
            ClientFree( pVarString );
        }

        LOG((TL_ERROR, "LineGetID failed for waveout device - %lx", hr ));
        
        return hr;
    }

    //
    // save it
    //
    pdwIDs[2] = *((LPDWORD)(pVarString+1));
    
    ClientFree( pVarString );
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::InitializeWaveDeviceIDs( HLINE hLine )
{
    DWORD           adwIDs[3];
    HRESULT         hr;


    hr = CreateWaveInfo(
                        hLine,
                        GetAddressID(),
                        NULL,
                        LINECALLSELECT_ADDRESS,
                        HasFullDuplexWaveDevice(),
                        adwIDs
                       );

    if ( SUCCEEDED(hr) )
    {
        adwIDs[0] = 3;
    }
    else
    {
        adwIDs[0] = 4;
    }

    hr = ReceiveTSPData(
                        NULL,
                        (LPBYTE)adwIDs,
                        sizeof(adwIDs)
                       );

    if ( TAPI_VERSION3_0 <= m_dwAPIVersion )
    {
        adwIDs[0] = 8;
        
        if ( m_dwAddressFlags & ADDRESSFLAG_WAVEFULLDUPLEX )
        {
            adwIDs[1] = 1;
        }
        else
        {
            adwIDs[1] = 0;
        }

        hr = ReceiveTSPData(
                            NULL,
                            (LPBYTE)adwIDs,
                            sizeof(adwIDs)
                           );
    }
    
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// SaveAddressName
//
// saves the address name based on the linename in devcaps
//
// called in lock
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::SaveAddressName( LPLINEDEVCAPS pDevCaps )
{
    PWSTR               pAddressName = NULL;
    PWSTR               pAddressString = NULL;
    DWORD               dwAddressStringSize = 0;
    
    //
    // save the line name
    //
    if ( pDevCaps->dwNumAddresses > 1 )
    {
        pAddressString = MyLoadString( IDS_ADDRESS );

        if ( NULL == pAddressString )
        {
            return E_UNEXPECTED;
        }

        dwAddressStringSize = (lstrlenW( pAddressString ) + 1) * sizeof(WCHAR);

        //
        // need to add some room for whitespace
        //
        dwAddressStringSize += 10 * sizeof(WCHAR);
    }
        
    if (0 != pDevCaps->dwLineNameSize)
    {
        DWORD       dwSize;

        dwSize = pDevCaps->dwLineNameSize + sizeof(WCHAR);

        dwSize += dwAddressStringSize;
        
        pAddressName = (PWSTR) ClientAlloc(dwSize);

        if (NULL == pAddressName)
        {
            LOG((TL_ERROR, "Initialize - alloc pAddressName failed" ));

            if ( NULL != pAddressString )
            {
                ClientFree( pAddressString );
            }
            
            return E_OUTOFMEMORY;
        }

        memcpy(
               pAddressName,
               ((LPBYTE)(pDevCaps)) + pDevCaps->dwLineNameOffset,
               pDevCaps->dwLineNameSize
              );

    }
    else
    {
        PWSTR           pTempBuffer;
        DWORD           dwSize = 0;

        pTempBuffer = MyLoadString( IDS_LINE );

        if ( NULL == pTempBuffer )
        {
            LOG((TL_ERROR, "Initialize - couldn't load LINE resource"));
            
            if ( NULL != pAddressString )
            {
                ClientFree( pAddressString );
            }
            
            return E_UNEXPECTED;
        }

        dwSize = (lstrlenW( pTempBuffer ) + 1) * sizeof(WCHAR);

        dwSize += dwAddressStringSize;

        //
        // need some whitespace
        //
        dwSize += 5 * sizeof(WCHAR);


        pAddressName = (PWSTR) ClientAlloc( dwSize );

        if ( NULL == pAddressName )
        {
            ClientFree( pTempBuffer );

            if ( NULL != pAddressString )
            {
                ClientFree( pAddressString );
            }

            return E_OUTOFMEMORY;
        }

        wsprintfW(
                  pAddressName,
                  L"%s %d",
                  pTempBuffer,
                  m_dwDeviceID
                 );

        ClientFree( pTempBuffer );
    }


    //
    // append the address # if there is more than one address on the line
    //
    if (pDevCaps->dwNumAddresses > 1)
    {
        wsprintfW(
                  pAddressName,
                  L"%s - %s %d",
                  pAddressName,
                  pAddressString,
                  m_dwAddressID
                 );
    }

    if ( NULL != pAddressString )
    {
        ClientFree( pAddressString );
    }
    
    if ( NULL != m_szAddressName )
    {
        ClientFree( m_szAddressName);
    }

    m_szAddressName = pAddressName;

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Initialize
//      Init the CAddress object
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::Initialize(
                     ITTAPI * pTapi,
                     HLINEAPP hLineApp,
#ifdef USE_PHONEMSP
                     HPHONEAPP hPhoneApp,
#endif USE_PHONEMSP
                     DWORD dwAPIVersion,
                     DWORD dwDeviceID,
                     DWORD dwAddressID,
                     DWORD dwProviderID,
                     LPLINEDEVCAPS pDevCaps,
                     DWORD dwEventFilterMask
                    )
{
    LONG                lResult;
    HRESULT             hr;
    T3LINE              t3Line;
#ifdef USE_PHONEMSP
    BOOL                bPreferPhoneMSPForProvider =  FALSE;
#endif USE_PHONEMSP


    t3Line.hLine = NULL;
    t3Line.dwAddressLineStructHandle = 0;

    LOG((TL_TRACE, "Initialize[%p] enter", this ));
    LOG((TL_INFO, "   hLineApp ---------->%lx", hLineApp ));
#ifdef USE_PHONEMSP
    LOG((TL_INFO, "   hPhoneApp --------->%lx", hPhoneApp ));
#endif USE_PHONEMSP
    LOG((TL_INFO, "   dwAPIVersion ------>%lx", dwAPIVersion ));
    LOG((TL_INFO, "   dwDeviceID -------->%lx", dwDeviceID ));
    LOG((TL_INFO, "   dwAddressID ------->%lx", dwAddressID ));
    LOG((TL_INFO, "   pDevCaps ---------->%p", pDevCaps ));


    Lock();
            
    //
    // save relevant info
    //
    m_pTAPI                         = pTapi;
    m_dwDeviceID                    = dwDeviceID;
    m_dwAddressID                   = dwAddressID;
    m_dwMediaModesSupported         = pDevCaps->dwMediaModes;
    m_hLineApp                      = hLineApp;
#ifdef USE_PHONEMSP
    m_hPhoneApp                     = hPhoneApp;
#endif USE_PHONEMSP
    m_dwAPIVersion                  = dwAPIVersion;
    m_AddressState                  = AS_INSERVICE;
    m_pCallHubTrackingLine          = NULL;
    m_dwProviderID                  = dwProviderID;
    m_pPrivate                      = NULL;
    m_szAddressName                 = NULL;
    m_pAddressCaps                  = NULL;
    m_pDevCaps                      = NULL;

    
    //
    // Read the event filter mask from TAPIobject
    //
    SetEventFilterMask( dwEventFilterMask );
    
    AddRef();
    
    m_pTAPI->AddRef();
    
    //
    // default  address type
    //
    if (m_dwAPIVersion >= TAPI_VERSION3_0)
    {
        //
        // save msp and address types support
        //
        if ( (pDevCaps->dwDevCapFlags) & LINEDEVCAPFLAGS_MSP )
        {
            m_dwAddressFlags |= ADDRESSFLAG_MSP;
        
            LOG((TL_INFO, "Initialize - has an msp" ));
        }

        if ( (pDevCaps->dwDevCapFlags) & LINEDEVCAPFLAGS_PRIVATEOBJECTS )
        {
            m_dwAddressFlags |= ADDRESSFLAG_PRIVATEOBJECTS;

            LOG((TL_INFO, "Initialize - has private object" ));
        }

        if ( (pDevCaps->dwDevCapFlags) & LINEDEVCAPFLAGS_CALLHUB )
        {
            m_dwAddressFlags |= ADDRESSFLAG_CALLHUB;

            LOG((TL_INFO, "Initialize - supports callhubs" ));
        }

        if ( (pDevCaps->dwDevCapFlags) & LINEDEVCAPFLAGS_CALLHUBTRACKING )
        {
            m_dwAddressFlags |= ADDRESSFLAG_CALLHUBTRACKING;

            LOG((TL_INFO, "Initialize - supports callhub tracking" ));
        }

    }

    //
    // check for wave device if it doesn't
    // have it's own MSP
    //
    // the sp lets tapi know of wave support through the
    // device classes field, as well
    //
    // so, go through the array
    // and look for the appropriate string
    //
    if ( !(m_dwAddressFlags & ADDRESSFLAG_MSP) && (m_dwAPIVersion >= TAPI_VERSION2_0 ) )
    {
        if (0 != pDevCaps->dwDeviceClassesOffset)
        {
            PWSTR       pszDevices;


            //
            // look for full duplex
            // if not full duplex then
            //      look for wave out
            //      look for wave in
            //      if not wave then
            //          look for wave
            // 
            pszDevices = (PWSTR)( ( (PBYTE)pDevCaps ) + pDevCaps->dwDeviceClassesOffset );

            while (NULL != *pszDevices)
            {
                if (0 == lstrcmpiW(pszDevices, L"wave/in/out"))
                {
                    m_dwAddressFlags |= ADDRESSFLAG_WAVEFULLDUPLEX;

                    LOG((TL_INFO, "Initialize - supports full duplex wave"));

                    break;
                }

                pszDevices += (lstrlenW(pszDevices) + 1 );
            }

            if (!HasWaveDevice())
            {
                pszDevices = (PWSTR)( ( (PBYTE)pDevCaps ) + pDevCaps->dwDeviceClassesOffset );
                
                //
                // look for wave out
                //
                while (NULL != *pszDevices)
                {
                    if (0 == lstrcmpiW(pszDevices, L"wave/out"))
                    {
                        m_dwAddressFlags |= ADDRESSFLAG_WAVEOUTDEVICE;

                        LOG((TL_INFO, "Initialize - supports wave/out device" ));

                        break;
                    }

                    pszDevices += (lstrlenW(pszDevices) +1);

                }

                pszDevices = (PWSTR)( ( (PBYTE)pDevCaps ) + pDevCaps->dwDeviceClassesOffset );


                //
                // look for wave in
                //

                while (NULL != *pszDevices)
                {
                    if (0 == lstrcmpiW(pszDevices, L"wave/in"))
                    {
                        m_dwAddressFlags |= ADDRESSFLAG_WAVEINDEVICE;

                        LOG((TL_INFO, "Initialize - supports wave/in device" ));

                        break;
                    }

                    pszDevices += (lstrlenW(pszDevices) +1);

                }

                if (!HasWaveDevice())
                {
                    pszDevices = (PWSTR)( ( (PBYTE)pDevCaps ) + pDevCaps->dwDeviceClassesOffset );

                    //
                    // look for just wave
                    // some sps don't differentiate between wave out and wave in
                    //
                    while (NULL != *pszDevices)
                    {
                        if (0 == lstrcmpiW(pszDevices, L"wave"))
                        {
                            m_dwAddressFlags |= (ADDRESSFLAG_WAVEINDEVICE|ADDRESSFLAG_WAVEOUTDEVICE);

                            LOG((TL_INFO, "Initialize - supports wave device" ));

                            break;
                        }

                        pszDevices += (lstrlenW(pszDevices) + 1);

                    }
                }
            }
        }
    }

    IUnknown * pUnk;

    _InternalQueryInterface(IID_IUnknown, (void**)&pUnk);

#ifdef USE_PHONEMSP
    if ( HasWaveDevice() || ( NULL != GetHPhoneApp() ) )
#else
    if ( HasWaveDevice() )
#endif USE_PHONEMSP
    {
        t3Line.hLine = NULL;
        t3Line.pAddress = this;
        t3Line.dwAddressLineStructHandle = 0;
        
        hr = LineOpen(
                      GetHLineApp(),
                      GetDeviceID(),
                      GetAddressID(),
                      &t3Line,
                      GetAPIVersion(),
                      LINECALLPRIVILEGE_NONE,
                      LINEMEDIAMODE_UNKNOWN,
                      0,
                      NULL,
                      this,
                      GetTapi(),
                      FALSE         // no need to add to line hash table
                     );

        if (S_OK != hr)
        {
            LOG((TL_ERROR, "Initialize failed to open the line"));
            t3Line.hLine = NULL;
            t3Line.dwAddressLineStructHandle = 0;
        }
 
        //
        // Try to set the event filter mask to the TapiSrv level
        //

        hr = m_EventMasks.SetTapiSrvAddressEventMask( 
            t3Line.hLine
            );

        if( FAILED(hr) )
        {
            LOG((TL_ERROR, "SetTapiSrvAddressEventMask failed "));
        }

        m_hLine = t3Line.hLine;
    }
  
#ifdef USE_PHONEMSP     
    {
    HKEY    hKey;
    TCHAR   szProviderKeyName[256];
    DWORD   dwDataType;
    DWORD   dwDataSize = sizeof(DWORD);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     "Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\TAPI3",
                     0,
                     KEY_READ,
                     &hKey
                    ) == ERROR_SUCCESS)
    {
        // form reg name
        wsprintf(szProviderKeyName, ("PreferPhoneMSPForProvider%d"), m_dwProviderID);
        RegQueryValueEx(hKey,
                        szProviderKeyName,
                        0,
                        &dwDataType,
                        (LPBYTE) &bPreferPhoneMSPForProvider,
                        &dwDataSize
                       );
        RegCloseKey(hKey);
    }
    }
#endif USE_PHONEMSP
    
    if ( (m_dwAddressFlags & ADDRESSFLAG_MSP) )
    {
        //
        // CreateMSPObject
        //
        hr = CreateMSPObject(
                             m_dwDeviceID,
                             pUnk,
                             &m_pMSPAggAddress
                            );

        if (S_OK != hr)
        {
            LOG((TL_ERROR, "Initialize - CreateMSPObject return %lx", hr));

            m_dwAddressFlags = m_dwAddressFlags & ~(ADDRESSFLAG_MSP);
        }
    }
    else
    {
#ifdef USE_PHONEMSP
        if(bPreferPhoneMSPForProvider == TRUE)
        {
            // Create the Phone MSP as preference
            //
            if ( NULL != GetHPhoneApp() )
            {
                hr = CreatePhoneDeviceMSP(
                                          pUnk,
                                          t3Line.hLine,
                                          &m_pMSPAggAddress
                                         );
                if (!SUCCEEDED(hr))
                {
                    LOG((TL_ERROR, "Initialize - failed to create phone msp object - %lx", hr));
                }
                    
            }
            //
            // if it's a wave device, create wavemsp object
            //
            else if ( HasWaveDevice() ) 
            {
                
                hr = CreateWaveMSPObject(
                                         pUnk,
                                         &m_pMSPAggAddress
                                        );

                if (!SUCCEEDED(hr))
                {
                    LOG((TL_ERROR, "Initialize - failed to create wave msp object - %lx", hr));

                    m_dwAddressFlags = m_dwAddressFlags & ~(ADDRESSFLAG_WAVEINDEVICE | ADDRESSFLAG_WAVEOUTDEVICE | ADDRESSFLAG_WAVEFULLDUPLEX);
                }
            }
        }
        else
#endif USE_PHONEMSP
        {
            //
            // if it's a wave device, create wavemsp object as preference
            //
            if ( HasWaveDevice() ) 
            {
                
                hr = CreateWaveMSPObject(
                                         pUnk,
                                         &m_pMSPAggAddress
                                        );

                if (!SUCCEEDED(hr))
                {
                    LOG((TL_ERROR, "Initialize - failed to create wave msp object - %lx", hr));

                    m_dwAddressFlags = m_dwAddressFlags & ~(ADDRESSFLAG_WAVEINDEVICE | ADDRESSFLAG_WAVEOUTDEVICE | ADDRESSFLAG_WAVEFULLDUPLEX);
                }
            }
#ifdef USE_PHONEMSP
            // Create the Phone MSP
            //
            else if ( NULL != GetHPhoneApp() )
            {
                hr = CreatePhoneDeviceMSP(
                                          pUnk,
                                          t3Line.hLine,
                                          &m_pMSPAggAddress
                                         );
                if (!SUCCEEDED(hr))
                {
                    LOG((TL_ERROR, "Initialize - failed to create phone msp object - %lx", hr));
                }
                    
            }
#endif USE_PHONEMSP
        }

    }


    pUnk->Release();

    if (NULL != m_pMSPAggAddress)
    {
        m_hMSPEvent = CreateEvent(
                                  NULL,
                                  FALSE,
                                  FALSE,
                                  NULL
                                 );

        if ( NULL == m_hMSPEvent )
        {
            LOG((TL_ERROR, "Initialize - can't create MSP event"));

            m_dwAddressFlags = m_dwAddressFlags & ~(ADDRESSFLAG_AMREL);

            
            //
            // release msp object, so we are not tempted to do Shutdown on it
            // later without having (successfully) initialized it first
            //

            m_pMSPAggAddress->Release();
            m_pMSPAggAddress = NULL;
        }
        else
        {
            // Create a context handle to give the Callback & associate it with this object
            // in the global handle hash table

            m_MSPContext = GenerateHandleAndAddToHashTable((ULONG_PTR)this);
            
            LOG((TL_INFO, "Initialize - Map MSP handle %p to Address object %p", m_MSPContext, this ));

            BOOL fSuccess = RegisterWaitForSingleObject(
                & m_hWaitEvent,
                m_hMSPEvent,
                MSPEventCallback,
                (PVOID)m_MSPContext,
                INFINITE,
                WT_EXECUTEDEFAULT
                );

            if ( ( ! fSuccess ) || ( NULL == m_hWaitEvent ) )
            {
                LOG((TL_ERROR, "Initialize - RegisterWaitForSingleObject failed"));

                m_dwAddressFlags = m_dwAddressFlags & ~(ADDRESSFLAG_AMREL);

                m_pMSPAggAddress->Release();

                m_pMSPAggAddress = NULL;
            }
            else
            {
                ITMSPAddress * pMSPAddress = GetMSPAddress();
                
                hr = pMSPAddress->Initialize(
                                             (MSP_HANDLE)m_hMSPEvent
                                            );

                if ( SUCCEEDED(hr) && HasWaveDevice() )
                {
                    InitializeWaveDeviceIDs( t3Line.hLine );
                }
                
                pMSPAddress->Release();
                
                if (!SUCCEEDED(hr))
                {
                    LOG((TL_ERROR, "Initialize - failed to initialize msp object - %lx", hr));

                    UnregisterWait( m_hWaitEvent );

                    m_hWaitEvent = NULL;

                    m_dwAddressFlags = m_dwAddressFlags & ~(ADDRESSFLAG_AMREL);

                    m_pMSPAggAddress->Release();

                    m_pMSPAggAddress = NULL;
                }
            }
        }
    }

    if ( NULL != t3Line.hLine )
    {
        LineClose( &t3Line );
    }
    
    //
    // get the address caps structure
    //
    hr = UpdateAddressCaps();
    

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "Initialize - LineGetAddressCaps failed - return %lx", hr ));

        Unlock();

        LOG((TL_ERROR, hr, "Initialize - exit LineGetAddressCaps failed"));

        return hr;
    }

    //
    // save the address name
    //
    if (0 != m_pAddressCaps->dwAddressSize)
    {
        m_szAddress = (PWSTR) ClientAlloc (m_pAddressCaps->dwAddressSize + sizeof(WCHAR));

        if (NULL == m_szAddress)
        {
            LOG((TL_ERROR, "Initialize - alloc m_szAddress failed" ));

            Unlock();

            LOG((TL_ERROR, E_OUTOFMEMORY, "Initialize - exit alloc m_szAddress failed"));

            return E_OUTOFMEMORY;
        }
        
        memcpy(
               m_szAddress,
               ((LPBYTE)(m_pAddressCaps)) + m_pAddressCaps->dwAddressOffset,
               m_pAddressCaps->dwAddressSize
              );
        
        LOG((TL_INFO, "CAddress - Address is '%ls'", m_szAddress ));
    }

    hr = SaveAddressName( pDevCaps );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "Initialize - SaveAddressName failed %lx", hr));
        
        ClientFree(m_szAddress);

        /*This is to take care of AV*/
        m_szAddress = NULL;

        Unlock();

        LOG((TL_ERROR, hr, "Initialize - exit SaveAddressName failed"));

        return hr;
    }

    LOG((TL_INFO, "CAddress - m_szAddressName is '%ls'", m_szAddressName ));

    
    LOG((TL_TRACE, "Initialize - exit S_OK" ));

    Unlock();

    return S_OK;
    
    }

#ifdef USE_PHONEMSP
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CreatePhoneDeviceMSP
//      This address has a tapi phone devices, so create
//      the relevant terminals
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT
CAddress::CreatePhoneDeviceMSP(
                               IUnknown * pUnk,
                               HLINE hLine,
                               IUnknown ** ppMSPAggAddress
                              )
{
    HRESULT                         hr = S_OK;
    BOOL                            bSucceeded = FALSE;
    LPPHONECAPS                     pPhoneCaps;
    DWORD                           dwPhoneDevice;
    LPVARSTRING                     pVarString = NULL;
    CComAggObject<CPhoneMSP>      * pPhoneMSP;
    CPhoneMSP                     * pCPhoneMSP;
    ITMSPAddress                  * pMSPAddress;
    
    
    LOG((TL_TRACE, "CreatePhoneTerminal enter" ));

    //
    // get the related phone device id
    //
    hr = LineGetID(
                   hLine,
                   GetAddressID(),
                   NULL,
                   LINECALLSELECT_ADDRESS,
                   &pVarString,
                   L"tapi/phone"
                  );

    //
    // there is no phone device
    //
    if (S_OK != hr)
    {
        if ( NULL != pVarString )
        {
            ClientFree( pVarString );

            /*This is to take care of AV*/
            pVarString = NULL;
        }
        
        return hr;
    }

    
    //
    // get the phone device id at the endo
    // of the var string
    //
    if (pVarString->dwStringSize < sizeof(DWORD))
    {
        LOG((TL_ERROR, "CreatePhoneDeviceMSP - dwStringSize < 4" ));
        LOG((TL_ERROR, "CreatePhoneDeviceMSP exit - return LINEERR_OPERATIONFAILED" ));

        ClientFree( pVarString );

        /*This is to take care of AV*/
        pVarString = NULL;
        
        return mapTAPIErrorCode( LINEERR_OPERATIONFAILED );
    }

    //
    // get the phone device
    //
    dwPhoneDevice = (DWORD) ( * ( ( (PBYTE)pVarString ) + pVarString->dwStringOffset ) );

    ClientFree( pVarString );
    
    /*This is to take care of AV*/
    pVarString = NULL;

    //
    // create the msp object
    //
    pPhoneMSP = new CComAggObject<CPhoneMSP>(pUnk);

    /*NikhilB: This is to take care of an AV*/
    if ( NULL == pPhoneMSP )
    {
        LOG((TL_ERROR, "Could not allocate for phone MSP object" ));
        return E_OUTOFMEMORY;
    }


    //
    // save the aggregated interface in
    // the msppointer
    //
    pPhoneMSP->QueryInterface(
                              IID_IUnknown,
                              (void **)ppMSPAggAddress
                             );

    //
    // get to the real object
    //
    pMSPAddress = GetMSPAddress();
    
    pCPhoneMSP = dynamic_cast<CPhoneMSP *>(pMSPAddress);
    
    //
    // initialize it
    //
    hr = pCPhoneMSP->InitializeTerminals(
        GetHPhoneApp(),
        m_dwAPIVersion,
        dwPhoneDevice,
        this
        );

    pCPhoneMSP->Release();
    
    if ( !SUCCEEDED(hr) )
    {
    }

    LOG((TL_TRACE, "CreatePhoneDeviceMSP exit - return %lx", hr ));
    
    return hr;
}
#endif USE_PHONEMSP

    
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// AddCall
//      Keep track of calls
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CAddress::AddCall(
                  ITCallInfo * pCallInfo
                 )
{
    Lock();
    
    m_CallArray.Add( pCallInfo );

    Unlock();

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// RemoveCall
//
//      remove call from address's list
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CAddress::RemoveCall(
                     ITCallInfo * pCallInfo
                    )
{
    Lock();
    
    m_CallArray.Remove( pCallInfo );

    Unlock();

    return S_OK;
}



// ITMediaSupport methods
HRESULT
STDMETHODCALLTYPE
CAddress::get_MediaTypes(
               long * plMediaTypes
              )
{
    LOG((TL_TRACE, "get_MediaTypes enter" ));
    LOG((TL_TRACE, "   plMediaType ------->%p", plMediaTypes ));

    if (TAPIIsBadWritePtr( plMediaTypes, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "get_MediaTypes - bad pointer"));

        return E_POINTER;
    }
    
    *plMediaTypes = (long)m_dwMediaModesSupported;
    if (*plMediaTypes & LINEMEDIAMODE_INTERACTIVEVOICE)
    {
        *plMediaTypes |= LINEMEDIAMODE_AUTOMATEDVOICE;
    }
        
    *plMediaTypes &= ALLMEDIAMODES;

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// QueryMediaType
//      find out of mediatype is supported
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
STDMETHODCALLTYPE
CAddress::QueryMediaType( 
    long lMediaType,
    VARIANT_BOOL * pbSupport
    )
{
    HRESULT         hr = S_OK;
    DWORD           dwMediaMode;

    LOG((TL_TRACE, "QueryMediaType enter"));
    LOG((TL_TRACE, "   lMediaType--------->%lx", lMediaType));
    LOG((TL_TRACE, "   pbSupport---------->%p", pbSupport));

    if ( TAPIIsBadWritePtr( pbSupport, sizeof(VARIANT_BOOL) ) )
    {
        LOG((TL_ERROR, "QueryMediaType - inval pointer"));

        return E_POINTER;
    }
    
    //
    // get the tapi mediamode that
    // the application is asking about
    //
    if (GetMediaMode(
                     lMediaType,
                     &dwMediaMode
                    ) )
    {
        *pbSupport = VARIANT_TRUE;
    }
    else
    {
        *pbSupport = VARIANT_FALSE;
    }

    LOG((TL_TRACE, "QueryMediaType exit - return success"));

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// AddCallNotification
//
// Adds a callback to notify on call events
//
// dwPrivs
//      IN tapi 2 style Privileges
//
// dwMediaModes
//      IN tapi 2 style mediamodes
//
// pNotification
//      IN the callback to notify
//
// pulRegiser
//      OUT the unique ID of the callback (so they can unregister)
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::AddCallNotification(
                              DWORD dwPrivs,
                              DWORD dwMediaModes,
                              long lInstance,
                              PVOID * ppRegister
                             )
{
    HRESULT                 hr;
    AddressLineStruct *     pAddressLine;

    //
    // create addressline
    //
    pAddressLine = (AddressLineStruct *)ClientAlloc( sizeof( AddressLineStruct ) );

    if (NULL == pAddressLine)
    {
        LOG((TL_ERROR, "AddCallNotification - pAddressLine is NULL"));

        return E_OUTOFMEMORY;
    }

    //
    // initialize
    //
    pAddressLine->dwPrivs               = dwPrivs;
    pAddressLine->t3Line.pAddress       = this;
    pAddressLine->t3Line.dwAddressLineStructHandle = 0;
    pAddressLine->InitializeRefcount(1);
    pAddressLine->lCallbackInstance     = lInstance;
    
    if (ALLMEDIATYPES == dwMediaModes)
    {
        pAddressLine->dwMediaModes      = GetMediaModes();
    }
    else
    {
        pAddressLine->dwMediaModes      = dwMediaModes;

        //
        // if we are listening on any audio mode
        //
        if (pAddressLine->dwMediaModes & AUDIOMEDIAMODES)
        {
            //
            // add in all the audio modes that we support
            //
            pAddressLine->dwMediaModes |= (GetMediaModes() & AUDIOMEDIAMODES);
        }
    }

    //
    // get a line
    //
    hr = LineOpen(
                  GetHLineApp(),
                  GetDeviceID(),
                  GetAddressID(),
                  &(pAddressLine->t3Line),
                  GetAPIVersion(),
                  pAddressLine->dwPrivs,
                  pAddressLine->dwMediaModes,
                  pAddressLine,
                  NULL,
                  (CAddress *)this,
                  GetTapi()
                 );


    if (!SUCCEEDED(hr))
    {
        LOG((TL_ERROR, "AddCallNotification - LineOpen failed %lx", hr));

        ClientFree( pAddressLine );
        
        return hr;
    }

    //
    // Try to set the event filter mask to the TapiSrv level
    //

    hr = m_EventMasks.SetTapiSrvAddressEventMask( 
        pAddressLine->t3Line.hLine
        );

    if( FAILED(hr) )
    {
        LOG((TL_ERROR, "AddCallNotification - SetTapiSrvAddressEventMask failed 0x%08x", hr));

        LineClose( &(pAddressLine->t3Line) );

        ClientFree( pAddressLine );
        
        return hr;
    }

    // Fix for bug 263866 & 250924
    //
    if ( m_dwAddressFlags & ADDRESSFLAG_MSP )
    {
        hr = LineCreateMSPInstance(
                                   pAddressLine->t3Line.hLine,
                                   GetAddressID()
                                  );

        if ( !SUCCEEDED(hr) )
        {
            LOG((TL_ERROR, "AddCallNotification - LineCreateMSPInstance failed %lx", hr));

            LineClose( &(pAddressLine->t3Line) );

            ClientFree( pAddressLine );

            return hr;
        }
    }


    // Tell TAPISRV what status messages we want
    // NOTE : if the lines SP doesn't support TSPI_lineSetStatusMessages
    // TAPISRV will fail this with LINEERR_OPERATIONUNAVAIL
    LineSetStatusMessages( 
                          &(pAddressLine->t3Line),
                          ALL_LINEDEVSTATE_MESSAGES,
                          ALL_LINEADDRESSSTATE_MESSAGES 
                          );


    //
    // ZoltanS fix: enable callhub notifications only if the app
    // hasn't already told us it doesn't want them
    //

    if ( m_fEnableCallHubTrackingOnLineOpen )
    {
        LINECALLHUBTRACKINGINFO         lchti;
        lchti.dwTotalSize = sizeof(lchti);
        lchti.dwCurrentTracking = LINECALLHUBTRACKING_ALLCALLS;

        hr = LineSetCallHubTracking(
                                    &(pAddressLine->t3Line),
                                    &lchti
                                   );

        if ( S_OK != hr )
        {
            LOG((TL_ERROR, "AddCallNotification - LineSetCallHubTracking failed %lx", hr ));

            LineClose( &(pAddressLine->t3Line) );

            ClientFree( pAddressLine );

            return hr;
        }
    }

    if (m_pCallHubTrackingLine)
    {
        MaybeCloseALine( &m_pCallHubTrackingLine );
        m_pCallHubTrackingLine = pAddressLine;
        pAddressLine->AddRef();
    }

    //
    // save the line in the address's list
    //
    hr = AddNotificationLine( pAddressLine );;

    if ( S_OK != hr )
    {
        LOG((TL_ERROR, "AddCallNotification - AddNotificationLine failed %lx", hr ));

        LineClose( &(pAddressLine->t3Line) );

        ClientFree( pAddressLine );

    }
    else
    {
        //
        // fill in pulRegister
        //
        
        *ppRegister = (PVOID) pAddressLine;
    }

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// RemoveCallNotification
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::RemoveCallNotification(
                                 PVOID pRegister
                                )
{
    AddressLineStruct *pLine = (AddressLineStruct *)pRegister;

    MaybeCloseALine( &pLine );

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// FindOrOpenALine
//
//  Attempts to find a line that's already open.  If so, keeps a
//  pointer to it.  If not opens the line.
//
//  dwMediaModes
//      IN tapi 2 style mediamodes
//
//  ppAddressLine
//      OUT addresslinestruct associated with this request
//
//  RETURNS
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT
CAddress::FindOrOpenALine(
                          DWORD dwMediaModes,
                            AddressLineStruct ** ppAddressLine
                         )
{
    HRESULT                 hr = S_OK;

    LOG((TL_TRACE, "FindOrOpenALine - enter" ));

    Lock();

    //
    // if there is already a line,
    // just return it
    //
    if ( m_AddressLinesPtrList.size() > 0 )
    {
        LOG((TL_INFO, "Found a line that is already open" ));

        *ppAddressLine = (AddressLineStruct *)*( m_AddressLinesPtrList.begin() );
        
        (*ppAddressLine)->AddRef();

        LOG((TL_TRACE, "FindOrOpenALine - exit"));

        Unlock();
        
        return S_OK;
    }
        

    //
    // we didn't have an address
    //
    LOG((TL_INFO, "Did not find an already open line"));


    //
    // create a new addressline
    //
    AddressLineStruct * pLine = (AddressLineStruct *)ClientAlloc( sizeof(AddressLineStruct) );

    if (NULL == pLine)
    {
        LOG((TL_ERROR, "FindOrOpenALine - alloc pLine failed" ));

        Unlock();
        
        return E_OUTOFMEMORY;
    }

    //
    // initialize
    //
    pLine->dwMediaModes = dwMediaModes;
    pLine->dwPrivs = LINECALLPRIVILEGE_NONE;
    pLine->t3Line.pAddress = this;
    pLine->t3Line.dwAddressLineStructHandle = 0;
    pLine->InitializeRefcount(1);
    pLine->lCallbackInstance = 0;

    
    LOG((TL_INFO, "FindOrOpenALine - Opening a line" ));

    //
    // open the line
    //
    hr = LineOpen(
                  GetHLineApp(),
                  GetDeviceID(),
                  GetAddressID(),
                  &(pLine->t3Line),
                  GetAPIVersion(),
                  LINECALLPRIVILEGE_NONE,
                  dwMediaModes,
                  pLine,
                  NULL,
                  this,
                  GetTapi()
                 );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "FindOrOpenALine - LineOpen failed %lx", hr ));

        ClientFree( pLine );

        Unlock();
        
        return hr;
    }

    //
    // Try to set the event filter mask to the TapiSrv level
    //

    hr = m_EventMasks.SetTapiSrvAddressEventMask( 
        pLine->t3Line.hLine
        );

    if( FAILED(hr) )
    {
        LOG((TL_ERROR, "FindOrOpenALine - SetTapiSrvAddressEventMask failed 0x%08x", hr));

        LineClose( &(pLine->t3Line) );

        ClientFree( pLine );

        Unlock();
        
        return hr;
    }

    if ( m_dwAddressFlags & ADDRESSFLAG_MSP )
    {
        hr = LineCreateMSPInstance(
                                   pLine->t3Line.hLine,
                                   GetAddressID()
                                  );

        if ( !SUCCEEDED(hr) )
        {
            LOG((TL_ERROR, "FindOrOpenALine - LineCreateMSPInstance failed %lx", hr));

            LineClose( &(pLine->t3Line) );

            ClientFree( pLine );

            Unlock();
            
            return hr;
        }
    }

    // Tell TAPISRV what status messages we want
    // NOTE : if the lines SP doesn't support TSPI_lineSetStatusMessages
    // TAPISRV will fail this with LINEERR_OPERATIONUNAVAIL
    LineSetStatusMessages( 
                          &(pLine->t3Line),
                          ALL_LINEDEVSTATE_MESSAGES,
                          ALL_LINEADDRESSSTATE_MESSAGES 
                          );


    //
    // ZoltanS fix: enable callhub notifications only if the app
    // hasn't already told us it doesn't want them
    //

    if ( m_fEnableCallHubTrackingOnLineOpen )
    {
        LINECALLHUBTRACKINGINFO         lchti;
        lchti.dwTotalSize = sizeof(lchti);
        lchti.dwCurrentTracking = LINECALLHUBTRACKING_ALLCALLS;


        hr = LineSetCallHubTracking(
                                    &(pLine->t3Line),
                                    &lchti
                                   );

        if ( S_OK != hr )
        {
            LOG((TL_ERROR, "FindOrOpenALine - LineSetCallHubTracking failed %lx", hr ));

            LineClose( &(pLine->t3Line) );

            ClientFree( pLine );

            Unlock();
        
            return hr;
        }
    }
    
    //
    // Add this line to our list of open lines. This is independent of
    // the callhub tracking stuff above.
    //

    hr = AddNotificationLine( pLine );

    if ( S_OK != hr )
    {
        LOG((TL_ERROR, "FindOrOpenALine - AddNotificationLine failed %lx", hr ));

        LineClose( &(pLine->t3Line) );

        ClientFree( pLine );
    }
    else
    {
        *ppAddressLine  = pLine;
    }

    LOG((TL_TRACE, "FindOrOpenALine - exit"));

    Unlock();
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// MaybeCloseALine
//      After a call is done, close the line if it's not being
//      used for monitoring.
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::MaybeCloseALine(
                          AddressLineStruct ** ppAddressLine
                         )
{
    HRESULT hr = S_OK;

    LOG((TL_TRACE, "MaybeCloseALine - enter"));


    Lock();

    if (NULL == *ppAddressLine || !IsValidAddressLine(*ppAddressLine))
    {
        Unlock();
        
        return S_OK;
    }

    
    //
    // decrement reference count on the the address line
    //

    DWORD dwAddressLineRefcount = (*ppAddressLine)->Release();
    
    //
    // if ref count is 0, close line
    //
    if ( 0 == dwAddressLineRefcount )
    {

        m_AddressLinesPtrList.remove( (PVOID)*ppAddressLine );


        //
        // clean handle table.
        //

        try
        {

            DWORD dwAddressLineHandle = (*ppAddressLine)->t3Line.dwAddressLineStructHandle;

            DeleteHandleTableEntry(dwAddressLineHandle);

        }
        catch(...)
        {

            LOG((TL_ERROR, 
                "MaybeCloseALine - exception accessing address line's handle" ));

            _ASSERTE(FALSE);
        }


        //
        // attempt to close the line
        //

        LOG((TL_INFO, "MaybeCloseALine - Calling LineClose" ));

        if ( m_dwAddressFlags & ADDRESSFLAG_MSP )
        {
            LineCloseMSPInstance( (*ppAddressLine)->t3Line.hLine );
        }

    
        //
        // release the lock and call lineclose
        //

        Unlock();


        //
        // now that the line was removed from our list of managed lines and all
        // the calls have been notified, we can close the line and free the
        // structure
        //
 
        hr = LineClose(
                       &((*ppAddressLine)->t3Line)
                      );

        ClientFree( *ppAddressLine );

    }
    else
    {
        
        Unlock();


        //
        // otherwise, decrement the dwRefCount count
        //
        LOG((TL_INFO, "MaybeCloseALine - Not calling line close - decrementing number of addresses using line" ));

    }

    *ppAddressLine = NULL;
    
    LOG((TL_TRACE, "MaybeCloseALine - exit"));

   
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// SetCallHubTracking
//
// called by the tapi object to start callhub tracking on this
// address
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::SetCallHubTracking(
                             BOOL bSet
                            )
{
    HRESULT                         hr = S_OK;
    LINECALLHUBTRACKINGINFO         lchti;

        

    Lock();

    //
    // Check if we have to make any change now.
    //

    if ( bSet == m_fEnableCallHubTrackingOnLineOpen )
    {
        //
        // already doing the right thing
        //
        Unlock();
        
        return S_OK;
    }

    //
    // ZoltanS: make sure we don't clobber this setting in other methods
    // (e.g., AddCallNotification or FindOrOpenALine) where the
    // default call notification behavior (true) would otherwise
    // be set.
    //

    m_fEnableCallHubTrackingOnLineOpen = bSet;


    
    //
    // need an hline to call setcallhubtracking
    //

    if ( m_pCallHubTrackingLine == NULL )
    {
        hr = FindOrOpenALine(
                             LINEMEDIAMODE_INTERACTIVEVOICE,
                             &m_pCallHubTrackingLine
                            );

        if ( !SUCCEEDED( hr ) )
        {
            LOG((TL_ERROR, "SCHT - FindOrOpen failed %lx", hr));
            Unlock();
            return hr;
        }
        
        //
        // ZoltanS fix:
        // FindOrOpenALine does callhubtracking for non-sp
        // tracking capable lines, but only if it is opening
        // the line (rather than just finding it in our list.
        // So we still need to do LineSetCallHubTracking below,
        // even for an SPCallHubTrackingAddress.
        //
    }

    //
    // tell the sp to track callhubs
    //
    ZeroMemory(
               &lchti,
               sizeof(lchti)
              );

    lchti.dwTotalSize = sizeof(lchti);
    lchti.dwCurrentTracking = bSet? LINECALLHUBTRACKING_ALLCALLS : 
                                    LINECALLHUBTRACKING_NONE;

    //
    // ZoltanS: Only pass this flag if it applies.
    // Note: LineSetCallHubTracking apparently ignores its first argument
    // if the tracking level is set to LINECALLHUBTRACKING_NONE; otherwise
    // we would also have to FindOrOpenALine if we are unsetting.
    //

    if ( bSet && IsSPCallHubTrackingAddress() )
    {
        lchti.dwCurrentTracking |= LINECALLHUBTRACKING_PROVIDERLEVEL;
    }

    hr = LineSetCallHubTracking(
                                &(m_pCallHubTrackingLine->t3Line),
                                &lchti
                               );

    if ( !SUCCEEDED( hr ) )
    {
        LOG((TL_ERROR, "SCHT - LSCHT failed %lx", hr));

        if ( bSet )
        {
            MaybeCloseALine( &m_pCallHubTrackingLine );

            m_pCallHubTrackingLine = NULL;
        }
        
        Unlock();
        return hr;
    }

    //
    //  Also properly set callhub tracking on lines that were
    //  opened for call notification
    //
    PtrList::iterator l;

    for (l = m_AddressLinesPtrList.begin(); l != m_AddressLinesPtrList.end(); l++)
    {
        AddressLineStruct * pLine;

        pLine = (AddressLineStruct *)(*l);
        if (pLine != m_pCallHubTrackingLine)
        {
            LineSetCallHubTracking(
                &(pLine->t3Line),
                &lchti
                );
        }
    }

    //
    // close it if unsetting
    //
    if ( !bSet )
    {
        MaybeCloseALine( &m_pCallHubTrackingLine );

        m_pCallHubTrackingLine = NULL;
    }

    Unlock();
    
    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// DoesThisAddressSupportCallHubs
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD
CAddress::DoesThisAddressSupportCallHubs(
                                         CCall * pCall
                                        )
{
    HCALL                   hCall;
    LINECALLINFO          * pCallInfo;
    HRESULT                 hr;
    

    //
    // does the sp tell us it supports callhubs?
    //
    if ( IsSPCallHubAddress() )
    {
        return CALLHUBSUPPORT_FULL;
    }

    //
    // have we already determined that it doesn't?
    //
    if ( m_dwAddressFlags & ADDRESSFLAG_NOCALLHUB )
    {
        return CALLHUBSUPPORT_NONE;
    }

    //
    // otherwise - hack - see if the dwrelatedcallid
    // field is non-zero in this call.
    // if so, it does callhubs,
    //
    hCall = pCall->GetHCall();
    
    hr = LineGetCallInfo(
                         hCall,
                         &pCallInfo
                        );

    if ( SUCCEEDED( hr ) )
    {
        if ( 0 != pCallInfo->dwCallID )
        {
            Lock();

            m_dwAddressFlags |= ADDRESSFLAG_CALLHUB;

            Unlock();
            
            ClientFree( pCallInfo );
            
            return CALLHUBSUPPORT_FULL;
        }
        else
        {
            Lock();
            
            m_dwAddressFlags |= ADDRESSFLAG_NOCALLHUB;

            Unlock();

            ClientFree( pCallInfo );

            return CALLHUBSUPPORT_NONE;
        }
    }
                         
    return CALLHUBSUPPORT_UNKNOWN;
}




//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CreateForwardInfoObject
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::CreateForwardInfoObject(
                                  ITForwardInformation ** ppForwardInfo
                                 )
{
    CComObject< CForwardInfo > * p;
    HRESULT                     hr = S_OK;

    LOG((TL_TRACE, "CreatForwardInfoObject - enter"));

    
    if (TAPIIsBadWritePtr(ppForwardInfo , sizeof(ITForwardInformation *) ) )
    {
        LOG((TL_ERROR, "CreateForwardInfoObject - bad pointer"));

        return E_POINTER;
    }

    //
    // create object
    //
    CComObject< CForwardInfo >::CreateInstance( &p );

    if ( NULL == p )
    {
        LOG((TL_ERROR, "Create forward object failed"));
        return E_OUTOFMEMORY;
    }

    //
    // init
    //
    hr = p->Initialize();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "Initialize forward object failed"));
        delete p;
        return hr;
    }

    //
    // return
    //
    hr = p->QueryInterface(
                           IID_ITForwardInformation,
                           (void**)ppForwardInfo
                          );
    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "CreateForwardobject failed - %lx", hr));
        delete p;
        return hr;
    }

    LOG((TL_TRACE, "CreateForwardObject - exit success"));
    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Forward - simple forwarding
//
// will unconditially forward to pDestAddress
//
// if pDestAddress is NULL, will cancel forwarding
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::Forward(
                  ITForwardInformation * pForwardInfo,
                  ITBasicCallControl * pCall
                 )
{
    HRESULT               hr;
    LINEFORWARDLIST     * pList;
    AddressLineStruct   * pLine;
    HCALL                 hCall = NULL;
    CForwardInfo        * pFI;
    CCall               * pCCall;
    LONG                  lCap;

    if ( IsBadReadPtr( pForwardInfo, sizeof( ITForwardInformation * ) ) )
    {
        LOG((TL_ERROR, "Forward - bad pForwardInfo"));
        
        return E_POINTER;
    }
    
    hr = get_AddressCapability( AC_ADDRESSCAPFLAGS, &lCap );

    if ( !SUCCEEDED(hr) )
    {
        return hr;
    }
    
    if ( lCap & LINEADDRCAPFLAGS_FWDCONSULT )
    {
        if ( IsBadReadPtr( pCall, sizeof(ITBasicCallControl *) ) )
        {
            LOG((TL_ERROR, "Forward - Need consultation call"));
            return E_INVALIDARG;
        }

        pCCall = dynamic_cast<CCall *>(pCall);

        if ( NULL == pCCall )
        {
            LOG((TL_ERROR, "Forward - invalid call"));
            return E_POINTER;
        }
    }

    pFI = dynamic_cast<CForwardInfo *>(pForwardInfo);

    if ( NULL == pFI )
    {
        return E_POINTER;
    }

    hr = pFI->CreateForwardList( &pList );

    if ( !SUCCEEDED(hr) )
    {
        return hr;
    }


    //
    // get a line
    //
    hr = FindOrOpenALine(
                         LINEMEDIAMODE_INTERACTIVEVOICE,
                         &pLine
                        );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "Forward - FindOrOpen failed - %lx", hr));

        ClientFree( pList );
        
        return hr;
    }

    //
    // call forward
    //
    //
    DWORD dwRings;

    pForwardInfo->get_NumRingsNoAnswer( (long *)&dwRings );


    hr = LineForward(
                     &(pLine->t3Line),
                     m_dwAddressID,
                     pList,
                     dwRings,
                     &hCall
                    );

    ClientFree( pList );
    
    if ( ((long)hr) < 0 )
    {
        LOG((TL_ERROR, "Forward failed sync - %lx", hr));

        MaybeCloseALine( &pLine );

        return hr;
    }

    hr = WaitForReply( hr );


    if ( lCap & LINEADDRCAPFLAGS_FWDCONSULT )
    {
        pCCall->Lock();

        pCCall->FinishSettingUpCall( hCall );

        pCCall->Unlock();
    }
    else
    {
        HRESULT     hr2;

        if( hCall != NULL )
        {
            hr2 = LineDrop(
                           hCall,
                           NULL,
                           0
                          );

            if ( ((long)hr2) > 0 )
            {
                hr2 = WaitForReply( hr2 );
            }

            LineDeallocateCall( hCall );
        }
    }
    
    MaybeCloseALine( &pLine );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "Forward failed async - %lx", hr));

        return hr;
    }

    LOG((TL_TRACE, "Forward - Exit"));

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress
// Method    : get_CurrentForwardInfo
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_CurrentForwardInfo(
                                 ITForwardInformation ** ppForwardInfo
                                )
{
    HRESULT             hr = S_OK;
    AddressLineStruct * pLine = NULL;
    LINEADDRESSSTATUS * pAddressStatus = NULL;
    LINEFORWARD       * plineForward = NULL;
    DWORD               dwNumEntries = 0;
    DWORD               dwCount = 0;
    PWSTR               pszCallerAddress = NULL;    
    PWSTR               pszDestddress = NULL;    

    LOG((TL_TRACE, "get_CurrentForwardInfo - enter"));
    
    hr = CreateForwardInfoObject(ppForwardInfo);
    if ( SUCCEEDED(hr) )
    {
    
        hr = FindOrOpenALine(
                             LINEMEDIAMODE_INTERACTIVEVOICE,
                             &pLine
                            );
    
        if ( SUCCEEDED(hr) )
        {
            hr = LineGetAddressStatus(
                                      &(pLine->t3Line),
                                      m_dwAddressID,
                                      &pAddressStatus
                                     );
            if ( SUCCEEDED(hr) )
            {
                
                (*ppForwardInfo)->put_NumRingsNoAnswer(pAddressStatus->dwNumRingsNoAnswer);

                //
                // if there is forwarding
                //
                dwNumEntries = pAddressStatus->dwForwardNumEntries;
                
                plineForward = (LINEFORWARD *) (((LPBYTE)pAddressStatus) + pAddressStatus->dwForwardOffset);

                for (dwCount = 0; dwCount != dwNumEntries; dwCount++)
                {
                    if (plineForward->dwCallerAddressOffset > 0) // Caller address is not used for some forward modes
                    {
                        pszCallerAddress = (PWSTR) (((LPBYTE)pAddressStatus) + plineForward->dwCallerAddressOffset);
                    }

                    pszDestddress = (PWSTR) (((LPBYTE)pAddressStatus) + plineForward->dwDestAddressOffset);
                   
                    if ( m_dwAPIVersion >= TAPI_VERSION3_1 )
                    {
                        //
                        // We have negotiated TAPI3.1 or better, so we can get the address types.
                        //

                        ITForwardInformation2 * pForwardInfo2;

                        //
                        // Get the ITForwardInformation2 interface so we can call SetForwardType2
                        //

                        hr = (*ppForwardInfo)->QueryInterface(
                                                              IID_ITForwardInformation2,
                                                              (void **)&pForwardInfo2
                                                             );

                        if ( SUCCEEDED(hr) )
                        {
                            pForwardInfo2->SetForwardType2(plineForward->dwForwardMode,
                                                           pszDestddress,
                                                           plineForward->dwDestAddressType,
                                                           pszCallerAddress,
                                                           plineForward->dwCallerAddressType                                                           
                                                          ); 

                            pForwardInfo2->Release();
                        }
                        else
                        {
                            LOG((TL_ERROR, "get_CurrentForwardInfo - QueryInterface failed - %lx", hr));

                            //
                            // If for some reason the QI fails, break out of the loop
                            //

                            break;
                        }
                    }
                    else
                    {
                        (*ppForwardInfo)->SetForwardType(plineForward->dwForwardMode,                                                         
                                                         pszDestddress,
                                                         pszCallerAddress
                                                        ); 
                    }
                    
                    plineForward++;
                }
            
                
                ClientFree( pAddressStatus );
            }
            else
            {
                LOG((TL_ERROR, "get_CurrentForwardInfo - LineGetAddressStatus failed "));
            }
            
            MaybeCloseALine( &pLine );

        }
        else
        {
            LOG((TL_ERROR, "get_CurrentForwardInfo - FindOrOpen failed"));
        }                      
            
    }
    else
    {
        LOG((TL_ERROR, "get_CurrentForwardInfo - failed to create"));
    }


    LOG((TL_TRACE, hr, "get_CurrentForwardInfo - exit"));
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_DialableAddress(
                              BSTR * ppDialableAddress
                             )
{
    HRESULT             hr = S_OK;

    LOG((TL_TRACE, "get_DialableAddress - Enter"));

    if (TAPIIsBadWritePtr(ppDialableAddress , sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_DialableAddress - bad pointer"));

        return E_POINTER;
    }

    *ppDialableAddress = SysAllocString( m_szAddress );

    if ( ( NULL == *ppDialableAddress ) && ( NULL != m_szAddress ) )
    {
        LOG((TL_TRACE, "SysAllocString Failed" ));
        hr = E_OUTOFMEMORY;
    }
    
    LOG((TL_TRACE, "get_DialableAddress - Exit"));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::put_MessageWaiting(
                             VARIANT_BOOL  fMessageWaiting
                            )
{
    HRESULT             hr = S_OK;
    AddressLineStruct * pLine = NULL;

    
    LOG((TL_TRACE, "put_MessageWaiting - Enter"));

    hr = FindOrOpenALine(
                         LINEMEDIAMODE_INTERACTIVEVOICE,
                         &pLine
                        );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "put_MessageWaiting - findoropen failed %lx", hr));
        return hr;
    }
    
    hr = LineSetLineDevStatus(
                              &(pLine->t3Line),
                              LINEDEVSTATUSFLAGS_MSGWAIT,
                              fMessageWaiting?-1:0
                             );

    if ( ((LONG)hr) < 0 )
    {
        LOG((TL_TRACE, "put_MessageWaiting failed sync - %lx", hr));
        
        MaybeCloseALine( &pLine );

        return hr;
    }

    // Wait for the async reply & map it's tapi2 code T3
    hr = WaitForReply( hr );
    
    MaybeCloseALine( &pLine );
    
    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_TRACE, "put_MessageWaiting failed async - %lx", hr));

        return hr;
    }
    
    LOG((TL_TRACE, "put_MessageWaiting - Exit"));

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_MessageWaiting(
                             VARIANT_BOOL * pfMessageWaiting
                            )
{
    HRESULT               hr = S_OK;
    LINEDEVSTATUS       * pDevStatus;
    AddressLineStruct   * pLine;

    
    LOG((TL_TRACE, "get_MessageWaiting - Enter"));

    if (TAPIIsBadWritePtr(pfMessageWaiting , sizeof(VARIANT_BOOL) ) )
    {
        LOG((TL_ERROR, "get_MessageWaiting - bad pointer"));

        return E_POINTER;
    }

    hr = FindOrOpenALine(
                         LINEMEDIAMODE_INTERACTIVEVOICE,
                         &pLine
                        );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "FindOrOpenALine failed - %lx", hr ));

        return hr;
    }
    
    hr = LineGetLineDevStatus(
                              pLine->t3Line.hLine,
                              &pDevStatus
                             );

    MaybeCloseALine( &pLine );
    
    if ( !SUCCEEDED( hr ) )
    {
        LOG((TL_ERROR, "LineGetDevStatus failed - %lx", hr ));

        return hr;
    }

    if ( pDevStatus->dwDevStatusFlags & LINEDEVSTATUSFLAGS_MSGWAIT )
    {
        *pfMessageWaiting = VARIANT_TRUE;
    }
    else
    {
        *pfMessageWaiting = VARIANT_FALSE;
    }

    ClientFree( pDevStatus );
    
    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "Bad pointer in get_MessageWaiting"));
        return hr;
    }

    LOG((TL_TRACE, "get_MessageWaiting - Exit"));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::put_DoNotDisturb(
                           VARIANT_BOOL  fDoNotDisturb
                          )
{
    HRESULT             hr = S_OK;
    LINEFORWARDLIST     lfl;
    HCALL               hCall = NULL;
    AddressLineStruct * pLine;
    

    //
    // do not disturb is acheived through calling
    // lineforward with NULL for the dest address
    //
    
    LOG((TL_TRACE, "put_DoNotDisturb - Enter"));

    //
    // if we are setting dnd, create a lineforwardlist
    // structure
    //
    if ( fDoNotDisturb )
    {
        ZeroMemory(
                   &lfl,
                   sizeof( LINEFORWARDLIST )
                  );

        lfl.dwTotalSize = sizeof( LINEFORWARDLIST );
        lfl.dwNumEntries = 1;
        //
        // there is only one item, and the dest address
        // is NULL
        //
        lfl.ForwardList[0].dwForwardMode = LINEFORWARDMODE_UNCOND;
    }

    //
    // get a line to use
    //
    hr = FindOrOpenALine(
                         LINEMEDIAMODE_INTERACTIVEVOICE,
                         &pLine
                        );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "put_DoNotDisturb - FindOrOpen failed %lx", hr));

        return hr;
    }

    //
    // call line forward
    // if fDND is false, the LINEFORWARDLIST structure pointer
    // should be NULL.  This clears any fowarding on that
    // line.
    //

    hr = LineForward(
                     &(pLine->t3Line),
                     m_dwAddressID,
                     fDoNotDisturb?&lfl:NULL,
                     0,
                     &hCall
                    );

    if ( ((long)hr) < 0 )
    {
        LOG((TL_ERROR, "put_DND - linefoward failed sync - %lx", hr));
        MaybeCloseALine( &pLine );

        return hr;
    }

    // Wait for the async reply & map it's tapi2 code T3
    hr = WaitForReply( hr );

    if ( NULL != hCall )
    {
        T3CALL t3Call;
        HRESULT hr2;
        
        t3Call.hCall = hCall;
        
        hr2 = LineDrop(
                       t3Call.hCall,
                       NULL,
                       0
                      );

        if ( ((long)hr2) > 0 )
        {
            hr2 = WaitForReply( hr2 ) ;
        }

        hr2 = LineDeallocateCall(
                                 t3Call.hCall
                                );
    }
    
    //
    // we are no longer using the line
    //
    MaybeCloseALine( &pLine );
    
    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "put_DND - linefoware failed async - %lx", hr));
        return hr;
    }

    
    LOG((TL_TRACE, "put_DoNotDisturb - Exit"));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_DoNotDisturb(
                           VARIANT_BOOL * pfDoNotDisturb
                          )
{
    HRESULT             hr = S_OK;
    AddressLineStruct * pLine;
    LINEADDRESSSTATUS * pAddressStatus;
    LINEDEVSTATUS       * pDevStatus = NULL;
    
    //
    // donotdisturb is implemented through
    // line forward.
    // to get_DND, check the forward state
    //
    LOG((TL_TRACE, "get_DoNotDisturb - Enter"));

    if (TAPIIsBadWritePtr(pfDoNotDisturb , sizeof(VARIANT_BOOL) ) )
    {
        LOG((TL_ERROR, "pfDoNotDisturb - bad pointer"));

        return E_POINTER;
    }

    
    hr = FindOrOpenALine(
                         LINEMEDIAMODE_INTERACTIVEVOICE,
                         &pLine
                        );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_DND - FindOrOpen failed %lx", hr));
        return hr;
    }

    hr = LineGetLineDevStatus(
                              pLine->t3Line.hLine,
                              &pDevStatus
                             );

    if ( !SUCCEEDED(hr) )
    {
        MaybeCloseALine( &pLine );
        return hr;
    }

    if ( !(pDevStatus->dwLineFeatures & LINEFEATURE_FORWARD ) )
    {
        LOG((TL_INFO, "get_DND - not supported"));
        MaybeCloseALine( &pLine );

        if(pDevStatus != NULL)
        {
            ClientFree(pDevStatus);
        }

        return TAPI_E_NOTSUPPORTED;
    }

    // finished with pDevStatus
    if(pDevStatus != NULL)
    {
        ClientFree(pDevStatus);
    }
    
    //
    // get the addresss status
    //
    hr = LineGetAddressStatus(
                              &(pLine->t3Line),
                              m_dwAddressID,
                              &pAddressStatus
                             );

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_DND - LineGetAddressStatus failed - %lx", hr));
        MaybeCloseALine( &pLine );
        return hr;
    }

    //
    // initialize to false
    //
    *pfDoNotDisturb = VARIANT_FALSE;

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_DND - bad pointer"));
        return E_OUTOFMEMORY;
    }

    //
    // if there is forwarding
    //
    if ( 0 != pAddressStatus->dwForwardNumEntries )
    {
        LINEFORWARD * pfl;

        pfl = (LINEFORWARD *) (((LPBYTE)pAddressStatus) + pAddressStatus->dwForwardOffset);

        //
        // and the dest address is NULL
        //
        if ( 0 == pfl->dwDestAddressOffset )
        {
            //
            // DND is set
            //
            *pfDoNotDisturb = VARIANT_TRUE;
        }
    }

    MaybeCloseALine( &pLine );
    
    ClientFree( pAddressStatus );
                              
    LOG((TL_TRACE, "get_DoNotDisturb - Exit"));

    return S_OK;
}

//
// itaddresscapabilities
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_AddressCapability(
         ADDRESS_CAPABILITY AddressCap,
         long * plCapability
         )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "get_AddressCapability - Enter"));

    if ( TAPIIsBadWritePtr( plCapability, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_AddressCapability - bad pointer"));

        return E_POINTER;
    }

    Lock();
    
    hr = UpdateAddressCaps();

    if ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "get_AddressCapability - could not get addresscaps"));

        Unlock();
        
        return E_UNEXPECTED;
    }

    switch (AddressCap)
    {
        case AC_LINEID:
            *plCapability = m_dwDeviceID;
            break;
            
        case AC_ADDRESSID:
            *plCapability = m_dwAddressID;
            break;
            
        case AC_ADDRESSTYPES:
        case AC_BEARERMODES:  
        case AC_MONITORDIGITSUPPORT:
        case AC_GENERATEDIGITSUPPORT:
        case AC_GENERATETONEMODES:
        case AC_GENERATETONEMAXNUMFREQ:
        case AC_MONITORTONEMAXNUMFREQ:
        case AC_MONITORTONEMAXNUMENTRIES:
        case AC_DEVCAPFLAGS:
        case AC_ANSWERMODES:
        case AC_LINEFEATURES:
        case AC_SETTABLEDEVSTATUS:
        case AC_PERMANENTDEVICEID:
        case AC_GATHERDIGITSMINTIMEOUT:
        case AC_GATHERDIGITSMAXTIMEOUT:
        case AC_GENERATEDIGITMINDURATION:
        case AC_GENERATEDIGITMAXDURATION:
        case AC_GENERATEDIGITDEFAULTDURATION:
        {
                                   
            hr = UpdateLineDevCaps();

            if ( !SUCCEEDED(hr) )
            {
                LOG((TL_ERROR, "get_AddressCap - could not get devcaps - %lx", hr));

                Unlock();

                return hr;
            }

            switch (AddressCap)
            {
                case AC_ADDRESSTYPES:
                    if ( m_dwAPIVersion >= TAPI_VERSION3_0 )
                    {
                        *plCapability = m_pDevCaps->dwAddressTypes;
                    }
                    else
                    {
                        *plCapability = LINEADDRESSTYPE_PHONENUMBER;
                    }
                    break;
                case AC_BEARERMODES:  
                    *plCapability = m_pDevCaps->dwBearerModes;
                    break;
                case AC_MONITORDIGITSUPPORT:
                    *plCapability = m_pDevCaps->dwMonitorDigitModes;
                    break;
                case AC_GENERATEDIGITSUPPORT:
                    *plCapability = m_pDevCaps->dwGenerateDigitModes;
                    break;
                case AC_GENERATETONEMODES:
                    *plCapability = m_pDevCaps->dwGenerateToneModes;
                    break;
                case AC_GENERATETONEMAXNUMFREQ:
                    *plCapability = m_pDevCaps->dwGenerateToneMaxNumFreq;
                    break;
                case AC_MONITORTONEMAXNUMFREQ:
                    *plCapability = m_pDevCaps->dwMonitorToneMaxNumFreq;
                    break;
                case AC_MONITORTONEMAXNUMENTRIES:
                    *plCapability = m_pDevCaps->dwMonitorToneMaxNumEntries;
                    break;
                case AC_DEVCAPFLAGS:
                    *plCapability = m_pDevCaps->dwDevCapFlags;
                    break;
                case AC_ANSWERMODES:
                    *plCapability = m_pDevCaps->dwAnswerMode;
                    break;
                case AC_LINEFEATURES:
                    *plCapability = m_pDevCaps->dwLineFeatures;
                    break;
                case AC_SETTABLEDEVSTATUS:
                    if ( m_dwAPIVersion >= TAPI_VERSION2_0 )
                    {
                        *plCapability = m_pDevCaps->dwSettableDevStatus;
                    }
                    else
                        hr = TAPI_E_NOTSUPPORTED;
                    
                    break;
                case AC_PERMANENTDEVICEID:
                    *plCapability = m_pDevCaps->dwPermanentLineID;
                    break;
                case AC_GATHERDIGITSMINTIMEOUT:
                    *plCapability = m_pDevCaps->dwGatherDigitsMinTimeout;
                    break;
                case AC_GATHERDIGITSMAXTIMEOUT:
                    *plCapability = m_pDevCaps->dwGatherDigitsMaxTimeout;
                    break;
                case AC_GENERATEDIGITMINDURATION:
                    *plCapability = m_pDevCaps->MinDialParams.dwDigitDuration;
                    break;
                case AC_GENERATEDIGITMAXDURATION:
                    *plCapability = m_pDevCaps->MaxDialParams.dwDigitDuration;
                    break;
                case AC_GENERATEDIGITDEFAULTDURATION:
                    *plCapability = m_pDevCaps->DefaultDialParams.dwDigitDuration;
                    break;
            }

            break;
        }                              


        case AC_MAXACTIVECALLS:
        case AC_MAXONHOLDCALLS:
        case AC_MAXONHOLDPENDINGCALLS:
        case AC_MAXNUMCONFERENCE:
        case AC_MAXNUMTRANSCONF:
        case AC_PARKSUPPORT:
        case AC_CALLERIDSUPPORT:
        case AC_CALLEDIDSUPPORT:
        case AC_CONNECTEDIDSUPPORT:
        case AC_REDIRECTIONIDSUPPORT:
        case AC_REDIRECTINGIDSUPPORT:
        case AC_ADDRESSCAPFLAGS:
        case AC_CALLFEATURES1:
        case AC_CALLFEATURES2:
        case AC_REMOVEFROMCONFCAPS:
        case AC_REMOVEFROMCONFSTATE:
        case AC_TRANSFERMODES:
        case AC_ADDRESSFEATURES:
        case AC_PREDICTIVEAUTOTRANSFERSTATES:
        case AC_MAXCALLDATASIZE:
        case AC_FORWARDMODES:
        case AC_MAXFORWARDENTRIES:
        case AC_MAXSPECIFICENTRIES:
        case AC_MINFWDNUMRINGS:
        case AC_MAXFWDNUMRINGS:
        case AC_MAXCALLCOMPLETIONS:
        case AC_CALLCOMPLETIONCONDITIONS:
        case AC_CALLCOMPLETIONMODES:
        {
            hr = UpdateAddressCaps();

            if ( !SUCCEEDED(hr) )
            {
                LOG((TL_ERROR, "get_AddressCaps - could not update caps - %lx", hr));

                Unlock();

                return hr;
            }

            switch (AddressCap)
            {
                case AC_MAXACTIVECALLS:
                    *plCapability = m_pAddressCaps->dwMaxNumActiveCalls;
                    break;
                case AC_MAXONHOLDCALLS:
                    *plCapability = m_pAddressCaps->dwMaxNumOnHoldCalls;
                    break;
                case AC_MAXONHOLDPENDINGCALLS:
                    *plCapability = m_pAddressCaps->dwMaxNumOnHoldPendingCalls;
                    break;
                case AC_MAXNUMCONFERENCE:
                    *plCapability = m_pAddressCaps->dwMaxNumConference;
                    break;
                case AC_MAXNUMTRANSCONF:
                    *plCapability = m_pAddressCaps->dwMaxNumTransConf;
                    break;
                case AC_PARKSUPPORT:
                    *plCapability = m_pAddressCaps->dwParkModes;
                    break;
                case AC_CALLERIDSUPPORT:
                    *plCapability = m_pAddressCaps->dwCallerIDFlags;
                    break;
                case AC_CALLEDIDSUPPORT:
                    *plCapability = m_pAddressCaps->dwCalledIDFlags;
                    break;
                case AC_CONNECTEDIDSUPPORT:
                    *plCapability = m_pAddressCaps->dwConnectedIDFlags;
                    break;
                case AC_REDIRECTIONIDSUPPORT:
                    *plCapability = m_pAddressCaps->dwRedirectionIDFlags;
                    break;
                case AC_REDIRECTINGIDSUPPORT:
                    *plCapability = m_pAddressCaps->dwRedirectingIDFlags;
                    break;
                case AC_ADDRESSCAPFLAGS:
                    *plCapability = m_pAddressCaps->dwAddrCapFlags;
                    break;
                case AC_CALLFEATURES1:
                    *plCapability = m_pAddressCaps->dwCallFeatures;
                    break;
                case AC_CALLFEATURES2:
                    if ( m_dwAPIVersion < TAPI_VERSION2_0 )
                    {
                        hr = TAPI_E_NOTSUPPORTED;
                    }
                    else
                    {
                        *plCapability = m_pAddressCaps->dwCallFeatures2;
                    }
                    
                    break;
                case AC_REMOVEFROMCONFCAPS:
                    *plCapability = m_pAddressCaps->dwRemoveFromConfCaps;
                    break;
                case AC_REMOVEFROMCONFSTATE:
                    *plCapability = m_pAddressCaps->dwRemoveFromConfState;
                    break;
                case AC_TRANSFERMODES:
                    *plCapability = m_pAddressCaps->dwTransferModes;
                    break;
                case AC_ADDRESSFEATURES:
                    *plCapability = m_pAddressCaps->dwAddressFeatures;
                    break;
                case AC_PREDICTIVEAUTOTRANSFERSTATES:
                    if ( m_dwAPIVersion < TAPI_VERSION2_0 )
                    {
                        hr = TAPI_E_NOTSUPPORTED;
                    }
                    else
                    {
                        *plCapability = m_pAddressCaps->dwPredictiveAutoTransferStates;
                    }
                    break;
                case AC_MAXCALLDATASIZE:

                    if ( m_dwAPIVersion < TAPI_VERSION2_0 )
                    {
                        hr = TAPI_E_NOTSUPPORTED;
                    }
                    else
                    {
                        *plCapability = m_pAddressCaps->dwMaxCallDataSize;
                    }
                    break;
                case AC_FORWARDMODES:
                    *plCapability = m_pAddressCaps->dwForwardModes;
                    break;
                case AC_MAXFORWARDENTRIES:
                    *plCapability = m_pAddressCaps->dwMaxForwardEntries;
                    break;
                case AC_MAXSPECIFICENTRIES:
                    *plCapability = m_pAddressCaps->dwMaxSpecificEntries;
                    break;
                case AC_MINFWDNUMRINGS:
                    *plCapability = m_pAddressCaps->dwMinFwdNumRings;
                    break;
                case AC_MAXFWDNUMRINGS:
                    *plCapability = m_pAddressCaps->dwMaxFwdNumRings;
                    break;
                case AC_MAXCALLCOMPLETIONS:
                    *plCapability = m_pAddressCaps->dwMaxCallCompletions;
                    break;
                case AC_CALLCOMPLETIONCONDITIONS:
                    *plCapability = m_pAddressCaps->dwCallCompletionConds;
                    break;
                case AC_CALLCOMPLETIONMODES:
                    *plCapability = m_pAddressCaps->dwCallCompletionModes;
                    break;
            }
            
            break;
        }
        default:
            LOG((TL_ERROR, "get_AddressCapability - bad addrcap"));

            Unlock();
            
            return E_INVALIDARG;
    }

    
    LOG((TL_TRACE, "get_AddressCapability - Exit - result - %lx", hr));

    Unlock();
    
    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_AddressCapabilityString(
         ADDRESS_CAPABILITY_STRING AddressCapString,
         BSTR * ppCapabilityString
         )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "get_AddressCapabilityString - Enter"));

    if ( TAPIIsBadWritePtr( ppCapabilityString, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_AddressCapabilityString - bad pointer"));

        return E_POINTER;
    }

    *ppCapabilityString = NULL;
    
    Lock();

    //
    // note on:
    // ACS_ADDRESSDEVICESPECIFIC
    // ACS_LINEDEVICESPECIFIC:
    // ACS_PROVIDERSPECIFIC:
    // ACS_SWITCHSPECIFIC:
    //
    // These buffers in LINEDEVCAPS and LINEADDRESSCAPS may or may not be strings.  However
    // in TAPI 3, we define them as strings.
    //
    // The algorithm for moving them from the tapi 2 structure to the tapi 3 string is:
    //
    // if the size of the buffer is evenly divisible by sizeof(WCHAR)
    //      then it's definitely not a string (we only support WCHAR)
    //      so we will just copy the buffer straight into the returned string, and append a
    //      NULL at the end
    // else
    //      if the buffer already has a null at the end, don't copy it, because SysAllocStringByteLen
    //      always appends a NULL and double NULLs frighten VB.
    //
    // It can still be a "buffer" and not a string even if it is divisible by sizeof WCHAR, but for
    // this it does matter, since we are using SysAllocStringByteLen to copy the buffer no
    // matter what
    //
    switch (AddressCapString)
    {
        case ACS_ADDRESSDEVICESPECIFIC:
            hr = UpdateAddressCaps();

            if ( !SUCCEEDED(hr) )
            {
                Unlock();

                return hr;
            }

            if ( m_pAddressCaps->dwDevSpecificSize != 0 )
            {
                LPWSTR      pHold;
                DWORD       dwSize;

                dwSize = m_pAddressCaps->dwDevSpecificSize;

                //
                // is size divisible by sizeof(WCHAR)?
                //
                if (0 == (dwSize % sizeof(WCHAR)))
                {
                    //
                    // yes - get to the last character in the string
                    //
                    pHold = (LPWSTR)(((LPBYTE)(m_pAddressCaps)) + m_pAddressCaps->dwDevSpecificOffset),
                    (dwSize-sizeof(WCHAR))/sizeof(WCHAR);

                    //
                    // is the last character a NULL?
                    //
                    if (*pHold == NULL)
                    {
                        //
                        // yes, so don't copy it
                        //
                        dwSize-=sizeof(WCHAR);
                    }
                }

                //
                // Alloc and copy into return string.  SysAllocStringByteLen always
                // appends a NULL
                //
                *ppCapabilityString = SysAllocStringByteLen(
                    (LPSTR)(((LPBYTE)(m_pAddressCaps)) + m_pAddressCaps->dwDevSpecificOffset),
                    dwSize
                    );
                if ( NULL == *ppCapabilityString )
                {
                    LOG((TL_ERROR, "get_AddressCapabilityString - SysAllocString Failed"));
                    hr = E_OUTOFMEMORY;
                }
            }

            break;
                
        case ACS_PROTOCOL:
        case ACS_LINEDEVICESPECIFIC:
        case ACS_PROVIDERSPECIFIC:
        case ACS_SWITCHSPECIFIC:
        case ACS_PERMANENTDEVICEGUID:
        {
            hr = UpdateLineDevCaps();

            if ( !SUCCEEDED(hr) )
            {
                Unlock();

                return hr;
            }

            switch (AddressCapString)
            {
                case ACS_PROTOCOL:
                {
                    LPWSTR pwstr;
                    
                    if ( m_dwAPIVersion >= TAPI_VERSION3_0 )
                    {
                        IID iid;

                        iid = m_pDevCaps->ProtocolGuid;
                        StringFromIID(iid, &pwstr);
                    }
                    else
                    {
                        StringFromIID( TAPIPROTOCOL_PSTN, &pwstr );
                    }

                    *ppCapabilityString = SysAllocString( pwstr );

                    if ( NULL == *ppCapabilityString )
                    {
                        LOG((TL_ERROR, "get_AddressCapabilityString - SysAllocString Failed"));
                        hr = E_OUTOFMEMORY;
                    }
                    
                    CoTaskMemFree( pwstr );

                    break;
                }
                case ACS_LINEDEVICESPECIFIC:
                    if ( m_pDevCaps->dwDevSpecificSize != 0 )
                    {
                        LPWSTR      pHold;
                        DWORD       dwSize;

                        dwSize = m_pDevCaps->dwDevSpecificSize;

                        //
                        // is size divisible by sizeof(WCHAR)?
                        //
                        if (0 == (dwSize % sizeof(WCHAR)))
                        {
                            //
                            // yes - get to the last character in the string
                            //
                            pHold = (LPWSTR)(((LPBYTE)(m_pDevCaps)) + m_pDevCaps->dwDevSpecificOffset) +
                                    (dwSize-sizeof(WCHAR))/sizeof(WCHAR);

                            //
                            // is the last character a NULL?
                            //
                            if (*pHold == NULL)
                            {
                                //
                                // yes, so don't copy it
                                //
                                dwSize-=sizeof(WCHAR);
                            }
                        }

                        //
                        // Alloc and copy into return string.  SysAllocStringByteLen always
                        // appends a NULL
                        //
                        *ppCapabilityString = SysAllocStringByteLen(
                            (LPSTR)(((LPBYTE)(m_pDevCaps)) + m_pDevCaps->dwDevSpecificOffset),
                            dwSize
                            );
                        
                        if ( NULL == *ppCapabilityString )
                        {
                            LOG((TL_ERROR, "get_AddressCapabilityString - SysAllocString Failed"));
                            hr = E_OUTOFMEMORY;
                        }
                            
                    }

                    break;
                case ACS_PROVIDERSPECIFIC:
                    if ( m_pDevCaps->dwProviderInfoSize != 0 )
                    {
                        LPWSTR      pHold;
                        DWORD       dwSize;

                        dwSize = m_pDevCaps->dwProviderInfoSize;
                        
                        //
                        // is size divisible by sizeof(WCHAR)?
                        //
                        if (0 == (dwSize % sizeof(WCHAR)))
                        {
                            //
                            // yes - get to the last character in the string
                            //
                            pHold = (LPWSTR)(((LPBYTE)(m_pDevCaps)) + m_pDevCaps->dwProviderInfoOffset) +
                                    (dwSize-sizeof(WCHAR))/sizeof(WCHAR);

                            //
                            // is the last character a NULL?
                            //
                            if (*pHold == NULL)
                            {
                                //
                                // yes, so don't copy it
                                //
                                dwSize-=sizeof(WCHAR);
                            }
                        }

                        //
                        // Alloc and copy into return string.  SysAllocStringByteLen always
                        // appends a NULL
                        //
                        *ppCapabilityString = SysAllocStringByteLen(
                                (LPSTR)(((LPBYTE)(m_pDevCaps)) + m_pDevCaps->dwProviderInfoOffset),
                                dwSize
                                );

                        if ( NULL == *ppCapabilityString )
                        {
                            LOG((TL_ERROR, "get_AddressCapabilityString - SysAllocString Failed"));
                            hr = E_OUTOFMEMORY;
                        }
                            
                    }

                    break;
                case ACS_SWITCHSPECIFIC:
                    if ( m_pDevCaps->dwSwitchInfoSize != 0 )
                    {
                        LPWSTR      pHold;
                        DWORD       dwSize;

                        dwSize = m_pDevCaps->dwSwitchInfoSize;

                        //
                        // is size divisible by sizeof(WCHAR)?
                        //
                        if (0 == (dwSize % sizeof(WCHAR)))
                        {
                            //
                            // yes - get to the last character in the string
                            //
                            pHold = (LPWSTR)(((LPBYTE)(m_pDevCaps)) + m_pDevCaps->dwSwitchInfoOffset) +
                                    (dwSize-sizeof(WCHAR))/sizeof(WCHAR);

                            //
                            // is the last character a NULL?
                            //
                            if (*pHold == NULL)
                            {
                                //
                                // yes, so don't copy it
                                //
                                dwSize-=sizeof(WCHAR);
                            }
                        }

                        //
                        // Alloc and copy into return string.  SysAllocStringByteLen always
                        // appends a NULL
                        //
                        *ppCapabilityString = SysAllocStringByteLen(
                            (LPSTR)(((LPBYTE)(m_pDevCaps)) + m_pDevCaps->dwSwitchInfoOffset),
                            dwSize
                            );
                        
                        if ( NULL == *ppCapabilityString )
                        {
                            LOG((TL_ERROR, "get_AddressCapabilityString - SysAllocString Failed"));
                            hr = E_OUTOFMEMORY;
                        }
                            
                    }

                    break;
                case ACS_PERMANENTDEVICEGUID:
                {
                    LPWSTR pwstrGUIDText;
                    
                    if ( m_dwAPIVersion >= TAPI_VERSION2_2 )
                    {
                        IID iid;

                        iid = m_pDevCaps->PermanentLineGuid;
                        StringFromIID(iid, &pwstrGUIDText);
                        
                        *ppCapabilityString = SysAllocString( pwstrGUIDText );

                        if ( NULL == *ppCapabilityString )
                        {
                            LOG((TL_ERROR, "get_AddressCapabilityString - SysAllocString Failed"));
                            hr = E_OUTOFMEMORY;
                        }
                            
                        
                        CoTaskMemFree( pwstrGUIDText );
                    }
                    else
                    {
                        // return with NULL string & error code
                        hr = TAPI_E_NOTSUPPORTED;
                    }


                    break;
                }

                default:
                    break;
            }

            break;
        }

        default:
            LOG((TL_ERROR, "get_AddressCapabilityString - invalid cap"));

            Unlock();
            
            return E_INVALIDARG;
    }
    
    LOG((TL_TRACE, "get_AddressCapabilityString - Exit - result - %lx", hr));

    Unlock();
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CreateBstrCollection(
    IN  BSTR  *     pBstr,
    IN  DWORD       dwCount,
    OUT VARIANT *   pVariant
    )
{
    //
    // create the collection object
    //

    CComObject<CTapiBstrCollection> * pCollection;
    HRESULT hr = CComObject<CTapiBstrCollection>::CreateInstance( &pCollection );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "CreateBstrCollection - "
            "can't create collection - exit 0x%lx", hr));

        return hr;
    }

    //
    // get the Collection's IDispatch interface
    //

    IDispatch * pDispatch;

    hr = pCollection->_InternalQueryInterface(__uuidof(IDispatch),
                                              (void **) &pDispatch );

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "CreateBstrCollection - "
            "QI for IDispatch on collection failed - exit 0x%lx", hr));

        delete pCollection;

        return hr;
    }

    //
    // Init the collection using an iterator -- pointers to the beginning and
    // the ending element plus one.
    //

    hr = pCollection->Initialize( dwCount,
                                  pBstr,
                                  pBstr + dwCount);

    if ( FAILED(hr) )
    {
        LOG((TL_ERROR, "CreateBstrCollection - "
            "Initialize on collection failed - exit 0x%lx", hr));
        
        pDispatch->Release();

        return hr;
    }

    //
    // put the IDispatch interface pointer into the variant
    //

    LOG((TL_ERROR, "CreateBstrCollection - "
        "placing IDispatch value %p in variant", pDispatch));

    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDispatch;

    LOG((TL_TRACE, "CreateBstrCollection - exit S_OK"));
 
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CreateBstrEnumerator(
    IN  BSTR *                  begin,
    IN  BSTR *                  end,
    OUT IEnumBstr **           ppIEnum
    )
{
typedef CSafeComEnum<IEnumBstr, &__uuidof(IEnumBstr), BSTR, _CopyBSTR> CEnumerator;

    HRESULT hr;

    CComObject<CEnumerator> *pEnum = NULL;

    hr = CComObject<CEnumerator>::CreateInstance(&pEnum);

    if (pEnum == NULL)
    {
        LOG((TL_ERROR, "CreateBstrEnumerator - "
            "Could not create enumerator object, 0x%lx", hr));
        return hr;
    }

    IEnumBstr * pIEnum;

    hr = pEnum->_InternalQueryInterface(
        __uuidof(IEnumBstr),
        (void**)&pIEnum
        );

    if (FAILED(hr))
    {
        LOG((TL_ERROR, "CreateBstrEnumerator - "
            "query enum interface failed, 0x%lx", hr));
        delete pEnum;
        return hr;
    }

    hr = pEnum->Init(begin, end, NULL, AtlFlagCopy);

    if (FAILED(hr))
    {
        LOG((TL_ERROR, "CreateBstrEnumerator - "
            "init enumerator object failed, 0x%lx", hr));
        pIEnum->Release();
        return hr;
    }

    *ppIEnum = pIEnum;

    LOG((TL_TRACE, "CreateBstrEnumerator - exit S_OK"));

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_CallTreatments(VARIANT * pVariant )
{
    HRESULT         hr = E_NOTIMPL;

    LOG((TL_TRACE, "get_CallTreatments - Enter"));
    LOG((TL_TRACE, "get_CallTreatments - Exit - result - %lx", hr));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::EnumerateCallTreatments(IEnumBstr ** ppEnumCallTreatment )
{
    HRESULT         hr = E_NOTIMPL;

    LOG((TL_TRACE, "EnumerateCallTreatments - Enter"));
    LOG((TL_TRACE, "EnumerateCallTreatments - Exit - result - %lx", hr));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_CompletionMessages(VARIANT * pVariant)
{
    HRESULT         hr = E_NOTIMPL;

    LOG((TL_TRACE, "get_CompletionMessages - Enter"));
    LOG((TL_TRACE, "get_CompletionMessages - Exit - result - %lx", hr));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::EnumerateCompletionMessages(IEnumBstr ** ppEnumCompletionMessage)
{
    HRESULT         hr = E_NOTIMPL;

    LOG((TL_TRACE, "EnumerateCompletionMessages - Enter"));
    LOG((TL_TRACE, "EnumerateCompletionMessages - Exit - result - %lx", hr));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_DeviceClasses(VARIANT * pVariant)
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "get_DeviceClasses - Enter"));

    //
    // Check arguments.
    //

    if ( TAPIIsBadWritePtr( pVariant, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_DeviceClasses - bad pointer"));

        return E_POINTER;
    }

    Lock();

    hr = UpdateLineDevCaps();

    if ( SUCCEEDED(hr) )
    {
        if ( (m_dwAPIVersion >= TAPI_VERSION2_0) && (0 != m_pDevCaps->dwDeviceClassesOffset) )
        {
            PWSTR       pszDevices;
            DWORD       dwNumDeviceClasses;              
         
            //
            // first count the device classes
            //

            dwNumDeviceClasses = 0;

            pszDevices = (PWSTR)( ( (PBYTE)m_pDevCaps ) + m_pDevCaps->dwDeviceClassesOffset );

            while (NULL != *pszDevices)
            {
                dwNumDeviceClasses++;                

                pszDevices += (lstrlenW(pszDevices) + 1 );
            }

            //
            // allocate an array of BSTR pointers
            //

            BSTR *DeviceClasses = 
                (BSTR *)ClientAlloc(sizeof(BSTR *) * dwNumDeviceClasses);
    
            if (DeviceClasses == NULL)
            {
                LOG((TL_ERROR, "get_DeviceClasses - out of memory"));

                Unlock();

                return E_OUTOFMEMORY;
            }

            //
            // allocate all the BSTRs, copying the device class names
            //

            DWORD       dwCount = 0;

            pszDevices = (PWSTR)( ( (PBYTE)m_pDevCaps ) + m_pDevCaps->dwDeviceClassesOffset );

            for (DWORD i = 0; i < dwNumDeviceClasses; i++)
            {
                LOG((TL_INFO, "get_DeviceClasses - got '%ws'", pszDevices));

                DeviceClasses[i] = SysAllocString(pszDevices);     
                
                if (DeviceClasses[i] == NULL)
                {
                    LOG((TL_ERROR, "get_DeviceClasses - out of memory"));

                    hr = E_OUTOFMEMORY;

                    break;
                }

                dwCount++;

                pszDevices += (lstrlenW(pszDevices) + 1 );
            }

            if ( FAILED(hr) )
            {
                // release all the BSTRs and the array.
                for (i = 0; i < dwCount; i ++)
                {
                    SysFreeString(DeviceClasses[i]);
                }
                
                ClientFree(DeviceClasses);

                Unlock();

                return hr;
            }

            hr = CreateBstrCollection(DeviceClasses, dwCount, pVariant);

            // if the collection is not created, release all the BSTRs.
            if (FAILED(hr))
            {
                LOG((TL_ERROR, "get_DeviceClasses - unable to create collection"));

                for (i = 0; i < dwCount; i ++)
                {
                    SysFreeString(DeviceClasses[i]);
                }
            }

            // delete the pointer array.
            ClientFree(DeviceClasses);
        }
        else
        {
            LOG((TL_ERROR, "get_DeviceClasses - no device classes"));

            //
            // create an empty collection
            //

            hr = CreateBstrCollection(NULL, 0, pVariant);

            if (FAILED(hr))
            {
                LOG((TL_ERROR, "get_DeviceClasses - unable to create collection"));
            }
        }
    }

    Unlock();

    LOG((TL_TRACE, "get_DeviceClasses - Exit - result - %lx", hr));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::EnumerateDeviceClasses(IEnumBstr ** ppEnumDeviceClass)
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "EnumerateDeviceClasses - Enter"));

    //
    // Check arguments.
    //

    if ( TAPIIsBadWritePtr( ppEnumDeviceClass, sizeof( IEnumBstr * ) ) )
    {
        LOG((TL_ERROR, "EnumerateDeviceClasses - bad pointer"));

        return E_POINTER;
    }

    Lock();

    hr = UpdateLineDevCaps();

    if ( SUCCEEDED(hr) )
    {
        if ( (m_dwAPIVersion >= TAPI_VERSION2_0) && (0 != m_pDevCaps->dwDeviceClassesOffset) )
        {
            PWSTR       pszDevices;
            DWORD       dwNumDeviceClasses;              
         
            //
            // first count the device classes
            //

            dwNumDeviceClasses = 0;

            pszDevices = (PWSTR)( ( (PBYTE)m_pDevCaps ) + m_pDevCaps->dwDeviceClassesOffset );

            while (NULL != *pszDevices)
            {
                dwNumDeviceClasses++;                

                pszDevices += (lstrlenW(pszDevices) + 1 );
            }

            //
            // allocate an array of BSTR pointers
            //

            BSTR *DeviceClasses = 
                (BSTR *)ClientAlloc(sizeof(BSTR *) * dwNumDeviceClasses);
    
            if (DeviceClasses == NULL)
            {
                LOG((TL_ERROR, "EnumerateDeviceClasses - out of memory"));

                Unlock();

                return E_OUTOFMEMORY;
            }

            //
            // allocate all the BSTRs, copying the device class names
            //

            DWORD       dwCount = 0;

            pszDevices = (PWSTR)( ( (PBYTE)m_pDevCaps ) + m_pDevCaps->dwDeviceClassesOffset );

            for (DWORD i = 0; i < dwNumDeviceClasses; i++)
            {
                LOG((TL_INFO, "EnumerateDeviceClasses - got '%ws'", pszDevices));

                DeviceClasses[i] = SysAllocString(pszDevices);     
                
                if (DeviceClasses[i] == NULL)
                {
                    LOG((TL_ERROR, "EnumerateDeviceClasses - out of memory"));

                    hr = E_OUTOFMEMORY;

                    break;
                }

                dwCount++;

                pszDevices += (lstrlenW(pszDevices) + 1 );
            }

            if ( FAILED(hr) )
            {
                // release all the BSTRs and the array.
                for (i = 0; i < dwCount; i ++)
                {
                    SysFreeString(DeviceClasses[i]);
                }
                
                ClientFree(DeviceClasses);

                Unlock();

                return hr;
            }

            hr = CreateBstrEnumerator(DeviceClasses, DeviceClasses + dwCount, ppEnumDeviceClass);

            if (FAILED(hr))
            {
                LOG((TL_ERROR, "EnumerateDeviceClasses - unable to create enum"));
            }

            // release all the BSTRs as the enumerator made a copy of them            
            for (i = 0; i < dwCount; i ++)
            {
                SysFreeString(DeviceClasses[i]);
            }                          

            // delete the pointer array.
            ClientFree(DeviceClasses);
        }
        else
        {
            LOG((TL_ERROR, "EnumerateDeviceClasses - no device classes"));

            //
            // create an empty enumeration
            //

            hr = CreateBstrEnumerator(NULL, NULL, ppEnumDeviceClass);

            if (FAILED(hr))
            {
                LOG((TL_ERROR, "EnumerateDeviceClasses - unable to create enumeration"));
            }
        }
        
    }

    Unlock();

    LOG((TL_TRACE, "EnumerateDeviceClasses - Exit - result - %lx", hr));

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
HandleLineDevStateMessage(
                          CTAPI * pTapi,
                          PASYNCEVENTMSG pParams
                         )
{
    LOG((TL_TRACE, "HandleLineDevStateMessage - enter. tapi[%p]", pTapi));

    CAddress * pAddress;
    
    if ( LINEDEVSTATE_REINIT == pParams->Param1 )
    {
        LOG((TL_TRACE, "HandleLineDevStateMessage - LINEDEVSTATE_REINIT"));

        pTapi->AddRef();    
        
        //This is to remove the bug, 4 RE_INIT messages for two objects.
        pTapi->HandleReinit();


        pTapi->Release();


        LOG((TL_TRACE, "HandleLineDevStateMessage - exit"));
        
        return;
    }

    if ( LINEDEVSTATE_TRANSLATECHANGE == pParams->Param1 )
    {
        CTapiObjectEvent::FireEvent(
                                    pTapi,
                                    TE_TRANSLATECHANGE,
                                    NULL,
                                    0,
                                    NULL
                                   );
        return;
    }
    
    if ( !FindAddressObject(
                            (HLINE)(pParams->hDevice),
                            &pAddress
                           ) )
    {
        LOG((TL_WARN, "Can't process LINE_LINEDEVSTATE message"));
        LOG((TL_WARN, "  - cannot find hLine %lx", pParams->hDevice));

        return;
    }

    switch ( pParams->Param1 )
    {
        case LINEDEVSTATE_CONNECTED:
        case LINEDEVSTATE_INSERVICE:
        {
            pAddress->InService( pParams->Param1 );
            break;
        }

        case LINEDEVSTATE_OUTOFSERVICE:
        case LINEDEVSTATE_MAINTENANCE:
        case LINEDEVSTATE_REMOVED:
        case LINEDEVSTATE_DISCONNECTED:
        case LINEDEVSTATE_LOCK:
            pAddress->OutOfService( pParams->Param1 );
            break;

        case LINEDEVSTATE_MSGWAITON:
            
            CAddressEvent::FireEvent(
                                     pAddress,
                                     AE_MSGWAITON,
                                     NULL
                                    );
            break;
            
        case LINEDEVSTATE_MSGWAITOFF:
            
            CAddressEvent::FireEvent(
                                     pAddress,
                                     AE_MSGWAITOFF,
                                     NULL
                                    );
            break;

        // the line has been opened or
        // closed by another app
        case LINEDEVSTATE_OPEN:
        case LINEDEVSTATE_CLOSE:
            break;
            
        case LINEDEVSTATE_CAPSCHANGE:
            pAddress->CapsChange( FALSE );
            break;
            
        case LINEDEVSTATE_CONFIGCHANGE:
        {
            CAddressEvent::FireEvent(
                                     pAddress,
                                     AE_CONFIGCHANGE,
                                     NULL
                                    );
            break;
        }
            
        case LINEDEVSTATE_RINGING:
        {
            CAddressEvent::FireEvent(
                                     pAddress,
                                     AE_RINGING,
                                     NULL
                                    );
            break;
        }
            
        case LINEDEVSTATE_DEVSPECIFIC:

        case LINEDEVSTATE_OTHER:
        
        case LINEDEVSTATE_NUMCALLS:
        case LINEDEVSTATE_NUMCOMPLETIONS:
        case LINEDEVSTATE_TERMINALS:
        case LINEDEVSTATE_ROAMMODE:
        case LINEDEVSTATE_BATTERY:
        case LINEDEVSTATE_SIGNAL:
        case LINEDEVSTATE_COMPLCANCEL:
            LOG((TL_INFO, "LINE_LINEDEVSTATE message not handled - %lx", pParams->Param1));
            break;
            
        default:
            LOG((TL_WARN, "Unknown LINE_LINEDEVSTATE message - %lx", pParams->Param1));
            break;
    }

    //FindAddressObject addrefs the address objct
    pAddress->Release();
    
    LOG((TL_TRACE, "HandleLineDevStateMessage - exit."));

    return;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
HandleAddressStateMessage(
                          PASYNCEVENTMSG pParams
                         )
{
    CAddress * pAddress;

    
    if ( !FindAddressObject(
                            (HLINE)(pParams->hDevice),
                            &pAddress
                           ) )
    {
        LOG((TL_WARN, "Can't process LINE_LINEDEVSTATE message"));
        LOG((TL_WARN, "  - cannot find hLine %lx", pParams->hDevice));

        return;
    }

    switch ( pParams->Param1 )
    {
        case LINEADDRESSSTATE_FORWARD:
        {
            CAddressEvent::FireEvent(
                                     pAddress,
                                     AE_FORWARD,
                                     NULL
                                    );
            break;
        }
        case LINEADDRESSSTATE_CAPSCHANGE:
        {
            pAddress->CapsChange( TRUE );
            break;
        }
        case LINEADDRESSSTATE_OTHER:
        case LINEADDRESSSTATE_DEVSPECIFIC:

        case LINEADDRESSSTATE_INUSEZERO:
        case LINEADDRESSSTATE_INUSEONE:
        case LINEADDRESSSTATE_INUSEMANY:
        case LINEADDRESSSTATE_NUMCALLS:
            
        case LINEADDRESSSTATE_TERMINALS:
            LOG((TL_WARN, "HandleAddressStateMessage - not handled %lx", pParams->Param1));
            break;
        default:
            LOG((TL_WARN, "HandleAddressStateMessage - Unknown %lx", pParams->Param1));
            break;
    }

    //FindAddressObject addrefs the address objct
    pAddress->Release();

    return;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
CAddress::InService(
                    DWORD dwType
                   )
{
    BOOL        bEvent = FALSE;

    
    switch( dwType )
    {
        case LINEDEVSTATE_CONNECTED:
        case LINEDEVSTATE_INSERVICE:
        default:
            break;
    }
    
    Lock();

    if ( AS_INSERVICE != m_AddressState )
    {
        m_AddressState = AS_INSERVICE;
        bEvent = TRUE;
    }

    Unlock();

    if (bEvent)
    {
        CAddressEvent::FireEvent(
                                 this,
                                 AE_STATE,
                                 NULL
                                );
    }
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
CAddress::OutOfService(
                       DWORD dwType
                      )
{
    BOOL        bEvent = FALSE;

    
    switch ( dwType )
    {
        case LINEDEVSTATE_OUTOFSERVICE:
        case LINEDEVSTATE_MAINTENANCE:
        case LINEDEVSTATE_REMOVED:
        case LINEDEVSTATE_DISCONNECTED:
        case LINEDEVSTATE_LOCK:
        default:
            break;
    }

    Lock();

    if ( AS_OUTOFSERVICE != m_AddressState )
    {
        m_AddressState = AS_OUTOFSERVICE;
        bEvent = TRUE;
    }
    
    Unlock();

    if ( bEvent )
    {
        CAddressEvent::FireEvent(
                                 this,
                                 AE_STATE,
                                 NULL
                                );
    }
}

void
CAddress::CapsChange( BOOL bAddress )
{
    Lock();

    if (bAddress)
    {
        m_dwAddressFlags |= ADDRESSFLAG_ADDRESSCAPSCHANGE;
    }
    else
    {
        m_dwAddressFlags |= ADDRESSFLAG_DEVCAPSCHANGE;
    }

    Unlock();

    CAddressEvent::FireEvent(
                             this,
                             AE_CAPSCHANGE,
                             NULL
                            );
}

//
// CAddressEvent
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddressEvent::FireEvent(
                         CAddress * pCAddress,
                         ADDRESS_EVENT Event,
                         ITTerminal * pTerminal
                        )
{
    HRESULT                           hr = S_OK;
    CComObject<CAddressEvent>  * p;
    IDispatch                       * pDisp;


    //
    // Check the event filter mask
    // just if is the AE_NEWTERMINAL or AE_REMOVETERMINAL
    // These two events are MSP events and are not filtered by 
    // TapiSrv
    //

    DWORD dwEventFilterMask = 0;
    dwEventFilterMask = pCAddress->GetSubEventsMask( TE_ADDRESS );
    if( !( dwEventFilterMask & GET_SUBEVENT_FLAG(Event)))
    {
        STATICLOG((TL_ERROR, "This event is filtered - %lx", Event));
        return S_OK;
    }

    //
    // create event
    //
    hr = CComObject<CAddressEvent>::CreateInstance( &p );

    if ( !SUCCEEDED(hr) )
    {
        STATICLOG((TL_ERROR, "Could not create AddressEvent object - %lx", hr));
        return hr;
    }


    //
    // initialize
    //
    p->m_Event = Event;
    p->m_pAddress = dynamic_cast<ITAddress *>(pCAddress);
    p->m_pAddress->AddRef();
    p->m_pTerminal = pTerminal;

    if ( NULL != pTerminal )
    {
        pTerminal->AddRef();
    }   

#if DBG
    p->m_pDebug = (PWSTR) ClientAlloc( 1 );
#endif

    //
    // get idisp interface
    //
    hr = p->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDisp
                          );

    if ( !SUCCEEDED(hr) )
    {
        STATICLOG((TL_ERROR, "Could not get disp interface of AddressEvent object %lx", hr));
        
        delete p;
        
        return hr;
    }

    //
    // get callback
    //
    //
    // fire event
    //
    (pCAddress->GetTapi())->Event(
                                  TE_ADDRESS,
                                  pDisp
                                 );

    //
    // release stuff
    //
    pDisp->Release();
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// finalrelease
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
CAddressEvent::FinalRelease()
{
    LOG((TL_INFO, "CAddressEvent - FinalRelease"));
    
    m_pAddress->Release();

    if ( NULL != m_pTerminal )
    {
        m_pTerminal->Release();
    }    

#if DBG
    ClientFree( m_pDebug );
#endif
}




//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Address
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddressEvent::get_Address(
                           ITAddress ** ppAddress
                          )
{
    if (TAPIIsBadWritePtr(ppAddress , sizeof(ITAddress *) ) )
    {
        LOG((TL_ERROR, "get_Address - bad pointer"));

        return E_POINTER;
    }

    *ppAddress = m_pAddress;
    (*ppAddress)->AddRef();

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Terminal
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddressEvent::get_Terminal(
                            ITTerminal ** ppTerminal
                           )
{
    if ( TAPIIsBadWritePtr( ppTerminal , sizeof(ITTerminal *) ) )
    {
        LOG((TL_ERROR, "get_Terminal - bad pointer"));

        return E_POINTER;
    }

    if ((m_Event != AE_NEWTERMINAL) && (m_Event != AE_REMOVETERMINAL))
    {
        LOG((TL_ERROR, "get_Terminal - wrong event"));

        return TAPI_E_WRONGEVENT;
    }

    *ppTerminal = m_pTerminal;

    if ( NULL != m_pTerminal )
    {
        m_pTerminal->AddRef();
    }
       
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Event
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddressEvent::get_Event(
                         ADDRESS_EVENT * pEvent
                        )
{
    if (TAPIIsBadWritePtr(pEvent , sizeof(ADDRESS_EVENT) ) )
    {
        LOG((TL_ERROR, "get_Event - bad pointer"));

        return E_POINTER;
    }

    *pEvent = m_Event;

    return S_OK;
}




///////////////////////////////////////////////////////////////////////////////
//
// CAddressDevSpecificEvent
//

// static
HRESULT CAddressDevSpecificEvent::FireEvent( CAddress * pCAddress,
                                             CCall    * pCall,
                                             long l1,
                                             long l2,
                                             long l3
                                            )
{
    STATICLOG((TL_INFO, "CAddressDevSpecificEvent::FireEvent - enter"));


    //
    // try to create the event
    //

    CComObject<CAddressDevSpecificEvent> *pEventObject = NULL;

    HRESULT hr = CComObject<CAddressDevSpecificEvent>::CreateInstance(&pEventObject);

    if ( FAILED(hr) )
    {
        STATICLOG((TL_ERROR, 
            "CAddressDevSpecificEvent::FireEvent - failed to create CAddressDevSpecificEvent. hr = %lx", 
            hr));

        return hr;
    }


    //
    // initialize the event with the data we received
    //


    //
    // get ITAddress from CAddress we received
    //

    hr = pCAddress->_InternalQueryInterface(IID_ITAddress, (void**)(&(pEventObject->m_pAddress)) );

    if (FAILED(hr))
    {
        STATICLOG((TL_ERROR, 
            "CAddressDevSpecificEvent::FireEvent - failed to create get ITAddress interface from address. hr = %lx", 
            hr));

        delete pEventObject;

        return hr;
    }


    //
    // get ITCallInfo interface from CCall we received
    //


    if (NULL != pCall)
    {

        hr = pCall->_InternalQueryInterface(IID_ITCallInfo, (void**)(&(pEventObject->m_pCall)) );

        if (FAILED(hr))
        {
            STATICLOG((TL_ERROR, 
                "CAddressDevSpecificEvent::FireEvent - failed to create get ITAddress interface from address. hr = %lx", 
                hr));

            //
            // no need to release event's data members, event's destructor will do 
            // this for us
            //

            delete pEventObject;

            return hr;
        }
    }


    //
    // keep the actual data
    //

    pEventObject->m_l1 = l1;
    pEventObject->m_l2 = l2;
    pEventObject->m_l3 = l3;


#if DBG
    pEventObject->m_pDebug = (PWSTR) ClientAlloc( 1 );
#endif


    //
    // get event's idispatch interface
    //

    IDispatch *pDispatch = NULL;

    hr = pEventObject->QueryInterface( IID_IDispatch,
                                       (void **)&pDispatch );

    if ( FAILED(hr) )
    {
        STATICLOG((TL_ERROR, 
            "CAddressDevSpecificEvent::FireEvent - Could not get disp interface of AddressEvent object %lx", 
            hr));

        
        //
        // no need to release event's data members, event's destructor will do 
        // this for us
        //


        //
        // delete the event object
        //

        delete pEventObject;
        
        return hr;
    }


    //
    // from this point on, we will be using events pDispatch
    //

    pEventObject = NULL;


    //
    // get callback
    //
    //
    // fire event to tapi
    //

    hr = (pCAddress->GetTapi())->Event(TE_ADDRESSDEVSPECIFIC, pDispatch);


    //
    // succeeded or not, we no longer need a reference to the event object
    //

    pDispatch->Release();
    pDispatch = NULL;
    
    STATICLOG((TL_INFO, "CAddressDevSpecificEvent::FireEvent - exit, hr = %lx", hr));

    return hr;
}

///////////////////////////////////////////////////////////////////////////////

CAddressDevSpecificEvent::CAddressDevSpecificEvent()
    :m_pAddress(NULL),
    m_pCall(NULL)
{
    LOG((TL_INFO, "CAddressDevSpecificEvent - enter"));

#if DBG
    m_pDebug = NULL;
#endif 


    LOG((TL_INFO, "CAddressDevSpecificEvent - exit"));
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// ~CAddressDevSpecificEvent
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
CAddressDevSpecificEvent::~CAddressDevSpecificEvent()
{
    LOG((TL_INFO, "~CAddressDevSpecificEvent - enter"));

    
    if (NULL != m_pAddress)
    {
        m_pAddress->Release();
        m_pAddress = NULL;
    }


    if (NULL != m_pCall)
    {
        m_pCall->Release();
        m_pCall = NULL;
    }


#if DBG
    ClientFree( m_pDebug );
#endif

    LOG((TL_INFO, "~CAddressDevSpecificEvent - exit"));

}




//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Address
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddressDevSpecificEvent::get_Address(
                           ITAddress ** ppAddress
                          )
{
    LOG((TL_TRACE, "get_Address - enter"));


    //
    // good out pointer?
    //

    if (TAPIIsBadWritePtr(ppAddress , sizeof(ITAddress *) ) )
    {
        LOG((TL_ERROR, "get_Address - bad pointer at [%p]", ppAddress));

        return E_POINTER;
    }


    //
    // return addreff'd address
    //

    _ASSERTE(NULL != m_pAddress);

    *ppAddress = m_pAddress;
    (*ppAddress)->AddRef();


    LOG((TL_TRACE, "get_Address - enter. address[%p]", (*ppAddress) ));

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_Address
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddressDevSpecificEvent::get_Call(
                           ITCallInfo ** ppCall
                          )
{
    LOG((TL_TRACE, "get_Call - enter"));


    //
    // good out pointer?
    //

    if (TAPIIsBadWritePtr(ppCall, sizeof(ITCallInfo*) ) )
    {
        LOG((TL_ERROR, "get_Call - bad pointer at [%p]", ppCall));

        return E_POINTER;
    }


    //
    // return addreff'd call
    //


    HRESULT hr = S_OK;

    if ( NULL != m_pCall )
    {

        //
        // this event is call specific
        //

        *ppCall = m_pCall;
        (*ppCall)->AddRef();

    }
    else 
    {

        //
        // this event was not call specific
        //

        LOG((TL_WARN, "get_Call - no call"));

        hr = TAPI_E_CALLUNAVAIL;
    }


    LOG(( TL_TRACE, "get_Call - enter. call [%p]. hr = %lx", (*ppCall), hr ));

    return hr;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_lParam1
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CAddressDevSpecificEvent::get_lParam1( long *pl1 )
{
    LOG((TL_TRACE, "get_lParam1 - enter"));


    //
    // good out pointer?
    //

    if (TAPIIsBadWritePtr(pl1, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_lParam1 - bad pointer at %p", pl1));

        return E_POINTER;
    }


    //
    // log and return the value
    //

    *pl1 = m_l1;

    LOG((TL_TRACE, "get_lParam1 - exit. p1[%ld]", *pl1));


    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_lParam2
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CAddressDevSpecificEvent::get_lParam2( long *pl2 )
{
    LOG((TL_TRACE, "get_lParam2 - enter"));


    //
    // good out pointer?
    //

    if (TAPIIsBadWritePtr(pl2, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_lParam2 - bad pointer at %p", pl2));

        return E_POINTER;
    }


    //
    // log and return the value
    //

    *pl2 = m_l2;

    LOG((TL_TRACE, "get_lParam2 - exit. p2[%ld]", *pl2));


    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_lParam3
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP CAddressDevSpecificEvent::get_lParam3( long *pl3 )
{
    LOG((TL_TRACE, "get_lParam3 - enter"));


    //
    // good out pointer?
    //

    if ( TAPIIsBadWritePtr(pl3, sizeof(long)) )
    {
        LOG((TL_ERROR, "get_lParam3 - bad pointer at %p", pl3));

        return E_POINTER;
    }


    //
    // log and return the value
    //

    *pl3 = m_l3;

    LOG((TL_TRACE, "get_lParam3 - exit. p3[%ld]", *pl3));


    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Initialize
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CForwardInfo::Initialize()
{
    HRESULT         hr = S_OK;

    ZeroMemory(
               m_ForwardStructs,
               sizeof( MYFORWARDSTRUCT ) * NUMFORWARDTYPES
              );

    m_lNumRings = 0;
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetForwardOffset
//
// maps a forward type to an offset for the array
// in the 
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD
GetForwardOffset(
                 DWORD dwForwardType
                )
{
    switch (dwForwardType)
    {
        case LINEFORWARDMODE_UNCOND:
            return 0;
        case LINEFORWARDMODE_UNCONDINTERNAL:
            return 1;
        case LINEFORWARDMODE_UNCONDEXTERNAL:
            return 2;
        case LINEFORWARDMODE_UNCONDSPECIFIC:
            return 3;
        case LINEFORWARDMODE_BUSY:
            return 4;
        case LINEFORWARDMODE_BUSYINTERNAL:
            return 5;
        case LINEFORWARDMODE_BUSYEXTERNAL:
            return 6;
        case LINEFORWARDMODE_BUSYSPECIFIC:
            return 7;
        case LINEFORWARDMODE_NOANSW:
            return 8;
        case LINEFORWARDMODE_NOANSWINTERNAL:
            return 9;
        case LINEFORWARDMODE_NOANSWEXTERNAL:
            return 10;
        case LINEFORWARDMODE_NOANSWSPECIFIC:
            return 11;
        case LINEFORWARDMODE_BUSYNA:
            return 12;
        case LINEFORWARDMODE_BUSYNAINTERNAL:
            return 13;
        case LINEFORWARDMODE_BUSYNAEXTERNAL:
            return 14;
        case LINEFORWARDMODE_BUSYNASPECIFIC:
            return 15;
        case LINEFORWARDMODE_UNKNOWN:
            return 16;
        case LINEFORWARDMODE_UNAVAIL:
            return 17;
        default:
            return 0;
    }

    return 0;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// put_NumRingsNoAnswer
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::put_NumRingsNoAnswer(
                                   long lNumRings
                                  )
{
    HRESULT         hr = S_OK;

    Lock();
    
    m_lNumRings = lNumRings;

    Unlock();
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_NumRingsNoAnswer
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::get_NumRingsNoAnswer(
                                   long * plNumRings
                                  )
{
    if (TAPIIsBadWritePtr(plNumRings , sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_NumRingsNoAnswer - bad pointer"));

        return E_POINTER;
    }

    Lock();
    
    *plNumRings = m_lNumRings;

    Unlock();
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// SetForwardType
//
// save the forward type.  overwrite and free is there is already
// a matching type
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::SetForwardType( 
        long ForwardType, 
        BSTR pDestAddress,
        BSTR pCallerAddress
        )
{
    HRESULT         hr;

    LOG((TL_TRACE, "SetForwardType - enter"));

    hr = SetForwardType2(
                         ForwardType,
                         pDestAddress,
                         0,
                         pCallerAddress,
                         0
                        );
    
    LOG((TL_TRACE, "SetForwardType - exit - %lx", hr));
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// SetForwardType2
//
// save the forward type.  overwrite and free is there is already
// a matching type
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::SetForwardType2( 
        long ForwardType, 
        BSTR pDestAddress,
        long DestAddressType,
        BSTR pCallerAddress,
        long CallerAddressType
        )
{
    HRESULT         hr = S_OK;
    DWORD           dwCount;

    LOG((TL_TRACE, "SetForwardType2 - enter"));

    //
    // check forwardtype
    //
    if ( !IsOnlyOneBitSetInDWORD( ForwardType ) )
    {
        LOG((TL_ERROR, "ForwardType has more than one bit set"));
        return E_INVALIDARG;
    }

    //
    // check destaddress
    //
    if ( pDestAddress == NULL )
    {
        LOG((TL_ERROR, "Forward destaddress cannot be NULL"));
        return E_INVALIDARG;
    }

    if ( IsBadStringPtrW( pDestAddress, -1 ) )
    {
        LOG((TL_ERROR, "Forward destaddress invalid"));
        return E_POINTER;
    }
    
    //
    // check calleraddress
    //
    if ( FORWARDMODENEEDSCALLER( ForwardType ) )
    {
        if ( NULL == pCallerAddress )
        {
            LOG((TL_ERROR, "Forward type needs calleraddress"));
            return E_INVALIDARG;
        }

        if ( IsBadStringPtrW( pCallerAddress, -1 ) )
        {
            LOG((TL_ERROR, "Forward calleraddress invalid"));
            return E_POINTER;
        }
    }

    Lock();
    
    //
    // find correct structure in array
    //
    MYFORWARDSTRUCT * pStruct = NULL;

    pStruct = &(m_ForwardStructs[GetForwardOffset(ForwardType)]);
    
    //
    // free alloced stuff
    //
    if ( NULL != pStruct->bstrDestination )
    {
        SysFreeString( pStruct->bstrDestination );
        pStruct->bstrDestination = NULL;
    }

    if ( NULL != pStruct->bstrCaller )
    {
        SysFreeString( pStruct->bstrCaller );
        pStruct->bstrCaller = NULL;
    }

    //
    // save stuff
    //
    pStruct->bstrDestination = SysAllocString( pDestAddress );
    if ( NULL == pStruct->bstrDestination )
    {
        Unlock();
        
        LOG((TL_ERROR, "Could not alloc dest in put_Forward"));
        return E_OUTOFMEMORY;
    }

    if ( NULL != pCallerAddress )
    {
        pStruct->bstrCaller = SysAllocString( pCallerAddress );
        if ( NULL == pStruct->bstrCaller )
        {
            LOG((TL_ERROR, "Could not calloc caller in put_Forward"));
            SysFreeString( pStruct->bstrDestination );
            Unlock();
            return E_OUTOFMEMORY;
        }
    }

    pStruct->dwDestAddressType = DestAddressType;
    pStruct->dwCallerAddressType = CallerAddressType;
    
    pStruct->dwForwardType = ForwardType;

    Unlock();
    
    LOG((TL_TRACE, "SetForwardType2 - exit - success"));
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_ForwardTypeDestination
//
// will return null if nothing saved
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::get_ForwardTypeDestination( 
        long ForwardType, 
        BSTR * ppDestAddress 
        )
{
    HRESULT         hr = S_OK;
    DWORD           dwCount;

    LOG((TL_TRACE, "get_ForwardTypeDest - enter"));

    //
    // check forwardtype
    //
    if ( !IsOnlyOneBitSetInDWORD( ForwardType ) )
    {
        LOG((TL_ERROR, "ForwardType has more than one bit set"));
        return E_INVALIDARG;
    }

    
    if ( TAPIIsBadWritePtr( ppDestAddress, sizeof( BSTR ) ) )
    {
        LOG((TL_ERROR, "Bad pointer in get_ForwardTypeDest"));
        return E_POINTER;
    }

    *ppDestAddress = NULL;

    Lock();

    dwCount = GetForwardOffset( ForwardType );
    
    if ( NULL != m_ForwardStructs[dwCount].bstrDestination )
    {
        *ppDestAddress = SysAllocString(
                                        m_ForwardStructs[dwCount].bstrDestination
                                       );

        if ( NULL == *ppDestAddress )
        {
            LOG((TL_ERROR, "OutOfMemory in get_ForwardTypeDest"));

            Unlock();

            return E_POINTER;
        }
    }

    Unlock();
    
    LOG((TL_TRACE, "get_ForwardTypeDest - exit"));
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_ForwardTypeDestinationAddressType
//
// will return null if nothing saved
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::get_ForwardTypeDestinationAddressType( 
        long ForwardType, 
        long * pDestAddressType 
        )
{
    HRESULT         hr = S_OK;
    DWORD           dwCount;

    LOG((TL_TRACE, "get_ForwardTypeDestinationAddressType - enter"));

    //
    // check forwardtype
    //
    if ( !IsOnlyOneBitSetInDWORD( ForwardType ) )
    {
        LOG((TL_ERROR, "ForwardType has more than one bit set"));
        return E_INVALIDARG;
    }

    
    if ( TAPIIsBadWritePtr( pDestAddressType, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "Bad pointer in get_ForwardTypeDestinationAddressType"));
        return E_POINTER;
    }

    Lock();

    dwCount = GetForwardOffset( ForwardType );

    *pDestAddressType = m_ForwardStructs[dwCount].dwDestAddressType;
    
    Unlock();
    
    LOG((TL_TRACE, "get_ForwardTypeDestinationAddressType - exit"));
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_ForwardTypeCaller
//
// gets the caller save for the specifies forward type
//
// will return NULL in ppCallerAddress if nothing saved
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::get_ForwardTypeCaller( 
        long ForwardType, 
        BSTR * ppCallerAddress 
        )
{
    HRESULT         hr = S_OK;

    DWORD           dwCount;

    LOG((TL_TRACE, "get_ForwardTypeCaller - enter"));

    //
    // check forwardtype
    //
    if ( !IsOnlyOneBitSetInDWORD( ForwardType ) )
    {
        LOG((TL_ERROR, "ForwardType has more than one bit set"));
        return E_INVALIDARG;
    }

    
    if ( TAPIIsBadWritePtr( ppCallerAddress, sizeof( BSTR ) ) )
    {
        LOG((TL_ERROR, "Bad pointer in get_ForwardTypeCaller"));
        return E_POINTER;
    }

    *ppCallerAddress = NULL;

    Lock();

    dwCount = GetForwardOffset( ForwardType );
    
    if ( NULL != m_ForwardStructs[dwCount].bstrCaller )
    {
        *ppCallerAddress = SysAllocString(
                                          m_ForwardStructs[dwCount].bstrCaller
                                         );

        if ( NULL == *ppCallerAddress )
        {
            LOG((TL_ERROR, "OutOfMemory in get_ForwardTypeCaller"));

            Unlock();

            return E_POINTER;
        }
    }

    Unlock();
    
    LOG((TL_TRACE, "get_ForwardTypeDest - exit"));
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_ForwardTypeCallerAddressType
//
// will return null if nothing saved
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::get_ForwardTypeCallerAddressType( 
        long ForwardType, 
        long * pCallerAddressType 
        )
{
    HRESULT         hr = S_OK;
    DWORD           dwCount;

    LOG((TL_TRACE, "get_ForwardTypeCallerAddressType - enter"));

    //
    // check forwardtype
    //
    if ( !IsOnlyOneBitSetInDWORD( ForwardType ) )
    {
        LOG((TL_ERROR, "ForwardType has more than one bit set"));
        return E_INVALIDARG;
    }

    
    if ( TAPIIsBadWritePtr( pCallerAddressType, sizeof( long ) ) )
    {
        LOG((TL_ERROR, "Bad pointer in get_ForwardTypeCallerAddressType"));
        return E_POINTER;
    }

    Lock();

    dwCount = GetForwardOffset( ForwardType );

    *pCallerAddressType = m_ForwardStructs[dwCount].dwCallerAddressType;
    
    Unlock();
    
    LOG((TL_TRACE, "get_ForwardTypeCallerAddressType - exit"));
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetForwardType
//
// get the destination and caller based on the type
//
// simply use the vb functions to do this.
//
// will return success even if no info - both addresses will
// be NULL in that case
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::GetForwardType(
        long ForwardType,
        BSTR * ppDestinationAddress,
        BSTR * ppCallerAddress
        )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "GetForwardType - enter"));
    
    hr = get_ForwardTypeDestination( ForwardType, ppDestinationAddress );

    if ( !SUCCEEDED(hr) )
    {
        return hr;
    }
    
    hr = get_ForwardTypeCaller( ForwardType, ppCallerAddress );

    if ( !SUCCEEDED(hr) )
    {
        SysFreeString( *ppDestinationAddress );
        return hr;
    }
    
    LOG((TL_TRACE, "GetForwardType - exit"));
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// GetForwardType2
//
// get the destination and caller based on the type
//
// simply use the vb functions to do this.
//
// will return success even if no info - both addresses will
// be NULL in that case
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::GetForwardType2(
        long ForwardType,
        BSTR * ppDestinationAddress,
        long * pDestAddressType,
        BSTR * ppCallerAddress,
        long * pCallerAddressType
        )
{
    HRESULT         hr = S_OK;

    LOG((TL_TRACE, "GetForwardType2 - enter"));
    
    hr = get_ForwardTypeDestination( ForwardType, ppDestinationAddress );

    if ( !SUCCEEDED(hr) )
    {
        return hr;
    }

    hr = get_ForwardTypeDestinationAddressType( ForwardType, pDestAddressType );

    if ( !SUCCEEDED(hr) )
    {
        SysFreeString( *ppDestinationAddress );
        return hr;
    }
    
    hr = get_ForwardTypeCaller( ForwardType, ppCallerAddress );

    if ( !SUCCEEDED(hr) )
    {
        SysFreeString( *ppDestinationAddress );
        return hr;
    }

    hr = get_ForwardTypeCallerAddressType( ForwardType, pCallerAddressType );

    if ( !SUCCEEDED(hr) )
    {
        SysFreeString( *ppDestinationAddress );
        SysFreeString( *ppCallerAddress );
        return hr;
    }
    
    LOG((TL_TRACE, "GetForwardType2 - exit"));
    
    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Clear
//
// clears & frees all info in the forward object
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CForwardInfo::Clear()
{
    HRESULT         hr = S_OK;
    DWORD           dwCount;

    LOG((TL_TRACE, "Clear - enter"));

    Lock();

    //
    // go through all the structs and free
    // related memory
    //
    for (dwCount = 0; dwCount < NUMFORWARDTYPES; dwCount++)
    {
        if ( NULL != m_ForwardStructs[dwCount].bstrDestination )
        {
            SysFreeString( m_ForwardStructs[dwCount].bstrDestination );
        }

        if ( NULL != m_ForwardStructs[dwCount].bstrCaller )
        {
            SysFreeString( m_ForwardStructs[dwCount].bstrCaller );
        }
    }

    //
    // zero out stuff
    //
    ZeroMemory(
               m_ForwardStructs,
               sizeof( MYFORWARDSTRUCT ) * NUMFORWARDTYPES
              );

    Unlock();
    
    LOG((TL_TRACE, "Clear - exit"));
    
    return S_OK;
}
    
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CreateForwardList
//
// Creates a LINEFORWARDLIST structure based on the info
// in the object
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CForwardInfo::CreateForwardList(
                                LINEFORWARDLIST ** ppList
                               )
{
    LINEFORWARDLIST       * pList;
    DWORD                   dwCount;
    DWORD                   dwSize = 0;
    DWORD                   dwOffset;
    DWORD                   dwNumEntries = 0;

    Lock();

    //
    // count the number of entries that are filled
    //
    for (dwCount = 0; dwCount < NUMFORWARDTYPES; dwCount++)
    {
        if ( 0 != m_ForwardStructs[dwCount].dwForwardType )
        {
            dwSize += ( (lstrlenW( m_ForwardStructs[dwCount].bstrDestination ) + 1) * sizeof(WCHAR*));
            dwSize += ( (lstrlenW( m_ForwardStructs[dwCount].bstrCaller ) + 1) * sizeof(WCHAR*));

            dwNumEntries++;
        }
    }

    if ( 0 == dwNumEntries )
    {
        Unlock();
        *ppList = NULL;
        return S_OK;
    }
    
    dwSize += sizeof (LINEFORWARDLIST) +
              sizeof (LINEFORWARD) * dwNumEntries +
              dwSize;


    //
    // alloc structure
    //
    pList = (LINEFORWARDLIST *)ClientAlloc( dwSize );

    if ( NULL == pList )
    {
        LOG((TL_ERROR, "CreateForwardList - OutOfMemory"));

        Unlock();
        
        return E_OUTOFMEMORY;
    }

    //
    // init
    //
    pList->dwTotalSize = dwSize;
    pList->dwNumEntries = dwNumEntries;

    //
    // offset should be past the fixed part of the structure
    //
    dwOffset = sizeof( LINEFORWARDLIST ) + sizeof( LINEFORWARD ) * dwNumEntries;

    dwNumEntries = 0;

    //
    // go through entries again
    //
    for (dwCount = 0; dwCount < NUMFORWARDTYPES; dwCount++)
    {
        if ( 0 != m_ForwardStructs[dwCount].dwForwardType )
        {
            DWORD           dwSize;
            LINEFORWARD   * pEntry = &(pList->ForwardList[dwNumEntries]);
            

            //
            // save the type
            //
            pEntry->dwForwardMode = m_ForwardStructs[dwCount].dwForwardType;

            //
            // save destination - should always be a destination if
            // there is a type
            //
            pEntry->dwDestAddressType = m_ForwardStructs[dwCount].dwDestAddressType; 

            pEntry->dwDestAddressSize = (lstrlenW(m_ForwardStructs[dwCount].bstrDestination) + 1)
                                        * sizeof( WCHAR );
            pEntry->dwDestAddressOffset = dwOffset;
            lstrcpyW(
                     (PWSTR)(((PBYTE)pList)+dwOffset),
                     m_ForwardStructs[dwCount].bstrDestination
                    );

            //
            // fixup offset
            //
            dwOffset += pEntry->dwDestAddressSize;

            //
            // if there is a caller, do the same
            //
            if ( NULL != m_ForwardStructs[dwCount].bstrCaller )
            {
                pEntry->dwCallerAddressType = m_ForwardStructs[dwCount].dwCallerAddressType; 

                pEntry->dwCallerAddressSize = (lstrlenW(m_ForwardStructs[dwCount].bstrCaller) + 1)
                                            * sizeof( WCHAR );
                pEntry->dwCallerAddressOffset = dwOffset;
                lstrcpyW(
                         (PWSTR)(((PBYTE)pList)+dwOffset),
                         m_ForwardStructs[dwCount].bstrCaller
                        );

                dwOffset += pEntry->dwCallerAddressSize;
            }

            dwNumEntries++;
        }
    }

    //
    // return it
    //
    *ppList = pList;

    Unlock();
    
    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// FinalRelease()
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
CForwardInfo::FinalRelease()
{
    //
    // simply clear it
    //
    Clear();
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddressTranslation
// Method    : TranslateAddress
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

STDMETHODIMP
CAddress::TranslateAddress(
            BSTR pAddressToTranslate,
            long ulCard,
            long ulTranslateOptions,
            ITAddressTranslationInfo ** ppTranslated
            )
{
    HRESULT                 hr = S_OK;
    LPLINETRANSLATEOUTPUT   pTranslateOutput = NULL;
    PWSTR                   pszDialableString = NULL;
    PWSTR                   pszDisplayableString = NULL;
    CComObject< CAddressTranslationInfo > * pTranslationInfo = NULL;
    long                    lCap = 0;
    BOOL                    bUsePSTNAddressTranslation =  TRUE;
    HLINEAPP                hLineApp;
    DWORD                   dwDeviceID;
          
    
    LOG((TL_TRACE, "TranslateAddress - enter" ));

    if ( !TAPIIsBadWritePtr( ppTranslated, sizeof(ITAddressTranslationInfo *) ) )
    {
        // ppTranslated OK
        if ( !IsBadStringPtrW( pAddressToTranslate, -1 ) )
        {
            //  pAddressToTranslate OK
            
            // Check Addresscap bit
            hr = get_AddressCapability( AC_ADDRESSCAPFLAGS, &lCap );
            if ( SUCCEEDED(hr) )
            {
                if ( lCap & LINEADDRCAPFLAGS_NOPSTNADDRESSTRANSLATION  )
                {
                    bUsePSTNAddressTranslation =  FALSE;
                }
            }

            // create Translate Info object
            hr = CComObject< CAddressTranslationInfo >::CreateInstance( &pTranslationInfo );
            if ( SUCCEEDED(hr) )
            {
                // Translate or copy ?
                if (bUsePSTNAddressTranslation)
                {
                    LOG((TL_INFO, "TranslateAddress - Do address translation" ));

                    Lock();
                    hLineApp = m_hLineApp;
                    dwDeviceID = m_dwDeviceID;
                    Unlock();

                    hr= LineTranslateAddress(
                        hLineApp,
                        dwDeviceID,
                        TAPI_CURRENT_VERSION,
                        (LPCWSTR)pAddressToTranslate,
                        ulCard,
                        ulTranslateOptions,
                        &pTranslateOutput);
                    if(SUCCEEDED(hr) )
                    {
                        // Pull String info out of LPLINETRANSLATEOUTPUT structure
                        pszDialableString   = (PWSTR) ((BYTE*)(pTranslateOutput) + pTranslateOutput->dwDialableStringOffset);
                        pszDisplayableString = (PWSTR) ((BYTE*)(pTranslateOutput) + pTranslateOutput->dwDisplayableStringOffset);
                        
                        hr = pTranslationInfo->Initialize(pszDialableString, 
                                                          pszDisplayableString, 
                                                          pTranslateOutput->dwCurrentCountry,  
                                                          pTranslateOutput->dwDestCountry,     
                                                          pTranslateOutput->dwTranslateResults
                                                          );
                    }
                    else // LinetranslateAddress failed
                    {
                        LOG((TL_ERROR, "TranslateAddress - LineTranslateAddress failed" ));
                    }
                }
                else // copy input string unmodified
                {
                    LOG((TL_INFO, "TranslateAddress - No address translation" ));

                    hr = pTranslationInfo->Initialize(pAddressToTranslate, 
                                                      pAddressToTranslate, 
                                                      0,  
                                                      0,     
                                                      LINETRANSLATERESULT_NOTRANSLATION
                                                     );
                } // end if (bUsePSTNAddressTranslation)

                //
                // Did we translate & initialize output object  ?
                if ( SUCCEEDED(hr) )
                {
                    hr = pTranslationInfo->QueryInterface(IID_ITAddressTranslationInfo,(void**)ppTranslated);

                    if ( SUCCEEDED(hr) )
                    {
                        LOG((TL_TRACE, "TranslateAddress - success"));
                        hr = S_OK;
                    }
                    else
                    {
                        LOG((TL_ERROR, "TranslateAddress - Bad pointer" ));
                        delete pTranslationInfo;
                    }
                    
                }
                else  // object failed to initialize
                {
                    LOG((TL_ERROR, "TranslateAddress - Initialize TranslateInfo object failed" ));
                    delete pTranslationInfo;
                }
            }
            else  // Create instance failed 
            {
                LOG((TL_ERROR, "TranslateAddress - Create TranslateInfo object failed" ));
            }
        }
        else // pAddressToTranslate bad
        {
            LOG((TL_ERROR, "TranslateAddress -pAddressToTranslate invalid"));
            hr = E_POINTER;
        }
    }
    else // ppTranslated bad
    {
        LOG((TL_ERROR, "TranslateAddress - Bad ppTranslated Pointer" ));
        hr = E_POINTER;
    }

    
    if(pTranslateOutput != NULL)
    {
        ClientFree(pTranslateOutput);
    }

    LOG((TL_TRACE, hr, "TranslateAddress - exit" ));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// TranslateDialog
//
// simply call LineTranslateDialog
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::TranslateDialog(
                          TAPIHWND hwndOwner,
                          BSTR pAddressIn
                         )
{
    HRESULT             hr = E_NOTIMPL;
    HLINEAPP            hLineApp;
    DWORD               dwDeviceID;
    DWORD               dwAPIVersion;
            
    LOG((TL_TRACE, "TranslateDialog - enter:%p", hwndOwner ));
    
    Lock();

    hLineApp = m_hLineApp;
    dwDeviceID = m_dwDeviceID;
    dwAPIVersion = m_dwAPIVersion;

    Unlock();
    
    hr = LineTranslateDialog(
                             dwDeviceID,
                             dwAPIVersion,
                             (HWND)hwndOwner,
                             pAddressIn
                            );

    LOG((TL_TRACE, "TranslateDialog - exit - return %lx", hr));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddressTranslation
// Method    : EnumerateLocations
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAddress::EnumerateLocations (IEnumLocation ** ppEnumLocation )
{
    HRESULT                 hr = S_OK;
    LPLINETRANSLATECAPS     pTranslateCaps = NULL;
    DWORD                   dwNumLocations;    
    DWORD                   dwCount;
    LPLINELOCATIONENTRY     pEntry = NULL;
    
    PWSTR                   pszLocationName;            
    PWSTR                   pszCityCode;                
    PWSTR                   pszLocalAccessCode;         
    PWSTR                   pszLongDistanceAccessCode;  
    PWSTR                   pszTollPrefixList;          
    PWSTR                   pszCancelCallWaitingCode;   
    DWORD                   dwPermanentLocationID;   
    DWORD                   dwCountryCode;           
    DWORD                   dwPreferredCardID;       
    DWORD                   dwCountryID;             
    DWORD                   dwOptions;               
                                                     
    
    LOG((TL_TRACE, "EnumerateLocations - enter" ));

    
    if ( TAPIIsBadWritePtr( ppEnumLocation, sizeof(IEnumLocation *) ) )
    {
        LOG((TL_ERROR, "EnumerateLocations - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        //
        // create the enumerator
        //
        CComObject< CTapiEnum<IEnumLocation, ITLocationInfo, &IID_IEnumLocation> > * pEnum;
        hr = CComObject< CTapiEnum<IEnumLocation, ITLocationInfo, &IID_IEnumLocation> > ::CreateInstance( &pEnum );
    
        if (SUCCEEDED(hr) )
        {
            //
            // initialize it with our Locations list
            //
            pEnum->Initialize();

            hr = LineGetTranslateCaps(m_hLineApp, TAPI_CURRENT_VERSION, &pTranslateCaps);
            if(SUCCEEDED(hr) )
            {
                dwNumLocations = pTranslateCaps->dwNumLocations ;    
        
                // Find positionn of 1st LINELOCATIONENTRY structure in the LINETRANSLATECAPS structure
                pEntry = (LPLINELOCATIONENTRY) ((BYTE*)(pTranslateCaps) + pTranslateCaps->dwLocationListOffset );
            
                for (dwCount = 0; dwCount < dwNumLocations; dwCount++)
                {
                    // Pull Location Info out of LINELOCATIONENTRY structure
                    pszLocationName           = (PWSTR) ((BYTE*)(pTranslateCaps) + pEntry->dwLocationNameOffset);
                    pszCityCode               = (PWSTR) ((BYTE*)(pTranslateCaps) + pEntry->dwCityCodeOffset);
                    pszLocalAccessCode        = (PWSTR) ((BYTE*)(pTranslateCaps) + pEntry->dwLocalAccessCodeOffset);
                    pszLongDistanceAccessCode = (PWSTR) ((BYTE*)(pTranslateCaps) + pEntry->dwLongDistanceAccessCodeOffset);
                    pszTollPrefixList         = (PWSTR) ((BYTE*)(pTranslateCaps) + pEntry->dwTollPrefixListOffset);
                    pszCancelCallWaitingCode  = (PWSTR) ((BYTE*)(pTranslateCaps) + pEntry->dwCancelCallWaitingOffset);
                    dwPermanentLocationID     = pEntry->dwPermanentLocationID;
                    dwCountryCode             = pEntry->dwCountryCode;
                    dwPreferredCardID         = pEntry->dwPreferredCardID;
                    dwCountryID               = pEntry->dwCountryID;
                    dwOptions                 = pEntry->dwOptions;

                    // create our new LocationInfo Object                
                    CComObject<CLocationInfo> * pLocationInfo;
                    CComObject<CLocationInfo>::CreateInstance( &pLocationInfo );
                    if (SUCCEEDED(hr) )
                    {
                        // initialize the new LocationInfo Object
                        hr = pLocationInfo->Initialize(
                                                       pszLocationName, 
                                                       pszCityCode, 
                                                       pszLocalAccessCode, 
                                                       pszLongDistanceAccessCode, 
                                                       pszTollPrefixList, 
                                                       pszCancelCallWaitingCode , 
                                                       dwPermanentLocationID,
                                                       dwCountryCode,
                                                       dwPreferredCardID,
                                                       dwCountryID,
                                                       dwOptions
                                                      );
                        if (SUCCEEDED(hr) )
                        {
                            // Add it to the enumerator
                            hr = pEnum->Add(pLocationInfo);
                            if (SUCCEEDED(hr))
                            {
                                LOG((TL_INFO, "EnumerateLocations - Added LocationInfo object to enum"));
                            }
                            else
                            {
                                LOG((TL_INFO, "EnumerateLocations - Add LocationInfo object failed"));
                                delete pLocationInfo;
                            }
                        }
                        else
                        {
                            LOG((TL_ERROR, "EnumerateLocations - Init LocationInfo object failed"));
                            delete pLocationInfo;
                        }
                    
                    }
                    else  // CComObject::CreateInstance failed
                    {
                        LOG((TL_ERROR, "EnumerateLocations - Create LocationInfo object failed"));
                    }

                    // Try next location in list
                    pEntry++;
                
                } //for(dwCount.....)
    
                
                //
                // return the Enumerator
                //
                *ppEnumLocation = pEnum;

            }
            else // LineGetTranslateCaps failed
            {
                LOG((TL_ERROR, "EnumerateLocations - LineGetTranslateCaps failed" ));
                pEnum->Release();
            }

        }
        else  // CComObject::CreateInstance failed
        {
            LOG((TL_ERROR, "EnumerateLocations - could not create enum" ));
        }


        // finished with TAPI memory block so release
        if ( pTranslateCaps != NULL )
                ClientFree( pTranslateCaps );
    }
    
    LOG((TL_TRACE, hr, "EnumerateLocations - exit" ));
    return hr;
}

STDMETHODIMP
CAddress::get_Locations( 
            VARIANT * pVariant
            )
{
    IEnumLocation         * pEnumLocation;
    HRESULT                 hr;
    CComObject< CTapiCollection< ITLocationInfo > >         * p;
    LocationArray           TempLocationArray;
    ITLocationInfo        * pLocation;
    
    
    if ( TAPIIsBadWritePtr( pVariant, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_locations - bad pointer"));

        return E_POINTER;
    }
    
    //
    // create collection object
    //
    CComObject< CTapiCollection< ITLocationInfo > >::CreateInstance( &p );

    if (NULL == p)
    {
        LOG((TL_ERROR, "get_Locations - could not create collection" ));
        
        return E_OUTOFMEMORY;
    }


    hr = EnumerateLocations ( &pEnumLocation );

    if ( !SUCCEEDED(hr) )
    {
        delete p;
        LOG((TL_ERROR, "get_locations - enumerate locations failed"));

        return hr;
    }

    while (TRUE)
    {
        hr = pEnumLocation->Next(1, &pLocation, NULL);

        if ( S_OK != hr )
        {
            break;
        }

        TempLocationArray.Add( pLocation );

        pLocation->Release();
    }

    pEnumLocation->Release();
    
    p->Initialize( TempLocationArray );

    TempLocationArray.Shutdown();
    
    IDispatch * pDisp;
    
    //
    // get the IDispatch interface
    //
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_Locations - could not get IDispatch interface" ));
        
        delete p;
        return hr;
    }

    //
    // put it in the variant
    //
    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDisp;

    LOG((TL_TRACE, "get_Locations exit - return success"));
    
    return S_OK;
    
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddressTranslation
// Method    : EnumerateCallingCards
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAddress::EnumerateCallingCards (IEnumCallingCard ** ppCallingCards )
{
    HRESULT                 hr = S_OK;
    LPLINETRANSLATECAPS     pTranslateCaps = NULL;
    DWORD                   dwNumCards;    
    DWORD                   dwCount;
    LPLINECARDENTRY         pEntry = NULL;
    
    PWSTR                   pszCardName;
    PWSTR                   pszSameAreaDialingRule;
    PWSTR                   pszLongDistanceDialingRule;
    PWSTR                   pszInternationalDialingRule;
    DWORD                   dwPermanentCardID;
    DWORD                   dwNumberOfDigits;
    DWORD                   dwOptions;

    
    LOG((TL_TRACE, "EnumerateCallingCards - enter" ));

    
    if ( TAPIIsBadWritePtr( ppCallingCards, sizeof(IEnumCallingCard *) ) )
    {
        LOG((TL_ERROR, "EnumerateCallingCards - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        //
        // create the enumerator
        //
        CComObject< CTapiEnum<IEnumCallingCard, ITCallingCard, &IID_IEnumCallingCard> > * pEnum;
        hr = CComObject< CTapiEnum<IEnumCallingCard, ITCallingCard, &IID_IEnumCallingCard> > ::CreateInstance( &pEnum );
    
        if ( SUCCEEDED(hr) )
        {
            //
            // initialize it with our Locations list
            //
            pEnum->Initialize();

            hr = LineGetTranslateCaps(m_hLineApp, TAPI_CURRENT_VERSION, &pTranslateCaps);
            if( SUCCEEDED(hr) )
            {
                dwNumCards = pTranslateCaps->dwNumCards ;    
        
                // Find positionn of 1st LINECARDENTRY  structure in the LINETRANSLATECAPS structure
                pEntry = (LPLINECARDENTRY) ((BYTE*)(pTranslateCaps) + pTranslateCaps->dwCardListOffset );
            
                for (dwCount = 0; dwCount < dwNumCards; dwCount++)
                {
                    // Pull Location Info out of LINECARDENTRY  structure
                    pszCardName                 = (PWSTR) ((BYTE*)(pTranslateCaps) + pEntry->dwCardNameOffset);
                    pszSameAreaDialingRule      = (PWSTR) ((BYTE*)(pTranslateCaps) + pEntry->dwSameAreaRuleOffset);
                    pszLongDistanceDialingRule  = (PWSTR) ((BYTE*)(pTranslateCaps) + pEntry->dwLongDistanceRuleOffset);
                    pszInternationalDialingRule = (PWSTR) ((BYTE*)(pTranslateCaps) + pEntry->dwInternationalRuleOffset);
                    dwPermanentCardID           = pEntry->dwPermanentCardID;
                    dwNumberOfDigits            = pEntry->dwCardNumberDigits;
                    dwOptions                   = pEntry->dwOptions;

                    // create our new CallingCard Object                
                    CComObject<CCallingCard> * pCallingCard;
                    CComObject<CCallingCard>::CreateInstance( &pCallingCard );
                    if (SUCCEEDED(hr) )
                    {
                        // initialize the new CallingCard Object
                        hr = pCallingCard->Initialize(
                                                       pszCardName,
                                                       pszSameAreaDialingRule,
                                                       pszLongDistanceDialingRule,
                                                       pszInternationalDialingRule,
                                                       dwPermanentCardID,
                                                       dwNumberOfDigits,
                                                       dwOptions
                                                      );
                        if (SUCCEEDED(hr) )
                        {
                            // Add it to the enumerator
                            hr = pEnum->Add(pCallingCard);
                            if (SUCCEEDED(hr))
                            {
                                LOG((TL_INFO, "EnumerateCallingCards - Added CallingCard object to enum"));
                            }
                            else
                            {
                                LOG((TL_INFO, "EnumertateCallingCards - Add CallingCard object failed"));
                                delete pCallingCard;
                            }
                        }
                        else
                        {
                            LOG((TL_ERROR, "EnumerateCallingCards - Init CallingCard object failed"));
                            delete pCallingCard;
                        }
                    
                    }
                    else  // CComObject::CreateInstance failed
                    {
                        LOG((TL_ERROR, "EnumerateCallingCards - Create CallingCard object failed"));
                    }

                    // Try next card in list
                    pEntry++;
                
                } //for(dwCount.....)
    
                
                //
                // return the Enumerator
                //
                *ppCallingCards = pEnum;
            }
            else // LineGetTranslateCaps failed
            {
                LOG((TL_ERROR, "EnumerateCallingCards - LineGetTranslateCaps failed" ));
                pEnum->Release();
            }

        }
        else  // CComObject::CreateInstance failed
        {
            LOG((TL_ERROR, "EnumerateCallingCards - could not create enum" ));
        }


        // finished with TAPI memory block so release
        if ( pTranslateCaps != NULL )
                ClientFree( pTranslateCaps );
    }
    LOG((TL_TRACE, hr, "EnumerateCallingCards - exit" ));
    return hr;
}

STDMETHODIMP
CAddress::get_CallingCards( 
            VARIANT * pVariant
            )
{
    IEnumCallingCard      * pEnumCallingCards;
    HRESULT                 hr;
    CComObject< CTapiCollection< ITCallingCard > >         * p;
    CallingCardArray        TempCallingCardArray;
    ITCallingCard         * pCallingCard;

    
    if ( TAPIIsBadWritePtr( pVariant, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_CallingCard - bad pointer"));

        return E_POINTER;
    }
    
    //
    // create collection object
    //
    CComObject< CTapiCollection< ITCallingCard > >::CreateInstance( &p );

    if (NULL == p)
    {
        LOG((TL_ERROR, "get_CallingCards - could not create collection" ));
        
        return E_OUTOFMEMORY;
    }


    hr = EnumerateCallingCards ( &pEnumCallingCards );

    if ( !SUCCEEDED(hr) )
    {
        delete p;
        LOG((TL_ERROR, "get_CallingCards - enumerate callingcards failed"));

        return hr;
    }

    while (TRUE)
    {
        hr = pEnumCallingCards->Next(1, &pCallingCard, NULL);

        if ( S_OK != hr )
        {
            break;
        }

        TempCallingCardArray.Add( pCallingCard );

        pCallingCard->Release();
    }

    pEnumCallingCards->Release();
    
    p->Initialize( TempCallingCardArray );

    TempCallingCardArray.Shutdown();
    
    IDispatch * pDisp;
    
    //
    // get the IDispatch interface
    //
    hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );

    if (S_OK != hr)
    {
        LOG((TL_ERROR, "get_CallingCards - could not get IDispatch interface" ));
        
        delete p;
        return hr;
    }

    //
    // put it in the variant
    //
    VariantInit(pVariant);
    pVariant->vt = VT_DISPATCH;
    pVariant->pdispVal = pDisp;

    LOG((TL_TRACE, "get_CallingCards exit - return success"));
    
    return S_OK;
    
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Method    : GetPhoneArrayFromTapiAndPrune
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::GetPhoneArrayFromTapiAndPrune( 
                                        PhoneArray *pPhoneArray,
                                        BOOL bPreferredOnly
                                       )
{
    HRESULT         hr;
    CTAPI         * pCTapi;
    ITPhone       * pPhone;
    CPhone        * pCPhone;

    LOG((TL_TRACE, "GetPhoneArrayFromTapiAndPrune enter"));

    if ( IsBadReadPtr( pPhoneArray, sizeof( PhoneArray ) ) )
    {
        LOG((TL_ERROR, "GetPhoneArrayFromTapiAndPrune - bad pointer"));

        return E_POINTER;
    }
               
    pCTapi = GetTapi();
    
    if( NULL == pCTapi )
    {
        LOG((TL_ERROR, "dynamic cast operation failed"));
        hr = E_POINTER;
    }
    else
    {   
        hr = pCTapi->GetPhoneArray( pPhoneArray );

        if ( SUCCEEDED(hr) )
        {
            //
            // Go through the phones
            //
            for(int iCount = 0; iCount < pPhoneArray->GetSize(); iCount++)
            {
                pPhone = (*pPhoneArray)[iCount];

                pCPhone = dynamic_cast<CPhone *>(pPhone);

                if ( NULL == pCPhone )
                {
                    //
                    // We have a bad pointer in our phone array.
                    // Lets skip it and move on.
                    //

                    _ASSERTE(FALSE);
                    continue;   
                }

                //
                // Is the phone on this address?
                //
                if ( bPreferredOnly ? pCPhone->IsPhoneOnPreferredAddress(this) : pCPhone->IsPhoneOnAddress(this) )
                {
                    LOG((TL_INFO, "GetPhoneArrayFromTapiAndPrune - found matching phone - %p", pPhone));
                }
                else
                {
                    // No, remove it from the array
                    pPhoneArray->RemoveAt(iCount);
                    iCount--;
                }
            }         
        }
    }

    LOG((TL_TRACE, "GetPhoneArrayFromTapiAndPrune - exit - return %lx", hr ));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress2
// Method    : get_Phones
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::get_Phones(
                     VARIANT * pPhones
                     )
{
    HRESULT         hr;
    IDispatch     * pDisp;
    PhoneArray      PhoneArray;

    LOG((TL_TRACE, "get_Phones enter"));

    if ( TAPIIsBadWritePtr( pPhones, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_Phones - bad pointer"));

        return E_POINTER;
    }

    hr = GetPhoneArrayFromTapiAndPrune( &PhoneArray, FALSE );
       
    if ( SUCCEEDED(hr) )
    {
        CComObject< CTapiCollection< ITPhone > > * p;
        CComObject< CTapiCollection< ITPhone > >::CreateInstance( &p );
    
        if (NULL == p)
        {
            LOG((TL_ERROR, "get_Phones - could not create collection" ));

            PhoneArray.Shutdown();
            return E_OUTOFMEMORY;
        }

        // get the IDispatch interface
        hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );

        if (S_OK != hr)
        {
            LOG((TL_ERROR, "get_Phones - could not get IDispatch interface" ));
        
            delete p;
            return hr;
        }

        Lock();
    
        // initialize
        hr = p->Initialize( PhoneArray );

        Unlock();

        PhoneArray.Shutdown();

        if (S_OK != hr)
        {
            LOG((TL_ERROR, "get_Phones - could not initialize collection" ));
        
            pDisp->Release();
            return hr;
        }

        // put it in the variant

        VariantInit(pPhones);
        pPhones->vt = VT_DISPATCH;
        pPhones->pdispVal = pDisp;
    }

    LOG((TL_TRACE, "get_Phones - exit - return %lx", hr ));
    
    return hr;
}
   
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress2
// Method    : EnumeratePhones
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::EnumeratePhones(
                          IEnumPhone ** ppEnumPhone
                          )
{
    HRESULT     hr;
    PhoneArray  PhoneArray;

    LOG((TL_TRACE, "EnumeratePhones - enter"));
    LOG((TL_TRACE, "   ppEnumPhone----->%p", ppEnumPhone ));

    if ( TAPIIsBadWritePtr( ppEnumPhone, sizeof( IEnumPhone * ) ) )
    {
        LOG((TL_ERROR, "EnumeratePhones - bad pointer"));

        return E_POINTER;
    }

    hr = GetPhoneArrayFromTapiAndPrune( &PhoneArray, FALSE );
       
    if ( SUCCEEDED(hr) )
    {
        //
        // create the enumerator
        //
        CComObject< CTapiEnum< IEnumPhone, ITPhone, &IID_IEnumPhone > > * p;

        try
        {
            hr = CComObject< CTapiEnum< IEnumPhone, ITPhone, &IID_IEnumPhone > >
                 ::CreateInstance( &p );
        }
        catch(...)
        {
            LOG((TL_ERROR, 
                "EnumeratePhones - failed to create phone enumeration. exception thrown." ));

            hr = E_OUTOFMEMORY;
        }

        if (S_OK != hr)
        {
            LOG((TL_ERROR, "EnumeratePhones - could not create enum" ));
        
            PhoneArray.Shutdown();
            return hr;
        }


        Lock();
    
        // initialize it with our phone list
        p->Initialize( PhoneArray );

        Unlock();

        PhoneArray.Shutdown();

        //
        // return it
        //
        *ppEnumPhone = p;
    }

    LOG((TL_TRACE, "EnumeratePhones - exit - return %lx", hr ));
    
    return hr;
} 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress2
// Method    : get_PreferredPhones
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::get_PreferredPhones(
                              VARIANT * pPhones
                             )
{
    HRESULT         hr;
    IDispatch     * pDisp;
    PhoneArray      PhoneArray;

    LOG((TL_TRACE, "get_PreferredPhones enter"));

    if ( TAPIIsBadWritePtr( pPhones, sizeof( VARIANT ) ) )
    {
        LOG((TL_ERROR, "get_PreferredPhones - bad pointer"));

        return E_POINTER;
    }

    hr = GetPhoneArrayFromTapiAndPrune( &PhoneArray, TRUE );
       
    if ( SUCCEEDED(hr) )
    {
        CComObject< CTapiCollection< ITPhone > > * p;
        CComObject< CTapiCollection< ITPhone > >::CreateInstance( &p );
    
        if (NULL == p)
        {
            LOG((TL_ERROR, "get_PreferredPhones - could not create collection" ));

            PhoneArray.Shutdown();
            return E_OUTOFMEMORY;
        }

        // get the IDispatch interface
        hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );

        if (S_OK != hr)
        {
            LOG((TL_ERROR, "get_PreferredPhones - could not get IDispatch interface" ));
        
            delete p;
            return hr;
        }

        Lock();
    
        // initialize
        hr = p->Initialize( PhoneArray );

        Unlock();

        PhoneArray.Shutdown();

        if (S_OK != hr)
        {
            LOG((TL_ERROR, "get_PreferredPhones - could not initialize collection" ));
        
            pDisp->Release();
            return hr;
        }

        // put it in the variant

        VariantInit(pPhones);
        pPhones->vt = VT_DISPATCH;
        pPhones->pdispVal = pDisp;
    }

    LOG((TL_TRACE, "get_PreferredPhones - exit - return %lx", hr ));
    
    return hr;
}
   
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress2
// Method    : EnumeratePreferredPhones
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::EnumeratePreferredPhones(
                                   IEnumPhone ** ppEnumPhone
                                  )
{
    HRESULT     hr;
    PhoneArray  PhoneArray;

    LOG((TL_TRACE, "EnumeratePreferredPhones - enter"));
    LOG((TL_TRACE, "   ppEnumPhone----->%p", ppEnumPhone ));

    if ( TAPIIsBadWritePtr( ppEnumPhone, sizeof( IEnumPhone * ) ) )
    {
        LOG((TL_ERROR, "EnumeratePreferredPhones - bad pointer"));

        return E_POINTER;
    }

    hr = GetPhoneArrayFromTapiAndPrune( &PhoneArray, TRUE );
       
    if ( SUCCEEDED(hr) )
    {
        //
        // create the enumerator
        //
        CComObject< CTapiEnum< IEnumPhone, ITPhone, &IID_IEnumPhone > > * p;
        hr = CComObject< CTapiEnum< IEnumPhone, ITPhone, &IID_IEnumPhone > >
             ::CreateInstance( &p );

        if (S_OK != hr)
        {
            LOG((TL_ERROR, "EnumeratePreferredPhones - could not create enum" ));
        
            PhoneArray.Shutdown();
            return hr;
        }


        Lock();
    
        // initialize it with our phone list
        p->Initialize( PhoneArray );

        Unlock();

        PhoneArray.Shutdown();

        //
        // return it
        //
        *ppEnumPhone = p;
    }

    LOG((TL_TRACE, "EnumeratePreferredPhones - exit - return %lx", hr ));
    
    return hr;
} 

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress2
// Method    : GetPhoneFromTerminal
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CAddress::GetPhoneFromTerminal(
                             ITTerminal * pTerminal,
                             ITPhone ** ppPhone
                            )
{
    HRESULT     hr = E_FAIL;
    PhoneArray  PhoneArray;
    ITStaticAudioTerminal * pStaticAudioTerminal;
    LONG lMediaType;
    TERMINAL_DIRECTION nDir;

    LOG((TL_TRACE, "GetPhoneFromTerminal - enter"));

    if ( TAPIIsBadWritePtr( ppPhone, sizeof( ITPhone * ) ) ||
         IsBadReadPtr( pTerminal, sizeof( ITTerminal ) ) )
    {
        LOG((TL_ERROR, "GetPhoneFromTerminal - bad pointer"));

        return E_POINTER;
    }

    *ppPhone = NULL;

    if ( SUCCEEDED(pTerminal->get_MediaType(&lMediaType)) &&
         SUCCEEDED(pTerminal->get_Direction(&nDir))  &&
         (lMediaType == TAPIMEDIATYPE_AUDIO) )
    {
        hr = pTerminal->QueryInterface(IID_ITStaticAudioTerminal, (void **) &pStaticAudioTerminal);

        if ( SUCCEEDED(hr) )
        {
            LONG lWaveId;
    
            hr = pStaticAudioTerminal->get_WaveId(&lWaveId);
   
            if ( SUCCEEDED(hr) )
            {
                LOG((TL_INFO, "GetPhoneFromTerminal - got terminal wave id %d", lWaveId));
               
                hr = GetPhoneArrayFromTapiAndPrune( &PhoneArray, FALSE );

                if ( SUCCEEDED(hr) )
                {
                    ITPhone               * pPhone;
                    CPhone                * pCPhone;
                    int                     iPhoneCount;

                    hr = TAPI_E_NODEVICE;

                    for(iPhoneCount = 0; iPhoneCount < PhoneArray.GetSize(); iPhoneCount++)
                    {
                        pPhone = PhoneArray[iPhoneCount];

                        pCPhone = dynamic_cast<CPhone *>(pPhone);

                        if ( NULL == pCPhone )
                        {
                            //
                            // We have a bad pointer in our phone array.
                            // Lets skip it and move on.
                            //

                            _ASSERTE(FALSE);
                            continue;
                        }

                        if (pCPhone->IsPhoneUsingWaveID( lWaveId, nDir ))
                        {
                            *ppPhone = pPhone;

                            pPhone->AddRef();

                            hr = S_OK;
                            break;
                        }
                    }

                    PhoneArray.Shutdown();
                }
            }

            pStaticAudioTerminal->Release();
        }
    }
  
    LOG((TL_TRACE, "GetPhoneFromTerminal - exit - return %lx", hr ));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress2
// Method    : put_EventFilter
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::put_EventFilter(
    TAPI_EVENT      TapiEvent,
    long            lSubEvent,
    VARIANT_BOOL    bEnable
    )
{
    LOG((TL_TRACE, "put_EventFilter - enter"));

    //
    // Validates the pair TapiEvent - lSubEvent
    // Accept also all subevents
    //
    if( !m_EventMasks.IsSubEventValid( TapiEvent, lSubEvent, TRUE, FALSE) )
    {
        LOG((TL_ERROR, "put_EventFilter - "
            "This event can't be set: %x, return E_INVALIDARG", TapiEvent ));
        return E_INVALIDARG;
    }

    // Enter critical section
    Lock();

    // Set the subevent flag
    HRESULT hr = E_FAIL;
    hr = SetSubEventFlag( 
        TapiEvent, 
        (DWORD)lSubEvent, 
        (bEnable == VARIANT_TRUE)
        );
    
    // Leave critical section
    Unlock();

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress2
// Method    : get_EventFilter
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::get_EventFilter(
        TAPI_EVENT      TapiEvent,
        long            lSubEvent,
        VARIANT_BOOL*   pEnable
        )
{
    LOG((TL_TRACE, "get_EventFilter - enter"));

    //
    // Validates output argument
    //
    if( IsBadReadPtr(pEnable, sizeof(VARIANT_BOOL)) )
    {
        LOG((TL_ERROR, "get_EventFilter - "
            "invalid VARIANT_BOOL pointer, return E_POINTER" ));
        return E_POINTER;
    }

    //
    // Validates the pair TapiEvent - lSubEvent
    // Don't accept all subevents
    //
    if( !m_EventMasks.IsSubEventValid( TapiEvent, lSubEvent, FALSE, FALSE) )
    {
        LOG((TL_ERROR, "get_EventFilter - "
            "This event can't be set: %x, return E_INVALIDARG", TapiEvent ));
        return E_INVALIDARG;
    }

    // Enter critical section
    Lock();

    //
    // Get the subevent mask for that (event, subevent) pair
    //

    BOOL bEnable = FALSE;
    HRESULT hr = GetSubEventFlag(
        TapiEvent,
        (DWORD)lSubEvent,
        &bEnable);

    if( FAILED(hr) )
    {
        LOG((TL_ERROR, "get_EventFilter - "
            "GetSubEventFlag failed, return 0x%08x", hr ));

        // Leave critical section
        Unlock();

        return hr;
    }

    //
    // Set the output argument
    //

    *pEnable = bEnable ? VARIANT_TRUE : VARIANT_FALSE;

    // Leave critical section
    Unlock();

    LOG((TL_TRACE, "get_EventFilter - exit S_OK"));
    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress2
// Method    : DeviceSpecific
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CAddress::DeviceSpecific(
	     IN ITCallInfo *pCall,
	     IN BYTE *pbDataArray,
	     IN DWORD dwSize
        )
{

    LOG((TL_TRACE, "DeviceSpecific - enter"));


    //
    // check if arguments are any good
    //

    if ( NULL == pbDataArray )
    {
        LOG((TL_ERROR, "DeviceSpecific - pbDataArray is NULL. E_INVALIDARG"));

        return E_INVALIDARG;
    }

    if ( 0 == dwSize )
    {
        LOG((TL_ERROR, "DeviceSpecific - dwSize is 0. E_INVALIDARG"));

        return E_INVALIDARG;
    }

    //
    // check if the buffer is valid
    //

    if ( IsBadReadPtr(pbDataArray, dwSize) )
    {
        LOG((TL_ERROR,
            "DeviceSpecific - bad array passed in [%p] of size %ld",
            pbDataArray, dwSize));

        return E_POINTER;
    }


    //
    // see if the call is obviously bad, and try to get call object pointer if 
    // it is good
    //

    CCall *pCallObject = NULL;

    if (  (NULL != pCall)  )
    {

        //
        // does it point to readable memory at all?
        //
        if ( IsBadReadPtr(pCall, sizeof(ITCallInfo)) )
        {
            LOG((TL_ERROR, "DeviceSpecific - unreadable call pointer [%p]", pCall));

            return E_POINTER;
        }


        //
        // see if call is pointing to a real call object
        //

        try
        {

            pCallObject = dynamic_cast<CCall*>(pCall);
        }
        catch (...)
        {

            //
            // call pointer is really really bad
            //

            LOG((TL_ERROR,
                "DeviceSpecific - exception casting call pointer to a call object, bad call [%p]", 
                pCall));
        }


        //
        // if we could not get the call object pointer, this is not a good call
        //

        if (NULL == pCallObject)
        {

            LOG((TL_ERROR, 
                "DeviceSpecific - could not get call object from call pointer -- bad call pointer argument [%p]", 
                pCall));

            return E_POINTER;

        }


    } // received call pointer that is NULL?
    


    //
    // by this point we know pCall is either NULL or we have a call pointer 
    // that seems (but not guaranteed) to be good
    //


    //
    // prepare all the data for the call to lineDevSpecific
    //
    

    //
    // get hcall from the call
    //

    HCALL hCall = NULL;

    if (NULL != pCallObject)
    {
        hCall = pCallObject->GetHCall();


        //
        // if we there is no call handle, return an error -- the app did not 
        // called Connect on the call
        //

        if (NULL == hCall)
        {
            LOG((TL_ERROR, 
                "DeviceSpecific - no call handle. hr = TAPI_E_INVALCALLSTATE",
                pCall));

            return TAPI_E_INVALCALLSTATE;
        }
    }


    //
    // starting to access data members. lock.
    //

    Lock();


    //
    // get a line to use to communicate devspecific information
    //

    AddressLineStruct *pAddressLine = NULL;

    HRESULT hr = FindOrOpenALine(m_dwMediaModesSupported, &pAddressLine);

    if (FAILED(hr))
    {

        Unlock();

        LOG((TL_TRACE, "DeviceSpecific - FindOrOpenALine failed. hr = %lx", hr));

        return hr;
    }


    DWORD dwAddressID = m_dwAddressID;

    Unlock();


    //
    // make the tapisrv call
    //

    hr = lineDevSpecific( pAddressLine->t3Line.hLine,
                          dwAddressID,
                          hCall,
                          pbDataArray,
                          dwSize
                        );


    //
    // no longer need the line. if registered for address notifications, the 
    // line will remain opened. otherwise, if no one has the line open, it will
    // close -- we are not processing incoming events anyway.
    //

    MaybeCloseALine(&pAddressLine);


    LOG((TL_TRACE, "DeviceSpecific - exit. hr = %lx", hr));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress2
// Method    : DeviceSpecificVariant
//
// this is the scriptable version of DeviceSpecific
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CAddress::DeviceSpecificVariant(
	     IN ITCallInfo *pCall,
	     IN VARIANT varDevSpecificByteArray
        )
{
    LOG((TL_TRACE, "DeviceSpecificVariant - enter"));


    //
    // extract buffer from the variant
    //

    DWORD dwByteArraySize = 0;
    BYTE *pBuffer = NULL;

    HRESULT hr = E_FAIL;
    
    hr = MakeBufferFromVariant(varDevSpecificByteArray, &dwByteArraySize, &pBuffer);

    if (FAILED(hr))
    {
        LOG((TL_TRACE, "DeviceSpecificVariant - MakeBufferFromVariant failed. hr = %lx", hr));

        return hr;
    }


    //
    // call the non-scriptable version and pass it the nonscriptable implementation
    //
    
    hr = DeviceSpecific(pCall, pBuffer, dwByteArraySize);


    //
    // success or failure, free the buffer allocated by MakeBufferFromVariant
    //

    ClientFree(pBuffer);
    pBuffer = NULL;


    //
    // log rc and exit
    //

    LOG((TL_TRACE, "DeviceSpecificVariant - exit. hr = %lx", hr));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITAddress2
// Method    : NegotiateExtVersion
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HRESULT CAddress::NegotiateExtVersion (
	     IN long lLowVersion,
	     IN long lHighVersion,
	     OUT long *plExtVersion
        )
{
    
    LOG((TL_TRACE, "NegotiateExtVersion - enter"));

    
    //
    // make sure the out parameter is writable
    //

    if (IsBadWritePtr(plExtVersion, sizeof(long)) )
    {
        LOG((TL_ERROR, "NegotiateExtVersion - output arg [%p] not writeable", plExtVersion));

        return E_POINTER;
    }


    Lock();


    //
    // make a call to tapisrv
    //

    DWORD dwNegotiatedVersion = 0;

    LONG lResult = lineNegotiateExtVersion( m_hLineApp, 
                                            m_dwDeviceID, 
                                            m_dwAPIVersion, 
                                            lLowVersion, 
                                            lHighVersion, 
                                            &dwNegotiatedVersion );

    Unlock();


    HRESULT hr = mapTAPIErrorCode(lResult);


    //
    // return the value on success
    //

    if ( SUCCEEDED(hr) )
    {
        LOG((TL_TRACE, "NegotiateExtVersion - negotiated version %ld", dwNegotiatedVersion));

        *plExtVersion = dwNegotiatedVersion;
    }


    LOG((TL_TRACE, "NegotiateExtVersion - exit. hr = %lx", hr));

    return hr;
}


//
//  ----------------------- CAddressTranslationInfo -----------------------------
//


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddressTranslationInfo
// Method    : Initialize
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddressTranslationInfo::Initialize(
                       PWSTR pszDialableString,                  
                       PWSTR pszDisplayableString,               
                       DWORD dwCurrentCountry, 
                       DWORD dwDestCountry,    
                       DWORD dwTranslateResults
                      )
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "Initialize - enter" ));
    Lock();

    m_dwCurrentCountryCode      = dwCurrentCountry;
    m_dwDestinationCountryCode  = dwDestCountry;
    m_dwTranslationResults      = dwTranslateResults;
    m_szDialableString          = NULL;
    m_szDialableString          = NULL;

    // copy the Dialable String 
    if (pszDialableString!= NULL)
    {
        m_szDialableString = (PWSTR) ClientAlloc((lstrlenW(pszDialableString) + 1) * sizeof (WCHAR));
        if (m_szDialableString != NULL)
        {
            lstrcpyW(m_szDialableString, pszDialableString);

            // Now copy the Displayable String 
            if (pszDisplayableString!= NULL)
            {
                m_szDisplayableString = (PWSTR) ClientAlloc((lstrlenW(pszDisplayableString) + 1) * sizeof (WCHAR));
                if (m_szDisplayableString != NULL)
                {
                    lstrcpyW(m_szDisplayableString, pszDisplayableString);
                }
                else
                {
                    LOG((TL_ERROR, "Initialize - Alloc m_szDisplayableString failed" ));
                    ClientFree( pszDialableString );
                    pszDialableString = NULL;
                    hr = E_OUTOFMEMORY;
                }
            }
    
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szDialableString failed" ));
            hr = E_OUTOFMEMORY;
        }
    }


    Unlock();
    LOG((TL_TRACE, hr, "Initialize - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddressTranslationInfo
// Method    : FinalRelease
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CAddressTranslationInfo::FinalRelease()
{
    LOG((TL_TRACE, "FinalRelease - enter" ));
    

    if (m_szDialableString != NULL)
    {
        ClientFree( m_szDialableString);
    }

    if (m_szDisplayableString != NULL)
    {
        ClientFree( m_szDisplayableString);
    }

    LOG((TL_TRACE, "FinalRelease - exit" ));
    }


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddressTranslationInfo
// Interface : ITAddressTranslationInfo
// Method    : get_CurrentCountryCode
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddressTranslationInfo::get_CurrentCountryCode(long * CountryCode  )
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_CurrentCountryCode - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( CountryCode  , sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_CurrentCountryCode - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *CountryCode  = m_dwCurrentCountryCode;
    }
    
    Unlock();
    LOG((TL_TRACE, hr, "get_CurrentCountryCode - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddressTranslationInfo
// Interface : ITAddressTranslationInfo
// Method    : get_DestinationCountryCode
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddressTranslationInfo::get_DestinationCountryCode(long * CountryCode  )
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_DestinationCountryCode - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( CountryCode  , sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_DestinationCountryCode - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *CountryCode  = m_dwDestinationCountryCode;
    }
    Unlock();
    LOG((TL_TRACE, hr, "get_DestinationCountryCode - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddressTranslationInfo
// Interface : ITAddressTranslationInfo
// Method    : get_TranslationResult
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddressTranslationInfo::get_TranslationResults(long * Results  )
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_TranslationResults - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( Results  , sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_TranslationResults - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *Results  = m_dwTranslationResults;
    }
    Unlock();
    LOG((TL_TRACE, hr, "get_TranslationResults - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddressTranslationInfo
// Interface : ITAddressTranslationInfo
// Method    : get_DialableString
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddressTranslationInfo::get_DialableString(BSTR * ppDialableString)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_DialableString - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppDialableString, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_DialableString - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppDialableString = SysAllocString( m_szDialableString );

        if ( ( NULL == *ppDialableString ) && ( NULL != m_szDialableString ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    Unlock();
    
    

    LOG((TL_TRACE, hr, "get_DialableString - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddressTranslationInfo
// Interface : ITAddressTranslationInfo
// Method    : get_DisplayableString
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddressTranslationInfo::get_DisplayableString(BSTR * ppDisplayableString)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_DisplayableString - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppDisplayableString, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_DisplayableString - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppDisplayableString = SysAllocString( m_szDisplayableString );
        
        if ( ( NULL == *ppDisplayableString ) && ( NULL != m_szDisplayableString ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }

    }
    Unlock();
    LOG((TL_TRACE, hr, "get_DisplayableString - exit" ));

    return hr;
}




//
//  ----------------------- CCallingCard -----------------------------
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCallingCard
// Method    : Initialize
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CCallingCard::Initialize(
                       PWSTR pszCardName,
                       PWSTR pszSameAreaDialingRule,
                       PWSTR pszLongDistanceDialingRule,
                       PWSTR pszInternationalDialingRule,
                       DWORD dwPermanentCardID,
                       DWORD dwNumberOfDigits,
                       DWORD dwOptions
                      )
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "Initialize - enter" ));
    Lock();

    m_dwPermanentCardID             = dwPermanentCardID;
    m_dwNumberOfDigits              = dwNumberOfDigits;
    m_dwOptions                     = dwOptions;
    m_szCardName                    = NULL;
    m_szSameAreaDialingRule         = NULL;
    m_szLongDistanceDialingRule     = NULL;
    m_szInternationalDialingRule    = NULL;


    // copy the Card Name
    if (pszCardName != NULL)
    {
        m_szCardName = (PWSTR) ClientAlloc((lstrlenW(pszCardName) + 1) * sizeof (WCHAR));
        if (m_szCardName != NULL)
        {
            lstrcpyW(m_szCardName, pszCardName);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szCardName failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    // copy the Same Area Dialing Rule
    if (pszSameAreaDialingRule != NULL)
    {
        m_szSameAreaDialingRule = (PWSTR) ClientAlloc((lstrlenW(pszSameAreaDialingRule) + 1) * sizeof (WCHAR));
        if (m_szSameAreaDialingRule != NULL)
        {
            lstrcpyW(m_szSameAreaDialingRule, pszSameAreaDialingRule);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szSameAreaDialingRule failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    // copy the Long Distance Dialing Rule
    if (pszLongDistanceDialingRule != NULL)
    {
        m_szLongDistanceDialingRule = (PWSTR) ClientAlloc((lstrlenW(pszLongDistanceDialingRule) + 1) * sizeof (WCHAR));
        if (m_szLongDistanceDialingRule != NULL)
        {
            lstrcpyW(m_szLongDistanceDialingRule, pszLongDistanceDialingRule);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szLongDistanceDialingRule failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    //copy the International Dialing Rule
    if (pszInternationalDialingRule != NULL)
    {
        m_szInternationalDialingRule = (PWSTR) ClientAlloc((lstrlenW(pszInternationalDialingRule) + 1) * sizeof (WCHAR));
        if (m_szInternationalDialingRule != NULL)
        {
            lstrcpyW(m_szInternationalDialingRule, pszInternationalDialingRule);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szInternationalDialingRule failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    Unlock();
    LOG((TL_TRACE, hr, "Initialize - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCallingCard
// Method    : FinalRelease
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CCallingCard::FinalRelease()
{
    LOG((TL_TRACE, "FinalRelease - enter" ));
    
    if (m_szCardName != NULL)
    {
        ClientFree(m_szCardName);
    }

    if (m_szSameAreaDialingRule != NULL)
    {
        ClientFree(m_szSameAreaDialingRule);
    }
    
    if (m_szLongDistanceDialingRule != NULL)
    {
        ClientFree(m_szLongDistanceDialingRule);
    }
    
    if (m_szInternationalDialingRule != NULL)
    {
        ClientFree(m_szInternationalDialingRule);
    }

    LOG((TL_TRACE, "FinalRelease - exit" ));
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCallingCard
// Interface : ITCallingCard
// Method    : get_PermanentCardID
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCallingCard::get_PermanentCardID(long * ulCardID)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_PermanentCardID - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ulCardID, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_PermanentCardID - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ulCardID= m_dwPermanentCardID;
    }
    Unlock();
    LOG((TL_TRACE, hr, "get_PermanentCardID - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCallingCard
// Interface : ITCallingCard
// Method    : get_NumberOfDigits
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCallingCard::get_NumberOfDigits(long * ulDigits)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_NumberOfDigits - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ulDigits, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_NumberOfDigits - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ulDigits= m_dwNumberOfDigits;
    }
    Unlock();
    LOG((TL_TRACE, hr, "get_NumberOfDigits - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCallingCard
// Interface : ITCallingCard
// Method    : get_Options
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCallingCard::get_Options(long * ulOptions)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_Options - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ulOptions, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_Options - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ulOptions= m_dwOptions;
    }
    Unlock();
    LOG((TL_TRACE, hr, "get_Options - exit" ));

    return hr;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCallingCard
// Interface : ITCallingCard
// Method    : get_CardName
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCallingCard::get_CardName(BSTR * ppCardName)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_CardName - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppCardName, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_CardName - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppCardName = SysAllocString( m_szCardName );

        if ( ( NULL == *ppCardName ) && ( NULL != m_szCardName ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    Unlock();
        
    
    LOG((TL_TRACE, hr, "get_CardName - exit" ));

    return hr;
}


    
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCallingCard
// Interface : ITCallingCard
// Method    : get_SameAreaDialingRule
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCallingCard::get_SameAreaDialingRule(BSTR * ppRule)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_SameAreaDialingRule - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppRule, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_SameAreaDialingRule - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppRule = SysAllocString( m_szSameAreaDialingRule );

        if ( ( NULL == *ppRule ) && ( NULL != m_szSameAreaDialingRule ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    Unlock();

    LOG((TL_TRACE, hr, "get_SameAreaDialingRule - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCallingCard
// Interface : ITCallingCard
// Method    : get_LongDistanceDialingRule
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCallingCard::get_LongDistanceDialingRule(BSTR * ppRule)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_LongDistanceDialingRule - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppRule, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_LongDistanceDialingRule - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppRule = SysAllocString( m_szLongDistanceDialingRule );

        if ( ( NULL == *ppRule ) && ( NULL != m_szLongDistanceDialingRule ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }

    }
    Unlock();

    LOG((TL_TRACE, hr, "get_LongDistanceDialingRule - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CCallingCard
// Interface : ITCallingCard
// Method    : get_InternationalDialingRule
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CCallingCard::get_InternationalDialingRule(BSTR * ppRule)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_InternationalDialingRule - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppRule, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_InternationalDialingRule - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppRule = SysAllocString( m_szInternationalDialingRule );

        if ( ( NULL == *ppRule ) && ( NULL != m_szInternationalDialingRule ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    Unlock();

    LOG((TL_TRACE, hr, "get_InternationalDialingRule - exit" ));

    return hr;
}





//
//  ----------------------- CLocationInfo -----------------------------
//


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Method    : Initialize
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CLocationInfo::Initialize(
                       PWSTR pszLocationName, 
                       PWSTR pszCityCode, 
                       PWSTR pszLocalAccessCode, 
                       PWSTR pszLongDistanceAccessCode, 
                       PWSTR pszTollPrefixList, 
                       PWSTR pszCancelCallWaitingCode , 
                       DWORD dwPermanentLocationID,
                       DWORD dwCountryCode,
                       DWORD dwPreferredCardID,
                       DWORD dwCountryID,
                       DWORD dwOptions
                      )
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "Initialize - enter" ));
    Lock();

    m_dwPermanentLocationID     = dwPermanentLocationID;
    m_dwCountryCode             = dwCountryCode;
    m_dwPreferredCardID         = dwPreferredCardID;
    m_dwCountryID               = dwCountryID;
    m_dwOptions                 = dwOptions;
    m_szLocationName            = NULL;
    m_szCityCode                = NULL;
    m_szLocalAccessCode         = NULL;
    m_szLongDistanceAccessCode  = NULL;
    m_szTollPrefixList          = NULL;
    m_szCancelCallWaitingCode   = NULL;

    // copy the Location Name
    if (pszLocationName!= NULL)
    {
        m_szLocationName = (PWSTR) ClientAlloc((lstrlenW(pszLocationName) + 1) * sizeof (WCHAR));
        if (m_szLocationName != NULL)
        {
            lstrcpyW(m_szLocationName, pszLocationName);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szDialableString failed" ));
            hr = E_OUTOFMEMORY;
        }
    }


    // copy the City Code
    if (pszCityCode != NULL)
    {
        m_szCityCode  = (PWSTR) ClientAlloc((lstrlenW(pszCityCode) + 1) * sizeof (WCHAR));
        if (m_szCityCode  != NULL)
        {
            lstrcpyW(m_szCityCode , pszCityCode);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szCityCode  failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    // copy the Local Access Code
    if (pszLocalAccessCode != NULL)
    {
        m_szLocalAccessCode = (PWSTR) ClientAlloc((lstrlenW(pszLocalAccessCode) + 1) * sizeof (WCHAR));
        if (m_szLocalAccessCode != NULL)
        {
            lstrcpyW(m_szLocalAccessCode, pszLocalAccessCode);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szLocalAccessCode failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    // copy the Long Distance Access Code
    if (pszLongDistanceAccessCode != NULL)
    {
        m_szLongDistanceAccessCode = (PWSTR) ClientAlloc((lstrlenW(pszLongDistanceAccessCode) + 1) * sizeof (WCHAR));
        if (m_szLongDistanceAccessCode != NULL)
        {
            lstrcpyW(m_szLongDistanceAccessCode, pszLongDistanceAccessCode);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szLongDistanceAccessCode failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    // copy the Toll Prefix List
    if (pszTollPrefixList != NULL)
    {
        m_szTollPrefixList = (PWSTR) ClientAlloc((lstrlenW(pszTollPrefixList) + 1) * sizeof (WCHAR));
        if (m_szTollPrefixList != NULL)
        {
            lstrcpyW(m_szTollPrefixList, pszTollPrefixList);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szTollPrefixList failed" ));
            hr = E_OUTOFMEMORY;
        }
    }

    // copy the Cancel Call Waiting Code
    if (pszCancelCallWaitingCode != NULL)
    {
        m_szCancelCallWaitingCode = (PWSTR) ClientAlloc((lstrlenW(pszCancelCallWaitingCode) + 1) * sizeof (WCHAR));
        if (m_szCancelCallWaitingCode != NULL)
        {
            lstrcpyW(m_szCancelCallWaitingCode, pszCancelCallWaitingCode);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szCancelCallWaitingCode failed" ));
            hr = E_OUTOFMEMORY;
        }
    }


    Unlock();
    LOG((TL_TRACE, hr, "Initialize - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Method    : FinalRelease
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CLocationInfo::FinalRelease()
{
    LOG((TL_TRACE, "FinalRelease - enter" ));
    

    if (m_szLocationName != NULL)
    {
        ClientFree( m_szLocationName);
    }

    if (m_szCityCode != NULL)
    {
        ClientFree( m_szCityCode);
    }
    
    if (m_szLocalAccessCode != NULL)
    {
        ClientFree( m_szLocalAccessCode);
    }
    
    if (m_szLongDistanceAccessCode != NULL)
    {
        ClientFree( m_szLongDistanceAccessCode);
    }
    
    if (m_szTollPrefixList != NULL)
    {
        ClientFree( m_szTollPrefixList);
    }
    
    if (m_szCancelCallWaitingCode != NULL)
    {
        ClientFree( m_szCancelCallWaitingCode);
    }

    LOG((TL_TRACE, "FinalRelease - exit" ));
}





//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_PermanentLocationID
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_PermanentLocationID(long * ulLocationID )
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_PermanentLocationID - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ulLocationID , sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_PermanentLocationID - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ulLocationID = m_dwPermanentLocationID;
    }
    Unlock();
    LOG((TL_TRACE, hr, "get_PermanentLocationID - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_CountryCode
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_CountryCode(long * ulCountryCode)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_CountryCode - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ulCountryCode, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_CountryCode - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ulCountryCode= m_dwCountryCode;
    }
    Unlock();
    LOG((TL_TRACE, hr, "get_CountryCode - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_CountryID
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_CountryID(long * ulCountryID)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_CountryID - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ulCountryID, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_CountryID - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ulCountryID= m_dwCountryID;
    }
    Unlock();
    LOG((TL_TRACE, hr, "get_CountryID - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_Options
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_Options(long * Options)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_Options - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( Options, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_Options - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *Options= m_dwOptions;
    }
    Unlock();
    LOG((TL_TRACE, hr, "get_Options - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_PreferredCardID
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_PreferredCardID(long * ulCardID)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_PreferredCardID - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ulCardID, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_PreferredCardID - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ulCardID= m_dwPreferredCardID;
    }
    Unlock();
    LOG((TL_TRACE, hr, "get_PreferredCardID - exit" ));

    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_LocationName
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_LocationName(BSTR * ppLocationName)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_LocationName - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppLocationName, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_LocationName - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppLocationName = SysAllocString( m_szLocationName );

        if ( ( NULL == *ppLocationName ) && ( NULL != m_szLocationName ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    Unlock();
    
    
    
    LOG((TL_TRACE, hr, "gget_LocationName - exit" ));

    return hr;
}
    
    
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_CityCode
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_CityCode(BSTR * ppCode)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_CityCode - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppCode, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_CityCode - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppCode = SysAllocString( m_szCityCode );

        if ( ( NULL == *ppCode ) && ( NULL != m_szCityCode ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    Unlock();
    
    LOG((TL_TRACE, hr, "get_CityCode - exit" ));

    return hr;
}
    

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_LocalAccessCode
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_LocalAccessCode(BSTR * ppCode)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_LocalAccessCode - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppCode, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_LocalAccessCode - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppCode = SysAllocString( m_szLocalAccessCode );

        if ( ( NULL == *ppCode ) && ( NULL != m_szLocalAccessCode ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    Unlock();
   

    LOG((TL_TRACE, hr, "get_LocalAccessCode - exit" ));

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_LongDistanceAccessCode
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_LongDistanceAccessCode(BSTR * ppCode )
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_LongDistanceAccessCode - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppCode , sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_LongDistanceAccessCode - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppCode = SysAllocString( m_szLongDistanceAccessCode);

        if ( ( NULL == *ppCode ) && ( NULL != m_szLongDistanceAccessCode ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    Unlock();

    LOG((TL_TRACE, hr, "get_LongDistanceAccessCode - exit" ));

    return hr;
}
    

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_TollPrefixList
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_TollPrefixList(BSTR * ppTollList)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_TollPrefixList - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppTollList, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_TollPrefixList - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppTollList = SysAllocString( m_szTollPrefixList );

        if ( ( NULL == *ppTollList ) && ( NULL != m_szTollPrefixList ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    Unlock();

    LOG((TL_TRACE, hr, "get_TollPrefixList - exit" ));

    return hr;
}
    

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CLocationInfo
// Interface : ITLocationInfo
// Method    : get_CancelCallWaitingCode
//
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CLocationInfo::get_CancelCallWaitingCode(BSTR * ppCode)
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "get_CancelCallWaitingCode - enter" ));
    Lock();

    if ( TAPIIsBadWritePtr( ppCode, sizeof(BSTR) ) )
    {
        LOG((TL_ERROR, "get_CancelCallWaitingCode - Bad Pointer" ));
        hr = E_POINTER;
    }
    else // Ok Pointer
    {
        *ppCode = SysAllocString( m_szCancelCallWaitingCode );

        if ( ( NULL == *ppCode ) && ( NULL != m_szCancelCallWaitingCode ) )
        {
            LOG((TL_TRACE, "SysAllocString Failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    Unlock();
    
    LOG((TL_TRACE, hr, "get_CancelCallWaitingCode - exit" ));

    return hr;
}

BOOL
CAddress::GetMediaMode( long lMediaType, DWORD * pdwMediaMode )
{
    DWORD dwRet = (DWORD)lMediaType;
    DWORD dwHold;

    if (dwRet & AUDIOMEDIAMODES)
    {
        dwHold = m_dwMediaModesSupported & AUDIOMEDIAMODES;

        if ( dwHold == AUDIOMEDIAMODES )
        {
            dwHold = LINEMEDIAMODE_AUTOMATEDVOICE;
        }
        
        dwRet &= ~AUDIOMEDIAMODES;
        dwRet |= dwHold;
    }

    *pdwMediaMode = dwRet;

    if ( (dwRet == 0) ||
         ((dwRet & m_dwMediaModesSupported) != dwRet) ) 
    {
        return FALSE;
    }

    return TRUE;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_LineID
//
// returns the tapi 2 device ID for this line
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_LineID(
                     long * plLineID
                    )
{
    LOG((TL_TRACE, "get_LineID - enter"));
    
    if ( TAPIIsBadWritePtr( plLineID, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_LineID - bad pointer"));

        return E_POINTER;
    }

    Lock();

    *plLineID = m_dwDeviceID;

    Unlock();

    LOG((TL_TRACE, "get_LineID - exit"));

    return S_OK;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// get_AddressID
//
// returns the tapi 2 address ID of this address
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::get_AddressID(
                        long * plAddressID
                       )
{
    LOG((TL_TRACE, "get_AddressID - enter"));
    
    if ( TAPIIsBadWritePtr( plAddressID, sizeof(long) ) )
    {
        LOG((TL_ERROR, "get_AddressID - bad pointer"));

        return E_POINTER;
    }

    Lock();

    *plAddressID = m_dwAddressID;

    Unlock();

    LOG((TL_TRACE, "get_AddressID - exit"));

    return S_OK;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CAddress::UpdateAddressCaps
//
// must be called in lock
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::UpdateAddressCaps()
{
    HRESULT             hr = S_OK;

    if ( NULL == m_pAddressCaps )
    {
        LPLINEADDRESSCAPS       pTemp;
        CTAPI                 * pCTapi;
        
        pCTapi = GetTapi();
        
        if( NULL == pCTapi )
        {
            LOG((TL_ERROR, "dynamic cast operation failed"));
            hr = E_POINTER;
        }
        else
        {
            hr = pCTapi->GetBuffer( BUFFERTYPE_ADDRCAP,
                                    (UINT_PTR)this,
                                    (LPVOID*)&m_pAddressCaps
                                  );
        }

        if ( !SUCCEEDED(hr) )
        {
            return hr;
        }

        pTemp = m_pAddressCaps;
        
        hr = LineGetAddressCaps(
                                m_hLineApp,
                                m_dwDeviceID,
                                m_dwAddressID,
                                m_dwAPIVersion,
                                &m_pAddressCaps
                               );

        if ( !SUCCEEDED(hr) )
        {
            return hr;
        }

        if ( m_pAddressCaps != pTemp )
        {
            pCTapi->SetBuffer( BUFFERTYPE_ADDRCAP, (UINT_PTR)this, (LPVOID)m_pAddressCaps );
        }
    }

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// CAddress::UpdateLineDevCaps
//
// must be called in lock
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::UpdateLineDevCaps()
{
    HRESULT             hr = S_OK;

    if ( NULL == m_pDevCaps )
    {
        LPLINEDEVCAPS           pTemp;
        CTAPI                 * pCTapi;

        pCTapi = GetTapi();
        
        if( NULL == pCTapi )
        {
            LOG((TL_ERROR, "dynamic cast operation failed"));
            hr = E_POINTER;
        }
        else
        {
            hr = pCTapi->GetBuffer( BUFFERTYPE_LINEDEVCAP,
                                    (UINT_PTR)this,
                                    (LPVOID*)&m_pDevCaps
                                  );
        }
        if ( !SUCCEEDED(hr) )
        {
            return hr;
        }

        pTemp = m_pDevCaps;
        
        hr = LineGetDevCaps(
                            m_hLineApp,
                            m_dwDeviceID,
                            m_dwAPIVersion,
                            &m_pDevCaps
                           );

        if ( !SUCCEEDED(hr) )
        {
            return hr;
        }

        if ( m_pDevCaps != pTemp )
        {
            pCTapi->SetBuffer( BUFFERTYPE_LINEDEVCAP, (UINT_PTR)this, (LPVOID)m_pDevCaps );
        }
    }

    return S_OK;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// SetAddrCapBuffer
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void
CAddress::SetAddrCapBuffer( LPVOID pBuf )
{
    Lock();

    m_pAddressCaps = (LPLINEADDRESSCAPS)pBuf;

    Unlock();
}
    
void
CAddress::SetLineDevCapBuffer( LPVOID pBuf )
{
    Lock();

    m_pDevCaps = (LPLINEDEVCAPS)pBuf;
    
    Unlock();
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::CreateMSPCall(
                        MSP_HANDLE hCall,
                        DWORD dwReserved,
                        long lMediaType,
                        IUnknown * pOuterUnk,
                        IUnknown ** ppStreamControl
                       )
{
    HRESULT         hr = E_FAIL;
    
    if ( NULL != m_pMSPAggAddress )
    {
        ITMSPAddress * pMSPAddress = GetMSPAddress();
        
        __try
        {

            hr = pMSPAddress->CreateMSPCall(
                                         hCall,
                                         dwReserved,
                                         lMediaType,
                                         pOuterUnk,
                                         ppStreamControl
                                        );

        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {

            //
            // catch any exceptions thrown by the msp, to protect ouirselves from
            // misbehaving msps
            //

            LOG((TL_ERROR, 
                "CreateMSPCall - MSPAddress::CreateMSPCall threw an exception"));

            hr = E_OUTOFMEMORY;
        }

        
        pMSPAddress->Release();

    }

    return hr;
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::ShutdownMSPCall( IUnknown * pStreamControl )
{
    HRESULT     hr = S_FALSE;
    
    if ( NULL != m_pMSPAggAddress )
    {
        ITMSPAddress * pMSPAddress = GetMSPAddress();
        
        hr = pMSPAddress->ShutdownMSPCall( pStreamControl );

        pMSPAddress->Release();
    }

    return hr;
}


//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT
CAddress::ReceiveTSPData(
                         IUnknown * pMSPCall,
                         LPBYTE pBuffer,
                         DWORD dwSize
                        )
{
    HRESULT         hr = E_FAIL;
    
    Lock();
    
    if ( NULL != m_pMSPAggAddress )
    {
        ITMSPAddress * pMSPAddress = GetMSPAddress();
        
        hr = pMSPAddress->ReceiveTSPData(
                                           pMSPCall,
                                           pBuffer,
                                           dwSize
                                          );

        pMSPAddress->Release();
    }

    Unlock();

    return hr;
}
    

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// LINE_SENDMSPMESSAGE handler
//
// give the opaque blob to the msp
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT HandleSendMSPDataMessage( PASYNCEVENTMSG pParams )
{
    CAddress      * pAddress;
    BOOL            bSuccess;
    HRESULT         hr = S_OK;
    IUnknown      * pMSPCall = NULL;;


    LOG((TL_TRACE, "HandleSendMSPDataMessage - enter"));
    

    //
    // find the correct line
    //
    bSuccess = FindAddressObject(
                                 (HLINE)(pParams->hDevice),
                                 &pAddress
                                );

    if (bSuccess)
    {
        CCall     * pCall = NULL;

        if ( NULL != (HCALL)(pParams->Param1) )
        {
            bSuccess = FindCallObject(
                                      (HCALL)(pParams->Param1),
                                      &pCall
                                     );

            if ( !bSuccess )
            {
                LOG((TL_ERROR, "HandleSendMSPDataMessage - couldn't find call %X",pParams->Param1));
        
                //FindAddressObject addrefs the address objct
                pAddress->Release();
    
                return E_FAIL;
            }

            pMSPCall = pCall->GetMSPCall();
        }
        
        //
        // the blob is at the end of the fixed
        // structure
        //


        //
        // get the size of the blob
        //

        DWORD dwSize = pParams->Param2;


        BYTE *pBuffer = NULL;
        
        //
        // if the buffer's not empty, get a pointer to it
        //

        if (0 < dwSize)
        {

            pBuffer = (LPBYTE)(pParams + 1);
        }
        

        //
        // call the msp
        //
        pAddress->ReceiveTSPData(
                                 pMSPCall,
                                 pBuffer,
                                 dwSize
                                );

        if ( pCall )
        {
            pCall->Release();
            
            if ( pMSPCall )
            {
                pMSPCall->Release();
            }
        }
        
        hr = S_OK;

        //FindAddressObject addrefs the address objct
        pAddress->Release();
    
    }
    else
    {
        LOG((TL_ERROR, "HandleSendMSPDataMessage - failed to find address Object %lx",
               pParams->hDevice));
        
        hr = E_FAIL;
    }

    
    LOG((TL_TRACE, "HandleSendMSPDataMessage - exit. hr = %lx", hr));

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// HandleSendTSPData
//
// sends an opaque buffer from the msp to the tsp
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CAddress::HandleSendTSPData( MSP_EVENT_INFO * pEvent )
{
    LOG((TL_INFO, "HandleSendTSPData - enter pEvent %p", pEvent));


    //
    // see if the event is bad
    //

    if (IsBadReadPtr(pEvent, sizeof(MSP_EVENT_INFO) ) )
    {
        LOG((TL_ERROR, "HandleSendTSPData - bad event structure"));

        return E_POINTER;
    }


    HRESULT               hr = S_OK;
    HCALL                 hCall = NULL;
    CCall               * pCall = NULL;
	AddressLineStruct	* pAddressLine = NULL;


    //
    // if we were given msp call handle, find the corresponding call
    //

    if ( NULL != pEvent->hCall)
    {
    
        gpHandleHashTable->Lock();

        hr = gpHandleHashTable->Find( (ULONG_PTR)pEvent->hCall, (ULONG_PTR *)&pCall);

        if ( SUCCEEDED(hr) )
        {

            //
            // found the call, addreff the call and and release the table 
            //

            LOG((TL_INFO, "HandleSendTSPData - Matched handle %X to Call object %p",
                pEvent->hCall, pCall ));

            pCall->AddRef();
    
            gpHandleHashTable->Unlock();


            //
            // get the handle for this call
            //

            hCall = pCall->GetHCall();


            //
            // get call's address line, if any
            //

            pAddressLine = pCall->GetAddRefMyAddressLine();

            LOG((TL_INFO, "HandleSendTSPData - address line[%p] hCall[%lx]",
                pAddressLine, hCall ));

        }
        else
        {

            //
            // there is no corresponding call in the hash table. the call no 
            // longer exists, or msp passed a bugus handle
            //

            gpHandleHashTable->Unlock();

            LOG((TL_ERROR, 
                "HandleSendTSPData - Couldn't match handle %X to Call object. hr = %lx", 
                pEvent->hCall, hr));

            return hr;
        }

    }
   

    //
    // by this point we either had msp call handle that is null or successfully
    // found a matching call object and asked it for its address line
    //
    
	if (NULL == pAddressLine)
	{

        //
        // if we don't have address line, send a message to the first address line on
        // this address (?)
        //

        if ( m_AddressLinesPtrList.size() > 0 )
		{
			PtrList::iterator       iter;

			iter = m_AddressLinesPtrList.begin();

			//
			// send to the tsp
			//
			hr = LineReceiveMSPData(
							   ((AddressLineStruct *)(*iter))->t3Line.hLine,
							   hCall,
							   pEvent->MSP_TSP_DATA.pBuffer,
							   pEvent->MSP_TSP_DATA.dwBufferSize
							  );
		}
		else
		{
            LOG((TL_ERROR, 
                "HandleSendTSPData - no address lines on the address. E_UNEXPECTED"));

            hr = E_UNEXPECTED;
		}
    }
    else
    {

        //
        // if we have an address line, send a message to the corresponding line
        //

        hr = LineReceiveMSPData(
					   pAddressLine->t3Line.hLine,
					   hCall,
					   pEvent->MSP_TSP_DATA.pBuffer,
					   pEvent->MSP_TSP_DATA.dwBufferSize
					  );


        //
        // no longer need our address line, release it. the line will be closed
        // if needed
        //

        pCall->ReleaseAddressLine(pAddressLine);
        pAddressLine = NULL;

    }


    //
    // if we have a call, release it
    //
    
    if (NULL != pCall)
    {
        pCall->Release();
        pCall = NULL;
    }
                           

    LOG((TL_INFO, "HandleSendTSPData - finish hr = %lx", hr));

    return hr;
}


//
// handle dev specific message
//

void HandleLineDevSpecificMessage(  PASYNCEVENTMSG pParams )
{

    LOG((TL_INFO, "HandleLineDevSpecificMessage - enter"));


    //
    // note:
    //
    // unfortunately, the message that we receive does not give us any 
    // indication as to whether hDevice contains a call handle or am address
    // handle.
    //
    // to determine the kind of handle, we have to search both tables. if we 
    // find the corresponding address object, this is a line handle, if we find
    // a corresponding call, this is a call handle. this brute-force search is 
    // fairly expensive. 
    //
    // one possible optimization would be to track the number of calls and 
    // addresses and search the smaller table first. however, this would 
    // require tracking overhead (even in the cases where the optimization is 
    // not needed), and for this to work well, we would also need to estimate
    // the likelyhood of each type of message. which makes this kind of 
    // optimization even more expensive.
    //
    // so we will simply check both tables to determine whether we have a call
    // or an address.
    // 


    CCall *pCall = NULL;
   
    CAddress *pAddress = NULL;


    //
    // find the corresponding address
    //

    if ( !FindAddressObject( (HLINE)(pParams->hDevice), &pAddress ) )
    {

        LOG((TL_WARN, 
            "HandleLineDevSpecificMessage - FindAddressObject failed to find matching address. searching for call"));


        pAddress = NULL;


        //
        // no address, try to find matching call
        //

        if ( !FindCallObject( (HCALL)(pParams->hDevice), &pCall) )
        {
            LOG((TL_ERROR, 
                "HandleLineDevSpecificMessage - FindAddressObject failed to find matching call. "));
      
            return;
        }

    }


    //
    // if we got a call, get the corresponding address object
    //

    if (NULL != pCall)
    {
        ITAddress *pITAddress = NULL;

        HRESULT hr = pCall->get_Address(&pITAddress);

        if (FAILED(hr))
        {
            LOG((TL_ERROR,
                "HandleLineDevSpecificMessage - call does not have an address. hr = %lx", hr));

            pCall->Release();
            pCall = NULL;

            return;
        }

        try
        {

            pAddress = dynamic_cast<CAddress*>(pITAddress);
        }
        catch(...)
        {
            LOG((TL_ERROR,
                "HandleLineDevSpecificMessage - exception using address. address pointer bad"));
        }

        //
        // if the address is bad, return
        //

        if (NULL == pAddress)
        {
       
            LOG((TL_ERROR,
                "HandleLineDevSpecificMessage - no address"));

            pCall->Release();
            pCall = NULL;


            //
            // yes, queryinterface returned us an addreffed pITAddress... but
            // since it does not seem valid anyway, do not bother releasing.
            //

            _ASSERTE(FALSE);

            return;
        }
    
    } // call is not null


    //
    // by this time we must have an address and maybe a call. we actually 
    // ensured this in the logic above. this assert is to make this condition 
    // explicit.
    //

    _ASSERTE( NULL != pAddress );


    //
    // fire event
    //

    CAddressDevSpecificEvent::FireEvent(
                             pAddress,
                             pCall,
                             pParams->Param1,
                             pParams->Param2,
                             pParams->Param3
                            );


    //
    //  undo FindXObject's addreffs
    //

    if (NULL != pAddress)
    {
        pAddress->Release();
        pAddress = NULL;
    }


    if (NULL != pCall)
    {
        pCall->Release();
        pCall = NULL;
    }


    LOG((TL_INFO, "HandleLineDevSpecificMessage - exit. "));
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// HandleMSPAddressEvent
//
// fires an addressevent to the application based on
// an event from the MSP
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CAddress::HandleMSPAddressEvent( MSP_EVENT_INFO * pEvent )
{
    switch ( pEvent->MSP_ADDRESS_EVENT_INFO.Type )
    {
        case ADDRESS_TERMINAL_AVAILABLE:

            CAddressEvent::FireEvent(
                                     this,
                                     AE_NEWTERMINAL,
                                     pEvent->MSP_ADDRESS_EVENT_INFO.pTerminal
                                    );
            break;
            
        case ADDRESS_TERMINAL_UNAVAILABLE:

            CAddressEvent::FireEvent(
                                     this,
                                     AE_REMOVETERMINAL,
                                     pEvent->MSP_ADDRESS_EVENT_INFO.pTerminal
                                    );
            break;
            
        default:
            LOG((TL_ERROR, "HandleMSPAddressEvent - bad event"));
            break;
    }

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// HandleMSPCallEvent
//
// fires a callmediaevent to the application based on an
// event from the msp
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CAddress::HandleMSPCallEvent( MSP_EVENT_INFO * pEvent )
{
    CCall                   * pCall;
    ITCallInfo              * pCallInfo;
    CALL_MEDIA_EVENT          Event;
    CALL_MEDIA_EVENT_CAUSE    Cause;
    ITTerminal              * pTerminal = NULL;
    ITStream                * pStream = NULL;
    HRESULT                   hrEvent = 0;
    HRESULT                   hr = S_OK;


    gpHandleHashTable->Lock();
    hr = gpHandleHashTable->Find( (ULONG_PTR)pEvent->hCall, (ULONG_PTR *)&pCall);

    if ( SUCCEEDED(hr) )
    {
        LOG((TL_INFO, "HandleMSPCallEvent - Matched handle %X to Call object %p", pEvent->hCall, pCall ));

        pCall->AddRef();
        gpHandleHashTable->Unlock();
        
        hr = pCall->QueryInterface(
                                   IID_ITCallInfo,
                                   (void**) &pCallInfo
                                  );
    }
    else // ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "HandleMSPCallEvent - Couldn't match handle %X to Call object ", pEvent->hCall));
        gpHandleHashTable->Unlock();

        return hr;
    }
    

    //
    // set up the info for the event
    // pStream applies to all of the currently-defined events
    //

    pStream   = pEvent->MSP_CALL_EVENT_INFO.pStream;

    //
    // cause is the same, although the MSPI and API use different enumerated types.
    // Note: this will have to expand to a switch if the order of enums ever gets
    // out of sync!
    //

    Cause = (CALL_MEDIA_EVENT_CAUSE) pEvent->MSP_CALL_EVENT_INFO.Cause;

    //
    // Rest depend on the type...
    //

    switch ( pEvent->MSP_CALL_EVENT_INFO.Type )
    {
    
        case CALL_NEW_STREAM:
            Event     = CME_NEW_STREAM;
            break;
            
        case CALL_STREAM_FAIL:
            Event     = CME_STREAM_FAIL;
            hrEvent   = pEvent->MSP_CALL_EVENT_INFO.hrError;
            break;
            
        case CALL_TERMINAL_FAIL:
            Event     = CME_TERMINAL_FAIL;
            pTerminal = pEvent->MSP_CALL_EVENT_INFO.pTerminal;
            hrEvent   = pEvent->MSP_CALL_EVENT_INFO.hrError;
            break;
            
        case CALL_STREAM_NOT_USED:
            Event     = CME_STREAM_NOT_USED;
            break;
            
        case CALL_STREAM_ACTIVE:
            Event     = CME_STREAM_ACTIVE;
            break;
            
        case CALL_STREAM_INACTIVE:
            Event     = CME_STREAM_INACTIVE;
            break;
            
        default:
            LOG((TL_ERROR, "HandleMSPCallEvent - bad event"));

            return E_INVALIDARG;
    }

    //
    // fire the event
    //
    CCallMediaEvent::FireEvent(
                               pCallInfo,
                               Event,
                               Cause,
                               dynamic_cast<CTAPI *>(m_pTAPI),
                               pTerminal,
                               pStream,
                               hrEvent
                              );

    //
    // addref'd above
    //
    pCallInfo->Release();
    pCall->Release();
    
    return S_OK;
}

HRESULT
CAddress::HandleMSPTTSTerminalEvent( MSP_EVENT_INFO * pEvent )
{
    if (NULL == pEvent)
    {
        LOG((TL_ERROR, "HandleMSPTTSTerminalEvent - pEvent  is NULL"));
        return E_POINTER;
    }



    ITAddress *pAddress = dynamic_cast<ITAddress *>(this);

    if (pAddress == NULL)
    {
        LOG((TL_ERROR, "HandleMSPTTSTerminalEvent - can't cast the address %p to ITAddress", this));
        return E_UNEXPECTED;
    }


    CCall      * pCall =  NULL;
    ITCallInfo * pCallInfo =  NULL;

    gpHandleHashTable->Lock();


    HRESULT hr = E_FAIL;

    hr = gpHandleHashTable->Find( (ULONG_PTR)pEvent->hCall, (ULONG_PTR *)&pCall);

    if ( SUCCEEDED(hr) )
    {
        LOG((TL_INFO, "HandleMSPTTSTerminalEvent - Matched handle %X to Call object %p", pEvent->hCall, pCall ));

        pCall->AddRef();
        gpHandleHashTable->Unlock();
        
        hr = pCall->QueryInterface(
                                   IID_ITCallInfo,
                                   (void**) &pCallInfo
                                  );
    }
    else // ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "HandleMSPTTSTerminalEvent - Couldn't match handle %X to Call object ", pEvent->hCall));
        gpHandleHashTable->Unlock();

        return hr;
    }


    //
    // get tapi object and fire the event
    //

    hr = CTTSTerminalEvent::FireEvent(GetTapi(),
                                      pCallInfo,
                                      pEvent->MSP_TTS_TERMINAL_EVENT_INFO.pTTSTerminal,
                                      pEvent->MSP_TTS_TERMINAL_EVENT_INFO.hrErrorCode);

    if (FAILED(hr))
    {

        LOG((TL_ERROR, "HandleMSPTTSTerminalEvent - CFileTerminalEvent::FireEvent failed. hr = %lx", hr));
    }

 
    //
    // we addref'd these above, so release now
    //

    pCallInfo->Release();
    pCall->Release();
    
    return hr;
}

HRESULT
CAddress::HandleMSPASRTerminalEvent( MSP_EVENT_INFO * pEvent )
{
    if (NULL == pEvent)
    {
        LOG((TL_ERROR, "HandleMSPASRTerminalEvent - pEvent  is NULL"));
        return E_POINTER;
    }



    ITAddress *pAddress = dynamic_cast<ITAddress *>(this);

    if (pAddress == NULL)
    {
        LOG((TL_ERROR, "HandleMSPASRTerminalEvent - can't cast the address %p to ITAddress", this));
        return E_UNEXPECTED;
    }


    CCall      * pCall =  NULL;
    ITCallInfo * pCallInfo =  NULL;

    gpHandleHashTable->Lock();


    HRESULT hr = E_FAIL;

    hr = gpHandleHashTable->Find( (ULONG_PTR)pEvent->hCall, (ULONG_PTR *)&pCall);

    if ( SUCCEEDED(hr) )
    {
        LOG((TL_INFO, "HandleMSPASRTerminalEvent - Matched handle %X to Call object %p", pEvent->hCall, pCall ));

        pCall->AddRef();
        gpHandleHashTable->Unlock();
        
        hr = pCall->QueryInterface(
                                   IID_ITCallInfo,
                                   (void**) &pCallInfo
                                  );
    }
    else // ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "HandleMSPASRTerminalEvent - Couldn't match handle %X to Call object ", pEvent->hCall));
        gpHandleHashTable->Unlock();

        return hr;
    }


    //
    // get tapi object and fire the event
    //

    hr = CASRTerminalEvent::FireEvent(GetTapi(),
                                       pCallInfo,
                                       pEvent->MSP_ASR_TERMINAL_EVENT_INFO.pASRTerminal,
                                       pEvent->MSP_ASR_TERMINAL_EVENT_INFO.hrErrorCode);

    if (FAILED(hr))
    {

        LOG((TL_ERROR, "HandleMSPASRTerminalEvent - CFileTerminalEvent::FireEvent failed. hr = %lx", hr));
    }

 
    //
    // we addref'd these above, so release now
    //

    pCallInfo->Release();
    pCall->Release();
    
    return hr;
}

HRESULT
CAddress::HandleMSPToneTerminalEvent( MSP_EVENT_INFO * pEvent )
{
    if (NULL == pEvent)
    {
        LOG((TL_ERROR, "HandleMSPToneTerminalEvent - pEvent  is NULL"));
        return E_POINTER;
    }



    ITAddress *pAddress = dynamic_cast<ITAddress *>(this);

    if (pAddress == NULL)
    {
        LOG((TL_ERROR, "HandleMSPToneTerminalEvent - can't cast the address %p to ITAddress", this));
        return E_UNEXPECTED;
    }


    CCall      * pCall =  NULL;
    ITCallInfo * pCallInfo =  NULL;

    gpHandleHashTable->Lock();


    HRESULT hr = E_FAIL;

    hr = gpHandleHashTable->Find( (ULONG_PTR)pEvent->hCall, (ULONG_PTR *)&pCall);

    if ( SUCCEEDED(hr) )
    {
        LOG((TL_INFO, "HandleMSPToneTerminalEvent - Matched handle %X to Call object %p", pEvent->hCall, pCall ));

        pCall->AddRef();
        gpHandleHashTable->Unlock();
        
        hr = pCall->QueryInterface(
                                   IID_ITCallInfo,
                                   (void**) &pCallInfo
                                  );
    }
    else // ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "HandleMSPToneTerminalEvent - Couldn't match handle %X to Call object ", pEvent->hCall));
        gpHandleHashTable->Unlock();

        return hr;
    }


    //
    // get tapi object and fire the event
    //

    hr = CToneTerminalEvent::FireEvent(GetTapi(),
                                       pCallInfo,
                                       pEvent->MSP_TONE_TERMINAL_EVENT_INFO.pToneTerminal,
                                       pEvent->MSP_TONE_TERMINAL_EVENT_INFO.hrErrorCode);

    if (FAILED(hr))
    {

        LOG((TL_ERROR, "HandleMSPToneTerminalEvent - CFileTerminalEvent::FireEvent failed. hr = %lx", hr));
    }

 
    //
    // we addref'd these above, so release now
    //

    pCallInfo->Release();
    pCall->Release();
    
    return hr;
}


HRESULT
CAddress::HandleMSPFileTerminalEvent( MSP_EVENT_INFO * pEvent )
{

    if (NULL == pEvent)
    {
        LOG((TL_ERROR, "HandleMSPFileTerminalEvent - pEvent  is NULL"));
        return E_POINTER;
    }



    ITAddress *pAddress = dynamic_cast<ITAddress *>(this);

    if (pAddress == NULL)
    {
        LOG((TL_ERROR, "HandleMSPFileTerminalEvent - can't cast the address %p to ITAddress", this));
        return E_UNEXPECTED;
    }


    CCall      * pCall =  NULL;
    ITCallInfo * pCallInfo =  NULL;

    gpHandleHashTable->Lock();


    HRESULT hr = E_FAIL;

    hr = gpHandleHashTable->Find( (ULONG_PTR)pEvent->hCall, (ULONG_PTR *)&pCall);

    if ( SUCCEEDED(hr) )
    {
        LOG((TL_INFO, "HandleMSPFileTerminalEvent - Matched handle %X to Call object %p", pEvent->hCall, pCall ));

        pCall->AddRef();
        gpHandleHashTable->Unlock();
        
        hr = pCall->QueryInterface(
                                   IID_ITCallInfo,
                                   (void**) &pCallInfo
                                  );
    }
    else // ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "HandleMSPFileTerminalEvent - Couldn't match handle %X to Call object ", pEvent->hCall));
        gpHandleHashTable->Unlock();

        return hr;
    }


    //
    // get tapi object and fire the event
    //

    hr = CFileTerminalEvent::FireEvent(this,
                                       GetTapi(),
                                       pCallInfo,
                                       pEvent->MSP_FILE_TERMINAL_EVENT_INFO.TerminalMediaState,
                                       pEvent->MSP_FILE_TERMINAL_EVENT_INFO.ftecEventCause,
                                       pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pParentFileTerminal,
                                       pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pFileTrack,
                                       pEvent->MSP_FILE_TERMINAL_EVENT_INFO.hrErrorCode);

    if (FAILED(hr))
    {

        LOG((TL_ERROR, "HandleMSPFileTerminalEvent - CFileTerminalEvent::FireEvent failed. hr = %lx", hr));
    }

 
    //
    // we addref'd these above, so release now
    //

    pCallInfo->Release();
    pCall->Release();
    
    return hr;
}

HRESULT
CAddress::HandleMSPPrivateEvent( MSP_EVENT_INFO * pEvent )
{
    ITAddress *pAddress = dynamic_cast<ITAddress *>(this);

    if (pAddress == NULL)
    {
        LOG((TL_ERROR, "HandleMSPPrivateEvent - can't cast the address %p to ITAddress", this));
        return E_UNEXPECTED;
    }

    CCall               * pCall =  NULL;
    ITCallInfo          * pCallInfo =  NULL;
    HRESULT               hr;

    gpHandleHashTable->Lock();
    hr = gpHandleHashTable->Find( (ULONG_PTR)pEvent->hCall, (ULONG_PTR *)&pCall);

    if ( SUCCEEDED(hr) )
    {
        LOG((TL_INFO, "HandleMSPPrivateEvent - Matched handle %X to Call object %p", pEvent->hCall, pCall ));

        pCall->AddRef();
        gpHandleHashTable->Unlock();
        
        hr = pCall->QueryInterface(
                                   IID_ITCallInfo,
                                   (void**) &pCallInfo
                                  );
    }
    else // ( !SUCCEEDED(hr) )
    {
        LOG((TL_ERROR, "HandleMSPPrivateEvent - Couldn't match handle %X to Call object ", pEvent->hCall));
        gpHandleHashTable->Unlock();

        return hr;
    }
    


    CPrivateEvent::FireEvent(
                             GetTapi(),
                             pCallInfo,
                             pAddress,
                             NULL,
                             pEvent->MSP_PRIVATE_EVENT_INFO.pEvent,
                             pEvent->MSP_PRIVATE_EVENT_INFO.lEventCode
                            );


  
    //
    // addref'd above
    //
    pCallInfo->Release();
    pCall->Release();
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// ReleaseEvent
//
// releases any reference counts in the event from
// the msp.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CAddress::ReleaseEvent( MSP_EVENT_INFO * pEvent )
{

    LOG((TL_TRACE, "ReleaseEvent -  enter"));

    switch ( pEvent->Event )
    {
        case ME_ADDRESS_EVENT:

            if (NULL != pEvent->MSP_ADDRESS_EVENT_INFO.pTerminal)
            {
                (pEvent->MSP_ADDRESS_EVENT_INFO.pTerminal)->Release();
            }
            
            break;
            
        case ME_CALL_EVENT:

            if (NULL != pEvent->MSP_CALL_EVENT_INFO.pTerminal)
            {
                (pEvent->MSP_CALL_EVENT_INFO.pTerminal)->Release();
            }
            
            if (NULL != pEvent->MSP_CALL_EVENT_INFO.pStream)
            {
                (pEvent->MSP_CALL_EVENT_INFO.pStream)->Release();
            }
            
            break;
            
        case ME_TSP_DATA:

            break;

        case ME_PRIVATE_EVENT:
            
            if ( NULL != pEvent->MSP_PRIVATE_EVENT_INFO.pEvent )
            {
                (pEvent->MSP_PRIVATE_EVENT_INFO.pEvent)->Release();
            }

            break;

        case ME_FILE_TERMINAL_EVENT:

            if( NULL != pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pParentFileTerminal)
            {
                (pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pParentFileTerminal)->Release();
                pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pParentFileTerminal = NULL;
            }

            if( NULL != pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pFileTrack )
            {
                (pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pFileTrack)->Release();
                pEvent->MSP_FILE_TERMINAL_EVENT_INFO.pFileTrack = NULL;
            }

            break;

        case ME_ASR_TERMINAL_EVENT:

            if( NULL != pEvent->MSP_ASR_TERMINAL_EVENT_INFO.pASRTerminal)
            {
                (pEvent->MSP_ASR_TERMINAL_EVENT_INFO.pASRTerminal)->Release();
            }

            break;

        case ME_TTS_TERMINAL_EVENT:

            if( NULL != pEvent->MSP_TTS_TERMINAL_EVENT_INFO.pTTSTerminal)
            {
                (pEvent->MSP_TTS_TERMINAL_EVENT_INFO.pTTSTerminal)->Release();
            }

            break;

        case ME_TONE_TERMINAL_EVENT:

            if( NULL != pEvent->MSP_TONE_TERMINAL_EVENT_INFO.pToneTerminal)
            {
                (pEvent->MSP_TONE_TERMINAL_EVENT_INFO.pToneTerminal)->Release();
            }

            break;

        default:

            break;
    }


    LOG((TL_TRACE, "ReleaseEvent -  finished"));

    return S_OK;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
// HRESULT
// CAddress::MSPEvent()
//
// gets an event buffer from the MSP
// and calls the relevant event handler
//
// this is _only_ called from the asynceventsthread. this is
// necessary for synchronization of events.
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT
CAddress::MSPEvent()
{
    DWORD                   dwSize;
    MSP_EVENT_INFO        * pEvent = NULL;
    HRESULT                 hr;

    //
    // Allocate an MSP event buffer -- best guess as to an appropriate
    // size. We need to free it before returning.
    //

    dwSize = sizeof (MSP_EVENT_INFO) + 500;

    pEvent = (MSP_EVENT_INFO *)ClientAlloc( dwSize );

    if ( NULL == pEvent )
    {
        LOG((TL_ERROR, "Alloc failed in MSP event"));

        return E_OUTOFMEMORY;
    }

    pEvent->dwSize = dwSize;

    //
    // Get pointer to msp address object. We need to release it before returning.
    // This must be done while the address object is locked.
    //

    Lock();

    ITMSPAddress * pMSPAddress = GetMSPAddress();

    Unlock();
    
    while (TRUE)
    {
        //
        // Get an event from the event queue. Abort and clean up if
        // allocation fails.
        //

        do
        {
            hr = pMSPAddress->GetEvent(
                                       &dwSize,
                                       (LPBYTE)pEvent
                                      );

            if ( hr == TAPI_E_NOTENOUGHMEMORY)
            {
                ClientFree( pEvent );
                
                pEvent = (MSP_EVENT_INFO *)ClientAlloc( dwSize );

                if ( NULL == pEvent )
                {
                    LOG((TL_ERROR, "Alloc failed in MSP event"));

                    pMSPAddress->Release();

                    return E_OUTOFMEMORY;
                }

                pEvent->dwSize = dwSize;
            }

        } while ( hr == TAPI_E_NOTENOUGHMEMORY );

        //
        // If there is nothing left in the MSP event queue, then stop the
        // outer while loop.
        //

        if ( !SUCCEEDED(hr) )
        {
            break;
        }


        //
        // Call the relevant handler, and do not hold the address lock during
        // the call. 
        //

        switch ( pEvent->Event )
        {
            case ME_ADDRESS_EVENT:

                HandleMSPAddressEvent( pEvent );

                break;

            case ME_CALL_EVENT:

                HandleMSPCallEvent( pEvent );

                break;

            case ME_TSP_DATA:

                HandleSendTSPData( pEvent );

                break;

            case ME_PRIVATE_EVENT:

                HandleMSPPrivateEvent( pEvent );

                break;

            case ME_FILE_TERMINAL_EVENT:

                HandleMSPFileTerminalEvent( pEvent );

                break;

            case ME_ASR_TERMINAL_EVENT:

                HandleMSPASRTerminalEvent( pEvent );

                break;

            case ME_TTS_TERMINAL_EVENT:
                
                HandleMSPTTSTerminalEvent( pEvent );

                break;

            case ME_TONE_TERMINAL_EVENT:

                HandleMSPToneTerminalEvent( pEvent );

               break;

            default:

                break;
        }

        //
        // release any refcounts in the
        // event
        //

        ReleaseEvent( pEvent );
    }

    //
    // We get here when there is nothing more to retrieve from the
    // MSP event queue.
    //

    pMSPAddress->Release();

    ClientFree( pEvent );

    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
ITMSPAddress * CAddress::GetMSPAddress()
{
    ITMSPAddress * pMSPAddress = NULL;
    
    if ( NULL != m_pMSPAggAddress )
    {
        m_pMSPAggAddress->QueryInterface(IID_ITMSPAddress, (void**)&pMSPAddress);
    }

    return pMSPAddress;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP
CAddress::GetID(
                BSTR pDeviceClass,
                DWORD * pdwSize,
                BYTE ** ppDeviceID
               )
{
    HRESULT             hr;
    PtrList::iterator   iter;
    LPVARSTRING         pVarString = NULL;
    
    if ( IsBadStringPtrW( pDeviceClass, -1 ) )
    {
        LOG((TL_ERROR, "GetID - bad string"));

        return E_POINTER;
    }

    if ( TAPIIsBadWritePtr( pdwSize, sizeof(DWORD)))
    {
        LOG((TL_ERROR, "GetID - bad size"));

        return E_POINTER;
    }

    if ( TAPIIsBadWritePtr( ppDeviceID, sizeof(BYTE *) ) )
    {
        LOG((TL_ERROR, "GetID - bad pointer"));

        return E_POINTER;
    }

    Lock();
    
    if ( m_AddressLinesPtrList.size() > 0 )
    {
        iter = m_AddressLinesPtrList.begin();
    }
    else
    {
        Unlock();

        return E_FAIL;
    }
    
    hr = LineGetID(
                   ((AddressLineStruct *)*iter)->t3Line.hLine,
                   m_dwAddressID,
                   NULL,
                   LINECALLSELECT_ADDRESS,
                   &pVarString,
                   pDeviceClass
                  );

    Unlock();

    if ( SUCCEEDED(hr) )
    {
        *ppDeviceID = (BYTE *)CoTaskMemAlloc( pVarString->dwUsedSize );

        if ( *ppDeviceID != NULL )
        {
            CopyMemory(
                       *ppDeviceID,
                       ((LPBYTE)pVarString)+pVarString->dwStringOffset,
                       pVarString->dwStringSize
                      );

            *pdwSize = pVarString->dwStringSize;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if ( NULL != pVarString )
    {
        ClientFree( pVarString );
    }

    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITLegacyAddressMediaControl
// Method    : GetDevConfig
//
// Get Device Config
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::GetDevConfig(
                       BSTR     pDeviceClass,
                       DWORD  * pdwSize,
                       BYTE  ** ppDeviceConfig
                      )
{
    HRESULT             hr;
    LPVARSTRING         pVarString = NULL;
    
    LOG((TL_TRACE, "GetDevConfig -  enter"));

    if ( IsBadStringPtrW( pDeviceClass, -1 ) )
    {
        LOG((TL_ERROR, "GetDevConfig - bad DeviceClass string"));

        return E_POINTER;
    }

    if ( TAPIIsBadWritePtr( pdwSize, sizeof(DWORD)))
    {
        LOG((TL_ERROR, "GetDevConfig - bad size"));

        return E_POINTER;
    }

    if ( TAPIIsBadWritePtr( ppDeviceConfig, sizeof(BYTE*) ) )
    {
        LOG((TL_ERROR, "GetDevConfig - bad buffer pointer"));

        return E_POINTER;
    }

    Lock();
    
    hr = LineGetDevConfig(m_dwDeviceID,
                          &pVarString,
                          pDeviceClass
                         );
        
    Unlock();

    if ( SUCCEEDED(hr) )
    {
        *ppDeviceConfig = (BYTE *)CoTaskMemAlloc( pVarString->dwUsedSize );
        
        if(*ppDeviceConfig != NULL)
        {
    
            CopyMemory(
                       *ppDeviceConfig,
                       ((LPBYTE)pVarString)+pVarString->dwStringOffset,
                       pVarString->dwStringSize
                      );
    
            *pdwSize = pVarString->dwStringSize;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if ( NULL != pVarString )
    {
        ClientFree( pVarString );
    }

    LOG((TL_TRACE, hr, "GetDevConfig -  exit" ));
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITLegacyAddressMediaControl
// Method    : SetDevConfig
//
// Set Device Config
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::SetDevConfig(
                       BSTR     pDeviceClass,
                       DWORD    dwSize,
                       BYTE   * pDeviceConfig
                      )
{
    HRESULT     hr = S_OK;

    LOG((TL_TRACE, "SetDevConfig - enter"));

    if ( IsBadStringPtrW( pDeviceClass, -1) )
    {
        LOG((TL_ERROR, "SetDevConfig - bad string pointer"));

        return E_POINTER;
    }

    if (dwSize == 0)
    {
        LOG((TL_ERROR, "SetDevConfig - dwSize = 0"));
        return E_INVALIDARG;
    }
    
    if (IsBadReadPtr( pDeviceConfig, dwSize) )
    {
        LOG((TL_ERROR, "SetDevConfig - bad pointer"));

        return E_POINTER;
    }

    
    Lock();

    hr = lineSetDevConfigW(m_dwDeviceID,
                           pDeviceConfig,
                           dwSize,
                           pDeviceClass
                          );

    Unlock();
    
    LOG((TL_TRACE, hr, "SetDevConfig - exit"));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITLegacyAddressMediaControl2
// Method    : ConfigDialog
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::ConfigDialog(
                       HWND   hwndOwner,
                       BSTR   pDeviceClass
                      )
{
    HRESULT     hr = S_OK;

    LOG((TL_TRACE, "ConfigDialog - enter"));
    
    if ( (pDeviceClass != NULL) && IsBadStringPtrW( pDeviceClass, -1) )
    {
        LOG((TL_ERROR, "ConfigDialog - bad string pointer"));

        return E_POINTER;
    }

    Lock();

    hr = LineConfigDialogW(
                          m_dwDeviceID,
                          hwndOwner,
                          pDeviceClass
                         );

    Unlock();
    
    LOG((TL_TRACE, hr, "ConfigDialog - exit"));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAddress
// Interface : ITLegacyAddressMediaControl2
// Method    : ConfigDialogEdit
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP
CAddress::ConfigDialogEdit(
                           HWND    hwndOwner,
                           BSTR    pDeviceClass,
                           DWORD   dwSizeIn,
                           BYTE  * pDeviceConfigIn,
                           DWORD * pdwSizeOut,
                           BYTE ** ppDeviceConfigOut
                          )
{
    HRESULT     hr = S_OK;
    LPVARSTRING pVarString = NULL;

    LOG((TL_TRACE, "ConfigDialogEdit - enter"));

    if ( (pDeviceClass != NULL) && IsBadStringPtrW( pDeviceClass, -1) )
    {
        LOG((TL_ERROR, "ConfigDialogEdit - bad string pointer"));

        return E_POINTER;
    } 
    
    if (dwSizeIn == 0)
    {
        LOG((TL_ERROR, "ConfigDialogEdit - dwSize = 0"));

        return E_INVALIDARG;
    }
    
    if (IsBadReadPtr( pDeviceConfigIn, dwSizeIn) )
    {
        LOG((TL_ERROR, "ConfigDialogEdit - bad pointer"));

        return E_POINTER;
    }

    if ( TAPIIsBadWritePtr( pdwSizeOut, sizeof(DWORD)))
    {
        LOG((TL_ERROR, "ConfigDialogEdit - bad size"));

        return E_POINTER;
    }

    if ( TAPIIsBadWritePtr( ppDeviceConfigOut, sizeof(BYTE*) ) )
    {
        LOG((TL_ERROR, "ConfigDialogEdit - bad buffer pointer"));

        return E_POINTER;
    }

    Lock();

    hr = LineConfigDialogEditW(
                           m_dwDeviceID,
                           hwndOwner,                           
                           pDeviceClass,
                           pDeviceConfigIn,
                           dwSizeIn,
                           &pVarString
                          );

    Unlock();

    if ( SUCCEEDED(hr) )
    {
        *ppDeviceConfigOut = (BYTE *)CoTaskMemAlloc( pVarString->dwUsedSize );
        
        if(*ppDeviceConfigOut != NULL)
        {
    
            CopyMemory(
                       *ppDeviceConfigOut,
                       ((LPBYTE)pVarString)+pVarString->dwStringOffset,
                       pVarString->dwStringSize
                      );
    
            *pdwSizeOut = pVarString->dwStringSize;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if ( NULL != pVarString )
    {
        ClientFree( pVarString );
    }
    
    LOG((TL_TRACE, hr, "ConfigDialogEdit - exit"));
    
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
HRESULT HandleLineCloseMessage( PASYNCEVENTMSG pParams )
{
    CAddress                * pAddress;
    AddressLineStruct       * pAddressLine;
    CTAPI                   * pTapi;
    ITAddress               * pITAddress;

    LOG((TL_TRACE, "HandleLineCloseMessage - enter"));

    if ( !FindAddressObject(
                            (HLINE)(pParams->hDevice),
                            &pAddress
                           ) )
    {
        LOG((TL_TRACE, "HandleLineCloseMessage - FindAddressObject failed. exiting... "));
    
        return S_OK;
    }

    pTapi = pAddress->GetTapi();
    
    pAddress->QueryInterface(
                             IID_ITAddress,
                             (void **)&pITAddress
                            );



    //
    // get the lock so that the address line does not go away meanwhile
    //

    pAddress->Lock();


    //
    // covert the 32bit address line handle (contained in pParams->OpenContext)
    // into a pointer value
    //

    pAddressLine = (AddressLineStruct *)GetHandleTableEntry(pParams->OpenContext);


    //
    // is this a good line anyway?
    //

    BOOL bValidLine = pAddress->IsValidAddressLine(pAddressLine);


    long lCallBackInstance = 0;


    //
    // if seems to be a good line, attempt to get callback instance from it.
    //

    if (bValidLine)
    {

        try
        {

            lCallBackInstance = pAddressLine->lCallbackInstance;
        }
        catch(...)
        {
            LOG((TL_ERROR, 
                "HandleLineCloseMessage - exception getting callback instance from line struc"));

            _ASSERTE(FALSE);

            bValidLine = FALSE;
        }

    }

    
    pAddress->Unlock();


    //
    // if good and known line, attempt to fire an event
    //

    if ( bValidLine && pTapi && pTapi->FindRegistration( (PVOID)pAddressLine ) )
    {
        LOG((TL_TRACE, "HandleLineCloseMessage - found registration, firing event"));

        CTapiObjectEvent::FireEvent(
                                    pTapi,
                                    TE_ADDRESSCLOSE,
                                    pITAddress,
                                    lCallBackInstance,
                                    NULL
                                   );

    }
    else
    {
        LOG((TL_TRACE, 
            "HandleLineCloseMessage AddressLine %p not found. calling maybeclosealine", 
            pAddressLine ));

        pAddress->MaybeCloseALine(&pAddressLine);
    }
                        
    pITAddress->Release();
    
    //FindAddressObject addrefs the address objct
    pAddress->Release();
    
    LOG((TL_TRACE, "HandleLineCloseMessage - exit"));

    return S_OK;
    
}

/////////////////////////////////////////////////////////////////////////////
// IDispatch implementation
//
typedef IDispatchImpl<ITAddress2Vtbl<CAddress>, &IID_ITAddress2, &LIBID_TAPI3Lib> AddressType;
typedef IDispatchImpl<ITAddressCapabilitiesVtbl<CAddress>, &IID_ITAddressCapabilities, &LIBID_TAPI3Lib> AddressCapabilitiesType;
typedef IDispatchImpl<ITMediaSupportVtbl<CAddress>, &IID_ITMediaSupport, &LIBID_TAPI3Lib> MediaSupportType;
typedef IDispatchImpl<ITAddressTranslationVtbl<CAddress>, &IID_ITAddressTranslation, &LIBID_TAPI3Lib> AddressTranslationType;
typedef IDispatchImpl<ITLegacyAddressMediaControl2Vtbl<CAddress>, &IID_ITLegacyAddressMediaControl2, &LIBID_TAPI3Lib> LegacyAddressMediaControlType;



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CAddress::GetIDsOfNames
//
// Overide if IDispatch method
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP CAddress::GetIDsOfNames(REFIID riid, 
                                     LPOLESTR* rgszNames, 
                                     UINT cNames, 
                                     LCID lcid, 
                                     DISPID* rgdispid
                                    ) 
{ 
   HRESULT hr = DISP_E_UNKNOWNNAME;


    // See if the requsted method belongs to the default interface
    hr = AddressType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((TL_INFO, "GetIDsOfNames - found %S on ITAddress", *rgszNames));
        rgdispid[0] |= IDISPADDRESS;
        return hr;
    }

    // If not, then try the Address Capabilities interface
    hr = AddressCapabilitiesType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((TL_INFO, "GetIDsOfNames - found %S on ITAddressCapabilities", *rgszNames));
        rgdispid[0] |= IDISPADDRESSCAPABILITIES;
        return hr;
    }

    // If not, then try the Media Support interface
    hr = MediaSupportType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((TL_INFO, "GetIDsOfNames - found %S on ITMediaSupport", *rgszNames));
        rgdispid[0] |= IDISPMEDIASUPPORT;
        return hr;
    }

    // If not, then try the Address Translation interface
    hr = AddressTranslationType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((TL_INFO, "GetIDsOfNames - found %S on ITAddressTranslation", *rgszNames));
        rgdispid[0] |= IDISPADDRESSTRANSLATION;
        return hr;
    }

    // If not, then try the Legacy Address Media Control interface
    hr = LegacyAddressMediaControlType::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    if (SUCCEEDED(hr))  
    {  
        LOG((TL_INFO, "GetIDsOfNames - found %S on ITLegacyAddressMediaControl", *rgszNames));
        rgdispid[0] |= IDISPLEGACYADDRESSMEDIACONTROL;
        return hr;
    }

    // If not, then try the aggregated MSP Address object
    if (m_pMSPAggAddress != NULL)
    {
        IDispatch *pIDispatchMSPAggAddress;
        
        m_pMSPAggAddress->QueryInterface(IID_IDispatch, (void**)&pIDispatchMSPAggAddress);
        
        hr = pIDispatchMSPAggAddress->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
        if (SUCCEEDED(hr))  
        {  
            pIDispatchMSPAggAddress->Release();
            LOG((TL_INFO, "GetIDsOfNames - found %S on our aggregated MSP Address", *rgszNames));
            rgdispid[0] |= IDISPAGGREGATEDMSPADDRESSOBJ;
            return hr;
        }
        pIDispatchMSPAggAddress->Release();
    }
    
    LOG((TL_INFO, "GetIDsOfNames - Didn't find %S on our iterfaces", *rgszNames));
    return hr; 
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CAddress::Invoke
//
// Overide if IDispatch method
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
STDMETHODIMP CAddress::Invoke(DISPID dispidMember, 
                              REFIID riid, 
                              LCID lcid, 
                              WORD wFlags, 
                              DISPPARAMS* pdispparams, 
                              VARIANT* pvarResult, 
                              EXCEPINFO* pexcepinfo, 
                              UINT* puArgErr
                             )
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND;
    DWORD   dwInterface = (dispidMember & INTERFACEMASK);


    LOG((TL_TRACE, "Invoke - dispidMember %X", dispidMember));

    // Call invoke for the required interface
    switch (dwInterface)
    {
    case IDISPADDRESS:
    {
        hr = AddressType::Invoke(dispidMember, 
                                   riid, 
                                   lcid, 
                                   wFlags, 
                                   pdispparams,
                                   pvarResult, 
                                   pexcepinfo, 
                                   puArgErr
                                  );
        break;
    }
    case IDISPADDRESSCAPABILITIES:
    {
        hr = AddressCapabilitiesType::Invoke(dispidMember, 
                                               riid, 
                                               lcid, 
                                               wFlags, 
                                               pdispparams,
                                               pvarResult, 
                                               pexcepinfo, 
                                               puArgErr
                                              );
        break;
    }
    case IDISPMEDIASUPPORT:
    {
        hr = MediaSupportType::Invoke(dispidMember, 
                                         riid, 
                                         lcid, 
                                         wFlags, 
                                         pdispparams,
                                         pvarResult, 
                                         pexcepinfo, 
                                         puArgErr
                                        );
        break;
    }
    case IDISPADDRESSTRANSLATION:
    {
        hr = AddressTranslationType::Invoke(dispidMember, 
                                              riid, 
                                              lcid, 
                                              wFlags, 
                                              pdispparams,
                                              pvarResult, 
                                              pexcepinfo, 
                                              puArgErr
                                             );
        break;
    }
    case IDISPLEGACYADDRESSMEDIACONTROL:
    {
        hr = LegacyAddressMediaControlType::Invoke(dispidMember, 
                                                     riid, 
                                                     lcid, 
                                                     wFlags, 
                                                     pdispparams,
                                                     pvarResult, 
                                                     pexcepinfo, 
                                                     puArgErr
                                                    );

        break;
    }
    case IDISPAGGREGATEDMSPADDRESSOBJ:
    {
        IDispatch *pIDispatchMSPAggAddress = NULL;
    
        if (m_pMSPAggAddress != NULL)
        {
            m_pMSPAggAddress->QueryInterface(IID_IDispatch, (void**)&pIDispatchMSPAggAddress);
    
            hr = pIDispatchMSPAggAddress->Invoke(dispidMember, 
                                            riid, 
                                            lcid, 
                                            wFlags, 
                                            pdispparams,
                                            pvarResult, 
                                            pexcepinfo, 
                                            puArgErr
                                           );
            
            pIDispatchMSPAggAddress->Release();
        }

        break;
    }

    } // end switch (dwInterface)

    
    LOG((TL_TRACE, hr, "Invoke - exit" ));
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=
//
// CAddress::IsValidAddressLine
//
// returns TRUE if the address line passed in is in the address line list
//
// This method is not thread safe -- all calls must be protected, unless 
// bAddRef argument is TRUE
// 
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=

BOOL CAddress::IsValidAddressLine(AddressLineStruct *pAddressLine, BOOL bAddref)
{

    if (IsBadReadPtr(pAddressLine, sizeof(AddressLineStruct) ) )
    {
        LOG((TL_WARN,
            "IsValidAddressLine - unreadeable memory at [%p]",
            pAddressLine));

        return FALSE;
    }


    if (bAddref)
    {
        Lock();
    }

    PtrList::iterator it = m_AddressLinesPtrList.begin();

    PtrList::iterator end = m_AddressLinesPtrList.end();

    // iterate through address line list until we find the line
    for ( ; it != end; it++ )
    {
        if (pAddressLine == (AddressLineStruct *)(*it))
        {

            if (bAddref)
            {

                //
                // addref the line and release the lock
                //

                try
                {

                    pAddressLine->AddRef();

                }
                catch(...)
                {

                    //
                    // this is a bug. debug.
                    //

                    LOG((TL_INFO, "IsValidAddressLine -- exception while addreffing the line"));
                    
                    _ASSERTE(FALSE);

                    Unlock();

                    return FALSE;

                }

                
                Unlock();
            }

            LOG((TL_INFO, "IsValidAddressLine returning TRUE"));

            return TRUE;
        }
    }


    if (bAddref)
    {
        Unlock();
    }

    LOG((TL_INFO, "IsValidAddressLine returning FALSE"));

    return FALSE;
}



/////////////////////////////////////////////////////////////
//
// implementing method from CObjectSafeImpl
// 
// check the aggregated objects to see if they support the interface requested.
// if they do, return the non-delegating IUnknown of the object that supports 
// the interface. 
//


HRESULT CAddress::QIOnAggregates(REFIID riid, IUnknown **ppNonDelegatingUnknown)
{

    //
    // argument check
    // 

    if ( TAPIIsBadWritePtr(ppNonDelegatingUnknown, sizeof(IUnknown*)) )
    {
     
        return E_POINTER;
    }

    //
    // if we fail, at least return consistent values
    //
    
    *ppNonDelegatingUnknown = NULL;


    //
    // see if m_pMSPAggAddress or private support the interface riid
    //

    HRESULT hr = E_FAIL;


    Lock();

    if (m_pMSPAggAddress)
    {
        
        // 
        // does m_pMSPAggAddress expose this interface?
        // 

        IUnknown *pUnk = NULL;

        hr = m_pMSPAggAddress->QueryInterface(riid, (void**)&pUnk);
        
        if (SUCCEEDED(hr))
        {

            pUnk->Release();
            pUnk = NULL;


            //
            // return the mspcall's non-delegating unknown
            //

           *ppNonDelegatingUnknown = m_pMSPAggAddress;
           (*ppNonDelegatingUnknown)->AddRef();
        }
    }
    
    if ( FAILED(hr) && m_pPrivate )
    {
        
        //
        // bad luck with m_pMSPAggAddress? still have a chance with private
        //
        IUnknown *pUnk = NULL;
        
        hr = m_pPrivate->QueryInterface(riid, (void**)&pUnk);

        if (SUCCEEDED(hr))
        {

            pUnk->Release();
            pUnk = NULL;


            *ppNonDelegatingUnknown = m_pPrivate;
            (*ppNonDelegatingUnknown)->AddRef();
        }
    }

    Unlock();

    return hr;
}

// 
// Event filtering methods
//

/*++
SetEventFilterMask

  Is called by TAPI object to set the event filter mask to each address
  The caller method is CTAPI::SetEventFilterToAddresses()
  dwEventFilterMask is the TAPI event filter mask
--*/
HRESULT CAddress::SetEventFilterMask( 
    DWORD dwEventFilterMask
    )
{
    LOG((TL_TRACE, "SetEventFilterMask - enter. dwEventFilterMask[%lx]", dwEventFilterMask ));

    //
    // Set the event mask for all TAPI events
    //

    // TE_ADDRESS
    SetSubEventFlag( 
        TE_ADDRESS, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_ADDRESS) ? TRUE : FALSE);

    // TE_CALLHUB
    SetSubEventFlag( 
        TE_CALLHUB, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_CALLHUB) ? TRUE : FALSE);

    // TE_CALLINFOCHANGE
    SetSubEventFlag( 
        TE_CALLINFOCHANGE, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_CALLINFOCHANGE) ? TRUE : FALSE);

    // TE_CALLMEDIA
    SetSubEventFlag( 
        TE_CALLMEDIA, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_CALLMEDIA) ? TRUE : FALSE);

    // TE_CALLNOTIFICATION
    SetSubEventFlag( 
        TE_CALLNOTIFICATION, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_CALLNOTIFICATION) ? TRUE : FALSE);

    // TE_CALLSTATE
    SetSubEventFlag( 
        TE_CALLSTATE, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_CALLSTATE) ? TRUE : FALSE);

    // TE_FILETERMINAL
    SetSubEventFlag( 
        TE_FILETERMINAL, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_FILETERMINAL) ? TRUE : FALSE);

    // TE_PRIVATE
    SetSubEventFlag( 
        TE_PRIVATE, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_PRIVATE) ? TRUE : FALSE);

    // TE_QOSEVENT
    SetSubEventFlag( 
        TE_QOSEVENT, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_QOSEVENT) ? TRUE : FALSE);

    // TE_ADDRESSDEVSPECIFIC
    SetSubEventFlag( 
        TE_ADDRESSDEVSPECIFIC, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_ADDRESSDEVSPECIFIC) ? TRUE : FALSE);

    // TE_PHONEDEVSPECIFIC
    SetSubEventFlag( 
        TE_PHONEDEVSPECIFIC, 
        CEventMasks::EM_ALLSUBEVENTS, 
        (dwEventFilterMask & TE_PHONEDEVSPECIFIC) ? TRUE : FALSE);

    LOG((TL_TRACE, "SetEventFilterMask exit S_OK"));
    return S_OK;
}

/*++
SetSubEventFlag

Sets in m_EventFilterMasks array the bitflag for an subevent
Is called by CAddress::SetEventFilterMask
--*/
HRESULT CAddress::SetSubEventFlag(
    TAPI_EVENT  TapiEvent,
    DWORD       dwSubEvent,
    BOOL        bEnable
    )
{
    LOG((TL_TRACE, 
        "SetSubEventFlag - enter. event [%lx] subevent[%lx] enable?[%d]", 
        TapiEvent, dwSubEvent, bEnable ));

    HRESULT hr = S_OK;

    //
    // Set the mask for the event
    //

    hr = m_EventMasks.SetSubEventFlag( 
        TapiEvent, 
        dwSubEvent, 
        bEnable);

    if( SUCCEEDED(hr) )
    {
        hr = SetSubEventFlagToCalls( 
            TapiEvent,
            dwSubEvent,
            bEnable
            );
    }

    LOG((TL_TRACE, "SetSubEventFlag exit 0x%08x", hr));
    return hr;
}

/*++
GetSubEventFlag

It is calle by get_EventFilter() method
--*/
HRESULT CAddress::GetSubEventFlag(
    TAPI_EVENT  TapiEvent,
    DWORD       dwSubEvent,
    BOOL*       pEnable
    )
{
    LOG((TL_TRACE, "GetSubEventFlag enter" ));

    HRESULT hr = E_FAIL;

    //
    // Get the subevent falg
    //
    hr = m_EventMasks.GetSubEventFlag(
        TapiEvent,
        dwSubEvent,
        pEnable
        );

    LOG((TL_TRACE, "GetSubEventFlag exit 0x%08x", hr));
    return hr;
}

/*++
SetSubEventFlagToCalls

Sets the flags to all calls
Is called by SetSubEventFlag() method
--*/
HRESULT CAddress::SetSubEventFlagToCalls(
    TAPI_EVENT  TapiEvent,
    DWORD       dwSubEvent,
    BOOL        bEnable
    )
{
    LOG((TL_TRACE, "SetSubEventFlagToCalls enter" ));
    HRESULT hr = S_OK;

    //
    // Apply the sub event filter mask to all the calls on this address
    //
    for (int nCall = 0; nCall < m_CallArray.GetSize() ; nCall++ )
    {
        CCall * pCall = NULL;
        pCall = dynamic_cast<CCall *>(m_CallArray[nCall]);

        if ( NULL != pCall )
        {
            hr = pCall->SetSubEventFlag(
                TapiEvent, 
                dwSubEvent, 
                bEnable
                );

            if( FAILED(hr) )
            {
                break;
            }
        }
    }

    LOG((TL_TRACE, "SetSubEventFlagToCalls exit 0x%08x", hr));
    return hr;
}

/*++
GetSubEventsMask

  Is called by SetSubEventFlag to get the sub events mask for
  a specific TAPI_EVENT

  Assumed is called into a Lock statement
--*/
DWORD CAddress::GetSubEventsMask(
    IN  TAPI_EVENT TapiEvent
    )
{
    LOG((TL_TRACE, "GetSubEventsMask - enter"));

    DWORD dwSubEventFlag = m_EventMasks.GetSubEventMask( TapiEvent );

    LOG((TL_TRACE, "GetSubEventsMask - exit %ld", dwSubEventFlag));
    return dwSubEventFlag;
}

/*++
GetEventMasks

  It is called by CCall::Initialize()
--*/
HRESULT CAddress::GetEventMasks(
    OUT CEventMasks* pEventMasks
    )
{
    LOG((TL_TRACE, "GetEventMasks - enter"));

    m_EventMasks.CopyEventMasks( pEventMasks );

    LOG((TL_TRACE, "GetEventMasks - exit S_OK"));
    return S_OK;
}


////////////////////////////////////////////
//
//  RegisterNotificationCookie
//
//  adds the specified cookie to the list of cookies on this address
//

HRESULT CAddress::RegisterNotificationCookie(long lCookie)
{
    HRESULT hr = S_OK;

    LOG((TL_INFO, 
           "RegisterNotificationCookie - adding cookie %lx to m_NotificationCookies list", 
           lCookie ));

    Lock();

    try
    {
        m_NotificationCookies.push_back(lCookie);
    }
    catch(...)
    {
        LOG((TL_ERROR, 
            "RegisterNotificationCookie - failed to add a cookie to m_NotificationCookies list - alloc failure" ));

        hr = E_OUTOFMEMORY;
    }

    Unlock();

    return hr;
}


////////////////////////////////////////////
//
//  RemoveNotificationCookie
//
//  removes the specified cookie from this address's cookies
//

HRESULT CAddress::RemoveNotificationCookie(long lCookie)
{
    HRESULT hr = S_OK;

    LOG((TL_INFO, 
           "RemoveNotificationCookie - removing cookie %lx from m_NotificationCookies list", 
           lCookie ));

    Lock();

    m_NotificationCookies.remove(lCookie);

    Unlock();

    return hr;
}


////////////////////////////////////////////
//
//  UnregisterAllCookies
//
//  removes all cookies from this address's cookie list
//
//  for each valid cookie, call RemoveCallNotification
//

void CAddress::UnregisterAllCookies()
{
    LOG((TL_TRACE, "UnregisterAllCookies entering. this[%p]", this));

    Lock();

    LongList::iterator it = m_NotificationCookies.begin();

    LongList::iterator end = m_NotificationCookies.end();

    //
    // if there are any cookies, remove the corresponding registeritems 
    // from the handlehashtable
    //
    // also, unregister call notification for these cookies, to make sure
    // everything is cleaned up (and in particular that lineCloseMSPInstance
    // gets called if needed so the tsp gets notified that the msp is going
    // away
    // 

    for ( ; it != end; it++ )
    {
        long lCookie = (long)(*it);

        LOG((TL_INFO, "UnregisterAllCookies removing handle %lx", lCookie));

        
        //
        // get register item, so we can unregister call notifications with it.
        //

        REGISTERITEM *pRegisterItem = (REGISTERITEM*) GetHandleTableEntry(lCookie);


        //
        // remove the entry from the handle table
        //

        RemoveHandleFromHashTable(lCookie);


        //
        // if we did not get a good registeritem that corresponds to this cookie,
        // go on to the next cookie
        //

        if ( (NULL == pRegisterItem) || 
             IsBadReadPtr(pRegisterItem, sizeof(REGISTERITEM)) )
        {
            LOG((TL_INFO, 
                "UnregisterAllCookies - no corresponfing registeritem for cookie 0x%lx",
                lCookie));

            continue;
        }


        //
        // if the register item is not RA_ADDRESS, ignore it and go on to 
        // the next cookie.
        //

        if (RA_ADDRESS != pRegisterItem->dwType)
        {
            LOG((TL_INFO, 
                "UnregisterAllCookies - cookie 0x%lx is of type 0x%lx, not RA_ADDRESS",
                lCookie,
                pRegisterItem->dwType));

            continue;
        }


        //
        // remove call notification for this cookie, since the app did not 
        // do this. best effort -- ignore the error code.
        //

        LOG((TL_INFO,
            "UnregisterAllCookies - removing call notification for cookie 0x%lx",
            lCookie));

        RemoveCallNotification(pRegisterItem->pRegister);

    }
    

    //
    // clear cookie list
    //

    m_NotificationCookies.clear();


    Unlock();

    LOG((TL_TRACE, "UnregisterAllCookies exiting"));
}

///////////////////////////////////////////////////////////////////////////////
//
// CAddress::AddressOnTapiShutdown 
//
// this function is called by the owner tapi object when it is going away. 
//
// we then propagate tapi shutdown notification to each call, so the calls 
// can do their clean up
//

void CAddress::AddressOnTapiShutdown()
{

    LOG((TL_TRACE, "AddressOnTapiShutdown - enter"));


    //
    // protect access to m_CallArray
    //

    Lock();


    //
    // tell each call to clean up
    //

    int nCalls = m_CallArray.GetSize();

    for (int i = 0; i < nCalls; i++)
    {

        ITCallInfo *pCallInfo = m_CallArray[i];

        try 
        {

            //
            // get a pointer to the call object
            //

            CCall *pCallObject = dynamic_cast<CCall *>(pCallInfo);

            if (NULL == pCallObject)
            {


                //
                // the pointer is not pointing to a call object. this is odd 
                // and is worth debugging
                //
                
                LOG((TL_ERROR,
                    "AddressOnTapiShutdown - invalid call pointer[%p] in the call array",
                    pCallInfo));

                _ASSERTE(FALSE);

            }
            else
            {

                //
                // tell the call that it's time to go
                //

                pCallObject->CallOnTapiShutdown();
            }

        }
        catch(...)
        {

            //
            // not only is the pointer not pointing to a call object, but it is
            // also pointing to memory that is not readable. how did this happen?
            //

            LOG((TL_ERROR,
                "AddressOnTapiShutdown - unreadable call pointer[%p] in the call array",
                pCallInfo));

            _ASSERTE(FALSE);

        }

    }


    //
    // set the flag so no new calls are created following this
    //
    
    m_bTapiSignaledShutdown = TRUE;


    //
    // unregister the msp wait event in the thread pool. we don't want to get 
    // any callbacks after tapi has shut down
    //

    if ( NULL != m_hWaitEvent )
    {

        LOG((TL_TRACE, "AddressOnTapiShutdown - unregistering the MSPEventCallback callback"));

        UnregisterWaitEx( m_hWaitEvent, INVALID_HANDLE_VALUE);
        m_hWaitEvent = NULL;
    }

    

    Unlock();


    LOG((TL_TRACE, "AddressOnTapiShutdown - finish"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\tapi3\agent.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    Agent.h

Abstract:

    Declaration of the  CAgent & CAgentEvent Classes
    
Author:

    noela - 11/04/97

Notes:

Revision History:

--*/

#ifndef __AGENT_H_
#define __AGENT_H_

#include "resource.h"       // main symbols
#include "agenthand.h"

class CAgentHandler;
class CTAPI;


/////////////////////////////////////////////////////////////////////////////
// CAgent
class ATL_NO_VTABLE CAgent : 
	public CTAPIComObjectRoot<CAgent>,
	public IDispatchImpl<ITAgent, &IID_ITAgent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
private:
    PWSTR               m_szAgentUserName;
    PWSTR               m_szAgentID;
    PWSTR               m_szPIN;
    HAGENT              m_hAgent;
    CAgentHandler     * m_pHandler;      
    AgentSessionArray   m_AgentSessionArray;
    BOOL                m_bRequiresUpdating;


    AGENT_STATE         m_AgentState;
    AGENT_STATE         m_NextAgentState;
    DWORD               m_dwMeasurementPeriod;
    CURRENCY            m_cyOverallCallRate; 
    DWORD               m_dwNumberOfACDCalls;
    DWORD               m_dwNumberOfIncomingCalls;
    DWORD               m_dwNumberOfOutgoingCalls;
    DWORD               m_dwTotalACDTalkTime;
    DWORD               m_dwTotalACDCallTime;
    DWORD               m_dwTotalACDWrapUpTime;
    BOOL                m_bAgentHasBeenEnumerated;
    BOOL                m_bRegisteredForAgentEvents;
    BOOL                m_bRegisteredForAgentSessionEvents;


public:
	CAgent(){}

	~CAgent(){}
    
    BOOL wantsAgentEvents() {return m_bRegisteredForAgentEvents;}
    BOOL wantsAgentSessionEvents() {return m_bRegisteredForAgentSessionEvents;}
    BOOL agentHasID() { return ((m_szAgentID!=0)?1:0); }
    void SetState(AGENT_STATE state) { m_AgentState = state;}
    STDMETHOD(UpdateInfo) ();       
    STDMETHOD(CheckIfUpToDate) ();       
    inline void  SetRequiresUpdate() {m_bRequiresUpdating = TRUE;}
    inline HAGENT  getHandle() {return m_hAgent;}
    void FinalRelease();
    CAgentHandler * GetAgentHandler() { return m_pHandler; }

    STDMETHOD(InternalCreateSession)(ITACDGroup      * pACDGroup, 
                                     ITAddress       * pAddress, 
                                     PWSTR             pszPIN,
                                     ITAgentSession ** ppAgentSession);
    STDMETHOD(put_PIN) (BSTR pPIN);

DECLARE_DEBUG_ADDREF_RELEASE(CAgent)
DECLARE_MARSHALQI(CAgent)
DECLARE_QI()
DECLARE_TRACELOG_CLASS(CAgent)


BEGIN_COM_MAP(CAgent)
    COM_INTERFACE_ENTRY(ITAgent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()


// ITAgent
public:

    STDMETHOD(get_TotalWrapUpTime) (long * pulWrapUpTime);
    STDMETHOD(get_TotalACDCallTime) (long * pulCallTime);
    STDMETHOD(get_TotalACDTalkTime) (long * pulTalkTime);
    STDMETHOD(get_NumberOfOutgoingCalls) (long * pulCalls);
    STDMETHOD(get_NumberOfIncomingCalls) (long * pulCalls);
    STDMETHOD(get_NumberOfACDCalls) (long * pulCalls);
    STDMETHOD(get_OverallCallRate) (CURRENCY *pcyCallrate);
    STDMETHOD(get_MeasurementPeriod) (long *pulPeriod);
    STDMETHOD(put_MeasurementPeriod) (long ulPeriod);
    STDMETHOD(get_State) (AGENT_STATE * pAgentState);
    STDMETHOD(put_State) (AGENT_STATE AgentState);
    STDMETHOD(get_User) (BSTR * ppUser);
    STDMETHOD(get_ID) (BSTR *pID);
    STDMETHOD(CreateSession) (ITACDGroup * pACDGroup, 
                              ITAddress * pAddress, 
                              ITAgentSession ** ppAgentSession
                             );
    STDMETHOD(CreateSessionWithPIN) (ITACDGroup * pACDGroup, 
                                     ITAddress * pAddress, 
                                     BSTR pPIN, 
                                     ITAgentSession ** ppAgentSession
                                    );
    STDMETHOD(RegisterAgentEvents) (VARIANT_BOOL bNotify);
    STDMETHOD(RegisterAgentSessionEvents) (VARIANT_BOOL bNotify);
    STDMETHOD(EnumerateAgentSessions) (IEnumAgentSession ** ppEnumAgentSession);
    STDMETHOD(get_AgentSessions) (VARIANT  * pVariant);

    STDMETHOD(Initialize) 
        (
        HAGENT hAgent, 
        PWSTR pszUserName, 
        PWSTR pszID, 
        PWSTR pszPIN, 
        CAgentHandler * pHandler
        );

#if DBG

    STDMETHOD_(ULONG, InternalAddRef)()
    {
        DWORD   dwR;

        dwR = InterlockedIncrement(&m_dwRef);;

        LogDebugAddRef(dwR);

        return dwR;
    }

    
    STDMETHOD_(ULONG, InternalRelease)()
    {
        DWORD   dwR;

        dwR = InterlockedDecrement(&m_dwRef);

        LogDebugRelease( dwR );

        return dwR;
    }

#endif



};





/////////////////////////////////////////////////////////////////////////////
// CAgentEvent
class ATL_NO_VTABLE CAgentEvent : 
    public CTAPIComObjectRoot<CAgentEvent>,
    public IDispatchImpl<ITAgentEvent, &IID_ITAgentEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
protected:
    AGENT_EVENT         m_AgentEvent;
    ITAgent  *          m_pAgent;

public:
    CAgentEvent()
    {
    }

    static HRESULT FireEvent(
                             CAgent* pAgent,
                             AGENT_EVENT Event
                            );
    void FinalRelease();


DECLARE_MARSHALQI(CAgentEvent)
DECLARE_TRACELOG_CLASS(CAgentEvent)

BEGIN_COM_MAP(CAgentEvent)
    COM_INTERFACE_ENTRY(ITAgentEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

// ITAgentEvent
public:
    STDMETHOD(get_Event)(AGENT_EVENT * pEvent);
    STDMETHOD(get_Agent)(ITAgent ** ppAgent);
};




#endif //__AGENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\tapi3\agent.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    agent.cpp

Abstract:

    Implementation of the Agent object for TAPI 3.0.
    CAgent class
    CAgentEvent class

Author:

    noela - 11/04/97

Notes:

    optional-notes

Revision History:

--*/



#include "stdafx.h"


DWORD MapAgentStateFrom3to2(AGENT_STATE tapi3State);
HRESULT MapAgentStateFrom2to3(DWORD tapi2State, AGENT_STATE  *tapi3State);





/////////////////////////////////////////////////////////////////////////////
// CAgent



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Method    : Initialize
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::Initialize(
    HAGENT  hAgent, 
    PWSTR   pszUserName, 
    PWSTR   pszID, 
    PWSTR   pszPIN,
    CAgentHandler * pHandler
    )
{
    HRESULT  hr = S_OK;

    LOG((TL_TRACE, "Initialize - enter" ));

    m_bRegisteredForAgentEvents         = FALSE;  
    m_bRegisteredForAgentSessionEvents  = FALSE;  
    m_bRequiresUpdating                 = TRUE;

    m_pHandler          = pHandler;
    m_hAgent            = hAgent;
    m_AgentState        = AS_UNKNOWN;
    m_szAgentUserName   = NULL;
    m_szAgentID         = NULL;
    m_szPIN             = NULL;

    if (pszUserName != NULL)
    {
        m_szAgentUserName = (PWSTR) ClientAlloc((lstrlenW(pszUserName) + 1) * sizeof (WCHAR));
        if (m_szAgentUserName != NULL)
        {
            // Copy the name string
            lstrcpyW(m_szAgentUserName,pszUserName);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szAgentUserName failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    else  // Agent Name is aNULL string
    {
        LOG((TL_ERROR, "Initialize - Agent Name is NULL" ));
    }


    // Now do the  Agent ID
    if (pszID != NULL)
    {
        m_szAgentID = (PWSTR) ClientAlloc((lstrlenW(pszID) + 1) * sizeof (WCHAR));
        if (m_szAgentID != NULL)
        {
            lstrcpyW(m_szAgentID,pszID);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szAgentID failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    else  // ID is a NULL string
    {
        LOG((TL_INFO, "Initialize - Agent ID is NULL" ));
    }


    // Now do the  Agent PIN
    if (pszPIN != NULL)
    {
        m_szPIN = (PWSTR) ClientAlloc((lstrlenW(pszPIN) + 1) * sizeof (WCHAR));
        if (m_szPIN != NULL)
        {
            lstrcpyW(m_szPIN,pszPIN);
        }
        else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szPIN failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    else  // PIN is a NULL string
    {
        LOG((TL_INFO, "Initialize - Agent PIN is NULL" ));
    }


    // Get Agent Info from Proxy
    // UpdateInfo();

    if ( SUCCEEDED(hr) ) 
    {
    // Fire an event here
        CAgentEvent::FireEvent(this, AE_UNKNOWN);
    }

    LOG((TL_TRACE, "Initialize Agent - %S, %S", m_szAgentUserName, m_szAgentID ));
    LOG((TL_TRACE, hr, "Initialize - exit" ));
    return hr;
}





//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Method    : FinalRelease
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CAgent::FinalRelease()
{

    LOG((TL_TRACE, "FinalRelease Agent - %S", m_szAgentUserName ));
    if ( m_szAgentUserName != NULL )
    {
         ClientFree(m_szAgentUserName);
    }

    if ( m_szAgentID != NULL )
    {
         ClientFree(m_szAgentID);
    }

    if (m_szPIN != NULL)
    {
        ClientFree(m_szPIN);
    }

    m_AgentSessionArray.Shutdown();
    
    LOG((TL_TRACE, "FinalRelease Agent - exit"));

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Method    : UpdateInfo
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::UpdateInfo()
{
    HRESULT             hr = S_OK;
    LINEAGENTINFO       AgentInfo;


    LOG((TL_TRACE, "UpdateInfo - enter" ));
 
    AgentInfo.dwTotalSize = sizeof(LINEAGENTINFO);
    AgentInfo.dwNeededSize = sizeof(LINEAGENTINFO);
    AgentInfo.dwUsedSize = sizeof(LINEAGENTINFO);

    
    // **************************************************
    // Get Agent Info from Proxy
    hr = lineGetAgentInfo(
                        m_pHandler->getHLine(),
                        m_hAgent, 
                        &AgentInfo);

    if( SUCCEEDED(hr) )
    {
        // wait for async reply
        hr = WaitForReply( hr );
        if ( SUCCEEDED(hr) )
        {
            Lock();

            if( FAILED( MapAgentStateFrom2to3(AgentInfo.dwAgentState, &m_AgentState) ) )
            {    
                LOG((TL_ERROR, "UpdateInfo - AgentState is invalid %d - setting to AS_UNKNOWN", AgentInfo.dwAgentState));
            }    

            if( FAILED( MapAgentStateFrom2to3(AgentInfo.dwNextAgentState, &m_NextAgentState) ) )
            {    
                LOG((TL_ERROR, "UpdateInfo - NextAgentState is invalid %d - setting to AS_UNKNOWN",AgentInfo.dwNextAgentState));
            }    
                                    
            m_dwMeasurementPeriod     = AgentInfo.dwMeasurementPeriod;       
            m_cyOverallCallRate       = AgentInfo.cyOverallCallRate;       
            m_dwNumberOfACDCalls      = AgentInfo.dwNumberOfACDCalls;
            m_dwNumberOfIncomingCalls = AgentInfo.dwNumberOfIncomingCalls;
            m_dwNumberOfOutgoingCalls = AgentInfo.dwNumberOfOutgoingCalls;
            m_dwTotalACDTalkTime      = AgentInfo.dwTotalACDTalkTime;
            m_dwTotalACDCallTime      = AgentInfo.dwTotalACDCallTime;
            m_dwTotalACDWrapUpTime    = AgentInfo.dwTotalACDWrapUpTime;

            m_bRequiresUpdating = FALSE;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "UpdateInfo - call to lineGetAgentInfo failed async" ));
        }
    }
    else
    {
        LOG((TL_ERROR, "UpdateInfo - call to lineGetAgentInfo failed" ));
    }


    LOG((TL_TRACE, hr, "UpdateInfo - exit" ));
    return hr;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Method    : CheckIfUpToDate
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::CheckIfUpToDate()
{
    HRESULT     hr = S_OK;

    if (m_bRequiresUpdating)
    {
        hr = UpdateInfo();
    }
    return hr;
}






//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent
// Method    : EnumerateAgentSessions
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::EnumerateAgentSessions(IEnumAgentSession ** ppEnumAgentSession)
{
    ITAgent*    pITAgent;
    CAgent *    pAgent;
    HRESULT     hr = S_OK;

    LOG((TL_TRACE, "EnumerateAgentSessions - enter" ));
    LOG((TL_TRACE, "EnumerateAgentSessions - ppEnumAgentSessions %p", ppEnumAgentSession ));

    if(!TAPIIsBadWritePtr( ppEnumAgentSession, sizeof(IEnumAgentSession *) ) )
    {
        Lock();                                           
    
        //
        // create the enumerator
        //
        CComObject< CTapiEnum<IEnumAgentSession, ITAgentSession, &IID_IEnumAgentSession> > * pEnum;
        hr = CComObject< CTapiEnum<IEnumAgentSession, ITAgentSession, &IID_IEnumAgentSession> > ::CreateInstance( &pEnum );
    
        if ( SUCCEEDED (hr) )
        {
            //
            // initialize it with our Session list
            //
            pEnum->Initialize(m_AgentSessionArray);

            //
            // return it
            *ppEnumAgentSession = pEnum;
        }
        else
        {
            LOG((TL_TRACE, "EnumerateAgentSessions - could not create enum" ));
        }
        
        Unlock();
    }
    else
    {
        LOG((TL_ERROR, "EnumerateAgentSessions - bad ppEnumAgentSession pointer" ));
        hr = E_POINTER;
    }

    LOG((TL_ERROR, hr, "EnumerateAgentSessions - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent
// Method    : get_AgentSessions
//
// Return a collection of agent sessions
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::get_AgentSessions(VARIANT  * pVariant)
{
    HRESULT         hr = S_OK;
    IDispatch     * pDisp = NULL;


    LOG((TL_TRACE, "get_AgentSessions - enter"));

    if (!TAPIIsBadWritePtr( pVariant, sizeof(VARIANT) ) )
    {
        //
        // create the collection
        //
        CComObject< CTapiCollection< ITAgentSession > > * p;
        hr = CComObject< CTapiCollection< ITAgentSession > >::CreateInstance( &p );
        
        if (SUCCEEDED(hr) )
        {
            // initialize it with our address list
            Lock();
            hr = p->Initialize( m_AgentSessionArray );
            Unlock();
        
            if ( SUCCEEDED(hr) )
            {
                // get the IDispatch interface
                hr = p->_InternalQueryInterface( IID_IDispatch, (void **) &pDisp );
            
                if ( SUCCEEDED(hr) )
                {
                    // put it in the variant
                    VariantInit(pVariant);
                    pVariant->vt = VT_DISPATCH;
                    pVariant->pdispVal = pDisp;
                }
                else
                {
                    LOG((TL_ERROR, "get_AgentSessions - could not get IDispatch interface" ));
                    delete p;
                }
            }
            else
            {
                LOG((TL_ERROR, "get_AgentSessions - could not initialize collection" ));
                delete p;
            }
        }
        else
        {
            LOG((TL_ERROR, "get_AgentSessions - could not create collection" ));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_AgentSessions - bad pVariant pointer" ));
        hr = E_POINTER;
    }


    LOG((TL_TRACE, hr, "get_AgentSessions - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent   
// Method    : RegisterAgentEvents
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::RegisterAgentEvents(VARIANT_BOOL bNotify)
{
    HRESULT hr = S_OK;
    
    LOG((TL_TRACE, "RegisterAgentEvents - enter" ));
    
    m_bRegisteredForAgentEvents = bNotify;

    LOG((TL_TRACE, "RegisterAgentEvents - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent   
// Method    : RegisterAgentSessionEvents
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::RegisterAgentSessionEvents(VARIANT_BOOL bNotify)
{
    HRESULT hr = S_OK;

    LOG((TL_TRACE, "RegisterAgentSessionEvents - enter" ));

    m_bRegisteredForAgentSessionEvents = bNotify;

    LOG((TL_TRACE, hr, "RegisterAgentSessionEvents - exit" ));
    return hr;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent
// Method    : CreateSessionWithPIN
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::CreateSessionWithPIN(ITACDGroup       * pACDGroup, 
                                          ITAddress        * pAddress, 
                                          BSTR               pPIN,
                                          ITAgentSession  ** ppAgentSession
                                          )
{
    HRESULT hr = S_OK;


    LOG((TL_TRACE, "CreateSessionWithPIN - enter" ));


    if ( agentHasID() )
    {
        if(!TAPIIsBadWritePtr( ppAgentSession, sizeof(ITAgentSession *) ) )
        {
            if (!IsBadStringPtrW( pPIN, -1 ))
            {
                // Pointer OK, is it empty ?
                if( pPIN != NULL)
                {    
                    hr = InternalCreateSession(pACDGroup, pAddress, pPIN, ppAgentSession);
                }
                else // PIN is NULL
                {
                    LOG((TL_ERROR, "CreateSessionWithPIN - failed, PIN is NULL"));
                    hr = E_INVALIDARG;
                }
            }
            else // bad BSTR pointer
            {
                LOG((TL_ERROR, "CreateSessionWithPIN - invalid pPIN pointer" ));
                hr = E_POINTER;
            }
        }
        else
        {
            LOG((TL_ERROR, "CreateSessionWithPIN - invalid ppAgentSession pointer" ));
            hr = E_POINTER;
        }
    }
    else // no ID
    {
        LOG((TL_ERROR, "CreateSessionWithPIN - Agent not created by CreateAgentWithID()" ));
        hr = TAPI_E_CALLCENTER_NO_AGENT_ID;
    }
    
    
    LOG((TL_TRACE, hr, "CreateSessionWithPIN - exit" ));
    return hr;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent
// Method    : CreateSession
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::CreateSession(ITACDGroup       * pACDGroup, 
                                   ITAddress        * pAddress, 
                                   ITAgentSession  ** ppAgentSession
                                  )
{
    HRESULT hr = S_OK;


    LOG((TL_TRACE, "CreateSession - enter" ));

    if(!TAPIIsBadWritePtr( ppAgentSession, sizeof(ITAgentSession *) ) )
    {
        hr = InternalCreateSession(pACDGroup, pAddress, m_szPIN, ppAgentSession);
    }
    else
    {
        LOG((TL_ERROR, "CreateSession - invalid ppAgentSession pointer" ));
        hr = E_POINTER;
    }
    
    LOG((TL_TRACE, hr, "CreateSession - exit" ));
    return hr;
}





//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent
// Method    : CreateSession
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::InternalCreateSession(ITACDGroup      * pACDGroup, 
                                           ITAddress       * pAddress, 
                                           PWSTR             pszPIN,
                                           ITAgentSession ** ppAgentSession)
{
    HAGENTSESSION                   hAgentSession;
    LINEAGENTENTRY                  Agent;
    DWORD                           dwAddressID;
    GUID                            GroupID;
    CACDGroup                     * pGroup = NULL;
    CAddress                      * pCAddress = NULL;
    CComObject<CAgentSession>     * pAgentSession;
    AddressLineStruct             * pAddressLine;   


    HRESULT hr = S_OK;
    LOG((TL_TRACE, "InternalCreateSession - enter" ));

    // check for a valid ACD group & get its address ID
    pGroup = dynamic_cast<CComObject<CACDGroup>*>(pACDGroup);        
    if (pGroup != NULL)
    {
        GroupID = pGroup->getID();

        // check for a valid address & get its address ID
        pCAddress = dynamic_cast<CComObject<CAddress>*>(pAddress);        
        if (pCAddress != NULL)
        {
            dwAddressID = pCAddress->GetAddressID();
        
            hr  = pCAddress->FindOrOpenALine (LINEMEDIAMODE_INTERACTIVEVOICE, &pAddressLine);
            if(SUCCEEDED(hr) )
            {
                // All OK so far, try to create session (sends request to proxy)
                hr = LineCreateAgentSession(     
                        pAddressLine->t3Line.hLine,
                        m_hAgent,
                        pszPIN,
                        dwAddressID,
                        &GroupID,
                        &hAgentSession
                        );
                
                if ( SUCCEEDED(hr) )
                {
                    hr = WaitForReply( hr );
                    if ( SUCCEEDED(hr) )
                    {
                        LOG((TL_INFO, "InternalCreateSession - create new session" ));
                        hr = CComObject<CAgentSession>::CreateInstance( &pAgentSession );

                        if ( SUCCEEDED(hr) )
                        {
                            ITAgentSession * pITAgentSession;
                            hr = pAgentSession->QueryInterface(IID_ITAgentSession, (void **)&pITAgentSession);

                            if ( SUCCEEDED(hr) )
                            {
                                // initialize the Agent
                                hr = pAgentSession->Initialize(
                                        hAgentSession, 
                                        this, 
                                        pACDGroup, 
                                        pAddress, 
                                        m_pHandler,
                                        pAddressLine
                                        );
                                if ( SUCCEEDED(hr) )
                                {
                                
                                    // add to list
                                    Lock();
                                    m_AgentSessionArray.Add( pITAgentSession );
                                    Unlock();

                                    pITAgentSession->Release();
                                

                                    // This is the clients reference
                                    pAgentSession->AddRef();
        
                                    try
                                    {
                                        // set return value
                                        *ppAgentSession =  pAgentSession;
                                    }
                                    catch(...)
                                    {
                                        hr = E_POINTER;
                                    }
                                }
                                else  //(FAILED (hr) ) pAgentSession->Initialize
                                {
                                    LOG((TL_ERROR, "InternalCreateSession - failed to initialize new object" ));
                                    delete pAgentSession;
                                }
                            }
                            else  //(FAILED (hr) ) pAgentSession->QueryInterface
                            {
                                LOG((TL_ERROR, "InternalCreateSession - failed to query interface" ));
                                delete pAgentSession;
                            }

                        }
                        else  //(FAILED (hr) ) CreateInstance
                        {
                            LOG((TL_ERROR, "InternalCreateSession - createInstance failed for COM object" ));
                        }
                    }
                    else  // LineCreateAgentSession failed async
                    {
                        LOG((TL_ERROR, "InternalCreateSession - LineCreateAgentSession failed async" ));
                    }
                }
                else  //(FAILED (hr) ) LineCreateAgentSession
                {
                    LOG((TL_ERROR, "InternalCreateSession - LineCreateAgentSession failed" ));
                }
            }
            else
            {
            LOG((TL_ERROR, "InternalCreateSession - Failed to open a line for the target Address" ));
            hr = E_UNEXPECTED;
            }
        }
        else  //(pCAddress == NULL)
        {
            LOG((TL_ERROR, "InternalCreateSession - invalid Destination Address" ));
            hr = E_INVALIDARG;
        }
    }
    else  //(pGroup == NULL)
    {
        LOG((TL_ERROR, "InternalCreateSession - invalid ACDGroup" ));
        hr = E_INVALIDARG;
    }

            
    
    LOG((TL_TRACE, hr, "InternalCreateSession - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent
// Method    : ID
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::get_ID(BSTR * pID)
{
    HRESULT hr = S_OK;

    LOG((TL_TRACE, "ID - enter" ));
    Lock();

    if ( !agentHasID() )
    {
        LOG((TL_ERROR, "ID - Agent not created by CreateAgentWithID()" ));
        hr = TAPI_E_CALLCENTER_NO_AGENT_ID;
    }
    
    if(!TAPIIsBadWritePtr( pID, sizeof(BSTR) ) )
    {
        if (m_szAgentID == NULL)
        {
            *pID = NULL;
        }
        else
        {
            *pID = SysAllocString(m_szAgentID);
            if (*pID == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
        }

    }
    else
    {
        LOG((TL_ERROR, "ID - bad pID pointer" ));
        hr = E_POINTER;
    }



    Unlock();
    LOG((TL_TRACE, hr, "ID - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent
// Method    : User
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::get_User(BSTR * ppUser)
{
    HRESULT hr = S_OK;

    LOG((TL_TRACE, "User - enter" ));
    Lock();
    
    if(!TAPIIsBadWritePtr( ppUser, sizeof(BSTR) ) )
    {
        *ppUser = SysAllocString(m_szAgentUserName);
    
        if (*ppUser == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_ERROR, "User - bad ppUser pointer" ));
        hr = E_POINTER;
    }

    Unlock();
    LOG((TL_TRACE, hr, "User - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent
// Method    : put_State
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::put_State(AGENT_STATE AgentState)
{
    HRESULT hr = S_OK;
    HLINE   hLine;    
    DWORD   dwState = 0;



    LOG((TL_TRACE, "put_State - enter" ));

    Lock();
    hLine = (GetAgentHandler() )->getHLine();
    Unlock();

    dwState = MapAgentStateFrom3to2(AgentState);

    hr = lineSetAgentStateEx
            (hLine, 
             m_hAgent, 
             dwState,
             0          //MapAgentStateFrom3to2(m_NextAgentState)
            );
    
    if( SUCCEEDED(hr) )
    {
        // wait for async reply
        hr = WaitForReply( hr );
        if ( SUCCEEDED(hr) )
        {
            Lock();
            m_AgentState =  AgentState;
            Unlock();
            switch(AgentState) {
                case AS_NOT_READY:
                CAgentEvent::FireEvent(this, AE_NOT_READY);
                break;
                case AS_READY:
                CAgentEvent::FireEvent(this, AE_READY);
                break;
                case AS_BUSY_ACD:
                CAgentEvent::FireEvent(this, AE_BUSY_ACD);
                break;
                case AS_BUSY_INCOMING:
                CAgentEvent::FireEvent(this, AE_BUSY_INCOMING);
                break;
                case AS_BUSY_OUTGOING:
                CAgentEvent::FireEvent(this, AE_BUSY_OUTGOING);
                case AS_UNKNOWN:
                CAgentEvent::FireEvent(this, AE_UNKNOWN);
                break;
            }

        }
        else
        {
            LOG((TL_ERROR, "put_State - lineSetAgentStateEx failed async" ));
        }
    }
    else
    {
        LOG((TL_ERROR, "put_State - lineSetAgentStateEx failed" ));
    }

    LOG((TL_TRACE, hr, "put_State - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent
// Method    : get_State
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::get_State(AGENT_STATE * pAgentState)
{
    HRESULT hr = S_OK;

    LOG((TL_TRACE, "get_State - enter" ));
    
    if(!TAPIIsBadWritePtr( pAgentState, sizeof(AGENT_STATE) ) )
        {
        Lock();
        *pAgentState = m_AgentState;
        Unlock();
        }
    else
        {
        LOG((TL_ERROR, "get_State - bad pAgentState pointer"));
        hr = E_POINTER;
        }
  
    LOG((TL_TRACE, hr, "get_State - exit" ));
    return hr;
    }




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent
// Method    : put_MeasurementPeriod
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::put_MeasurementPeriod(long ulPeriod)
{
    HRESULT hr = S_OK;
    

    LOG((TL_TRACE, "put_MeasurementPeriod - enter" ));
    
    // Tell Proxy
    hr = lineSetAgentMeasurementPeriod(
                    m_pHandler->getHLine(),
                    m_hAgent, 
                    ulPeriod);

    if( SUCCEEDED(hr) )
    {
        // wait for async reply
        hr = WaitForReply( hr );
        if ( SUCCEEDED(hr) )
        {
            Lock();
            m_dwMeasurementPeriod = ulPeriod;    
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "put_MeasurementPeriod - call to LineSetAgentMeasurementPeriod failed async" ));
        }
    }
    else
    {
        LOG((TL_ERROR, "put_MeasurementPeriod - call to LineSetAgentMeasurementPeriod failed" ));
    }
    

    LOG((TL_TRACE, hr, "put_MeasurementPeriod - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent
// Method    : get_MeasurementPeriod
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::get_MeasurementPeriod(long * pulPeriod)
{
    HRESULT hr = S_OK;
    DWORD   period;


    LOG((TL_TRACE, "get_MeasurementPeriod  - enter" ));

    if(!TAPIIsBadWritePtr( pulPeriod, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pulPeriod = m_dwMeasurementPeriod;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_MeasurementPeriod - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_MeasurementPeriod -bad pulPeriod pointer" ));
        hr = E_POINTER;
    }

    LOG((TL_TRACE, hr, "get_MeasurementPeriod - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent
// Method    : OverallCallrate
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::get_OverallCallRate(CURRENCY * pcyCallrate)
{
    HRESULT hr = S_OK;


    LOG((TL_TRACE, "OverallCallrate - enter" ));
    if (!TAPIIsBadWritePtr( pcyCallrate, sizeof(CURRENCY) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pcyCallrate = m_cyOverallCallRate;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_OverallCallRate - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_OverallCallRate - bad pcyCallrate pointer"));
        hr = E_POINTER;
    }
  
    LOG((TL_TRACE, hr, "OverallCallrate - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent
// Method    : NumberOfACDCalls
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::get_NumberOfACDCalls(long * pulCalls)
{
    HRESULT hr = S_OK;


    LOG((TL_TRACE, "NumberOfACDCalls - enter" ));
    if (!TAPIIsBadWritePtr( pulCalls, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pulCalls = m_dwNumberOfACDCalls;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_NumberOfACDCalls - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_NumberOfACDCalls - bad pulCalls pointer"));
        hr = E_POINTER;
    }
  
    LOG((TL_TRACE, hr, "NumberOfACDCalls - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent
// Method    : NumberOfIncomingCalls
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::get_NumberOfIncomingCalls(long * pulCalls)
{
    HRESULT hr = S_OK;
    
    
    LOG((TL_TRACE, "NumberOfIncomingCalls - enter" ));
    if (!TAPIIsBadWritePtr( pulCalls, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pulCalls = m_dwNumberOfIncomingCalls;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_NumberOfIncomingCalls - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_NumberOfIncomingCalls - bad pulCalls pointer"));
        hr = E_POINTER;
    }
  
    LOG((TL_TRACE, hr, "NumberOfIncomingCalls - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent
// Method    : NumberOfOutgoingCalls
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::get_NumberOfOutgoingCalls(long * pulCalls)
{
    HRESULT hr = S_OK;

    
    LOG((TL_TRACE, "NumberOfOutgoingCalls - enter" ));
    if (!TAPIIsBadWritePtr( pulCalls, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pulCalls = m_dwNumberOfOutgoingCalls;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_NumberOfOutgoingCalls - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_NumberOfOutgoingCalls - bad pulCalls pointer"));
        hr = E_POINTER;
    }
  
    LOG((TL_TRACE, hr, "NumberOfOutgoingCalls - exit" ));
    return hr;
}

                                                          

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent
// Method    : TotalACDTalkTime
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::get_TotalACDTalkTime(long * pulTalkTime)
{
    HRESULT hr = S_OK;
    
    
    LOG((TL_TRACE, "TotalACDTalkTime - enter" ));
    if (!TAPIIsBadWritePtr( pulTalkTime, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pulTalkTime = m_dwTotalACDTalkTime;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_TotalACDTalkTime - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_TotalACDTalkTime - bad pulTalkTime pointer"));
        hr = E_POINTER;
    }
  
    LOG((TL_TRACE, hr, "TotalACDTalkTime - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent
// Method    : TotalACDCallTime
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::get_TotalACDCallTime(long * pulCallTime)
{
    HRESULT hr = S_OK;


    LOG((TL_TRACE, "TotalACDCallTime - enter" ));
    if (!TAPIIsBadWritePtr( pulCallTime, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pulCallTime = m_dwTotalACDCallTime;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_TotalACDCallTime - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_TotalACDCallTime - bad pulCallTime pointer"));
        hr = E_POINTER;
    }
  
    LOG((TL_TRACE, hr, "TotalACDCallTime - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent
// Method    : TotalWrapUpTime
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::get_TotalWrapUpTime(long * pulWrapUpTime)
{
    HRESULT hr = S_OK;
    
    
    LOG((TL_TRACE, "TotalWrapUpTime - enter" ));
    if (!TAPIIsBadWritePtr( pulWrapUpTime, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pulWrapUpTime = m_dwTotalACDWrapUpTime;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_TotalWrapUpTime - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_TotalWrapUpTime - bad pulWrapUpTime pointer"));
        hr = E_POINTER;
    }
  
    LOG((TL_TRACE, hr, "TotalWrapUpTime - exit" ));
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgent
// Interface : ITAgent
// Method    : put_PIN
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgent::put_PIN(BSTR pPIN)
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "put_PIN - enter" ));

    if (!IsBadStringPtrW( pPIN, -1 ))
    {
        // Pointer OK, is it empty ?
        if( pPIN != NULL)
        {    
            // do we have an existng PIN ?
            if (m_szPIN != NULL)
            {
                LOG((TL_INFO, "put_PIN - Overwrite exising PIN"));
                ClientFree(m_szPIN);
            }    
    
            // Alloc space for new PIN
            m_szPIN = (PWSTR) ClientAlloc((lstrlenW(pPIN) + 1) * sizeof (WCHAR));
            if (m_szPIN != NULL)
            {
                lstrcpyW(m_szPIN, pPIN);
            }
            else
            {
                LOG((TL_ERROR, "put_PIN - ClientAlloc m_szPIN failed" ));
                hr = E_OUTOFMEMORY;
            }
        }
        else // PIN is NULL
        {
            LOG((TL_ERROR, "put_PIN - failed, PIN is NULL"));
            hr = E_INVALIDARG;
        }
    }
    else // bad BSTR pointer
    {
        LOG((TL_ERROR, "put_PIN - invalid pointer" ));
        return E_POINTER;
    }

    LOG((TL_TRACE, hr, "put_PIN - exit" ));
    return hr;
}











/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
// CAgentEvent



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentEvent
// Method    : FireEvent
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CAgentEvent::FireEvent(CAgent* pAgent, AGENT_EVENT Event)
{
    HRESULT                    hr = S_OK;
    CComObject<CAgentEvent>  * pEvent;
    IDispatch                * pIDispatch;


    //
    // create event
    //
    hr = CComObject<CAgentEvent>::CreateInstance( &pEvent );

    if ( SUCCEEDED(hr) )
    {
        //
        // initialize
        //
        pEvent->m_AgentEvent = Event;
        pEvent->m_pAgent= dynamic_cast<ITAgent *>(pAgent);
        pEvent->m_pAgent->AddRef();
    
        //
        // get idisp interface
        //
        hr = pEvent->QueryInterface( IID_IDispatch, (void **)&pIDispatch );

        if ( SUCCEEDED(hr) )
        {
            //
            // get callback & fire event

            //
            CTAPI *pTapi = (pAgent->GetAgentHandler() )->GetTapi();
            pTapi->Event( TE_AGENT, pIDispatch );
        
            // release stuff
            //
            pIDispatch->Release();
            
        }
        else
        {
            STATICLOG((TL_ERROR, "(Event)FireEvent - Could not get disp interface of AgentEvent object"));
            delete pEvent;
        }
    }
    else
    {
        STATICLOG((TL_ERROR, "(Event)FireEvent - Could not create AgentEvent object"));
    }

   
    STATICLOG((TL_TRACE, hr, "(Event)FireEvent - exit"));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentEvent
// Method    : FinalRelease
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CAgentEvent::FinalRelease()
{
    m_pAgent->Release();

}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentEvent
// Interface : ITAgentEvent
// Method    : Agent
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentEvent::get_Agent(ITAgent ** ppAgent)
{
    HRESULT hr = S_OK;


    LOG((TL_TRACE, "(Event)Agent - enter" ));
    
    if(!TAPIIsBadWritePtr( ppAgent, sizeof(ITAgent *) ) )
    {
        *ppAgent = m_pAgent;
        m_pAgent->AddRef();
    }
    else
    {
        LOG((TL_ERROR, "(Event)Agent - bad ppAgent pointer"));
        hr = E_POINTER;
    }
            
    LOG((TL_TRACE, hr, "(Event)Agent - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentEvent
// Interface : ITAgentEvent
// Method    : Event
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentEvent::get_Event(AGENT_EVENT * pEvent)
{
    HRESULT hr = S_OK;

    
    LOG((TL_TRACE, "Event - enter" ));
    
    if(!TAPIIsBadWritePtr( pEvent, sizeof(AGENT_EVENT) ) )
    {
        *pEvent = m_AgentEvent;
    }
    else
    {
        LOG((TL_ERROR, "Event - bad pEvent pointer"));
        hr = E_POINTER;
    }
    
    LOG((TL_TRACE, hr, "Event - exit"));
    return hr;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function  : MapAgentStateFrom3to2
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD MapAgentStateFrom3to2(AGENT_STATE tapi3State)
{
    DWORD tapi2State = 0;

    switch(tapi3State)
    {
        case  AS_NOT_READY:
            tapi2State = LINEAGENTSTATEEX_NOTREADY;
            break;
        case  AS_READY:
            tapi2State = LINEAGENTSTATEEX_READY;
            break;
        case  AS_BUSY_ACD:
            tapi2State = LINEAGENTSTATEEX_BUSYACD;
            break;
        case  AS_BUSY_INCOMING:
            tapi2State = LINEAGENTSTATEEX_BUSYINCOMING;
            break;
        case  AS_BUSY_OUTGOING:
            tapi2State = LINEAGENTSTATEEX_BUSYOUTGOING;
            break;
        case AS_UNKNOWN:
            tapi2State = LINEAGENTSTATEEX_UNKNOWN;
            break;
        default:
            break;
    }

    return tapi2State;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function  : MapAgentStateFrom2to3
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT MapAgentStateFrom2to3(DWORD tapi2State, AGENT_STATE  *tapi3State)
{
    HRESULT hr = S_OK;


    if (tapi2State & LINEAGENTSTATEEX_NOTREADY)
    {
        *tapi3State = AS_NOT_READY;
    }
    else if (tapi2State & LINEAGENTSTATEEX_READY)
    {
        *tapi3State = AS_READY;
    }
    else if (tapi2State & LINEAGENTSTATEEX_BUSYACD)
    {
        *tapi3State = AS_BUSY_ACD;
    }
    else if (tapi2State & LINEAGENTSTATEEX_BUSYINCOMING)
    {
        *tapi3State = AS_BUSY_INCOMING;
    }
    else if (tapi2State & LINEAGENTSTATEEX_BUSYOUTGOING)
    {
        *tapi3State = AS_BUSY_OUTGOING;
    }
    else if (tapi2State & LINEAGENTSTATEEX_UNKNOWN)
    {
        *tapi3State = AS_UNKNOWN;
    }
    else
    {
        *tapi3State = AS_UNKNOWN;   // default
        hr = E_INVALIDARG;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\tapi3\agenthand.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    AgentHand.h

Abstract:

    Declaration of the CAgentHandler Class
    
Author:

    noela  02-06-98

Notes:

Revision History:

--*/

#ifndef __AGENTHANDLER_H
#define __AGENTHANDLER_H

#include "resource.h"       // main symbols

class CAgent;
class CTAPI;
class CAgentSession;
class CQueue;

/////////////////////////////////////////////////////////////////////////////
// CAgentHandler
class ATL_NO_VTABLE CAgentHandler : 
	public CTAPIComObjectRoot<CAgentHandler>,
	public IDispatchImpl<ITAgentHandler, &IID_ITAgentHandler, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
private:
    PWSTR                   m_szName;
    GUID                    m_GUID;    
    AddressLineStruct     * m_pAddressLine;   // Where we find our hLine
    CTAPI                 * m_tapiObj;        // Tapi obj this AH belongs to
    
    GroupArray              m_GroupArray;
    AgentArray              m_AgentArray;
    AddressArray            m_AddressArray;
    CHashTable              m_AgentSessionHashtable;
    CHashTable              m_QueueHashtable;


public:
	CAgentHandler(){}
	
    GUID getHandle() {return m_GUID;}
    HRESULT InternalCreateAgent(BSTR pID, BSTR pPIN, CAgent ** ppAgent);
    void AddAddress(CAddress *pAddress);
    HLINE getHLine();
    CTAPI * GetTapi() { return m_tapiObj; }
	HRESULT UpdateGroupArray();

    void FinalRelease();


    void AddAgentSessionToHash(HAGENTSESSION hSession, CAgentSession *pSession)
    {
        m_AgentSessionHashtable.Lock();
        m_AgentSessionHashtable.Insert( (ULONG_PTR)(hSession), (ULONG_PTR)pSession );
        m_AgentSessionHashtable.Unlock();
    }
    void RemoveAgentSessionFromHash(HAGENTSESSION hSession)
    {
        m_AgentSessionHashtable.Lock();
        m_AgentSessionHashtable.Remove( (ULONG_PTR)(hSession) );
        m_AgentSessionHashtable.Unlock();
    }
    BOOL FindSessionObject(HAGENTSESSION  hAgentSession, CAgentSession  ** ppAgentSession);

    void AddQueueToHash(DWORD dwQueueID, CQueue *pQueue)
    {
        m_QueueHashtable.Lock();
        m_QueueHashtable.Insert( (ULONG_PTR)(dwQueueID), (ULONG_PTR)pQueue );
        m_QueueHashtable.Unlock();
    }
    void RemoveQueueFromHash(DWORD dwQueueID)
    {
        m_QueueHashtable.Lock();
        m_QueueHashtable.Remove( (ULONG_PTR)(dwQueueID) );
        m_QueueHashtable.Unlock();
    }
    BOOL FindQueueObject(DWORD  dwQueueID,CQueue ** ppQueue);
    BOOL FindAgentObject( HAGENT hAgent, CAgent ** ppAgent);


DECLARE_MARSHALQI(CAgentHandler)    
DECLARE_QI()
DECLARE_TRACELOG_CLASS(CAgentHandler)

BEGIN_COM_MAP(CAgentHandler)
	COM_INTERFACE_ENTRY(ITAgentHandler)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

// ITAgentHandler
public:
	STDMETHOD(get_Name)(BSTR * ppName);
	STDMETHOD(CreateAgent)(ITAgent **ppAgent);
	STDMETHOD(CreateAgentWithID)(BSTR pID, BSTR pPIN, ITAgent **ppAgent);
	STDMETHOD(EnumerateACDGroups)(IEnumACDGroup ** ppEnumGroup);
    STDMETHOD(get_ACDGroups)(VARIANT  * pVariant);
    STDMETHOD(EnumerateUsableAddresses)(IEnumAddress ** ppEnumAddress);
    STDMETHOD(get_UsableAddresses)(VARIANT  * pVariant);
               
	
	STDMETHOD(Initialize) (PWSTR proxyName, GUID proxyGUID, CTAPI *tapiObj);       
};




/////////////////////////////////////////////////////////////////////////////
// CAgentHandlerEvent
class ATL_NO_VTABLE CAgentHandlerEvent : 
	public CTAPIComObjectRoot<CAgentHandlerEvent>,
	public IDispatchImpl<ITAgentHandlerEvent, &IID_ITAgentHandlerEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
protected:
    AGENTHANDLER_EVENT         m_AgentHandlerEvent;
    ITAgentHandler  *          m_pAgentHandler;

public:
	CAgentHandlerEvent()
	{
	}

	static HRESULT FireEvent(
                             CAgentHandler * pAgentHandler,
                             AGENTHANDLER_EVENT Event
                            );

    void FinalRelease();

DECLARE_MARSHALQI(CAgentHandlerEvent)
DECLARE_TRACELOG_CLASS(CAgentHandlerEvent)

BEGIN_COM_MAP(CAgentHandlerEvent)
	COM_INTERFACE_ENTRY(ITAgentHandlerEvent)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

// CAgentHandlerEvent
public:
	STDMETHOD(get_Event)(AGENTHANDLER_EVENT * pEvent);
	STDMETHOD(get_AgentHandler)(ITAgentHandler ** ppAgentHandler);

};




#endif //__AGENTHANDLER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\tapi3\address.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    Address.h

Abstract:

    Declaration of the CAddress
    
Author:

    mquinton - 06/12/97

Notes:

Revision History:

--*/

#ifndef __ADDRESS_H_
#define __ADDRESS_H_

#include "resource.h"       // main symbols

#ifdef USE_PHONEMSP
#include "terminal.h"
#endif USE_PHONEMSP

#include "ObjectSafeImpl.h"

#include <mspenum.h> // for CSafeComEnum

class CAddress;
class CTerminal;
class CTAPI;

extern CHashTable             * gpLineHashTable;
extern CHashTable             * gpHandleHashTable;
extern void RemoveHandleFromHashTable(ULONG_PTR Handle);



// address flag defines
#define ADDRESSFLAG_MSP                 0x00000001
#define ADDRESSFLAG_WAVEOUTDEVICE       0x00000002
#define ADDRESSFLAG_WAVEINDEVICE        0x00000004
#define ADDRESSFLAG_PHONEDEVICE         0x00000008
#define ADDRESSFLAG_DATAMODEM           0x00000010
#define ADDRESSFLAG_PRIVATEOBJECTS      0x00000020
#define ADDRESSFLAG_CALLHUB             0x00000100
#define ADDRESSFLAG_CALLHUBTRACKING     0x00000200
#define ADDRESSFLAG_WAVEFULLDUPLEX      0x00000400

#define ADDRESSFLAG_NOCALLHUB           0x00010000
#define ADDRESSFLAG_DEVSTATECHANGE      0x00020000
#define ADDRESSFLAG_ADDRESSSTATECHANGE  0x00040000
#define ADDRESSFLAG_DEVCAPSCHANGE       0x00080000
#define ADDRESSFLAG_ADDRESSCAPSCHANGE   0x00100000

#define ADDRESSFLAG_AMREL   (ADDRESSFLAG_MSP | ADDRESSFLAG_WAVEINDEVICE | ADDRESSFLAG_WAVEOUTDEVICE | ADDRESSFLAG_WAVEFULLDUPLEX)

#define CALLHUBSUPPORT_FULL             1
#define CALLHUBSUPPORT_NONE             3
#define CALLHUBSUPPORT_UNKNOWN          4

// Status message defines, set by LineSetStatusMessages( )
#define ALL_LINEDEVSTATE_MESSAGES       (LINEDEVSTATE_OTHER             | \
                                        LINEDEVSTATE_RINGING            | \
                                        LINEDEVSTATE_CONNECTED          | \
                                        LINEDEVSTATE_DISCONNECTED       | \
                                        LINEDEVSTATE_MSGWAITON          | \
                                        LINEDEVSTATE_MSGWAITOFF         | \
                                        LINEDEVSTATE_INSERVICE          | \
                                        LINEDEVSTATE_OUTOFSERVICE       | \
                                        LINEDEVSTATE_MAINTENANCE        | \
                                        LINEDEVSTATE_OPEN               | \
                                        LINEDEVSTATE_CLOSE              | \
                                        LINEDEVSTATE_NUMCALLS           | \
                                        LINEDEVSTATE_NUMCOMPLETIONS     | \
                                        LINEDEVSTATE_TERMINALS          | \
                                        LINEDEVSTATE_ROAMMODE           | \
                                        LINEDEVSTATE_BATTERY            | \
                                        LINEDEVSTATE_SIGNAL             | \
                                        LINEDEVSTATE_DEVSPECIFIC        | \
                                        LINEDEVSTATE_REINIT             | \
                                        LINEDEVSTATE_LOCK               | \
                                        LINEDEVSTATE_CAPSCHANGE         | \
                                        LINEDEVSTATE_CONFIGCHANGE       | \
                                        LINEDEVSTATE_TRANSLATECHANGE    | \
                                        LINEDEVSTATE_COMPLCANCEL        | \
                                        LINEDEVSTATE_REMOVED)

#define ALL_LINEADDRESSSTATE_MESSAGES   (LINEADDRESSSTATE_OTHER         | \
                                        LINEADDRESSSTATE_DEVSPECIFIC    | \
                                        LINEADDRESSSTATE_INUSEZERO      | \
                                        LINEADDRESSSTATE_INUSEONE       | \
                                        LINEADDRESSSTATE_INUSEMANY      | \
                                        LINEADDRESSSTATE_NUMCALLS       | \
                                        LINEADDRESSSTATE_FORWARD        | \
                                        LINEADDRESSSTATE_TERMINALS      | \
                                        LINEADDRESSSTATE_CAPSCHANGE) 


/////////////////////////////////////////////////////////////////
// Intermediate classes  used for DISPID encoding
template <class T>
class  ITAddress2Vtbl : public ITAddress2
{
};

template <class T>
class  ITAddressCapabilitiesVtbl : public ITAddressCapabilities
{
};
                                                                           
template <class T>
class  ITMediaSupportVtbl : public ITMediaSupport
{
};
                                                                           
template <class T>
class  ITAddressTranslationVtbl : public ITAddressTranslation
{
};
                                                                           
template <class T>
class  ITLegacyAddressMediaControl2Vtbl : public ITLegacyAddressMediaControl2
{
};
                                                                          

/////////////////////////////////////////////////////////////////////////////
// CEventMasks

class CEventMasks
{
public:
    CEventMasks()
    {
        m_dwTapiObjectMask = EM_NOSUBEVENTS;
        m_dwAddressMask = EM_NOSUBEVENTS;
        m_dwCallNotificationMask = EM_NOSUBEVENTS;
        m_dwCallStateMask = EM_NOSUBEVENTS;
        m_dwCallMediaMask = EM_NOSUBEVENTS;
        m_dwCallHubMask = EM_NOSUBEVENTS;
        m_dwCallInfoChangeMask = EM_NOSUBEVENTS;
        m_dwQOSEventMask = EM_NOSUBEVENTS;
        m_dwFileTerminalMask = EM_NOSUBEVENTS;
        m_dwPrivateMask = EM_NOSUBEVENTS;
        m_dwAddressDevSpecificMask = EM_NOSUBEVENTS;
        m_dwPhoneDevSpecificMask = EM_NOSUBEVENTS;
    }

    ~CEventMasks()
    {
    }

DECLARE_TRACELOG_CLASS(CEventMasks)

private:
    //
    // Event masks
    // Some event come from MSP:
    //  TE_ADDRESS, TE_CALLMEDIA, TE_FILETERMINAL
    //
    DWORD   m_dwTapiObjectMask;         // TE_TAPIOBJECT
    DWORD   m_dwAddressMask;            // TE_ADDRESS           MSP
    DWORD   m_dwCallNotificationMask;   // TE_CALLNOTIFICATION
    DWORD   m_dwCallStateMask;          // TE_CALLSTATE
    DWORD   m_dwCallMediaMask;          // TE_CALLMEDIA         MSP
    DWORD   m_dwCallHubMask;            // TE_CALLHUB
    DWORD   m_dwCallInfoChangeMask;     // TE_CALLINFOCHANGE
    DWORD   m_dwQOSEventMask;           // TE_QOSEVENT
    DWORD   m_dwFileTerminalMask;       // TE_FILETERMINAL      MSP
    DWORD   m_dwPrivateMask;            // TE_PRIVATE           MSP
    DWORD   m_dwAddressDevSpecificMask; // TE_ADDRESSDEVSPECIFIC
    DWORD   m_dwPhoneDevSpecificMask;   // TE_PHONEDEVSPECIFIC

public:
    // Constants
    static const DWORD EM_ALLSUBEVENTS  = 0x0FFFFFFF;
    static const DWORD EM_NOSUBEVENTS   = 0x00000000;

    static const DWORD  EM_ALLEVENTS    = (DWORD)(-1);

public:
    // Public methods
    HRESULT SetSubEventFlag(
        DWORD   dwEvent,        // The event 
        DWORD   dwFlag,         // The flag that should be setted
        BOOL    bEnable
        );

    HRESULT GetSubEventFlag(
        DWORD   dwEvent,        // The event 
        DWORD   dwFlag,         // The flag that should be setted
        BOOL*   pEnable
        );

    DWORD GetSubEventMask(
        TAPI_EVENT  TapiEvent
        );

    BOOL IsSubEventValid(
        TAPI_EVENT  TapiEvent,
        DWORD       dwSubEvent,
        BOOL        bAcceptAllSubEvents,
        BOOL        bCallLevel
        );

    HRESULT CopyEventMasks(
        CEventMasks* pEventMasks
        );

    HRESULT SetTapiSrvAddressEventMask(
        IN  HLINE   hLine
        );

    HRESULT SetTapiSrvCallEventMask(
        IN  HCALL   hCall
        );

private:
    ULONG64 GetTapiSrvEventMask(
        IN  BOOL bCallLevel);
    DWORD   GetTapiSrvLineStateMask();
    DWORD   GetTapiSrvAddrStateMask();
};
                                                                  
/////////////////////////////////////////////////////////////////////////////
// CAddress
class CAddress :
    public CTAPIComObjectRoot<CAddress>,
    public IDispatchImpl<ITAddress2Vtbl<CAddress>, &IID_ITAddress2, &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITAddressCapabilitiesVtbl<CAddress>, &IID_ITAddressCapabilities, &LIBID_TAPI3Lib>,    
    public IDispatchImpl<ITMediaSupportVtbl<CAddress>, &IID_ITMediaSupport, &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITAddressTranslationVtbl<CAddress>, &IID_ITAddressTranslation, &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITLegacyAddressMediaControl2Vtbl<CAddress>, &IID_ITLegacyAddressMediaControl2, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
    
public:
            
    CAddress() : m_pTAPI(NULL),
                 m_hLineApp(NULL),
                 m_hLine(NULL),
#ifdef USE_PHONEMSP
                 m_hPhoneApp(NULL),
#endif USE_PHONEMSP
                 m_dwAPIVersion(0),
                 m_dwDeviceID(0),
                 m_dwAddressID(0),
                 m_dwMediaModesSupported(0),
                 m_szAddress(NULL),
                 m_szAddressName(NULL),
                 m_szProviderName(NULL),
                 m_pMSPAggAddress(NULL),
                 m_pPrivate(NULL),
                 m_hMSPEvent(NULL),
                 m_hWaitEvent(NULL),
                 m_MSPContext(0),
                 m_dwAddressFlags(0),
                 m_fEnableCallHubTrackingOnLineOpen(TRUE),
                 m_bTapiSignaledShutdown(FALSE)

    { 
        LOG((TL_TRACE, "CAddress[%p] - enter", this));
        LOG((TL_TRACE, "CAddress - exit"));
    }


    ~CAddress()
    {
        LOG((TL_TRACE, "~CAddress[%p] - enter", this));
        LOG((TL_TRACE, "~CAddress - exit"));
    }

DECLARE_DEBUG_ADDREF_RELEASE(CAddress)
DECLARE_QI()
DECLARE_MARSHALQI(CAddress)
DECLARE_TRACELOG_CLASS(CAddress)


BEGIN_COM_MAP(CAddress)
//    COM_INTERFACE_ENTRY_FUNC(IID_IDispatch, 0, IDispatchQI)
    COM_INTERFACE_ENTRY2(IDispatch, ITAddress2)
    COM_INTERFACE_ENTRY(ITAddress)
    COM_INTERFACE_ENTRY(ITAddress2)
    COM_INTERFACE_ENTRY(ITMediaSupport)
    COM_INTERFACE_ENTRY(ITAddressCapabilities)
    COM_INTERFACE_ENTRY(ITAddressTranslation)
    COM_INTERFACE_ENTRY(ITLegacyAddressMediaControl)    
    COM_INTERFACE_ENTRY(ITLegacyAddressMediaControl2)  
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_pMSPAggAddress)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
    COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_pPrivate)            
END_COM_MAP()

    void FinalRelease();
    
private:

    // tapi info
    ITTAPI *            m_pTAPI;
    HLINEAPP            m_hLineApp;
    HLINE               m_hLine;
#ifdef USE_PHONEMSP
    HPHONEAPP           m_hPhoneApp;
#endif USE_PHONEMSP

    // caps/info that we keep around
    // because it is used often
    DWORD               m_dwAPIVersion;
    DWORD               m_dwDeviceID;
    DWORD               m_dwAddressID;
    DWORD               m_dwMediaModesSupported;
    DWORD               m_dwProviderID;
    PWSTR               m_szAddress;
    PWSTR               m_szAddressName;
    PWSTR               m_szProviderName;

    // m_dwAddressFlags keeps some info about the address
    // see ADDRESSFLAG_ constants above
    DWORD               m_dwAddressFlags;

    // tapi structures - using caching scheme
    // so these can be NULL
    LPLINEADDRESSCAPS   m_pAddressCaps;
    LPLINEDEVCAPS       m_pDevCaps;
    
    // current address state
    ADDRESS_STATE       m_AddressState;

    // msp for this address
    IUnknown          * m_pMSPAggAddress;

    // event for msp to signal on event
    HANDLE              m_hMSPEvent;

    HANDLE              m_hWaitEvent;
    // Create a context handle for MSP Callback
    ULONG_PTR           m_MSPContext;

    
    // IUnk for the private object
    IUnknown          * m_pPrivate;
    

    // TAPI terminals owned by this address
    TerminalArray       m_TerminalArray;
    
    // calls currently on this address    
    CallInfoArrayNR     m_CallArray;

    // list of "addresslines"
    PtrList             m_AddressLinesPtrList;

    // list of call notification cookies
    LongList          m_NotificationCookies;

    // addressline used for callhubtracking
    AddressLineStruct * m_pCallHubTrackingLine;

    // if true, we will do LineSetCallHubTracking in FindOrOpenALine
    // it is only false if the user has called SetCallHubTracking(FALSE)
    // on this address
    BOOL                m_fEnableCallHubTrackingOnLineOpen;


    //
    // this flag, when set, signals that the tapi object has signaled shutdown
    // it is currently used to synchronize creation of new calls and call 
    // cleanup performed on tapi shutdown
    //

    BOOL m_bTapiSignaledShutdown;


    HRESULT UpdateAddressCaps();
    HRESULT UpdateLineDevCaps();
    ITMSPAddress * GetMSPAddress();

    HRESULT GetPhoneArrayFromTapiAndPrune( 
                                          PhoneArray *pPhoneArray,
                                          BOOL bPreferredOnly
                                         );

public:
    
    BOOL IsValidAddressLine(AddressLineStruct *pAddressLine, BOOL bAddref = FALSE);
    
    HRESULT MSPEvent();
#ifdef USE_PHONEMSP
    HRESULT CreatePhoneDeviceMSP(
                                 IUnknown * pUnk,
                                 HLINE hLine,
                                 IUnknown ** ppMSPAggAddress
                                );
#endif USE_PHONEMSP
    HRESULT CreateStaticTerminalArray( TerminalArray& StaticTermArray );
    HRESULT CreateDynamicTerminalClassesList( TerminalClassPtrList * pList );
    HRESULT CreateMSPCall(
                          MSP_HANDLE hCall,
                          DWORD dwReserved,
                          long lMediaType,
                          IUnknown * pOuterUnk,
                          IUnknown ** ppStreamControl
                         );
                          
    DWORD GetDeviceID(){ return m_dwDeviceID; }
    DWORD GetAPIVersion(){ return m_dwAPIVersion; }
    DWORD GetAddressID(){ return m_dwAddressID; }
    HLINEAPP GetHLineApp(){ return m_hLineApp; }
#ifdef USE_PHONEMSP
    HPHONEAPP GetHPhoneApp(){ return m_hPhoneApp; }
#endif USE_PHONEMSP
    BOOL HasMSP(){ return (m_pMSPAggAddress?TRUE:FALSE); }
    BOOL HasWaveDevice(){ return m_dwAddressFlags & (ADDRESSFLAG_WAVEINDEVICE | ADDRESSFLAG_WAVEOUTDEVICE | ADDRESSFLAG_WAVEFULLDUPLEX); }
    BOOL HasFullDuplexWaveDevice(){ return m_dwAddressFlags & ADDRESSFLAG_WAVEFULLDUPLEX; }
    BOOL HasPhoneDevice(){ return m_dwAddressFlags & ADDRESSFLAG_PHONEDEVICE; }
    DWORD GetMediaModes(){ return m_dwMediaModesSupported; }
    PWSTR GetAddressName(){ return m_szAddressName; }
    BOOL IsSPCallHubTrackingAddress(){ return m_dwAddressFlags & ADDRESSFLAG_CALLHUBTRACKING; }
    BOOL IsSPCallHubAddress(){ return m_dwAddressFlags & ADDRESSFLAG_CALLHUB; }
    CTAPI * GetTapi(BOOL bAddRefTapi = FALSE);
    BOOL HasPrivateObjects(){return m_dwAddressFlags & ADDRESSFLAG_PRIVATEOBJECTS;}
    DWORD GetProviderID(){return m_dwProviderID;}
    BOOL GetMediaMode( long lMediaType, DWORD * pdwMediaMode );
    HRESULT ShutdownMSPCall( IUnknown * pStreamControl );
    HRESULT InitializeWaveDeviceIDs( HLINE hLine );
    
    HRESULT AddNotificationLine( AddressLineStruct * pLine )
    {
        HRESULT hr = S_OK;

        Lock();

        try
        {
            m_AddressLinesPtrList.push_back( (PVOID)pLine );
        }
        catch(...)
        {
            LOG((TL_ERROR, "AddNotificationLine - failed to add to m_AddressLinesPtrList list - alloc failure" ));

            hr = E_OUTOFMEMORY;
        }

        Unlock();

        return hr;
    }

    

    HRESULT RegisterNotificationCookie(long lCookie);

    HRESULT RemoveNotificationCookie(long lCookie);

    void UnregisterAllCookies();

    void AddressOnTapiShutdown();


    void AddTerminal( ITTerminal * pTerminal )
    {
        Lock();
        
        m_TerminalArray.Add( pTerminal );
        Unlock();
    }
    
    HRESULT
    AddCallNotification(
                        DWORD dwPrivs,
                        DWORD dwMediaModes,
                        long lInstance,
                        PVOID * ppRegister
                       );

    HRESULT
    RemoveCallNotification(
                           PVOID pRegister
                          );

    HRESULT
    SetCallHubTracking(
                       BOOL bSet
                      );
    
    DWORD DoesThisAddressSupportCallHubs( CCall * pCall );

    HRESULT
    FindOrOpenALine(
                    DWORD dwMediaModes,
                    AddressLineStruct ** ppAddressLine
                   );
    HRESULT
    MaybeCloseALine(
                    AddressLineStruct ** ppAddressLine
                   );
    
    HRESULT
    InternalCreateCall(
                       PWSTR pszDestAddress,
                       long lAddressType,
                       long lMediaType,
                       CALL_PRIVILEGE cp,
                       BOOL bNeedToNotify,
                       HCALL hCall,
                       BOOL bExpose,
                       CCall ** ppCall
                      );

    HRESULT Initialize(
                       ITTAPI * pTAPI,
                       HLINEAPP hLineApp,
#ifdef USE_PHONEMSP
                       HPHONEAPP hPhoneApp,
#endif USE_PHONEMSP
                       DWORD dwAPIVersion,
                       DWORD dwDeviceID,
                       DWORD dwAddressID,
                       DWORD dwProviderID,
                       LPLINEDEVCAPS pDevCaps,
                       DWORD dwEventFilterMask
                      );

    HRESULT
    AddCall(
            ITCallInfo * pCallInfo
           );

    HRESULT
    RemoveCall(
               ITCallInfo * pCallInfo
              );

    void InService( DWORD dwType );
    void OutOfService( DWORD dwType );
    void CapsChange( BOOL );
    HRESULT SaveAddressName(LPLINEDEVCAPS);
    void SetAddrCapBuffer( LPVOID pBuf );
    void SetLineDevCapBuffer( LPVOID pBuf );
    HRESULT ReceiveTSPData(
                           IUnknown * pCall,
                           LPBYTE pBuffer,
                           DWORD dwSize
                          );
    HRESULT HandleSendTSPData( MSP_EVENT_INFO * pEvent );
    HRESULT HandleMSPAddressEvent( MSP_EVENT_INFO * pEvent );
    HRESULT HandleMSPCallEvent( MSP_EVENT_INFO * pEvent );

    HRESULT HandleMSPFileTerminalEvent( MSP_EVENT_INFO * pEvent);
    HRESULT HandleMSPTTSTerminalEvent( MSP_EVENT_INFO * pEvent);
    HRESULT HandleMSPASRTerminalEvent( MSP_EVENT_INFO * pEvent);
    HRESULT HandleMSPToneTerminalEvent( MSP_EVENT_INFO * pEvent);

    HRESULT HandleMSPPrivateEvent( MSP_EVENT_INFO * pEvent );
    HRESULT ReleaseEvent( MSP_EVENT_INFO * pEvent );


    
    // ITMediaSupport methods
    STDMETHOD(get_MediaTypes)(long * plMediaTypes);
    STDMETHOD(QueryMediaType)( 
        long lMediaType,
        VARIANT_BOOL * pbSupport
        );

    // ITAddress methods
    STDMETHOD(get_State)(ADDRESS_STATE * pAddressState);
    STDMETHOD(get_AddressName)(BSTR * ppName);
    STDMETHOD(get_ServiceProviderName)(BSTR * ppName);
    STDMETHOD(get_TAPIObject)(ITTAPI ** ppTapiObject);
    STDMETHOD(CreateCall)(
        BSTR lpszDestAddress,
        long lAddressType,
        long lMediaType,
        ITBasicCallControl ** ppCall
        );
    STDMETHOD(get_Calls)(VARIANT * pVariant);
    STDMETHOD(EnumerateCalls)(IEnumCall ** ppCallEnum);
    STDMETHOD(CreateForwardInfoObject)(ITForwardInformation ** ppForwardInfo);
    STDMETHOD(Forward)(
                       ITForwardInformation * pForwardInfo,
                       ITBasicCallControl * pCall
                      );
    STDMETHOD(get_CurrentForwardInfo)(
                           ITForwardInformation ** ppForwardInfo
                          );
    STDMETHOD(get_DialableAddress)(BSTR * pDialableAddress);
    STDMETHOD(put_MessageWaiting)(VARIANT_BOOL  fMessageWaiting);
    STDMETHOD(get_MessageWaiting)(VARIANT_BOOL * pfMessageWaiting);
    STDMETHOD(put_DoNotDisturb)(VARIANT_BOOL  fDoNotDisturb);
    STDMETHOD(get_DoNotDisturb)(VARIANT_BOOL * pfDoNotDisturb);
    STDMETHOD(get_LineID)(long * plLineID);
    STDMETHOD(get_AddressID)(long * plAddressID);

    // ITAddress2 methods
    STDMETHOD(get_Phones)(VARIANT * pPhones);
    STDMETHOD(EnumeratePhones)(IEnumPhone ** ppEnumPhone);

    STDMETHOD(get_PreferredPhones)(VARIANT * pPhones);
    STDMETHOD(EnumeratePreferredPhones)(IEnumPhone ** ppEnumPhone);

    STDMETHOD(GetPhoneFromTerminal)(
                                ITTerminal * pTerminal,
                                ITPhone ** ppPhone
                               );

    STDMETHOD(get_EventFilter)(
        TAPI_EVENT      TapiEvent,
        long            lSubEvent,
        VARIANT_BOOL*   pEnable
        );

    STDMETHOD(put_EventFilter)(
        TAPI_EVENT      TapiEvent,
        long            lSubEvent,
        VARIANT_BOOL    bEnable
        );


    STDMETHOD(DeviceSpecific)(
	         IN ITCallInfo *pCall,
	         IN BYTE *pParams,
	         IN DWORD dwSize
            );

    STDMETHOD(DeviceSpecificVariant)(
	         IN ITCallInfo *pCall,
	         IN VARIANT varDevSpecificByteArray
            );

    STDMETHOD(NegotiateExtVersion)(
	         IN long lLowVersion,
	         IN long lHighVersion,
	         IN long *plExtVersion
            );

        
    // itaddresscapabilities
    STDMETHOD(get_AddressCapability)(ADDRESS_CAPABILITY AddressCap, long * plCapability);
    STDMETHOD(get_AddressCapabilityString)(ADDRESS_CAPABILITY_STRING AddressCapString, BSTR * ppCapabilityString);
    STDMETHOD(get_CallTreatments)(VARIANT * pVariant );
    STDMETHOD(EnumerateCallTreatments)(IEnumBstr ** ppEnumCallTreatment );
    STDMETHOD(get_CompletionMessages)(VARIANT * pVariant );
    STDMETHOD(EnumerateCompletionMessages)(IEnumBstr ** ppEnumCompletionMessage );
    STDMETHOD(get_DeviceClasses)(VARIANT * pVariant );
    STDMETHOD(EnumerateDeviceClasses)(IEnumBstr ** ppEnumDeviceClass );

    // ITAddressTranslation
    STDMETHOD(TranslateAddress)(
            BSTR pAddressToTranslate,
            long ulCard,
            long ulTranslateOptions,
            ITAddressTranslationInfo ** ppTranslated
            );
    STDMETHOD(TranslateDialog)(
            TAPIHWND hwndOwner,
            BSTR pAddressIn
            );
    STDMETHOD(EnumerateLocations)(IEnumLocation ** ppEnumLocation );
    STDMETHOD(get_Locations)(VARIANT * pVariant);
    STDMETHOD(EnumerateCallingCards)(IEnumCallingCard ** ppEnumLocations );
    STDMETHOD(get_CallingCards)(VARIANT * pVariant);

    // ITLegacyAddressMediaControl
    STDMETHOD(GetID)(
        BSTR pDeviceClass,
        DWORD * pdwSize,
        BYTE ** ppDeviceID
        );

    STDMETHOD(GetDevConfig)(
                            BSTR    pDeviceClass,
                            DWORD * pdwSize,
                            BYTE ** ppDeviceConfig
                           );

    STDMETHOD(SetDevConfig)(
                            BSTR   pDeviceClass,
                            DWORD  dwSize,
                            BYTE * pDeviceConfig
                           );

    // ITLegacyAddressMediaControl2
    STDMETHOD(ConfigDialog)(
                            HWND   hwndOwner,
                            BSTR   pDeviceClass
                           );

    STDMETHOD(ConfigDialogEdit)(
                                HWND    hwndOwner,
                                BSTR    pDeviceClass,
                                DWORD   dwSizeIn,
                                BYTE  * pDeviceConfigIn,
                                DWORD * pdwSizeOut,
                                BYTE ** ppDeviceConfigOut
                               );

    // IDispatch  Methods
    STDMETHOD(GetIDsOfNames)(REFIID riid, 
                             LPOLESTR* rgszNames,
                             UINT cNames, 
                             LCID lcid, 
                             DISPID* rgdispid
                            );
    STDMETHOD(Invoke)(DISPID dispidMember, 
                      REFIID riid, 
                      LCID lcid,
                      WORD wFlags, 
                      DISPPARAMS* pdispparams, 
                      VARIANT* pvarResult,
                      EXCEPINFO* pexcepinfo, 
                      UINT* puArgErr
                      );

    STDMETHOD_(ULONG, InternalAddRef)()
    {
        DWORD dwR;

        dwR = InterlockedIncrement(&m_dwRef);;

        #if DBG
            LogDebugAddRef(m_dwRef);
        #endif

        return dwR;
    }

    
    STDMETHOD_(ULONG, InternalRelease)()
    {
        DWORD               dwR;
        PtrList::iterator   iter, end;
        AddressLineStruct * pLine;
        T3LINE            * pt3Line;


        LOG((TL_INFO, "InternalRelease - m_dwRef %d",m_dwRef ));
        Lock();
        
        gpLineHashTable->Lock();
        gpHandleHashTable->Lock();
        
        dwR = InterlockedDecrement(&m_dwRef);

        // if ref count is 0 (means we entered function with 1) then we final release
        if (0 == dwR)
        {
            // remove from the hash table, so any more messages
            // from tapisrv are ignored
            //
            //
            // release addresslines
            //

            LOG((TL_TRACE, "InternalRelease - final" ));

            iter = m_AddressLinesPtrList.begin();
            end  = m_AddressLinesPtrList.end();

            LOG((TL_INFO, "InternalRelease - m_AddressLinesPtrList size %d ", m_AddressLinesPtrList.size() ));

            for ( ; iter != end; iter++ )
            {
                pLine = (AddressLineStruct *)(*iter);

                pt3Line = &(pLine->t3Line);

                if(FAILED(gpLineHashTable->Remove( (ULONG_PTR)(pt3Line->hLine) ) ))
                {
                    LOG((TL_INFO, "InternalRelease - pLineHashTable->Remove failed" ));
                }
            }

            gpLineHashTable->Unlock();

            // remove from the handle hash table, so any more messages
            // from msp are ignored
            //
            RemoveHandleFromHashTable(m_MSPContext);
            
            // unregister all the cookies, so CTAPI::UnregisterNotifications 
            // does nothing if called later
            UnregisterAllCookies();

            gpHandleHashTable->Unlock();

            // ExternalFinalRelease();
            dwR = m_dwRef = 0;

            Unlock();
            LOG((TL_INFO, "InternalRelease - final OK dwR %d",dwR ));
        }
        else
        {
            gpLineHashTable->Unlock();
            gpHandleHashTable->Unlock();
            Unlock();
            LOG((TL_INFO, "InternalRelease - not final dwR %d",dwR ));
        }

     

        #if DBG  
            LogDebugRelease( dwR );
        #endif

        return dwR;
    }


    //
    // (implementing method from CObjectSafeImpl)
    // check the aggregated objects to see if they support the interface requested.
    // if they do, return the non-delegating IUnknown of the first object that 
    // supports the interface. 
    //
    // it needs to be released by the caller.
    //

    HRESULT QIOnAggregates(REFIID riid, IUnknown **ppNonDelegatingUnknown);

public:
    // 
    // Event filtering methods
    //

    HRESULT SetEventFilterMask( 
        IN  DWORD dwEventFilterMask
        );

    // Get subevents mask
    /*DWORD GetSubEventsMask(
        IN  int nEvent
        );*/

    // Get subevents mask
    DWORD GetSubEventsMask(
        IN  TAPI_EVENT TapiEvent
        );


private:
    //
    // Helper methods for event filtering
    //

    HRESULT SetSubEventFlag(
        TAPI_EVENT  TapiEvent,
        DWORD       dwSubEvent,
        BOOL        bEnable
        );

    HRESULT GetSubEventFlag(
        TAPI_EVENT  TapiEvent,
        DWORD       dwSubEvent,
        BOOL*       pEnable
        );

    HRESULT SetSubEventFlagToCalls(
        TAPI_EVENT  TapiEvent,
        DWORD       dwFlag,
        BOOL        bEnable
        );

public:
    CEventMasks     m_EventMasks;       // Event filtering masks

    HRESULT GetEventMasks(
        OUT CEventMasks* pEventMasks
        );

};

////////////////////////////////////////////////////////////////////////
// CAddressTypeCollection
// 
////////////////////////////////////////////////////////////////////////
class CAddressTypeCollection :
    public CTAPIComObjectRoot<CAddressTypeCollection>,
    public CComDualImpl<ITCollection, &IID_ITCollection, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

DECLARE_MARSHALQI(CAddressTypeCollection)
DECLARE_TRACELOG_CLASS(CAddressTypeCollection)

BEGIN_COM_MAP(CAddressTypeCollection)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITCollection)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

private:

    DWORD               m_dwSize;
    CComVariant *       m_Var;
    
public:

    // initialize
    HRESULT STDMETHODCALLTYPE Initialize(
                                         PDWORD pdwAddressTypes,
                                         DWORD dwElements
                                        )
    {
        DWORD                   dw;
        HRESULT                 hr = S_OK;

        LOG((TL_TRACE, "Initialize - enter"));

        // create variant array
        m_dwSize = dwElements;

        m_Var = new CComVariant[m_dwSize];

        if (NULL == m_Var)
        {
            LOG((TL_ERROR, "Could not alloc for CComVariant array"));
            hr = E_OUTOFMEMORY;
        }
        else
        {
            for (dw = 0; dw < m_dwSize; dw++)
            {
                // create a variant and add it to the collection
                CComVariant& var = m_Var[dw];

                var.vt = VT_I4;
                var.lVal = pdwAddressTypes[dw];
            }
        }
        LOG((TL_TRACE, "Initialize - exit"));
        
        return hr;
    }
    
    STDMETHOD(get_Count)(
                         long* retval
                        )
    {
        HRESULT         hr = S_OK;

        LOG((TL_TRACE, "get_Count - enter"));

        try
        {
            *retval = m_dwSize;
        }
        catch(...)
        {
            hr = E_INVALIDARG;
        }

        LOG((TL_TRACE, "get_Count - exit"));
        
        return hr;
    }

    STDMETHOD(get_Item)(
                        long Index, 
                        VARIANT* retval
                       )
    {
        HRESULT         hr = S_OK;

        LOG((TL_TRACE, "get_Item - enter"));
        
        if (retval == NULL)
        {
            return E_POINTER;
        }

        try
        {
            VariantInit(retval);
        }
        catch(...)
        {
            hr = E_INVALIDARG;
        }

        if (S_OK != hr)
        {
            return hr;
        }

        retval->vt = VT_I4;
        retval->lVal = 0;

        // use 1-based index, VB like
        if ((Index < 1) || (Index > m_dwSize))
        {
            return E_INVALIDARG;
        }

        VariantCopy(retval, &m_Var[Index-1]);

        LOG((TL_TRACE, "get_Item - exit"));

        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE get__NewEnum(
                                           IUnknown** retval
                                          )
    
    {
        HRESULT         hr = S_OK;

        LOG((TL_TRACE, "get__NumEnum - enter"));
        
        if (NULL == retval)
        {
            return E_POINTER;
        }

        *retval = NULL;

        typedef CComObject<CSafeComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT> > > enumvar;

        enumvar* p = new enumvar;

        if (NULL == p)
        {
            LOG((TL_ERROR, "Could not alloc for enumvar"));
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = p->Init(&m_Var[0], &m_Var[m_dwSize], NULL, AtlFlagCopy);

            if (SUCCEEDED(hr))
            {
                hr = p->QueryInterface(IID_IEnumVARIANT, (void**)retval);
            }

            if (FAILED(hr))
            {
                delete p;
            }
        }

        LOG((TL_TRACE, "get__NewEnum - exit"));
        return hr;
    }

    void FinalRelease()
    {
        LOG((TL_TRACE, "FinalRelease()"));
    }
};

////////////////////////////////////////////////////////////////////////
// CTerminalClassCollection
// 
////////////////////////////////////////////////////////////////////////
class CTerminalClassCollection :
    public CTAPIComObjectRoot<CTerminalClassCollection>,
    public CComDualImpl<ITCollection, &IID_ITCollection, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

DECLARE_MARSHALQI(CTerminalClassCollection)
DECLARE_TRACELOG_CLASS(CTerminalClassCollection)

BEGIN_COM_MAP(CTerminalClassCollection)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITCollection)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

private:

    DWORD               m_dwSize;
    CComVariant *       m_Var;
    
public:

    // initialize
    HRESULT STDMETHODCALLTYPE Initialize(
                                         TerminalClassPtrList classlist
                                        )
    {
        TerminalClassPtrList::iterator      i;
        HRESULT                             hr = S_OK;
        DWORD                               dw = 0;

        LOG((TL_TRACE, "Initialize - enter"));

        // create variant array
        m_dwSize = classlist.size();

        m_Var = new CComVariant[m_dwSize];
        
        if (NULL == m_Var)
        {
            LOG((TL_ERROR, "Could not alloc for CComVariant array"));
            hr = E_OUTOFMEMORY;
        }
        else
        {
            for (i = classlist.begin(); i != classlist.end(); i++)
            {
                // create a variant and add it to the collection
                CComVariant& var = m_Var[dw];

                var.vt = VT_BSTR;
                var.bstrVal = *i;
                dw++;
            }
        }

        LOG((TL_TRACE, "Initialize - exit"));
        return hr;
    }
    
    STDMETHOD(get_Count)(
                         long* retval
                        )
    {
        HRESULT         hr = S_OK;

        LOG((TL_TRACE, "get_Count - enter"));

        try
        {
            *retval = m_dwSize;
        }
        catch(...)
        {
            hr = E_INVALIDARG;
        }

        LOG((TL_TRACE, "get_Count - exit"));
        
        return hr;
    }

    STDMETHOD(get_Item)(
                        long Index, 
                        VARIANT* retval
                       )
    {
        HRESULT         hr = S_OK;

        LOG((TL_TRACE, "get_Item - enter"));
        
        if (retval == NULL)
        {
            return E_POINTER;
        }

        try
        {
            VariantInit(retval);
        }
        catch(...)
        {
            hr = E_INVALIDARG;
        }

        if (S_OK != hr)
        {
            return hr;
        }

        retval->vt = VT_BSTR;
        retval->bstrVal = NULL;

        // use 1-based index, VB like
        if ((Index < 1) || (Index > m_dwSize))
        {
            return E_INVALIDARG;
        }

        VariantCopy(retval, &m_Var[Index-1]);

        LOG((TL_TRACE, "get_Item - exit"));

        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE get__NewEnum(
                                           IUnknown** retval
                                          )
    
    {
        HRESULT         hr;

        LOG((TL_TRACE, "get__NumEnum - enter"));
        
        if (NULL == retval)
        {
            return E_POINTER;
        }

        *retval = NULL;

        typedef CComObject<CSafeComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT> > > enumvar;

        enumvar* p = new enumvar;

        if ( NULL == m_Var )
        {
            LOG((TL_ERROR, "Internal variant is NULL"));
            hr = E_FAIL;
        }
        else if ( NULL == p )
        {
            LOG((TL_ERROR, "Could not alloc for enumvar"));
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = p->Init(&m_Var[0], &m_Var[m_dwSize], NULL, AtlFlagCopy);

            if (SUCCEEDED(hr))
            {
                hr = p->QueryInterface(IID_IEnumVARIANT, (void**)retval);
            }

            if (FAILED(hr))
            {
                delete p;
            }
        }

        LOG((TL_TRACE, "get__NewEnum - exit"));
        
        return hr;
    }

    void FinalRelease()
    {
        LOG((TL_INFO, "FinalRelease()"));
    }

};


class CAddressEvent : 
    public CTAPIComObjectRoot<CAddressEvent>,
    public CComDualImpl<ITAddressEvent, &IID_ITAddressEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

DECLARE_MARSHALQI(CAddressEvent)
DECLARE_TRACELOG_CLASS(CAddressEvent)

BEGIN_COM_MAP(CAddressEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITAddressEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

    static HRESULT FireEvent(
                             CAddress * pAddress,
                             ADDRESS_EVENT Event,
                             ITTerminal * pTerminal
                            );
    void FinalRelease();
                      
protected:
    ITAddress     * m_pAddress;
    ADDRESS_EVENT   m_Event;
    ITTerminal    * m_pTerminal;

#if DBG
    PWSTR           m_pDebug;
#endif

    
public:
    //
    // itaddressstateevent
    //
    STDMETHOD(get_Address)( ITAddress ** ppAddress );
    STDMETHOD(get_Event)( ADDRESS_EVENT * pEvent );
    STDMETHOD(get_Terminal)( ITTerminal ** ppTerminal );
    
};



class CAddressDevSpecificEvent : 
    public CTAPIComObjectRoot<CAddressDevSpecificEvent, CComMultiThreadModelNoCS>,
    public CComDualImpl<ITAddressDeviceSpecificEvent, &IID_ITAddressDeviceSpecificEvent, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

DECLARE_MARSHALQI(CAddressDevSpecificEvent)
DECLARE_TRACELOG_CLASS(CAddressDevSpecificEvent)

BEGIN_COM_MAP(CAddressDevSpecificEvent)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITAddressDeviceSpecificEvent)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

    static HRESULT FireEvent(
                             CAddress * pAddress,
                             CCall    * pCall,
                             long lParam1,
                             long lParam2,
                             long lParam3
                            );
    
    ~CAddressDevSpecificEvent();
                      

protected:


    CAddressDevSpecificEvent();


    //
    // properties
    //

    ITAddress  *m_pAddress;
    ITCallInfo *m_pCall;


    long m_l1;
    long m_l2;
    long m_l3;


#if DBG
    PWSTR           m_pDebug;
#endif

    
public:

    STDMETHOD(get_Address)( ITAddress ** ppAddress );
    STDMETHOD(get_Call)   ( ITCallInfo ** ppCall );
    STDMETHOD(get_lParam1)( long *plParam1 );
    STDMETHOD(get_lParam2)( long *plParam2 );
    STDMETHOD(get_lParam3)( long *plParam3 );
    
};


#define NUMFORWARDTYPES             18

typedef struct
{
    DWORD       dwForwardType;
    BSTR        bstrDestination;
    BSTR        bstrCaller;   
    DWORD       dwCallerAddressType;
    DWORD       dwDestAddressType;
    
} MYFORWARDSTRUCT;

class CForwardInfo :
    public CTAPIComObjectRoot<CForwardInfo>,
    public CComDualImpl<ITForwardInformation2, &IID_ITForwardInformation2, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

DECLARE_MARSHALQI(CForwardInfo)
DECLARE_TRACELOG_CLASS(CForwardInfo)

BEGIN_COM_MAP(CForwardInfo)
    COM_INTERFACE_ENTRY2(IDispatch, ITForwardInformation2)
    COM_INTERFACE_ENTRY(ITForwardInformation)
    COM_INTERFACE_ENTRY(ITForwardInformation2)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

    HRESULT Initialize();
    HRESULT CreateForwardList( LINEFORWARDLIST ** ppForwardList );
    void FinalRelease();
    
protected:

    MYFORWARDSTRUCT     m_ForwardStructs[NUMFORWARDTYPES];
    long                m_lNumRings;
    
public:

    STDMETHOD(put_NumRingsNoAnswer)(long lNumRings);
    STDMETHOD(get_NumRingsNoAnswer)(long * plNumRings);
    STDMETHOD(SetForwardType)( 
        long ForwardType, 
        BSTR pDestAddress,
        BSTR pCallerAddress
        );
    STDMETHOD(get_ForwardTypeDestination)( 
        long ForwardType, 
        BSTR * ppDestAddress 
        );
    STDMETHOD(get_ForwardTypeCaller)( 
        long Forwardtype, 
        BSTR * ppCallerAddress 
        );
    STDMETHOD(GetForwardType)(
        long ForwardType,
        BSTR * ppDestinationAddress,
        BSTR * ppCallerAddress
        );
    STDMETHOD(Clear)();
    STDMETHOD(SetForwardType2)( 
        long ForwardType, 
        BSTR pDestAddress,
        long DestAddressType,
        BSTR pCallerAddress,
        long CallerAddressType
        );
    STDMETHOD(GetForwardType2)(
        long ForwardType,
        BSTR * ppDestinationAddress,
        long * pDestAddressType,
        BSTR * ppCallerAddress,
        long * pCallerAddressType
        );
    STDMETHOD(get_ForwardTypeDestinationAddressType)( 
        long ForwardType, 
        long * pDestAddressType
        );
    STDMETHOD(get_ForwardTypeCallerAddressType)( 
        long Forwardtype, 
        long * pCallerAddressType
        );
    
};

#define FORWARDMODENEEDSCALLER(__dwMode__) \
( ( LINEFORWARDMODE_UNCONDSPECIFIC | LINEFORWARDMODE_BUSYSPECIFIC | \
    LINEFORWARDMODE_NOANSWSPECIFIC | LINEFORWARDMODE_BUSYNASPECIFIC ) & \
    (__dwMode__) )




////////////////////////////////////////////////////////////////////////
// CAddressTranslationInfo
// 
////////////////////////////////////////////////////////////////////////
class CAddressTranslationInfo :
    public CTAPIComObjectRoot<CAddressTranslationInfo>,
    public CComDualImpl<ITAddressTranslationInfo, &IID_ITAddressTranslationInfo, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

CAddressTranslationInfo() : m_szDialableString(NULL),
                            m_szDisplayableString(NULL),
                            m_dwCurrentCountryCode(0),
                            m_dwDestinationCountryCode(0),
                            m_dwTranslationResults(0)
                           {}


DECLARE_MARSHALQI(CAddressTranslationInfo)
DECLARE_TRACELOG_CLASS(CAddressTranslationInfo)

BEGIN_COM_MAP(CAddressTranslationInfo)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITAddressTranslationInfo)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

    HRESULT Initialize(
                       PWSTR pszDialableString,                  
                       PWSTR pszDisplayableString,               
                       DWORD dwCurrentCountry,
                       DWORD dwDestCountry,    
                       DWORD dwTranslateResults
                      );
    void FinalRelease();
 
private:
    DWORD   m_dwCurrentCountryCode;
    DWORD   m_dwDestinationCountryCode;
    DWORD   m_dwTranslationResults;
    PWSTR   m_szDialableString;
    PWSTR   m_szDisplayableString;
    
public:

    STDMETHOD(get_DialableString)(BSTR * ppDialableString );
    STDMETHOD(get_DisplayableString)(BSTR * ppDisplayableString );
    STDMETHOD(get_CurrentCountryCode)(long * CountryCode );
    STDMETHOD(get_DestinationCountryCode)(long * CountryCode );
    STDMETHOD(get_TranslationResults)(long * Results );
    
};


////////////////////////////////////////////////////////////////////////
// CLocationInfo
// 
////////////////////////////////////////////////////////////////////////
class CLocationInfo:
    public CTAPIComObjectRoot<CLocationInfo>,
    public CComDualImpl<ITLocationInfo, &IID_ITLocationInfo, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl
{
public:

DECLARE_MARSHALQI(CLocationInfo)
DECLARE_TRACELOG_CLASS(CLocationInfo)

BEGIN_COM_MAP(CLocationInfo)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITLocationInfo)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

    HRESULT Initialize(
                PWSTR pszLocationName, 
                PWSTR pszCityCode, 
                PWSTR pszLocalAccessCode, 
                PWSTR pszLongDistanceAccessCode, 
                PWSTR pszTollPrefixList, 
                PWSTR pszCancelCallWaitingCode , 
                DWORD dwPermanentLocationID,
                DWORD dwCountryCode,
                DWORD dwPreferredCardID,
                DWORD dwCountryID,
                DWORD dwOptions
                );

    
    void FinalRelease();
    
private:

    DWORD   m_dwPermanentLocationID;
    DWORD   m_dwCountryCode;
    DWORD   m_dwCountryID;
    DWORD   m_dwOptions;
    DWORD   m_dwPreferredCardID;
    PWSTR   m_szLocationName;
    PWSTR   m_szCityCode;
    PWSTR   m_szLocalAccessCode;
    PWSTR   m_szLongDistanceAccessCode;
    PWSTR   m_szTollPrefixList;
    PWSTR   m_szCancelCallWaitingCode;
    
public:

    //  ITLocationInfo
    STDMETHOD(get_PermanentLocationID)(long * ulLocationID );
    STDMETHOD(get_CountryCode)(long * ulCountryCode);
    STDMETHOD(get_CountryID)(long * ulCountryID);
    STDMETHOD(get_Options)(long * Options);
    STDMETHOD(get_PreferredCardID)( long * ulCardID);

    STDMETHOD(get_LocationName)(BSTR * ppLocationName );
    STDMETHOD(get_CityCode)(BSTR * ppCode );
    STDMETHOD(get_LocalAccessCode)(BSTR * ppCode );
    STDMETHOD(get_LongDistanceAccessCode)(BSTR * ppCode );
    STDMETHOD(get_TollPrefixList)(BSTR * ppTollList);
    STDMETHOD(get_CancelCallWaitingCode)(BSTR * ppCode );
};


////////////////////////////////////////////////////////////////////////
// CCallingCard
// 
////////////////////////////////////////////////////////////////////////
class CCallingCard:
    public CTAPIComObjectRoot<CCallingCard>,
    public CComDualImpl<ITCallingCard, &IID_ITCallingCard, &LIBID_TAPI3Lib>,
    public CObjectSafeImpl

{
public:

DECLARE_MARSHALQI(CCallingCard)
DECLARE_TRACELOG_CLASS(CCallingCard)

BEGIN_COM_MAP(CCallingCard)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITCallingCard)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_FUNC(IID_IMarshal, 0, IMarshalQI)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

    HRESULT Initialize(
                PWSTR pszCardName,
                PWSTR pszSameAreaDialingRule,
                PWSTR pszLongDistanceDialingRule,
                PWSTR pszInternationalDialingRule,
                DWORD dwPermanentCardID,
                DWORD dwNumberOfDigits,
                DWORD dwOptions
                );
    void FinalRelease();
    
private:

    DWORD   m_dwPermanentCardID;
    DWORD   m_dwNumberOfDigits;
    DWORD   m_dwOptions;
    PWSTR   m_szCardName;
    PWSTR   m_szSameAreaDialingRule;
    PWSTR   m_szLongDistanceDialingRule;
    PWSTR   m_szInternationalDialingRule;
    
public:

    //  ITCallingCard
    STDMETHOD(get_PermanentCardID)(long * ulCardID);
    STDMETHOD(get_NumberOfDigits)(long * ulDigits);
    STDMETHOD(get_Options)(long * ulOptions);

    STDMETHOD(get_CardName)(BSTR * ppCardName );
    STDMETHOD(get_SameAreaDialingRule)(BSTR * ppRule );
    STDMETHOD(get_LongDistanceDialingRule)(BSTR * ppRule );
    STDMETHOD(get_InternationalDialingRule)(BSTR * ppRule );
    
};

/////////////////////////////////////////////////////////////////////////////
// _CopyBSTR is used in creating BSTR enumerators.
/////////////////////////////////////////////////////////////////////////////
class _CopyBSTR
{
public:
#if _ATL_VER >= 0x0203
    static HRESULT copy(BSTR *p1, BSTR *p2)
    {
            (*p1) = SysAllocString(*p2);
            if (*p1)
                return S_OK;
            else
                return E_OUTOFMEMORY;
    }
#else
    static void copy(BSTR *p1, BSTR *p2)
    {
            (*p1) = SysAllocString(*p2);
    }
#endif
    static void init(BSTR* p) {*p = NULL;}
    static void destroy(BSTR* p) { SysFreeString(*p);}
};

#endif //__ADDRESS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\tapi3\agentsess.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    agentsess.cpp

Abstract:

    Implementation of the Agent Session object for TAPI 3.0.
    CAgentSession class
    CAgentSessionEvent class

Author:

    noela - 11/04/97

Notes:

    optional-notes

Revision History:

--*/



#include "stdafx.h"
#include "lmcons.h"

DWORD MapAgentSessionStateFrom3to2(AGENT_SESSION_STATE tapi3State);
HRESULT MapAgentSessionStateFrom2to3(DWORD tapi2State, AGENT_SESSION_STATE  *tapi3State);





/////////////////////////////////////////////////////////////////////////////
// CAgentSession

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession
// Method    : Initialize
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSession::Initialize(
        HAGENTSESSION       hAgentSession, 
        ITAgent           * pAgent, 
        ITACDGroup        * pGroup, 
        ITAddress         * pAddress,
        CAgentHandler     * pHandler,
        AddressLineStruct * pAddressLine
        )
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "Initialize - enter, sessionhandle :%d", hAgentSession ));

    m_SessionState                  = ASST_NOT_READY;

    m_hAgentSession                 = hAgentSession;
    m_pAgent                        = pAgent;
    m_pGroup                        = pGroup;
    m_pReceiveCallsOnThisAddress    = pAddress;
    pAddress->AddRef();
    m_pHandler                      = pHandler;
    m_pAddressLine                  = pAddressLine;
  
    m_bRequiresUpdating             = TRUE;

    // Now add to AgentHandler hash table 
    m_pHandler->AddAgentSessionToHash(m_hAgentSession, this);

    
    // UpdateInfo();

    // Fire an event here
    CAgentSessionEvent::FireEvent(this, ASE_NOT_READY);


    LOG((TL_TRACE, hr, "Initialize - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession
// Method    : FinalRelease
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CAgentSession::FinalRelease()
{
    LOG((TL_TRACE, "FinalRelease session %d", m_hAgentSession ));

    // Now Remove to AgentHandler hash table 
    //m_pHandler->RemoveAgentSessionFromHash(m_hAgentSession);

    // And then close our line
    CAddress *pAddress = (CAddress*)m_pReceiveCallsOnThisAddress;
    pAddress->MaybeCloseALine (&m_pAddressLine);
    pAddress->Release();

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession
// Method    : UpdateInfo
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSession::UpdateInfo()
{
    HRESULT                     hr2,hr = S_OK;
    LINEAGENTSESSIONINFO        AgentSessionInfo;


    LOG((TL_TRACE, "UpdateInfo - enter" ));
 
    AgentSessionInfo.dwTotalSize = sizeof(LINEAGENTSESSIONINFO);
    AgentSessionInfo.dwNeededSize = sizeof(LINEAGENTSESSIONINFO);
    AgentSessionInfo.dwUsedSize = sizeof(LINEAGENTSESSIONINFO);

    
    // **************************************************
    // Get Agent Info from Proxy
    hr = lineGetAgentSessionInfo(
                        m_pAddressLine->t3Line.hLine,
                        m_hAgentSession, 
                        &AgentSessionInfo);

    if( SUCCEEDED(hr) )
    {
        // wait for async reply
        hr = WaitForReply( hr );
        if ( SUCCEEDED(hr) )
        {
            Lock();
    
            if( FAILED( MapAgentSessionStateFrom2to3(AgentSessionInfo.dwAgentSessionState, &m_SessionState) ) )
            {    
                LOG((TL_ERROR, "UpdateInfo - AgentSessionState is invalid %d - setting to ASST_NOT_READY",AgentSessionInfo.dwAgentSessionState));
            }    

            if( FAILED( MapAgentSessionStateFrom2to3(AgentSessionInfo.dwNextAgentSessionState, &m_NextSessionState) ) )
            {    
                LOG((TL_ERROR, "UpdateInfo - NextAgentSessionState is invalid %d - setting to ASST_NOT_READY",AgentSessionInfo.dwAgentSessionState));
            }    
                                    
            m_dwSessionStartTime     = AgentSessionInfo.dateSessionStartTime;     
            m_dwSessionDuration      = AgentSessionInfo.dwSessionDuration;        
            m_dwNumberOfCalls        = AgentSessionInfo.dwNumberOfCalls;          
            m_dwTotalTalkTime        = AgentSessionInfo.dwTotalTalkTime;          
            m_dwAverageTalkTime      = AgentSessionInfo.dwAverageTalkTime;        
            m_dwTotalCallTime        = AgentSessionInfo.dwTotalCallTime;          
            m_dwAverageCallTime      = AgentSessionInfo.dwAverageCallTime;        
            m_dwTotalWrapUpTime      = AgentSessionInfo.dwTotalWrapUpTime;        
            m_dwAverageWrapUpTime    = AgentSessionInfo.dwAverageWrapUpTime;      
            m_dwACDCallRate          = AgentSessionInfo.cyACDCallRate;            
            m_dwLongestTimeToAnswer  = AgentSessionInfo.dwLongestTimeToAnswer;    
            m_dwAverageTimeToAnswer  = AgentSessionInfo.dwAverageTimeToAnswer;    

            m_bRequiresUpdating      = FALSE;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "UpdateInfo - call to lineGetAgentSessionInfo failed async" ));
        }
    }
    else
    {
        LOG((TL_ERROR, "UpdateInfo - call to lineGetAgentSessionInfo failed" ));
    }



    LOG((TL_TRACE, hr, "UpdateInfo - exit" ));
    return hr;
}





//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession
// Method    : CheckIfUpToDate
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSession::CheckIfUpToDate()
{
    HRESULT     hr = S_OK;

    if (m_bRequiresUpdating)
    {
        hr = UpdateInfo();
    }
    return hr;
}





//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession 
// Interface : ITAgentSession
// Method    : AverageTimeToAnswer
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSession::get_AverageTimeToAnswer(long * pulAnswerTime)
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "AverageTimeToAnswer - enter" ));
    if (!TAPIIsBadWritePtr( pulAnswerTime, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pulAnswerTime = m_dwAverageTimeToAnswer;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_AverageTimeToAnswer - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_AverageTimeToAnswer - bad pulAnswerTime pointer"));
        hr = E_POINTER;
    }

    LOG((TL_TRACE, hr, "AverageTimeToAnswer - exit" ));
    return hr;

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession
// Interface : ITAgentSession
// Method    : LongestTimeToAnswer
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSession::get_LongestTimeToAnswer(long * pulAnswerTime)
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "LongestTimeToAnswer - enter" ));
    if (!TAPIIsBadWritePtr( pulAnswerTime, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pulAnswerTime = m_dwLongestTimeToAnswer;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_LongestTimeToAnswer - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_LongestTimeToAnswer - bad pulAnswerTime pointer"));
        hr = E_POINTER;
    }

    LOG((TL_TRACE, hr, "LongestTimeToAnswer - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession
// Interface : ITAgentSession
// Method    : ACDCallRate
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSession::get_ACDCallRate(CURRENCY * pcyCallrate)
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "ACDCallRate - enter" ));
    if (!TAPIIsBadWritePtr( pcyCallrate, sizeof(CURRENCY) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pcyCallrate = m_dwACDCallRate;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_ACDCallRate - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_ACDCallRate - bad pcyCallrate pointer"));
        hr = E_POINTER;
    }

    LOG((TL_TRACE, hr, "ACDCallRate - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession
// Interface : ITAgentSession
// Method    : AverageWrapUpTime
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSession::get_AverageWrapUpTime(long * pulAverageWrapUpTime)
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "AverageWrapUpTime - enter" ));
    if (!TAPIIsBadWritePtr( pulAverageWrapUpTime, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pulAverageWrapUpTime = m_dwAverageWrapUpTime;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_AverageWrapUpTime - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_AverageWrapUpTime - bad pulAverageWrapUpTime pointer"));
        hr = E_POINTER;
    }

    LOG((TL_TRACE, hr, "AverageWrapUpTime - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession
// Interface : ITAgentSession
// Method    : TotalWrapUpTime
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSession::get_TotalWrapUpTime(long * pulTotalWrapUpTime)
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "TotalWrapUpTime - enter" ));
    if (!TAPIIsBadWritePtr( pulTotalWrapUpTime, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pulTotalWrapUpTime = m_dwTotalWrapUpTime;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_TotalWrapUpTime - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_TotalWrapUpTime - bad pulTotalWrapUpTime pointer"));
        hr = E_POINTER;
    }

    LOG((TL_TRACE, hr, "TotalWrapUpTime - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession
// Interface : ITAgentSession
// Method    : AverageCallTime
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSession::get_AverageCallTime(long * pulAverageCallTime)
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "AverageCallTime - enter" ));
    if (!TAPIIsBadWritePtr( pulAverageCallTime, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pulAverageCallTime = m_dwTotalCallTime;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_AverageCallTime - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_AverageCallTime - bad pulAverageCallTime pointer"));
        hr = E_POINTER;
    }

    LOG((TL_TRACE, hr, "AverageCallTime - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession
// Interface : ITAgentSession
// Method    : TotalCallTime
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSession::get_TotalCallTime(long * pulTotalCallTime)
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "TotalCallTime - enter" ));
    if (!TAPIIsBadWritePtr( pulTotalCallTime, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pulTotalCallTime = m_dwTotalCallTime;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_TotalCallTime - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_TotalCallTime - bad pulTotalCallTime pointer"));
        hr = E_POINTER;
    }

    LOG((TL_TRACE, hr, "TotalCallTime - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession
// Interface : ITAgentSession
// Method    : AverageTalkTime
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSession::get_AverageTalkTime(long * pulAverageTalkTime)
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "AverageTalkTime - enter" ));
    if (!TAPIIsBadWritePtr( pulAverageTalkTime, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pulAverageTalkTime = m_dwAverageTalkTime;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_AverageTalkTime - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_AverageTalkTime - bad pulAverageTalkTime pointer"));
        hr = E_POINTER;
    }

    LOG((TL_TRACE, hr, "AverageTalkTime - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession
// Interface : ITAgentSession
// Method    : TotalTalkTime
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSession::get_TotalTalkTime(long * pulTotalTalkTime)
{
    HRESULT  hr = S_OK;
 
	LOG((TL_TRACE, "TotalTalkTime - enter" ));
    if (!TAPIIsBadWritePtr( pulTotalTalkTime, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pulTotalTalkTime = m_dwTotalTalkTime;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_TotalTalkTime - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_TotalTalkTime - bad pulTotalTalkTime pointer"));
        hr = E_POINTER;
    }

    LOG((TL_TRACE, hr, "TotalTalkTime - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession
// Interface : ITAgentSession
// Method    : NumberOfCalls
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSession::get_NumberOfCalls(long * pulNumberOfCalls)
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "NumberOfCalls - enter" ));
    if (!TAPIIsBadWritePtr( pulNumberOfCalls, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pulNumberOfCalls = m_dwNumberOfCalls;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_NumberOfCalls - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_NumberOfCalls - bad pulNumberOfCalls pointer"));
        hr = E_POINTER;
    }

    LOG((TL_TRACE, hr, "NumberOfCalls - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession
// Interface : ITAgentSession
// Method    : SessionDuration
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSession::get_SessionDuration(long * pulSessionDuration)
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "SessionDuration - enter" ));
    if (!TAPIIsBadWritePtr( pulSessionDuration, sizeof(long) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *pulSessionDuration = m_dwSessionDuration;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_SessionDuration - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_SessionDuration - bad pulSessionDuration pointer"));
        hr = E_POINTER;                                          
    }

    LOG((TL_TRACE, hr, "SessionDuration - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession
// Interface : ITAgentSession
// Method    : SessionStartTime
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSession::get_SessionStartTime(DATE * dateSessionStart)
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "SessionStartTime - enter" ));
    if (!TAPIIsBadWritePtr( dateSessionStart, sizeof(DATE) ) )
    {
        hr = CheckIfUpToDate();
        if ( SUCCEEDED(hr) )
        {
            Lock();
            *dateSessionStart = m_dwSessionStartTime;
            Unlock();
        }
        else
        {
            LOG((TL_ERROR, "get_SessionStartTime - Object update failed"));
        }
    }
    else
    {
        LOG((TL_ERROR, "get_SessionStartTime - bad dateSessionStart pointer"));
        hr = E_POINTER;
    }

    LOG((TL_TRACE, hr, "SessionStartTime - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession
// Interface : ITAgentSession
// Method    : get_State
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSession::get_State(AGENT_SESSION_STATE * pSessionState)
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "get_State - enter" ));
    if (!TAPIIsBadWritePtr( pSessionState, sizeof(AGENT_SESSION_STATE) ) )
    {
        Lock();
        *pSessionState = m_SessionState;
        Unlock();    
    }
    else
    {
        LOG((TL_ERROR, "get_State - bad pSessionState pointer"));
        hr = E_POINTER;
    }

    LOG((TL_TRACE, hr, "get_State - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession
// Interface : ITAgentSession
// Method    : put_State
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSession::put_State(AGENT_SESSION_STATE sessionState)
{
    HRESULT hr = S_OK;
    HLINE   hLine;    
    DWORD   dwSessionState = 0;

    LOG((TL_TRACE, "put_State - enter" ));

    Lock();
    hLine = m_pAddressLine->t3Line.hLine;
    Unlock();

    dwSessionState = MapAgentSessionStateFrom3to2(sessionState);
    
    if( 0 == dwSessionState )
    {
        hr = E_INVALIDARG;        
    }
    else
    {
        hr = lineSetAgentSessionState
                (hLine, 
                 m_hAgentSession, 
                 dwSessionState,
                 0          // MapAgentSessionStateFrom3to2(m_NextSessionState)
                 );
    
        if( SUCCEEDED(hr) )
        {
            // wait for async reply
            hr = WaitForReply( hr );
            if ( SUCCEEDED(hr) )
            {
                Lock();
                m_SessionState =  sessionState;
                Unlock();
                switch( sessionState )
                {
                    case ASST_NOT_READY:
                    CAgentSessionEvent::FireEvent(this, ASE_NOT_READY);
                    break;
                    case ASST_READY:
                    CAgentSessionEvent::FireEvent(this, ASE_READY);
                    break;
                    case ASST_BUSY_ON_CALL:
                    CAgentSessionEvent::FireEvent(this, ASE_BUSY);
                    break;
                    case ASST_BUSY_WRAPUP:
                    CAgentSessionEvent::FireEvent(this, ASE_WRAPUP);
                    break;
                    case ASST_SESSION_ENDED:
                    CAgentSessionEvent::FireEvent(this, ASE_END);
                    break;
                }
            }
            else
            {
                LOG((TL_ERROR, "put_State - lineSetAgentSessionState failed async" ));
            }
        }
        else
        {
            LOG((TL_ERROR, "put_State - lineSetAgentSessionState failed" ));
        }
    }

    LOG((TL_TRACE, hr, "put_State - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession
// Interface : ITAgentSession
// Method    : ACDGroup
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSession::get_ACDGroup(ITACDGroup **ppACDGroup)
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "ACDGroup - enter" ));
    if (!TAPIIsBadWritePtr( ppACDGroup, sizeof(ITACDGroup *) ) )
        {
        Lock();
        *ppACDGroup = m_pGroup;
        Unlock();    
        }
    else
        {
        LOG((TL_ERROR, "get_ACDGroup - bad ppACDGroup pointer"));
        hr = E_POINTER;
        }

    LOG((TL_TRACE, hr, "ACDGroup - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession
// Interface : ITAgentSession
// Method    : Address
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSession::get_Address(ITAddress **ppAddress)
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "Address - enter" ));
    if (!TAPIIsBadWritePtr( ppAddress, sizeof(ITAddress *) ) )
        {
        Lock();
        *ppAddress = m_pReceiveCallsOnThisAddress;
        Unlock();
        }
    else
        {
        LOG((TL_ERROR, "get_Address - bad ppAddress pointer"));
        hr = E_POINTER;
        }
    
    LOG((TL_TRACE, hr, "Address - exit" ));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSession
// Interface : ITAgentSession
// Method    : Agent
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSession::get_Agent(ITAgent **ppAgent)
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "Agent - enter" ));
    if (!TAPIIsBadWritePtr( ppAgent, sizeof(ITAgent *) ) )
        {
        Lock();
        *ppAgent = m_pAgent;
        Unlock();
        }
    else
        {
        LOG((TL_ERROR, "get_Agent - bad ppAgent pointer"));
        hr = E_POINTER;
        }
    
    LOG((TL_TRACE, hr, "Agent - exit" ));
    return hr;
}


                            

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////





/////////////////////////////////////////////////////////////////////////////
// CAgentSessionEvent


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSessionEvent
// Method    : FireEvent
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CAgentSessionEvent::FireEvent(CAgentSession * pAgentSession, AGENT_SESSION_EVENT event)
{
    HRESULT                           hr = S_OK;
    CComObject<CAgentSessionEvent>  * pEvent;
    IDispatch                       * pIDispatch;
    CAgentHandler                   * pAgentHandler = NULL;


    //
    // create event
    //
    hr = CComObject<CAgentSessionEvent>::CreateInstance( &pEvent );

    if ( SUCCEEDED(hr) )
    {
        //
        // initialize
        //
        pEvent->m_SessionEvent = event;
        pEvent->m_pSession= dynamic_cast<ITAgentSession *>(pAgentSession);
        pEvent->m_pSession->AddRef();
    
        //
        // get idisp interface
        //
        hr = pEvent->QueryInterface( IID_IDispatch, (void **)&pIDispatch );

        if ( SUCCEEDED(hr) )
        {
            //
            // get callback & fire event

            //
            pAgentHandler = pAgentSession->GetAgentHandler();
            if( pAgentHandler != NULL)
            {
                CTAPI *pTapi = pAgentHandler->GetTapi();
                pTapi->Event( TE_AGENTSESSION, pIDispatch );
            }
            // release stuff
            //
            pIDispatch->Release();
            
        }
        else
        {
            STATICLOG((TL_ERROR, "(Event)FireEvent - Could not get disp interface of AgentSessionEvent object"));
            delete pEvent;
        }
    }
    else
    {
        STATICLOG((TL_ERROR, "(Event)FireEvent - Could not create AgentSessionEvent object"));
    }

   
    STATICLOG((TL_TRACE, hr, "(Event)FireEvent - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSessionEvent
// Method    : FinalRelease
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CAgentSessionEvent::FinalRelease()
{
    m_pSession->Release();

}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSessionEvent 
// Interface : ITAgentSessionEvent
// Method    : Session
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSessionEvent::get_Session(ITAgentSession * * ppSession)
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "(Event)Session - enter" ));

    if (!TAPIIsBadWritePtr( ppSession, sizeof(ITAgentSession *) ) )
        {
        *ppSession = m_pSession;
        m_pSession->AddRef();
        }
    else
        {
        LOG((TL_ERROR, "(Event)Session - bad ppSession pointer"));
        hr = E_POINTER;
        }
    
    LOG((TL_TRACE, hr, "(Event)Session - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentSessionEvent              .
// Interface : ITAgentSessionEvent
// Method    : Event
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentSessionEvent::get_Event(AGENT_SESSION_EVENT * pEvent)
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "Event - enter" ));

    if (!TAPIIsBadWritePtr( pEvent, sizeof(AGENT_SESSION_EVENT) ) )
        {
        *pEvent = m_SessionEvent;
        }
    else
        {
        LOG((TL_ERROR, "Event - bad pEvent pointer"));
        hr = E_POINTER;
        }

    LOG((TL_TRACE, hr, "Event - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function  : MapAgentSessionStateFrom3to2
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
DWORD MapAgentSessionStateFrom3to2(AGENT_SESSION_STATE tapi3State)
{
    DWORD tapi2State = 0;

    switch(tapi3State)
    {
        case  ASST_NOT_READY:
            tapi2State = LINEAGENTSESSIONSTATE_NOTREADY;
            break;
        case  ASST_READY:
            tapi2State = LINEAGENTSESSIONSTATE_READY;
            break;
        case  ASST_BUSY_ON_CALL:
            tapi2State = LINEAGENTSESSIONSTATE_BUSYONCALL;
            break;
        case  ASST_BUSY_WRAPUP:
            tapi2State = LINEAGENTSESSIONSTATE_BUSYWRAPUP;
            break;
        case  ASST_SESSION_ENDED:
            tapi2State = LINEAGENTSESSIONSTATE_ENDED;
            break;
        default:
            break;
    }
    
    /*Nikhilb:Assuming that 0 is not a valid state. So if this function 
      returns 0 then it is assumed that it was passed an invalid state*/
    return tapi2State;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Function  : MapAgentSessionStateFrom2to3
//
// 
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT MapAgentSessionStateFrom2to3(DWORD tapi2State, AGENT_SESSION_STATE  *tapi3State)
{
    HRESULT hr = S_OK;


    if (tapi2State & LINEAGENTSESSIONSTATE_NOTREADY)
    {
        *tapi3State = ASST_NOT_READY;
    }
    else if (tapi2State & LINEAGENTSESSIONSTATE_READY)
    {
        *tapi3State = ASST_READY;
    }
    else if (tapi2State & LINEAGENTSESSIONSTATE_BUSYONCALL)
    {
        *tapi3State = ASST_BUSY_ON_CALL;
    }
    else if (tapi2State & LINEAGENTSESSIONSTATE_BUSYWRAPUP)
    {
        *tapi3State = ASST_BUSY_WRAPUP;
    }
    else if (tapi2State & LINEAGENTSESSIONSTATE_ENDED)
    {
        *tapi3State = ASST_SESSION_ENDED;
    }
    else
    {
        *tapi3State = ASST_NOT_READY;   // default
        hr = E_INVALIDARG;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\tapi3\agenthand.cpp ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    agenthand.cpp

Abstract:

    Implementation of the CAll centre interface for TAPI 3.0.
    AgentHandler class

Author:

    noela - 03/16/98

Notes:

    optional-notes

Revision History:

--*/


#define UNICODE
#include "stdafx.h"
#include "lmcons.h"

extern CHashTable *    gpAgentHandlerHashTable ;





/////////////////////////////////////////////////////////////////////////////
// ITAgentHandler


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Method    : Initialize
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentHandler::Initialize(PWSTR pszProxyName, GUID proxyGUID, CTAPI *tapiObj)
{
    HRESULT  hr = S_OK;


    LOG((TL_TRACE, "Initialize - enter" ));

    m_GUID          = proxyGUID;
    m_tapiObj       = tapiObj;
    m_pAddressLine  = NULL;

    // copy the Name
    if (pszProxyName != NULL)
    {
        m_szName = (PWSTR) ClientAlloc((lstrlenW(pszProxyName) + 1) * sizeof (WCHAR));
        if (m_szName != NULL)
        {
            lstrcpyW(m_szName,pszProxyName);
        }
    else
        {
            LOG((TL_ERROR, "Initialize - Alloc m_szName failed" ));
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_ERROR, "Initialize - name is NULL" ));
        m_szName = NULL;
    }

    // Initialize our hash tables
    //
    m_AgentSessionHashtable.Initialize(1);
    m_QueueHashtable.Initialize(1);


    LOG((TL_TRACE, hr, "Initialize - exit" ));
    return hr;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Method    : AddAddress
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CAgentHandler::AddAddress(CAddress *pAddress)
{

    LOG((TL_TRACE, "AddAddress - enter"));

    
    //
    // good address?
    //

    if (IsBadReadPtr(pAddress, sizeof(CAddress) ))
    {
        LOG((TL_ERROR, "AddAddress - bad address pointer"));
        return;
    }


    //
    // get ITAddress out of the CAddress pointer
    //

    ITAddress *pITAddress = dynamic_cast<ITAddress *>(pAddress);

    if (NULL == pITAddress)
    {
        LOG((TL_ERROR, "AddAddress - pITAddress is NULL"));
        return;
    }


    //
    // log address' name
    //

#if DBG

    {
        BSTR bstrName = NULL;

        HRESULT hr = pITAddress->get_AddressName(&bstrName);

        if (SUCCEEDED(hr))
        {
            LOG((TL_TRACE, "AddAddress - using address %ls ",bstrName));
            SysFreeString( bstrName );
        }
    }

#endif


    //
    // first see if this ITAddress is in the array of my addresses
    //

    int nIndex = m_AddressArray.Find( pITAddress );

    if (nIndex >= 0)
    {
        
        LOG((TL_TRACE, 
            "AddAddress - address already in the array. doing nothing"));

        return;
    }


    //
    // add address to the array of managed addresses
    //

    BOOL bAddSuccess = m_AddressArray.Add( pITAddress );


    //
    // log a message if the object failed to be added to the array
    //

    if ( !bAddSuccess )
    {

        LOG((TL_ERROR,
            "AddAddress - failed to add address to the array"));

        return;

    }

    LOG((TL_TRACE, "AddAddress - exit"));
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Method    : getHLine
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HLINE CAgentHandler::getHLine()
{
    CAddress  * pAddress;
    HLINE       hLine = 0;
    HRESULT     hr = S_OK;

    LOG((TL_TRACE, "getHLine - enter"));

    if (m_pAddressLine != NULL)
    {
        hLine = m_pAddressLine->t3Line.hLine;
    }
    else
    {
        // If we don't have a line, find one
        pAddress = dynamic_cast<CAddress *>(m_AddressArray[0]);

        if ( NULL != pAddress )
        {

#if DBG
            {
                BSTR        bstrName;

                ((ITAddress *)(pAddress))->get_AddressName(&bstrName);
                LOG((TL_INFO, "getHLine - using address %ls ",bstrName));
                SysFreeString( bstrName );
            }
#endif
        
            hr = pAddress->FindOrOpenALine (LINEMEDIAMODE_INTERACTIVEVOICE, &m_pAddressLine);
            
            if (SUCCEEDED(hr) )
            {
                hLine = m_pAddressLine->t3Line.hLine;

                // We've got a line open to the proxy, so lets add it to the AH hash table
                gpAgentHandlerHashTable->Lock();
                gpAgentHandlerHashTable->Insert( (ULONG_PTR)hLine, (ULONG_PTR)this );
                gpAgentHandlerHashTable->Unlock();
            }
        }

    }

    LOG((TL_TRACE,hr, "getHLine(%8x) - exit", hLine));
    return hLine;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Method    : FinalRelease
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void CAgentHandler::FinalRelease()
{
    CAddress    * pAddress;

    LOG((TL_TRACE, "FinalRelease AgentHandler - %S", m_szName ));

    if ( m_szName != NULL )
    {
         ClientFree(m_szName);
    }

    // If we  have a line open close it
    if (m_pAddressLine != NULL)
    {
        // We've got a line open to the proxy, so lets remove it from the AH hash table
        gpAgentHandlerHashTable->Lock();
        gpAgentHandlerHashTable->Remove( (ULONG_PTR)(m_pAddressLine->t3Line.hLine) );
        gpAgentHandlerHashTable->Unlock();

        // And then close it
        pAddress = dynamic_cast<CAddress *>(m_AddressArray[0]);

        if ( NULL != pAddress )
        {
            pAddress->MaybeCloseALine (&m_pAddressLine);
        }
    }

    m_AddressArray.Shutdown();
    m_GroupArray.Shutdown();
    m_AgentArray.Shutdown();

    // Shutdown our hash tables
    //
    m_AgentSessionHashtable.Shutdown();
    m_QueueHashtable.Shutdown();


    LOG((TL_TRACE, "FinalRelease AgentHandler - exit" ));
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Method    : FindSessionObject
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CAgentHandler::FindSessionObject(
                            HAGENTSESSION  hAgentSession,
                            CAgentSession  ** ppAgentSession
                            )
{
    BOOL    bResult = FALSE;


    m_AgentSessionHashtable.Lock();

    if ( SUCCEEDED(m_AgentSessionHashtable.Find( (ULONG_PTR)hAgentSession, (ULONG_PTR *)ppAgentSession )) )
    {
        bResult = TRUE;
    }
    else
    {
        bResult = FALSE;
    }

    m_AgentSessionHashtable.Unlock();

    return bResult;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Method    : FindSessionObject
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CAgentHandler::FindQueueObject(
                            DWORD  dwQueueID,
                            CQueue  ** ppQueue
                            )
{
    BOOL    bResult = FALSE;


    m_QueueHashtable.Lock();

   
    if ( SUCCEEDED(m_QueueHashtable.Find( (ULONG_PTR)dwQueueID, (ULONG_PTR *)ppQueue )) )
    {
        bResult = TRUE;
    }
    else
    {
        bResult = FALSE;
    }

    m_QueueHashtable.Unlock();

    return bResult;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Method    : FindAgentObject
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
BOOL CAgentHandler::FindAgentObject(
                            HAGENT hAgent,
                            CAgent ** ppAgent
                            )
{
    HRESULT             hr = FALSE;
    CAgent              *pAgent;
    int                 iCount;
    
    LOG((TL_TRACE, "FindAgent %d", hAgent));

    for ( iCount = 0; iCount < m_AgentArray.GetSize(); iCount++ )
    {
        pAgent = dynamic_cast<CComObject<CAgent>*>(m_AgentArray[iCount]);
        if (pAgent !=NULL)
        {
            if (hAgent == pAgent->getHandle() )
            {
                // Found it
                *ppAgent = pAgent;
                hr = TRUE;
                break;
            }
        }
    }

    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CACDGroup
// Method    : UpdateAgentHandlerList
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CAgentHandler::UpdateGroupArray()
{
    HRESULT                 hr = S_OK;
    DWORD                   dwNumberOfEntries;
    LPLINEAGENTGROUPLIST    pGroupList = NULL;
    LPLINEAGENTGROUPENTRY   pGroupEntry = NULL;
    PWSTR                   pszGroupName;
    DWORD                   dwCount;
    GUID                  * pGroupID;
    BOOL                    foundIt;
    CACDGroup             * thisGroup = NULL;
    int                     iCount;
    

    LOG((TL_TRACE, "UpdateGroupArray - enter"));


    // Call lineGetGroupList to get list of Groups
    hr = LineGetGroupList( getHLine(), &pGroupList );
    if( SUCCEEDED(hr) )
    {
        dwNumberOfEntries = pGroupList->dwNumEntries;
        LOG((TL_INFO, "UpdateGroupArray - Number of entries: %d", dwNumberOfEntries));
        if ( dwNumberOfEntries !=0 )
        {
            // Run through the new list from the Proxy &see if any new groups have appeared
            // By Comparing IDs from the new list with those in TAPIs list
            
            
            // Find position of 1st LINEAGENTGROUPEENTRY structure in the LINEAGENTGROUPLIST
            pGroupEntry = (LPLINEAGENTGROUPENTRY) ((BYTE*)(pGroupList) + pGroupList->dwListOffset);
            
            // Run though the received list
            for (dwCount = 0; dwCount < dwNumberOfEntries; dwCount++)
            {
                pszGroupName= (PWSTR)( (PBYTE)pGroupList + pGroupEntry->dwNameOffset);
                pGroupID = (GUID*)&pGroupEntry->GroupID;
    
                #if DBG
                {
                    WCHAR guidName[100];
    
                    StringFromGUID2(*pGroupID, (LPOLESTR)&guidName, 100);
                    LOG((TL_INFO, "UpdateGroupArray - Group Name : %S", pszGroupName));
                    LOG((TL_INFO, "UpdateGroupArray - Group GUID : %S", guidName));
                }
                #endif
    
                // Run through the array of Groups & see if we already have this one in the list
                // by comparing IDs
                foundIt = FALSE;
                Lock();
                
                for (iCount = 0; iCount < m_GroupArray.GetSize(); iCount++)
                {
                    thisGroup = dynamic_cast<CComObject<CACDGroup>*>(m_GroupArray[iCount]);
                    if (thisGroup != NULL)
                    {
                        if ( IsEqualGUID(*pGroupID, thisGroup->getID() ) )
                        {
                            foundIt = TRUE;
                            break;
                        }
                    }
                }
                Unlock();
                
                if (foundIt == FALSE)
                {
                    // Didn't match so lets add this Group
                    LOG((TL_INFO, "UpdateGroupArray - create new Group"));
    
                    CComObject<CACDGroup> * pGroup;
                    hr = CComObject<CACDGroup>::CreateInstance( &pGroup );
                    if( SUCCEEDED(hr) )
                    {
                        ITACDGroup * pITGroup;
                        hr = pGroup->QueryInterface(IID_ITACDGroup, (void **)&pITGroup);
                        if ( SUCCEEDED(hr) )
                        {
                            // initialize the Group
                            hr = pGroup->Initialize(pszGroupName, *pGroupID, this);
                            if( SUCCEEDED(hr) )
                            {

                                LOG((TL_TRACE, "UpdateGroupArray - Initialize Group succeededed" ));
    
                                //
                                // add to Array of Groups
                                //
                                Lock();
                                m_GroupArray.Add(pITGroup);
                                Unlock();
                                pITGroup->Release();
    
                                LOG((TL_INFO, "UpdateGroupArray - Added Group to Array"));
    
                            }
                            else
                            {
                                LOG((TL_ERROR, "UpdateGroupArray - Initialize Group failed" ));
                                delete pGroup;
                            }
                        }
                        else
                        {
                            LOG((TL_ERROR, "UpdateGroupArray - QueryInterface failed" ));
                            delete pGroup;
                        }
                    }
                    else
                    {
                        LOG((TL_ERROR, "UpdateGroupArray - Create Group failed" ));
                    }
                }
                else // foundIt == TRUE
                {
                    LOG((TL_INFO, "UpdateGroupArray - Group Object exists for this entry" ));
                    // Just in case is was previously inactive
                    thisGroup->SetActive();
    
                }
    
                // next entry in list
                pGroupEntry ++;
            } //for(dwCount = 0......)
    
    
    
    
            // Run through the list of Groups & see if any groups have been removed by the Proxy
            // By comparing IDs of those in TAPIs list with the new list from the Proxy
            for (iCount = 0; iCount < m_GroupArray.GetSize(); iCount++)
            {
                thisGroup = dynamic_cast<CComObject<CACDGroup>*>( m_GroupArray[iCount] );
                if (thisGroup != NULL)
                {
                    foundIt = FALSE;
                    // Find position of 1st LINEAGENTGROUPEENTRY structure in the LINEAGENTGROUPLIST
                    pGroupEntry = (LPLINEAGENTGROUPENTRY) ((BYTE*)(pGroupList) + pGroupList->dwListOffset);
                    // Run though the list
                    for (dwCount = 0; dwCount < dwNumberOfEntries; dwCount++)
                    {
                        pGroupID = (GUID*)&pGroupEntry->GroupID;
                        if ( IsEqualGUID(*pGroupID, thisGroup->getID() ) )
                        {
                            foundIt = TRUE;
                            break;
                        }
                    pGroupEntry ++;     // next
                    } // for (dwCount = 0......) 
    
    
                    if (foundIt == FALSE)
                    {
                        // Didn't match so it's no longer a valid group , according to the Proxy
                        LOG((TL_INFO, "UpdateGroupArray - Group has gone from the proxy"));
                        thisGroup->SetInactive();
                    }
                }
            } 
        }
        else
        {
            LOG((TL_ERROR, "UpdateGroupArray - lineGetGroupList failed - empty list"));
            hr = E_FAIL; 
        }

    }
    else  // lineGetGroupList  failed
    {
        LOG((TL_ERROR, "UpdateGroupArray - lineGetGroupList failed"));
    }




    // finished with memory block so release
    if ( pGroupList != NULL )
        ClientFree( pGroupList );


    LOG((TL_TRACE, hr, "UpdateGroupArray - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Interface : ITAgentHandler
// Method    : get_Name
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentHandler::get_Name(BSTR * Name)
{
    HRESULT hr = S_OK;

    LOG((TL_TRACE, "Name - enter" ));
    Lock();
    if(!TAPIIsBadWritePtr( Name, sizeof(BSTR) ) )
    {
        *Name = SysAllocString(m_szName);

        if (*Name == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        LOG((TL_ERROR, "Name - bad Name pointer" ));
        hr = E_POINTER;
    }

    Unlock();
    LOG((TL_TRACE, hr, "Name - exit" ));
    return hr;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Interface : ITAgentHandler
// Method    : CreateAgent
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentHandler::CreateAgent(ITAgent **ppAgent)
{
    HRESULT     hr = S_OK;
    CAgent    * pAgent;

    LOG((TL_TRACE, "CreateAgent - enter"));
    if(!TAPIIsBadWritePtr( ppAgent, sizeof(ITAgent *) ) )
    {
        hr  = InternalCreateAgent(NULL, NULL, &pAgent);
        if ( SUCCEEDED(hr) )
        {
            //
            // put result in out pointer - also
            pAgent->QueryInterface(IID_ITAgent, (void **)ppAgent );
        }
        else
        {
            LOG((TL_ERROR, "CreateAgent - InternalCreateAgent failed" ));
        }
    }
    else
    {
        LOG((TL_ERROR, "CreateAgent - Bad ppAgent Pointer"));
        hr = E_POINTER;
    }
	LOG((TL_TRACE, hr, "CreateAgent - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Interface : ITAgentHandler
// Method    : CreateAgentWithID
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentHandler::CreateAgentWithID(BSTR pID, BSTR pPIN, ITAgent **ppAgent)
{
    HRESULT     hr = S_OK;
    CAgent    * pAgent;

    LOG((TL_TRACE, "CreateAgentWithID - enter"));

    if(!TAPIIsBadWritePtr( ppAgent, sizeof(ITAgent *) ) )
    {
        if (!IsBadStringPtrW( pID, -1 ))
        {
            // ID Pointer OK, is it empty ?
            if( *pID != NULL)
            {    
                if (!IsBadStringPtrW( pPIN, -1 ))
                {
                    // All OK so far, so try  to create
                    hr  = InternalCreateAgent(pID, pPIN, &pAgent);
                    if ( SUCCEEDED(hr) )
                    {
                        // put result in out pointer - also
                        pAgent->QueryInterface(IID_ITAgent, (void **)ppAgent );
                    }
                    else // InternalCreateAgent failed
                    {
                        LOG((TL_ERROR, "CreateAgentWithID - InternalCreateAgent failed" ));
                    }
                }
                else  // bad PIN pointer
                {
                    LOG((TL_ERROR, "CreateAgentWithID - Bad PIN pointer" ));
                    hr = E_POINTER;
                }
            }
            else // NULL ID
            {
                LOG((TL_ERROR, "CreateAgentWithID - ID is Empty String" ));
                hr = E_INVALIDARG;
            }
        }
        else // bad ID pointer
        {
            LOG((TL_ERROR, "CreateAgentWithID - Bad ID pointer" ));
            hr = E_POINTER;
        }
    }
    else
    {
        LOG((TL_ERROR, "CreateAgentWithID - Bad ppAgent Pointer"));
        hr = E_POINTER;
    }

	LOG((TL_TRACE, hr, "CreateAgentWithID - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Method    : InternalCreateAgent
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
HRESULT CAgentHandler::InternalCreateAgent(BSTR pID, BSTR pPIN, CAgent ** ppAgent)
{
    HRESULT     hr = S_OK;
    HAGENT      hAgent;
    DWORD       dwUserNameSize = (UNLEN + 1);
    PWSTR       pszName = NULL;

    LOG((TL_TRACE, "InternalCreateAgent - enter"));

    hr = LineCreateAgent(getHLine(), pID, pPIN, &hAgent);
    if ( SUCCEEDED(hr) )
    {
        hr = WaitForReply( hr );
        if ( SUCCEEDED(hr) )
        {
            // Successs, so create agent
            LOG((TL_INFO, "InternalCreateAgent - create new Agent Handler" ));

            CComObject<CAgent> * pAgent;
            hr = CComObject<CAgent>::CreateInstance( &pAgent);
            if( SUCCEEDED(hr) )
            {
                // initialize the AgentHandler
                pszName =  (PWSTR)ClientAlloc((dwUserNameSize + 1) * sizeof(WCHAR) );
                if (pszName != NULL)
                {
                    if ( GetUserNameW( pszName, &dwUserNameSize) )
                    {
                        ITAgent *pITAgent;
                        hr = pAgent->QueryInterface(IID_ITAgent, (void **)&pITAgent);

                        if( SUCCEEDED(hr ))
                        {
                            hr = pAgent->Initialize(hAgent, pszName, pID, pPIN, this );
                            if( SUCCEEDED(hr) )
                            {
                                //
                                // add to list
                                //
                                Lock();
                                m_AgentArray.Add(pITAgent);
                                Unlock();
                                
                                pITAgent->Release();
                                LOG((TL_INFO, "InternalCreateAgent - Added Agent to array"));
        
                                // Return new Agent object
                                *ppAgent = pAgent;
                            }
                            else
                            {
                                LOG((TL_ERROR, "InternalCreateAgent - Initialize Agent failed" ));
                                delete pAgent;
                            }
                        }
                        else
                        {
                            LOG((TL_ERROR, "InternalCreateAgent - QueryInterface failed" ));
                            delete pAgent;
                        }

                    }
                    else  // GetUserName fail
                    {
                        LOG((TL_ERROR, "InternalCreateAgent - GetUserNameW failed" ));
                        hr = TAPI_E_CALLCENTER_INVALAGENTID;
                    }
                }
                else // pszName == NULL
                {
                    LOG((TL_ERROR, "InternalCreateAgent - ClientAlloc pszName failed" ));
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                LOG((TL_ERROR, "InternalCreateAgent - Create Agent failed" ));
            }
        }
        else // LineCreateAgent failed async
        {
            LOG((TL_ERROR, "InternalCreateAgent - LineCreateAgent failed async" ));
        }
    }
    else // LineCreateAgent failed
    {
        LOG((TL_ERROR, "InternalCreateAgent - LineCreateAgent failed" ));
    }


    if(pszName != NULL)
        ClientFree(pszName);


	LOG((TL_TRACE, hr, "InternalCreateAgent - exit"));
    return hr;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Interface : ITAgentHandler
// Method    : EnumerateACDGroups
//
//
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentHandler::EnumerateACDGroups(IEnumACDGroup ** ppEnumACDGroup)
{
    HRESULT     hr = S_OK;

    LOG((TL_TRACE, "EnumerateACDGroups - enter"));

    if(!TAPIIsBadWritePtr( ppEnumACDGroup, sizeof(IEnumACDGroup *) ) )
    {
        UpdateGroupArray();
    
        //
        // create the enumerator
        //
        CComObject< CTapiEnum<IEnumACDGroup, ITACDGroup, &IID_IEnumACDGroup> > * pEnum;
        hr = CComObject< CTapiEnum<IEnumACDGroup, ITACDGroup, &IID_IEnumACDGroup> > ::CreateInstance( &pEnum );
    
        if (SUCCEEDED(hr) )
        {
            // initialize it with our group list
            Lock();
            hr = pEnum->Initialize( m_GroupArray );
            Unlock();
            if ( SUCCEEDED(hr) )
            {
                // return it
                *ppEnumACDGroup = pEnum;
            }
            else //  failed to  initialize
            {
                LOG((TL_ERROR, "EnumerateACDGroup - could not initialize enum" ));
                pEnum->Release();
            }
        }
        else  // failed to create enum
        {
            LOG((TL_ERROR, "EnumerateACDGroups - could not create enum" ));
        }
    }
    else
    {
        LOG((TL_ERROR, "EnumerateACDGroups - bad ppEnumACDGroup ponter" ));
        hr = E_POINTER;
    }

    LOG((TL_TRACE, hr, "EnumerateACDGroups - exit"));
    return hr;
}



//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Class     : CAgentHandler
// Interface : ITAgentHandler
// Method    : get_ACDGroups
//
// Return a collection of calls usable for this Agent Handler
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
STDMETHODIMP CAgentHandler::ge