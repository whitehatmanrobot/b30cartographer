RESENT(Members))
                {
                    // 
                    // allocate or extend the buffer
                    //
                    BufferSize = ((*MemberCount) + Count) * sizeof(PSID) +
                                 ((*MemberCount) + Count) * sizeof(NT4SID);
                                 
                    TmpMembers = MIDL_user_allocate( BufferSize );
                    
                    if (NULL == TmpMembers)
                    {
                        Status = STATUS_NO_MEMORY;
                        goto Error;
                    }
                    
                    RtlZeroMemory(TmpMembers, BufferSize);
                    
                    SidArray = (NT4SID *) (((PSID *) TmpMembers) + (*MemberCount) + Count);
                    
                    // 
                    // Copy any previous retrieved SID(s) to new location.
                    //  
                    
                    if (*MemberCount)
                    {
                        ASSERT(*Members);
                        
                        //
                        // Fix for RAID: 605082
                        // Note: because non security principal can be 
                        //       a member of (local / global) group, a gap 
                        //       between the pointers array (PSIDs) and the 
                        //       memory to store the member SIDs can be created
                        //       when we skip those non security principals. 
                        // 
                        // Illustrate as this:
                        //       if DsRead returns N members, but one of them 
                        //       is a non security principal, then PSID (Nth) 
                        //       will point to NULL, thus create a gap between 
                        //       PSID (N-1th) and SID (1st).  If there is not 
                        //       gap, we should have a contiguous space. 
                        // 
                        // -------------
                        // |  PSID 1   |-----------------
                        // -------------                |
                        // |  PSID 2   |-------------   |
                        // ------------             |   |
                        //      .                   |   |
                        //      .                   |   |
                        // ------------             |   |
                        // |  PSID N-1|-----------| |   |
                        // ------------           | |   |
                        // |  PSID N  |-> NULL    | |   |
                        // ------------           | |   |
                        // |  SID 1   |<----------+-+---|
                        // ------------           | |
                        // |  SID 2   |<----------+--
                        // ------------           |
                        //      .                 |
                        //      .                 |
                        // ------------           |
                        // |  SID N-1 |<-----------
                        // ------------
                        //    

                        RtlCopyMemory(SidArray, 
                                      (*Members)[0],
                                      (*MemberCount) * sizeof(NT4SID)
                                      );
                                      
                        //
                        // Set the pointer (to SID) to the right place 
                        // 
                        
                        for (TmpIndex = 0; TmpIndex < (*MemberCount); TmpIndex++)
                        {
                            TmpMembers[TmpIndex] = SidArray++;
                        }
                        
                    }
                    
                    if (*Members)
                    {
                        MIDL_user_free(*Members);
                    }
                    
                    *Members = TmpMembers;
                    TmpMembers = NULL;
                }
                
                // 
                // Loop Through each entry looking at the Sids 
                //
                
                for (Index = 0; Index < Count; Index++ )
                {
                    MemberName = (DSNAME *) AttrsRead.pAttr->AttrVal.pAVal[Index].pVal;
                    
                    if (MemberName->SidLen > 0)
                        MemberSid = &(MemberName->Sid);
                    else
                        MemberSid = SampDsGetObjectSid(MemberName);
                        
                    if (NULL == MemberSid)
                    {
                        // 
                        // Not a Security Principal, Skip
                        // 
                        
                        continue;
                    }
                    
                    if (ARGUMENT_PRESENT(Members))
                    {
                        // 
                        // Copy the new SID in the right place
                        // 
                        
                        (*Members)[*MemberCount] = SidArray ++;
                        
                        ASSERT(RtlLengthSid(MemberSid) <= sizeof(NT4SID));
                        
                        RtlCopyMemory((*Members)[*MemberCount],
                                      MemberSid, 
                                      RtlLengthSid(MemberSid)
                                      );
                    }
                    
                    // 
                    // Increment Count
                    // 
                    (*MemberCount)++;
                }
            }
        }

        //
        // (-1 == pReadRes->range.pRanges[0].upper) means the last values has been reached.
        // 
        if (NT_SUCCESS(Status)) {
            Upper = pReadRes->range.pRanges[0].upper;
        }


        //
        // End the transaction (and thread state) to limit server side resources
        //
        SampMaybeEndDsTransaction(TransactionCommit);

    } while (NT_SUCCESS(Status) && (-1 != Upper));
    
    
    if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE == Status)
    {
        Status = STATUS_SUCCESS;
    }

    //
    // On success cache the membership of large groups
    //

    if ((NT_SUCCESS(Status)) && (ARGUMENT_PRESENT(Members)))
    {
        NTSTATUS IgnoreStatus;

        IgnoreStatus = SampCacheGroupMembership(
                            AliasRid,
                            *Members,
                            SequenceNum,
                            *MemberCount,
                            SampAliasObjectType
                            );
    }
    
Error:


    if (!NT_SUCCESS(Status))
    {
        // 
        // Set Error Return
        // 
        
        if (ARGUMENT_PRESENT(Members) && (*Members))
        {
            MIDL_user_free((*Members));
            *Members = NULL;
        }
        
        *MemberCount = 0;
    }
    
    return Status;

}

NTSTATUS
SampDsGetPrimaryGroupMembers(
    DSNAME * DomainObject,
    ULONG   GroupRid,
    PULONG  PrimaryMemberCount,
    PULONG  *PrimaryMembers
    )
/*++

    Routine Description:

        SampDsGetPrimaryGroupMemberse obtains the members of the group by virtue of the
        Primary Group Id property. It searches the DS database looking for users whose
        primary group id is equal to the Rid of the users.

    Parameters:

        DomainObject -- The DS Name of the Domain Object
        GroupRid     -- The Rid of the group
        PrimaryMemberCount -- The number of users that are members by virtue of the primary
                              group id property is returned in here.
        PrimaryMembers  -- The Rids of all such users are returned in here.

    Return Values:

        STATUS_SUCCESS
        Other error codes depending upon failure mode
--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;
    ULONG           EntriesToQueryFromDs = 100; // Query just 100 entries at a time
    BOOLEAN         MoreEntriesPresent = TRUE;
    FILTER          DsFilter;
    SEARCHRES       *SearchRes;
    PRESTART        RestartToUse = NULL;

    ATTRTYP         AttrTypes[]=
                    {
                        SAMP_UNKNOWN_OBJECTSID,
                    };

    ATTRVAL         AttrVals[]=
                    {
                        {0,NULL}
                    };

    DEFINE_ATTRBLOCK1(
                      AttrsToRead,
                      AttrTypes,
                      AttrVals
                      );
    ULONG           BufferGrowthSize = 16 * 1024;  // allocate 16K entries at a time
    ULONG           CurrentBufferSize = 0;         // Note buffer sizes are in terms of
                                                   // number of entries

    //
    // Initialize our return values
    //

    *PrimaryMemberCount = 0;
    *PrimaryMembers = NULL;

    //
    // Build a filter structure for searching
    //
    memset (&DsFilter, 0, sizeof (DsFilter));
    DsFilter.pNextFilter = NULL;
    DsFilter.choice = FILTER_CHOICE_ITEM;
    DsFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    DsFilter.FilterTypes.Item.FilTypes.ava.type = SampDsAttrFromSamAttr(
                                                       SampUserObjectType,
                                                       SAMP_FIXED_USER_PRIMARY_GROUP_ID
                                                       );

    DsFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(ULONG);
    DsFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR *)&GroupRid;


    //
    // Now keep querying from DS till we have exhausted our query
    //


    while (MoreEntriesPresent)
    {
        ENTINFLIST  *CurrentEntInf;
        PULONG       NewMemory;

        //
        // Search the DS for objects with the given primary group Id
        //


        MoreEntriesPresent = FALSE;

        Status = SampMaybeBeginDsTransaction(TransactionRead);
        if (!NT_SUCCESS(Status))
            goto Error;

        Status = SampDsDoSearch(
                        RestartToUse,
                        DomainObject,
                        &DsFilter,
                        0,          // Starting Index
                        SampUnknownObjectType,
                        &AttrsToRead,
                        EntriesToQueryFromDs,
                        &SearchRes
                        );

        if (!NT_SUCCESS(Status))
        {
            goto Error;
        }

        if (SearchRes->count)
        {
            //
            // Allocate / Grow memory if required
            //

            if ((SearchRes->count+(*PrimaryMemberCount))>CurrentBufferSize)
            {

                NewMemory = MIDL_user_allocate(
                                    (CurrentBufferSize+BufferGrowthSize) * sizeof(ULONG));
                if (NULL== NewMemory)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Error;
                }

                CurrentBufferSize+=BufferGrowthSize;

                //
                // Copy in into the new buffer
                //
                //

                if (NULL!=*PrimaryMembers)
                {
                    RtlCopyMemory(NewMemory,*PrimaryMembers, sizeof(ULONG)*(*PrimaryMemberCount));
                    MIDL_user_free(*PrimaryMembers);
                }
                *PrimaryMembers = NewMemory;
            }

            //
            // Pack the results
            //

            for (CurrentEntInf = &(SearchRes->FirstEntInf);
                    CurrentEntInf!=NULL;
                    CurrentEntInf=CurrentEntInf->pNextEntInf)

            {
                ULONG   Rid;
                PSID    ReturnedSid = NULL;
                PSID    DomainSidOfCurrentEntry = NULL;
                PULONG  SamAccountType;

                ASSERT(CurrentEntInf->Entinf.AttrBlock.attrCount==1);
                ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr);

                ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.valCount==1);
                ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal->pVal);
                ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal->valLen);


                ReturnedSid = CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal->pVal;

                Status = SampSplitSid(
                            ReturnedSid,
                            NULL,
                            &Rid
                            );
                if (!NT_SUCCESS(Status))
                    goto Error;

                (*PrimaryMembers)[(*PrimaryMemberCount)++] = Rid;

            }

            //
            // Free the old restart structure
            //

            if (NULL!=RestartToUse)
            {
                MIDL_user_free(RestartToUse);
                RestartToUse = NULL;
            }

            //
            // Process search continuation
            //

            if (SearchRes->PagedResult.pRestart)
            {
                //
                // Restart structure was returned. More entries are still present
                //

                Status = SampCopyRestart(
                                SearchRes->PagedResult.pRestart,
                                &RestartToUse
                                );

                if (!NT_SUCCESS(Status))
                    goto Error;

                MoreEntriesPresent = TRUE;
            }
        }


        SampMaybeEndDsTransaction(TransactionCommit);

    }


Error:


    if (NULL!=RestartToUse)
    {
        MIDL_user_free(RestartToUse);
        RestartToUse = NULL;
    }


    SampMaybeEndDsTransaction(TransactionCommit);


    if (!NT_SUCCESS(Status))
    {
        if (NULL!=*PrimaryMembers)
        {
            MIDL_user_free(*PrimaryMembers);
            *PrimaryMembers=NULL;
        }
        *PrimaryMemberCount = 0;
    }

    return Status;
}

NTSTATUS
SampDsGetReverseMemberships(
    DSNAME * pObjName,
    ULONG    Flags,
    ULONG    *pcSids,
    PSID     **prpSids
   )
{
    NTSTATUS NtStatus;

    NtStatus = SampGetGroupsForToken(pObjName,
                                 Flags,
                                 pcSids,
                                 prpSids);

    return NtStatus;

}

NTSTATUS
SampDsResolveSidsWorker(
    IN  PSID    * rgSids,
    IN  ULONG   cSids,
    IN  PSID    *rgDomainSids,
    IN  ULONG   cDomainSids,
    IN  PSID    *rgEnterpriseSids,
    IN  ULONG   cEnterpriseSids,
    IN  ULONG   Flags,
    OUT DSNAME  ***rgDsNames
    )
/*++

    This is the worker routine for Resolve Sids.
    This is Resolves a Set of Sids Passed to it to obtain the DS Names
    of the Sids. Resolve Sids Does the Following

    1. Checks to see if the SID corresponds to Sids in the account domain.
    2. For Sids, for whom matches do not turn up, 
       this routine checks to see if they a foriegn security principal.
       For them a new object is created.
    3. For Sids that are not foregn security principal 
       this routine checks to see if they are present at a G.C

    4. Well Known SIDs and Builtin Domain SIDs. The Default behaviour for a
       WellKnown SID  ( e.g Everyone ) is to create a foriegn Security 
       Principal Object for the Well Known SID, if one did not exist and
       return the DSNAME corresponding to that. The default behaviour for
       Builtin Domain SID is to not resolve it. This corresponds to the Design
       of allowing SIDs like "everyone" in local groups but not SIDs like
       "Administratrators".

    Any Unresolved Sid will be returned with a NULL pointer for the DS Name.



    Parameters:

        rgSids -- The array of Sids that need to be passed in.
        cSids  -- The count of Sids
        Flags  -- Used to control the operation of the routine
        
                    RESOLVE_SIDS_ADD_FORIEGN_SECURITY_PRINCIPAL
                    -- Automatically Adds the foreign domain security principal to the DS.

                    RESOLVE_SIDS_VALIDATE_AGAINST_GC
                    -- Goes to the G.C if required

                    RESOLVE_SIDS_SID_ONLY_NAMES_OK
                    -- Constructs the DS Name with only a SID for all 
                       passed in SIDs. No validation is performed.

                    RESOLVE_SIDS_SID_ONLY_DOMAIN_SIDS_OK
                    -- Constructs the DS Name with only a SID for all passed
                       in SIDs, provided the SID is a SID in the domain

        rgDsNames -- Will MIDL_user alloc an array of DS Names 
                     back to the caller. Caller
                     is responsible for freeing them

    Return Values:

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL


    WARNING -- When running from SAM as part of regular SAM operations, this routine should be called
    with no locks held and no open transactions. Further this routine should not be
    called from the loopback case. The loopback call does its own validation ( GC / shim lookup )

  --*/
 {
    NTSTATUS         NtStatus = STATUS_SUCCESS;
    ULONG            i;
    DSNAME           *pLoopBackObject;
    SAMP_OBJECT_TYPE FoundType;
    BOOLEAN          fSamLockAcquired = FALSE,
                     DsContext = FALSE;
    PULONG           rgGcSidIndices=NULL;
    PSID             *rgGcSids=NULL;
    ULONG            cGcSids = 0;
    NTSTATUS         IgnoreStatus;
    ULONG            DsErr = 0;
    DSNAME           **GcDsNames=NULL;



    *rgDsNames = NULL;

    //
    // Allocate enough space for the array of DS Names
    //

    *rgDsNames = MIDL_user_allocate(cSids * sizeof(PDSNAME));
    if (NULL==*rgDsNames)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    //
    // Zero out the space
    //

    RtlZeroMemory(*rgDsNames, cSids * sizeof(PDSNAME));


    //
    // Alloc space from HEAP (instead of from stack) 
    // for the array of Sids which we will need
    // to remote to G.C ( Potentially every Sid is a G.C Sid ).
    //

    rgGcSids = MIDL_user_allocate(cSids * sizeof(PSID));
    
    if (NULL == rgGcSids)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }
    
    RtlZeroMemory(rgGcSids, cSids * sizeof(PSID));
    
    
    rgGcSidIndices  = MIDL_user_allocate(cSids * sizeof(ULONG));
    
    if (NULL == rgGcSidIndices)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }
    
    RtlZeroMemory(rgGcSidIndices, cSids * sizeof(ULONG));


    //
    // Walk through the Passed in Array of Sids, walking Sid by Sid
    //

    for (i=0;i<cSids;i++)
    {
        BOOLEAN     WellKnownSid = FALSE,
                    LocalSid = TRUE,
                    ForeignSid = FALSE,
                    EnterpriseSid = FALSE,
                    BuiltinDomainSid = FALSE;



        if (!(Flags & RESOLVE_SIDS_SID_ONLY_NAMES_OK))
        {
            //
            // Check Sid Type, if SID_ONLY_NAMES are requested,
            // then this check can be skipped as we simply will
            // construct a DSNAME with just the SID field filled
            // in. 
            //

            NtStatus = SampDsCheckSidType(
                            rgSids[i],
                            cDomainSids,
                            rgDomainSids,
                            cEnterpriseSids,
                            rgEnterpriseSids,
                            &WellKnownSid,
                            &BuiltinDomainSid,
                            &LocalSid,
                            &ForeignSid,
                            &EnterpriseSid
                            );

            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
        }


        //
        // Firewall against any Sids that
        // we do not understand
        //

        if ( (RtlLengthSid(rgSids[i])) >sizeof(NT4SID) )
        {
            continue;
        }

        if ((WellKnownSid) && (Flags & RESOLVE_SIDS_FAIL_WELLKNOWN_SIDS))
        {

            //
            // Caller asked us to fail the call if a SID like "EveryOne" were
            // present
            //
           
                NtStatus = STATUS_UNSUCCESSFUL;
                goto Error;
        }
        else if ((BuiltinDomainSid) && (Flags & RESOLVE_SIDS_FAIL_BUILTIN_DOMAIN_SIDS))
        {
            //
            // Caller asked us to fail the call if a SID like "Administrators" 
            // were present
            //
            
                NtStatus = STATUS_UNSUCCESSFUL;
                goto Error;
        }
        else if ((Flags& RESOLVE_SIDS_SID_ONLY_NAMES_OK)
                || ((Flags & RESOLVE_SIDS_SID_ONLY_DOMAIN_SIDS_OK)
                    && (LocalSid)))
         {
            //
            // Caller asked us to do this , so we just construct a
            // Sid Only Name. This is used by second phase of logon,
            // coming in through SamrGetAliasMembership. The Ds
            // reverse membership evaluation routines have the
            // intelligence to find a name just by SID, so this results
            // in a significant performance improvement, rather than
            // just searching or validating against G.C
            //
            DSNAME * SidOnlyDsName = NULL;

            // Construct a Sid Only DS Name
            SidOnlyDsName = MIDL_user_allocate(sizeof(DSNAME));
            if (NULL==SidOnlyDsName)
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }

            BuildDsNameFromSid(
                rgSids[i],
                SidOnlyDsName
                );

            (*rgDsNames)[i] = SidOnlyDsName;
        }
        else if (LocalSid || ForeignSid || WellKnownSid || BuiltinDomainSid)
        {

            //
            // Try to resolve the SID to a DS Name by looking up the object
            // locally. LocalSid Implies local account domain security principal,
            // Foreign SID implies that we  may resolve to an FPO, same is true
            // for WellKnownSid and for BuiltinDomainSId, we will resolve to the
            // appropriate Builtin Domain Object
            //

            //
            // Begin A transaction, if there is not one
            //


            NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
            if (!NT_SUCCESS(NtStatus))
                goto Error;

            //
            // Try to Resolve the Sid Locally.
            //

            NtStatus = SampDsObjectFromSid(rgSids[i],&((*rgDsNames)[i]));

            if (STATUS_NOT_FOUND==NtStatus)
            {
                NtStatus = STATUS_SUCCESS;
                (*rgDsNames)[i] = NULL;

                if ((ForeignSid || WellKnownSid)
                      && (Flags & RESOLVE_SIDS_ADD_FORIEGN_SECURITY_PRINCIPAL))
                {

                    //
                    // Construct a SID only name -- the DS will handle these
                    //
                    DSNAME * SidOnlyDsName = NULL;
        
                    // Construct a Sid Only DS Name
                    SidOnlyDsName = MIDL_user_allocate(sizeof(DSNAME));
                    if (NULL==SidOnlyDsName)
                    {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        goto Error;
                    }
        
                    BuildDsNameFromSid(
                        rgSids[i],
                        SidOnlyDsName
                        );
        
                    (*rgDsNames)[i] = SidOnlyDsName;
                }

            }
            else if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
        }
        else
        {

            ASSERT(EnterpriseSid==TRUE);

            //
            // Mark the Sid as a G.C Sid
            // Note its index in the original array as
            // we will have to merge in the DS names returned
            // by the G.C
            //


            rgGcSids[cGcSids]=rgSids[i];
            rgGcSidIndices[cGcSids] = i;
            cGcSids++;
        }
    }


    //
    // Commit any open transaction that we may  have as we prepare
    // to go to the G.C
    //

    SampMaybeEndDsTransaction(TransactionCommit);

    //
    // At this point we have resolved what can be done locally.
    // we have also a built a list of Sids that we thing may require
    // reference to the G.C.
    //

    if (cGcSids && (Flags & RESOLVE_SIDS_VALIDATE_AGAINST_GC))
    {

        ASSERT(!SampCurrentThreadOwnsLock());
        ASSERT(!SampExistsDsTransaction());
        ASSERT(!SampExistsDsLoopback(&pLoopBackObject));

       //
       // Create a Thread State so that SampVerifySids may operate
       //

       DsErr = THCreate( CALLERTYPE_SAM );
       if (0!=DsErr)
       {
           NtStatus = STATUS_INSUFFICIENT_RESOURCES;
           goto Error;
       }

       SampSetDsa(TRUE);
       SampSetSam(TRUE);

       DsErr = SampVerifySids(
                    cGcSids,
                    rgGcSids,
                    &GcDsNames
                    );

       // Morph Any errors in verification to  STATUS_DS_GC_NOT_AVAILABLE.
       if (0!=DsErr)
       {
           NtStatus = STATUS_DS_GC_NOT_AVAILABLE;
           goto Error;
       }

       //
       // Patch up the original array. Copy the DsNames passed from thread
       // memory
       //

       for (i=0;i<cGcSids;i++)
       {
          if (NULL!=GcDsNames[i])
          {
              (*rgDsNames)[rgGcSidIndices[i]] = MIDL_user_allocate(GcDsNames[i]->structLen);
              if (NULL==(*rgDsNames)[rgGcSidIndices[i]])
              {
                  NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                  goto Error;
              }

              RtlCopyMemory(
                  (*rgDsNames)[rgGcSidIndices[i]],
                  GcDsNames[i],
                  GcDsNames[i]->structLen
                  );
          }
       }


     //
     // Leave the thread state hanging in the system as it is.
     // This thread state holds the verified Ds Names.
     //

    }



Error:

    if (rgGcSids)
    {
        MIDL_user_free(rgGcSids);
    }
    
    if (rgGcSidIndices)
    {
        MIDL_user_free(rgGcSidIndices);
    }

    return NtStatus;
}



NTSTATUS
SampDsCheckSidType(
    IN  PSID    Sid,
    IN  ULONG   cDomainSids,
    IN  PSID    *rgDomainSids,
    IN  ULONG   cEnterpriseSids,
    IN  PSID    *rgEnterpriseSids,
    OUT BOOLEAN * WellKnownSid,
    OUT BOOLEAN * BuiltinDomainSid,
    OUT BOOLEAN * LocalSid,
    OUT BOOLEAN * ForeignSid,
    OUT BOOLEAN * EnterpriseSid
    )
/*++

    Routine Description

        Check the Sid and find out wether it is a candidate for a local Sid,
        a foriegn Sid or a candidate for  the G.C

    Parameters:

        Sid  - The Sid to be checked out

        cDomainSids - The count of domain Sids,that represent the 
                      domains hosted locally 

        rgDomainSids - The array of domain Sids of the domains that 
                       are hosted locally 

        WellKnownSid - TRUE indicates that the Sid is a well known Sid
                       e.g EveryOne

        BuiltinDomainSid - TRUE indicates that the SID is from the builtin 
                       domain, e.g Administrators

        LocalSid     - TRUE indicates that the Sid is a Sid that is from a 
                       domain that is hosted on this DC. 
                   
        ForiegnSid   - TRUE indicates that the Sid is not from a domain that is
                       not in the forest.
 
        EnterpriseSid - TRUE indicates that the SId belongs to a domain that is
                       in the forest

    Return Values:

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       i;
    PSID        DomainPrefix=NULL;


  //
  //  Initialize Return Values
  //

  *WellKnownSid = FALSE;
  *BuiltinDomainSid = FALSE;
  *LocalSid = FALSE;
  *ForeignSid = FALSE;
  *EnterpriseSid = FALSE;

  //
  //  Validate the Sid
  //

  if ((NULL==Sid) || (!(RtlValidSid(Sid)))
      || ((RtlLengthSid(Sid))>sizeof(NT4SID)))
  {
      NtStatus = STATUS_INVALID_PARAMETER;
      goto Error;
  }

  //
  //  Check for well known Sids
  //

  if (SampIsWellKnownSid(Sid))
  {
      //
      // Well known Sid.
      //

      *WellKnownSid = TRUE;
  }
  else if (SampIsMemberOfBuiltinDomain(Sid))
  {
      //
      // Builtin Domain SID
      //
      *BuiltinDomainSid = TRUE;
  }
  else
  {

      ULONG Rid;

      //
      // Get the Domain Prefix
      //

      NtStatus = SampSplitSid(
                    Sid,
                    &DomainPrefix,
                    &Rid
                    );
      if (!NT_SUCCESS(NtStatus))
      {
          goto Error;
      }

      //
      // Compare the Domain Prefixes
      //

      //
      // Check for local Sid
      //

      for (i=0;i<cDomainSids;i++)
      {
          if ((RtlEqualSid(DomainPrefix,rgDomainSids[i])) ||
               (RtlEqualSid(Sid,rgDomainSids[i])))
          {
              *LocalSid = TRUE;
              break;
          }
      }


      if (!(*LocalSid))
      {
          //
          // Check for Enterprise Sid
          //

          for (i=0;i<cEnterpriseSids;i++)
          {
              if ((RtlEqualSid(DomainPrefix,rgEnterpriseSids[i]))||
                  (RtlEqualSid(Sid,rgEnterpriseSids[i])))
              {
                  *EnterpriseSid = TRUE;
                  break;
              }
          }

        if (!(*EnterpriseSid))
        {
            *ForeignSid = TRUE;
        }
      }
  }

Error:

      if  (DomainPrefix)
      {
          MIDL_user_free(DomainPrefix);
          DomainPrefix = NULL;
      }

      return NtStatus;
}


NTSTATUS
SampDsResolveSidsForDsUpgrade(
    IN  PSID    DomainSid,
    IN  PSID    * rgSids,
    IN  ULONG   cSids,
    IN  ULONG   Flags,
    OUT DSNAME  ***rgDsNames
    )
/*++

    This is the flavour of Resolve Sids for DS upgrade. In the upgrade case
    all Sids not in the DS are treated as Foriegn Security Principals. This simplifies
    the upgrade process and does not require the availability of a G.C in order to perform
    the upgrade itself.

    Parameters:

        DomainSid -- The Sid of the domain that we are upgrading. Will be passed down to the
        SampCheckSidType to figure out wether the passed in Sid is belongs to the domain.

        rgSids    -- The set of Sids that we want to resolve.
        cSids     -- Number of Sids for above.
        Flags     -- Flags to be passed in for rgDsNames
        rgDsNames -- Array of DsNames.

    Return Values:

       STATUS_SUCCESS
       Other Error codes from SampResolveSidsWorker

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;


    NtStatus = SampDsBuildRootObjectName();
    if ( !NT_SUCCESS( NtStatus ) )
    {
        return NtStatus;
    }

    return ( SampDsResolveSidsWorker(
                rgSids,
                cSids,
                &DomainSid,
                1,
                NULL,
                0,
                Flags|RESOLVE_SIDS_SID_ONLY_DOMAIN_SIDS_OK,
                rgDsNames));
}


const SID_IDENTIFIER_AUTHORITY    WellKnownIdentifierAuthorities[] = {
                                    SECURITY_NULL_SID_AUTHORITY,
                                    SECURITY_WORLD_SID_AUTHORITY,
                                    SECURITY_LOCAL_SID_AUTHORITY,
                                    SECURITY_CREATOR_SID_AUTHORITY,
                                    SECURITY_NON_UNIQUE_AUTHORITY
                                 };


BOOLEAN SampIsWellKnownSid(
    IN PSID Sid
    )
/*++

  Routine Description

    This function checks to see if a Sid is a well known SID.

  Parameters:

        Sid  -- Sid to be checked out

  Return Values:


    TRUE if well known Sid
    FALSE if not

--*/
{

    BOOLEAN     RetValue = FALSE;
    PSID_IDENTIFIER_AUTHORITY   SidIdentifierAuthority;
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    ULONG   Index, 
            i = 0, 
            SubAuthCount = 0,
            FirstSubAuth = 0;


    
    SidIdentifierAuthority = RtlIdentifierAuthoritySid(Sid);

    for (Index=0;
            Index< ARRAY_COUNT(WellKnownIdentifierAuthorities);
                Index++)
    {
        if ((memcmp(
                &(WellKnownIdentifierAuthorities[Index]),
                SidIdentifierAuthority,
                sizeof(SID_IDENTIFIER_AUTHORITY)))==0)
        {
            RetValue = TRUE;
            break;
        }
        else if (memcmp(&NtAuthority, 
                        SidIdentifierAuthority,
                        sizeof(SID_IDENTIFIER_AUTHORITY)
                        ) == 0
                )
        {
            // SID belongs to Nt Authority
            SubAuthCount = *RtlSubAuthorityCountSid(Sid);

            if (SubAuthCount == 0)
            {
                // ONLY NT Authority SID has no sub auth's
                RetValue = TRUE;
            }
            else
            {

                //
                // Any Sid within builtin domain and account domain 
                // are not considered as well known SID in this routine,
                // because there is a real object in the backing store.
                //
                // For example  Builtin Domain itself, 
                //              Administrators Alias, 
                //              Domain Users Group are NOT well known here
                // 
                // Only those SIDs, which there is no real object to present 
                // them, are considered Well Known in SAM.
                //      
                // For Example  Anonymous Logon SID
                //              Dialup SID
                //              Network Service SID are well known SIDs. 
                // 

                FirstSubAuth = *RtlSubAuthoritySid(Sid, 0);

                if ((FirstSubAuth != SECURITY_BUILTIN_DOMAIN_RID) &&
                    (FirstSubAuth != SECURITY_NT_NON_UNIQUE))
                {
                    RetValue = TRUE;
                }
            }

            break;
        }
    }

    return RetValue;

}

NTSTATUS
SampDsGetSensitiveSidList(
    IN DSNAME *DomainObjectName,
    IN PULONG pcSensSids,
    IN PSID   **pSensSids
        )
/*++

    Routine Description:

        This routine retrieves the set of sensitive Sids given the name of
        the domain object.

    Parameters:

       DomainObjectName -- DS Name of the domain object
       pcSensSids       -- The count of Sids
       pSensSids        -- The List of sensitive Sids.

    Return Values:

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    //
    //
    // Today the list is hard coded to ADMINISTRATORS till
    // there is final decision on how this will be represented
    //

    *pcSensSids = 1;
    *pSensSids = ADMINISTRATOR_SID;
    return NtStatus;

}

BOOLEAN
SampCurrentThreadOwnsLock(
    VOID
    )
/*++

  Routine Description

        Tests wether the current thread owns the lock

--*/
{
    ULONG_PTR ExclusiveOwnerThread = (ULONG_PTR) SampLock.ExclusiveOwnerThread;
    ULONG_PTR CurrentThread = (ULONG_PTR) (NtCurrentTeb())->ClientId.UniqueThread;

    if ((SampLock.NumberOfActive <0) && (ExclusiveOwnerThread==CurrentThread))
        return TRUE;

    return FALSE;
}



NTSTATUS
SampDsExamineSid(
    IN PSID Sid,
    OUT BOOLEAN * WellKnownSid,
    OUT BOOLEAN * BuiltinDomainSid,
    OUT BOOLEAN * LocalSid,
    OUT BOOLEAN * ForeignSid,
    OUT BOOLEAN * EnterpriseSid
    )
/*++

    Routine Description

        Given a SID crack it to see what it represents

    Parameters:

        Sid the Sid
        WellKnownSid  -- The sid represents a security prinicipal like "EveryOne"
        LocalSid      -- Belongs to a domain that we host locally
        ForeignSid    -- Belongs to a domain unknown to the enterprise
        EnterpriseSid -- Belongs to a domain that is known to the enterprise but
                         not known to use
    Return Values

        Any resource failures
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSID        *rgDomainSids = NULL;
    PSID        *rgEnterpriseSids = NULL;
    ULONG       cDomainSids=0;
    ULONG       cEnterpriseSids=0;

    //
    // Get the list of domain sids that we know about
    //

    NtStatus = SampGetDomainSidListForSam(
                &cDomainSids,
                &rgDomainSids,
                &cEnterpriseSids,
                &rgEnterpriseSids
                );

    if (!NT_SUCCESS(NtStatus))
     goto Error;

    //
    // Check the SID type
    //

    NtStatus = SampDsCheckSidType(
                Sid,
                cDomainSids,
                rgDomainSids,
                cEnterpriseSids,
                rgEnterpriseSids,
                WellKnownSid,
                BuiltinDomainSid,
                LocalSid,
                ForeignSid,
                EnterpriseSid
                );

Error:

    if (NULL!=rgDomainSids)
        MIDL_user_free(rgDomainSids);

    if (NULL!=rgEnterpriseSids)
        MIDL_user_free(rgEnterpriseSids);

    return NtStatus;
}

NTSTATUS
SampGetDomainSidListForSam(
    PULONG pcDomainSids,
    PSID   **rgDomainSids,
    PULONG pcEnterpriseSids,
    PSID   **rgEnterpriseSids
   )
/*++

    This routine obtains the List of Domain Sids for the domains hosted
    in this DC, by SAM. It also obtains the list of Sids for all the domains
    in the enterprise.

    Parameters

        pcDomainSids     -- Number of DomainSids is returned in here
        rgDomainSids     -- the Domain Sids themselves are returned in here.
        pcEnterpriseSids -- The Count of the domains in the enterprise minus the
                            domains hosted in here.
        rgEnterpriseSids -- The list of domain Sids of all the domains in the enterprise
                            This includes the Domain Sids of the domains hosted in this
                            domain controller also, but the domains check is applied
                            first.

   Return Values:

    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOURCES
--*/
{

    ULONG i;
    ULONG DomainStart;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN  fLockAcquired = FALSE;



    DomainStart   = SampDsGetPrimaryDomainStart();
    *pcDomainSids = SampDefinedDomainsCount - DomainStart;
    *rgDomainSids = MIDL_user_allocate((*pcDomainSids) * sizeof(PSID));
    if (NULL==*rgDomainSids)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    //
    // Acquire the SAM lock before accessing globals. Do not
    // recursively acquire the lock
    //

    if (!SampCurrentThreadOwnsLock())
    {
        SampAcquireSamLockExclusive();
        fLockAcquired = TRUE;
    }

    //
    // Loop through defined domains array
    //

    for (i=0;i<*pcDomainSids;i++)
    {

        (*rgDomainSids)[i] = SampDefinedDomains[i+DomainStart].Sid;
    }

    //
    // Release the lock as soon as possible. We no longer need it
    //

    if (fLockAcquired)
    {
        SampReleaseSamLockExclusive();
        fLockAcquired = FALSE;
    }


    //
    // Query Number of Enterprise Sids
    //

    SampGetEnterpriseSidList(pcEnterpriseSids, NULL);

    if (*pcEnterpriseSids > 0)
    {
        //
        // Allocate memory for the Enterprise Sid Buffer
        //

        *rgEnterpriseSids = MIDL_user_allocate(*pcEnterpriseSids * sizeof(PSID));
        if (NULL==*rgEnterpriseSids)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Get the Sids
        //

        SampGetEnterpriseSidList(pcEnterpriseSids,*rgEnterpriseSids);


    }


Error:

    if (!NT_SUCCESS(NtStatus))
    {
        if (NULL!=*rgDomainSids)
        {
            MIDL_user_free(*rgDomainSids);
            *rgDomainSids = NULL;
        }

        if (NULL!=*rgEnterpriseSids)
        {
            MIDL_user_free(*rgEnterpriseSids);
            *rgEnterpriseSids = NULL;
        }
    }

    if (fLockAcquired)
    {
        SampReleaseSamLockExclusive();
        fLockAcquired = FALSE;
    }

    return NtStatus;
}

NTSTATUS
SampDsResolveSids(
    IN  PSID    * rgSids,
    IN  ULONG   cSids,
    IN  ULONG   Flags,
    OUT DSNAME  ***rgDsNames
    )
/*++

    This is the Resolve Sids routine that is called from SAM. This routine calls the
    worker routine after some preprocessing.

  Parameters:

        rgSids -- The array of Sids that need to be passed in.
        cSids  -- The count of Sids
        Flags  -- Used to control the operation of the routine

                    RESOLVE_SIDS_ADD_FORIEGN_SECURITY_PRINCIPAL
                    -- Automatically Adds the foreign domain security principal to the DS.
                    
                    RESOLVE_SIDS_FAIL_WELLKNOWN_SIDS
                    -- Fails the call if well known Sids are present in the array

                    RESOLVE_SIDS_VALIDATE_AGAINST_GC
                    -- Goes to the G.C if required

        rgDsNames -- Will MIDL_user alloc an array of DS Names back to the caller. Caller
                     is responsible for freeing them

    Return Values:

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL


    WARNING -- This Routine must be called with no Locks Held. Further this routine should not be
    called from the loopback case. The loopback call does its own validation ( GC / shim lookup )
    Further no open transaction must exist when DsResolveSids is called.

    It might seem unusual that this routine is called in the registry case also. The reason is that
    there should be no locks and no open transactions, while calling this routine and to ensure that
    the safest thing to do is to make it the first call in a Samr* call. This will cause this routine
    to be executed in the registry case also, but in reality this is a no Op in the registry case

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSID        *rgDomainSids = NULL;
    PSID        *rgEnterpriseSids = NULL;
    ULONG       cDomainSids;
    ULONG       cEnterpriseSids;
    DSNAME      *pLoopBackObject;


    //
    // Increment Active Thread Count. This routine Makes Ds Calls
    // without
    //

    NtStatus = SampIncrementActiveThreads();
    if (!NT_SUCCESS(NtStatus))
        return NtStatus;


    //
    // Check if are ds Case
    //

    if (SampUseDsData)
    {
        ASSERT(!SampCurrentThreadOwnsLock());
        ASSERT(!SampExistsDsTransaction());
        ASSERT(!SampExistsDsLoopback(&pLoopBackObject));

        if (Flags & RESOLVE_SIDS_SID_ONLY_NAMES_OK)
        {
            rgDomainSids = NULL;
            cDomainSids  = 0;
            rgEnterpriseSids = NULL;
            cEnterpriseSids = 0;
        }
        else
        {
             NtStatus = SampGetDomainSidListForSam(
                            &cDomainSids,
                            &rgDomainSids,
                            &cEnterpriseSids,
                            &rgEnterpriseSids
                            );
        }

        if (NT_SUCCESS(NtStatus))
        {


                NtStatus = SampDsResolveSidsWorker(
                            rgSids,
                            cSids,
                            rgDomainSids,
                            cDomainSids,
                            rgEnterpriseSids,
                            cEnterpriseSids,
                            Flags,
                            rgDsNames
                            );

        }
    }

    //
    // Free the array of Sids.
    //

    if (NULL!=rgDomainSids)
        MIDL_user_free(rgDomainSids);
    if (NULL!=rgEnterpriseSids)
        MIDL_user_free(rgEnterpriseSids);

    SampDecrementActiveThreads();

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dslayer.c ===
/*++

Copyright (C) 1996 Microsoft Corporation

Module Name:

    dslayer.c

Abstract:

    Contains SAM Private API Routines to access the DS
    These provide a simplified API, and hide most of the
    underlying complexity to set up the parameters to a DS call
    and parse the resulting result.

Author:
    MURLIS

Revision History

    5-14-96   Murlis Created
    08-07-96  ColinBr Adjusted for RFC1779 naming change
    04-13-98  Murlis/Wlees Mark well known user objects as critical for
              installation
--*/

#include <winerror.h>
#include <stdlib.h>
#include <samsrvp.h>
#include <ntdsa.h>
#include <dslayer.h>
#include <sdconvrt.h>
#include <mappings.h>
#include <objids.h>
#include <filtypes.h>
#include <dsdsply.h>
#include <fileno.h>
#include <dsconfig.h>
#include <mdlocal.h>
#include <malloc.h>
#include <errno.h>
#include <mdcodes.h>

//
//  Define FILENO for SAM
//


#define FILENO FILENO_SAM

//++
//++
//++   IMPORTANT NOTE REGARDING SID's and RID's
//++
//++   The DS can choose to either store the entire SID's or only
//++   the Rid's for account objects. In case Entire SID's are stored
//++   the DS layer handles the Mapping between the attribute type and
//++   and value of SID and those of Rid for account objects. This is
//++   done within SampDsToSamAttrBlock and SampSamToDsAttrBlock.
//++
//++
//++   Irrespective of which way we go the Rid and Sid are both
//++   attributes defined in the schema.
//++
//++   If we go the way the of storing Sid's then the DS functions
//++   should call the Convert AttrBlock functions using the MAP_SID_RID
//++   conversion Flag, and Lookup Object By Rid, should actually use
//++   the Sid Attribute.
//++
//++


//
// Forward declarations of Private Samp Routines used in this file only
//

NTSTATUS
SampDsSetNewSidAttribute(
    IN PSID DomainSid,
    IN ULONG ConversionFlags,
    IN ATTR *RidAttr,
    IN OUT ATTR *SidAttr,
    OUT BOOLEAN *WellKnownAccount
    );

NTSTATUS
SampDsCopyAttributeValue(
    IN ATTR * Src,
    IN OUT ATTR * Dst
    );

NTSTATUS
SampEscapeAccountName(
    IN PUNICODE_STRING AccountName,
    IN OUT PUNICODE_STRING EscapedAccountName
    );

VOID
SampDsComputeObjectClassAndAccountType(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG            *SamAccountControl, OPTIONAL
    IN ULONG            Flags,
    IN ULONG            GroupType,
    OUT PULONG           DsClass,
    OUT PULONG           SamAccountType,
    OUT BOOLEAN          *SamAccountTypePresent,
    OUT BOOLEAN          *DcAccount
    );

VOID
SampDsAccountTypeFromUserAccountControl(
    ULONG   UserAccountControl,
    PULONG  SamAccountType
    );

ULONG
Ownstrlen(
    CHAR * Sz
   );

BOOLEAN
SampDefaultContainerExists(
    IN ULONG AccountControl
    );

VOID
BuildStdCommArg(
    IN OUT COMMARG * pCommArg
    )
/*++

  Routine Description:

    Fills a COMMARG structue with the standard set of options

  Arguments:
    pCommArg - Pointer to the COMMARG structure

  Return Values:
    None

--*/
{
    /* Get the default values... */
    InitCommarg(pCommArg);

    /* ...and override some of them */
    pCommArg->Svccntl.DerefAliasFlag = DA_NEVER;
    pCommArg->ulSizeLimit = SAMP_DS_SIZE_LIMIT;
    pCommArg->Svccntl.localScope = TRUE;
    pCommArg->fFindSidWithinNc = TRUE;
}



NTSTATUS
SampDsInitialize(
    BOOL fSamLoopback)

/*++

Routine Description:

   Initializes the DS system
   starts up DS.

Arguments:

   fSamLoopback - indicates whether or not DSA.DLL should loop security
        principal calls back through SAM.

Return Values:
        Any values from DsInitialize
--*/
{
    NTSTATUS    Status;
    ULONG       DsInitFlags = 0;

    SAMTRACE("SampDsInitialize");

    ASSERT(SampDsInitialized==FALSE);

    if ( fSamLoopback )
    {
        DsInitFlags |= DSINIT_SAMLOOP_BACK;
    }

    // Start up the DS
    Status = DsInitialize( DsInitFlags ,NULL, NULL );


    // This global variable indicates to SAM routines that
    // the DS initialized.  This routine is called during startup
    // so there should only one thread that ever calls this routine
    // The above assert assures that this function is only called
    // when the the ds has not been started or has been uninitialized
    // in the case of installation.
    if (NT_SUCCESS(Status)) {

        SampDsInitialized = TRUE;

    }
    else
    {
        //
        // In the case of DS failure, and returned us meaningless
        // status code, change it to STATUS_DS_CANT_START
        //
        if (STATUS_UNSUCCESSFUL == Status)
        {
            Status = STATUS_DS_CANT_START;
        }

        //
        // Set the Flag to TRUE, so that later on (in SamIInitialize),
        // we will display the matching error message, which would
        // correctly describe which part is wrong.
        //
        SampDsInitializationFailed = TRUE;
    }

    return Status;
}

NTSTATUS
SampDsUninitialize()

/*++

Routine Description

   Initiates a clean shut down of the DS

Arguments:
                None
Return codes:
                Any returned by DSUninitialize

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    SAMTRACE("SampDsUninitialize");

    if (SampDsInitialized)
    {
        Status = DsUninitialize( FALSE );  // do the full shutdown

        SampDsInitialized = FALSE;
    }

    return Status;
}


NTSTATUS
SampDoImplicitTransactionStart(
        SAMP_DS_TRANSACTION_CONTROL LocalTransactionType
        )
/*++

  Routine Description

    This routine does the logic of implict transaction start.


  Parameters

    LocalTransactionType -- The transaction type required by the immediate caller

  Return Values

     Any errors returned by SampMaybeBeginDsTransaction

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    //
    // We follow the following rules while beginning a transaction implicitly
    //
    // 1. If caller owns the sam lock, then we begin a transaction described in
    //    the global variable SampDsTransactionType. AcquireReadLock will set
    //    TransactionRead and AcquireWriteLock will set TransactionWrite. This
    //    will take care of cases where we want to write, but start by reading.
    //
    // 2. If caller does not owm the sam lock then begin a transaction of the
    //    local transaction type. The caller then has the responsiblity of
    //    either starting with a call that will ensure the correct transaction
    //    type, or explicitly begin a transaction of the correct transaction
    //    type.
    //

    if (SampCurrentThreadOwnsLock())
    {

        //
        // If we are holding the Sam lock
        //

        NtStatus = SampMaybeBeginDsTransaction(SampDsTransactionType);
    }
    else
    {
        NtStatus = SampMaybeBeginDsTransaction(LocalTransactionType);
    }

    return NtStatus;
}


NTSTATUS
SampDsRead(
    IN DSNAME * Object,
    IN ULONG    Flags,
    IN  SAMP_OBJECT_TYPE ObjectType,
    IN ATTRBLOCK * AttributesToRead,
    OUT ATTRBLOCK * AttributeValues
)

/*++

Routine Description:

 Read attributes of an object from the DS

Argumants:
        Object                          -- Pointer to Dist Name, which sepcifies object to read
        Flags                           -- To control operation of routine
        ObjectType              -- Specifies the type of the object
        AttributesToRead        -- Specfies the attributes to read
        AttributeValues         -- Returned value of the attributes

  Return Values:

    STATUS_SUCCESS on successful completion
    DS return codes mapped to NT_STATUS as in SampMapDSErrorToNTStatus

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ENTINFSEL   EntInf;
    READARG     ReadArg;
    COMMARG     *pCommArg;
    ULONG       RetValue;
    READRES     * pReadRes=NULL;
    ATTRBLOCK   *AttrBlockForDs, * ConvertedAttrBlock;

    SAMTRACE("SampDsRead");


    //
    // Asserts and parameter validation
    //

    ASSERT(Object!=NULL);
    ASSERT(AttributesToRead!=NULL);
    ASSERT(AttributeValues != NULL);
    ASSERT(AttributesToRead->attrCount > 0);

    //
    // Perform lazy thread and transaction initialization.
    //

    Status = SampDoImplicitTransactionStart(TransactionRead);

    if (Status!= STATUS_SUCCESS)
        goto Error;

    //
    // Translate the attribute types in Attrblock to map between
    // SAM and DS attributes.
    //

    //
    // First allocate space in stack for the Attrblock to be passed
    // down into the DS
    //

    SAMP_ALLOCA(EntInf.AttrTypBlock.pAttr,AttributesToRead->attrCount*sizeof(ATTR));

    if (NULL==EntInf.AttrTypBlock.pAttr)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    Status = SampSamToDsAttrBlock(
                ObjectType,                     // Object Type
                AttributesToRead,               // Attributes To Convert
                ( MAP_RID_TO_SID
                  | IGNORE_GROUP_UNUSED_ATTR ), // Conversion Flags
                NULL,                           // Domain Sid
                &(EntInf.AttrTypBlock)
                );

    if (!NT_SUCCESS(Status))
    {
        goto Error;
    }

    //
    // Setup up the ENTINFSEL structure
    //

    EntInf.attSel = EN_ATTSET_LIST;
    //EntInf.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntInf.infoTypes = EN_INFOTYPES_SHORTNAMES;

    //
    // init ReadArg
    //
    RtlZeroMemory(&ReadArg, sizeof(READARG));


    //
    // Build the commarg structure
    //

    pCommArg = &(ReadArg.CommArg);
    BuildStdCommArg(pCommArg);

    if (Flags & SAM_ALLOW_REORDER)
    {
        pCommArg->Svccntl.fMaintainSelOrder = FALSE;
        pCommArg->Svccntl.fDontOptimizeSel = FALSE;
    }

    //
    // Setup the Read Arg Structure
    //

    ReadArg.pObject = Object;
    ReadArg.pSel    = & EntInf;

    //
    // Make the DS call
    //

    SAMTRACE_DS("DirRead");

    RetValue = DirRead(& ReadArg, & pReadRes);

    SAMTRACE_RETURN_CODE_DS(RetValue);

    //
    // Map the RetValue to a NT Status code
    //

    if (NULL==pReadRes)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        Status = SampMapDsErrorToNTStatus(RetValue,&pReadRes->CommRes);
    }

    if (Status!= STATUS_SUCCESS)
        goto Error;

    //
    // Translate attribute types back from DS to SAM
    //

    Status = SampDsToSamAttrBlock(
        ObjectType,
        &(pReadRes->entry.AttrBlock),
        ( MAP_SID_TO_RID ),
        AttributeValues
        );

    if (Status != STATUS_SUCCESS)
        goto Error;



Error:

    //
    // Clear any errors
    //

    SampClearErrors();

    //
    // Turn the fDSA flag back on as in loopback cases this can get reset
    //
    SampSetDsa(TRUE);


    return Status;
}


NTSTATUS
SampDsSetAttributes(
    IN DSNAME * Object,
    IN ULONG  Flags,
    IN ULONG  Operation,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ATTRBLOCK * AttributeList
    )
{
    ULONG *Operations;
    ULONG i;

    SAMP_ALLOCA(Operations,AttributeList->attrCount*sizeof(ULONG));
    if (NULL==Operations)
    {
       return(STATUS_INSUFFICIENT_RESOURCES);
    }
    for (i = 0; i < AttributeList->attrCount; i++) {
        Operations[i] = Operation;
    }

    return SampDsSetAttributesEx(Object,
                                 Flags,
                                 Operations,
                                 ObjectType,
                                 AttributeList);


}

NTSTATUS
SampDsSetAttributesEx(
    IN DSNAME * Object,
    IN ULONG  Flags,
    IN ULONG  *Operations,
    IN  SAMP_OBJECT_TYPE ObjectType,
    IN ATTRBLOCK * AttributeList
)

/*++

Routine Description:

  Set an Object's attributes

Arguments:

      Object         Specifies the DS Object

      Flags          Controls Operation of Routine

                        ALREADY_MAPPED_ATTRIBUTE_TYPES

                         - Attribute types have been mapped from SAM attribute
                           to DS attribute already. so not not map again.

      Operation      Specifies operation to perform

                     Valid Values of Operation are

                        REPLACE_ATT
                        ADD_ATT
                        REMOVE_ATT
                        ADD_VALUE
                        REMOVE_VALUE

      ObjectType     SAM Object Type for attribute Type conversion

      AttributeList  Specifies the attributes to Modify

Return Values:

      STATUS_SUCCESS on succesful completion
      STATUS_NO_MEMORY - if failed to allocate memory
      DS return codes mapped to NT_STATUS as in SampMapDSErrorToNTStatus


--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ATTRMODLIST * AttrModList = NULL;
    MODIFYARG   ModifyArg;
    MODIFYRES   *pModifyRes = NULL;
    ATTRMODLIST * CurrentMod, * NextMod, *LastMod;
    ULONG       Index;
    COMMARG     *pCommArg;
    ULONG       RetValue;
    UCHAR       Choice;
    ULONG       ModCount = 0;


    SAMTRACE("SampDsSetAttributes");

    //
    // Asserts and parameter validation
    //

    ASSERT(Object!=NULL);
    ASSERT(AttributeList != NULL);
    ASSERT(AttributeList->attrCount > 0);

    // Perform lazy thread and transaction initialization.
    Status = SampDoImplicitTransactionStart(TransactionWrite);

    if (Status!= STATUS_SUCCESS)
        goto Error;


    //
    // Allocate enough memory in AttrModList to hold the contents of
    // AttrBlock. First such structure is specified in ModifyArg itself.
    // One additonal structure is allocated so that we can add SAM account
    // type if necessary
    //

    AttrModList = (ATTRMODLIST *)  DSAlloc(
                                        (AttributeList->attrCount-1+2)
                                        // -1 because first structure is in ModifyArg itself
                                        // +1 in case we need to add Sam Account type
                                        // +1 in case we need to add is critical system object
                                        * sizeof(ATTRMODLIST)
                                        );
    if (AttrModList==NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto Error;

    }

    //
    // Initialize the Linked Attribute Modification List
    // required for the DS call
    //

    memset( &ModifyArg, 0, sizeof( ModifyArg ) );
    CurrentMod = &(ModifyArg.FirstMod);
    NextMod    = AttrModList;
    LastMod    = NULL;

    for (Index = 0; Index < AttributeList->attrCount; Index++)
    {
        ULONG DsAttrTyp;

        //
        // Setup our Choice
        //
    
        if (Operations[Index] == ADD_VALUE)
            Choice = AT_CHOICE_ADD_VALUES;
    
        else if (Operations[Index] == REMOVE_VALUE)
            Choice = AT_CHOICE_REMOVE_VALUES;
    
        else if (Operations[Index] == REMOVE_ATT)
            Choice = AT_CHOICE_REMOVE_ATT;
    
        else if (Operations[Index] == REPLACE_ATT)
            Choice = AT_CHOICE_REPLACE_ATT;
    
        else
            Choice = AT_CHOICE_REPLACE_ATT;
    
        //
        // MAP the attribute Type from SAM to DS if requested.
        //
        if (Flags & ALREADY_MAPPED_ATTRIBUTE_TYPES)
        {
            DsAttrTyp = AttributeList->pAttr[Index].attrTyp;
        }
        else
        {
            DsAttrTyp = SampDsAttrFromSamAttr(
                            ObjectType,
                            AttributeList->pAttr[Index].attrTyp
                            );
        }

        //
        // Skip over any Rid Attribute
        //
        if (DsAttrTyp == SampDsAttrFromSamAttr(
                            SampUnknownObjectType,
                            SAMP_UNKNOWN_OBJECTRID
                           ))
        {

            //
            // We will not allow modifications of Rid's
            //

            continue;
        }


        //
        // Setup the Choice
        //

        CurrentMod->choice = Choice;

        //
        // Copy over the ATTR Type
        //
        CurrentMod->AttrInf.attrTyp = DsAttrTyp;

        //
        // Copy Over the Attribute Value
        //

        Status = SampDsCopyAttributeValue(
                     &(AttributeList->pAttr[Index]),
                     &(CurrentMod->AttrInf)
                     );

        if (Status != STATUS_SUCCESS)
            goto Error;

        //
        // If the current attribute is User account control
        // and if we are replacing the attribute then
        // translate the user account control field to UF_Flags and
        // recompute the SAM account type property.
        //

        if (
               (SampUserObjectType==ObjectType)
            && (DsAttrTyp == SampDsAttrFromSamAttr(
                                SampUserObjectType,
                            SAMP_FIXED_USER_ACCOUNT_CONTROL))
            && (REPLACE_ATT==Operations[Index])
           )
        {
            ULONG   UserAccountControl = *((ULONG *)CurrentMod->AttrInf.AttrVal.pAVal->pVal);
            ULONG   SamAccountType;
            ATTR    SamAccountTypeAttr;
            ATTRVAL SamAccountTypeVal = {sizeof(ULONG),(UCHAR*) &SamAccountType};

            //
            // Ensure we don't write the computed bits
            //
            ASSERT((UserAccountControl & USER_COMPUTED_ACCOUNT_CONTROL_BITS) == 0);
    

            //
            // Translate User Account Control to UF_ Flags
            //

            *((ULONG *)CurrentMod->AttrInf.AttrVal.pAVal->pVal) =
                        SampAccountControlToFlags(UserAccountControl);

            //
            // Get the SamAccount Type Value
            //

            SampDsAccountTypeFromUserAccountControl(
                    UserAccountControl,
                    &SamAccountType
                    );

            SamAccountTypeAttr.attrTyp =  SampDsAttrFromSamAttr(
                                                SampUnknownObjectType,
                                                SAMP_UNKNOWN_ACCOUNT_TYPE
                                                );
            SamAccountTypeAttr.AttrVal.valCount = 1;
            SamAccountTypeAttr.AttrVal.pAVal = &SamAccountTypeVal;


            //
            // Get the next Attrinf Block
            //

            LastMod = CurrentMod;
            CurrentMod->pNextMod = NextMod;
            CurrentMod = CurrentMod->pNextMod;
            NextMod    = NextMod +1 ;
            ModCount++;

            //
            // Set it up to hold the SAM Account type property
            //

            CurrentMod->choice = Choice;
            CurrentMod->AttrInf.attrTyp = SamAccountTypeAttr.attrTyp;
            Status = SampDsCopyAttributeValue(
                     &SamAccountTypeAttr,
                     &(CurrentMod->AttrInf)
                     );

            if (Status != STATUS_SUCCESS)
                goto Error;

            // If changing the machine account type, update criticality
            if( UserAccountControl & USER_MACHINE_ACCOUNT_MASK ) {
                ULONG   IsCrit;
                ATTR    IsCritAttr;
                ATTRVAL IsCritVal = {sizeof(ULONG),(UCHAR*) &IsCrit};

                // Only server and interdomain trust accounts should be crit
                if ( (UserAccountControl & USER_SERVER_TRUST_ACCOUNT) ||
                     (UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) ) {
                    IsCrit = 1;
                } else {
                    IsCrit = 0;
                }

                IsCritAttr.attrTyp = ATT_IS_CRITICAL_SYSTEM_OBJECT;
                IsCritAttr.AttrVal.valCount = 1;
                IsCritAttr.AttrVal.pAVal = &IsCritVal;

                //
                // Get the next Attrinf Block
                //

                LastMod = CurrentMod;
                CurrentMod->pNextMod = NextMod;
                CurrentMod = CurrentMod->pNextMod;
                NextMod    = NextMod +1 ;
                ModCount++;

                //
                // Set it up to hold the is critical property
                //

                CurrentMod->choice = Choice;
                CurrentMod->AttrInf.attrTyp = IsCritAttr.attrTyp;
                Status = SampDsCopyAttributeValue(
                    &IsCritAttr,
                    &(CurrentMod->AttrInf)
                    );

                if (Status != STATUS_SUCCESS)
                    goto Error;
            }
        }

        //
        // Setup the chaining. AttrModList is suposed to be a linked list, though
        // for effciency purposes we allocated a single block
        //

        LastMod = CurrentMod;
        CurrentMod->pNextMod = NextMod;
        CurrentMod = CurrentMod->pNextMod;
        NextMod    = NextMod +1 ;

        //
        //  Keep track of Count of Modifications we pass to DS, as we skip over RId etc
        //
        ModCount++;

    }

    //
    // Initialize the last pointer in the chain to NULL
    //

    if (LastMod)
        LastMod->pNextMod = NULL;
    else

    {
        //
        // This Means we have nothing to modify
        //

        Status = STATUS_SUCCESS;
        goto Error;
    }



    //
    // Setup the Common Args structure
    //

    pCommArg = &(ModifyArg.CommArg);
    BuildStdCommArg(pCommArg);

    //
    // Enable Lazy Commit if caller requested it.
    //

    if (Flags & SAM_LAZY_COMMIT)
        pCommArg->fLazyCommit = TRUE;

    //
    // Urgently replicate the change if necessary
    //
    if ( Flags & SAM_URGENT_REPLICATION )
    {
        pCommArg->Svccntl.fUrgentReplication = TRUE;
    }


    //
    // Specify to allow FPO creation on intra forest object
    //
    if ( Flags & SAM_ALLOW_INTRAFOREST_FPO ) {

        pCommArg->Svccntl.fAllowIntraForestFPO = TRUE;
    }



    //
    // Setup the MODIFY ARG structure
    //

    ModifyArg.pObject = Object;
    ModifyArg.count = (USHORT) ModCount;

    //
    // Make the DS call
    //

    SAMTRACE_DS("DirModifyEntry\n");

    RetValue = DirModifyEntry(&ModifyArg, &pModifyRes);

    SAMTRACE_RETURN_CODE_DS(RetValue);

    //
    // Map the return code to an NT status
    //

    if (NULL==pModifyRes)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        Status = SampMapDsErrorToNTStatus(RetValue,&pModifyRes->CommRes);
    }

Error:

    //
    // Clear any errors
    //

    SampClearErrors();

    //
    // Turn the fDSA flag back on as in loopback cases this can get reset
    //

    SampSetDsa(TRUE);


    return Status;
}

NTSTATUS
SampDsCreateInitialAccountObject(
    IN   PSAMP_OBJECT    Object,
    IN   ULONG           Flags,
    IN   ULONG           AccountRid,
    IN   PUNICODE_STRING AccountName,
    IN   PSID            CreatorSid OPTIONAL,
    IN   PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN   PULONG          UserAccountControl OPTIONAL,
    IN   PULONG          GroupType OPTIONAL
    )
/*++

  Routine Description:

    Creates an account object in the DS having only the Sid,
    Account Name , and a few special attributes like, security
    descriptor, User account control Field etc

  Arguments:

    Object                  the object of the account being created
    Flags                   Controls the operation of the routine

    AccountRid              the rid of the account
    AccountName             Name of the Account

    CreatorSid              Pointer to SID the value of ms-ds-CreatorSid
                            attribute

    SecurityDescriptor      SecurityDescriptor on the account
    UserAccountControl      The User Account Control Field
    GroupType               Group Type field, in case the caller passed
                            this in.

  Return values:

    STATUS_SUCCESS on successful completion

--*/
{
    NTSTATUS NtStatus;

    ATTRBLOCK AttrBlock;
    ATTR      Attr[7];
    ATTRVAL   AttrValRid, AttrValAccountName, AttrValSecurityDescriptor,
              AttrValUserAccountControl, AttrValLocalPolicyFlags,
              AttrValGroupType, AttrValCreatorSid;
    ULONG     SecurityDescriptorAttrTyp;
    ULONG     GroupTypeAttrTyp = SAMP_FIXED_GROUP_TYPE;
    ULONG     LocalPolicyFlags;
    BOOLEAN   BuiltinDomain = IsBuiltinDomain(Object->DomainIndex);


    SAMTRACE("SampDsCreateInitialAccountObject");

    ASSERT(Object);
    ASSERT(AccountName);

    ASSERT(Flags == 0);

    // This must have been set
    ASSERT(Object->ObjectNameInDs);

    ASSERT(Object->ObjectType == SampUserObjectType  ||
           Object->ObjectType == SampGroupObjectType ||
           Object->ObjectType == SampAliasObjectType);


    //
    // We must create the attr's required by the DS to create an object
    // namely, we must set the rid.
    //
    AttrBlock.attrCount = 2;
    AttrBlock.pAttr = &(Attr[0]);

    switch ( Object->ObjectType ) {
        case SampUserObjectType:
            Attr[0].attrTyp  = SAMP_FIXED_USER_USERID;
            Attr[1].attrTyp  = SAMP_USER_ACCOUNT_NAME;
            SecurityDescriptorAttrTyp = SAMP_USER_SECURITY_DESCRIPTOR;
            break;
        case SampGroupObjectType:
            Attr[0].attrTyp  = SAMP_FIXED_GROUP_RID;
            Attr[1].attrTyp  = SAMP_GROUP_NAME;
            SecurityDescriptorAttrTyp = SAMP_GROUP_SECURITY_DESCRIPTOR;
            GroupTypeAttrTyp = SAMP_FIXED_GROUP_TYPE;
            ASSERT(!ARGUMENT_PRESENT(UserAccountControl));
            ASSERT(ARGUMENT_PRESENT(GroupType));
            break;
        case SampAliasObjectType:
            Attr[0].attrTyp  = SAMP_FIXED_ALIAS_RID;
            Attr[1].attrTyp  = SAMP_ALIAS_NAME;
            SecurityDescriptorAttrTyp = SAMP_ALIAS_SECURITY_DESCRIPTOR;
            GroupTypeAttrTyp = SAMP_FIXED_ALIAS_TYPE;
            ASSERT(!ARGUMENT_PRESENT(UserAccountControl));
            ASSERT(ARGUMENT_PRESENT(GroupType));
            break;
        default:
            ASSERT(FALSE && "Not Account Object Type");
    }

    // Set Rid
    AttrValRid.valLen = sizeof(ULONG);
    AttrValRid.pVal = (PVOID) &AccountRid;
    Attr[0].AttrVal.valCount = 1;
    Attr[0].AttrVal.pAVal = &AttrValRid;

    // Set Account Name
    AttrValAccountName.valLen = AccountName->Length;
    AttrValAccountName.pVal = (PVOID) AccountName->Buffer;
    Attr[1].AttrVal.valCount = 1;
    Attr[1].AttrVal.pAVal = &AttrValAccountName;

    // Set Security Descriptor
    if (ARGUMENT_PRESENT(SecurityDescriptor))
    {
        AttrValSecurityDescriptor.valLen = RtlLengthSecurityDescriptor(SecurityDescriptor);
        AttrValSecurityDescriptor.pVal = (UCHAR *) SecurityDescriptor;
        Attr[AttrBlock.attrCount].attrTyp = SecurityDescriptorAttrTyp;
        Attr[AttrBlock.attrCount].AttrVal.valCount = 1;
        Attr[AttrBlock.attrCount].AttrVal.pAVal = &AttrValSecurityDescriptor;
        AttrBlock.attrCount++;
    }

    // Set User Account Control
    if (ARGUMENT_PRESENT(UserAccountControl))
    {
        ASSERT(Object->ObjectType==SampUserObjectType);

        AttrValUserAccountControl.valLen = sizeof(ULONG);
        AttrValUserAccountControl.pVal = (UCHAR *) UserAccountControl;
        Attr[AttrBlock.attrCount].attrTyp = SAMP_FIXED_USER_ACCOUNT_CONTROL;
        Attr[AttrBlock.attrCount].AttrVal.valCount =1;
        Attr[AttrBlock.attrCount].AttrVal.pAVal = &AttrValUserAccountControl;
        AttrBlock.attrCount++;

        // For Machine objects also set the local policy flags
        if ((USER_WORKSTATION_TRUST_ACCOUNT & *UserAccountControl)
            || (USER_SERVER_TRUST_ACCOUNT & *UserAccountControl))
        {
            AttrValLocalPolicyFlags.valLen = sizeof(ULONG);
            LocalPolicyFlags = 0;
            AttrValLocalPolicyFlags.pVal = (UCHAR *) &LocalPolicyFlags;
            Attr[AttrBlock.attrCount].attrTyp = SAMP_FIXED_USER_LOCAL_POLICY_FLAGS;
            Attr[AttrBlock.attrCount].AttrVal.valCount=1;
            Attr[AttrBlock.attrCount].AttrVal.pAVal = &AttrValLocalPolicyFlags;
            AttrBlock.attrCount++;
        }

    }

    if (ARGUMENT_PRESENT(CreatorSid))
    {

        ASSERT((SampUserObjectType == Object->ObjectType));

        AttrValCreatorSid.valLen = RtlLengthSid(CreatorSid);
        AttrValCreatorSid.pVal = CreatorSid;
        Attr[AttrBlock.attrCount].attrTyp =  SAMP_USER_CREATOR_SID;
        Attr[AttrBlock.attrCount].AttrVal.valCount = 1;
        Attr[AttrBlock.attrCount].AttrVal.pAVal = &AttrValCreatorSid;
        AttrBlock.attrCount++;
    }

     // Set the group Type
    if (ARGUMENT_PRESENT(GroupType))
    {
        ASSERT((Object->ObjectType==SampGroupObjectType)||
                (Object->ObjectType == SampAliasObjectType));

        AttrValGroupType.valLen = sizeof(ULONG);
        AttrValGroupType.pVal = (UCHAR *) GroupType;
        Attr[AttrBlock.attrCount].attrTyp = GroupTypeAttrTyp;
        Attr[AttrBlock.attrCount].AttrVal.valCount =1;
        Attr[AttrBlock.attrCount].AttrVal.pAVal = &AttrValGroupType;
        AttrBlock.attrCount++;

        //
        // For Builtin Domain Accouts, set the additional group type
        // bit indicating a builtin local group.
        //

        if (BuiltinDomain)
        {
            (*GroupType)|=GROUP_TYPE_BUILTIN_LOCAL_GROUP;
        }

    }

    //
    // Pass in the DOMAIN_TYPE_BUILTIN flag for the case of
    // the builtin domain.
    //

    if (BuiltinDomain)
    {
        Flags|= DOMAIN_TYPE_BUILTIN;
    }

    //
    // Some SAM objects are meant for advanced view only
    //
    if ( AccountRid == DOMAIN_USER_RID_KRBTGT ) {

        Flags |= ADVANCED_VIEW_ONLY;
    }

    NtStatus = SampDsCreateObjectActual(
                                  Object->ObjectNameInDs,
                                  Flags,
                                  Object->ObjectType,
                                  &AttrBlock,
                                  DomainSidFromAccountContext(Object));
    if ( !NT_SUCCESS(NtStatus) ) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SampDsCreateObject failed (0x%x) trying to create account %d\n",
                   NtStatus,
                   AccountRid));

        return NtStatus;
    }

    return NtStatus;

}

NTSTATUS
SampDsCreateObject(
    IN   DSNAME         *Object,
    SAMP_OBJECT_TYPE    ObjectType,
    IN   ATTRBLOCK      *AttributesToSet,
    IN   OPTIONAL PSID  DomainSid
    )
/*++

  Routine Description:

    Creates a SAM Object in the DS.
    
    N.B.  This routine is only used during the migration of SAM objects
    from the registry to the DS.

  Arguments:

    Object              DSNAME of Object
    ObjectType          One of
                            SampDomainObjectType
                            SampServerObjectType
                            SampGroupObjectType
                            SampUserObjectType
                            SampAliasObjectType

                       Specifying SampDomainObjectType creates an
                       actual Domain Object in the DS. For Creating
                       a Builtin-Domain use the SampDsCreateBuiltinDomainObject
                       Function

    AttributesToSet -- Allows the caller to pass in an
                       attribute block to to Set at Object creation time
                       itself. Useful as this allows one to save a JET
                       write. Also the attributes are set in the same
                       transaction as the write.
                       NULL can be passed in if caller does
                       not want any attribute to be set

    DomainSid       -- Optional Parameter, used in creating the Full
                       SID for the account, from the specified Rid


  Return values:

    STATUS_SUCCESS on successful completion
    DS return codes mapped to NT_STATUS as in SampMapDSErrorToNTStatus

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Flags = SAM_LAZY_COMMIT;

    ATTRBLOCK AttrBlock;
    ATTR     *pAttr = NULL;
    ATTRVAL   GroupTypeAttrVal;
    ULONG GroupTypeAttribute;
    ULONG GroupTypeValue;
    

    //
    // If Domain SID specifies a builtin domain account, then
    // set the DOMAIN_TYPE_BUILTIN flag so that correct system
    // flags etc can be set on the object.
    //
    if (RtlEqualSid(DomainSid, SampBuiltinDomainSid))
    {
        Flags |= DOMAIN_TYPE_BUILTIN;
    }

    //
    // Group and Alias objects require a GroupType
    //
    if ( (ObjectType == SampGroupObjectType)
      || (ObjectType == SampAliasObjectType) ) {

        if (ObjectType == SampGroupObjectType) {
            GroupTypeAttribute = SAMP_FIXED_GROUP_TYPE;
            GroupTypeValue = GROUP_TYPE_ACCOUNT_GROUP | GROUP_TYPE_SECURITY_ENABLED;
        } else {
            GroupTypeAttribute = SAMP_FIXED_ALIAS_TYPE;
            GroupTypeValue = GROUP_TYPE_RESOURCE_GROUP | GROUP_TYPE_SECURITY_ENABLED;
        }

        if (Flags & DOMAIN_TYPE_BUILTIN) {
            GroupTypeValue |=GROUP_TYPE_BUILTIN_LOCAL_GROUP;
        }

#if DBG
        //
        // Make sure no one is already adding the group type
        //
        {
            ULONG i;
            for (i = 0; i < AttributesToSet->attrCount; i++) {
                ASSERT(AttributesToSet->pAttr[i].attrTyp != GroupTypeAttribute);
            }
        }
#endif
        //
        // Make a new attrblock including the group type
        //
        pAttr = MIDL_user_allocate( (AttributesToSet->attrCount + 1) * sizeof(ATTR));
        if (NULL == pAttr) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory(pAttr, AttributesToSet->pAttr, AttributesToSet->attrCount * sizeof(ATTR));
        pAttr[AttributesToSet->attrCount].attrTyp = GroupTypeAttribute;
        pAttr[AttributesToSet->attrCount].AttrVal.valCount = 1;
        pAttr[AttributesToSet->attrCount].AttrVal.pAVal = &GroupTypeAttrVal;
        ZeroMemory(&GroupTypeAttrVal, sizeof(GroupTypeAttrVal));
        GroupTypeAttrVal.valLen = sizeof(DWORD);
        GroupTypeAttrVal.pVal = (UCHAR*)&GroupTypeValue;

        ZeroMemory(&AttrBlock, sizeof(AttrBlock));
        AttrBlock.attrCount = AttributesToSet->attrCount + 1;
        AttrBlock.pAttr = pAttr;

    } else {

        // Pass the attributes straight through
        AttrBlock = *AttributesToSet;
    }

    Status = SampDsCreateObjectActual(Object,
                                      Flags,
                                      ObjectType,
                                      &AttrBlock,
                                      DomainSid);


    if (pAttr != NULL) {
        MIDL_user_free(pAttr);
    }

    return Status;
}



NTSTATUS
SampDsCreateBuiltinDomainObject(
    IN   DSNAME         *Object,
    IN   ATTRBLOCK      *AttributesToSet
    )
/*++

  Routine Description:

    Creates a Builtin Domain Object in the DS.

  Arguments:

    Object              DSNAME of Object

    AttributesToSet -- Allows the caller to pass in an
                       attribute block to to Set at Object creation time
                       itself. Useful as this allows one to save a JET
                       write. Also the attributes are set in the same
                       transaction as the write.
                       NULL can be passed in if caller does
                       not want any attribute to be set




  Return values:

    STATUS_SUCCESS on successful completion
    DS return codes mapped to NT_STATUS as in SampMapDSErrorToNTStatus

--*/
{
    //
    // N.B. The FORCE_NO_ADVANCED_VIEW_ONLY is used to override
    // the schema default which was done in the Windows 2000 release.
    // To have the builtin domain object be hidden, simply remove
    // this flag.
    //
    return(SampDsCreateObjectActual(
                Object,
                DOMAIN_TYPE_BUILTIN | FORCE_NO_ADVANCED_VIEW_ONLY, // Flags
                SampDomainObjectType,
                AttributesToSet,
                NULL
                ));
}


NTSTATUS
SampDsCreateObjectActual(
    IN   DSNAME         *Object,
    IN   ULONG          Flags,
    SAMP_OBJECT_TYPE    ObjectType,
    IN   ATTRBLOCK      *AttributesToSet,
    IN   OPTIONAL PSID  DomainSid
    )
/*++

 Routine Description:

     Creates an Object in the DS

 Arguments:


    Object          -- DSNAME of the object to be created

    Flags           -- Flags Controlling the Operation of
                       the routine

                       Valid Flags are
                            DOMAIN_TYPE_DOMAIN
                            DOMAIN_TYPE_BUILTIN
                            ALREADY_MAPPED_ATTRIBUTE_TYPES

    ObjectType      -- one of

                          SampServerObjectType
                          SampDomainObjectType
                          SampGroupObjectType
                          SampUserObjectType
                          SampAliasObjectType


    AttributesToSet -- Allows the caller to pass in an
                       attribute block to to Set at Object creation time
                       itself. Useful as this allows one to save a JET
                       write. Also the attributes are set in the same
                       transaction as the write.
                       NULL can be passed in if caller does
                       not want any attribute to be set

    DomainSid       -- Optional Parameter, used in creating the Full
                       SID for the account, from the specified Rid


  Return values:

    STATUS_SUCCESS on successful completion
    DS return codes mapped to NT_STATUS as in SampMapDSErrorToNTStatus




--*/
{


    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       RetCode;
    ADDARG      AddArg;
    ADDRES      * pAddRes = NULL;
    COMMARG     * pCommArg;


    SAMTRACE("SampDsCreateObjectActual");

    //
    // Parameter validation
    //

    ASSERT(Object);
    ASSERT(AttributesToSet);
    ASSERT(AttributesToSet->attrCount > 0);

    // Perform lazy thread and transaction initialization.
    Status = SampDoImplicitTransactionStart(TransactionWrite);

    if (Status!= STATUS_SUCCESS)
        goto Error;

    //
    // MAP the AttrBlock to get the final attributes to Set
    //

    memset( &AddArg, 0, sizeof( AddArg ) );

    Status = SampSamToDsAttrBlock(
                ObjectType,
                AttributesToSet,
                (
                    MAP_RID_TO_SID
                    | REALLOC_IN_DSMEMORY
                    | ADD_OBJECT_CLASS_ATTRIBUTE
                    | IGNORE_GROUP_UNUSED_ATTR
                    | Flags
                    ),
                DomainSid,
                &AddArg.AttrBlock
                );

    if (Status != STATUS_SUCCESS)
        goto Error;

    //
    // Setup the Common Args structure
    //

    pCommArg = &(AddArg.CommArg);
    BuildStdCommArg(pCommArg);
    if (Flags & SAM_LAZY_COMMIT)
        pCommArg->fLazyCommit = TRUE;

    if (Flags & SAM_URGENT_REPLICATION)
    {
        pCommArg->Svccntl.fUrgentReplication = TRUE;
    }

    //
    // Setup the AddArg structure
    //

    AddArg.pObject = Object;

    //
    // Make the DS call
    //

    SAMTRACE_DS("DirAddEntry\n");

    RetCode = DirAddEntry(&AddArg, &pAddRes);

    SAMTRACE_RETURN_CODE_DS(RetCode);

    //
    // Map the return code to an NT status
    //

    if (NULL==pAddRes)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        Status = SampMapDsErrorToNTStatus(RetCode,&pAddRes->CommRes);
    }

Error:

    //
    // Turn the fDSA flag back on as in loopback cases this can get reset
    //

    SampSetDsa(TRUE);

    return Status;

}


NTSTATUS
SampDsDeleteObject(
    IN DSNAME * Object,
    IN ULONG    Flags
    )
/*++

  Routine Description:

    Delete an Object in the DS

  Arguments:
        Object   -- specifies the Object to delete

        Flags    -- Control Delete, currently defined value is

                    SAM_DELETE_TREE - tells this routine sets argument in
                    RemoveArg, asks core DS to do a Delete Tree operation.

  Return Values:
    STATUS_SUCCESS on succesful completion
    DS return codes mapped to NT_STATUS as in SampMapDSErrorToNTStatus

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    REMOVEARG   RemoveArg;
    REMOVERES   *pRemoveRes=NULL;
    COMMARG     *pCommArg;
    ULONG       RetValue;


    SAMTRACE("SampDsDeleteObject");

    //
    // Asserts and parameter validation
    //

    ASSERT(Object!=NULL);

    // Perform lazy thread and transaction initialization.
    Status = SampDoImplicitTransactionStart(TransactionWrite);

    if (Status!= STATUS_SUCCESS)
        goto Error;

    //
    // Setup the Common Args structure
    //

    memset( &RemoveArg, 0, sizeof( RemoveArg ) );
    pCommArg = &(RemoveArg.CommArg);
    BuildStdCommArg(pCommArg);

    //
    // Setup the RemoveArgs structure
    //

    RemoveArg.pObject = Object;


    //
    // if this is a Tree Delete, set RemoveArgs
    //

    if (SAM_DELETE_TREE & Flags)
    {
        RemoveArg.fTreeDelete = TRUE;
    }


    //
    // Make the directory call
    //

    SAMTRACE_DS("DirRemoveEntry\n");

    RetValue = DirRemoveEntry(&RemoveArg, &pRemoveRes);

    SAMTRACE_RETURN_CODE_DS(RetValue);

    //
    // Map to corresponding NT status code
    //

    if (NULL==pRemoveRes)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        Status = SampMapDsErrorToNTStatus(RetValue,&pRemoveRes->CommRes);
    }


Error:

    //
    // Clear any errors
    //

    SampClearErrors();

    //
    // Turn the fDSA flag back on as in loopback cases this can get reset
    //

    SampSetDsa(TRUE);


    return Status;
}


NTSTATUS
SampDsDeleteWellKnownSidObject(
    IN DSNAME * Object
    )
/*++

  Routine Description:


    This routine first replaces the ATT_OBJECT_SID attribute value with a 
    structurally sound, but non existent SID, and then deletes the object.
    
    We are doing that because SAM still keeps the newest Builtin Well Known 
    Object (even with duplicate SID). If the tombstone object still holds the 
    Object Sid attribute after the deletion, SAM will not be able to find the 
    retained Well Known Account because DS will continue to find duplicate 
    SIDs in the indexed table, (ATT_OBJECT_SID is an indexed attribute) thus 
    leads to SAM Lookup failure.
    
    The solution is to replace the SID attribute with a value that a security
    principal can never have (domain sid, with a RID of 0).
    
  
  Arguments:
        Object   -- specifies the Object to delete

  Return Values:
    STATUS_SUCCESS on succesful completion
    DS return codes mapped to NT_STATUS as in SampMapDSErrorToNTStatus

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    MODIFYARG   ModArg;
    MODIFYRES   *ModRes = NULL;
    REMOVEARG   RemoveArg;
    REMOVERES   *pRemoveRes=NULL;
    COMMARG     *pCommArg;
    ATTR        Attr;
    ATTRVAL     AttrVal;
    ATTRVALBLOCK   AttrValBlock;
    ULONG       RetValue;
    BOOL        fRet;
    BYTE        DomainBuffer[SECURITY_MAX_SID_SIZE];
    BYTE        ReplacementBuffer[SECURITY_MAX_SID_SIZE];
    PSID        DomainSid = (PSID) DomainBuffer;
    PSID        ReplacementSid = (PSID) ReplacementBuffer;
    ULONG       Size;
    ULONG       i;
    BOOL        fBuiltinDomain = FALSE;

    SAMTRACE("SampDsDeleteWellKnownSidObject");

    //
    // Asserts and parameter validation
    //

    ASSERT(Object!=NULL);

    // Perform lazy thread and transaction initialization.
    Status = SampDoImplicitTransactionStart(TransactionWrite);

    if (Status!= STATUS_SUCCESS)
        goto Error;


    //
    // Change the SID to a SID that will never exist.  See routine description.
    //
    ASSERT(IsValidSid(&Object->Sid));
    Size = sizeof(DomainBuffer);

    if (EqualDomainSid(SampBuiltinDomainSid, &Object->Sid, &fBuiltinDomain)
     && fBuiltinDomain) {

        RtlCopyMemory(DomainSid, SampBuiltinDomainSid, RtlLengthSid(SampBuiltinDomainSid));

    } else {

        fRet = GetWindowsAccountDomainSid(&Object->Sid,
                                          DomainSid,
                                          &Size);
        if (!fRet)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }
    }

    fRet = InitializeSid(ReplacementSid,
                         GetSidIdentifierAuthority(DomainSid),
                        (*GetSidSubAuthorityCount(DomainSid)) + 1);
    if (!fRet)
    {
        Status = STATUS_NO_MEMORY;
        goto Error;
    }

    for (i = 0; i < *GetSidSubAuthorityCount(DomainSid); i++) {
        *GetSidSubAuthority(ReplacementSid, i) = *GetSidSubAuthority(DomainSid, i);
    }
    *GetSidSubAuthority(ReplacementSid, i) = 0;


    RtlZeroMemory(&ModArg, sizeof(MODIFYARG));

    ModArg.pObject = Object;
    ModArg.FirstMod.pNextMod = NULL;
    ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;

    AttrVal.valLen = GetLengthSid(ReplacementSid);
    AttrVal.pVal = ReplacementSid;

    AttrValBlock.valCount = 1;
    AttrValBlock.pAVal = &AttrVal;

    Attr.attrTyp = ATT_OBJECT_SID;
    Attr.AttrVal = AttrValBlock;

    ModArg.FirstMod.AttrInf = Attr;
    ModArg.count = 1;

    pCommArg = &(ModArg.CommArg);
    BuildStdCommArg( pCommArg );


    //
    // set fDSA, so that we can remove ATT_OBJECT_SID
    // 
    SampSetDsa(TRUE);
    
    RetValue = DirModifyEntry( &ModArg, &ModRes );

    if (NULL == ModRes)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        Status = SampMapDsErrorToNTStatus( RetValue, &ModRes->CommRes );
    }


    if (!NT_SUCCESS(Status))
    {
        goto Error;
    }


    //
    // Setup the Common Args structure
    //

    memset( &RemoveArg, 0, sizeof( RemoveArg ) );
    pCommArg = &(RemoveArg.CommArg);
    BuildStdCommArg(pCommArg);

    //
    // Setup the RemoveArgs structure
    //

    RemoveArg.pObject = Object;


    //
    // Make the directory call
    //

    SAMTRACE_DS("DirRemoveEntry\n");

    RetValue = DirRemoveEntry(&RemoveArg, &pRemoveRes);

    SAMTRACE_RETURN_CODE_DS(RetValue);

    //
    // Map to corresponding NT status code
    //

    if (NULL==pRemoveRes)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        Status = SampMapDsErrorToNTStatus(RetValue,&pRemoveRes->CommRes);
    }


Error:

    //
    // Clear any errors
    //

    SampClearErrors();

    //
    // Turn the fDSA flag back on as in loopback cases this can get reset
    //

    SampSetDsa(TRUE);


    return Status;
}



NTSTATUS
SampGenerateNameForDuplicate(
    ULONG   Rid,
    UNICODE_STRING  *NewAccountName
    )
/*++
Routine Description:

    This routine generates a SamAccountName based on the object RID. 
    The new name is like

    $DUPLICATE-<RID>. 

Parameter:

    Rid - object RID
    
    NewAccountName - out parameter

Return Value:

    NtStatus Code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    LPWSTR      NameString = NULL;


    memset(NewAccountName, 0, sizeof(UNICODE_STRING));


    NameString = MIDL_user_allocate( sizeof(WCHAR) * SAMP_MAX_DOWN_LEVEL_NAME_LENGTH ); 
    if (NULL == NameString)
    {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }
    memset(NameString, 0, sizeof(WCHAR) * SAMP_MAX_DOWN_LEVEL_NAME_LENGTH);


    wsprintf(NameString, L"$DUPLICATE-%x", Rid);
    RtlInitUnicodeString(NewAccountName, NameString);

    return( NtStatus );
}


NTSTATUS
SampApplyConstructedAccountName(
    DSNAME *pObjectDsName,
    UNICODE_STRING *pNewAccountName
    )
/*++
Routine Description:

    This routine modifies object (pObjectDsname) SamAccountNamt to pNewAccountName

Parameter:

    pObjectDsName - object dsname 

    pNewAccountName - New SamAccountName

Return Value:

    NtStatus Code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       RetCode = 0; 
    MODIFYARG   ModArg;
    MODIFYRES   *pModRes = NULL;
    COMMARG     *pCommArg = NULL;
    ATTR        Attr;
    ATTRVAL     AttrVal;
    ATTRVALBLOCK    AttrValBlock;

    memset( &ModArg, 0, sizeof(ModArg) );
    ModArg.pObject = pObjectDsName;

    ModArg.FirstMod.pNextMod = NULL;
    ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;

    AttrVal.valLen = pNewAccountName->Length;
    AttrVal.pVal = (PUCHAR) pNewAccountName->Buffer;

    AttrValBlock.valCount = 1;
    AttrValBlock.pAVal = &AttrVal;

    Attr.attrTyp = ATT_SAM_ACCOUNT_NAME;
    Attr.AttrVal = AttrValBlock;

    ModArg.FirstMod.AttrInf = Attr;
    ModArg.count = 1;

    pCommArg = &(ModArg.CommArg);
    BuildStdCommArg( pCommArg );

    RetCode = DirModifyEntry(&ModArg, &pModRes);

    if (NULL==pModRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetCode,&pModRes->CommRes);
    }

    //
    // clear any error
    //
    SampClearErrors();

    return( NtStatus );  

}






NTSTATUS
SampRenameDuplicateAccount(
    PVOID pv
    )
/*++
Routine Description:

    This routine renames duplicate objects to unique values based on their RIDs

    
    Note: This routine will not re-register itself again if anything fails. 
          Because DuplicateAccountRename will be executed whenever a duplicate 
          is detected, it is not a one time deal. 

Parameter:

    pv - contains object DSNAMEs

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       Index = 0;
    SAMP_RENAME_DUP_ACCOUNT_PARM    * RenameParm = (SAMP_RENAME_DUP_ACCOUNT_PARM *)pv;


    if (SampServiceEnabled != SampServiceState)
    {
        goto Cleanup;
    }

    //
    // Perform lazy thread and transaction initialization.
    //

    NtStatus = SampDoImplicitTransactionStart(TransactionRead);

    if (!NT_SUCCESS(NtStatus))
        goto Cleanup;

    // 
    // walk through all duplicate accounts, and generate new SamAccountName. Then
    // rename
    // 

    for (Index = 0; Index < RenameParm->Count; Index ++)
    {
        PSID    pSid = NULL;
        ULONG   Rid = 0;
        UNICODE_STRING  NewAccountName;
        UNICODE_STRING  StringDN;
        PUNICODE_STRING Strings[2];

        // 
        // Create a unique account Name for duplicate objects
        // derive it from object RID
        //

        ASSERT(0 != RenameParm->DuplicateAccountDsNames[Index]->SidLen);
        pSid = &(RenameParm->DuplicateAccountDsNames[Index]->Sid);

        NtStatus = SampSplitSid(pSid, NULL, &Rid); 

        if (!NT_SUCCESS(NtStatus))
        {
            continue;   // continue with the next object to be renamed
        }

        NtStatus = SampGenerateNameForDuplicate(
                            Rid,                             
                            &NewAccountName
                            );

        if (NT_SUCCESS(NtStatus))
        {

            //
            // Call DirModify to rename SamAccountName
            // 
            NtStatus = SampApplyConstructedAccountName(
                                RenameParm->DuplicateAccountDsNames[Index],
                                &NewAccountName
                                );

            if (NT_SUCCESS(NtStatus))
            {
                //
                // Event log account name change if operate succeeds.
                // 
    
                StringDN.Length = (USHORT) RenameParm->DuplicateAccountDsNames[Index]->NameLen * sizeof (WCHAR );
                StringDN.MaximumLength = StringDN.Length;
                StringDN.Buffer= (WCHAR *) &(RenameParm->DuplicateAccountDsNames[Index]->StringName);


                Strings[0] = &StringDN;
                Strings[1] = &NewAccountName;

                SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                                  0,
                                  SAMMSG_RENAME_DUPLICATE_ACCOUNT_NAME,
                                  pSid,
                                  2,
                                  0,
                                  Strings,
                                  NULL
                                  );
            }

            MIDL_user_free( NewAccountName.Buffer );
        }
    }
        

Cleanup:

    SampMaybeEndDsTransaction(TransactionCommit);

    // free the layered structure
    for (Index = 0; Index < ((SAMP_RENAME_DUP_ACCOUNT_PARM *)pv)->Count; Index++)
    {
        if ( ((SAMP_RENAME_DUP_ACCOUNT_PARM *)pv)->DuplicateAccountDsNames[Index])
        {
            MIDL_user_free( ((SAMP_RENAME_DUP_ACCOUNT_PARM *)pv)->DuplicateAccountDsNames[Index] );
        }
    }
    MIDL_user_free(((SAMP_RENAME_DUP_ACCOUNT_PARM *)pv)->DuplicateAccountDsNames);
    MIDL_user_free(pv);

    return( NtStatus );
}


NTSTATUS
SampRegisterRenameRoutine(
    IN ULONG   NumMatches,
    IN ENTINFLIST *MatchingEntinfs[],
    IN PDSNAME FoundObject
    )
/*++
Routine Description:

    This routine triggers an asynchronous procedure to rename the duplicate 
    accounts to unique value.

Parameter:

    NumMatches - number of accounts with the same name

    MatchingEntinfs - an array of pointers to ENTINF structure

    FoundObject - pointer to object DSNAME, indicates the account should NOT be 
                  rename, leave this and ONLY this account name unchanged.
    

Return Value:

    NtStatus Code
        STATUS_INSUFFICIENT_RESOURCES
        STATUS_SUCCESS

--*/
{
    NTSTATUS    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    PSAMP_RENAME_DUP_ACCOUNT_PARM   pv = NULL;
    ULONG       Index = 0;
    ULONG       DupIndex = 0;
    ULONG       BufLength = 0;

    pv = MIDL_user_allocate(sizeof(SAMP_RENAME_DUP_ACCOUNT_PARM));

    if (NULL != pv)
    {
        memset(pv, 0, sizeof(SAMP_RENAME_DUP_ACCOUNT_PARM));


        // 
        // set the count of objects, which need to be renamed
        //

        ASSERT( NumMatches > 1);
        pv->Count = NumMatches - 1;

        //
        // walk through all duplicate accounts, copy them to process heap
        //

        //
        // SAMP_RENAME_DUP_ACCOUNT_PARM is a three level structure
        //
        //
        //  pv (Rename Parm)
        //  *--------------------------+
        //  | Count                    |    +----------+     
        //  | DuplicateAccountDsNames -|--> | DsName0 -|---->+--------+
        //  *--------------------------+    |----------|     |        |
        //                                  |   ...    |     +--------+
        //                                  |----------|     
        //                                  | DsNameN -|---->+--------+
        //                                  +----------+     |        |
        //                                                   +--------+ 
        //
        //  the buffers containing the DSNAMEs are allocated in separate memory.
        // 

        BufLength = 0;
        BufLength = (NumMatches - 1) * sizeof( PDSNAME );

        pv->DuplicateAccountDsNames = MIDL_user_allocate( BufLength );

        if (NULL != pv->DuplicateAccountDsNames)
        {
            memset(pv->DuplicateAccountDsNames, 0, BufLength);

            DupIndex = 0;

            for (Index = 0; Index < NumMatches; Index ++)
            {
                // skip the account to be kept
                if (FoundObject == MatchingEntinfs[Index]->Entinf.pName)
                {
                    continue;
                }

                // allocate separate memory for each DSNAME
                BufLength = MatchingEntinfs[Index]->Entinf.pName->structLen;

                pv->DuplicateAccountDsNames[DupIndex] = (PDSNAME) MIDL_user_allocate( BufLength );

                if (NULL == pv->DuplicateAccountDsNames[DupIndex])
                {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    goto Error;
                }

                memset(pv->DuplicateAccountDsNames[DupIndex], 0, BufLength);

                // copy DSNAME of the duplicate object
                memcpy(pv->DuplicateAccountDsNames[DupIndex],   // using DupIndex
                       MatchingEntinfs[Index]->Entinf.pName,    // using Index
                       BufLength
                       );

                // increase the count of duplicate dsnames
                DupIndex ++;

            }

            //
            // trigger the worker routine
            //

            LsaIRegisterNotification(
                    SampRenameDuplicateAccount,
                    (PVOID) pv,
                    NOTIFIER_TYPE_INTERVAL,
                    0,      // no class
                    NOTIFIER_FLAG_ONE_SHOT,
                    5,      // 1 minute
                    NULL    // no handle
                    );

            //
            // set return code to success 
            // 

            NtStatus = STATUS_SUCCESS;
        }
    }

Error:

    // release resources if failed

    if ( !NT_SUCCESS(NtStatus) ) 
    {
        if ( pv ) {
            if ( pv->DuplicateAccountDsNames ) {
                for (Index = 0; Index < pv->Count; Index++)
                {
                    if ( pv->DuplicateAccountDsNames[Index] )
                    {
                        MIDL_user_free( pv->DuplicateAccountDsNames[Index] );
                    }
                }
                MIDL_user_free( pv->DuplicateAccountDsNames );
            }
            MIDL_user_free( pv );
        }
    }

    return( NtStatus );
}




NTSTATUS
SampHandleDuplicates(
    IN ATTRTYP MatchAttr,
    IN ULONG   NumMatches,
    IN ENTINFLIST *MatchingEntinfs[],
    OUT PDSNAME *FoundObject
    )

/*++

    Routine Description

    SampHandleDuplicates Handles occurences of duplicate Sam account names,
    SIDs etc that are caused by operation within a Distributed System Environment
    The algorithms used to handle these cases are as follows


    1. Duplicate Sids -- In this case both the accounts are deleted
    2. Duplicate Sam account names --
            a. Machine account(s). In this case the most recent account is retained. The
               existance of duplicate accounts is event logged.
            b. All other cases -- The older account is used. The existance of duplicate
               is event logged

    Parameters:

        MatchAttr -- The type of attribute we are matching on
        NumMatches -- The number of entries that matched
        MatchingEntinfs -- The search results containing the matching entries
        FoundObject -- If an object is chosen from the several matching ones, then that
                       object is returned in here



    Return Values:

        STATUS_SUCCESS if an object has been picked
        STATUS_NOT_FOUND if all duplicates were deleted
        STATUS_INTERNAL_ERROR Otherwise
--*/
{
    NTSTATUS    Status = STATUS_SUCCESS, IgnoreStatus = STATUS_SUCCESS;
    ULONG       i;
    LARGE_INTEGER OldestCreationTime;
    LARGE_INTEGER NewestCreationTime;
    DSNAME      * OldestObject;
    DSNAME      * NewestObject;
    VOID          *CurrentThreadState=NULL;

    //
    // Walk through the matches and find the oldest and newest objects
    //

    ASSERT(NumMatches>1);

    ASSERT(3==MatchingEntinfs[0]->Entinf.AttrBlock.attrCount);
    ASSERT(MatchAttr==MatchingEntinfs[0]->Entinf.AttrBlock.pAttr[0].attrTyp);
    ASSERT(ATT_WHEN_CREATED==MatchingEntinfs[0]->Entinf.AttrBlock.pAttr[1].attrTyp);
    ASSERT(ATT_OBJECT_CLASS==MatchingEntinfs[0]->Entinf.AttrBlock.pAttr[2].attrTyp);

    OldestCreationTime
        = *((LARGE_INTEGER *)
          MatchingEntinfs[0]->Entinf.AttrBlock.pAttr[1].AttrVal.pAVal[0].pVal);

    NewestCreationTime
        = *((LARGE_INTEGER *)
          MatchingEntinfs[0]->Entinf.AttrBlock.pAttr[1].AttrVal.pAVal[0].pVal);
    NewestObject = MatchingEntinfs[0]->Entinf.pName;
    OldestObject = MatchingEntinfs[0]->Entinf.pName;

    for (i=1;i<NumMatches;i++)
    {
        ULONG ObjectClass;
        LARGE_INTEGER CreationTime;

        ASSERT(3==MatchingEntinfs[i]->Entinf.AttrBlock.attrCount);
        ASSERT(MatchAttr == MatchingEntinfs[i]->Entinf.AttrBlock.pAttr[0].attrTyp);
        ASSERT(ATT_WHEN_CREATED == MatchingEntinfs[i]->Entinf.AttrBlock.pAttr[1].attrTyp);
        ASSERT(ATT_OBJECT_CLASS == MatchingEntinfs[i]->Entinf.AttrBlock.pAttr[2].attrTyp);

        ObjectClass = *((ULONG *)MatchingEntinfs[i]->Entinf.AttrBlock.pAttr[2].AttrVal.pAVal[0].pVal);
        CreationTime =
            *((LARGE_INTEGER *)MatchingEntinfs[i]->Entinf.AttrBlock.pAttr[1].AttrVal.pAVal[0].pVal);

        if (OldestCreationTime.QuadPart>CreationTime.QuadPart)
        {
            OldestCreationTime = CreationTime;
            OldestObject = MatchingEntinfs[i]->Entinf.pName;
        }

        if (NewestCreationTime.QuadPart<CreationTime.QuadPart)
        {
            NewestCreationTime = CreationTime;
            NewestObject = MatchingEntinfs[i]->Entinf.pName;
        }
    }


    //
    // Now Handle the various cases
    //

    switch(MatchAttr)
    {
    case ATT_OBJECT_SID:

        //
        // Duplicate SIDs are always deleted
        //

        CurrentThreadState = THSave();

        for (i=0;i<NumMatches;i++)
        {
            UNICODE_STRING StringDN;
            PUNICODE_STRING StringPointers = &StringDN;
            PSID            pSid = NULL;
            ULONG           Rid = 0;
            ULONG           EventId = 0;
            BOOLEAN         fFPO = FALSE;
            ULONG           ObjectClass;
            ULONG           j;

            ASSERT(0 != MatchingEntinfs[i]->Entinf.pName->SidLen);
            pSid = &(MatchingEntinfs[i]->Entinf.pName->Sid);

            //
            // Duplicate FPO's shouldn't be deleted.  They cause no harm being
            // duplicated and deleting would ruin an existing membership.
            // Note: perhaps the FPO cleanup task could identify duplicate
            // FPO's and consolidate.  This would have to handle well known
            // SID's (like Everyone) to be complete.
            //
            for (j = 0; j < MatchingEntinfs[i]->Entinf.AttrBlock.pAttr[2].AttrVal.valCount; j++)
            {
                if (CLASS_FOREIGN_SECURITY_PRINCIPAL ==
                     *((ULONG *)MatchingEntinfs[i]->Entinf.AttrBlock.pAttr[2].AttrVal.pAVal[j].pVal))
                {
                    fFPO = TRUE;
                    break;
                }
            }
            if ( fFPO )
            {
                //
                // Return the newest object and don't delete the rest
                // 
                // N.B. If a duplicate SID is found and one of the objects is
                // an FPO, then all duplicate SID objects must be FPO's as
                // well since SAM searches are in the scope of a single 
                // domain.
                //
                *FoundObject = NewestObject;
                break;
            }

            SampSplitSid(pSid, NULL, &Rid);

            //
            // Well known accounts 
            // Only SAM can create wellknown accounts. Instead of delete all
            // duplicates, we will keep the newest well known accounts and 
            // delete the rest.
            //


            if ( SampIsAccountBuiltIn( Rid ) )
            {
                if ( NewestObject == MatchingEntinfs[i]->Entinf.pName )
                {
                    // keep the newest account
                    *FoundObject = NewestObject;
                    continue;
                }
                else
                {
                    // delete all older accounts
                    EventId = SAMMSG_DUPLICATE_SID_WELLKNOWN_ACCOUNT;
                }
            }
            else
            {
                EventId = SAMMSG_DUPLICATE_SID;
            }

            if ( SampIsAccountBuiltIn( Rid ) )
            {
                //
                // This variation of delete object will replace the SID value
                // with a strucuturally sound, non existent SID so that
                // subsequent searches won't find the deleted object.
                //
                SampDsDeleteWellKnownSidObject(MatchingEntinfs[i]->Entinf.pName);
            }
            else 
            {
                //
                // ASSERT at this point since we have a duplicate SID in 
                // an account domain.
                //
                ASSERT(FALSE && "Duplicate SID Found");

                SampDsDeleteObject(MatchingEntinfs[i]->Entinf.pName,
                                   0);
            }

            StringDN.Length = (USHORT) MatchingEntinfs[i]->Entinf.pName->NameLen * sizeof (WCHAR );
            StringDN.MaximumLength = StringDN.Length;
            StringDN.Buffer= (WCHAR *) &MatchingEntinfs[i]->Entinf.pName->StringName;

            SampWriteEventLog(
                    EVENTLOG_ERROR_TYPE,
                    0,
                    EventId,
                    &MatchingEntinfs[i]->Entinf.pName->Sid,
                    1,
                    0,
                    &StringPointers,
                    NULL
                    );
        }

        SampMaybeEndDsTransaction(TransactionCommit);

        THRestore(CurrentThreadState);

        //
        // The return Status is object not found
        //
        if (*FoundObject == NULL) {
            Status =  STATUS_NOT_FOUND;
        }

        break;

    case ATT_SAM_ACCOUNT_NAME:

        //
        // Whistler always preserves the newest account. This is so that we are always
        // consistent with the replicator when mangling CN's.
        //

    
        *FoundObject = NewestObject;
      
        //
        // Trigger a asynchronous routine to rename the dupliate
        // account to a unique value. The duplicates will be 
        // event logged as they are renamed.
        // 

        IgnoreStatus = SampRegisterRenameRoutine(
                                NumMatches,
                                MatchingEntinfs,
                                *FoundObject
                                );

        //
        // The return status is success
        //

        Status = STATUS_SUCCESS;

        break;

    case ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME:

        Status = STATUS_USER_EXISTS;
        break;

    default:

        Status = STATUS_OBJECT_NAME_COLLISION;
        break;
    }


    return Status;

}


NTSTATUS
SampDsDoUniqueSearch(
             IN ULONG  Flags,
             IN DSNAME * ContainerObject,
             IN ATTR * AttributeToMatch,
             OUT DSNAME **Object
             )
/*++

  Routine Description:

    Searches for the object with the given attribute
    NOTE - SampDsDoUniqueSearch expects that the search result is unique.
    It is typically used in Rid to Object, Sid To Object, Name To Object Mappings,
    This is a simplified search, so that simple searches on a single attribute
    can be easily set up.

  Arguments
        Flags            -- Flags, control searching. Currently defined flag is

            SAM_UNICODE_STRING_MANUAL_COMPARISON   -- Tells the routine to manually
            compare using RtlCompareUnicodeString in a case insenstive fashion in
            case of multiple matches.

            SAM_UPGRADE_FROM_REGISTRY - Tells the routine to not call
            SampHandleDuplicates() when duplicates are found since we are
            upgrading accounts from the registry to the DS.


        ContainerObject  -- specifies the DSNAME of the container in which to search

        AttributeToMatch -- specifies the type and value of the attribute that must match.
                            The attribute Type is the DS attribute Type. Caller must do
                            the translation. This is acceptable as this is not a function that
                            is called from outside dslayer.c

        Object           -- Pointer to a DSNAME specifying the object is returned in here.
                            This object is allocated using SAM's memory allocation routines

  Return Values:
        STATUS_SUCCESS   -- on successful completion
        STATUS_NOT_FOUND -- if object not found
        STATUS_UNSUCCESSFUL -- if more than one match
        DS return codes mapped to NT_STATUS as in SampMapDSErrorToNTStatus
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SEARCHARG SearchArg;
    SEARCHRES * SearchRes=NULL;
    FILTER  Filter;
    ULONG   RetCode;
    COMMARG * pCommArg;
    SVCCNTL * pSvcCntl;
    ENTINFSEL EntInfSel;
    PVOID     pVal = NULL;
    ENTINFLIST *MatchingEntInf = NULL;
    BOOLEAN   fUseDirFind =  FALSE;
    BOOLEAN   fUseDirSearch = TRUE;
    ULONG     DomainHandle = 0;
    FINDARG   FindArg;
    FINDRES   *pFindRes;
    DSNAME    *FoundObject = NULL;

    SAMTRACE("SampDsDoUniqueSearch");

    //
    // Asserts and parameter validation
    //

    ASSERT(AttributeToMatch);
    ASSERT(AttributeToMatch->AttrVal.pAVal);
    ASSERT(ContainerObject);
    ASSERT(Object);

    //
    // Set Object To NULL for sake of error returns
    //

    *Object = NULL;

    //
    // Check to see if we can use Dir Find instead
    // of Dir Search
    //

    if ((SampServiceEnabled==SampServiceState)
        && (ContainerObject->SidLen>0))
    {
        ULONG i;

        //
        // Scan the defined domains Array
        //

        for (i=SampDsGetPrimaryDomainStart();i<SampDefinedDomainsCount;i++)
        {
            if ((RtlEqualSid(&ContainerObject->Sid,
                        SampDefinedDomains[i].Sid))
                 && (0!=SampDefinedDomains[i].DsDomainHandle)
                 && (!IsBuiltinDomain(i)))
            {
                //
                // Yes we found a domain that we host, and that domain
                // is not a builtin domain
                //

                DomainHandle = SampDefinedDomains[i].DsDomainHandle;
                fUseDirFind = TRUE;
                break;
            }
        }
    }


    //
    // Dir Find is hard coded to not find deleted
    // objects. So in such cases use Dir Search
    //

    if (Flags & SAM_MAKE_DEL_AVAILABLE)
    {
        fUseDirFind = FALSE;
    }


    //
    // Perform lazy thread and transaction initialization.
    //

    Status = SampDoImplicitTransactionStart(TransactionRead);

    if (Status!= STATUS_SUCCESS)
        goto Error;



    //
    // Search by using DirFindEntry
    //

    if (fUseDirFind)
    {
        //
        // Dir Find can being used try using it
        //

        RtlZeroMemory(&FindArg,sizeof(FINDARG));
        FindArg.hDomain = DomainHandle;
        FindArg.AttId = AttributeToMatch->attrTyp;
        FindArg.AttrVal = *(AttributeToMatch->AttrVal.pAVal);
        FindArg.fShortNames = TRUE;
        BuildStdCommArg(&FindArg.CommArg);

        SAMTRACE_DS("DirFind\n");

        RetCode = DirFindEntry(&FindArg,&pFindRes);

        SAMTRACE_RETURN_CODE_DS(RetCode);

        //
        // Clear any errors
        //

        SampClearErrors();

        if (0==RetCode)
        {
            //
            // Dir Find Succeeded, No duplicates etc
            // Need not fall over to DirSearch, therefore
            // set fUseDirSearch to false
            //

            FoundObject = pFindRes->pObject;
            fUseDirSearch = FALSE;

        }
        else if (NULL!=pFindRes)
        {
            Status  = SampMapDsErrorToNTStatus(RetCode,&pFindRes->CommRes);
            if (STATUS_OBJECT_NAME_NOT_FOUND == Status)
            {
                //
                // We cound not find the object. Bail
                //

                Status = STATUS_NOT_FOUND;
                goto Error;
            }

            //
            // Some other wierd error occured out here. Fall
            // through to the Dir Search
            //

            Status = STATUS_SUCCESS;

        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }
    }


    //
    // Fall over to full DirSearch if DirFindEntry detected any kind of
    // error condition or if we cannot use DirFind
    //

    if (fUseDirSearch)
    {

        //
        // Build the filter
        //
        memset (&Filter, 0, sizeof (Filter));
        Filter.choice = FILTER_CHOICE_ITEM;
        Filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        Filter.FilterTypes.Item.FilTypes.ava.type = AttributeToMatch->attrTyp;
        Filter.FilterTypes.Item.FilTypes.ava.Value.valLen = AttributeToMatch->AttrVal.pAVal->valLen;

        pVal = DSAlloc(AttributeToMatch->AttrVal.pAVal->valLen);
        if (NULL==pVal)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        RtlCopyMemory(
            pVal,
            AttributeToMatch->AttrVal.pAVal->pVal,
            AttributeToMatch->AttrVal.pAVal->valLen
            );

        Filter.FilterTypes.Item.FilTypes.ava.Value.pVal = pVal;

        //
        // Build the SearchArg Structure
        //

        memset(&SearchArg, 0, sizeof(SEARCHARG));
        SearchArg.pObject = ContainerObject;
        SearchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
        SearchArg.pFilter = & Filter;
        SearchArg.searchAliases = FALSE;
        SearchArg.pSelection = & EntInfSel;
        SearchArg.bOneNC = TRUE;

        EntInfSel.attSel = EN_ATTSET_LIST;
        EntInfSel.AttrTypBlock.attrCount = 3;
        SAMP_ALLOCA(EntInfSel.AttrTypBlock.pAttr,3*sizeof(ATTR));
        if (NULL==EntInfSel.AttrTypBlock.pAttr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }
        RtlZeroMemory(
           EntInfSel.AttrTypBlock.pAttr,
           3*sizeof(ATTR));

        EntInfSel.AttrTypBlock.pAttr[0].attrTyp = AttributeToMatch->attrTyp;
        EntInfSel.AttrTypBlock.pAttr[1].attrTyp = ATT_WHEN_CREATED;
        EntInfSel.AttrTypBlock.pAttr[2].attrTyp = ATT_OBJECT_CLASS;

        // Unique search does a Dir Search only in fairly
        // rare error cases. And in these cases it is useful to
        // have the string name for event logging. So ask for
        // string names
        EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;


        //
        // Build the Commarg structure
        // Get the address of the service control structure
        //

        pCommArg = &(SearchArg.CommArg);
        BuildStdCommArg(pCommArg);

        if (Flags & SAM_MAKE_DEL_AVAILABLE)
        {
            pSvcCntl = &(pCommArg->Svccntl);
            pSvcCntl->makeDeletionsAvail = TRUE;
        }

        //
        // Make the Directory call
        //

        SAMTRACE_DS("DirSearch\n");

        RetCode = DirSearch(&SearchArg, &SearchRes);

        SAMTRACE_RETURN_CODE_DS(RetCode);

        //
        // check for errors
        //
        if (NULL==SearchRes)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            Status  = SampMapDsErrorToNTStatus(RetCode,&SearchRes->CommRes);
            if (STATUS_OBJECT_NAME_NOT_FOUND == Status)
            {
                // Map error to what client expects
                Status = STATUS_NOT_FOUND;
            }
        }
        if (Status != STATUS_SUCCESS)
            goto Error;

        //
        // If more data exists then error out. Under normal memory
        // conditions we should not ever need to hit size limits.
        //

        if ((SearchRes->pPartialOutcomeQualifier)
            && (SearchRes->pPartialOutcomeQualifier->problem == PA_PROBLEM_SIZE_LIMIT))
        {
            // Partial outcome,  error out saying no mmeory
            Status = STATUS_NO_MEMORY;
            goto Error;
        }


        //
        // Check if no match exists or more than one match exists.
        //

        if (SearchRes->count == 0)
        {
            //
            // No Match Exists
            //

            Status =  STATUS_NOT_FOUND;
            goto Error;
        }
        else if (SearchRes->count >= 1)
        {

            //
            // More than one match exists, ( or as exists as claimed by Jet ),
            // perform a binary comparison of the data, with the supplied value
            // for the Data, if this was requested by the caller

            ULONG i, valIndex;
            ENTINFLIST * pEntinf = &SearchRes->FirstEntInf;
            ULONG      NumMatches=0;
            ENTINFLIST **pMatchingEntinfList;

            //
            // Alloc Stack space for all the matching objects.
            //


            SAMP_ALLOCA(pMatchingEntinfList,SearchRes->count * sizeof (ENTINF *));
            if (NULL==pMatchingEntinfList)
            {
                 Status = STATUS_INSUFFICIENT_RESOURCES;
                 goto Error;
            }


            //
            // Walk through the object looking at each object that matched.
            //

            for (i=0;i<SearchRes->count;i++)
            {
                BOOLEAN Matched = FALSE;


                if (Flags & SAM_UNICODE_STRING_MANUAL_COMPARISON)
                {
                    //
                    // If Manual Comparison to further weed out any matches was requested
                    // by caller then perform the appropriate manual comparison. This
                    // comparison is needed because the Jet indices treat many kinds of
                    // localized names as the same, and NT account names do not treat them
                    // so.
                    //

                    UNICODE_STRING TmpString1,TmpString2;


                    TmpString1.Buffer=(WCHAR *)AttributeToMatch->AttrVal.pAVal[0].pVal;
                    TmpString1.Length=(USHORT)AttributeToMatch->AttrVal.pAVal[0].valLen;
                    TmpString1.MaximumLength = TmpString1.Length;

                    ASSERT(NULL!=TmpString1.Buffer);

                    ASSERT(3==pEntinf->Entinf.AttrBlock.attrCount);
                    // ASSERT(1==pEntinf->Entinf.AttrBlock.pAttr[0].AttrVal.valCount);

                    for (valIndex = 0; 
                         valIndex < pEntinf->Entinf.AttrBlock.pAttr[0].AttrVal.valCount;
                         valIndex++)
                    {
                        TmpString2.Buffer=(WCHAR *)pEntinf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[valIndex].pVal;
                        TmpString2.Length=(USHORT)pEntinf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[valIndex].valLen;
                        TmpString2.MaximumLength = TmpString2.Length;

                        ASSERT(NULL!=TmpString2.Buffer);

                        //
                        // Do a Case In-Sensitive Comparison
                        //

                        if (0==RtlCompareUnicodeString(&TmpString1,&TmpString2,TRUE))
                        {
                            pMatchingEntinfList[NumMatches] = pEntinf;
                            NumMatches++;
                            MatchingEntInf = pEntinf;
                            Matched = TRUE;
                            break;
                        }
                    }
                }
                else
                {
                    //
                    // Consider it a match if no manual comparison was requested.
                    //
                    pMatchingEntinfList[NumMatches]=pEntinf;
                    NumMatches++;
                    MatchingEntInf = pEntinf;
                    Matched = TRUE;
                }


        #if DBG
                //
                // On Checked Builds print out information regarding conflicting
                // object's if more that one object was returned. Some legal cases
                // will also be printed out but, that is rare enough that this much
                // support is adequate.
                //

                if ((Matched) && (SearchRes->count>1))
                {
                    SampDiagPrint(OBJECT_CONFLICT,("[SAMSS]:Conflict Object is %S\n",
                                    &(pEntinf->Entinf.pName->StringName)));
                }

        #endif
                pEntinf = pEntinf->pNextEntInf;
            }

            if (NumMatches >1)
            {

                //
                // If There were more than one match then call the routine. It is an internal
                // problem such as duplicate SIDs or Sam Account Names. SampHandleDuplicates
                // handles many cases of such duplicates.
                //
                if ( Flags & SAM_UPGRADE_FROM_REGISTRY ) {

                    ASSERT( (Flags & SAM_UNICODE_STRING_MANUAL_COMPARISON) == 0 );

                    //
                    // Since manual comparison was not done, NumMatches will
                    // always be greater that one if any duplicates were found.
                    // In the upgrade case, don't event log the duplicates;
                    // the upgrader code will log an event indicating the RDN
                    // for the account is not the samaccountname.
                    //

                    //
                    // Return the first one
                    //
                    FoundObject = MatchingEntInf->Entinf.pName;

                    Status = STATUS_SUCCESS;

                } else {

                    Status = SampHandleDuplicates(
                                AttributeToMatch->attrTyp,
                                NumMatches,
                                pMatchingEntinfList,
                                &FoundObject
                                );


                }


                if (!NT_SUCCESS(Status))
                {
                    goto Error;
                }

            }
            else if (0==NumMatches)
            {
                //
                // If there were no matches then error out.
                //
                Status = STATUS_NOT_FOUND;
                goto Error;
            }
            else
            {

                //
                // Allocate Memory to hold that object, and copy in its Value
                //

                ASSERT(NULL!=MatchingEntInf);
                FoundObject = MatchingEntInf->Entinf.pName;
            }
        }

    }

    *Object = MIDL_user_allocate(FoundObject->structLen);
    if (NULL==*Object)
    {
        Status = STATUS_NO_MEMORY;
        goto Error;
    }

    RtlCopyMemory(*Object,
                  FoundObject,
                  FoundObject->structLen
                  );

Error:

    //
    // Clear any errors
    //

    SampClearErrors();

    //
    // Turn the fDSA flag back on as in loopback cases this can get reset
    //

    SampSetDsa(TRUE);


    return Status;
}


NTSTATUS
SampDsDoSearch2(
                ULONG    Flags,
                RESTART *Restart,
                DSNAME  *DomainObject,
                FILTER  *DsFilter,
                int      Delta,
                SAMP_OBJECT_TYPE ObjectTypeForConversion,
                ATTRBLOCK *  AttrsToRead,
                ULONG   MaxMemoryToUse,
                ULONG   TimeLimit,
                SEARCHRES **SearchRes
                )
/*++

  Routine Description:

   This routine calls a DS Search to list a set of Objects with
   the given Filter. The user passes in a Filter Structure. PagedResults
   are always requested.

     WARNING

          This Routine Translates only the incoming Attributes To Read, and
          does not translate either the filter structure or the returned
          attributes. This is done for the sake of efficiency as otherwise
          it requires a second walk through cumbersome filter structures and
          potentially large number of search results.

  Arguments:

        Restart         - Pointer to Restart Structure to contine an
                          old search
        ContainerObject - The place to Search in
        DsFilter        - A Ds Filter Structure that is passed in
        StartingIndex   - The number of initial objects to skip
        ObjectTypeForConversion -  Sam Object Type to be used in
                          AttrBlock Conversion of the passed in Attrblock.
        AttrsToRead     - Attributes to be read back, and returned with
                          every object that matched the search criteria.
        MaxMemoryToUse  - The Maximum Memory to Use.
        TimeLimit       - In milliseconds
        SearchRes       - Pointer to Search Results is passed back
                          in this

  Return Values
        DS error codes Mapped to NT Status

--*/
{
    SEARCHARG   SearchArg;
    ENTINFSEL   EntInfSel;
    ULONG       RetCode;
    COMMARG     *pCommArg;
    NTSTATUS    Status = STATUS_SUCCESS;

    SAMTRACE("SampDsDoSearch");

    *SearchRes = NULL;

    // Perform lazy thread and transaction initialization.
    Status = SampDoImplicitTransactionStart(TransactionRead);

    if (Status!= STATUS_SUCCESS)
        return(Status);

    //
    // Build the SearchArg Structure
    //

    memset(&SearchArg, 0, sizeof(SEARCHARG));
    SearchArg.pObject = DomainObject;
    SearchArg.pFilter = DsFilter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = & EntInfSel;
    SearchArg.bOneNC = TRUE;

    // 
    // For builtin domain, use one level search
    // For account domain, use subtree search
    //
    // Reason: During normal operation, the ancestry of NC heads, as well as well-known 
    // containers (such as Builtin), never changes. In our domain rename scenario, we have 
    // changed the ancestry of ALL objects in the database. It takes at least a few hours 
    // for the SDP to complete the propagation pass, which takes place after the reboot.
    // That means during the reboot after domain rename, before ancestors index has been 
    // fixed up by SDP, subtree search will not return correct result. This caused a problem
    // to SAM builtin domain alias membership cache, which was scheduled to initialize 2.5 
    // minutes after system startup. To fix the SAM builtin domain alias cache problem, 
    // we will switch to one level search which is not affected by ancestor index. 
    // Also DS team will fix the incorrect subtree search if ancestors is in flux in longhorn.
    // (for detail, see RAID 700415)
    // 
    if (SampUseDsData &&
        NameMatched(DomainObject, SampDefinedDomains[DOMAIN_START_DS].Context->ObjectNameInDs)) 
    {
        SearchArg.choice = SE_CHOICE_IMMED_CHLDRN;
    }
    else
    {
        SearchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    }

    //
    // Fill the ENTINF Structure
    //

    EntInfSel.attSel = EN_ATTSET_LIST;
    //EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntInfSel.infoTypes = EN_INFOTYPES_SHORTNAMES;

    //
    // Map the Passed in Sam Attribute Type to
    // DS Attribute Type
    //

    //
    // First allocate space in stack for the Attrblock to be passed
    // down into the DS
    //

    SAMP_ALLOCA(EntInfSel.AttrTypBlock.pAttr,AttrsToRead->attrCount * sizeof(ATTR));
    if (NULL==EntInfSel.AttrTypBlock.pAttr)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Status = SampSamToDsAttrBlock(
                ObjectTypeForConversion,
                AttrsToRead,
                ( MAP_RID_TO_SID      |
                  IGNORE_GROUP_UNUSED_ATTR),
                NULL,
                & EntInfSel.AttrTypBlock
                );

    //
    // Build the CommArg Structure
    // Build the Commarg structure
    // Get the address of the service control structure
    //

    pCommArg = &(SearchArg.CommArg);
    BuildStdCommArg(pCommArg);

    //
    // Request For Paged Results
    //

    pCommArg->PagedResult.fPresent = TRUE;
    pCommArg->PagedResult.pRestart = Restart;

    //
    // Set our memory size
    //

    pCommArg->ulSizeLimit = MaxMemoryToUse;

    //
    // Set Delta
    //

    pCommArg->Delta = Delta;

    //
    // Search deleted objects
    //

    if (Flags & SAM_MAKE_DEL_AVAILABLE)
    {
        pCommArg->Svccntl.makeDeletionsAvail = TRUE;
    }

    //
    // Set any requested time limit
    //
    if (0!=TimeLimit)
    {
        pCommArg->StartTick = GetTickCount();
        if(0==pCommArg->StartTick) {
            pCommArg->StartTick = 0xFFFFFFFF;
        }
        pCommArg->DeltaTick = TimeLimit;
    }

    //
    // Make the Directory call
    //

    SAMTRACE_DS("DirSearch\n");

    RetCode = DirSearch(&SearchArg, SearchRes);

    SAMTRACE_RETURN_CODE_DS(RetCode);

    //
    // Map Errors
    //

    if (NULL==*SearchRes)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        Status  = SampMapDsErrorToNTStatus(RetCode,&(*SearchRes)->CommRes);
    }

    //
    // Clear any errors
    //

    SampClearErrors();

    //
    // Turn the fDSA flag back on as in loopback cases this can get reset
    //

    SampSetDsa(TRUE);



    //
    // Return error code
    //

    return Status;
}

NTSTATUS
SampDsLookupObjectByNameEx(
    IN DSNAME * DomainObject,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PUNICODE_STRING ObjectName,
    OUT DSNAME ** Object,
    ULONG SearchFlags
    )
/*++

    Routine Description:

        Does a Name to Object Mapping.

    Arguments:
        ContainerObject -- The container in which to search the object
        ObjectType -- The type of the Object.
        ObjectName -- Unicode name of the Object to be located
        Object -- DSNAME structure specifying the object
        SearchFlags -- flags to pass through to SampDsDoUniqueSearch

    Return Values:

            STATUS_UNSUCCESSFUL
            Returned Status from SampDoDsSearch

--*/

{

    NTSTATUS    Status = STATUS_SUCCESS;
    ATTRVAL     NameVal;
    ATTR        NameAttr;
    PSID        DomainSid;


    SAMTRACE("SampDsLookupObjectByName");

    SampDiagPrint(LOGON,("[SAMSS] DsLookupObjectByName  on %S\n",ObjectName->Buffer));

    //
    // The Name is a property stored in the object
    // and we search for it.
    //

    //
    // setup the attribute field for the search
    //
    NameVal.valLen = (ObjectName->Length);
    NameVal.pVal = (UCHAR *) ObjectName->Buffer;
    NameAttr.AttrVal.valCount = 1;
    NameAttr.AttrVal.pAVal = & NameVal;

    switch (ObjectType)
    {
    case SampGroupObjectType:
        NameAttr.attrTyp =
            SampDsAttrFromSamAttr(ObjectType,SAMP_GROUP_NAME);
        break;

    case SampUserObjectType:
        NameAttr.attrTyp =
            SampDsAttrFromSamAttr(ObjectType,SAMP_USER_ACCOUNT_NAME);
        break;

    case SampAliasObjectType:
        NameAttr.attrTyp =
            SampDsAttrFromSamAttr(ObjectType,SAMP_ALIAS_NAME);
        break;

    case SampUnknownObjectType:
        NameAttr.attrTyp =
            SampDsAttrFromSamAttr(ObjectType,SAMP_UNKNOWN_OBJECTNAME);
        break;
    default:
        ASSERT(FALSE);
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }


    DomainSid = SampDsGetObjectSid(DomainObject);
    Status = SampDsDoUniqueSearch(SearchFlags,DomainObject,&NameAttr,Object);

    if ((NT_SUCCESS(Status)) && (NULL!=DomainSid)
            && ((*Object)->SidLen>0) && (RtlValidSid(&(*Object)->Sid)))
    {
        NT4SID AccountSid;

        //
        // Filter out Additionaly by SID, since the builtin domain is
        // under the domain object and we don't want builtin domain
        // security prinicpals to show up on the account dommain
        //


        RtlCopyMemory(&AccountSid,&(*Object)->Sid,sizeof(NT4SID));
        (*(RtlSubAuthorityCountSid(&AccountSid)))--;
        if (!RtlEqualSid(&AccountSid,DomainSid))
        {
            MIDL_user_free(*Object);
            *Object=NULL;
            Status = STATUS_NOT_FOUND;
        }
    }

    SampDiagPrint(LOGON,("[SAMSS] Returns Status %d\n",Status));

Error:

    return(Status);
}

NTSTATUS
SampDsLookupObjectByName(
    IN DSNAME * DomainObject,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PUNICODE_STRING ObjectName,
    OUT DSNAME ** Object
    )
{
    return SampDsLookupObjectByNameEx( DomainObject,
                                       ObjectType,
                                       ObjectName,
                                       Object,
                                       SAM_UNICODE_STRING_MANUAL_COMPARISON );

}

NTSTATUS
SampDsObjectFromSid(
    IN PSID Sid,
    OUT DSNAME ** Object
    )
/*++

    This routine searches the local Database for a Sid
    in the local DS Database.

  Arguments:

    Sid -- SID of the object
    DsName -- DS NAME of the located object.


  Return Values:

    STATUS_SUCCESS
    STATUS_NOT_FOUND
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTR     SidAttr;
    ATTRVAL  SidVal;
    DSNAME   RootObject;

    SAMTRACE("SampDsObjectFromSid");



    //
    //  Set up the Sid Attribute
    //

    SidAttr.attrTyp = SampDsAttrFromSamAttr(
                        SampUnknownObjectType,
                        SAMP_UNKNOWN_OBJECTSID
                        );

    SidAttr.AttrVal.valCount = 1;
    SidAttr.AttrVal.pAVal = &SidVal;
    SidVal.valLen = RtlLengthSid(Sid);
    SidVal.pVal = (UCHAR *)Sid;


    //
    // Specify Root domain  as base of Search
    //


    Status = SampDsDoUniqueSearch(
                 0,           // Flags
                 ROOT_OBJECT, // Search Base
                 &SidAttr,    // Sid
                 Object       // Get Results in Here.
                );

    return Status;

}


PSID
SampDsGetObjectSid(
    IN DSNAME * Object
    )
/*++
Routine Description:

  Given the DSNAME of the Object this routine returns the Sid
  of the Object.

  Arguments:

  Object:
        Object whose Sid needs returning

  Return Values:
     Sid of the object.
     NULL if no Sid exists
--*/
{

    ATTR SidAttr;
    ATTRBLOCK SidAttrBlock;
    ATTRBLOCK Result;
    NTSTATUS  Status;
    ULONG     i, sidLen;
    PSID      pSid;

    SAMTRACE("SampDsGetObjectSid");

    // We're either going to do a SampDsRead or a DSAlloc, both
    // of which need a DS transaction.  So start it now.

    Status = SampDoImplicitTransactionStart(TransactionRead);

    if ( !NT_SUCCESS(Status) )
    {
        return(NULL);
    }

    //
    // Check if the SID portion is filled in
    //
    if (Object->SidLen>0)
     {
        // Return a thread state allocated SID just like the search
        // based code does.

        sidLen = Object->SidLen;

        pSid = (PSID) DSAlloc(sidLen);

        if ( NULL != pSid )
        {
            Status = RtlCopySid(sidLen, pSid, &Object->Sid);

            ASSERT(NT_SUCCESS(Status));
        }

        return(pSid);
    }

    //
    // Read the Database to obtain the SID
    //


    SidAttrBlock.attrCount =1;
    SidAttrBlock.pAttr = &(SidAttr);

    SidAttr.AttrVal.valCount =0;
    SidAttr.AttrVal.pAVal = NULL;
    SidAttr.attrTyp = SAMP_UNKNOWN_OBJECTSID;

    Status = SampDsRead(
                   Object,
                   0,
                   SampUnknownObjectType,
                   & SidAttrBlock,
                   & Result
                   );

    if (Status != STATUS_SUCCESS)
        return NULL;

    return Result.pAttr[0].AttrVal.pAVal->pVal;
}

NTSTATUS
SampDsRemoveDuplicateRids(
    IN DSNAME * DomainObject,
    IN ULONG ObjectRid
    )
/*++

Routine Description:

    This routine removes any objects with identical ObjectRid's.  Note that
    this routine specifies the "make deletions available" flag, so will
    remove accounts with the same SID even if they are deleted.

Arguments:

    ContainerObject -- The container in which to locate this object
    ObjectRid  -- RID of the object to be located

  Return Values:
  
    STATUS_SUCCESS on successful completion
    Any returned by SampDsDoSearch

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTRVAL  RidVal = {sizeof(ULONG), (UCHAR *)&ObjectRid};
    ATTR     RidAttr = {SAMP_UNKNOWN_OBJECTRID, {1, &RidVal}};
    PSID     DomainSid;
    ATTR     SidAttr;
    BOOLEAN  WellKnownAccount;
    DSNAME   *Object = NULL;

    SAMTRACE("SampDsRemoveDuplicateRids");

    DomainSid = SampDsGetObjectSid(DomainObject);

    if (DomainSid == NULL) {
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    SidAttr.attrTyp = SampDsAttrFromSamAttr(
                        SampUnknownObjectType,
                        SAMP_UNKNOWN_OBJECTSID
                        );


    Status = SampDsSetNewSidAttribute(
                        DomainSid,
                        REALLOC_IN_DSMEMORY,
                        &RidAttr,
                        &SidAttr,
                        &WellKnownAccount
                        );

    if (!NT_SUCCESS(Status))
        goto Error;

    Status = SampDsDoUniqueSearch(SAM_MAKE_DEL_AVAILABLE,
                                  DomainObject,
                                  &SidAttr,
                                  &Object);


Error:

    if (Object != NULL) {
        MIDL_user_free(Object);
    }

    return Status;

}



NTSTATUS
SampDsLookupObjectByRid(
    IN DSNAME * DomainObject,
    IN ULONG ObjectRid,
    OUT DSNAME **Object
    )
/*++

Routine Description:

  RID to Object Mapping

Arguments:

        ContainerObject -- The container in which to locate this object
        ObjectRid  -- RID of the object to be located
        Object     -- returns pointer to DSNAME structure specifying the object

  Return Values:
            STATUS_SUCCESS on successful completion
            Any returned by SampDsDoSearch

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTRVAL  RidVal = {sizeof(ULONG), (UCHAR *)&ObjectRid};
    ATTR     RidAttr = {SAMP_UNKNOWN_OBJECTRID, {1, &RidVal}};
    PSID     DomainSid;
    ATTR     SidAttr;
    BOOLEAN  WellKnownAccount;

    SAMTRACE("SampDsLookupObjectByRid");

    DomainSid = SampDsGetObjectSid(DomainObject);


    if (DomainSid == NULL)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    SidAttr.attrTyp = SampDsAttrFromSamAttr(
                        SampUnknownObjectType,
                        SAMP_UNKNOWN_OBJECTSID
                        );


    Status = SampDsSetNewSidAttribute(
                        DomainSid,
                        REALLOC_IN_DSMEMORY,
                        &RidAttr,
                        &SidAttr,
                        &WellKnownAccount
                        );

    if (Status != STATUS_SUCCESS)
        goto Error;

    Status = SampDsDoUniqueSearch(0,DomainObject,&SidAttr,Object);


Error:

    return Status;

}

NTSTATUS
SampDsLookupObjectBySid(
    IN DSNAME * DomainObject,
    PSID ObjectSid,
    DSNAME **Object
    )
/*++

Routine Description:

  SID to Object Mapping

Arguments:

        ContainerObject -- The container in which to locate this object
        ObjectSid       -- SID of the object to be located
        Object          -- returns pointer to DSNAME structure specifying the object

  Return Values:
            STATUS_SUCCESS on successful completion
            Any returned by SampDsDoSearch

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTR     SidAttr;

    SAMTRACE("SampDsLookupObjectBySid");

    SidAttr.attrTyp = SampDsAttrFromSamAttr(
                        SampUnknownObjectType,
                        SAMP_UNKNOWN_OBJECTSID
                        );

    SidAttr.AttrVal.pAVal = DSAlloc(sizeof(ATTRVAL));

    if (NULL == SidAttr.AttrVal.pAVal)
    {
        Status = STATUS_NO_MEMORY;
        goto Error;
    }

    SidAttr.AttrVal.valCount = 1;
    SidAttr.AttrVal.pAVal->valLen = RtlLengthSid(ObjectSid);
    SidAttr.AttrVal.pAVal->pVal = ObjectSid;

    Status = SampDsDoUniqueSearch(0,DomainObject,&SidAttr,Object);


Error:

    return Status;

}

NTSTATUS
SampMapDsErrorToNTStatus(
    ULONG   DsRetVal,
    COMMRES *ComRes
    )
/*++

Routine Description:

    Maps a DS error to NTSTATUS

Arguments:
    DsRetVal -- The DS return Value
    ComRes   -- The Common results structure, contains
                information regarding the error.

Return Values:
    See the switch statement below

--*/
{
    ULONG ExtendedErr = 0;

    if (   ComRes
        && ComRes->pErrInfo ) {

        switch (ComRes->errCode) {
        case attributeError:
            ExtendedErr = ComRes->pErrInfo->AtrErr.FirstProblem.intprob.extendedErr;
            break;
        case nameError:
            ExtendedErr = ComRes->pErrInfo->NamErr.extendedErr;
            break;
        case referralError:
            ExtendedErr = ComRes->pErrInfo->RefErr.extendedErr;
            break;
        case securityError:
            ExtendedErr = ComRes->pErrInfo->SecErr.extendedErr;
            break;
        case serviceError:
            ExtendedErr = ComRes->pErrInfo->SvcErr.extendedErr;
            break;
        case updError:
            ExtendedErr = ComRes->pErrInfo->UpdErr.extendedErr;
            break;
        case systemError:
            ExtendedErr = ComRes->pErrInfo->SysErr.extendedErr;
            break;
        }
    }

    //
    // create a fast path for the success case
    //

    if ((0==DsRetVal ) && (0==ExtendedErr)) {

        return(STATUS_SUCCESS);
    }

    if ( ExtendedErr == ERROR_DS_NAME_REFERENCE_INVALID ) {

        //
        // This will occur when trying to add a user to a group
        // and the user doesn't exist
        //
        return STATUS_NO_SUCH_USER;

    } else if ( ExtendedErr == ERROR_DS_DUPLICATE_ID_FOUND ) {

        //
        // This is returned when a duplicate SID is found
        //
        return STATUS_DS_DUPLICATE_ID_FOUND;

    }

    return DirErrorToNtStatus( DsRetVal, ComRes );
}



NTSTATUS
SampSamToDsAttrBlock(
            IN SAMP_OBJECT_TYPE ObjectType,
            IN ATTRBLOCK  *AttrBlockToConvert,
            IN ULONG      ConversionFlags,
            IN PSID       DomainSid,
            OUT ATTRBLOCK * ConvertedAttrBlock
            )
/*++

Routine Description:

    Converts the Attribute types in an Attrblock
    from SAM to DS Types. This routine can do various things depending upon
    the flags that are passed in.

Arguments:

    ObjectType           -- specifies type of SAM object

    AttrBlockToConvert   -- pointer to Attrblock to be converted

    ConversionFlags      -- The Type of conversion Desired. Currently
                            defined values are

                            ALREADY_MAPPED_ATTRIBUTE_TYPES

                                This flag indicates that the attribue types
                                has alreade been mapped from SAM attribute types
                                to DS attribute types. So no need to map again.

                            REALLOC_IN_DSMEMORY

                                This flag indicates that the new attrblock to be created
                                requires its pAttr Structure and all values hanging off
                                this structure to be realloc'd using the DS thread memory.
                                The rationale for this is that the DS does not treat many
                                of the in parameters as strictly in-parameters but rather
                                reallocs them using the thread heap. This is typically done
                                in the AddEntry case ( to add default parameters ) etc.


                                REALLOC_IN_DSMEMORY must be specified if either the
                                ADD_OBJECT_CLASS_ATTRIBUTE is specified or if values are
                                present.

                            ADD_OBJECT_CLASS_ATTRIBUTE

                                This flag makes this routine to add the object class attribute
                                and also the corresponding SAM account types to the attr block.
                                This flag is also passed in during the AddEntry Case. The value
                                of the object class attribute is computed using the passed in
                                Sam Object Type.  REALLOC_IN_DSMEMORY must be specified if the
                                Add object class attribute flag is specified.


                            MAP_RID_TO_SID

                                In a number of places in the SAM code the SAM deals with Rids.
                                These are really stored as Sids in the DS. Passing this flag
                                uses the DomainSid parameter and maps all Rids to Sids.

                            DOMAIN_TYPE_BUILTIN

                                This flag is used with the ADD_OBJECT_CLASS_ATTRIBUTE. This flag
                                indicates that the security principal involved belongs to the
                                builtin domain. This is used in 2 ways

                                1. Determination of Object class when creating a domain object
                                   ( DOMAIN_DNS vs Builtin Domain )

                                2. Set System Flags, add an additional Group Type Bit etc when
                                   creating builtin domain security principals


                            IGNORE_GROUP_UNUSED_ATTR

                                Group Membership in the old registry based SAM was represented
                                using an array of Rids. The SAM buffers have space for it, and
                                the attrblock to SAM buffer conversion code still deals with this
                                To be sure that we never will ever write the old registry based
                                membership data to the DS, this flag tells this routine to skip
                                all the Group-Unused Attrs. It also asserts that this attribute
                                is never passed down.

                            ADVANCED_VIEW_ONLY
                            
                                Indicates to create the object with the 
                                advanced view only set to TRUE
                                
                            FORCE_NO_ADVANCED_VIEW_ONLY
                            
                                Indicates to add the advanced view only and set
                                to FALSE.  This can be used to override schema
                                defaults (as was done in Windows 2000)

    DomainSid            -- Used to Compose the Sid of the Object when the MAP_RID_TO_SID flag is
                            specified.

    ConvertedAttrBlock   -- The Converted DS AttrBlock.


Return Values:
    None

--*/
{

    ULONG Index;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN  WellKnownAccount = FALSE;
    ULONG  DsSidAttr = SampDsAttrFromSamAttr(
                            SampUnknownObjectType,
                            SAMP_UNKNOWN_OBJECTSID
                            );

    ULONG  DsRidAttr = SampDsAttrFromSamAttr(
                            SampUnknownObjectType,
                            SAMP_UNKNOWN_OBJECTRID
                            );

    ULONG SamAccountControlBuffer, *SamAccountControl = NULL;

    ULONG ExtraAttrIndex;

    ULONG GroupType = 0;

    SAMTRACE("SampSamToDsAttrBlock");


    //
    // Both DOMAIN_TYPE_BUILTIN and ADVANCED_VIEW_ONLY add attributes
    // to the block, so this must be an addition.
    //
    ASSERT((ConversionFlags & DOMAIN_TYPE_BUILTIN)?
        (ConversionFlags & ADD_OBJECT_CLASS_ATTRIBUTE):TRUE);

    ASSERT((ConversionFlags & ADVANCED_VIEW_ONLY)?
        (ConversionFlags & ADD_OBJECT_CLASS_ATTRIBUTE):TRUE);

    ASSERT((ConversionFlags & FORCE_NO_ADVANCED_VIEW_ONLY)?
        (ConversionFlags & ADD_OBJECT_CLASS_ATTRIBUTE):TRUE);

    //
    // If Add Object Class attribute was specified then Realloc in
    // DS memory must be specified.
    //

    ASSERT((ConversionFlags & ADD_OBJECT_CLASS_ATTRIBUTE)?
        (ConversionFlags & REALLOC_IN_DSMEMORY):TRUE);



    //
    // Copy the Fixed Portion
    //

    ConvertedAttrBlock->attrCount = AttrBlockToConvert->attrCount;

    if (ConversionFlags & REALLOC_IN_DSMEMORY)
    {

        ULONG   AttrsToAllocate = AttrBlockToConvert->attrCount;

        if ((ConversionFlags & ADVANCED_VIEW_ONLY) ||
            (ConversionFlags & FORCE_NO_ADVANCED_VIEW_ONLY)) {

            AttrsToAllocate+=1;

        }

        if (ConversionFlags & DOMAIN_TYPE_BUILTIN)
        {
            //
            //  If this is a Builtin Domain Object.
            //  allocate 1 more attribute: ATT_SYSTEM_FLAGS
            //
            AttrsToAllocate+=1;
        }



        if (ConversionFlags & ADD_OBJECT_CLASS_ATTRIBUTE)
        {
            //
            //  Caller requested that an object class attribute
            //  be added, alloc two more attr, one for object class,
            //  one for Sam Account Type, and one
            //  if necessary for Critical System Object
            //

            AttrsToAllocate+=3 ;
        }

        //
        // Realloc and Copy the pAttr portion of it.
        //

        ConvertedAttrBlock->pAttr = DSAlloc(
                                        AttrsToAllocate
                                        * sizeof(ATTR)
                                        );

        if (NULL==ConvertedAttrBlock->pAttr)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        RtlCopyMemory(
            ConvertedAttrBlock->pAttr,
            AttrBlockToConvert->pAttr,
            AttrBlockToConvert->attrCount * sizeof(ATTR)
            );

        ConvertedAttrBlock->attrCount = AttrsToAllocate;

    }
    else
    {
        //
        // Assert that the caller has already allocated space
        // for the pAttr structure
        //

        ASSERT(ConvertedAttrBlock->pAttr!=NULL);

        //
        // Initialize that to Zero
        //

        RtlZeroMemory(
            ConvertedAttrBlock->pAttr,
            sizeof(ATTR) *ConvertedAttrBlock->attrCount
            );
    }

    for (Index=0; Index<AttrBlockToConvert->attrCount;Index++)
    {

        //
        // MAP Sam Attribute Types to DS Types if that was requested
        //

        if ( !(ConversionFlags & ALREADY_MAPPED_ATTRIBUTE_TYPES) )
        {
            ConvertedAttrBlock->pAttr[Index].attrTyp =
                    SampDsAttrFromSamAttr(
                        ObjectType,
                        AttrBlockToConvert->pAttr[Index].attrTyp
                        );
        }
        else
        {
            ConvertedAttrBlock->pAttr[Index].attrTyp =
                AttrBlockToConvert->pAttr[Index].attrTyp;
        }


        //
        //
        // Handle the Conversion of the Attribute Value
        //
        //

        if ( (ConversionFlags & MAP_RID_TO_SID)
             &&(ConvertedAttrBlock->pAttr[Index].attrTyp == DsRidAttr)
            )

        {
            //
            // if Attribute is Rid, Map Rid to Sid
            //

            ConvertedAttrBlock->pAttr[Index].attrTyp = DsSidAttr;
            Status = SampDsSetNewSidAttribute(
                        DomainSid,
                        ConversionFlags,
                        & (AttrBlockToConvert->pAttr[Index]),
                        & (ConvertedAttrBlock->pAttr[Index]),
                        & WellKnownAccount
                        );

            if (!(NT_SUCCESS(Status)))
                goto Error;
        }
        else if (NULL!= AttrBlockToConvert->pAttr[Index].AttrVal.pAVal)
        {

            //
            //  Else if a value is present then Copy the attribute
            //  value
            //


            Status = SampDsCopyAttributeValue(
                        & (AttrBlockToConvert->pAttr[Index]),
                        & (ConvertedAttrBlock->pAttr[Index])
                        );


            //
            // Translate User Account Control Values from SAM User Account control
            // to UF Values
            //

            if ((ATT_USER_ACCOUNT_CONTROL==ConvertedAttrBlock->pAttr[Index].attrTyp)
                    && ( NULL!=ConvertedAttrBlock->pAttr[Index].AttrVal.pAVal[0].pVal))
            {


                PULONG UserAccountControl;

                UserAccountControl = (ULONG*)ConvertedAttrBlock->pAttr[Index].AttrVal.pAVal[0].pVal;

                SamAccountControl = &SamAccountControlBuffer;
                SamAccountControlBuffer = *UserAccountControl;

                *UserAccountControl = SampAccountControlToFlags(*UserAccountControl);
            }

            if ( (ATT_GROUP_TYPE == ConvertedAttrBlock->pAttr[Index].attrTyp)
              && (NULL !=ConvertedAttrBlock->pAttr[Index].AttrVal.pAVal[0].pVal)  ) {

                GroupType = *((ULONG*)ConvertedAttrBlock->pAttr[Index].AttrVal.pAVal[0].pVal);

            }
        }
        else
        {
            //
            // No Value is present, just zero out the value
            // portions
            //

            ConvertedAttrBlock->pAttr[Index].AttrVal.valCount=0;
            ConvertedAttrBlock->pAttr[Index].AttrVal.pAVal = NULL;
        }

    }

    //
    // If this is a Builtin Domain Object
    // then add ATT_SYSTEM_FLAGS
    //

    ExtraAttrIndex = AttrBlockToConvert->attrCount;
    if (ConversionFlags & DOMAIN_TYPE_BUILTIN)
    {

        ATTR    *SysFlagsAttr;


        SysFlagsAttr =
            &(ConvertedAttrBlock->pAttr[ExtraAttrIndex]);
        SysFlagsAttr->attrTyp = ATT_SYSTEM_FLAGS;
        SysFlagsAttr->AttrVal.valCount = 1;
        SysFlagsAttr->AttrVal.pAVal = DSAlloc(sizeof(ATTRVAL));

        if (NULL == SysFlagsAttr->AttrVal.pAVal)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        SysFlagsAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
        SysFlagsAttr->AttrVal.pAVal->pVal = DSAlloc(sizeof(ULONG));

        if (NULL == SysFlagsAttr->AttrVal.pAVal->pVal)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }
        *((ULONG *) SysFlagsAttr->AttrVal.pAVal->pVal) =
                                        FLAG_DOMAIN_DISALLOW_RENAME |
                                        FLAG_DOMAIN_DISALLOW_MOVE   |
                                        FLAG_DISALLOW_DELETE ;

        ExtraAttrIndex++;

    }

    if (   (ConversionFlags & ADVANCED_VIEW_ONLY) 
        || (ConversionFlags & FORCE_NO_ADVANCED_VIEW_ONLY)) {

        ATTR    *HideFromABAttr;
        ULONG   Value;

        if (ConversionFlags & ADVANCED_VIEW_ONLY) {
            // TRUE
            Value = 1;
        } else {
            ASSERT((ConversionFlags & FORCE_NO_ADVANCED_VIEW_ONLY));
            // FALSE
            Value = 0;
        }

        HideFromABAttr =
            &(ConvertedAttrBlock->pAttr[ExtraAttrIndex]);
        HideFromABAttr->attrTyp = ATT_SHOW_IN_ADVANCED_VIEW_ONLY;
        HideFromABAttr->AttrVal.valCount = 1;
        HideFromABAttr->AttrVal.pAVal = DSAlloc(sizeof(ATTRVAL));

        if (NULL == HideFromABAttr->AttrVal.pAVal)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        HideFromABAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
        HideFromABAttr->AttrVal.pAVal->pVal = DSAlloc(sizeof(ULONG));

        if (NULL == HideFromABAttr->AttrVal.pAVal->pVal)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }
        *((ULONG *) HideFromABAttr->AttrVal.pAVal->pVal)=Value;

    }

    //
    // If Addition of Object Class attribute was requested then
    // Add this attribute and the SAM_ACCOUNT_TYPE attribute
    //

    if (ConversionFlags & ADD_OBJECT_CLASS_ATTRIBUTE)
    {
        ULONG DsClass;
        ULONG SamAccountType;
        ATTR    *ObjectClassAttr;
        ATTR    *SamAccountTypeAttr;
        BOOLEAN SetSamAccountType = TRUE;
        BOOLEAN SetGroupType = TRUE;
        BOOLEAN DcAccount=FALSE;


        //
        //  Find the object class, and SAM account type to Use
        //
        if ( (ObjectType == SampGroupObjectType) ||
             (ObjectType == SampAliasObjectType) ) {
            // Group type must be specified
            ASSERT(GroupType != 0);
        }

        SampDsComputeObjectClassAndAccountType(
                ObjectType,
                SamAccountControl,
                ConversionFlags,
                GroupType,
                &DsClass,
                &SamAccountType,
                &SetSamAccountType,
                &DcAccount
                );

        //
        // Set the object class Attr
        //

        ObjectClassAttr =
            &(ConvertedAttrBlock->pAttr[ConvertedAttrBlock->attrCount-3]);
        ObjectClassAttr->attrTyp = SampDsAttrFromSamAttr(
                                        SampUnknownObjectType,
                                        SAMP_UNKNOWN_OBJECTCLASS
                                    );
        ObjectClassAttr->AttrVal.valCount = 1;
        ObjectClassAttr->AttrVal.pAVal = DSAlloc(sizeof(ATTRVAL));
        if (NULL== ObjectClassAttr->AttrVal.pAVal)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        ObjectClassAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
        ObjectClassAttr->AttrVal.pAVal->pVal = DSAlloc(sizeof(ULONG));
        if (NULL== ObjectClassAttr->AttrVal.pAVal->pVal)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }
        *((ULONG *) ObjectClassAttr->AttrVal.pAVal->pVal) = DsClass;


        //
        // Set the Sam Account Type attribute
        //

        if (SetSamAccountType)
        {
            SamAccountTypeAttr =
                &(ConvertedAttrBlock->pAttr[ConvertedAttrBlock->attrCount-2]);
            SamAccountTypeAttr->attrTyp = SampDsAttrFromSamAttr(
                                            SampUnknownObjectType,
                                            SAMP_UNKNOWN_ACCOUNT_TYPE
                                            );
            SamAccountTypeAttr->AttrVal.valCount = 1;
            SamAccountTypeAttr->AttrVal.pAVal = DSAlloc(sizeof(ATTRVAL));
            if (NULL== SamAccountTypeAttr->AttrVal.pAVal)
            {
                Status = STATUS_NO_MEMORY;
                goto Error;
            }

            SamAccountTypeAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
            SamAccountTypeAttr->AttrVal.pAVal->pVal = DSAlloc(sizeof(ULONG));
            if (NULL== SamAccountTypeAttr->AttrVal.pAVal->pVal)
            {
                Status = STATUS_NO_MEMORY;
                goto Error;
            }
            *((ULONG *) SamAccountTypeAttr->AttrVal.pAVal->pVal) = SamAccountType;
        }
        else
        {
            //
            // Or current attrcount includes space for the Sam account type property.
            // Since we do not plan on setting it decrement the attrcount, to reflect
            // the true number of attrs that we want to set.
            //

            ConvertedAttrBlock->attrCount--;
        }

        if (   (WellKnownAccount)
            || (DcAccount)
            || (ObjectType == SampServerObjectType)
            || (ObjectType == SampDomainObjectType) )
        {

            //
            // Set Critical System to 1
            //
            ATTR * CriticalAttr;

            CriticalAttr =
                &(ConvertedAttrBlock->pAttr[ConvertedAttrBlock->attrCount-1]);
            CriticalAttr->attrTyp = ATT_IS_CRITICAL_SYSTEM_OBJECT;
            CriticalAttr->AttrVal.valCount = 1;
            CriticalAttr->AttrVal.pAVal = DSAlloc(sizeof(ATTRVAL));
            if (NULL== CriticalAttr->AttrVal.pAVal)
            {
                Status = STATUS_NO_MEMORY;
                goto Error;
            }

            CriticalAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
            CriticalAttr->AttrVal.pAVal->pVal = DSAlloc(sizeof(ULONG));
            if (NULL== CriticalAttr->AttrVal.pAVal->pVal)
            {
                Status = STATUS_NO_MEMORY;
                goto Error;
            }
            *((ULONG *) CriticalAttr->AttrVal.pAVal->pVal) = 1;
        }
        else
        {

            ConvertedAttrBlock->attrCount--;
        }

    }


Error:

    return Status;
}


VOID
SampDsComputeObjectClassAndAccountType(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG            *SamAccountControl, OPTIONAL
    IN ULONG            Flags,
    IN ULONG            GroupType,
    OUT PULONG           DsClass,
    OUT PULONG           SamAccountType,
    OUT BOOLEAN          *SamAccountTypePresent,
    OUT BOOLEAN          *DcAccount
    )
/*++

    Routine Description

        Given an Object Type, and a attribute block that
        is being set ( as part of a create ), compute the correct
        DS object class , and the SAM account type for the object.
        This routine tries to walk the attr-block and tries to find
        the user account control property and uses this to compute the
        SAM object type value. This routine is called only during a create.
        This function also computes the Group type also if necessary

    Parameters:

        ObjectType     -- The SAM object type of the object,

        SamAccountControl --  the account control in terms of the SAM flags

        Flags          -- Flags specifier - currently no flags defined
        
        GroupType     -- the type of group

        DsClass        -- The DS object class is returned in here.

        SamAccountType -- The SAM account type of the object is returned in here

        SamAccountTypePresent -- Boolen value, indicating wether Sam Account Type
                        property needs to be set for the given object type

--*/
{
    ULONG i;

    *DcAccount = FALSE;
    switch(ObjectType)
    {
    case SampUserObjectType:
        *DsClass = SampDsClassFromSamObjectType(ObjectType);
        *SamAccountType = SAM_USER_OBJECT;

        if ( ARGUMENT_PRESENT( SamAccountControl ) )
        {
            SampDsAccountTypeFromUserAccountControl(
                    *SamAccountControl,
                    SamAccountType
                    );

            if ( (*SamAccountControl) & USER_SERVER_TRUST_ACCOUNT )
                *DcAccount = TRUE;

        }

        // Set classid to computer for machine objects
        if (SAM_MACHINE_ACCOUNT == *SamAccountType) {
            *DsClass = CLASS_COMPUTER;
        }

        *SamAccountTypePresent = TRUE;
        break;

    case SampGroupObjectType:
        *DsClass = SampDsClassFromSamObjectType(ObjectType);

        // Set the account type
        *SamAccountType = SampGetAccountTypeFromGroupType(GroupType);
        *SamAccountTypePresent = TRUE;
        break;

    case SampAliasObjectType:
        *DsClass = SampDsClassFromSamObjectType(ObjectType);

        // Set the account type
        *SamAccountType = SampGetAccountTypeFromGroupType(GroupType);
        *SamAccountTypePresent = TRUE;
        break;

    case SampDomainObjectType:
        if (Flags & DOMAIN_TYPE_BUILTIN)
        {
            *DsClass = CLASS_BUILTIN_DOMAIN;
        }
        else
        {
            // 
            // SAM should not be creating objects of class domain save for the builtin
            // container that is crated at install time and handled as above
            // If we do get a creation assert as below -- indicates a coding error
            // and default the class to CLASS_DOMAIN_DNS
            //         

            *DsClass = CLASS_DOMAIN_DNS;

            //
            // Currently we know of no code that tries to create a
            // root domain object, therefore we think we should never
            // hit this code path
            //

            ASSERT(FALSE && " Should not be creating Domain object");
        }
        //
        // Domain objects do not have the sam account type property.
        // therefore do not set this on them
        //

        *SamAccountTypePresent = FALSE;
        break;

    case SampServerObjectType:
        *DsClass = SampDsClassFromSamObjectType(ObjectType);
        *SamAccountTypePresent = FALSE;
        break;

    default:
        ASSERT(FALSE && "Unknown Object Type");
    }


}


NTSTATUS
SampDsNewAccountSid(
    PSID DomainSid,
    ULONG AccountRid,
    PSID *NewSid
    )
/*
    Routine Description

        Composes an Account Sid from the given Domain Sid and Rid.
        Uses DS thread memory. THis is the main difference between
        the function in utility.c

    Arguments:

         DomainSid   The Domain Sid
         AccountRid  The Rid
         NewSid      The final account Sid

    Return Values

        STATUS_SUCCESS
        STATUS_NO_MEMORY
*/

{

    ULONG DomainSidLength = RtlLengthSid(DomainSid);
    NTSTATUS    Status = STATUS_SUCCESS;

    SAMTRACE("SampDsNewAccountSid");

    //
    // Alloc Memory to hold the account Sid
    //

    *NewSid = DSAlloc(DomainSidLength + sizeof(ULONG));

    if (NULL==*NewSid)
    {
        Status = STATUS_NO_MEMORY;
        goto Error;
    }

    //
    // Copy the Domain Sid Part
    //

    RtlCopyMemory(*NewSid,DomainSid,DomainSidLength);

    //
    // Increment the SubAuthority Count
    //

    ((UCHAR *) *NewSid)[1]++;

    //
    // Add the RID as a sub authority
    //

    *((ULONG *) (((UCHAR *) *NewSid ) + DomainSidLength)) =
            AccountRid;

Error:

    return Status;
}


NTSTATUS
SampDsSetNewSidAttribute(
    PSID DomainSid,
    ULONG ConversionFlags,
    ATTR *RidAttr,
    ATTR *SidAttr,
    BOOLEAN * WellKnownAccount
    )
/*
    Routine Description

        Composes a DS Sid Attr , given a DS Rid Attr

  Arguments:

        Conversion Flags

                Any Value that Can be passed to the Sam to DS attrblock
                conversion functions.

                Currently only used value is REALLOC_IN_DS_MEMORY
                REALLOC_IN_DS_MEMORY must be specified if an attribute
                value is actually present for the Rid.



        RidAttr

                Rid Attribute
        SidAttr

                The Sid Attribute that is composed
*/
{

    PSID NewSid = NULL;
    ULONG AccountRid;
    NTSTATUS Status = STATUS_SUCCESS;

    SAMTRACE("SampDsSetNewSidAttribute");

    *WellKnownAccount=FALSE;

    if (
         (RidAttr->AttrVal.valCount)
         && (RidAttr->AttrVal.pAVal)
         && (RidAttr->AttrVal.pAVal->pVal)
         && (RidAttr->AttrVal.pAVal->valLen)
         )
    {
        //
        // Values are Present, assert that REALLOC is also
        // specified
        //

        ASSERT(ConversionFlags & REALLOC_IN_DSMEMORY);
        ASSERT(DomainSid!=NULL);

        if (!(ConversionFlags & REALLOC_IN_DSMEMORY))
        {
            //
            // Realloc in DS memory is not specified
            //

            Status = STATUS_NOT_IMPLEMENTED;
            goto Error;
        }

        //
        // Compose New Sid
        //

        AccountRid = * ((ULONG *)RidAttr->AttrVal.pAVal->pVal);
        Status = SampDsNewAccountSid(DomainSid,AccountRid, &NewSid);
        if (!(NT_SUCCESS(Status)))
            goto Error;


        //
        // if the Account RID is less than the well known account RID
        // of 1000 then return that information to the caller. The caller
        // will use this information to mark the object as critical.

        if (SampIsAccountBuiltIn(AccountRid))
        {
            *WellKnownAccount = TRUE;
        }

        //
        //  Alloc Memory for ATTRVAL structure
        //

        SidAttr->AttrVal.pAVal =
                            DSAlloc(sizeof(ATTRVAL));

        if (NULL== SidAttr->AttrVal.pAVal)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        //
        // Set the Value to the New Sid
        //

        SidAttr->AttrVal.valCount = 1;
        SidAttr->AttrVal.pAVal->valLen = RtlLengthSid(NewSid);
        SidAttr->AttrVal.pAVal->pVal = NewSid;
    }
    else
    {
        SidAttr->AttrVal.valCount = 0;
        SidAttr->AttrVal.pAVal = NULL;
    }

Error:


    return Status;
}


NTSTATUS
SampDsCopyAttributeValue(
    ATTR * Src,
    ATTR * Dst
    )
/*
    Routine Description

        Copies a DS Attributes Value

    Arguments:

        Src - Source Attribute
        Dst - Destination Attribute

    Return Values

        STATUS_SUCCESS
        STATUS_NO_MEMORY

*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG    Index;

    if (
         (Src->AttrVal.valCount)
         && (Src->AttrVal.pAVal)
         )
    {
        //
        // Values are Present, Copy Them
        //

        Dst->AttrVal.pAVal = DSAlloc(
                                Src->AttrVal.valCount *
                                sizeof(ATTRVAL)
                                );

        if (NULL== Dst->AttrVal.pAVal)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        Dst->AttrVal.valCount = Src->AttrVal.valCount;

        for (Index=0;Index<Src->AttrVal.valCount;Index++)
        {

            Dst->AttrVal.pAVal[Index].valLen =
                    Src->AttrVal.pAVal[Index].valLen;

            if ((Src->AttrVal.pAVal[Index].valLen)
                && (Src->AttrVal.pAVal[Index].pVal))
            {

                Dst->AttrVal.pAVal[Index].pVal =
                    DSAlloc(Src->AttrVal.pAVal[Index].valLen);
                if (NULL== Dst->AttrVal.pAVal[Index].pVal)
                    {
                        Status = STATUS_NO_MEMORY;
                        goto Error;
                    }
                RtlCopyMemory(
                        Dst->AttrVal.pAVal[Index].pVal,
                        Src->AttrVal.pAVal[Index].pVal,
                        Dst->AttrVal.pAVal[Index].valLen
                        );
            }
            else
              Dst->AttrVal.pAVal[Index].pVal = NULL;
        }
    }
    else
    {
         Dst->AttrVal.pAVal = NULL;
         Dst->AttrVal.valCount = 0;
    }

Error:

    return Status;
}



NTSTATUS
SampDsToSamAttrBlock(
            IN SAMP_OBJECT_TYPE ObjectType,
            IN ATTRBLOCK * AttrBlockToConvert,
            IN ULONG     ConversionFlags,
            OUT ATTRBLOCK * ConvertedAttrBlock
            )
/*++

Routine Description:

    Converts the Attribute types in an Attrblock
    from DS to SAM Types

Arguments:

    ObjectType           -- specifies type of SAM object
    AttrBlockToConvert   -- pointer to Attrblock to be converted
    ConversionFlags      -- The Type of Conversion Desired. Currently
                            defined values are

                                ALREADY_MAPPED_ATTRIBUTE_TYPES
                                MAP_SID_TO_RID

    ConvertedAttrBlock   -- The converted AttrBlock.

Return Values:
    None


 --*/
 {
    ULONG Index,Index2;
    ULONG   DsSidAttr = SampDsAttrFromSamAttr(
                            SampUnknownObjectType,
                            SAMP_UNKNOWN_OBJECTSID
                            );

    ULONG   DsRidAttr = SampDsAttrFromSamAttr(
                            SampUnknownObjectType,
                            SAMP_UNKNOWN_OBJECTRID
                            );

    SAMTRACE("SampDsToSamAttrBlock");

    *ConvertedAttrBlock = *AttrBlockToConvert;

    for (Index=0; Index<AttrBlockToConvert->attrCount;Index++)
    {
        //
        // MAP Any Sid Attribute to Rid Attribute
        //

        if ((ConversionFlags & MAP_SID_TO_RID) &&
            (AttrBlockToConvert->pAttr[Index].attrTyp == DsSidAttr))

        {
            ATTR * pSidAttr =  &(AttrBlockToConvert->pAttr[Index]);

            switch(ObjectType)
            {
                case SampGroupObjectType:
                case SampAliasObjectType:
                case SampUserObjectType:

                    //
                    // Map the Attr Type
                    //

                    pSidAttr->attrTyp = DsRidAttr;

                    //
                    // Map the Attr Value, the Last ULONG in the Sid
                    // is the Rid, so advance the pointer accordingly
                    //

                    pSidAttr->AttrVal.pAVal->pVal+=
                        pSidAttr->AttrVal.pAVal->valLen - sizeof(ULONG);
                    pSidAttr->AttrVal.pAVal->valLen = sizeof(ULONG);

                default:
                    break;
            }
        }

        //
        //  MAP Attribute Types
        //

        if ( !(ConversionFlags & ALREADY_MAPPED_ATTRIBUTE_TYPES) )
        {
            ConvertedAttrBlock->pAttr[Index].attrTyp =
                SampSamAttrFromDsAttr(
                    ObjectType,
                    AttrBlockToConvert->pAttr[Index].attrTyp
                    );
        }

        //
        // Translate User Account Control From Flags which are stored in
        // the DS.
        //

        if ((SampUserObjectType==ObjectType)
                && (SAMP_FIXED_USER_ACCOUNT_CONTROL==ConvertedAttrBlock->pAttr[Index].attrTyp)
                && (NULL!=ConvertedAttrBlock->pAttr[Index].AttrVal.pAVal[0].pVal))
        {
            NTSTATUS IgnoreStatus;
            PULONG UserAccountControl;

            UserAccountControl = (ULONG*)ConvertedAttrBlock->pAttr[Index].AttrVal.pAVal[0].pVal;

            IgnoreStatus = SampFlagsToAccountControl(*UserAccountControl,UserAccountControl);
            // What's stored in the DS better be valid
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }


    } // End of For Loop

    return STATUS_SUCCESS;

}


NTSTATUS
SampDsCreateDsName2(
            IN DSNAME * DomainObject,
            IN PUNICODE_STRING AccountName,
            IN ULONG           Flags,
            IN OUT DSNAME ** NewObject
            )
/*++
    Routine Description

        Builds a DSName given the account Name and  the Domain Object

  Arguments:

          DomainObject -- DSName of the Domain Object
          AccountName  -- The name of the account
          Flags        -- Controls operation of the routine
          NewObject    -- Returns the New DS Name in this object

  Return values:
          STATUS_SUCCESS - upon successful completion
          STATUS_NO_MEMORY - Memory alloc Failure

--*/
{


    NTSTATUS    Status = STATUS_SUCCESS;
    WCHAR       *CommonNamePart;
    ULONG       SizeofCommonNamePart = 0;
    WCHAR       CNPart[] = L"CN=";
    WCHAR       OUPart[] = L"OU=";
    ULONG       NewStructLen;
    ULONG       NewNameLen;
    UCHAR       *DomainNameStart;
    UCHAR       *CommonNamePartStart;
    UCHAR       *AccountNameStart;
    DSNAME      *LoopbackName;

    SAMTRACE("SampDsCreateDsName");

    if ( (Flags & SAM_USE_OU_FOR_CN) )
    {
        CommonNamePart = OUPart;
        SizeofCommonNamePart = sizeof( OUPart );
    }
    else
    {
        CommonNamePart = CNPart;
        SizeofCommonNamePart = sizeof( CNPart );
    }

    //
    // We need to handle two different conditions.
    //
    // 1) We got here because of a native Samr call (eg: user manager)
    //    in which case we construct a DN from the default domain
    //    container and use the account name as the RDN.
    //
    // 2) We got here because we're looping back from the DS in which
    //    case we want to use the DN which is stored in the loopback
    //    arguments.
    //

    if (( SampExistsDsLoopback(&LoopbackName) )
        && (!(Flags & SAM_NO_LOOPBACK_NAME)))
    {
        *NewObject = MIDL_user_allocate(LoopbackName->structLen);

        if ( NULL == *NewObject )
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        RtlCopyMemory(*NewObject, LoopbackName, LoopbackName->structLen);

        Status = STATUS_SUCCESS;
    }

    else
    {
        WCHAR EscapeBuffer[MAX_RDN_SIZE+1];
        UNICODE_STRING EscapedAccountName;

        //
        // Non-loopback case.  Compute the New Name Length
        //

        //
        // Escape the Account Name
        //

        EscapedAccountName.Buffer = EscapeBuffer;
        EscapedAccountName.Length = 0;
        EscapedAccountName.MaximumLength = sizeof(EscapeBuffer);

        Status = SampEscapeAccountName(AccountName,&EscapedAccountName);
        if (!NT_SUCCESS(Status))
        {
            goto Error;
        }

        NewNameLen  = DomainObject->NameLen +                     // Name Len of Domain
                        (EscapedAccountName.Length) /sizeof(WCHAR) +    // Name Len of Account
                        SizeofCommonNamePart/sizeof(WCHAR) - 1+ // Len of CN=
                        1;                                        // 1 for Comma
        //
        // Compute the new structure length
        //

        NewStructLen =  DSNameSizeFromLen(NewNameLen);

        //
        // Allocate space for the new Object
        //

        *NewObject = MIDL_user_allocate(NewStructLen);

        if (*NewObject == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        //
        // Compute the starting locations of DomainName , cn= and Account Name Parts
        //

        CommonNamePartStart = (UCHAR *) &((*NewObject)->StringName);
        AccountNameStart    = CommonNamePartStart + SizeofCommonNamePart - sizeof(WCHAR);
        DomainNameStart     = AccountNameStart + (EscapedAccountName.Length)
                                               + sizeof(WCHAR); // For Comma

        //
        // Zero out the GUID
        //

        RtlZeroMemory(&((*NewObject)->Guid), sizeof(GUID));


        //
        // Copy Common Name Part
        //

        RtlCopyMemory(
           CommonNamePartStart,
           CommonNamePart,
           SizeofCommonNamePart - sizeof(WCHAR)
           );

        //
        //  Copy Account Name Part
        //

         RtlCopyMemory(
            AccountNameStart,
            EscapedAccountName.Buffer,
            EscapedAccountName.Length
            );

        //
        // Add The Comma before Domain Name Part
        //

        *((UNALIGNED WCHAR *)DomainNameStart -1) = L',';

        //
        // NULL terminate the DSNAME
        //

        (*NewObject)->StringName[NewNameLen] = 0;

        //
        // Copy the Domain name part
        //

        RtlCopyMemory(
            DomainNameStart,
            &(DomainObject->StringName),
            (DomainObject->NameLen) * sizeof(WCHAR)
            );

        //
        // Initialize all the fields
        //
        (*NewObject)->NameLen = NewNameLen;
        (*NewObject)->structLen = NewStructLen;
        (*NewObject)->SidLen = 0;

    }



Error:

    return Status;
}

NTSTATUS
SampDsCreateAccountObjectDsName(
    IN  DSNAME *DomainObject,
    IN  PSID    DomainSid OPTIONAL,
    IN  SAMP_OBJECT_TYPE ObjectType,
    IN  PUNICODE_STRING AccountName,
    IN  PULONG  AccountRid OPTIONAL,
    IN  PULONG  UserAccountControl OPTIONAL,
    IN  BOOLEAN BuiltinDomain,
    OUT DSNAME  **AccountObject
    )
/*++

    Routine Description

        This Routine Creates an Account Object's DSNAME,

    Parameters
        Domain Object  DSNAME of the domain Object
        ObjectType     The SAM object Type
        AccountName    Account Name of the Account to be created
        UserAccountControl Optional Argument passing in the user account
                        control field
        BuiltinDomain   TRUE, indicates that the domain is a builtin domain
                        in which case no containers will be prepended
        AccountObject   Account Object is returned in here

    Return Values
        STATUS_SUCCESS
        Other Error Codes upon Creation
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;


    ASSERT((SampUserObjectType==ObjectType)||
            (SampAliasObjectType==ObjectType)
            || (SampGroupObjectType==ObjectType));


    if (BuiltinDomain)
    {
        //
        // Everything is children of Root for Builtin Domain
        //

        return(SampDsCreateDsName(DomainObject,AccountName,
                    AccountObject));
    }

    //
    // We Must prepend a Container path
    //

    if ((SampUserObjectType==ObjectType)
        &&(ARGUMENT_PRESENT(UserAccountControl))
        &&((*UserAccountControl & USER_WORKSTATION_TRUST_ACCOUNT)
            ||(*UserAccountControl & USER_SERVER_TRUST_ACCOUNT)))
    {
        UNICODE_STRING ComputerName;

        //
        // Machine Account
        //

        //
        // Trim the dollar at the end of the account name ( if account
        // name ends with $)
        //

        RtlCopyMemory(&ComputerName,AccountName,sizeof(UNICODE_STRING));
        if (L'$'==ComputerName.Buffer[ComputerName.Length/2-1])
        {
            ComputerName.Length-=sizeof(USHORT);
        }

        if ( (*UserAccountControl & USER_SERVER_TRUST_ACCOUNT)
           && SampDefaultContainerExists( *UserAccountControl ) )
        {
            //
            // domain controller
            //

            ASSERT(SampDomainControllersOUDsName);

            NtStatus = SampDsCreateDsName(
                            SampDomainControllersOUDsName,
                            &ComputerName,
                            AccountObject
                            );

        }
        else
        {
            //
            // Computers Container
            //

            ASSERT(SampComputersContainerDsName);

            NtStatus = SampDsCreateDsName(
                            SampComputersContainerDsName,
                            &ComputerName,
                            AccountObject
                            );
        }
    }
    else
    {
        //
        // User Group or Alias Account
        //

        if (NT_SUCCESS(NtStatus))
        {
            DSNAME  *LoopbackName = NULL;

            ASSERT(SampUsersContainerDsName);

            if (((SampGroupObjectType == ObjectType) ||
                 (SampAliasObjectType == ObjectType)) &&
                 (ARGUMENT_PRESENT(AccountRid)) &&
                !SampExistsDsLoopback(&LoopbackName) )
            {
                ATTRVAL     AttValCN;
                BOOL        UseSidName = FALSE;
                //
                // come from downlevel API (not a Loopback case), then
                // check whether the samAccountName can be used as
                // a valid CN or not
                //
                AttValCN.valLen = AccountName->Length;
                AttValCN.pVal = (PUCHAR) AccountName->Buffer;
                UseSidName = DsCheckConstraint(ATT_COMMON_NAME,
                                               &AttValCN,
                                               TRUE      // also check RDN
                                               );
                if (!UseSidName)
                {
                    // The samAccountName is not a valid CN
                    // We will use the SID string as the CN instead
                    PSID    AccountSid = NULL;

                    NtStatus = SampCreateFullSid(DomainSid,
                                                 *AccountRid,
                                                 &AccountSid);

                    if (NT_SUCCESS(NtStatus))
                    {
                        UNICODE_STRING  SidName;

                        RtlZeroMemory(&SidName, sizeof(UNICODE_STRING));
                        NtStatus = RtlConvertSidToUnicodeString(&SidName,
                                                                AccountSid,
                                                                TRUE );

                        if (NT_SUCCESS(NtStatus))
                        {
                            NtStatus = SampDsCreateDsName(
                                            SampUsersContainerDsName,
                                            &SidName,
                                            AccountObject
                                            );

                            // free memory
                            RtlFreeUnicodeString(&SidName);
                        }

                        // free memory
                        MIDL_user_free(AccountSid);
                    }
                }
                else
                {
                    //
                    // samAccountName can be used as valid CN
                    //
                    NtStatus = SampDsCreateDsName(
                                    SampUsersContainerDsName,
                                    AccountName,
                                    AccountObject
                                    );
                }
            }
            else
            {
                //
                // User Account(Downlevel API or Loopback)
                //      Use Account Name as CN
                // Group/Alias in Loopback case
                //      Use DsName cached in Loopback
                //
                NtStatus = SampDsCreateDsName(
                                SampUsersContainerDsName,
                                AccountName,
                                AccountObject
                                );
            }
        }
    }

    return NtStatus;

}



void
SampInitializeDsName(
                     IN DSNAME * pDsName,
                     IN WCHAR * NamePrefix,
                     IN ULONG NamePrefixLen,
                     IN WCHAR * ObjectName,
                     IN ULONG NameLen
                     )
/*++

Routine Description:
    Initializes a DSNAME structure

Arguments:
    pDsName -- A pointer to a buffer large enough to hold everything. This
               buffer will be filled with a NULL GUID plus a complete name

    NamePrefix -- pointer to a sequence of NULL terminated
                  UNICODE chars holding any prefix
                  to the name. Useful  in composing
                  hierarchial names

    NamePrefixLen -- Length of the Prefix in bytes. Also includes the
                     NULL terminator

    ObjectName -- pointer to a sequence of NULL terminated
                  UNICODE char the name of the object

    NameLen    --   Length of the Object Name in bytes. Also includes the
                    NULL terminator, even though the DSNAME field does not.


 Return Values:

     None

--*/
{
    SAMTRACE("SampInitializeDsName");

    //
    // Single NULL string is not allowed for name or Prefix
    //

    ASSERT(NamePrefixLen!=sizeof(WCHAR));
    ASSERT(NameLen!=sizeof(WCHAR));

    //
    // Zero the GUID
    //

    RtlZeroMemory(&(pDsName->Guid), sizeof(GUID));

    //
    // Compute String Length not including Null terminator
    //

    if (NamePrefix)
    {

        UCHAR       *NameStart;
        UCHAR       *CommaStart;
        UCHAR       *PrefixStart;

        // Exclude NULL characters in Name and Prefix strings
        pDsName->NameLen = (NameLen + NamePrefixLen) / sizeof(WCHAR)
                           - 2    // for null characters
                           + 1;   // for comma

        //
        // Compute the Struct length
        //

        pDsName->structLen = DSNameSizeFromLen(pDsName->NameLen);

        NameStart   = (UCHAR*) &(pDsName->StringName[0]);
        CommaStart  = NameStart + NameLen - sizeof(WCHAR);
        PrefixStart = CommaStart + sizeof(WCHAR);

        //
        // Copy the Object Name
        //

        RtlCopyMemory(NameStart, ObjectName, NameLen);

        //
        // Copy the comma
        //

        RtlCopyMemory(CommaStart, L",", sizeof(WCHAR));

        //
        // Copy the name Prefix
        //

        RtlCopyMemory(PrefixStart, NamePrefix, NamePrefixLen);


    }
    else
    {
        pDsName->NameLen = (NameLen/sizeof(WCHAR)) - 1;

        //
        // Compute the Struct length
        //

        pDsName->structLen = DSNameSizeFromLen(pDsName->NameLen);

        //
        // Copy the Object Name
        //

        RtlCopyMemory(&(pDsName->StringName[0]), ObjectName, NameLen);
    }

}


PVOID
DSAlloc(
        IN ULONG Length
        )
/*++

  Routine Description:

        Ds Memory Allocation Routine

  Arguments:

      Length - Amount of memory to be allocated

  Return Values

    NULL if Memory alloc failed
    Pointer to memory upon success
--*/
{
    PVOID MemoryToReturn = NULL;

    // Must have a DS transaction (i.e. valid thread state)
    // else there is no thread local allocator!

    ASSERT(SampExistsDsTransaction());

    MemoryToReturn = THAlloc(Length);

    return MemoryToReturn;
}


NTSTATUS
SampDsBuildRootObjectName()
/*++

  Routine Description:

        Initializes the Global variable that holds the
        name of the Root Object

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DWORD    Size = 0;

    if ( !RootObjectName )
    {
        NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                         &Size,
                                         RootObjectName );

        ASSERT( STATUS_BUFFER_TOO_SMALL == NtStatus );
        if ( STATUS_BUFFER_TOO_SMALL == NtStatus )
        {
            RootObjectName = (DSNAME*) MIDL_user_allocate( Size );
            if ( RootObjectName )
            {
                RtlZeroMemory( RootObjectName, Size );
                NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                                 &Size,
                                                 RootObjectName );
            }
            else
            {
                NtStatus = STATUS_NO_MEMORY;
            }
        }
    }

    return NtStatus;

}


NTSTATUS
SampDsGetWellKnownContainerDsName(
    IN  DSNAME  *DomainObject,
    IN  GUID    *WellKnownGuid,
    OUT DSNAME  **ContainerObject
    )
/*++
Routine Description

    The routine will read core DS, trying to find the wellknown container's
    dsname based on the well known GUID publiched in ntdsapi.h. Even the
    wellknown container has been renamed, DS still has logic to find them.
    As far as Users Container, Computers Container and Domain Controllers
    OU, they can not be renamed, deleted or moved according to the schema.

    The caller should have a DS transaction open. And it is the responsbility
    of caller to close the transaction.

Parameters:

    DomainObject - pointer to the Domain Object's DsName

    WellKnowGuid - pointer to the well known guid published in ntdsapi.h

    ContainerObject - return the read result

Return Value:

    STATUS_SUCCESS

    NtStatus from DirRead
--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    READARG     ReadArg;
    READRES     *ReadRes = NULL;
    DSNAME      *ReadDsName = NULL;
    DSNAME      *LoopbackName;
    ENTINFSEL   EntInfSel;
    ULONG       Size = 0, Length = 0;
    ULONG       DirError = 0;


    SAMTRACE("SampDsGetWellKnownContainerDsName");


    //
    // ASSERT we have an open transaction
    //
    ASSERT( SampExistsDsTransaction() );

    //
    // Get Domain Object's String Name
    // required by DirRead, with Domain Object's String Name,
    // we can not get the well known container's DsName
    //
    // Core DS requires Domain Object's String Name and
    // published well known container's GUID to find
    // the ds name for that well known container.
    //

    Length = DomainObject->NameLen;
    ASSERT(Length && "DomainObject's String Name should not be NULL");

    Size = DSNameSizeFromLen( Length );
    SAMP_ALLOCA(ReadDsName , Size );
    if (NULL==ReadDsName)
    {
         return(STATUS_INSUFFICIENT_RESOURCES);
    }
    RtlZeroMemory( ReadDsName, Size );

    ReadDsName->structLen = Size;
    ReadDsName->NameLen = Length;
    wcscpy( ReadDsName->StringName, DomainObject->StringName );
    ReadDsName->Guid = *WellKnownGuid;

    //
    // Build the ReadArg structure
    //

    memset(&ReadArg, 0, sizeof(READARG));
    memset(&EntInfSel, 0, sizeof(ENTINFSEL));

    ReadArg.pObject = ReadDsName;
    ReadArg.pSel = &EntInfSel;

    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntInfSel.AttrTypBlock.attrCount = 1;
    SAMP_ALLOCA(EntInfSel.AttrTypBlock.pAttr,sizeof(ATTR));
    if (NULL==EntInfSel.AttrTypBlock.pAttr)
    {
         return(STATUS_INSUFFICIENT_RESOURCES);
    }
    RtlZeroMemory(EntInfSel.AttrTypBlock.pAttr, sizeof(ATTR));
    EntInfSel.AttrTypBlock.pAttr[0].attrTyp = ATT_OBJ_DIST_NAME;

    BuildStdCommArg( &(ReadArg.CommArg) );

    //
    // Read Core DS
    //

    DirError = DirRead( &ReadArg, &ReadRes );

    //
    // Map the return error
    //

    if (ReadRes)
    {
        NtStatus = SampMapDsErrorToNTStatus( DirError, &ReadRes->CommRes );
    }
    else
    {
        NtStatus = STATUS_NO_MEMORY;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // fill the container object's dsname if we find that container
    //

    Size = ReadRes->entry.pName->structLen;

    *ContainerObject = MIDL_user_allocate( Size );

    if (NULL == *ContainerObject)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(*ContainerObject, Size);
    RtlCopyMemory(*ContainerObject,
                  ReadRes->entry.pName,
                  Size
                  );

Cleanup:

    //
    // ASSERT we still have the transaction opened
    //
    ASSERT( SampExistsDsTransaction() );

    return NtStatus;
}


NTSTATUS
SampDelayedMIDLUserFreeArray(
    IN PVOID p
    )
//
// This routine assumes p points to an array of pointers that need to be freed.
// The array is NULL terminated.
//
{
    ULONG i;
    PVOID* pp = (PVOID*) p;

    if (pp) {
        for (i = 0; NULL != pp[i]; i++) {
            MIDL_user_free(pp[i]);
        }
        MIDL_user_free(pp);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
SampInitWellKnownContainersDsNameAsync(
    IN DSNAME *DomainObject
    )
//
// See SampInitWellKnownContainersDsName for details.  This routine
// will reschedule itself on failure.
//
{
    NTSTATUS Status = SampInitWellKnownContainersDsName(DomainObject);

    if (!NT_SUCCESS(Status)) {

        LsaIRegisterNotification(
                        SampInitWellKnownContainersDsNameAsync,
                        DomainObject,
                        NOTIFIER_TYPE_INTERVAL,
                        0,        // no class
                        NOTIFIER_FLAG_ONE_SHOT,
                        300,      // wait for 5 min
                        NULL      // no handle
                        );

    }

    return STATUS_SUCCESS;
}

NTSTATUS
SampInitWellKnownContainersDsName(
    IN DSNAME *DomainObject
    )
/*++
Routine Description:

    This routine will initilize these well known containers' DsName including
    Domain Controllers OU, Users Container and Computers Container.

    NOTE: SHOULD NOT have an open transaction while calling this routine.

Parameters:

    DomainObject - pointer to the Domain Object's ds name.

Return Values:

    STATUS_SUCCESS,
    STATUS_NO_MEMORY,
    error returned from SampDsGetWellKnownContainerDsName

--*/
{
    NTSTATUS   NtStatus = STATUS_SUCCESS;
    NTSTATUS   NtStatus2;

    ULONG   i;

    struct {

        GUID     *Guid;
        DSNAME **Container;
        
    } ContainerTable [] = {

        {(GUID *)GUID_DOMAIN_CONTROLLERS_CONTAINER_BYTE, &SampDomainControllersOUDsName},
        {(GUID *)GUID_COMPUTRS_CONTAINER_BYTE,           &SampComputersContainerDsName},
        {(GUID *)GUID_USERS_CONTAINER_BYTE,              &SampUsersContainerDsName},
    };

    PVOID   *PtrsToFree = NULL;
    ULONG   NumberOfPtrs = 0;


    SAMTRACE("SampInitWellKnownContainersDsName");


    //
    // Should not have an open transaction while calling this routine.
    //
    ASSERT( !SampExistsDsTransaction() );

    //
    // Allocate buffer of pointers to free
    //
    PtrsToFree = MIDL_user_allocate((RTL_NUMBER_OF(ContainerTable) + 1) * sizeof(PVOID));
    if (NULL == PtrsToFree) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlZeroMemory(PtrsToFree, (RTL_NUMBER_OF(ContainerTable) + 1) * sizeof(PVOID));


    //
    // Open a DS transaction
    //
    NtStatus = SampMaybeBeginDsTransaction( TransactionRead );

    if (NT_SUCCESS(NtStatus)) {

        //
        // For each element in the array, get the current container name
        //
        for (i = 0; i < RTL_NUMBER_OF(ContainerTable); i++) {

            PVOID   Ptr = NULL;
            DSNAME  *NewContainer = NULL;

            NtStatus = SampDsGetWellKnownContainerDsName(
                                    DomainObject,
                                    ContainerTable[i].Guid,
                                    &NewContainer
                                    );

            if (!NT_SUCCESS(NtStatus)) {
                break;
            }

            Ptr = InterlockedExchangePointer(ContainerTable[i].Container,
                                             NewContainer);

            if (Ptr) {
                PtrsToFree[NumberOfPtrs++] = Ptr;    
            }
        }

        NtStatus2 = SampMaybeEndDsTransaction( TransactionCommit );
        if (NT_SUCCESS(NtStatus) && !NT_SUCCESS(NtStatus2)) {
            NtStatus = NtStatus2;
        }

    }


    if (NumberOfPtrs > 0) {

        LsaIRegisterNotification(
                        SampDelayedMIDLUserFreeArray,
                        PtrsToFree,
                        NOTIFIER_TYPE_INTERVAL,
                        0,        // no class
                        NOTIFIER_FLAG_ONE_SHOT,
                        3600,     // wait for 60 min
                        NULL      // no handle
                        );
    } else {

        MIDL_user_free(PtrsToFree);

    }

    return NtStatus;
}




NTSTATUS
SampEscapeAccountName(
    IN PUNICODE_STRING AccountName,
    IN OUT PUNICODE_STRING EscapedAccountName
    )
/*++

    Routine Description

        Given an Account Name, this routine scans the string to find wether an
        invalid RFC1779 Character is present. If so the string is then quoted and
        depending upon the character, the character might be paired. Pairing a
        character in RFC1779 is same as escaping with a "\"


            For example

                  MS1  will yield  MS1
                  MS#1 will yield "MS#1"
                  MS"1 will yield "MS\"1"
    Parameters

        AccountName -- The account Name to escape
        EscapedAccount Name -- The Escaped Account Name

    Return Values

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       NumQuotedRDNChars=0;

    NumQuotedRDNChars = QuoteRDNValue(
                            AccountName->Buffer,
                            AccountName->Length/sizeof(WCHAR),
                            EscapedAccountName->Buffer,
                            EscapedAccountName->MaximumLength/sizeof(WCHAR)
                            );
    if (   (NumQuotedRDNChars == 0)
        || (NumQuotedRDNChars > EscapedAccountName->MaximumLength/sizeof(WCHAR)))
    {
        Status = STATUS_UNSUCCESSFUL;
    }
    else {
        EscapedAccountName->Length = (USHORT) NumQuotedRDNChars * sizeof(WCHAR);
        EscapedAccountName->MaximumLength = (USHORT) NumQuotedRDNChars * sizeof(WCHAR);
    }

    return Status;
}

VOID
SampDsAccountTypeFromUserAccountControl(
    ULONG   UserAccountControl,
    PULONG  SamAccountType
    )
/*++

    Routine Description

        This routined computes a SAM account type attribute value,
        given the user account control field of a user object

    Parameters
        UserAccountControl  -- The User account control field
        SamAccountType  -- Computed Sam account type value is
                           returned in here
--*/
{
    if ((UserAccountControl & USER_WORKSTATION_TRUST_ACCOUNT)
        || ( UserAccountControl & USER_SERVER_TRUST_ACCOUNT))
    {
        *SamAccountType = SAM_MACHINE_ACCOUNT;
    }
    else if (UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT)
    {
        *SamAccountType = SAM_TRUST_ACCOUNT;
    }
    else
    {
        *SamAccountType = SAM_NORMAL_USER_ACCOUNT;
    }

}


NTSTATUS
SampCopyRestart(
    IN  PRESTART OldRestart,
    OUT PRESTART *NewRestart
    )
/*++

  Routine Description:

        This Routine Copies a Restart Structure

  Arguments:

    OldRestart - Old Structure
    NewRestart - New Structure

  Return Values:

        STATUS_SUCCESS
        STATUS_NO_MEMORY

  --*/
{
    NTSTATUS    Status = STATUS_SUCCESS;

    *NewRestart = NULL;
    if (OldRestart!=NULL)
    {
        // Alloc memory for 1 restart structure
        *NewRestart = MIDL_user_allocate(OldRestart->structLen);
        if (NULL == *NewRestart)
        {
            Status = STATUS_NO_MEMORY;
        }
        else {
            memcpy((*NewRestart),OldRestart,OldRestart->structLen);
        }
    }

    return Status;
}


ULONG
Ownstrlen(
    CHAR * Sz
   )
/*++

  Routine Description

    String Length function for ASCII Null terminated strings. Own version
    as we are not yet inclined to use C-Runtime

  Arguments

    Sz - NULL terminated String Whose lenght we eant to count

  Return Values

    Length of String

--*/
{
    ULONG   Count = 0;

    ASSERT(Sz);

    while (*Sz)
    {
        Sz++;
        Count++;
    }

    return Count;
}

VOID
BuildDsNameFromSid(
    PSID Sid,
    DSNAME * DsName
    )
/*++

  Builds a Ds Name from a SID that contains only a SID

    Parameters

        Sid -- Pointer to SID
        DsName -- Pointer to DSNAME

  --*/
{
    RtlZeroMemory(DsName,sizeof(DSNAME));
    DsName->structLen =
                        DSNameSizeFromLen(DsName->NameLen);
    DsName->SidLen = RtlLengthSid(Sid);
    RtlCopyMemory(
        &(DsName->Sid),
        Sid,
        RtlLengthSid(Sid)
        );
}

ATTR *
SampDsGetSingleValuedAttrFromAttrBlock(
    IN ATTRTYP attrTyp,
    IN ATTRBLOCK * AttrBlock
    )
/*++

    Given an AttrBlock, this routine walks through the attrblock
    and returns the first pAttr structure that matches the attribute
    specified through the attrTyp parameter. This routine makes the
    assumption that attribute is single valued

    Parameters:

        attrTyp : Attribute type to find
        Attrblock -- Specifies to the set of attributes, where we need
                     to look

    Return Values

        Address of the pAttr, if found, NULL if not

--*/
{
    ULONG i;

    for (i=0;i<AttrBlock->attrCount;i++)
    {
        if ((AttrBlock->pAttr[i].attrTyp == attrTyp)
            && (1==AttrBlock->pAttr[i].AttrVal.valCount)
            && (NULL!=AttrBlock->pAttr[i].AttrVal.pAVal[0].pVal)
            && (0!=AttrBlock->pAttr[i].AttrVal.pAVal[0].valLen))
        {
            return (&(AttrBlock->pAttr[i]));
        }
    }

    return NULL;
}



NTSTATUS
SampDsChangeAccountRDN(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING NewAccountName
    )

/*++
Routine Description:

    This routine changes the RDN of a user account, when the user
    account is changed.

    THIS SERVICE MUST BE CALLED WITH THE TRANSACTION DOMAIN SET.

Arguments:

    Context - Points to the User context whose name is to be changed.

    NewAccountName - New name to give this account

Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    Other status values that may be returned by:
--*/
{

    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ENTINFSEL   EntInf;
    READARG     ReadArg;
    READRES     *pReadRes = NULL;
    MODIFYDNARG ModifyDNArg;
    MODIFYDNRES *pModifyDNRes = NULL;
    COMMARG     *pCommArg = NULL;
    ATTRVAL     RDNAttrVal;
    ATTR        RDNAttr;
    ULONG       RetValue;


    SAMTRACE("SampDsChangeMachineAccountRDN");

    NtStatus = SampDoImplicitTransactionStart(TransactionWrite);

    if (NtStatus != STATUS_SUCCESS)
        return NtStatus;


    EntInf.attSel = EN_ATTSET_LIST;
    EntInf.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntInf.AttrTypBlock.attrCount = 0;
    EntInf.AttrTypBlock.pAttr = NULL;

    memset( &ReadArg, 0, sizeof(READARG) );
    ReadArg.pObject = Context->ObjectNameInDs;
    ReadArg.pSel = &EntInf;
    pCommArg = &(ReadArg.CommArg);
    BuildStdCommArg(pCommArg);

    SAMTRACE_DS("DirRead\n");

    RetValue = DirRead(&ReadArg, &pReadRes);

    SAMTRACE_RETURN_CODE_DS(RetValue);

    if (NULL==pReadRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetValue, &pReadRes->CommRes);
    }

    if (NtStatus != STATUS_SUCCESS)
        goto Error;


    RDNAttr.attrTyp = ATT_COMMON_NAME;
    RDNAttr.AttrVal.valCount = 1;
    RDNAttr.AttrVal.pAVal = &RDNAttrVal;

    // Trim the dollar at the end of machine account name.
    if (L'$'==NewAccountName->Buffer[NewAccountName->Length/2-1])
    {
        RDNAttrVal.valLen = NewAccountName->Length - sizeof(WCHAR);
    }
    else
    {
        RDNAttrVal.valLen = NewAccountName->Length;
    }
    RDNAttrVal.pVal = (PUCHAR)NewAccountName->Buffer;

    memset( &ModifyDNArg, 0, sizeof(MODIFYDNARG) );
    ModifyDNArg.pObject = pReadRes->entry.pName;
    ModifyDNArg.pNewRDN = &RDNAttr;
    pCommArg = &(ModifyDNArg.CommArg);
    BuildStdCommArg(pCommArg);

    SAMTRACE_DS("DirModifyDN\n");

    RetValue = DirModifyDN(&ModifyDNArg, &pModifyDNRes);

    SAMTRACE_RETURN_CODE_DS(RetValue);

    if (NULL==pModifyDNRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetValue,&pModifyDNRes->CommRes);
    }


Error:

    SampClearErrors();

    return NtStatus;

}


BOOLEAN
SampDefaultContainerExists(
    IN ULONG AccountControl
    )
/*++
Routine Description:

    This routine determines if the well known ou container for SAM
    objects exists.

    This routine assumes a current transaction.

    //
    // Note: this code is needed because although the containers are well known
    // and hence cannot be renamed or deleted, the Domain Controllers
    // OU was not added until after the last incompatible build was
    // released.  So, theoretically, some domains could exist without
    // this OU
    //

Arguments:

    AccountControl : the type of account object

Return Value:

    TRUE if it exists; FALSE otherwise

--*/
{
    if ( AccountControl & USER_SERVER_TRUST_ACCOUNT )
    {
        return SampDomainControllersOUExists;
    }
    else if ( AccountControl & USER_WORKSTATION_TRUST_ACCOUNT )
    {
        return SampComputersContainerExists;
    }
    else
    {
        // every else goes into Users
        return SampUsersContainerExists;
    }

}


VOID
SampMapSamAttrIdToDsAttrId(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT ATTRBLOCK * AttributeBlock
    )

/*++

Routine Description:

Parameters:

Return Values:

--*/

{
    ULONG Index, DsAttrTyp;

    SAMTRACE("SampMapAttrIdToAttrId");

    if (NULL == AttributeBlock)
    {
        return;
    }                        

    for (Index = 0; Index < AttributeBlock->attrCount; Index++)
    {
        DsAttrTyp = SampDsAttrFromSamAttr(
                        ObjectType,
                        AttributeBlock->pAttr[Index].attrTyp
                        );

        AttributeBlock->pAttr[Index].attrTyp = DsAttrTyp;
    }

    return;
}


NTSTATUS
SampFillGuidAndSid(
    IN OUT DSNAME *DSName
    )
/*++

Routine Description:

    This routine improves a DSName by attempting to find the object or 
    corresponding phantom and intialize the Guid and Sid.  A thread state
    must exist and a transaction must be open.
        
    This routine calls into SampDsControl to get the Guid/Sid lookup done.
        
    This routine changes database currency.

Arguments:

    DSName - The DSNAME to be improved.
    
Return Value:

    STATUS_SUCCESS -- If the routine successfully filled the Guid, the Sid, 
                      or both.
                      
    STATUS_UNSUCCESSFUL -- A called routine failed.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    SAMP_DS_CTRL_OP DsControlOp;
    DSNAME *DummyDSName = NULL;
    
    //
    // If either the Sid or Guid are missing try to obtain them
    //
    if (0 == DSName->SidLen || fNullUuid(&DSName->Guid)) {                
        
        //
        // Be sure we've got a transaction open to perform the read.
        //  
        NtStatus = SampDoImplicitTransactionStart(TransactionRead);
              
        if ( NT_SUCCESS(NtStatus) ) {
            
            RtlZeroMemory(&DsControlOp, sizeof(SAMP_DS_CTRL_OP));
            DsControlOp.OpType = SampDsCtrlOpTypeFillGuidAndSid;
            DsControlOp.OpBody.FillGuidAndSid.DSName = DSName;
            
            NtStatus = SampDsControl(&DsControlOp, &DummyDSName);
        }                
    }
     
    return NtStatus;
    
}


NTSTATUS
SampDsReadSingleAttribute(
    IN PDSNAME pObjectDsName,
    IN ATTRTYP AttrTyp,
    OUT PVOID *ppValue,
    OUT ULONG *Size
    )
/*++

Routine Description:

    This routine reads the single valued attribute AttrTyp from 
    pObjectDsName

Parameter:

    pObjectDsName - object ds name

    AttrTyp -- the attribute to retrieve
                                            
    ppValue -- pointer to hold the value
    
    Size -- the size of the value

Return Value:

    NtStatus Code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    DWORD       DirError;
    READARG     ReadArg;
    READRES    *ReadRes = NULL;
    COMMARG    *CommArg = NULL;
    ATTR        Attr;
    ATTRBLOCK   ReadAttrBlock;
    ENTINFSEL   EntInfSel;

    //
    // Init Read Argument
    // 
    RtlZeroMemory(&Attr, sizeof(ATTR));
    RtlZeroMemory(&ReadArg, sizeof(READARG));
    RtlZeroMemory(&EntInfSel, sizeof(ENTINFSEL));
    RtlZeroMemory(&ReadAttrBlock, sizeof(ATTRBLOCK));

    Attr.attrTyp = AttrTyp;

    ReadAttrBlock.attrCount = 1;
    ReadAttrBlock.pAttr = &Attr;

    EntInfSel.AttrTypBlock = ReadAttrBlock;
    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EntInfSel;
    ReadArg.pObject = pObjectDsName;

    CommArg = &(ReadArg.CommArg);
    BuildStdCommArg(CommArg);


    DirError = DirRead(&ReadArg, &ReadRes);

    if (NULL == ReadRes) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {
        NtStatus = SampMapDsErrorToNTStatus(DirError, &ReadRes->CommRes);
    }
    SampClearErrors();

    if (NT_SUCCESS(NtStatus))
    {
        ATTRBLOCK   AttrBlock;

        ASSERT(NULL != ReadRes);

        AttrBlock = ReadRes->entry.AttrBlock;

        if ( (1 == AttrBlock.attrCount) &&
             (NULL != AttrBlock.pAttr) &&
             (1 == AttrBlock.pAttr[0].AttrVal.valCount) &&
             (NULL != AttrBlock.pAttr[0].AttrVal.pAVal) )
        {
            ULONG   ValLen = 0;

            ValLen = AttrBlock.pAttr[0].AttrVal.pAVal[0].valLen;

            *ppValue = MIDL_user_allocate(ValLen);

            if (NULL == (*ppValue))
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {

                RtlCopyMemory(*ppValue,
                              AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal,
                              ValLen
                              );

                *Size = ValLen;

            }
        }
        else
        {
            NtStatus = STATUS_INTERNAL_ERROR;
        }
    }

    return( NtStatus );    
}

NTSTATUS
SampAppendCommonName(
    IN PDSNAME DsName,
    IN PWSTR CN,
    OUT PDSNAME *NewDsName
    )
/*++

Routine Description:

    This routine appends a cn to a dsname.

Parameters:

    DsName - This is the parent ds name to which cn is going to be added

    CN - CN to be added to the beginning of the DsName

    NewDsName - This is the output of the function containing,
        CN="CN", DsName

Return Values:

    STATUS_SUCCESS
        The operation was successfully completed.

    STATUS_NO_MEMORY
        Cannot continue, not enough memory

    STATUS_INVALID_PARAMETER
        one of the parameters was invalid
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG DsNameSize;
    PDSNAME NewDsName2;

    *NewDsName = NULL;

    //
    // Find the size of the structure to allocate for NewDsName 
    //
    DsNameSize = AppendRDN(
                    DsName,
                    NULL,
                    0,
                    CN,
                    0,  // Null terminated
                    ATT_COMMON_NAME
                    );

    ASSERT( DsNameSize > 0 && "We must get the size of the new DSNAME structure" );

    NewDsName2 = MIDL_user_allocate( DsNameSize );

    if( NewDsName2 == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto Error;
    }

    //
    // Append the CN to the beginning of DsName
    //
    DsNameSize = AppendRDN(
                    DsName,
                    NewDsName2,
                    DsNameSize,
                    CN,
                    0,  // Null terminated
                    ATT_COMMON_NAME
                    );

    if( DsNameSize != 0 ) {

        //
        // What value can be put here? AppendRDN returns only error if
        //  parameter is invalid.
        //
        Status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    *NewDsName = NewDsName2;

Exit:
    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ) );
    MIDL_user_free( NewDsName2 );
    goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dsutil.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dsutil.c

Abstract:

    This file contains helper routines for accessing and manipulating data
    based on the DS backing store. Included, are routines for converting be-
    tween the SAM data format (BLOBs) and the DS data format (ATTRBLOCKs).

    NOTE: The routines in this file have direct knowledge of the SAM fixed-
    length attribute and variable-length attribute structures, as well as the
    DS ATTRBLOCK structure. Any changes to these structures, including:

    -addition/deletion of a structure member
    -data type/size change of a structure member
    -reordering of the data members
    -renaming of the data members

    will break these routines. SAM attributes are accessed via byte buffer
    offsets and lengths, rather than by identifier or by explicit structure
    data members. Because of this, changes to the structure layout will lead
    to failures in SAM operation.

    Several of the routines have been written assuming that the order of the
    attributes passed in via an ATTRBLOCK are exactly the order in which SAM
    understands its own buffer layout. If the attributes are passed into the
    routines (that take ATTRBLOCKs) out of order, the data in the SAM buffers
    will be invalid.

Author:

    Chris Mayhall (ChrisMay) 09-May-1996

Environment:

    User Mode - Win32

Revision History:

    ChrisMay        09-May-1996
        Created initial file, DS ATTRBLOCK-SAM buffer conversion routines for
        variable-length attributes.
    ChrisMay        14-May-1996
        DS ATTRBLOCK-SAM buffer conversion routines for fixed-length attri-
        butes.
    ChrisMay        22-May-1996
        Added DWORD_ALIGN macro to align data on DWORD boundaries. Fixed
        alignment problems on MIPS in SampExtractAttributeFromDsAttr routine.
    ChrisMay        30-May-1996
        Added routines to convert SAM combined-buffer attributes to/from DS
        ATTRBLOCKs. Revised fixed-length routines to do explicit structure
        member assignment instead of attempting to compute structure offsets.
    ChrisMay        18-Jun-1996
        Updated fixed-attribute tables to reflect recent changes in mappings.c
        and mappings.h, and DS schema. Added code to coerce the data sizes of
        USHORT and BOOLEAN to DS integer data type (4 bytes) so that the DS
        modify entry routines don't AV. Correctly set attribute type for the
        variable-length attributes.
    ChrisMay        25-Jun-1996
        Added RtlZeroMemory calls where they were missing.
    ColinBr         18-Jul-1996
        Fixed array overwrite and assigned type to variable length
        attributes when combining fixed and variable length attrs
        into one.
    ColinBr         19-Jul-1996
        Replaced the mappings of membership related SAM attributes to
        *_UNUSED. So
        SAMP_USER_GROUPS   -> SAMP_USER_GROUPS_UNUSED
        SAMP_GROUP_MEMBERS -> SAMP_GROUP_MEMBERS_UNUSED
        SAMP_ALIAS_MEMBERS -> SAMP_ALIAS_MEMBERS_UNUSED
    ChrisMay        25-Jun-1996
        Added extremely slime-ridden hack to make logon hours work for the
        technology preview.

        REMOVE THIS COMMENT AFTER THIS IS FIXED, AFTER THE PREVIEW.

        Search for "TECHNOLOGY PREVIEW HACK". The problem is that the
        Qualifier field is used to store the units of time for a user's
        logon hours. This is bogus since most of the time it is used as
        a count of values for multivalued attributes. Consequently, this
        code "whacks" 0xa8 into the qualifier field whenever the attri-
        butes are read in from disk. 0xa8 means that the time units are
        in hours-per-day (probably!).


--*/

#include <samsrvp.h>
#include <dsutilp.h>
#include <mappings.h>
#include <objids.h>

// Private debugging display routine is enabled when DSUTIL_DBG_PRINTF = 1.

#define DSUTIL_DBG_PRINTF                  0

#if (DSUTIL_DBG_PRINTF == 1)
#define DebugPrint printf
#else
#define DebugPrint
#endif


#if DBG
#define AssertAddressWhenSuccess(NtStatus, Address)    \
        if (NT_SUCCESS(NtStatus))                      \
        {                                              \
            ASSERT(Address);                           \
        }
#else
#define AssertAddressWhenSuccess(NtStatus, Address)
#endif // DBG

// DWORD_ALIGN is used to adjust pointer offsets up to the next DWORD boundary
// during the construction of SAM blob buffers.

#define DWORD_ALIGN(value) (((DWORD)(value) + 3) & ~3)

// Because it is apparently difficult for the DS to support NT data types of
// USHORT, UCHAR, and BOOLEAN (and which are used by SAM), these crappy data
// types have been defined for the SampFixedAttributeInfo table so that four-
// byte quantities are used. These four-byte quantities correspond to the DS
// "integer" data type (for how long?) which is used for storing certain SAM
// attributes. Note that it is important to zero out any memory allocated w/
// these data sizes, since only the lower couple of bytes actually contain
// data. Enjoy...and refer to the DS schema(.hlp file) for the ultimate word
// on the currently used DS data types.

#define DS_USHORT   ULONG
#define DS_UCHAR    ULONG
#define DS_BOOLEAN  ULONG

// This type-information table is used by the routines that convert between
// SAM fixed-length buffers and DS ATTRBLOCKs. The table contains information
// about the data type and size (but may contain any suitable information that
// is needed in the future) of the fixed-length attributes. NOTE: the layout
// of this table corresponds to the data members of the fixed-length struct-
// ures (in samsrvp.h), hence, any changes to those structures must be re-
// flected in the type-information table.

SAMP_FIXED_ATTRIBUTE_TYPE_INFO
    SampFixedAttributeInfo[SAMP_OBJECT_TYPES_MAX][SAMP_FIXED_ATTRIBUTES_MAX] =
{
    // The initialization values of this table must strictly match the set
    // and order of the data members in the SAM fixed-attribute structures,
    // contained in samsrvp.h.

    // The routines that manipulate this table assume that the fixed-length
    // attributes, unlike the variable-length counterparts, are single valued
    // attributes (i.e. are not multi-valued attributes).

    // The first column of each element in the table is a type identifier, as
    // defined in mappings.c. This is used to map the SAM data type into the
    // equivalent DS data type. The second column of each table element is the
    // actual (C-defined) size of the element and is used throughout the data
    // conversion routines in this file in order to allocate memory or set
    // offset information correctly.

    // SampServerObjectType

    {
        {SAMP_FIXED_SERVER_REVISION_LEVEL,              sizeof(ULONG), sizeof(ULONG)}
    },

    // SampDomainObjectType

    {
        {SAMP_FIXED_DOMAIN_CREATION_TIME,               sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_DOMAIN_MODIFIED_COUNT,              sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_DOMAIN_MAX_PASSWORD_AGE,            sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_DOMAIN_MIN_PASSWORD_AGE,            sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_DOMAIN_FORCE_LOGOFF,                sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_DOMAIN_LOCKOUT_DURATION,            sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_DOMAIN_LOCKOUT_OBSERVATION_WINDOW,  sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_DOMAIN_MODCOUNT_LAST_PROMOTION,     sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_DOMAIN_NEXT_RID,                    sizeof(ULONG),sizeof(ULONG)},
        {SAMP_FIXED_DOMAIN_PWD_PROPERTIES,              sizeof(ULONG),sizeof(ULONG)},
        {SAMP_FIXED_DOMAIN_MIN_PASSWORD_LENGTH,         sizeof(USHORT),sizeof(DS_USHORT)},
        {SAMP_FIXED_DOMAIN_PASSWORD_HISTORY_LENGTH,     sizeof(USHORT),sizeof(DS_USHORT)},
        {SAMP_FIXED_DOMAIN_LOCKOUT_THRESHOLD,           sizeof(USHORT),sizeof(DS_USHORT)},
        {SAMP_FIXED_DOMAIN_SERVER_STATE,                sizeof(DOMAIN_SERVER_ENABLE_STATE),sizeof(DOMAIN_SERVER_ENABLE_STATE)},
        {SAMP_FIXED_DOMAIN_UAS_COMPAT_REQUIRED,         sizeof(BOOLEAN),sizeof(DS_BOOLEAN)}
    },

    // SampGroupObjectType

    {
        {SAMP_FIXED_GROUP_RID,                          sizeof(ULONG),sizeof(ULONG)}
       
    },

    // SampAliasObjectType

    {
        {SAMP_FIXED_ALIAS_RID,                          sizeof(ULONG),sizeof(ULONG)}
    },

    // SampUserObjectType

    {
        {SAMP_FIXED_USER_LAST_LOGON,                    sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_USER_LAST_LOGOFF,                   sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_USER_PWD_LAST_SET,                  sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_USER_ACCOUNT_EXPIRES,               sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_USER_LAST_BAD_PASSWORD_TIME,        sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_USER_USERID,                        sizeof(ULONG),sizeof(ULONG)},
        {SAMP_FIXED_USER_PRIMARY_GROUP_ID,              sizeof(ULONG),sizeof(ULONG)},
        {SAMP_FIXED_USER_ACCOUNT_CONTROL,               sizeof(ULONG),sizeof(ULONG)},
        {SAMP_FIXED_USER_COUNTRY_CODE,                  sizeof(USHORT),sizeof(DS_USHORT)},
        {SAMP_FIXED_USER_CODEPAGE,                      sizeof(USHORT),sizeof(DS_USHORT)},
        {SAMP_FIXED_USER_BAD_PWD_COUNT,                 sizeof(USHORT),sizeof(DS_USHORT)},
        {SAMP_FIXED_USER_LOGON_COUNT,                   sizeof(USHORT),sizeof(DS_USHORT)}
    }
};



SAMP_VAR_ATTRIBUTE_TYPE_INFO
    SampVarAttributeInfo[SAMP_OBJECT_TYPES_MAX][SAMP_VAR_ATTRIBUTES_MAX] =
{
    // The initialization values of this table must strictly match the set
    // and order of the data members in the SAM variable-attributes, defined
    // in samsrvp.h. Size is not defined here, because SAM variable-length
    // attributes store attribute length explicity. Refer to mappings.c and
    // mappings.h for the definitions used for the data types in this table.

    // SampServerObjectType

    {
        {SAMP_SERVER_SECURITY_DESCRIPTOR,0,FALSE}
    },

    // SampDomainObjectType

    {
        {SAMP_DOMAIN_SECURITY_DESCRIPTOR,0,FALSE},
        {SAMP_DOMAIN_SID,0,FALSE},
        {SAMP_DOMAIN_OEM_INFORMATION,0,FALSE},
        {SAMP_DOMAIN_REPLICA,0,FALSE}
    },

    // SampGroupObjectType

    {
        {SAMP_GROUP_SECURITY_DESCRIPTOR,0,FALSE},
        {SAMP_GROUP_NAME,0, FALSE},
        {SAMP_GROUP_ADMIN_COMMENT,0,FALSE},
        {SAMP_GROUP_MEMBERS,0,TRUE}
    },

    // SampAliasObjectType

    {
        {SAMP_ALIAS_SECURITY_DESCRIPTOR,0,FALSE},
        {SAMP_ALIAS_NAME,0,FALSE},
        {SAMP_ALIAS_ADMIN_COMMENT,0,FALSE},
        {SAMP_ALIAS_MEMBERS,0,TRUE}
    },

    // SampUserObjectType

    {
        {SAMP_USER_SECURITY_DESCRIPTOR,USER_ALL_SECURITYDESCRIPTOR,FALSE},
        {SAMP_USER_ACCOUNT_NAME, 0 /* USER_ALL_USERNAME */,FALSE},
                   // always fetch sam account name, as sam requires at least
                   // one variable attribute in the context. Having a 0 in 
                   // the field identifier portion causes the code to always
                   // fetch SAM account name
        {SAMP_USER_FULL_NAME,USER_ALL_FULLNAME,FALSE},
        {SAMP_USER_ADMIN_COMMENT,USER_ALL_ADMINCOMMENT,FALSE},
        {SAMP_USER_USER_COMMENT,USER_ALL_USERCOMMENT,FALSE},
        {SAMP_USER_PARAMETERS,USER_ALL_PARAMETERS,FALSE},
        {SAMP_USER_HOME_DIRECTORY,USER_ALL_HOMEDIRECTORY,FALSE},
        {SAMP_USER_HOME_DIRECTORY_DRIVE,USER_ALL_HOMEDIRECTORYDRIVE,FALSE},
        {SAMP_USER_SCRIPT_PATH,USER_ALL_SCRIPTPATH,FALSE},
        {SAMP_USER_PROFILE_PATH,USER_ALL_PROFILEPATH,FALSE},
        {SAMP_USER_WORKSTATIONS,USER_ALL_WORKSTATIONS,FALSE},
        {SAMP_USER_LOGON_HOURS,USER_ALL_LOGONHOURS,FALSE},
        {SAMP_USER_GROUPS,0,TRUE},
        {SAMP_USER_DBCS_PWD,(USER_ALL_OWFPASSWORD|USER_ALL_PASSWORDMUSTCHANGE),FALSE},
        {SAMP_USER_UNICODE_PWD,(USER_ALL_OWFPASSWORD|USER_ALL_PASSWORDMUSTCHANGE),FALSE},
        {SAMP_USER_NT_PWD_HISTORY,USER_ALL_PRIVATEDATA,FALSE},
        {SAMP_USER_LM_PWD_HISTORY,USER_ALL_PRIVATEDATA,FALSE}
    }
};



//
// MISCELLANEOUS HELPER ROUTINES
//

VOID
SampFreeAttributeBlock(
    IN DSATTRBLOCK * AttrBlock
    )
/*
    Routine Description:
        This routine Frees a DS Attrblock structure allocated
        out of the process Heap

    Arguments

      AttrBlock - Pointer to the Attrblock

    Return Values:

      None
*/
{
   ULONG i;
   ULONG j;

   if (NULL!=AttrBlock)
   {
      if (NULL!=AttrBlock->pAttr)
      {
         for(i=0;i<AttrBlock->attrCount;i++)
         {
            if (NULL!=AttrBlock->pAttr[i].AttrVal.pAVal)
            {
               for(j=0;j<AttrBlock->pAttr[i].AttrVal.valCount;j++)
               {
                  if (NULL!=AttrBlock->pAttr[i].AttrVal.pAVal[j].pVal)
                      RtlFreeHeap(RtlProcessHeap(),0,AttrBlock->pAttr[i].AttrVal.pAVal[j].pVal);
               }
               RtlFreeHeap(RtlProcessHeap(),0,AttrBlock->pAttr[i].AttrVal.pAVal);
             }
         }
         RtlFreeHeap(RtlProcessHeap(),0,AttrBlock->pAttr);
      }
      RtlFreeHeap(RtlProcessHeap(),0,AttrBlock);
    }
}




NTSTATUS
SampFreeSamAttributes(
    IN PSAMP_VARIABLE_LENGTH_ATTRIBUTE SamAttributes
    )

/*++

Routine Description:

    (Under development)

Arguments:



Return Value:


--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampFreeSamAttributes");

    return(NtStatus);
}



NTSTATUS
SampReallocateBuffer(
    IN ULONG OldLength,
    IN ULONG NewLength,
    IN OUT PVOID *Buffer
    )

/*++

Routine Description:

    This routine resizes an in-memory buffer. The routine can either grow or
    shrink the buffer based on specified lengths. Data is preserved from old
    to new buffers, truncating if the new buffer is shorter than the actual
    data length. The newly allocated buffer is returned as an out parameter,
    the passed in buffer is released for the caller.

Arguments:

    OldLength - Length of the buffer passed into the routine.

    NewLength - Length of the re-allocated buffer.

    Buffer - Pointer, incoming buffer to resize, outgoing new buffer.

Return Value:

    STATUS_SUCCESS - Buffer header block allocated and initialized.

    Other codes indicating the nature of the failure.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    PVOID BufferTmp = NULL;

    SAMTRACE("SampReallocateBuffer");

    if ((NULL != Buffer)  &&
        (NULL != *Buffer) &&
        (0 < OldLength)   &&
        (0 < NewLength))
    {
        // Allocate a new buffer and set the temporary variable. Note that
        // the routine does not destroy the old buffer if there is any kind
        // of failure along the way.

        BufferTmp = RtlAllocateHeap(RtlProcessHeap(), 0, NewLength);

        if (NULL != BufferTmp)
        {
            RtlZeroMemory(BufferTmp, NewLength);

            // Copy the original buffer into the new one, truncating data if
            // the new buffer is shorter than the original data size.

            if (OldLength < NewLength)
            {
                RtlCopyMemory(BufferTmp, *Buffer, OldLength);
            }
            else
            {
                RtlCopyMemory(BufferTmp, *Buffer, NewLength);
            }

            // If all has worked, delete the old buffer and set the outgoing
            // buffer pointer.

            RtlFreeHeap(RtlProcessHeap(), 0, *Buffer);
            *Buffer = BufferTmp;

            NtStatus = STATUS_SUCCESS;
        }
        else
        {
            NtStatus = STATUS_NO_MEMORY;
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return(NtStatus);
}



BOOLEAN
IsGroupMembershipAttr(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG AttrIndex
    )
{
    BOOLEAN RetValue = FALSE;


    switch(ObjectType)
    {
    case SampGroupObjectType:
        if (SAMP_GROUP_MEMBERS== 
            SampVarAttributeInfo[ObjectType][AttrIndex].Type)
        {
            RetValue = TRUE;
        }
        break;

     case SampAliasObjectType:
        if (SAMP_ALIAS_MEMBERS== 
            SampVarAttributeInfo[ObjectType][AttrIndex].Type)
        {
            RetValue = TRUE;
        }
        break;

     case SampUserObjectType:
        if (SAMP_USER_GROUPS== 
            SampVarAttributeInfo[ObjectType][AttrIndex].Type)
        {
            RetValue = TRUE;
        }

        break;
    }


    return (RetValue);
}




//
// ATTRBLOCK-TO-VARIABLE LENGTH CONVERSION ROUTINES
//

NTSTATUS
SampInitializeVarLengthAttributeBuffer(
    IN ULONG AttributeCount,
    OUT PULONG BufferLength,
    OUT PSAMP_VARIABLE_LENGTH_ATTRIBUTE *SamAttributes
    )

/*++

Routine Description:

    This routine sets up the SAM attribute buffer that is the destination for
    attributes read from the DS backing store. The buffer contains a header,
    followed by variable-length attributes (SAMP_VARIABLE_LENGTH_ATTRIBUTE).

    This routine allocates memory for the buffer header and zeros it out.

Arguments:

    AttributeCount - Number of variable-length attributes.

    BufferLength - Pointer, buffer size allocated by this routine.

    SamAttributes - Pointer, returned buffer.

Return Value:

    STATUS_SUCCESS - Buffer header block allocated and initialized.

    Other codes indicating the nature of the failure.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG Length = 0;

    SAMTRACE("SampInitializeVarLengthAttributeBuffer");

    if (0 < AttributeCount)
    {
        // Calculate the space needed for the attribute-offset array. If the
        // attribute count is zero, skip the allocation and return an error.

        Length = AttributeCount * sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE);

        if (NULL != SamAttributes)
        {
            *SamAttributes = RtlAllocateHeap(RtlProcessHeap(), 0, Length);

            if (NULL != *SamAttributes)
            {
                // Initialize the block and return the updated buffer offset,
                // which now points to the last byte of the header block.

                RtlZeroMemory(*SamAttributes, Length);

                if (NULL != BufferLength)
                {
                    *BufferLength = Length;
                    NtStatus = STATUS_SUCCESS;
                }
            }
            else
            {
                NtStatus = STATUS_NO_MEMORY;
            }
        }
    }

    return(NtStatus);
}



NTSTATUS
SampExtractAttributeFromDsAttr(
    IN PDSATTR Attribute,
    OUT PULONG MultiValuedCount,
    OUT PULONG Length,
    OUT PVOID  Buffer
    )

/*++

Routine Description:

    This routine determines whether or not the current attribute is single-
    valued or multi-valued and returns a buffer containing the value(s) of
    the attribute. If the attribute is multi-valued, the values are appended
    in the buffer.

Arguments:

    Attribute - Pointer, incoming DS attribute structure.

    MultiValuedCount - Pointer, returned count of the number of values found
        for this attribute.

    Length - Pointer, returned buffer length.

    Buffer - Pointer, returned buffer containing one or more values.
             Caller has the responsibility of allocating an appropriate sized
             buffer.

Return Value:

    STATUS_SUCCESS - Buffer header block allocated and initialized.

    Other codes indicating the nature of the failure.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG ValueCount = 0;
    PDSATTRVALBLOCK ValueBlock;
    PDSATTRVAL Values = NULL;
    ULONG ValueIndex = 0;
    ULONG TotalLength = 0;
    ULONG Offset = 0;
    

    SAMTRACE("SampExtractAttributeFromDsAttr");

    // Get the count of attributes and a pointer to the attribute. Note that
    // it is possible to have multi-valued attributes, in which case they are
    // appended onto the end of the return buffer.

    if (NULL != Attribute)
    {
        // DSATTR structure contains: attrTyp, AttrVal

        ValueBlock = &(Attribute->AttrVal);

        // DSATTRVALBLOCK structure contains: valCount, pAVal

        ValueCount = ValueBlock->valCount;
        Values = ValueBlock->pAVal;

        if ((0 < ValueCount) && (NULL != Values))
        {
            // Multi-valued attribute processing; first determine the total
            // buffer length that will be needed.

            // Note that padded only occurs between values, so the first
            // value should only be padded when followed by another
            // value, and the last value should not be padded
            // Note that the length of each individual value length
            // should not include the amout of padding, of course.

            TotalLength = Values[0].valLen;
            for (ValueIndex = 1; ValueIndex < ValueCount; ValueIndex++)
            {
                // Determine total length needed for this attribute. Because
                // the value lengths may not be DWORD size, pad up to the
                // next DWORD size.
                TotalLength = DWORD_ALIGN(TotalLength);

                TotalLength += Values[ValueIndex].valLen;
            }
        }

        //
        // if the passed in length was less then return buffer too small
        //

        if (*Length < TotalLength)
        {
            *Length = TotalLength;
            return ( STATUS_BUFFER_TOO_SMALL);
        }

        if ((0 < TotalLength) && (NULL != Buffer))
        {

           RtlZeroMemory(Buffer, TotalLength);

           for (ValueIndex = 0;
                 ValueIndex < ValueCount;
                 ValueIndex++)
           {
                // DSATTRVAL structure contains: valLen, pVal. Append
                // subsequent values onto the end of the buffer, up-
                // dating the end-of-buffer offset each time.

                RtlCopyMemory(((BYTE *)Buffer + Offset),
                             (PBYTE)(Values[ValueIndex].pVal),
                             Values[ValueIndex].valLen);

                // Adjust the offset up to the next DWORD boundary.

                Offset += DWORD_ALIGN(Values[ValueIndex].valLen);
            }

            if ((NULL != MultiValuedCount) && (NULL != Length))
            {
               // Finished, update return values.

               *MultiValuedCount = ValueCount;
               *Length = TotalLength;
               NtStatus = STATUS_SUCCESS;
            }
        }
    }

    return(NtStatus);
}



NTSTATUS
SampVerifyVarLengthAttribute(
    IN INT ObjectType,
    IN ULONG AttrIndex,
    IN ULONG MultiValuedCount,
    IN ULONG AttributeLength
    )

/*++

Routine Description:

    This routine is under construction.

Arguments:


Return Value:

    STATUS_SUCCESS - Buffer header block allocated and initialized.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampVerifyVarLengthAttribute");

    // BUG: Define a table of variable-length attribute information.

    switch(ObjectType)
    {

    // For each SAM object type, verify that attributes that are supposed to
    // be single valued, have a MultiValueCount of 1 (multi-valued attributes
    // can have a count greater-than or equal to 1).

    case SampServerObjectType:

        if (1 == MultiValuedCount)
        {
            NtStatus = STATUS_SUCCESS;
        }

        break;

    case SampDomainObjectType:

        if (1 == MultiValuedCount)
        {
            NtStatus = STATUS_SUCCESS;
        }

        break;

    case SampGroupObjectType:

        // Multi-valued attribute

        if ((SAMP_GROUP_MEMBERS != AttrIndex))
        {
            if (1 == MultiValuedCount)
            {
                NtStatus = STATUS_SUCCESS;
            }
        }

        break;

    case SampAliasObjectType:

        // Multi-valued attribute

        if ((SAMP_ALIAS_MEMBERS != AttrIndex))
        {
            if (1 == MultiValuedCount)
            {
                NtStatus = STATUS_SUCCESS;
            }
        }

        break;

    case SampUserObjectType:

        // Multi-valued attributes

        if ((SAMP_USER_GROUPS != AttrIndex) &&
            (SAMP_USER_LOGON_HOURS != AttrIndex))
        {
            if (1 == MultiValuedCount)
            {
                NtStatus = STATUS_SUCCESS;
            }
        }

        break;

    default:

        break;

    }

    NtStatus = STATUS_SUCCESS;

    return(NtStatus);
}



NTSTATUS
SampAppendVarLengthAttributeToBuffer(
    IN INT ObjectType,
    IN ULONG AttrIndex,
    IN PVOID NewAttribute,
    IN ULONG MultiValuedCount,
    IN ULONG AttributeLength,
    IN OUT PULONG BufferLength,
    IN OUT PULONG BufferLengthUsed,
    IN OUT PSAMP_VARIABLE_LENGTH_ATTRIBUTE *SamAttributes
    )

/*++

Routine Description:

    This routine appends the current attribute onto the end of the attribute
    buffer, and updates the SAMP_VARIABLE_LENGTH_DATA structures in the head-
    er of the buffer with new offset, length, and qualifier information.

Arguments:

    AttrIndex - Index into the array of variable-length offsets.

    NewAttribute - Pointer, the new attribute to be appended to the buffer.

    MultiValuedCount - Number of values for the attribute.

    AttributeLength - Number of bytes of the attribute.

    BufferLength - Pointer, incoming contains the current length of the buf-
        fer; outgoing contains the updated length after appending the latest
        attribute.

    BufferLength - Pointer, incoming contains the current length of the buffer
       that has been used so far. Outgoing containes the updated length of the
       buffer that has been used.

    SamAttributes - Pointer, SAMP_VARIABLE_LENGTH_ATTRIBUTE buffer.

Return Value:

    STATUS_SUCCESS - Buffer header block allocated and initialized.

    Other codes indicating the nature of the failure.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG NewLength = 0;
    #define SAMP_DS_ONDISK_BUFFER_GROWTH_SIZE 512

    SAMTRACE("SampAppendVarLengthAttributeToBuffer");

    if (AttributeLength>0)
    {
        // Compute the required buffer length needed to append the attribute.

        // BUG: >>>TECHNOLOGY PREVIEW HACK BELOW THIS LINE<<<

        if ((SampUserObjectType == ObjectType) &&
            (SAMP_USER_LOGON_HOURS == AttrIndex))
        {
            // (*SamAttributes + AttrIndex)->Qualifier = *((DWORD*)NewAttribute);
            // NewAttribute = ((PBYTE)NewAttribute) + sizeof(DWORD);
            // AttributeLength -= sizeof(DWORD);

            (*SamAttributes + AttrIndex)->Qualifier = 0xa8;
        }
        else
        {
            (*SamAttributes + AttrIndex)->Qualifier = MultiValuedCount;
        }

        // BUG: >>>TECHNOLOGY PREVIEW HACK ABOVE THIS LINE<<<

        // DWORD_ALIGN the space for the value so the next value will be
        // be aligned.

        NewLength = *BufferLengthUsed + DWORD_ALIGN(AttributeLength);

        if ( (*BufferLength) < NewLength)
        {
            // Adjust buffer size for the attribute.

            NtStatus = SampReallocateBuffer(*BufferLengthUsed,
                                            NewLength+SAMP_DS_ONDISK_BUFFER_GROWTH_SIZE,
                                            SamAttributes);

            if (NT_SUCCESS(NtStatus))
            {
                *BufferLength = NewLength+SAMP_DS_ONDISK_BUFFER_GROWTH_SIZE;
            }
        }

        if (NT_SUCCESS(NtStatus))
        {
            // Zero out the allocated memory in case of padding

            RtlZeroMemory((((PBYTE)(*SamAttributes)) + *BufferLengthUsed),
                         DWORD_ALIGN(AttributeLength));

            // Append the attribute onto the return buffer.

            RtlCopyMemory((((PBYTE)(*SamAttributes)) + *BufferLengthUsed),
                         NewAttribute,
                         AttributeLength);

            // Update the variable-length header information for the latest
            // attribute.

            (*SamAttributes + AttrIndex)->Offset = *BufferLengthUsed;
            (*SamAttributes + AttrIndex)->Length = AttributeLength;

            // Pass back the updated buffer length.

            *BufferLengthUsed = NewLength;

            DebugPrint("BufferLength = %lu\n", *BufferLength);
            DebugPrint("NewLength = %lu\n", NewLength);
            DebugPrint("SamAttributes Offset = %lu\n",      (*SamAttributes + AttrIndex)->Offset);
            DebugPrint("SamAttributes Length = %lu\n",      (*SamAttributes + AttrIndex)->Length);
            DebugPrint("SamAttributes Qualifier = %lu\n",   (*SamAttributes + AttrIndex)->Qualifier);
        }
    }
    else
    {
            // Update the variable-length header information for the latest
            // attribute.

            (*SamAttributes + AttrIndex)->Offset = *BufferLengthUsed;
            (*SamAttributes + AttrIndex)->Length = 0;

            // BUG: Assuming that Qualifier is used for multi-value count?

            (*SamAttributes + AttrIndex)->Qualifier = MultiValuedCount;
            NtStatus = STATUS_SUCCESS;
    }

    return(NtStatus);
}



NTSTATUS
SampConvertAttrBlockToVarLengthAttributes(
    IN INT ObjectType,
    IN PDSATTRBLOCK DsAttributes,
    OUT PSAMP_VARIABLE_LENGTH_ATTRIBUTE *SamAttributes,
    OUT PULONG TotalLength
    )

/*++

Routine Description:

    This routine extracts the DS attributes from a DS READRES structure and
    builds a SAMP_VARIABLE_LENGTH_BUFFER with them. This routine allocates
    the necessary memory block for the SAM variable-length attribute buffer.

    This routine assumes that the attributes passed in via the READRES struc-
    ture are in the correct order (as known to SAM).

Arguments:

    ObjectType - SAM object type identifier (this parameter is currently un-
        used, but will likely be used to set the maximum number of attributes
        for any given conversion).

    DsAttributes - Pointer, DS attribute list.

    SamAttributes - Pointer, returned SAM variable-length attribute buffer.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG AttributeCount = 0;
    PDSATTR Attributes = NULL;
    ULONG BufferLength = 0;
    ULONG BufferLengthUsed=0;
    ULONG AttrIndex = 0;
    ULONG AttributeLength = 0;
    ULONG AttributeBufferLength = 0;
    ULONG MultiValuedCount = 0;
    PVOID Attribute = NULL;
    ULONG DsIndex   = 0;

    #define SAM_INITIAL_ATTRIBUTE_BUFFER_SIZE 512

    SAMTRACE("SampConvertAttrBlockToVarLengthAttributes");

    if ((NULL != DsAttributes) && (NULL != SamAttributes))
    {
        // Get the attribute count and a pointer to the attributes.

        switch(ObjectType)
        {
            case SampDomainObjectType:
                AttributeCount = SAMP_DOMAIN_VARIABLE_ATTRIBUTES;
                break;
            case SampServerObjectType:
                AttributeCount = SAMP_SERVER_VARIABLE_ATTRIBUTES;
                break;
            case SampGroupObjectType:
                AttributeCount = SAMP_GROUP_VARIABLE_ATTRIBUTES;
                break;
            case SampAliasObjectType:
                AttributeCount = SAMP_ALIAS_VARIABLE_ATTRIBUTES;
                break;
            case SampUserObjectType:
                AttributeCount = SAMP_USER_VARIABLE_ATTRIBUTES;
                break;
            default:
                ASSERT(FALSE);
                return(STATUS_INVALID_PARAMETER);
        }

        Attributes = DsAttributes->pAttr;

        if ((0 < AttributeCount) && (NULL != Attributes))
        {
            // Set up the variable-length attribute buffer header based on the
            // number of attributes. Allocate and initialize the SamAttributes
            // buffer. Update BufferLength to reflect the new size.

            NtStatus = SampInitializeVarLengthAttributeBuffer(
                                                     AttributeCount,
                                                     &BufferLength,
                                                     SamAttributes);
            BufferLengthUsed = BufferLength;
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    //
    // Pre allocate memory for the attributes
    //

    Attribute = MIDL_user_allocate(SAM_INITIAL_ATTRIBUTE_BUFFER_SIZE);
    if (NULL!=Attribute)
    {
       AttributeBufferLength = SAM_INITIAL_ATTRIBUTE_BUFFER_SIZE;
    }
    else
    {
        NtStatus = STATUS_NO_MEMORY;
    }
        

    if (NT_SUCCESS(NtStatus))
    {
        // For each attribute, get its value (or values in the case of multi-
        // valued attributes).

        DsIndex = 0;

        for (AttrIndex = 0; AttrIndex < AttributeCount ; AttrIndex++)
        {
            // A given attribute may be multi-valued, in which case multiple
            // values are simply concatenated together. MultiValuedCount will
            // contain the number of values for the attribute.

            if ((DsIndex < DsAttributes->attrCount)
                 && (Attributes[DsIndex].attrTyp==AttrIndex))
            {
                //
                // Ds Actually Returned the Attribute
                //

                AttributeLength = AttributeBufferLength;

                NtStatus = SampExtractAttributeFromDsAttr(
                                                &(Attributes[DsIndex]),
                                                &MultiValuedCount,
                                                &AttributeLength,
                                                Attribute);

                if (STATUS_BUFFER_TOO_SMALL==NtStatus)
                {
                    //
                    // The attribute is bigger than the buffer
                    //
                    if (NULL!=Attribute)
                    {
                        MIDL_user_free(Attribute);
                    }
                    Attribute = MIDL_user_allocate(AttributeLength);
                    if (NULL!=Attribute)
                    {
                        AttributeBufferLength = AttributeLength;
                        NtStatus = SampExtractAttributeFromDsAttr(
                                                &(Attributes[DsIndex]),
                                                &MultiValuedCount,
                                                &AttributeLength,
                                                Attribute
                                                ); 
                    }
                    else
                    {
                       NtStatus = STATUS_NO_MEMORY;
                    }
                 }
                       

                // Verify that the DS has returned SAM attributes correctly. Check
                // such things as attribute length, single vs. multi-value status.

                if (NT_SUCCESS(NtStatus))
                {
                    NtStatus = SampVerifyVarLengthAttribute(ObjectType,
                                                        AttrIndex,
                                                        MultiValuedCount,
                                                        AttributeLength);
                }
                if (NT_SUCCESS(NtStatus))
                {
                    // Append the current attribute onto the end of the SAM vari-
                    // able length attribute buffer and update the offset array.

                    // AttrIndex is not only the loop counter, but is also the
                    // index into the proper element of the variable-length attr-
                    // ibute array. NOTE: This routine assumes that the order in
                    // which the elements were returned in the READRES buffer is
                    // in fact the correct order of the SAM attributes as defined
                    // in samsrvp.h

                    NtStatus = SampAppendVarLengthAttributeToBuffer(
                                                           ObjectType,
                                                           AttrIndex,
                                                           Attribute,
                                                           MultiValuedCount,
                                                           AttributeLength,
                                                           &BufferLength,
                                                           &BufferLengthUsed,
                                                           SamAttributes);

                }


                DsIndex++;
            }
            else if ((DsIndex < DsAttributes->attrCount)
                    && (Attributes[DsIndex].attrTyp >= AttributeCount))
            {
               //
               // Case where we do not care about the Attribute
               // SAMP_USER_GROUPS_UNUSED
               //
                NtStatus = SampAppendVarLengthAttributeToBuffer(
                                                        ObjectType,
                                                        AttrIndex,
                                                        NULL,
                                                        0,
                                                        0,
                                                        &BufferLength,
                                                        &BufferLengthUsed,
                                                        SamAttributes);

                DsIndex++;
            }
            else
            {
                //
                // The Attribute was not returned. Append NULL Attribute
                //

                NtStatus = SampAppendVarLengthAttributeToBuffer(
                                                        ObjectType,
                                                        AttrIndex,
                                                        NULL,
                                                        0,
                                                        0,
                                                        &BufferLength,
                                                        &BufferLengthUsed,
                                                        SamAttributes);
            }


            if (!NT_SUCCESS(NtStatus))
            {
                // Detect failure of either routine and break for return. Let
                // the caller release the memory that is returned.

                break;
            }
        }

        if (NULL != TotalLength)
        {
            *TotalLength = BufferLength;
        }
        else
        {
            NtStatus = STATUS_INVALID_PARAMETER;
        }
    }

    if (NULL!=Attribute)
    {
        MIDL_user_free(Attribute);
    }

    return(NtStatus);
}



//
// VARIABLE LENGTH-TO-ATTRBLOCK CONVERSION ROUTINES
//

BOOLEAN
SampIsQualifierTheCount(
    IN INT ObjectType,
    IN ULONG AttrIndex
    )
{
    BOOLEAN IsCount = FALSE;

    SAMTRACE("SampIsQualifierTheCount");

    switch(ObjectType)
    {

    case SampServerObjectType:

        IsCount = FALSE;

        break;

    case SampDomainObjectType:

        IsCount = FALSE;

        break;

    case SampGroupObjectType:

        // Multi-valued attribute

        if ((SAMP_GROUP_MEMBERS == AttrIndex))
        {
            IsCount = TRUE;
        }

        break;

    case SampAliasObjectType:

        // Multi-valued attribute

        if ((SAMP_ALIAS_MEMBERS == AttrIndex))
        {
            IsCount = TRUE;
        }

        break;

    case SampUserObjectType:

        // Multi-valued attributes

        if (SAMP_USER_GROUPS == AttrIndex)
        {
            IsCount = TRUE;
        }

        break;

    default:

        // Error

        break;

    }

    return(IsCount);

}



NTSTATUS
SampConvertAndAppendAttribute(
    IN INT ObjectType,
    IN ULONG AttrIndex,
    IN ULONG CurrentAttribute,
    IN PSAMP_VARIABLE_LENGTH_ATTRIBUTE SamAttributes,
    OUT PDSATTR Attributes
    )

/*++

Routine Description:

    This routine does the work of converting a variable-length attribute from
    a SAM buffer into a DS attribute. A DSATTR structure is constructed and
    passed back from this routine to the caller.

Arguments:

    ObjectType - SAM object type identifier (this parameter is currently un-
        used, but will likely be used to set the maximum number of attributes
        for any given conversion).

    AttrIndex - Index into the array of the variable-length attribute inform-
        ation 
        
    CurrentAttribute - Index into the DS attribute array (i.e. the current attribute).

    SamAttributes - Pointer, returned SAM variable-length attribute buffer.

    Attributes - Pointer, the returned DS attribute structure.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG Offset = SamAttributes[AttrIndex].Offset;
    ULONG Length = SamAttributes[AttrIndex].Length;
    ULONG MultiValuedCount = SamAttributes[AttrIndex].Qualifier;
    BOOLEAN SpecialFlag = FALSE;
    ULONG Index = 0;
    PDSATTRVAL Attribute = NULL;
    PBYTE Value = NULL;

    SAMTRACE("SampConvertAndAppendAttribute");

    // Set the attribute type to the equivalent DS data type.

    Attributes[CurrentAttribute].attrTyp =
        SampVarAttributeInfo[ObjectType][AttrIndex].Type;


    if (TRUE == SampIsQualifierTheCount(ObjectType, AttrIndex))
    {
        // Qualifier contains the attribute's multi-value count.

        Attributes[CurrentAttribute].AttrVal.valCount = MultiValuedCount;
    }
    else
    {
       
        // Qualifier is used for group, alias, membership counts, in which
        // case it serves as the count of a multivalued attribute count. In
        // other cases, it has another meaning:
        //
        // SAM server revision value
        // SAM user-logon hours time units
        //
        // and is not a multivalued count, but something else. These must be
        // handled as special-case values (see below).
        //
        // These are "special" attributes! Add more cases as needed.

        if ((SampUserObjectType == ObjectType) &&
            (SAMP_USER_LOGON_HOURS == AttrIndex))
        {
            SpecialFlag = TRUE;
        }

        MultiValuedCount = 1;
        Attributes[CurrentAttribute].AttrVal.valCount = 1;

    }

    // Allocate memory for the attribute (array if multi-valued).

    Attribute = RtlAllocateHeap(RtlProcessHeap(),
                                0,
                                (MultiValuedCount * sizeof(DSATTRVAL)));
    if (NULL == Attribute) {
        NtStatus = STATUS_NO_MEMORY;
        goto Exit;
    }

    RtlZeroMemory(Attribute, (MultiValuedCount * sizeof(DSATTRVAL)));

    // Begin construction of the DSATTR structure by setting the pointer
    // the to the attribute.

    Attributes[CurrentAttribute].AttrVal.pAVal = Attribute;

    // SAM does not store per-value length information for multi-valued
    // attributes, instead the total length of all of the values of a
    // single attribute is stored.

    // Length is the number of bytes in the overall attribute. If the
    // attribute is multi-valued, then this length is the total length
    // of all of the attribute values. The per-value allocation is equal
    // to the Length divided by the number of values (because all values
    // of all multi-valued attributes are a fixed size (i.e. ULONG or
    // LARGE_INTEGER).

    // Test to make sure that total length is an integral multiple of the
    // number of values--a sanity check.

    if (0 == (Length % MultiValuedCount))
    {
        Length = (Length / MultiValuedCount);
    }
    else
    {
        // The length is erroneous, fail
        NtStatus = STATUS_INTERNAL_ERROR;
        goto Exit;
    }

    for (Index = 0; Index < MultiValuedCount; Index++)
    {
        // Allocate memory for the attribute data.

        Value = RtlAllocateHeap(RtlProcessHeap(), 0, Length);
        if (NULL == Value) {
            NtStatus = STATUS_NO_MEMORY;
            goto Exit;
        }

        RtlZeroMemory(Value, Length);

        // For each value, in the attribute, store its length and
        // copy the value into the destination buffer.

        Attribute[Index].valLen = Length;
        Attribute[Index].pVal = Value;

        // Note: SamAttributes is passed in as PSAMP_VARIABLE_-
        // LENGTH_ATTRIBUTE, hence is explicitly cast to a byte
        // pointer to do the byte-offset arithmetic correctly
        // for RtlCopyMemory.

        if (FALSE == SpecialFlag)
        {
            // Qualifier was the count, so just copy the attribute.

            RtlCopyMemory(Value,
                          (((PBYTE)SamAttributes) + Offset),
                          Length);
        }
        else
        {
            
            // Qualifier was not the count, so first copy the value
            // of the Qualifier and then append the remaining SAM
            // attribute onto the end of the buffer, creating a blob
            // of concatenated values. Note that the first element
            // is a DWORD, so will be aligned correctly. Enjoy.

         
            RtlCopyMemory(Value,
                          (((PBYTE)SamAttributes) + Offset),
                          Length);

          
        }

        // Adjust the SAM-buffer offset to point at the next value in
        // the multi-valued attribute.

        Offset += Length;
    }


Exit:

    return(NtStatus);
}



NTSTATUS
SampConvertVarLengthAttributesToAttrBlock(
    IN PSAMP_OBJECT Context,
    IN PSAMP_VARIABLE_LENGTH_ATTRIBUTE SamAttributes,
    OUT PDSATTRBLOCK *DsAttributes
    )

/*++

Routine Description:

    This routine determines the SAM object type so that the attribute count
    can be set, and then performs the attribute conversion. This routine al-
    locates the top-level DS structure and then calls a helper routine to
    fill in the rest of the data.

Arguments:

    ObjectType - SAM object type identifier (this parameter is currently un-
        used, but will likely be used to set the maximum number of attributes
        for any given conversion).

    SamAttributes - Pointer, returned SAM variable-length attribute buffer.

    DsAttributes - Pointer, the returned DS attribute structure.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG AttributeCount = 0;
    PDSATTR Attributes = NULL;
    PVOID Attribute = NULL;
    ULONG AttrIndex = 0;
    ULONG Length = 0;
    ULONG Qualifier = 0;
    SAMP_OBJECT_TYPE ObjectType = Context->ObjectType;

    SAMTRACE("SampConvertVarLengthAttributesToAttrBlock");

    ASSERT(DsAttributes);
    ASSERT(SamAttributes);

    // Allocate the top-level structure.

    *DsAttributes = RtlAllocateHeap(RtlProcessHeap(),
                                    0,
                                    sizeof(DSATTRBLOCK));

    if (NULL == *DsAttributes)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(*DsAttributes, sizeof(DSATTRBLOCK));

    // Determine the object type, and hence set the corresponding
    // attribute count.

    switch(ObjectType)
    {

    case SampServerObjectType:

        AttributeCount = SAMP_SERVER_VARIABLE_ATTRIBUTES;
        break;

    case SampDomainObjectType:

        AttributeCount = SAMP_DOMAIN_VARIABLE_ATTRIBUTES;
        break;

    case SampGroupObjectType:

        AttributeCount = SAMP_GROUP_VARIABLE_ATTRIBUTES;
        break;

    case SampAliasObjectType:

        AttributeCount = SAMP_ALIAS_VARIABLE_ATTRIBUTES;
        break;

    case SampUserObjectType:

        AttributeCount = SAMP_USER_VARIABLE_ATTRIBUTES;
        break;

    default:

        AttributeCount = 0;
        break;

    }

    DebugPrint("AttributeCount = %lu\n", AttributeCount);

    // Allocate the array of DS attribute-information structs.

    Attributes = RtlAllocateHeap(RtlProcessHeap(),
                                 0,
                                 (AttributeCount * sizeof(DSATTR)));

    if (NULL != Attributes)
    {
        RtlZeroMemory(Attributes, (AttributeCount * sizeof(DSATTR)));

        (*DsAttributes)->attrCount = 0;
        (*DsAttributes)->pAttr = Attributes;

        // Walk through the array of attributes, converting each
        // SAM variable-length attribute to a DS attribute. Refer to
        // the DS header files (core.h, drs.h) for definitions of
        // these structures.

        for (AttrIndex = 0; AttrIndex < AttributeCount; AttrIndex++)
        {
            if ((RtlCheckBit(&Context->PerAttributeDirtyBits, AttrIndex))
                && (!IsGroupMembershipAttr(Context->ObjectType,AttrIndex)))
            {
                //
                // The per attribute dirty is also set. Add this attribute
                // to the attributes to flush
                //

                NtStatus = SampConvertAndAppendAttribute(ObjectType,
                                                     AttrIndex,
                                                     (*DsAttributes)->attrCount,
                                                     SamAttributes,
                                                     Attributes);

                if (!NT_SUCCESS(NtStatus))
                {
                    break;
                }

                (*DsAttributes)->attrCount++;

                DebugPrint("attrCount = %lu\n", (*DsAttributes)->attrCount);
                DebugPrint("attrTyp = %lu\n",   (*DsAttributes)->pAttr[AttrIndex].attrTyp);
                DebugPrint("valCount = %lu\n",   (*DsAttributes)->pAttr[AttrIndex].AttrVal.valCount);
                DebugPrint("valLen = %lu\n",    (*DsAttributes)->pAttr[AttrIndex].AttrVal.pAVal->valLen);
            }
            
        }
    }
    else
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // In the error case, memory should be free by caller by 
    // calling SampFreeAttributeBlock().
    // 

    return(NtStatus);
}



//
// ATTRBLOCK-TO-FIXED LENGTH CONVERSION ROUTINES
//

NTSTATUS
SampExtractFixedLengthAttributeFromDsAttr(
    IN PDSATTR Attribute,
    OUT PULONG Length,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    This routine determines whether or not the current attribute is single-
    valued or multi-valued and returns a buffer containing the value(s) of
    the attribute. The Call is failed if Multi Valued attributes are present.
    The Assumption is that all fixed attributes are just single valued.

Arguments:

    Attribute - Pointer, incoming DS attribute structure.

    Length - Pointer, returned buffer length.

    Buffer - Pointer, returned buffer containing one or more values.

Return Value:

    STATUS_SUCCESS - Buffer header block allocated and initialized.

    Other codes indicating the nature of the failure.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG ValueCount = 0;
    PDSATTRVALBLOCK ValueBlock;
    PDSATTRVAL Values = NULL;
    ULONG ValueIndex = 0;
    ULONG TotalLength = 0;
    ULONG Offset = 0;

    SAMTRACE("SampExtractFixedLengthAttributeFromDsAttr");

    // Get the count of attributes and a pointer to the attribute. Note that
    // it is possible to have multi-valued attributes, in which case they are
    // appended onto the end of the return buffer.

    if (NULL != Attribute)
    {
        // DSATTR structure contains: attrTyp, AttrVal

        ValueBlock = &(Attribute->AttrVal);

        // DSATTRVALBLOCK structure contains: valCount, pAVal

        if (NULL != ValueBlock)
        {
            ValueCount = ValueBlock->valCount;
            Values = ValueBlock->pAVal;

            if ((1==ValueCount) && (0!=Values->valLen) && (NULL!=Values->pVal))
            {
                *Buffer = Values->pVal;
                *Length = Values->valLen;
                NtStatus = STATUS_SUCCESS;
            }
        }
    }

    return(NtStatus);
}



NTSTATUS
SampVerifyFixedLengthAttribute(
    IN INT ObjectType,
    IN ULONG AttrIndex,
    IN ULONG AttributeLength
    )

/*++

Routine Description:

    This routine verifies that the length of a given (fixed-length) attribute
    obtained from the attribute information in a DSATTRBLOCK is in fact the
    correct length. This check is necessary because the underlying data store
    and various internal DS layers remap the SAM data types to their internal
    data types, which may be a different size (e.g. BOOLEAN is mapped to INT).
    Validation of the lenght is accomplished by comparing the passed-in length
    to the a prior known lengths stored in the SampFixedAttributeInfo table.

    NOTE: Currently, this routine simply checks for equality, returning an
    error if the two lengths are not equal. This test may need to "special
    case" certain attributes as the database schema is finalized and more is
    known about the underlying data types.


Arguments:

    ObjectType - SAM Object identifier (server, domain, etc.) index

    AttrIndex - Index into the array of fixed-length attribute length inform-
        ation.

    AttributeLength - Attribute length (byte count) to be verified.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampVerifyFixedLengthAttribute");

    // Verify that the attribute length is correct. The AttributeLength is
    // already rounded up to a DWORD boundary, so do the same for the attri-
    // bute information length.

    if (AttributeLength ==
            (SampFixedAttributeInfo[ObjectType][AttrIndex].Length))
    {
        

        NtStatus = STATUS_SUCCESS;
    }
    else
    {
        DebugPrint("AttributeLength = %lu Length = %lu\n",
                   AttributeLength,
                   SampFixedAttributeInfo[ObjectType][AttrIndex].Length);
    }


    return(NtStatus);
}



NTSTATUS
SampAppendFixedLengthAttributeToBuffer(
    IN INT ObjectType,
    IN ULONG AttrIndex,
    IN PVOID NewAttribute,
    IN OUT PVOID SamAttributes
    )

/*++

Routine Description:

    This routine builds a SAM fixed-length attribute buffer from a correspond-
    ing DS attribute by copying the data into the SAM fixed-length structure.

    Note that pointer-casts during structure member assignment are not only
    needed due to the fact that NewAttribute is a PVOID, but also because the
    DS uses different data types than does SAM for certain data types (e.g.
    SAM USHORT is stored as a four-byte integer in the DS). Refer to the Samp-
    FixedAttributeInfo table for details. The data truncation is benign in
    all cases.

Arguments:

    ObjectType - SAM object type (server, domain, etc.).

    AttrIndex - Index of the attribute to set. This value corresponds to the
        elements of the various fixed-length attributes (see samsrvp.h).

    NewAttribute - The incoming attribute, extracted from the DS data.

    SamAttributes - Pointer, updated SAM attribute buffer.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_V1_FIXED_LENGTH_SERVER ServerAttrs = NULL;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN DomainAttrs = NULL;
    PSAMP_V1_0A_FIXED_LENGTH_GROUP GroupAttrs = NULL;
    PSAMP_V1_FIXED_LENGTH_ALIAS AliasAttrs = NULL;
    PSAMP_V1_0A_FIXED_LENGTH_USER UserAttrs = NULL;

    SAMTRACE("SampAppendFixedLengthAttributeToBuffer");

    ASSERT(NULL != NewAttribute);
    ASSERT(NULL != SamAttributes);

    // BUG: Define constants for the fixed attributes cases.

    // Determine the object type, and then the attribute for that object
    // to copy into the target SAM fixed-length structure.

    switch(ObjectType)
    {

    case SampServerObjectType:

        ServerAttrs = SamAttributes;

        switch(AttrIndex)
        {

        case 0:
            ServerAttrs->RevisionLevel = *(PULONG)NewAttribute;
            break;

        default:
            NtStatus = STATUS_INTERNAL_ERROR;
            break;

        }

        break;

    case SampDomainObjectType:

        DomainAttrs = SamAttributes;

        //
        // The following Domain Attrs are Defaulted rather than
        // Read from the Database
        //

        DomainAttrs->Revision = SAMP_DS_REVISION;
        DomainAttrs->Unused1  = 0;
        DomainAttrs->ServerRole = DomainServerRoleBackup;

        switch(AttrIndex)
        {
        
        case 0:
            DomainAttrs->CreationTime = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 1:
            DomainAttrs->ModifiedCount = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 2:
            DomainAttrs->MaxPasswordAge = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 3:
            DomainAttrs->MinPasswordAge = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 4:
            DomainAttrs->ForceLogoff = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 5:
            DomainAttrs->LockoutDuration = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 6:
            DomainAttrs->LockoutObservationWindow = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 7:
            DomainAttrs->ModifiedCountAtLastPromotion = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 8:
            DomainAttrs->NextRid = *(PULONG)NewAttribute;
            break;

        case 9:
            DomainAttrs->PasswordProperties = *(PULONG)NewAttribute;
            break;

        case 10:
            DomainAttrs->MinPasswordLength = *(PUSHORT)NewAttribute;
            break;

        case 11:
            DomainAttrs->PasswordHistoryLength = *(PUSHORT)NewAttribute;
            break;

        case 12:
            DomainAttrs->LockoutThreshold = *(PUSHORT)NewAttribute;
            break;

        case 13:
            DomainAttrs->ServerState = *(PULONG)NewAttribute;
            break;

       
        case 14:
            DomainAttrs->UasCompatibilityRequired = *(PBOOLEAN)NewAttribute;
            break;

        default:

            ASSERT(FALSE && "Unknown Attribute");
            NtStatus = STATUS_INTERNAL_ERROR;
            break;

        }

        break;

    case SampGroupObjectType:

        GroupAttrs = SamAttributes;

        //
        // The following Group Attrs are defaulted rather than
        // read from the Database
        //

        GroupAttrs->Revision = SAMP_DS_REVISION;
        GroupAttrs->Attributes = SAMP_DEFAULT_GROUP_ATTRIBUTES;
        GroupAttrs->Unused1 = 0;
        GroupAttrs->AdminCount =0;
        GroupAttrs->OperatorCount = 0;

        switch(AttrIndex)
        {

       
        case 0:
            GroupAttrs->RelativeId = *(PULONG)NewAttribute;
            break;

        default:

            ASSERT(FALSE && "Unknown Attribute");
            NtStatus = STATUS_INTERNAL_ERROR;
            break;

        }

        break;

    case SampAliasObjectType:

        AliasAttrs = SamAttributes;

        switch(AttrIndex)
        {

        case 0:
            AliasAttrs->RelativeId = *(PULONG)NewAttribute;
            break;

        default:
            ASSERT(FALSE && "Unknown Attribute");
            NtStatus = STATUS_INTERNAL_ERROR;
            break;

        }

        break;

    case SampUserObjectType:

        UserAttrs = SamAttributes;

        //
        // The following User Attrs are defaulted rather than
        // read from the database
        //
        
        UserAttrs->Revision = SAMP_DS_REVISION;
        UserAttrs->Unused1  = 0;
        UserAttrs->Unused2  = 0;
        UserAttrs->AdminCount = 0;
        UserAttrs->OperatorCount = 0;

        switch(AttrIndex)
        {

       
        case 0:
            UserAttrs->LastLogon = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 1:
            UserAttrs->LastLogoff = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 2:
            UserAttrs->PasswordLastSet = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 3:
            UserAttrs->AccountExpires = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 4:
            UserAttrs->LastBadPasswordTime = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 5:
            UserAttrs->UserId = *(PULONG)NewAttribute;
            break;

        case 6:
            UserAttrs->PrimaryGroupId = *(PULONG)NewAttribute;
            break;

        case 7:
            UserAttrs->UserAccountControl = *(PULONG)NewAttribute;
            break;

        case 8:
            UserAttrs->CountryCode = *(PUSHORT)NewAttribute;
            break;

        case 9:
            UserAttrs->CodePage = *(PUSHORT)NewAttribute;
            break;

        case 10:
            UserAttrs->BadPasswordCount = *(PUSHORT)NewAttribute;
            break;

        case 11:
            UserAttrs->LogonCount = *(PUSHORT)NewAttribute;
            break;

     
        default:
            ASSERT(FALSE && "Unknown Attribute");
            NtStatus = STATUS_INTERNAL_ERROR;
            break;

        }

        break;

    default:
        ASSERT(FALSE && "Unknown Object Type");
        NtStatus = STATUS_INTERNAL_ERROR;
        break;

    }
    

    return(NtStatus);
}


NTSTATUS
SampGetDefaultAttributeValue(
    IN  ULONG            RequestedAttrTyp,
    IN  SAMP_OBJECT_TYPE ObjectType,
    IN  ULONG            BufferSize,
    IN  OUT PVOID        Buffer,
    OUT PULONG           DefaultLen
    )
/*++

  Routine Description

     This Routine Provides Default Values for all those Fixed Attributes
     that are not present in the DS. Not all fixed attributes have default
     values. Only those subset of attributes that are not replicated are
     provided default values by this routine. This is because in the replicated
     install case, they will not be initially set and therefore in order to continue
     we must provide default Values


   Parameters:

        RequestedAttrTyp -- The Attribute that we requested
        ObjectType       -- The object type of the object
        BufferSize       -- The Size of the passed in buffer
        Buffer           -- The Passed in Buffer
        DefaultLen       -- The length of the attribute is returned in here. A length of zero
                            returned in here means that no attribute is found, but the caller
                            should go on without supplying an attribute value for that attribute

   Return Values

    STATUS_SUCCESS
    STATUS_INTERNAL_ERROR

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    switch (ObjectType)
    {
    case SampDomainObjectType:
        switch(RequestedAttrTyp)
        {
       
        //
        // Server State is defaulted to Enabled
        //

        case SAMP_FIXED_DOMAIN_SERVER_STATE:
            *DefaultLen = sizeof(DOMAIN_SERVER_ENABLE_STATE);
            ASSERT(BufferSize>=*DefaultLen);
            *((DOMAIN_SERVER_ENABLE_STATE *)Buffer) = DomainServerEnabled;
            break;

        //
        // Modified Count is defaulted to 1
        //

        case SAMP_FIXED_DOMAIN_MODIFIED_COUNT:
            *DefaultLen = sizeof(LARGE_INTEGER);
             ASSERT(BufferSize>=*DefaultLen);
             ((LARGE_INTEGER *)Buffer)->QuadPart = 1;
             break;

        default:
            NtStatus = STATUS_INTERNAL_ERROR;
            break;
        }
        break;

    case SampUserObjectType:

        switch(RequestedAttrTyp)
        {

        //
        // Logon and Bad pwd counts are defaulted to 0
        //

        case SAMP_FIXED_USER_BAD_PWD_COUNT:
        case SAMP_FIXED_USER_LOGON_COUNT:
        case SAMP_FIXED_USER_COUNTRY_CODE:
        case SAMP_FIXED_USER_CODEPAGE:
         

            *DefaultLen = sizeof(DS_USHORT);
            ASSERT(BufferSize>=*DefaultLen);
            *((DS_USHORT *)Buffer) = 0;
            break;

        //
        // Last Logon, Last Logoff and Bad Pwd Times are defaulted to Never
        //

        case SAMP_FIXED_USER_LAST_LOGON:
        case SAMP_FIXED_USER_LAST_LOGOFF:
        case SAMP_FIXED_USER_LAST_BAD_PASSWORD_TIME:

            *DefaultLen = sizeof(LARGE_INTEGER);
            ASSERT(BufferSize>=*DefaultLen);
            RtlCopyMemory(Buffer,&SampHasNeverTime,sizeof(LARGE_INTEGER));
            break;

        default:
            //
            // Under Normal Circumstances the only properties that may be absent
            // are the non replicable properties above. However in a freshly created
            // account object not all properties are set and therefore this function
            // is called to initialize default values. The value of such defaults is
            // immaterial as the properties would be written to immediately. 
            // This function therefore just returns a length of 0.
            //

            *DefaultLen = 0;
            break;
        }

        break;

        case SampAliasObjectType:
        case SampGroupObjectType:

            //
            // Same Reason as Above
            //

            *DefaultLen = 0;
            break;

    default:

        NtStatus = STATUS_INTERNAL_ERROR;
        break;
    }

    return NtStatus;
}



NTSTATUS
SampConvertAttrBlockToFixedLengthAttributes(
    IN INT ObjectType,
    IN PDSATTRBLOCK DsAttributes,
    OUT PVOID *SamAttributes,
    OUT PULONG TotalLength
    )

/*++

Routine Description:

    This routine converts a DS ATTRBLOCK into a SAM fixed-length buffer. The
    SAM buffer that is passed back from the routine can be either treated as
    a blob or can be cast to one of the SAM fixed-length attribute types for
    convenience.

Arguments:

    ObjectType - Identifies which SAM object type, and hence, which attribute
        set to work with.

    DsAttributes - Pointer, incoming DS ATTRBLOCK containing fixed-length
        attributes.

    SamAttributes - Pointer, updated SAM attribute buffer.

    TotalLength - Pointer, length of the SAM fixed attribute data returned.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG ReturnedAttrCount = 0;
    PDSATTR Attributes = NULL;
    ULONG Length = 0;
    ULONG BufferLength = 0;
    ULONG AttributeLength = 0;
    ULONG ReturnedAttrIndex = 0;
    PVOID AttributeValue = NULL;
    ULONG RequestedAttrIndex=0;
    ULONG RequestedAttrCount=0;
    UCHAR DefaultValueBuffer[sizeof(LARGE_INTEGER)];
    

    SAMTRACE("SampConvertAttrBlockToFixedLengthAttributes");

    ASSERT(NULL!=DsAttributes);
    ASSERT(NULL!=SamAttributes);
    ASSERT(NULL!=TotalLength);    

    ReturnedAttrCount = DsAttributes->attrCount;
    RequestedAttrCount = ARRAY_COUNT(SampFixedAttributeInfo[ObjectType]);
    Attributes = DsAttributes->pAttr;
    
    ASSERT(NULL!=Attributes);

    // Using the SAM object type identifer, set the length of the buffer
    // to be allocated based on the fixed-length data structure.

    switch(ObjectType)
    {

    case SampServerObjectType:

        Length = sizeof(SAMP_V1_FIXED_LENGTH_SERVER);
        break;

    case SampDomainObjectType:

        Length = sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN);
        break;

    case SampGroupObjectType:

        Length = sizeof(SAMP_V1_0A_FIXED_LENGTH_GROUP);
        break;

    case SampAliasObjectType:

        Length = sizeof(SAMP_V1_FIXED_LENGTH_ALIAS);
        break;

    case SampUserObjectType:

        Length = sizeof(SAMP_V1_0A_FIXED_LENGTH_USER);
        break;

    default:

        Length = 0;
        break;
    }

    // Allocate space for the fixed-length attributes.
    
    *SamAttributes = MIDL_user_allocate(Length);

    if (NULL != *SamAttributes)
    {
        RtlZeroMemory(*SamAttributes, Length);

        //
        // Walk the DSATTRBLOCK, pulling out the attributes and returning
        // each one in the Attribute out parameter.
        //

        for (ReturnedAttrIndex = 0,RequestedAttrIndex=0; 
                (ReturnedAttrIndex<ReturnedAttrCount)&&(RequestedAttrIndex<RequestedAttrCount); 
                    RequestedAttrIndex++)
        {

            ULONG   RequestedAttrTyp;
            ULONG   ReturnedAttrTyp;

            AttributeValue = NULL;
            
            // 
            // The Read would have asked for all attributes, but the DS may
            // not have returned all the attributes. In case a particular 
            // attribute was missing, the DS does not give an error value in
            // its place, but rather just simply skips them. Therefore try to
            // match the attribute Type , Starting from the Last Sam Atribute
            // that we matched
            //
            ReturnedAttrTyp = Attributes[ReturnedAttrIndex].attrTyp;
            RequestedAttrTyp  = SampFixedAttributeInfo[ObjectType][RequestedAttrIndex].Type;
            if (RequestedAttrTyp!=ReturnedAttrTyp)
            {
                //
                // The Attribute at RequestedAttrIndex has not been returned by the DS.
                // The reason, for that in the absence of any other error codes is that
                // the attribute is not present. This is a legal condition and in this
                // case provide a default value for the attribute from the table
                //

                
                NtStatus = SampGetDefaultAttributeValue(
                                RequestedAttrTyp,
                                ObjectType,
                                sizeof(DefaultValueBuffer),
                                DefaultValueBuffer,
                                &AttributeLength
                                );

                if (NT_SUCCESS(NtStatus))
                {

                    if (AttributeLength>0)
                    {

                        AttributeValue = DefaultValueBuffer;
                    }
                    else
                    {
                        //
                        // You may get a 0 for a defaulted length. This just
                        // means that the property has not been set and happens
                        // when a new object is being created
                        // 

                        ASSERT(NULL==AttributeValue);
                    }

                }

                //
                // Since we defaulted the attribute we should not proceed to the
                // next returned attribute, ie do not increment ReturnedAttrIndex.
                // We will examine if this returned attribute matches the next 
                // requested attribute.
                //
            }
            else
            {
                //
                // The attribute was returned by the DS.
                //

                NtStatus = SampExtractFixedLengthAttributeFromDsAttr(
                                        &(Attributes[ReturnedAttrIndex]),
                                        &AttributeLength,
                                        &AttributeValue);

                //
                // Verify the extraction
                //

                if (NT_SUCCESS(NtStatus))
                {
                    NtStatus = SampVerifyFixedLengthAttribute(ObjectType,
                                                      RequestedAttrIndex,
                                                      AttributeLength);

                    //
                    // We may now proceed to the next Returned Attribute
                    //

                    ReturnedAttrIndex++;
                }
            }

            // Append the attribute onto the end of the SAM buffer (i.e.
            // fill in the members of the fixed-length data structure).

            // NOTE: This routine assumes that the order of the attributes
            // returned in the DSATTRBLOCK are correct (i.e. correspond
            // to the order of the members in the given SAM fixed-length
            // structure). It also assumes that SAM fixed-length attri-
            // butes are always single-valued attributes.

            if (NT_SUCCESS(NtStatus))
            {

                
                if (NULL!=AttributeValue)
                {
              
                    //
                    // If the Attribute is Non Null then Set it in the
                    // Fixed Attributes Blob
                    //
                    NtStatus = SampAppendFixedLengthAttributeToBuffer(
                                    ObjectType,
                                    RequestedAttrIndex,
                                    AttributeValue,
                                    *SamAttributes
                                    );
                }
                else
                {
                    //
                    // You may have NULL values for attributes in conditions where
                    // you are newly creating objects where all properties are not
                    // yet set. This is O.K and legal.
                    //
                }
                              
            }
            else
            {
                //
                // We error'd out so break out of the loop
                //

                break;
            }
        }
                    
        *TotalLength = Length;
       
    }
    else
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
       
    }

    return(NtStatus);
}



//
// FIXED LENGTH-TO-ATTRBLOCK CONVERSION ROUTINES
//

NTSTATUS
SampConvertFixedLengthAttributes(
    IN INT ObjectType,
    IN PVOID SamAttributes,
    IN ULONG AttributeCount,
    OUT PDSATTR Attributes
    )

/*++

Routine Description:

    This routine does the work of converting a given SAM fixed-length attri-
    bute type (i.e. contains all of the fixed-length attributes pertinent to
    the specified ObjectType) into a DSATTR array. Related DS attribute infor-
    mation, such as attribute length and type, are also set by this routine.

Arguments:

    ObjectType - Identifies which SAM object type, and hence, which attribute
        set to work with.

    SamAttributes - Pointer, updated SAM attribute buffer.

    AttributeCount - Number of attributes to convert into DSATTRs.

    Attributes - Pointer, outgoing DSATTR, containing fixed-length attributes.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG Offset = 0;
    ULONG Length = 0;
    ULONG SamLength=0;
    ULONG Index = 0;
    PDSATTRVAL Attribute = NULL;
    PBYTE Value = NULL;
    ULONG AttrIndex = 0;
    PSAMP_V1_FIXED_LENGTH_SERVER ServerAttrs = NULL;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN DomainAttrs = NULL;
    PSAMP_V1_0A_FIXED_LENGTH_GROUP GroupAttrs = NULL;
    PSAMP_V1_FIXED_LENGTH_ALIAS AliasAttrs = NULL;
    PSAMP_V1_0A_FIXED_LENGTH_USER UserAttrs = NULL;

    SAMTRACE("SampConvertFixedLengthAttributes");

    for (AttrIndex = 0; AttrIndex < AttributeCount; AttrIndex++)
    {
        // BUG: Assuming that all fixed-length attributes are single-valued.

        // Set the multi-value count to 1 for the fixed-length attribute, and
        // set its type identifier.

        Attributes[AttrIndex].AttrVal.valCount = 1;

        Attributes[AttrIndex].attrTyp =
            SampFixedAttributeInfo[ObjectType][AttrIndex].Type;

        // First, allocate a block for the individual DSATTRVAL.

        Attribute = RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(DSATTRVAL));

        if (NULL != Attribute)
        {
            RtlZeroMemory(Attribute, sizeof(DSATTRVAL));

            Attributes[AttrIndex].AttrVal.pAVal = Attribute;
            Length = SampFixedAttributeInfo[ObjectType][AttrIndex].Length;
            SamLength = SampFixedAttributeInfo[ObjectType][AttrIndex].SamLength;
            ASSERT(SamLength<=Length);

            // Second, allocate a block for the actual value, and make the
            // DSATTRVAL point to it.

            Value = RtlAllocateHeap(RtlProcessHeap(), 0, Length);

            if (NULL != Value)
            {
                RtlZeroMemory(Value, Length);
                Attribute->pVal = Value;
                Attribute->valLen = Length;

                // Then copy the data into the target DS attribute.

                switch(ObjectType)
                {

                case SampServerObjectType:

                    ServerAttrs = SamAttributes;

                    switch(AttrIndex)
                    {

                    case 0:
                        RtlCopyMemory(Value,
                                     &(ServerAttrs->RevisionLevel),
                                     SamLength);
                        break;

                    default:
                        ASSERT(FALSE && "UndefinedAttribute");
                        NtStatus = STATUS_INTERNAL_ERROR;
                        break;

                    }

                    break;

                case SampDomainObjectType:

                    DomainAttrs = SamAttributes;

                    switch(AttrIndex)
                    {


                    case 0:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->CreationTime),
                                     SamLength);
                        break;

                    case 1:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->ModifiedCount),
                                     SamLength);
                        break;

                    case 2:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->MaxPasswordAge),
                                     SamLength);
                        break;

                    case 3:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->MinPasswordAge),
                                     SamLength);
                        break;

                    case 4:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->ForceLogoff),
                                     SamLength);
                        break;

                    case 5:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->LockoutDuration),
                                     SamLength);
                        break;

                    case 6:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->LockoutObservationWindow),
                                     SamLength);
                        break;

                    case 7:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->ModifiedCountAtLastPromotion),
                                     SamLength);
                        break;

                    case 8:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->NextRid),
                                     SamLength);
                        break;

                    case 9:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->PasswordProperties),
                                     SamLength);
                        break;

                    case 10:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->MinPasswordLength),
                                     SamLength);
                        break;

                    case 11:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->PasswordHistoryLength),
                                     SamLength);
                        break;

                    case 12:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->LockoutThreshold),
                                     SamLength);
                        break;

                    case 13:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->ServerState),
                                     SamLength);
                        break;
                   
                    case 14:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->UasCompatibilityRequired),
                                     SamLength);
                        break;

                    default:
                        ASSERT(FALSE && "UndefinedAttribute");
                        NtStatus = STATUS_INTERNAL_ERROR;
                        break;

                    }

                    break;

                case SampGroupObjectType:

                    GroupAttrs = SamAttributes;

                    switch(AttrIndex)
                    {

                    
                    case 0:
                        RtlCopyMemory(Value,
                                     &(GroupAttrs->RelativeId),
                                     SamLength);
                        break;

                   
                    default:
                        ASSERT(FALSE && "UndefinedAttribute");
                        NtStatus = STATUS_INTERNAL_ERROR;
                        break;

                    }

                    break;

                case SampAliasObjectType:

                    AliasAttrs = SamAttributes;

                    switch(AttrIndex)
                    {

                    case 0:
                        RtlCopyMemory(Value,
                                     &(AliasAttrs->RelativeId),
                                     SamLength);
                        break;

                    default:
                        ASSERT(FALSE && "UndefinedAttribute");
                        NtStatus = STATUS_INTERNAL_ERROR;
                        break;

                    }

                    break;

                case SampUserObjectType:

                    UserAttrs = SamAttributes;

                    switch(AttrIndex)
                    {

                    case 0:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->LastLogon),
                                     SamLength);
                        break;

                    case 1:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->LastLogoff),
                                     SamLength);
                        break;

                    case 2:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->PasswordLastSet),
                                     SamLength);
                        break;

                    case 3:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->AccountExpires),
                                     SamLength);
                        break;

                    case 4:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->LastBadPasswordTime),
                                     SamLength);
                        break;

                    case 5:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->UserId),
                                     SamLength);
                        break;

                    case 6:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->PrimaryGroupId),
                                     SamLength);
                        break;

                    case 7:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->UserAccountControl),
                                     SamLength);
                        break;

                    case 8:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->CountryCode),
                                     SamLength);
                        break;

                    case 9:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->CodePage),
                                     SamLength);
                        break;

                    case 10:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->BadPasswordCount),
                                     SamLength);
                        break;

                    case 11:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->LogonCount),
                                     SamLength);
                        break;


                    default:
                        ASSERT(FALSE && "UndefinedAttribute");
                        NtStatus = STATUS_INTERNAL_ERROR;
                        break;

                    }

                    break;

                default:
                    ASSERT(FALSE && "UndefinedObjectClass");
                    NtStatus = STATUS_INTERNAL_ERROR;
                    break;

                }
            }
            else
            {
                NtStatus = STATUS_NO_MEMORY;
                break;
            }
        }
        else
        {
            NtStatus = STATUS_NO_MEMORY;
            break;
        }
    }

    return(NtStatus);
}



NTSTATUS
SampConvertFixedLengthAttributesToAttrBlock(
    IN INT ObjectType,
    IN PVOID SamAttributes,
    OUT PDSATTRBLOCK *DsAttributes
    )

/*++

Routine Description:

    This routine is the top-level routine for converting a SAM fixed-length
    attribute into a DSATTRBLOCK. Based on the SAM object type, the attribute
    count is set, and subsequently used to allocate memory for the DS attri-
    butes.

Arguments:

    ObjectType - Identifies which SAM object type, and hence, which attribute
        set to work with.

    SamAttributes - Pointer, updated SAM attribute buffer.

    DsAttributes - Pointer, outgoing DSATTRBLOCK, containing fixed-length
        attributes.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG AttributeCount = 0;
    ULONG Length = 0;
    PDSATTR Attributes = NULL;

    SAMTRACE("SampConvertFixedLengthAttributesToAttrBlock");

    ASSERT(SamAttributes);
    ASSERT(DsAttributes);

    // Allocate the top-level DS structure, DSATTRBLOCK.

    *DsAttributes = RtlAllocateHeap(RtlProcessHeap(),
                                    0,
                                    sizeof(DSATTRBLOCK));

    if (NULL == *DsAttributes)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // From the SAM object type, set the attribute count.

    RtlZeroMemory(*DsAttributes, sizeof(DSATTRBLOCK));

    switch(ObjectType)
    {

    case SampServerObjectType:

        AttributeCount = SAMP_SERVER_FIXED_ATTR_COUNT;
        break;

    case SampDomainObjectType:

        AttributeCount = SAMP_DOMAIN_FIXED_ATTR_COUNT;
        break;

    case SampGroupObjectType:

        AttributeCount = SAMP_GROUP_FIXED_ATTR_COUNT;
        break;

    case SampAliasObjectType:

        AttributeCount = SAMP_ALIAS_FIXED_ATTR_COUNT;
        break;

    case SampUserObjectType:

        AttributeCount = SAMP_USER_FIXED_ATTR_COUNT;
        break;

    default:

        break;

    }

    // Allocate a block for the DSATTR array, then convert the SAM
    // fixed-length attributes into the DSATTRBLOCK.

    Length = AttributeCount * sizeof(DSATTR);
    Attributes = RtlAllocateHeap(RtlProcessHeap(), 0, Length);

    if (NULL != Attributes)
    {
        RtlZeroMemory(Attributes, Length);

        (*DsAttributes)->attrCount = AttributeCount;
        (*DsAttributes)->pAttr = Attributes;

        NtStatus = SampConvertFixedLengthAttributes(ObjectType,
                                                    SamAttributes,
                                                    AttributeCount,
                                                    Attributes);
    }
    else
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // In the error case, allocated memory will be free by 
    // the caller
    // 

    return(NtStatus);
}



//
// ATTRBLOCK-TO-COMBINED BUFFER CONVERSION ROUTINES
//

NTSTATUS
SampWalkAttrBlock(
    IN ULONG FixedLengthAttributeCount,
    IN ULONG VarLengthAttributeCount,
    IN PDSATTRBLOCK DsAttributes,
    OUT PDSATTRBLOCK *FixedLengthAttributes,
    OUT PDSATTRBLOCK *VarLengthAttributes
    )

/*++

Routine Description:

    This routine scans the DSATTRBLOCK containing the fixed and variable-
    length attributes, identifying where each starts. Two new DSATTRBLOCK are
    allocated, one that points to the fixed-length data, while the second
    points at the variable-length data.

Arguments:

    FixedLengthAttributeCount - Number of fixed-length attributes for this
        object.

    VarLengthAttributeCount - Number of variable-length attributes for this
        object.

    DsAttributes - Pointer, incoming DSATTRBLOCK, containing all of the
        attributes.

    FixedLengthAttributes - Pointer, returned pointer to the first fixed-
        length attribute.

    VarLengthAttributes - Pointer, returned pointer to the first variable-
        length attribute.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG AttributeCount = FixedLengthAttributeCount + VarLengthAttributeCount;

    if ((0 < FixedLengthAttributeCount) &&
        (0 < VarLengthAttributeCount) &&
        (NULL != DsAttributes))
    {
        ASSERT(DsAttributes->attrCount == AttributeCount);

        if ((NULL != FixedLengthAttributes) &&
            (NULL != VarLengthAttributes))
        {
            // Allocate a new DSATTRBLOCK structure that will point to the
            // first N DSATTR elements, representing the fixed-length attri-
            // butes for this SAM object.

            *FixedLengthAttributes = RtlAllocateHeap(RtlProcessHeap(),
                                                     0,
                                                     sizeof(DSATTRBLOCK));

            if (NULL != *FixedLengthAttributes)
            {
                RtlZeroMemory(*FixedLengthAttributes, sizeof(DSATTRBLOCK));

                // Set the pointer, and attribute count to the number of fixed
                // length attributes.

                if (NULL != DsAttributes->pAttr)
                {
                    (*FixedLengthAttributes)->pAttr = DsAttributes->pAttr;

                    (*FixedLengthAttributes)->attrCount =
                        FixedLengthAttributeCount;

                    // Now, allocate a second DSATTRBLOCK that will point
                    // to the variable-length attributes.

                    *VarLengthAttributes = RtlAllocateHeap(RtlProcessHeap(),
                                                           0,
                                                           sizeof(DSATTRBLOCK));

                    if (NULL != *VarLengthAttributes)
                    {
                        RtlZeroMemory(*VarLengthAttributes,
                                      sizeof(DSATTRBLOCK));

                        // The remaining M DSATTR elements represent the var-
                        // iable length attributes. Set the pointer, and the
                        // attribute count to the number of variable attrs.

                        (*VarLengthAttributes)->pAttr =
                            DsAttributes->pAttr + FixedLengthAttributeCount;

                        (*VarLengthAttributes)->attrCount =
                            VarLengthAttributeCount;

                        NtStatus = STATUS_SUCCESS;
                    }
                    else
                    {
                        NtStatus = STATUS_NO_MEMORY;
                    }
                }
                else
                {
                    NtStatus = STATUS_INTERNAL_ERROR;
                }
            }
            else
            {
                NtStatus = STATUS_NO_MEMORY;
            }
        }
        else
        {
            NtStatus = STATUS_INVALID_PARAMETER;
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return(NtStatus);
}



NTSTATUS
SampLocateAttributesInAttrBlock(
    IN INT ObjectType,
    IN PDSATTRBLOCK DsAttributes,
    OUT PDSATTRBLOCK *FixedLengthAttributes,
    OUT PDSATTRBLOCK *VarLengthAttributes
    )

/*++

Routine Description:

    This routine determines the number of attributes based on object type,
    then calls a worker routine to obtain pointers to the fixed-length and
    variable-length portions of the DSATTRBLOCK.

Arguments:

    ObjectType - Identifies which SAM object type, and hence, which attribute
        set to work with.

    DsAttributes - Pointer, incoming DSATTRBLOCK.

    FixedLengthAttributes - Pointer, returned pointer to the fixed data.

    VarLengthAttributes - Pointer, returned pointer to the variable data.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG FixedLengthAttributeCount = 0;
    ULONG VarLengthAttributeCount = 0;
    ULONG AttributeCount = 0;

    SAMTRACE("SampLocateAttributesInAttrBlock");

    // Set the fixed-length, variable-length attribute counts based upon
    // the object type.

    switch(ObjectType)
    {

    case SampServerObjectType:

        FixedLengthAttributeCount = SAMP_SERVER_FIXED_ATTR_COUNT;
        VarLengthAttributeCount = SAMP_SERVER_VARIABLE_ATTRIBUTES;
        break;

    case SampDomainObjectType:

        FixedLengthAttributeCount = SAMP_DOMAIN_FIXED_ATTR_COUNT;
        VarLengthAttributeCount = SAMP_DOMAIN_VARIABLE_ATTRIBUTES;
        break;

    case SampGroupObjectType:

        FixedLengthAttributeCount = SAMP_GROUP_FIXED_ATTR_COUNT;
        VarLengthAttributeCount = SAMP_GROUP_VARIABLE_ATTRIBUTES;
        break;

    case SampAliasObjectType:

        FixedLengthAttributeCount = SAMP_ALIAS_FIXED_ATTR_COUNT;
        VarLengthAttributeCount = SAMP_ALIAS_VARIABLE_ATTRIBUTES;
        break;

    case SampUserObjectType:

        FixedLengthAttributeCount = SAMP_USER_FIXED_ATTR_COUNT;
        VarLengthAttributeCount = SAMP_USER_VARIABLE_ATTRIBUTES;
        break;

    default:
        break;

    }

    AttributeCount = FixedLengthAttributeCount + VarLengthAttributeCount;

    if (0 < AttributeCount)
    {
        NtStatus = SampWalkAttrBlock(FixedLengthAttributeCount,
                                     VarLengthAttributeCount,
                                     DsAttributes,
                                     FixedLengthAttributes,
                                     VarLengthAttributes);
    }

    return(NtStatus);
}



NTSTATUS
SampCombineSamAttributes(
    IN PVOID SamFixedLengthAttributes,
    IN ULONG FixedLength,
    IN PSAMP_VARIABLE_LENGTH_ATTRIBUTE SamVarLengthAttributes,
    IN ULONG VarLength,
    OUT PVOID *SamAttributes
    )

/*++

Routine Description:

    This routine combines the SAM fixed and variable-length buffers into a
    single SAM combined-attribute buffer.

Arguments:

    SamFixedLengthAttributes - Pointer, fixed attributes.

    FixedLength - Number of bytes.

    SamVarLengthAttributes - Pointer, variable attributes.

    VarLength - Number of bytes.

    SamAttributes - Pointer, returned combined-attribute buffer.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG CombinedLength = 0;

    SAMTRACE("SampCombineSamAttributes");

    if ((0 < FixedLength) && (0 < VarLength))
    {
        // Adjust the length so that the appended variable attributes start
        // on a DWORD boundary.

        FixedLength = DWORD_ALIGN(FixedLength);
        CombinedLength = FixedLength + VarLength;

        if (NULL != SamAttributes)
        {
            // Allocate a new buffer for the combined attributes.

            *SamAttributes = RtlAllocateHeap(RtlProcessHeap(),
                                             0,
                                             CombinedLength);

            if (NULL != *SamAttributes)
            {
                RtlZeroMemory(*SamAttributes, CombinedLength);

                if ((NULL != SamFixedLengthAttributes) &&
                    (NULL != SamVarLengthAttributes))
                {
                    // BUG: Check return value from RtlCopyMemory.

                    // Copy the fixed-length attributes first...

                    RtlCopyMemory(*SamAttributes,
                                 SamFixedLengthAttributes,
                                 FixedLength);

                    RtlFreeHeap(RtlProcessHeap(), 0, SamFixedLengthAttributes);

                    // then the variable ones.

                    RtlCopyMemory(((PBYTE)(*SamAttributes)) + FixedLength,
                                 SamVarLengthAttributes,
                                 VarLength);

                    RtlFreeHeap(RtlProcessHeap(), 0, SamVarLengthAttributes);

                    // BUG: Need to set Object->VariableArrayOffset, etc.

                    NtStatus = STATUS_SUCCESS;
                }
                else
                {
                    NtStatus = STATUS_INVALID_PARAMETER;
                }
            }
            else
            {
                NtStatus = STATUS_NO_MEMORY;
            }
        }
        else
        {
            NtStatus = STATUS_INVALID_PARAMETER;
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return(NtStatus);
}



//
// COMBINED BUFFER-TO-ATTRBLOCK CONVERSION ROUTINES
//

NTSTATUS
SampLocateAttributesInSamBuffer(
    IN INT ObjectType,
    IN PVOID SamAttributes,
    IN ULONG FixedLength,
    IN ULONG VariableLength,
    OUT PVOID *FixedLengthAttributes,
    OUT PSAMP_VARIABLE_LENGTH_ATTRIBUTE *VarLengthAttributes
    )

/*++

Routine Description:

    This routine finds the start of the fixed-length and variable-length
    attributes, returning a pointer to each.

Arguments:

    ObjectType - Identifies which SAM object type, and hence, which attribute
        set to work with.

    SamAttributes - Pointer, SAM attribute buffer.

    FixedLength - Number of bytes of fixed-length attributes.

    VariableLength - Number of bytes of variable-length attributes.

    FixedLengthAttributes - Pointer, returned pointer to the fixed data.

    VarLengthAttributes - Pointer, returned pointer to the variable data.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampLocateAttributesInSamBuffer");

    // BUG: ObjectType and VariableLength are not used in this routine.
    // These parameters could be used in the future for validation checks.

    if ((NULL != SamAttributes) && (NULL != FixedLengthAttributes))
    {
        // The fixed-length attributes are in the first part of the overall
        // buffer.

        *FixedLengthAttributes = SamAttributes;

        if (NULL != VarLengthAttributes)
        {
            // The variable-length attributes come after the fixed ones.

            *VarLengthAttributes =
                (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)(((PBYTE)SamAttributes) +
                FixedLength);

            NtStatus = STATUS_SUCCESS;
        }
    }

    return(NtStatus);
}



NTSTATUS
SampCreateDsAttributes(
    IN INT ObjectType,
    IN PDSATTRBLOCK DsFixedLengthAttributes,
    IN ULONG FixedLengthAttributeCount,
    IN PDSATTRBLOCK DsVarLengthAttributes,
    IN ULONG VarLengthAttributeCount,
    OUT PDSATTRBLOCK *DsAttributes
    )

/*++

Routine Description:

    This routine does the work of combining two DSATTRBLOCKs into a single
    DSATTRBLOCK by "concatenating" them together. The routine allocates a
    new top-level DSATTR array, and then fixes up the pointers to the real
    attributes, finally releasing the old DSATTR array.

Arguments:

    AttributeCount - Total number of attributes, fixed and variable.

    DsFixedLengthAttributes - Pointer, the DSATTRBLOCK containing the fixed-
        length attributes.

    DsVarLengthAttributes - Pointer, the DSATTRBLOCK containing the variable-
        length attributes.

    DsAttributes - Pointer, the outgoing DSATTRBLOCK containing both sets of
        attributes.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    PDSATTR Attributes = NULL;
    PDSATTR FixedAttributes = NULL;
    PDSATTR VarAttributes = NULL;
    ULONG AttrIndex = 0;
    ULONG AttrIndexTmp = 0;
    ULONG AttributeCount = FixedLengthAttributeCount + VarLengthAttributeCount;

    ASSERT(DsAttributes);
    ASSERT(DsFixedLengthAttributes);
    ASSERT(DsVarLengthAttributes);


    // Allocate a new top-level DSATTRBLOCK for DsAttributes.

    *DsAttributes = RtlAllocateHeap(RtlProcessHeap(),
                                    0,
                                    sizeof(DSATTRBLOCK));

    if (NULL != *DsAttributes)
    {
        RtlZeroMemory(*DsAttributes, sizeof(DSATTRBLOCK));

        // Allocate the DSATTR array for the attributes.

        Attributes = RtlAllocateHeap(RtlProcessHeap(),
                                     0,
                                     (AttributeCount * sizeof(DSATTR)));

        if (NULL != Attributes)
        {
            RtlZeroMemory(Attributes, (AttributeCount * sizeof(DSATTR)));

            // Set the return DsAttributes members.

            (*DsAttributes)->attrCount = AttributeCount;
            (*DsAttributes)->pAttr = Attributes;

            if ((NULL != DsFixedLengthAttributes) &&
                (NULL != DsVarLengthAttributes))
            {
                FixedAttributes = DsFixedLengthAttributes->pAttr;
                VarAttributes = DsVarLengthAttributes->pAttr;

                if ((NULL != FixedAttributes) &&
                    (NULL != VarAttributes))
                {
                    // Reset the attribute pointers so that DsAttributes
                    // points to the fixed-length attributes and counts.

                    for (AttrIndex = 0;
                         AttrIndex < FixedLengthAttributeCount;
                         AttrIndex++)
                    {
                        Attributes[AttrIndex].attrTyp =
                            SampFixedAttributeInfo[ObjectType][AttrIndex].Type;

                        Attributes[AttrIndex].AttrVal.valCount =
                            FixedAttributes[AttrIndex].AttrVal.valCount;

                        Attributes[AttrIndex].AttrVal.pAVal =
                            FixedAttributes[AttrIndex].AttrVal.pAVal;
                    }

                    // Save the current attribute index so that the
                    // variable-length attributes can be appended next.

                    AttrIndexTmp = AttrIndex;

                    // Now fix up the variable-length attribute pointers.

                    for (AttrIndex = 0;
                         AttrIndex < VarLengthAttributeCount;
                         AttrIndex++)
                    {
                        Attributes[AttrIndex + AttrIndexTmp].attrTyp =
                            VarAttributes[AttrIndex].attrTyp;

                        Attributes[AttrIndex + AttrIndexTmp].AttrVal.valCount =
                            VarAttributes[AttrIndex].AttrVal.valCount;

                        Attributes[AttrIndex + AttrIndexTmp].AttrVal.pAVal =
                            VarAttributes[AttrIndex].AttrVal.pAVal;
                    }

                    ASSERT( (AttrIndex+AttrIndexTmp) == AttributeCount );

                    NtStatus = STATUS_SUCCESS;
                }
            }
        }
        else
        {
            NtStatus = STATUS_NO_MEMORY;
        }
    }
    else
    {
        NtStatus = STATUS_NO_MEMORY;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        if (*DsAttributes)
        {
            if ((*DsAttributes)->pAttr)
            {
                RtlFreeHeap(RtlProcessHeap(), 0, (*DsAttributes)->pAttr);
            }
            RtlFreeHeap(RtlProcessHeap(), 0, *DsAttributes);
            *DsAttributes = NULL;
        }
    }

    return(NtStatus);
}



NTSTATUS
SampCombineDsAttributes(
    IN INT ObjectType,
    IN PDSATTRBLOCK DsFixedLengthAttributes,
    IN PDSATTRBLOCK DsVarLengthAttributes,
    OUT PDSATTRBLOCK *DsAttributes
    )

/*++

Routine Description:

    This routine does the work of combining two DSATTRBLOCKs into a single
    DSATTRBLOCK by "concatenating" them together. The routine allocates a
    new top-level DSATTR array, and then fixes up the pointers to the real
    attributes, finally releasing the old DSATTR array.

Arguments:

    ObjectType - Identifies which SAM object type, and hence, which attribute
        set to work with.

    DsFixedLengthAttributes - Pointer, the DSATTRBLOCK containing the fixed-
        length attributes.

    DsVarLengthAttributes - Pointer, the DSATTRBLOCK containing the variable-
        length attributes.

    DsAttributes - Pointer, the outgoing DSATTRBLOCK containing both sets of
        attributes.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG FixedLengthAttributeCount = 0;
    ULONG VarLengthAttributeCount = 0;
    ULONG AttributeCount = 0;

    SAMTRACE("SampCombineDsAttributes");

    // Set the combined attribute count 

    AttributeCount = DsFixedLengthAttributes->attrCount + DsVarLengthAttributes->attrCount;

    ASSERT(0 < AttributeCount);

    if (0 < AttributeCount)
    {
        NtStatus = SampCreateDsAttributes(ObjectType,
                                          DsFixedLengthAttributes,
                                          DsFixedLengthAttributes->attrCount,
                                          DsVarLengthAttributes,
                                          DsVarLengthAttributes->attrCount,
                                          DsAttributes);
    }

    return(NtStatus);
}



NTSTATUS
SampConvertCombinedAttributesToAttrBlock(
    IN PSAMP_OBJECT Context,
    IN ULONG FixedLength,
    IN ULONG VariableLength,
    OUT PDSATTRBLOCK *DsAttributes
    )

/*++

Routine Description:

    This routine converts a SAM combined-attribute buffer into a DSATTRBLOCK
    containing all of the attributes. A SAM combined buffer contains fixed-
    length attributes, followed by variable-length attributes (see attr.c for
    the layout).

    The resultant DSATTRBLOCK contains the SAM attributes in exactly the
    order in which they appeared in the input SAM buffer.

Arguments:

    ObjectType - Identifies which SAM object type, and hence, which attribute
        set to work with.

    SamAttributes - Pointer, input SAM combined attribute buffer.

    FixedLength - Number of bytes of the buffer containing the fixed-length
        attributes.

    VariableLength - Number of bytes of the buffer containing the variable-
        length attributes.

    DsAttributes - Pointer, the returned DSATTRBLOCK containing the SAM attri-
        butes.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    PVOID SamFixedLengthAttributes = NULL;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE SamVarLengthAttributes = NULL;
    PDSATTRBLOCK DsFixedLengthAttributes = NULL;
    PDSATTRBLOCK DsVarLengthAttributes = NULL;
    SAMP_OBJECT_TYPE    ObjectType = Context->ObjectType;
    PVOID               SamAttributes = Context->OnDisk;

    SAMTRACE("SampConvertCombinedAttributesToAttrBlock");

    ASSERT(SamAttributes);
    ASSERT(DsAttributes);
    ASSERT(FixedLength);
    ASSERT(VariableLength);

    if ((NULL != SamAttributes) && (0 < FixedLength) && (0 < VariableLength))
    {
        // Begin by obtaining a two pointers: a pointer to the fixed-length
        // attributes and a pointer to the variable-length attributes within
        // the SAM buffer.

        NtStatus = SampLocateAttributesInSamBuffer(ObjectType,
                                                   SamAttributes,
                                                   FixedLength,
                                                   VariableLength,
                                                   &SamFixedLengthAttributes,
                                                   &SamVarLengthAttributes);


        if (NT_SUCCESS(NtStatus) &&
            (NULL != SamFixedLengthAttributes) &&
            (NULL != SamVarLengthAttributes))
        {
            // First, convert the fixed-length attributes into a DSATTRBLOCK.

            NtStatus = SampConvertFixedLengthAttributesToAttrBlock(
                            ObjectType,
                            SamFixedLengthAttributes,
                            &DsFixedLengthAttributes);

            AssertAddressWhenSuccess(NtStatus, DsFixedLengthAttributes); 

            if (NT_SUCCESS(NtStatus) && (NULL != DsFixedLengthAttributes))
            {
                // Then convert the variable-length attributes.

                NtStatus = SampConvertVarLengthAttributesToAttrBlock(
                                Context,
                                SamVarLengthAttributes,
                                &DsVarLengthAttributes);

                AssertAddressWhenSuccess(NtStatus, DsVarLengthAttributes);

                if (NT_SUCCESS(NtStatus) && (NULL != DsVarLengthAttributes))
                {
                    if (NULL != DsAttributes)
                    {
                        // Finally, combine the two DSATTRBLOCKs into a single
                        // DSATTRBLOCK, containing all of the attributes.

                        NtStatus = SampCombineDsAttributes(
                                        ObjectType,
                                        DsFixedLengthAttributes,
                                        DsVarLengthAttributes,
                                        DsAttributes);

                        AssertAddressWhenSuccess(NtStatus, DsAttributes);
                    }
                    else
                    {
                        NtStatus = STATUS_INVALID_PARAMETER;
                    }
                }
                else
                {
                    NtStatus = STATUS_INTERNAL_ERROR;
                }
            }
            else
            {
                NtStatus = STATUS_INTERNAL_ERROR;
            }
        }
        else
        {
            NtStatus = STATUS_INTERNAL_ERROR;
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        if (NULL != DsFixedLengthAttributes)
        {
            SampFreeAttributeBlock(DsFixedLengthAttributes);
        }
        if (NULL != DsVarLengthAttributes)
        {
            SampFreeAttributeBlock(DsVarLengthAttributes);
        }
    }
    else
    {
        if (NULL != DsFixedLengthAttributes)
        {
            if (NULL != DsFixedLengthAttributes->pAttr)
            {
                RtlFreeHeap(RtlProcessHeap(), 0, DsFixedLengthAttributes->pAttr);
            }
            RtlFreeHeap(RtlProcessHeap(), 0, DsFixedLengthAttributes);
        }

        if (NULL != DsVarLengthAttributes)
        {
            if (NULL != DsVarLengthAttributes->pAttr)
            {
                RtlFreeHeap(RtlProcessHeap(), 0, DsVarLengthAttributes->pAttr);
            }
            RtlFreeHeap(RtlProcessHeap(), 0, DsVarLengthAttributes);
        }
    }

    return(NtStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dsmodify.c ===
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dsutilp.h>
#include <dslayer.h>
#include <dsmember.h>
#include <attids.h>
#include <mappings.h>
#include <ntlsa.h>
#include <nlrepl.h>
#include <msaudite.h>
#include <sdconvrt.h>
#include <ridmgr.h>
#include <malloc.h>
#include <setupapi.h>
#include <crypt.h>
#include <wxlpc.h>
#include <rc4.h>
#include <md5.h>
#include <enckey.h>
#include <rng.h>


             
NTSTATUS
SampInitUnicodeStringFromAttrVal(
    UNICODE_STRING  *pUnicodeString,
    ATTRVAL         *pAttrVal)

/*++

Routine Description:

    Initializes a RPC_UNICODE_STRING from an ATTRVAL.

Arguments:

    pUnicodeString - pointer to RPC_UNICODE_STRING to initialize.

    pAttrVal - pointer to ATTRVAL providing initialization value.

Return Value:

    None.

--*/

{
    if ( 0 == pAttrVal->valLen )
    {
        pUnicodeString->Length = 0;
        pUnicodeString->MaximumLength = 0;
        pUnicodeString->Buffer = NULL;
    }
    else if (pAttrVal->valLen > UNICODE_STRING_MAX_BYTES)
    {
        return(RPC_NT_STRING_TOO_LONG);
    }
    else if ((pAttrVal->valLen %2) !=0)
    {
        return (STATUS_INVALID_PARAMETER);
    }
    else if ((pAttrVal->valLen!=0) && (pAttrVal->pVal == NULL))
    {
        return (STATUS_INVALID_PARAMETER);
    }
    else
    {
        pUnicodeString->Length = (USHORT) pAttrVal->valLen;
        pUnicodeString->MaximumLength = (USHORT) pAttrVal->valLen;
        pUnicodeString->Buffer = (PWSTR) pAttrVal->pVal;
    }

    return (STATUS_SUCCESS);
}


NTSTATUS
SampGetUnicodeStringFromAttrVal(
    IN ULONG        iAttr,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN BOOLEAN      fRemoveAllowed,
    OUT UNICODE_STRING  * pUnicodeString
    )
/*++

Routine Description:
    
    This routine get the unicode string attribute from a cell of 
    SAM_CALL_MAPPING

Parameters:

    iAttr - indicate the i'th attribute in the array

    rCallMap - pointer to the array
    
    fRemoveAllowed - indicate whether remove attribute is allowed
   
    pUnicodeString - string to return  

Return Values:    

    none

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RtlInitUnicodeString(pUnicodeString, 
                         NULL
                         );

    if ((AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice) && 
        (1 == rCallMap[iAttr].attr.AttrVal.valCount) )
    {
        Status = SampInitUnicodeStringFromAttrVal(
                        pUnicodeString,
                        rCallMap[iAttr].attr.AttrVal.pAVal
                        );
        return(Status);
    }

    ASSERT(fRemoveAllowed && 
           (AT_CHOICE_REMOVE_ATT == rCallMap[iAttr].choice) && 
           (0 == rCallMap[iAttr].attr.AttrVal.valCount) );

    return(Status);

}


VOID
SampGetUlongFromAttrVal(
    IN ULONG        iAttr,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN BOOLEAN      fRemoveAllowed,
    OUT ULONG       *UlongValue
    )
/*++

Routine Description:
    
    This routine get the value of ULONG attribute from a cell of 
    SAM_CALL_MAPPING

Parameters:

    iAttr - indicate the i'th attribute in the array

    rCallMap - pointer to the array
    
    fRemoveAllowed - indicate whether remove attribute is allowed
   
    ULongValue - value to return  

Return Values:    

    none

--*/
{

    *UlongValue = 0;
    if ((AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice) && 
        (1 == rCallMap[iAttr].attr.AttrVal.valCount) &&
        (sizeof(ULONG) == rCallMap[iAttr].attr.AttrVal.pAVal[0].valLen)
       )
    {
        *UlongValue = 
            * (ULONG *) rCallMap[iAttr].attr.AttrVal.pAVal[0].pVal;

        return;
    }
    ASSERT(fRemoveAllowed && 
           (AT_CHOICE_REMOVE_ATT == rCallMap[iAttr].choice) && 
           (0 == rCallMap[iAttr].attr.AttrVal.valCount) );

}


NTSTATUS
SampGetUShortFromAttrVal(
    IN ULONG        iAttr,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN BOOLEAN      fRemoveAllowed,
    OUT USHORT       *UShortValue
    )
/*++

Routine Description:
    
    This routine get the value of USHORT attribute from a cell of 
    SAM_CALL_MAPPING

Parameters:

    iAttr - indicate the i'th attribute in the array

    rCallMap - pointer to the array
    
    fRemoveAllowed - indicate whether remove attribute is allowed
   
    UShortValue - value to return  

Return Values:    

    none

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    *UShortValue = 0;
    if ((AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice) && 
        (1 == rCallMap[iAttr].attr.AttrVal.valCount) &&
        (sizeof(SYNTAX_INTEGER) == rCallMap[iAttr].attr.AttrVal.pAVal[0].valLen)
       )
    {
        ULONG  SuppliedValue;
        SuppliedValue = 
            *((ULONG *) rCallMap[iAttr].attr.AttrVal.pAVal[0].pVal);

        if (SuppliedValue>MAXUSHORT)
        {
            return(STATUS_DS_OBJ_CLASS_VIOLATION);
        }

        *UShortValue = (USHORT) SuppliedValue;

        return (STATUS_SUCCESS);
    }
    ASSERT(fRemoveAllowed && 
           (AT_CHOICE_REMOVE_ATT == rCallMap[iAttr].choice) && 
           (0 == rCallMap[iAttr].attr.AttrVal.valCount));

    return(STATUS_SUCCESS);

}

VOID
SampGetBooleanFromAttrVal(
    IN ULONG        iAttr,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN BOOLEAN      fRemoveAllowed,
    OUT BOOLEAN       *BooleanValue
    )
/*++

Routine Description:
    
    This routine get the value of BOOLEAN attribute from a cell of 
    SAM_CALL_MAPPING

Parameters:

    iAttr - indicate the i'th attribute in the array

    rCallMap - pointer to the array
    
    fRemoveAllowed - indicate whether remove attribute is allowed
   
    BooleanValue - value to return  

Return Values:    

    none

--*/
{

    *BooleanValue = FALSE;
    if ((AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice) && 
        (1 == rCallMap[iAttr].attr.AttrVal.valCount) &&
        (sizeof(ULONG) == rCallMap[iAttr].attr.AttrVal.pAVal[0].valLen)
       )
    {
        *BooleanValue = 
             ((*((ULONG *) rCallMap[iAttr].attr.AttrVal.pAVal[0].pVal)) != 0);

        return;
    }
    
    ASSERT(fRemoveAllowed && 
           (AT_CHOICE_REMOVE_ATT == rCallMap[iAttr].choice) && 
           (0 == rCallMap[iAttr].attr.AttrVal.valCount) );
}



VOID
SampGetLargeIntegerFromAttrVal(
    IN ULONG        iAttr,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN BOOLEAN      fRemoveAllowed,
    OUT LARGE_INTEGER   *LargeIntegerValue
    )
/*++

Routine Description:
    
    This routine get the value of a LargeInteger attribute from a cell of 
    SAM_CALL_MAPPING

Parameters:

    iAttr - indicate the i'th attribute in the array

    rCallMap - pointer to the array
    
    fRemoveAllowed - indicate whether remove attribute is allowed
   
    LargeIntegerValue - value to return  

Return Values:    

    none

--*/
{

    LargeIntegerValue->LowPart = 0;
    LargeIntegerValue->HighPart = 0;

    if ((AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice) && 
        (1 == rCallMap[iAttr].attr.AttrVal.valCount) &&
        (sizeof(LARGE_INTEGER) == rCallMap[iAttr].attr.AttrVal.pAVal[0].valLen)
       )
    {
        *LargeIntegerValue = * (LARGE_INTEGER *) 
                    rCallMap[iAttr].attr.AttrVal.pAVal[0].pVal;
        return;
    }
    ASSERT(fRemoveAllowed && 
           (AT_CHOICE_REMOVE_ATT == rCallMap[iAttr].choice) && 
           (0 == rCallMap[iAttr].attr.AttrVal.valCount) );

}



NTSTATUS
SampGetNewUnicodePasswordFromAttrVal(
    ULONG               iAttr,
    SAMP_CALL_MAPPING   *rCallMap,
    UNICODE_STRING      *NewPassword
    )
/*++

Routine Description:

    This routine retrieve Clear Text New Password from call_mapping

Parameters:

    iAttr - index of password attribute in the array
    
    rCallMap - attributes array
    
    NewPassword - return New Password
    
Return Values:

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    UNICODE_STRING  PasswordInQuote;
    ATTR            *pAttr = &rCallMap[iAttr].attr;
    WCHAR           *pUnicodePwd;
    ULONG           cUnicodePwd, cb, i;


    //
    // At this statge replace is the only valid combination 
    //

    if ( !( (AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice) &&
            (1 == pAttr->AttrVal.valCount)) )
    {
        return( STATUS_UNSUCCESSFUL );
    }

    // 
    // Verify that this is a secure enough connection - one of the 
    // requirements for accepting passwords sent over the wire.
    //  
    if (!SampIsSecureLdapConnection())
    {
        return( STATUS_UNSUCCESSFUL );
    }


    // 
    // Verify that the password is enclosed in quotes.
    // 

    pUnicodePwd = (WCHAR *)pAttr->AttrVal.pAVal[0].pVal;
    cb = pAttr->AttrVal.pAVal[0].valLen;
    cUnicodePwd = cb / sizeof(WCHAR);
    if (     (cb < (2 * sizeof(WCHAR)))
          || (cb % sizeof(WCHAR))
          || (L'"' != pUnicodePwd[0])
          || (L'"' != pUnicodePwd[cUnicodePwd - 1])
       )
    {
        return( STATUS_UNSUCCESSFUL );
    }

    // Strip the quotes off of the password.
    pAttr->AttrVal.pAVal[0].valLen -= (2 * sizeof(WCHAR));
    for (i = 0; i < (cUnicodePwd - 2); i++) {
        pUnicodePwd[i] = pUnicodePwd[i+1];
    }
    
    NtStatus = SampInitUnicodeStringFromAttrVal(
                            NewPassword,
                            pAttr->AttrVal.pAVal);

    return( NtStatus );
}


NTSTATUS
SampGetNewUTF8PasswordFromAttrVal(
    ULONG               iAttr,
    SAMP_CALL_MAPPING   *rCallMap,
    UNICODE_STRING      *NewPassword
    )
/*++

Routine Description:

    This routine retrieve Clear Text New Password from call_mapping

Parameters:

    iAttr - index of password attribute in the array

    rCallMap - attributes array

    NewPassword - return New Password

Return Values:

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    UNICODE_STRING  PasswordInQuote;
    ATTR            *pAttr = &rCallMap[iAttr].attr;
    OEM_STRING      OemPassword;
    ULONG           WinError =0;
    ULONG           Length = 0;

    if (AT_CHOICE_REMOVE_ATT == rCallMap[iAttr].choice)
    {
        RtlInitUnicodeString(NewPassword,NULL);
        return(STATUS_SUCCESS);
    }

    //
    // At this stage replace is the only valid combination
    // All other combinations have been mapped to replace
    // or remove
    //

    if ( AT_CHOICE_REPLACE_ATT != rCallMap[iAttr].choice )
    {
        return( STATUS_UNSUCCESSFUL );
    }

    //
    // Verify that this is a secure enough connection - one of the
    // requirements for accepting passwords sent over the wire.
    //
    if (!SampIsSecureLdapConnection())
    {
        return( STATUS_UNSUCCESSFUL );
    }


    //
    // retrieve passed in password 
    // 

    if (0 == pAttr->AttrVal.valCount)
    {
        OemPassword.Length = OemPassword.MaximumLength = 0;
        OemPassword.Buffer = NULL;
    }
    else
    {
        OemPassword.Length = OemPassword.MaximumLength = 
                (USHORT) pAttr->AttrVal.pAVal[0].valLen;
        OemPassword.Buffer = pAttr->AttrVal.pAVal[0].pVal;
    }

    //
    // The empty password is a special case
    //

    if (0==OemPassword.Length)
    {
        NewPassword->Length = NewPassword->MaximumLength = 0;
        NewPassword->Buffer = NULL;

        return(STATUS_SUCCESS);
    }

    Length =  MultiByteToWideChar(
                   CP_UTF8,
                   0,
                   OemPassword.Buffer,
                   OemPassword.Length,
                   NULL,
                   0
                   );


    if ((0==Length) || (Length > PWLEN))
    {
        //
        // Indicates that the function failed in some way
        // or that the password is too long
        //

        NtStatus = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    else
    {

        NewPassword->Length = (USHORT) Length * sizeof(WCHAR);
        NewPassword->Buffer = MIDL_user_allocate(NewPassword->Length);
        if (NULL==NewPassword->Buffer)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        NewPassword->MaximumLength = NewPassword->Length;

        if (!MultiByteToWideChar(
                    CP_UTF8,
                    0,
                    OemPassword.Buffer,
                    OemPassword.Length,
                    NewPassword->Buffer,
                    Length
                    ))
        {
            //
            // Some error occured in the conversion. Return
            // invalid parameter for now.
            //

            NtStatus = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

Cleanup:

    return( NtStatus );
}

NTSTATUS
SampWriteDomainNtMixedDomain(
    SAMPR_HANDLE        hObj,
    ULONG               iAttr,
    DSNAME              *pObject,
    SAMP_CALL_MAPPING   *rCallMap
    )
/*++

Routine Description:

    This routine resets the Mixed Domain Flag to FALSE, coverting 
    this domain from mixed mode to native mode. 
    
    Note: This operation is not reversable !!!
    
Arguments:
-
    hObj - SAM handle of the domain object 

    iAttr - indicate the i'th attribute in the array

    pObject - pointer to the object DSNAME

    rCallMap - pointer to the attributes array
    

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                        NtStatus = STATUS_SUCCESS;
    SAMPR_DOMAIN_INFO_BUFFER        *pInfo=NULL;
    ATTR                            *pAttr = &rCallMap[iAttr].attr;
    NT_PRODUCT_TYPE                 NtProductType;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN pFixedAttrs = NULL;
    PSAMP_DEFINED_DOMAINS           pDomain = NULL;
    BOOLEAN                         NewNtMixedDomainValue = TRUE; 

    //
    // double check the attr, we should check it already in loopback.c
    // 
    ASSERT( ( (AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice) &&
            (1 == pAttr->AttrVal.valCount) &&
            (sizeof(BOOL) == (pAttr->AttrVal.pAVal[0].valLen)) ) 
          );

    //
    // get the new value
    // 
    SampGetBooleanFromAttrVal(
                    iAttr,
                    rCallMap,
                    FALSE,  // remove is not allowed
                    &NewNtMixedDomainValue
                    );

    
    RtlGetNtProductType(&NtProductType);



    // Make sure this only occurs on an NT4 PDC (and not a BDC), and that the
    // change is going from mixed domain to non-mixed domain only.

    if ((NtProductLanManNt == NtProductType) &&
        (SamIMixedDomain(hObj)))
    {
        MODIFYARG ModArg;
        MODIFYRES *pModRes = NULL;
        COMMARG *pCommArg = NULL;
        ATTR Attr;
        ATTRVALBLOCK AttrValBlock;
        ATTRVAL AttrVal;
        ULONG err = 0;
        ULONG NtMixedMode = 0;


        if (NewNtMixedDomainValue)
        {
            //
            // we are still in Mixed Domain state, and the caller wants
            // to stay with that, smile and turn around
            // 
            return( STATUS_SUCCESS );
        }


        // reset ATT_NT_MIXED_DOMAIN to zero, 
        // indicating that the system is going from mixed NT4-NT5
        // DC's to only NT5 DC's. Note, ATT_NT_MIXED_DOMAIN once set to 0
        // should never be reset to 1.


        RtlZeroMemory(&ModArg, sizeof(ModArg));

        ModArg.pObject = pObject;
        ModArg.FirstMod.pNextMod = NULL;
        ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;

        // By default, when the system is installed, the value of the attr-
        // ibute ATT_NT_MIXED_DOMAIN is one. This remains at one until the DC
        // is upgraded to NT5 and the Administrator resets the value to zero.
        // From then on, the value of ATT_NT_MIXED_DOMAIN must remain zero,
        // otherwise numerous operations on the DC will fail, such as account
        // creation. Note also, that it can only be set once. Subsequent
        // attempts to reset the value will error out.

        AttrVal.valLen = sizeof(ULONG);
        AttrVal.pVal = (PUCHAR)(&NtMixedMode);

        AttrValBlock.valCount = 1;
        AttrValBlock.pAVal = &AttrVal;

        Attr.attrTyp = ATT_NT_MIXED_DOMAIN;
        Attr.AttrVal = AttrValBlock;

        ModArg.FirstMod.AttrInf = Attr;
        ModArg.count = 1;

        pCommArg = &(ModArg.CommArg);
        InitCommarg(pCommArg);

        err = DirModifyEntry(&ModArg, &pModRes);

        //
        // Map the return code to an NT status
        //

        if (err)
        {
            KdPrint(("SAMSS: DirModifyEntry status = %d in SampWriteDomainNtMixedDomain\n", err));

            if (NULL==pModRes)
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                NtStatus = SampMapDsErrorToNTStatus(err,&pModRes->CommRes);
            }
        }

        // Given that the flag was reset, call the SAM routine that will
        // create the RID Manager object and initialize the RID pools on
        // the RID object (currently the NTDS-DSA object) with default
        // values.

        if (0 == err)
        {

            // Set the in-memory mixed-domain flag in SAM so that operations
            // still referencing this flag work as they should.

            NtStatus = SamISetMixedDomainFlag( hObj );

            // 
            // No error so far, event log the change.
            //

            SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,    // Event type
                              0,                            // Category
                              SAMMSG_CHANGE_TO_NATIVE_MODE, // MessageId
                              NULL,                         // User Sid
                              0,                            // Num of strings
                              0,                            // Data Size
                              NULL,                         // String
                              NULL                          // Data
                              );
        }
    }
    else
    {
        KdPrint(("SAMSS: Attempt to set NT-Mixed-Domain flag failed\n"));
        NtStatus = STATUS_UNSUCCESSFUL;
    }

    return(NtStatus);
}





NTSTATUS
SampValidatePrimaryGroupId(
    IN PSAMP_OBJECT AccountContext,
    IN SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed,
    IN ULONG PrimaryGroupId
    )
/*++
Routine Description:

    This routine validates the new primary group ID

Parameters: 
    
    AccountContext - object context
    
    V1aFixed - Fixed attributes
    
    PrimaryGroupId - New primary group ID to be set    

Return Value:

    NTSTATUS code
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    //
    // ISSUE: the check should actually enforce that we cannot set
    // the primary group to anything other than domain controllers
    // if the group were not set correctly initially -- which does 
    // not happen today, it could be set to something different
    //

    if ((V1aFixed.UserAccountControl & USER_SERVER_TRUST_ACCOUNT) &&
        (V1aFixed.PrimaryGroupId == DOMAIN_GROUP_RID_CONTROLLERS)
       ) 
    {
        // 
        // Domain Controller's Primary Group should ALWAYS be
        // DOMAIN_GROUP_RID_CONTROLLERS
        //

        if (DOMAIN_GROUP_RID_CONTROLLERS == PrimaryGroupId)
        {
            // no change
            NtStatus = STATUS_SUCCESS;
        }
        else
        {
            NtStatus = STATUS_DS_CANT_MOD_PRIMARYGROUPID;
        }
    }
    else
    {
        //
        // Make sure the primary group is legitimate
        // (it must be one the user is a member of)
        //

        NtStatus = SampAssignPrimaryGroup(
                            AccountContext,
                            PrimaryGroupId
                            );
    }

    return( NtStatus );
}


NTSTATUS
SampValidateUserAccountExpires(
    IN PSAMP_OBJECT AccountContext,
    IN LARGE_INTEGER    AccountExpires
    )
/*++

Routine Description:

    This routine checks whether the caller can set Account Expires
    on this account
    
Parameters:

    AccountContext - object context
    
    AccountExpires - new value of Account Expires attribute
    
Return Value:

    STATUS_SPECIAL_ACCOUNT
    
    STATUS_SUCCESS

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;


    //
    // ISSUE: This code can be made simpler --- all it does is to
    // validate that the admin account can never expire
    //

    if ( (!(AccountContext->TrustedClient)) && 
         (DOMAIN_USER_RID_ADMIN == AccountContext->TypeBody.User.Rid)
       )
    {
        LARGE_INTEGER   AccountNeverExpires;

        AccountNeverExpires = RtlConvertUlongToLargeInteger(
                                    SAMP_ACCOUNT_NEVER_EXPIRES
                                    );

        if (!(AccountExpires.QuadPart == AccountNeverExpires.QuadPart))
        {
            NtStatus = STATUS_SPECIAL_ACCOUNT;
        }
    }

    return( NtStatus );
}



NTSTATUS
SampValidateUserPwdLastSet(
    IN PSAMP_OBJECT AccountContext,
    IN LARGE_INTEGER TimeSupplied,
    OUT BOOLEAN     *PasswordExpired
    )
/*++

Routine Description:

    This routine determines the password should be expired or re-enabled. 
    
Parameters: 

    AccountContext - object context 
    
    TimeSupplied - Time provided by caller

                   Valid Values:
                   
                   0 - expire
                   
                   Max - re-enable password
                   
    PasswordExpired - Indicate whether the caller requests the password
                   to expire or not. 
    
Return Values  

    STATUS_SUCCESS
    STATUS_INVALID_PARAMETER

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    LARGE_INTEGER   ZeroTime, MaxTime;

    //
    // validate Parameters.
    // If Client passes in a 0 time, expire password.
    // Max Time re-enables Password
    //

    MaxTime.LowPart  = 0xFFFFFFFF;
    MaxTime.HighPart = 0xFFFFFFFF;

    if (TimeSupplied.QuadPart == 0i64)
    {
        *PasswordExpired = TRUE;
    }
    else if (TimeSupplied.QuadPart == MaxTime.QuadPart)
    {
        *PasswordExpired = FALSE;
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return( NtStatus );
}

NTSTATUS
SampWriteLockoutTime(
    IN PSAMP_OBJECT UserContext,
    IN PSAMP_V1_0A_FIXED_LENGTH_USER    V1aFixed,
    IN LARGE_INTEGER LockoutTime
    )
/*++

Routine Description:

    Called during loopback, this routine validates and then writes the lockout
    to the ds.

Parameters:

    UserHandle - a valid user context

    LockoutTime - the user specified lockout time

Return Values:

    STATUS_SUCCESS; STATUS_INVALID_PARAMETER
    other ds resource errors

--*/
{
    NTSTATUS         NtStatus  = STATUS_SUCCESS;


    //
    // Users can only write a zero value to lockout time, so
    // bail right away if this is the case
    //
    if ( !( LockoutTime.QuadPart == 0i64 ) )
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Ok, set the lockout time
    //
    RtlZeroMemory( &UserContext->TypeBody.User.LockoutTime,
                   sizeof( LARGE_INTEGER ) );

    NtStatus = SampDsUpdateLockoutTime( UserContext );

    //
    // Set the Bad Password count to zero
    //
    if ( NT_SUCCESS( NtStatus ) )
    {
        V1aFixed->BadPasswordCount = 0;

        NtStatus = SampReplaceUserV1aFixed( UserContext,
                                            V1aFixed );
    }

    if ( NT_SUCCESS( NtStatus ) &&
         SampDoAccountAuditing(UserContext->DomainIndex)
         )
    {
        NTSTATUS        TmpNtStatus = STATUS_SUCCESS;
        UNICODE_STRING  UserAccountName;
        PSAMP_DEFINED_DOMAINS   Domain = NULL;

        TmpNtStatus = SampGetUnicodeStringAttribute(
                            UserContext,
                            SAMP_USER_ACCOUNT_NAME,
                            FALSE,      // Don't make copy
                            &UserAccountName
                            );

        if (NT_SUCCESS(TmpNtStatus))
        {

            Domain = &SampDefinedDomains[ UserContext->DomainIndex ]; 
            //
            // audit this event
            //
        
            SampAuditAnyEvent(
                UserContext,
                STATUS_SUCCESS,                         
                SE_AUDITID_ACCOUNT_UNLOCKED,        // Audit ID
                Domain->Sid,                        // Domain SID
                NULL,                               // Additional Info
                NULL,                               // Member Rid (unused)
                NULL,                               // Member Sid (unused)
                &UserAccountName,                   // Account Name
                &Domain->ExternalName,              // Domain Name
                &UserContext->TypeBody.User.Rid,    // Account Rid
                NULL,                               // Privileges used
                NULL                                // New State Data
                );
        }
    }


    return NtStatus;

}




NTSTATUS
SampWriteGroupMembers(
    IN SAMPR_HANDLE GroupHandle,
    IN DSNAME       *pObject,
    IN ULONG        iAttr,
    IN SAMP_CALL_MAPPING    *rCallMap
    )
/*++

Routine Description:

    This routine modifies the member attribute of group object
    
Parameters: 

    GroupHandle - SAM Handle of the group object
    
    pObject - object DSNAME

    iAttr - index of member attribute in the array
    
    rCallMap - attributes array

Returne Value:

    NTSTATUS code
    
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ATTR        *pAttr = &rCallMap[iAttr].attr;
    ULONG       i;
    ATTRBLOCK   AttrsRead;
    BOOLEAN     fValueExists = TRUE;

    // For expediency, we only allow adding / removing of values
    // and replacing of the whole attribute.

    if ( (AT_CHOICE_ADD_VALUES != rCallMap[iAttr].choice) &&
         (AT_CHOICE_REMOVE_VALUES != rCallMap[iAttr].choice) &&
         (AT_CHOICE_REPLACE_ATT != rCallMap[iAttr].choice) &&
         (AT_CHOICE_REMOVE_ATT != rCallMap[iAttr].choice) )
    {
        return( STATUS_INVALID_PARAMETER );
    }

    if ((AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice) || 
        (AT_CHOICE_REMOVE_ATT == rCallMap[iAttr].choice) )
    {
        READARG     ReadArg;
        READRES     * pReadRes = NULL;
        COMMARG     * pCommArg = NULL;
        ATTR        MemberAttr;
        ENTINFSEL   EntInf;
        ULONG       err;

        //
        // Commit any existing buffered writes, as the replace
        // need not be the first membership operation on the group
        //

        NtStatus = SampCommitBufferedWrites(GroupHandle);
        if(!NT_SUCCESS(NtStatus))
        {
            return(NtStatus);
        }

        //
        // Get all values in the member attribute by doing a DirRead
        // 

        memset(&EntInf, 0, sizeof(ENTINFSEL));
        memset(&ReadArg, 0, sizeof(READARG));

        MemberAttr.AttrVal.valCount = 0;
        MemberAttr.AttrVal.pAVal = NULL;
        MemberAttr.attrTyp = SampDsAttrFromSamAttr(
                                    SampGroupObjectType,
                                    SAMP_GROUP_MEMBERS
                                    );

        EntInf.AttrTypBlock.attrCount = 1;
        EntInf.AttrTypBlock.pAttr = &MemberAttr;
        EntInf.attSel = EN_ATTSET_LIST;
        EntInf.infoTypes = EN_INFOTYPES_SHORTNAMES;

        ReadArg.pObject = pObject;
        ReadArg.pSel = &EntInf;
        pCommArg = &(ReadArg.CommArg);
        BuildStdCommArg(pCommArg);

        err = DirRead(&ReadArg, &pReadRes);

        if (err)
        {
            if (NULL == pReadRes)
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                NtStatus = SampMapDsErrorToNTStatus(err, &pReadRes->CommRes);
            }

            //
            // if member attribute doesn't exist, that's ok
            // 
            if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE == NtStatus)
            {
                fValueExists = FALSE;
                SampClearErrors();
                NtStatus = STATUS_SUCCESS; 
            }
            else
            {
                return( NtStatus );
            }
        }

        //
        // remove all existing values if they exist
        // 
        if (fValueExists)
        {
            AttrsRead = pReadRes->entry.AttrBlock;

            if (AttrsRead.attrCount && AttrsRead.pAttr)
            {
                // only one attribute (members) should be returned
                ASSERT(1 == AttrsRead.attrCount);

                for (i = 0; i < AttrsRead.pAttr->AttrVal.valCount; i++)
                {
                    if (0 != AttrsRead.pAttr->AttrVal.pAVal[i].valLen)
                    {
                        NtStatus = SamIRemoveDSNameFromGroup(
                                       GroupHandle,
                                       (DSNAME *)AttrsRead.pAttr->AttrVal.pAVal[i].pVal
                                            );

                        if (!NT_SUCCESS(NtStatus))
                        {
                            return( NtStatus );
                        }
                    }
                }
            }
        }

        // We should have removed all the old values already, 
        // Now, start adding new values. 

        if (AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice)
        {
            for (i = 0; i < pAttr->AttrVal.valCount; i++)
            {
                if (0 != pAttr->AttrVal.pAVal[i].valLen)
                {
                    NtStatus = SamIAddDSNameToGroup(
                                    GroupHandle, 
                                    (DSNAME *)pAttr->AttrVal.pAVal[i].pVal );

                    if (!NT_SUCCESS(NtStatus))
                    {
                        return (NtStatus);
                    }
                }
            }
        }
    }
    else
    {
        // 
        // add value or remove value, process them one by one
        // 
        for ( i = 0; i < pAttr->AttrVal.valCount; i++ )
        {
            if ( 0 != pAttr->AttrVal.pAVal[i].valLen )
            {
                if ( AT_CHOICE_ADD_VALUES == rCallMap[iAttr].choice )
                {
                    NtStatus = SamIAddDSNameToGroup(
                                    GroupHandle,
                                    (DSNAME *) pAttr->AttrVal.pAVal[i].pVal);
                }
                else
                {
                    NtStatus = SamIRemoveDSNameFromGroup(
                                    GroupHandle,
                                    (DSNAME *) pAttr->AttrVal.pAVal[i].pVal);
                }

                if ( !NT_SUCCESS(NtStatus) )
                {
                    return(NtStatus);
                }
            }       
        }
    }

    return( NtStatus );

}

NTSTATUS
SampWriteAliasLinkedAttribute(
    IN SAMPR_HANDLE AliasHandle,
    IN ULONG        Attribute,
    IN DSNAME       *pObject,
    IN ULONG        iAttr,
    IN SAMP_CALL_MAPPING    *rCallMap
    )
/*++
Routine Description:

    This routine modifies the member or non member attribute of an alias 
    object.
    
Parameters: 

    AliasHandle - SAM Handle of the Alias object
    
    Attribute  - the attribute to modify
    
    pObject - object DSNAME

    iAttr - index of member attribute in the array
    
    rCallMap - attributes array

Returne Value:

    NTSTATUS code
    
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ATTR        *pAttr = &rCallMap[iAttr].attr;
    ULONG       i;
    ATTRBLOCK   AttrsRead;
    BOOLEAN     fValueExists = TRUE;

    // For expediency, we only allow adding / removing of values
    // and replacing of the whole attribute.

    if ( (AT_CHOICE_ADD_VALUES != rCallMap[iAttr].choice) &&
         (AT_CHOICE_REMOVE_VALUES != rCallMap[iAttr].choice) &&
         (AT_CHOICE_REPLACE_ATT != rCallMap[iAttr].choice) &&
         (AT_CHOICE_REMOVE_ATT != rCallMap[iAttr].choice) )
    {
        return( STATUS_INVALID_PARAMETER );
    }

    if ((AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice) || 
        (AT_CHOICE_REMOVE_ATT == rCallMap[iAttr].choice) )
    {
        READARG     ReadArg;
        READRES     * pReadRes = NULL;
        COMMARG     * pCommArg = NULL;
        ATTR        MemberAttr;
        ENTINFSEL   EntInf;
        ULONG       err;


        //
        // Commit any existing buffered writes as the replace
        // need not be first membership operation on the group
        //

        NtStatus = SampCommitBufferedWrites(AliasHandle);
        if(!NT_SUCCESS(NtStatus))
        {
            return(NtStatus);
        }

        //
        // Get all values in the member attribute by doing a DirRead
        // 

        memset(&EntInf, 0, sizeof(ENTINFSEL));
        memset(&ReadArg, 0, sizeof(READARG));

        MemberAttr.AttrVal.valCount = 0;
        MemberAttr.AttrVal.pAVal = NULL;
        MemberAttr.attrTyp = SampDsAttrFromSamAttr(
                                    SampAliasObjectType,
                                    Attribute
                                    );

        EntInf.AttrTypBlock.attrCount = 1;
        EntInf.AttrTypBlock.pAttr = &MemberAttr;
        EntInf.attSel = EN_ATTSET_LIST;
        EntInf.infoTypes = EN_INFOTYPES_SHORTNAMES;

        ReadArg.pObject = pObject;
        ReadArg.pSel = &EntInf;
        pCommArg = &(ReadArg.CommArg);
        BuildStdCommArg(pCommArg);

        err = DirRead(&ReadArg, &pReadRes);

        if (err)
        {
            if (NULL == pReadRes)
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                NtStatus = SampMapDsErrorToNTStatus(err, &pReadRes->CommRes);
            }

            //
            // if member attribute doesn't exist, that's ok
            // 
            if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE == NtStatus)
            {
                fValueExists = FALSE;
                SampClearErrors();
                NtStatus = STATUS_SUCCESS; 
            }
            else
            {
                return( NtStatus );
            }
        }


        //
        // remove all existing values if they exist 
        // 
        if (fValueExists)
        {
            AttrsRead = pReadRes->entry.AttrBlock;

            if (AttrsRead.attrCount && AttrsRead.pAttr)
            {
                // only one attribute (members) should be returned
                ASSERT(1 == AttrsRead.attrCount);

                for (i = 0; i < AttrsRead.pAttr->AttrVal.valCount; i++)
                {
                    if (0 != AttrsRead.pAttr->AttrVal.pAVal[i].valLen)
                    {
                        NtStatus = SamIRemoveDSNameFromAlias(
                                       AliasHandle,
                                       Attribute,
                                       (DSNAME *)AttrsRead.pAttr->AttrVal.pAVal[i].pVal
                                        );

                        if (!NT_SUCCESS(NtStatus))
                        {
                            return( NtStatus );
                        }
                    }
                }
            }
        }

        // We should have removed all the old values already, 
        // Now, start adding new values. 

        if (AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice)
        {
            for (i = 0; i < pAttr->AttrVal.valCount; i++)
            {
                if (0 != pAttr->AttrVal.pAVal[i].valLen)
                {
                    NtStatus = SamIAddDSNameToAlias(
                                    AliasHandle, 
                                    Attribute,
                                    (DSNAME *)pAttr->AttrVal.pAVal[i].pVal );

                    if (!NT_SUCCESS(NtStatus))
                    {
                        return (NtStatus);
                    }
                }
            }
        }
    }
    else
    {
        // 
        // add value or remove value, process them one by one
        // 
        for ( i = 0; i < pAttr->AttrVal.valCount; i++ )
        {
            if ( 0 != pAttr->AttrVal.pAVal[i].valLen )
            {
                if ( AT_CHOICE_ADD_VALUES == rCallMap[iAttr].choice )
                {
                    NtStatus = SamIAddDSNameToAlias(
                                    AliasHandle,
                                    Attribute,
                                    (DSNAME *) pAttr->AttrVal.pAVal[i].pVal);

                }
                else
                {
                    NtStatus = SamIRemoveDSNameFromAlias(
                                    AliasHandle,
                                    Attribute,
                                    (DSNAME *) pAttr->AttrVal.pAVal[i].pVal);
                }

                if ( !NT_SUCCESS(NtStatus) )
                {
                    return(NtStatus);
                }
            }       
        }
    }

    return( NtStatus );

}

NTSTATUS
SampWriteAliasMembers(
    IN SAMPR_HANDLE AliasHandle,
    IN DSNAME       *pObject,
    IN ULONG        iAttr,
    IN SAMP_CALL_MAPPING    *rCallMap
    )
{
    return SampWriteAliasLinkedAttribute(AliasHandle,
                                         SAMP_ALIAS_MEMBERS,
                                         pObject,
                                         iAttr,
                                         rCallMap);
}


NTSTATUS
SampWriteAliasNonMembers(
    IN SAMPR_HANDLE AliasHandle,
    IN DSNAME       *pObject,
    IN ULONG        iAttr,
    IN SAMP_CALL_MAPPING    *rCallMap
    )
{
    return SampWriteAliasLinkedAttribute(AliasHandle,
                                         SAMP_ALIAS_NON_MEMBERS,
                                         pObject,
                                         iAttr,
                                         rCallMap);
}


NTSTATUS
SampWriteSidHistory(
    SAMPR_HANDLE        hObj,
    ULONG               iAttr,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )

/*++

Routine Description:

    Generic routine to write the sid history attribute

Arguments:

    hObj - SAMPR_HANDLE of open SAM object.

    iAttr - Index into SAMP_CALL_MAPPING holding new security descriptor.

    pObject - pointer to DSNAME of object being modified.

    cCallMap - number of elements in SAMP_CALL_MAPPING.

    rCallMap - address of SAMP_CALL_MAPPING array representing all
        attributes being modified by the high level Dir* call.

Return Value:

    NTSTATUS code

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_OBJECT    AccountContext = (PSAMP_OBJECT) hObj;
    MODIFYARG ModifyArg;
    MODIFYRES *pModifyRes;
    ULONG RetCode=0;
    
    //
    // Non trusted client can ONLY remove values. 
    //
    // TrustedClient is turned on if pTHS->fCrossDomainMove is set
    //
    
    if (!AccountContext->TrustedClient && 
        (AT_CHOICE_REMOVE_VALUES != rCallMap[iAttr].choice) )
    {
        return( STATUS_ACCESS_DENIED );
    }
    
    //
    // If cross domain move is set or if its a remove
    // value operation then proceed on modifying the object.
    //

    memset( &ModifyArg, 0, sizeof( ModifyArg ) );
    ModifyArg.FirstMod.AttrInf = rCallMap[iAttr].attr;
    InitCommarg(&(ModifyArg.CommArg));
    ModifyArg.FirstMod.choice = rCallMap[iAttr].choice;
    ModifyArg.pObject = pObject;
    ModifyArg.count = (USHORT) 1;

    RetCode = DirModifyEntry(&ModifyArg,&pModifyRes);

    if (RetCode)
    {
        if (NULL==pModifyRes)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            NtStatus = SampMapDsErrorToNTStatus(RetCode,&pModifyRes->CommRes);
        }
    } 
    
    if (NT_SUCCESS(NtStatus) && 
        SampDoAccountAuditing(((SAMP_OBJECT)hObj)->DomainIndex)) 
    {
        NtStatus = SampAuditSidHistory((PSAMP_OBJECT)hObj, pObject);     
    }
    
    return NtStatus;

}

NTSTATUS
SampValidateSiteAffinity(
    ATTRVAL      *SiteAffinityAttrVal
    )
/*++

Routine Description:

    This routine determines if SiteAffinityAttrVal points to a value that is a
    valid site affinity.
    
    The checks performed are:
    
    1) the site guid (the first 16 bytes) refer to an object that is site object
    (ie the object class contains the CLASS_SITE class
    2) the time stamp (the next 8 bytes) is zero

Arguments:

    SiteAffinityAttrVal -- a proposed site affinity value

Return Value:

    STATUS_SUCCESS,
    STATUS_INVALID_PARAMETER, if a bogus SA
    a resource error otherwise                 

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_SITE_AFFINITY SiteAffinity;
    SAMP_SITE_AFFINITY NullAffinity = {0};
    ULONG DirError;
    READARG ReadArg;
    READRES *ReadResult = NULL;
    ENTINFSEL EntInfSel; 
    ATTR      Attr;
    DSNAME  *SiteCandidate;
    BOOLEAN fSiteObject;

  
    if (SiteAffinityAttrVal->valLen < sizeof(SAMP_SITE_AFFINITY))
    {
        //
        // Wrong size; note that this accepts site affinities
        // that are of larger size in the future.
        //
        return STATUS_INVALID_PARAMETER;
    }
    SiteAffinity = (PSAMP_SITE_AFFINITY) SiteAffinityAttrVal->pVal;

    if (memcmp(&SiteAffinity->TimeStamp, 
               &NullAffinity.TimeStamp,
               sizeof(NullAffinity.TimeStamp)))
    {

        //
        // Time value is not zero
        //
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Try to find a site object that matches the GUID
    //
    SAMP_ALLOCA(SiteCandidate, DSNameSizeFromLen(0));
    if (NULL == SiteCandidate) {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(SiteCandidate, DSNameSizeFromLen(0));
    SiteCandidate->structLen = DSNameSizeFromLen(0);
    RtlCopyMemory(&SiteCandidate->Guid, &SiteAffinity->SiteGuid, sizeof(GUID));

    RtlZeroMemory(&Attr, sizeof(Attr));
    Attr.attrTyp = ATT_OBJECT_CLASS;

    RtlZeroMemory(&EntInfSel, sizeof(EntInfSel));
    EntInfSel.AttrTypBlock.attrCount = 1;
    EntInfSel.AttrTypBlock.pAttr = &Attr;
    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

    RtlZeroMemory(&ReadArg, sizeof(READARG));
    ReadArg.pObject = SiteCandidate;
    ReadArg.pSel = &EntInfSel;
    InitCommarg(&ReadArg.CommArg);

    //
    // Issue the read
    //

    DirError = DirRead(&ReadArg, &ReadResult);

   

    if (NULL == ReadResult)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(DirError, &ReadResult->CommRes);
    }
   
    THClearErrors();

    if (STATUS_OBJECT_NAME_NOT_FOUND == NtStatus)
    {
        //
        // Couldn't find the object?
        //
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        //
        // Fatal resource error
        //
        goto Cleanup;
    }

    //
    // Look for the object class of CLASS_SITE; note that object class is
    // a multivalued attribute and this logic has to work for classes 
    // derived from CLASS_SITE as well.
    //
    fSiteObject = FALSE;
    if ((ReadResult->entry.AttrBlock.attrCount == 1)
     && (ReadResult->entry.AttrBlock.pAttr[0].attrTyp == ATT_OBJECT_CLASS))
    {
        ULONG i;

        for (i = 0; 
                i < ReadResult->entry.AttrBlock.pAttr[0].AttrVal.valCount;
                    i++) {

            ULONG Class;
            ATTRVAL *pAV;

            pAV = &ReadResult->entry.AttrBlock.pAttr[0].AttrVal.pAVal[i];
            if (pAV->valLen == sizeof(ULONG)) {
                Class = *((ULONG*)pAV->pVal);
                if (Class == CLASS_SITE) {
                    fSiteObject = TRUE;
                    break;
                }
            }
        }
    }

    if (!fSiteObject)
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


Cleanup:

    if (ReadResult)
    {
        THFree(ReadResult);
    }

    return NtStatus;

}

NTSTATUS
SampWriteNoGCLogonAttrs(
    SAMPR_HANDLE        hObj,
    ULONG               AttrName,
    ULONG               iAttr,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )

/*++

Routine Description:

    Generic routine to write the no gc logon attributes

Arguments:

    hObj - SAMPR_HANDLE of open SAM object.
    
    AttrName - the SAM attribute

    iAttr - Index into SAMP_CALL_MAPPING holding new security descriptor.

    pObject - pointer to DSNAME of object being modified.

    cCallMap - number of elements in SAMP_CALL_MAPPING.

    rCallMap - address of SAMP_CALL_MAPPING array representing all
        attributes being modified by the high level Dir* call.

Return Value:

    NTSTATUS code

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_OBJECT    AccountContext = (PSAMP_OBJECT) hObj;
    MODIFYARG ModifyArg;
    MODIFYRES *pModifyRes;
    ULONG RetCode=0;
    ULONG i;

    if ( (AttrName == SAMP_FIXED_USER_SITE_AFFINITY) 
        && ( (rCallMap[iAttr].choice == AT_CHOICE_ADD_ATT)
          || (rCallMap[iAttr].choice == AT_CHOICE_ADD_VALUES)))
    {
        //
        // The caller is writing the site affinity; we need to do 
        // validation checks
        // 
        for (i = 0; i < rCallMap[iAttr].attr.AttrVal.valCount; i++)
        {
            NtStatus = SampValidateSiteAffinity(&rCallMap[iAttr].attr.AttrVal.pAVal[i]);
            if (!NT_SUCCESS(NtStatus))
            {
                goto Cleanup;
            }
        }

    }
    else
    {
        //
        // Clients can only remove values; this should have been
        // checked in the loopback layer
        //
        if ( (AT_CHOICE_REMOVE_VALUES != rCallMap[iAttr].choice)
          && (AT_CHOICE_REMOVE_ATT    != rCallMap[iAttr].choice) )
        {
            ASSERT( FALSE && "Invalid call to SampWriteNoGcLogonAttrs -- review code" );
            NtStatus = STATUS_ACCESS_DENIED;
            goto Cleanup;
        }
    }
    
    
    memset( &ModifyArg, 0, sizeof( ModifyArg ) );
    ModifyArg.FirstMod.AttrInf = rCallMap[iAttr].attr;
    InitCommarg(&(ModifyArg.CommArg));
    ModifyArg.FirstMod.choice = rCallMap[iAttr].choice;
    ModifyArg.pObject = pObject;
    ModifyArg.count = (USHORT) 1;

    RetCode = DirModifyEntry(&ModifyArg,&pModifyRes);

    if (RetCode)
    {
        if (NULL==pModifyRes)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            NtStatus = SampMapDsErrorToNTStatus(RetCode,&pModifyRes->CommRes);
        }
    }

Cleanup:

    return(NtStatus);

}



NTSTATUS
SampMaintainPrimaryGroupIdChange(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG        NewPrimaryGroupId,
    IN ULONG        OldPrimaryGroupId,
    IN BOOLEAN      KeepOldPrimaryGroupMembership
    )
/*++
    //
    // If the primary group Id has been changed then explicitly modify the
    // user's membership to include the old primary group as a member. This
    // is because in the DS case the membership in the primary group is not
    // stored explicitly, but is rather implicit in the primary group-id property.
    //
    // We will do two things:
    // 1. Always remove user from the New Primary Group. Thus eliminate duplicate
    //    membership in all scenarios.
    //    Case 1: client explicity changes the PrimaryGroupId, then the
    //            user must a member of the New Primary Group
    //    Case 2: System changes PrimaryGroupId when the account morphed,
    //            then the user may or may be a member of the New Primary Group.
    //
    // 2. When KeepOldPrimaryGroupMembership == TRUE, then add the user as a
    //    member in the Old Primary Group.
    //    KeepOldPrimaryGroupMembership will be set to TRUE whenever:
    //          a) PrimaryGroupId explicitly changed    OR
    //          b) PrimaryGroupId has been changed due to Domain Controller's
    //             PrimaryGroudId enforcement and the old Primary Group ID is
    //             not the default one.
    //

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS, IgnoreStatus;

    if (NewPrimaryGroupId != OldPrimaryGroupId)
    {
        //
        // STATUS_MEMBER_NOT_IN_GROUP is an expected error, that
        // is because the user is not necessary to be a member of the
        // new Primary Group in the case of the account getting morphed,
        // which triggers the PrimaryGroupId change.
        //
        IgnoreStatus = SampRemoveUserFromGroup(
                            AccountContext,
                            NewPrimaryGroupId,
                            AccountContext->TypeBody.User.Rid
                            );

        //
        // ISSUE: rather than ignoring the status --- need to explicitly
        // check for STATUS_MEMBER_IN_GROUP -- in future the function may
        // return othe errors
        //

        if (KeepOldPrimaryGroupMembership)
        {
            NtStatus =  SampAddUserToGroup(
                            AccountContext,
                            OldPrimaryGroupId,
                            AccountContext->TypeBody.User.Rid
                            );

            if ( (STATUS_NO_SUCH_GROUP==NtStatus)  ||
                 (STATUS_MEMBER_IN_GROUP==NtStatus) )

            {
                //
                // Could be because the group has been deleted using
                // the tree delete mechanism. Reset status code to success
                //
                NtStatus = STATUS_SUCCESS;
            }
        }

    }

    return( NtStatus );
}





NTSTATUS
SampDsSetInformationDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN DSNAME       *pObject,
    IN ULONG        cCallMap,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN SAMP_ATTRIBUTE_MAPPING *rSamAttributeMap 
    )
/*++

Routine Description:

    This routine is called by loopback client to set domain object
    information.

Parameters:

    DomainHandle - Domain Context
    
    pObject - Domain Object DS Name
    
    cCallMap - number of attributes 
    
    rCallMap - contains attribute blocks
    
    rSamAttributeMap - SAM attribute mapping table

Return Value:

    STATUS_SUCCESS  success
    other value - failed

--*/

{
    NTSTATUS        NtStatus = STATUS_SUCCESS, IgnoreStatus;
    PSAMP_OBJECT    DomainContext = (PSAMP_OBJECT)DomainHandle; 
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN V1aFixed = NULL;
    SAMP_OBJECT_TYPE    FoundType;
    ACCESS_MASK     DesiredAccess = 0;
    BOOLEAN         fLockAcquired = FALSE;   
    BOOLEAN         FixedAttrChanged = FALSE,
                    OldUasCompat;
    ULONG           i, TempIntegerValue;
    BOOLEAN         fPasswordAgePolicyChanged = FALSE;
    BOOLEAN         fLockoutPolicyChanged = FALSE;


    //
    // Increment the active thread count, so we will consider this
    // thread at shutdown time
    // 
    NtStatus = SampIncrementActiveThreads();
    if (!NT_SUCCESS(NtStatus))
    {
        return( NtStatus );
    }

    //
    // Set the desired access based upon the attributes
    // 

    for ( i = 0; i < cCallMap; i++ )
    {
        if ( !rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore)
        {
            continue;
        }

        switch (rSamAttributeMap[ rCallMap[i].iAttr ].SamAttributeType)
        {
        case SAMP_FIXED_DOMAIN_FORCE_LOGOFF:
        case SAMP_FIXED_DOMAIN_UAS_COMPAT_REQUIRED:

            DesiredAccess |= DOMAIN_WRITE_OTHER_PARAMETERS; 
            break;

        case SAMP_FIXED_DOMAIN_MAX_PASSWORD_AGE:
        case SAMP_FIXED_DOMAIN_MIN_PASSWORD_AGE:
        case SAMP_FIXED_DOMAIN_LOCKOUT_DURATION:
        case SAMP_FIXED_DOMAIN_LOCKOUT_OBSERVATION_WINDOW:
        case SAMP_FIXED_DOMAIN_PWD_PROPERTIES:
        case SAMP_FIXED_DOMAIN_MIN_PASSWORD_LENGTH:
        case SAMP_FIXED_DOMAIN_PASSWORD_HISTORY_LENGTH:
        case SAMP_FIXED_DOMAIN_LOCKOUT_THRESHOLD:

            DesiredAccess |= DOMAIN_WRITE_PASSWORD_PARAMS;
            break;

        default:
            break;
        }
    }

    //
    // Validate type of, and access to object
    // 

    NtStatus = SampLookupContext(DomainContext,
                                 DesiredAccess,
                                 SampDomainObjectType,
                                 &FoundType
                                 );
    
    if (NT_SUCCESS(NtStatus))
    {
        //
        // Get the fixed length data for the domain object 
        // 

        NtStatus = SampGetFixedAttributes(DomainContext,
                                          FALSE,     //  Don't Make Copy
                                          (PVOID *)&V1aFixed
                                          );

        if (NT_SUCCESS(NtStatus))
        {
            OldUasCompat = V1aFixed->UasCompatibilityRequired;

            for ( i = 0; i < cCallMap; i++ )
            {
                ATTR    *pAttr = NULL;

                if ( !rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore )
                {
                    continue;
                }

                //
                // get the attr address
                // 
                pAttr = &(rCallMap[i].attr);

                switch (rSamAttributeMap[ rCallMap[i].iAttr ].SamAttributeType)
                {
                case SAMP_FIXED_DOMAIN_MAX_PASSWORD_AGE:

                    SampGetLargeIntegerFromAttrVal(i, rCallMap, FALSE, 
                                                   &(V1aFixed->MaxPasswordAge) ); 

                    if (V1aFixed->MaxPasswordAge.QuadPart > 0) 
                    {

                        // the max password age isn't a delta time

                        NtStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        FixedAttrChanged = TRUE;
                        fPasswordAgePolicyChanged = TRUE;
                    }

                    break;

                case SAMP_FIXED_DOMAIN_MIN_PASSWORD_AGE:

                    SampGetLargeIntegerFromAttrVal(i, rCallMap, FALSE,
                                        &(V1aFixed->MinPasswordAge) );

                    if (V1aFixed->MinPasswordAge.QuadPart > 0)
                    {

                        // the min password age isn't a delta time

                        NtStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        FixedAttrChanged = TRUE;
                        fPasswordAgePolicyChanged = TRUE;
                    }

                    break;

                case SAMP_FIXED_DOMAIN_FORCE_LOGOFF:

                    SampGetLargeIntegerFromAttrVal( i, rCallMap, FALSE,
                                        &(V1aFixed->ForceLogoff) );

                    FixedAttrChanged = TRUE;

                    break;

                case SAMP_FIXED_DOMAIN_LOCKOUT_DURATION:

                    SampGetLargeIntegerFromAttrVal( i, rCallMap, FALSE,
                                        &(V1aFixed->LockoutDuration) );

                    if (V1aFixed->LockoutDuration.QuadPart > 0)
                    {

                        // the lock out duration isn't a delta time

                        NtStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        FixedAttrChanged = TRUE;
                        fLockoutPolicyChanged = TRUE;
                    }

                    break;

                case SAMP_FIXED_DOMAIN_LOCKOUT_OBSERVATION_WINDOW:

                    SampGetLargeIntegerFromAttrVal( i, rCallMap, FALSE,
                                        &(V1aFixed->LockoutObservationWindow) );

                    if (V1aFixed->LockoutObservationWindow.QuadPart > 0)
                    {

                        // the lock out oberservation isn't a delta time

                        NtStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        FixedAttrChanged = TRUE;
                        fLockoutPolicyChanged = TRUE;
                    }

                    break;

                case SAMP_FIXED_DOMAIN_PWD_PROPERTIES:

                    SampGetUlongFromAttrVal( i, rCallMap, FALSE,
                                        &(V1aFixed->PasswordProperties) );

                    FixedAttrChanged = TRUE;

                    break;

                case SAMP_FIXED_DOMAIN_MIN_PASSWORD_LENGTH:

                    NtStatus = SampGetUShortFromAttrVal( i, rCallMap, FALSE,
                                        &(V1aFixed->MinPasswordLength) );

                    if (!NT_SUCCESS(NtStatus))
                    {
                        break;
                    }
                    
                    if (V1aFixed->MinPasswordLength > PWLEN)
                    {
                        //
                        // Password should be less then PWLEN - 256
                        // or Mix Password Length should be larger
                        // than that.
                        // 

                        NtStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        FixedAttrChanged = TRUE;
                    }

                    break;

                case SAMP_FIXED_DOMAIN_PASSWORD_HISTORY_LENGTH:

                    NtStatus = SampGetUShortFromAttrVal( i, rCallMap, FALSE,
                                        &(V1aFixed->PasswordHistoryLength) );
                    if (!NT_SUCCESS(NtStatus))
                    {
                        break;
                    }

                    if (V1aFixed->PasswordHistoryLength >
                        SAMP_MAXIMUM_PASSWORD_HISTORY_LENGTH)
                    {
                        // the history length is larger than we can 
                        // allow 

                        NtStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        FixedAttrChanged = TRUE;
                    }

                    break;

                case SAMP_FIXED_DOMAIN_LOCKOUT_THRESHOLD:

                    NtStatus = SampGetUShortFromAttrVal( i, rCallMap, FALSE,
                                        &(V1aFixed->LockoutThreshold) );
                    if (!NT_SUCCESS(NtStatus))
                    {
                        break;
                    }

                    FixedAttrChanged = TRUE;

                    break;

                case SAMP_FIXED_DOMAIN_UAS_COMPAT_REQUIRED:

                    //
                    // We will drop support for UAS compatibility 
                    // 

                    NtStatus = STATUS_INVALID_PARAMETER;

                    break;

                case SAMP_DOMAIN_MIXED_MODE:

                    //
                    // Call the worker routine in DS
                    // 

                    NtStatus = SampWriteDomainNtMixedDomain(
                                                DomainHandle,
                                                i,
                                                pObject,
                                                rCallMap
                                                ); 

                    break;

                default:

                    ASSERT(FALSE && "Logic Error, invalide SAM attr type");
                    break;
                }   // switch

                if (!NT_SUCCESS(NtStatus))
                    break;

            }// for
        }

        //
        // Do combination checks
        //
        if (NT_SUCCESS(NtStatus)
        &&  fPasswordAgePolicyChanged
        && (V1aFixed->MaxPasswordAge.QuadPart >= V1aFixed->MinPasswordAge.QuadPart)  ) {

            //
            // Can't have a minimum age longer than a maximum age
            //

            NtStatus = STATUS_INVALID_PARAMETER;
        }

        if (NT_SUCCESS(NtStatus)
        &&  fLockoutPolicyChanged
        && (V1aFixed->LockoutDuration.QuadPart > 
            V1aFixed->LockoutObservationWindow.QuadPart)) {

            //
            // Infeasible to have a duration shorter than the observation
            // window; note these values are negative.
            //

            NtStatus = STATUS_INVALID_PARAMETER;
        }

        if (NT_SUCCESS(NtStatus) && FixedAttrChanged)
        {
            NtStatus = SampSetFixedAttributes(
                                DomainContext,
                                V1aFixed
                                );
        }

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampDeReferenceContext(DomainContext, TRUE);
        }
        else {

            IgnoreStatus = SampDeReferenceContext(DomainContext, FALSE);
        }
    }
    
    //
    // Let shutdown handling logic know that we are done
    // 

    SampDecrementActiveThreads();

    return( NtStatus );
}





NTSTATUS
SampDsSetInformationGroup(
    IN SAMPR_HANDLE GroupHandle,
    IN DSNAME       *pObject,
    IN ULONG        cCallMap,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN SAMP_ATTRIBUTE_MAPPING *rSamAttributeMap 
    )
/*++

Routine Description:

    This routine is called by loopback client to set group object
    information.

Parameters:

    GroupHandle - Group Context
    
    pObject - Domain Object DS Name
    
    cCallMap - number of attributes 
    
    rCallMap - contains attribute blocks
    
    rSamAttributeMap - SAM attribute mapping table

Return Value:

    STATUS_SUCCESS  success
    other value - failed

--*/
{
    NTSTATUS            NtStatus = STATUS_SUCCESS, IgnoreStatus;
    PSAMP_OBJECT        GroupContext = (PSAMP_OBJECT)GroupHandle;
    SAMP_OBJECT_TYPE    FoundType;
    SAMP_V1_0A_FIXED_LENGTH_GROUP   V1Fixed;
    ACCESS_MASK         DesiredAccess = 0;
    UNICODE_STRING      OldAccountName = {0, 0, NULL};
    UNICODE_STRING      NewAccountName, AdminComment;
    ULONG               GroupType, i;
    BOOLEAN             AccountNameChanged = FALSE;

    //
    // Increment the active thread count, so we will consider this
    // thread at shutdown time
    // 
    NtStatus = SampIncrementActiveThreads();
    if (!NT_SUCCESS(NtStatus))
    {
        return( NtStatus );
    }


    //
    // Set the desired access based upon the attributes to be modified
    // 
    for ( i = 0; i< cCallMap; i++ )
    {
        if (!rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore)
        {
            continue;
        }

        switch (rSamAttributeMap[ rCallMap[i].iAttr ].SamAttributeType)
        {
        case SAMP_GROUP_NAME:
        case SAMP_GROUP_ADMIN_COMMENT:
            DesiredAccess |= GROUP_WRITE_ACCOUNT;
            break;
        default:
            break; 
        }
    }

    //
    // Validate type of, and access to object
    // 
    NtStatus = SampLookupContext(GroupContext,
                                 DesiredAccess,        // Desired Access
                                 SampGroupObjectType,
                                 &FoundType
                                 );

    if (NT_SUCCESS(NtStatus))
    {

        NtStatus = SampRetrieveGroupV1Fixed(GroupContext,
                                            &V1Fixed
                                            );

        if (NT_SUCCESS(NtStatus))
        {
            for ( i = 0; i < cCallMap; i++ )
            {
                ATTR        *pAttr = NULL;

                if ( !rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore )
                {
                    continue;
                }

                //
                // get the attr address
                // 
                pAttr = &(rCallMap[i].attr);

                switch (rSamAttributeMap[ rCallMap[i].iAttr ].SamAttributeType)
                {
                case SAMP_GROUP_NAME:

                    //
                    // Can only replace the name - can't remove it 
                    // 

                    NtStatus = SampGetUnicodeStringFromAttrVal( 
                                        i, rCallMap,
                                        FALSE,      // remove is not allowed
                                        &NewAccountName );
                    if (NT_SUCCESS(NtStatus))
                    {
                    

                        RtlInitUnicodeString(&OldAccountName, NULL);

                        NtStatus = SampChangeGroupAccountName(
                                        GroupContext,
                                        &NewAccountName,
                                        &OldAccountName
                                        );

                        if (!NT_SUCCESS(NtStatus))
                        {
                            OldAccountName.Buffer = NULL;
                        }

                        AccountNameChanged = TRUE;
                    }

                    break;

                case SAMP_GROUP_ADMIN_COMMENT:
        
                    NtStatus = SampGetUnicodeStringFromAttrVal( 
                                        i, rCallMap, TRUE, &AdminComment );
                    if (NT_SUCCESS(NtStatus))
                    {

                        NtStatus = SampSetUnicodeStringAttribute(
                                        GroupContext,
                                        SAMP_GROUP_ADMIN_COMMENT,
                                        &AdminComment
                                        );
                    }

                    break;

                case SAMP_GROUP_MEMBERS:
            
                    //
                    // Write group member attribute
                    // 
                    NtStatus = SampWriteGroupMembers(GroupHandle, 
                                                     pObject,
                                                     i, 
                                                     rCallMap
                                                     );

                    break;

                case SAMP_GROUP_SID_HISTORY:
        
                    //
                    // SampWriteSidHistory
                    // 
                    NtStatus = SampWriteSidHistory(
                                            GroupHandle,
                                            i,
                                            pObject,
                                            cCallMap,
                                            rCallMap
                                            );

                    break;

                case SAMP_FIXED_GROUP_TYPE:
                
                    //
                    // Get Group Type Value
                    // 
                    SampGetUlongFromAttrVal( i, rCallMap,
                                        FALSE,      // remove is not allowed
                                        &GroupType );

                    NtStatus = SampWriteGroupType(GroupHandle, 
                                                  GroupType,
                                                  FALSE
                                                  );

                    break;

                case SAMP_GROUP_NON_MEMBERS:

                    //
                    // Not currently supported in this release
                    //
                    NtStatus = STATUS_NOT_SUPPORTED;
                    break;

                default:
                    ASSERT(FALSE && "Logic Error, invalid SAM attr type");
                    break;
                }

                if (!NT_SUCCESS(NtStatus))
                    break;
            }
        }

        //
        // Loopback is complicated and one of its complexities is the loopback
        // merge process. What this involves is that when SAM issues the first
        // write ( ie DirModifyEntry ) in response to an update on a SAM attribute
        // the modifications to the non SAM attributes are merged into this DirModifyEntry
        // by the loopback code in ntdsa. This created a class of bugs -- there are
        // some modifications that the client can issue to SAM attributes, which depending
        // on the curent state may effectively be no ops. An example is unexpiring
        // the password when the password is already valid. In these cases SAM will not
        // issue a DirModifyEntry as effectively no write needs to be performed 
        // ( at least from SAM's perspective ). However if the client combined this
        // operation along with writes of other non SAM attributes, the writes to the other
        // non SAM attributes will be skipped. The following  lines of code is a 
        // firewall that effectively forces a write of the old Group Account Name 
        // attribute in such cases to cause a dummy write.
        //

        if ((NT_SUCCESS(NtStatus)) &&
           ( !GroupContext->VariableDirty && !GroupContext->FixedDirty))
        {
            //
            // N.B The following assert doesn't hold true when the group
            // membership is changed because that will commit the memory
            // to disk and leave the context up to date (and hence not
            // dirty).
            //
            // ASSERT( FALSE == AccountNameChanged );
            UNICODE_STRING TempString;

            NtStatus = SampGetUnicodeStringAttribute(
                            GroupContext,
                            SAMP_GROUP_NAME,
                            TRUE, // Make copy
                            &TempString
                            );

           if (NT_SUCCESS(NtStatus))
           {
               NtStatus = SampSetUnicodeStringAttribute(
                              GroupContext,
                              SAMP_GROUP_NAME,
                              &TempString
                              );

               SampFreeUnicodeString( &TempString );
           }
        }


        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampDeReferenceContext(GroupContext, TRUE);
        }
        else {
        
            IgnoreStatus = SampDeReferenceContext(GroupContext, FALSE);
        }
    }

    //
    // Audit Account Name Change
    //
    // Note: GroupType, SidHistory, Members changes all have been audited
    //       separately.
    //
    // a more generic audit event will be generated when processing notification 
    // list in SampNotifyReplicatedinChange()
    // 

    if (NT_SUCCESS(NtStatus) && 
        AccountNameChanged && 
        SampDoAccountAuditing(GroupContext->DomainIndex) )
    {
        SampAuditAccountNameChange(GroupContext, &NewAccountName, &OldAccountName);
    }


    //
    // Let shutdown handling logic know that we are done
    // 

    SampDecrementActiveThreads();

    //
    // Cleanup string
    // 
    SampFreeUnicodeString( &OldAccountName );

    return( NtStatus );
}



NTSTATUS
SampDsSetInformationAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN DSNAME       *pObject,
    IN ULONG        cCallMap,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN SAMP_ATTRIBUTE_MAPPING *rSamAttributeMap 
    )
/*++
Routine Description:

    This routine is called by loopback client to set alias object
    information.

Parameters:

    AliasHandle - Alias Context
    
    pObject - Domain Object DS Name
    
    cCallMap - number of attributes 
    
    rCallMap - contains attribute blocks
    
    rSamAttributeMap - SAM attribute mapping table

Return Value:

    STATUS_SUCCESS  success
    other value - failed

--*/

{
    NTSTATUS            NtStatus = STATUS_SUCCESS, IgnoreStatus;
    PSAMP_OBJECT        AliasContext = (PSAMP_OBJECT)AliasHandle;
    SAMP_OBJECT_TYPE    FoundType;
    ACCESS_MASK         DesiredAccess = 0;
    UNICODE_STRING      OldAccountName = {0, 0, NULL};
    UNICODE_STRING      NewAccountName, AdminComment;
    ULONG               GroupType, i;
    BOOLEAN             AccountNameChanged = FALSE;

    //
    // Increment the active thread count, so we will consider this
    // thread at shutdown time
    // 
    NtStatus = SampIncrementActiveThreads();
    if (!NT_SUCCESS(NtStatus))
    {
        return( NtStatus );
    }



    //
    // Set the desired access based upon the attributes to be modified
    // 
    for ( i = 0; i< cCallMap; i++ )
    {
        if (!rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore)
        {
            continue;
        }

        switch (rSamAttributeMap[ rCallMap[i].iAttr ].SamAttributeType)
        {
        case SAMP_ALIAS_NAME:
        case SAMP_ALIAS_ADMIN_COMMENT:
            DesiredAccess |= ALIAS_WRITE_ACCOUNT;
            break;
        default:
            break; 
        }
    }

    //
    // Validate type of, and access to object
    // 
    NtStatus = SampLookupContext(AliasContext, 
                                 DesiredAccess,
                                 SampAliasObjectType,
                                 &FoundType
                                 );


    if (NT_SUCCESS(NtStatus))
    {
        for ( i = 0; i < cCallMap; i++ )
        {
            ATTR    *pAttr = NULL;

            if ( !rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore )
            {
                continue;
            }

            switch (rSamAttributeMap[ rCallMap[i].iAttr ].SamAttributeType)
            {
            case SAMP_ALIAS_NAME:

                //
                // Can only replace the name - can't remove it 
                // 

                 NtStatus = SampGetUnicodeStringFromAttrVal(i, rCallMap, 
                                                FALSE, // remove is not allowed
                                                &NewAccountName );
                if (NT_SUCCESS(NtStatus))
                {

                    NtStatus = SampChangeAliasAccountName(
                                    AliasContext,
                                    &NewAccountName,
                                    &OldAccountName
                                    );

                    if (!NT_SUCCESS(NtStatus))
                    {
                        OldAccountName.Buffer = NULL;
                    }

                    AccountNameChanged = TRUE;
                }

                break;

            case SAMP_ALIAS_ADMIN_COMMENT:

                NtStatus = SampGetUnicodeStringFromAttrVal(
                                    i, rCallMap, TRUE,&AdminComment );

                if (NT_SUCCESS(NtStatus))
                {
                    NtStatus = SampSetUnicodeStringAttribute(
                                    AliasContext,
                                    SAMP_ALIAS_ADMIN_COMMENT,
                                    &AdminComment
                                    );
                }

                break;

            case SAMP_ALIAS_MEMBERS:

                //
                // Write alias member attribute
                // 
                NtStatus = SampWriteAliasMembers(AliasHandle,
                                                 pObject,
                                                 i,
                                                 rCallMap
                                                 );

                break;


            case SAMP_ALIAS_NON_MEMBERS:

                //
                // Write alias non member attribute for Application Basic
                // and LDAP Query groups
                // 
                if ((AliasContext->TypeBody.Alias.NT5GroupType == NT5AppBasicGroup)
                 || (AliasContext->TypeBody.Alias.NT5GroupType == NT5AppQueryGroup)  ) {

                    NtStatus = SampWriteAliasNonMembers(AliasHandle,
                                                        pObject,
                                                        i,
                                                        rCallMap
                                                        );
                } else {

                    NtStatus = STATUS_NOT_SUPPORTED;
                }

                break;

            case SAMP_ALIAS_SID_HISTORY:

                // 
                // SampWriteSidHistory
                // 
                NtStatus = SampWriteSidHistory(
                                        AliasHandle,
                                        i,
                                        pObject,
                                        cCallMap,
                                        rCallMap
                                        );

                break;

            case SAMP_FIXED_ALIAS_TYPE:

                //
                // Get Group Type Value
                // 
                SampGetUlongFromAttrVal(i, rCallMap,
                                        FALSE,  // remove is not allowed
                                        &GroupType );

                NtStatus = SampWriteGroupType(AliasHandle, 
                                              GroupType,
                                              FALSE
                                              );

                break;

            default:

                ASSERT(FALSE && "Logic Error, invalide SAM attr type");
                break;

            }

            if (!NT_SUCCESS(NtStatus))
                break;
        }


        //
        // Loopback is complicated and one of its complexities is the loopback
        // merge process. What this involves is that when SAM issues the first
        // write ( ie DirModifyEntry ) in response to an update on a SAM attribute
        // the modifications to the non SAM attributes are merged into this DirModifyEntry
        // by the loopback code in ntdsa. This created a class of bugs -- there are
        // some modifications that the client can issue to SAM attributes, which depending
        // on the curent state may effectively be no ops. An example is unexpiring
        // the password when the password is already valid. In these cases SAM will not
        // issue a DirModifyEntry as effectively no write needs to be performed 
        // ( at least from SAM's perspective ). However if the client combined this
        // operation along with writes of other non SAM attributes, the writes to the other
        // non SAM attributes will be skipped. The following  lines of code is a 
        // firewall that effectively forces a write of the old Alias Account Name 
        // attribute in such cases to cause a dummy write.
        //

        if ((NT_SUCCESS(NtStatus)) &&
           ( !AliasContext->VariableDirty && !AliasContext->FixedDirty))
        {
            //
            // N.B The following assert doesn't hold true when the group
            // membership is changed because that will commit the memory
            // to disk and leave the context up to date (and hence not
            // dirty).
            //
            // ASSERT( FALSE == AccountNameChanged );
            UNICODE_STRING TempString;

            NtStatus = SampGetUnicodeStringAttribute(
                            AliasContext,
                            SAMP_ALIAS_NAME,
                            TRUE, // Make copy
                            &TempString
                            );

           if (NT_SUCCESS(NtStatus))
           {
               NtStatus = SampSetUnicodeStringAttribute(
                              AliasContext,
                              SAMP_ALIAS_NAME,
                              &TempString
                              );

               SampFreeUnicodeString( &TempString );
           }
        }


        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampDeReferenceContext(AliasContext, TRUE);
        }
        else
        {
            IgnoreStatus = SampDeReferenceContext(AliasContext, FALSE);
        }
    }

    //
    // audit account name change
    //
    // Note: GroupType, SidHistory, Members changes all have been audited
    //       separately.
    // 
    // a more generic audit event will be generated when processing notification 
    // list in SampNotifyReplicatedinChange()
    //

    if (NT_SUCCESS(NtStatus) && 
        AccountNameChanged && 
        SampDoAccountAuditing(AliasContext->DomainIndex) )
    {
        SampAuditAccountNameChange(AliasContext, &NewAccountName, &OldAccountName);
    }

    //
    // Let shutdown handling logic know that we are done
    // 

    SampDecrementActiveThreads();


    //
    // Cleanup Strings
    // 
    SampFreeUnicodeString( &OldAccountName );

    return( NtStatus );
}


NTSTATUS
SampDsSetInformationUser(
    IN SAMPR_HANDLE UserHandle,
    IN DSNAME       *pObject,
    IN ULONG        cCallMap,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN SAMP_ATTRIBUTE_MAPPING *rSamAttributeMap 
    )
/*++
Routine Description:

    This routine is called by loopback client to set User object
    information.

Parameters:

    UserHandle - User Context
    
    pObject - Domain Object DS Name
    
    cCallMap - number of attributes 
    
    rCallMap - contains attribute blocks
    
    rSamAttributeMap - SAM attribute mapping table

Return Value:

    STATUS_SUCCESS  success
    other value - failed

--*/

{
    NTSTATUS            NtStatus = STATUS_SUCCESS, IgnoreStatus;
    PSAMP_OBJECT        UserContext = (PSAMP_OBJECT)UserHandle;
    SAMP_OBJECT_TYPE    FoundType;
    ACCESS_MASK         DesiredAccess = 0;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    PSAMP_DEFINED_DOMAINS   Domain;
    ULONG               DomainIndex, 
                        UserAccountControlFlag = 0,
                        UserAccountControl = 0,
                        OldUserAccountControl = 0,
                        PrimaryGroupId = 0,
                        OldPrimaryGroupId = 0,
                        UserRid = 0, 
                        i;
    UNICODE_STRING      Workstations,
                        ApiList,
                        FullName,
                        NewAccountName,
                        OldAccountName = {0, 0, NULL},
                        AdminComment,
                        PasswordInQuote,
                        AccountName = {0, 0, NULL},
                        NewPassword;
    LONG                CountryCode,
                        CodePage;
    BOOLEAN             PasswordExpired = FALSE, 
                        AccountControlChange = FALSE,
                        PrimaryGroupIdChange = FALSE,
                        AccountGettingMorphed = FALSE,
                        KeepOldPrimaryGroupMembership = FALSE,
                        SystemChangesPrimaryGroupId = FALSE,
                        AccountNameChanged = FALSE,
                        FreePassword = FALSE,
                        AccountUnlocked = FALSE;
    LOGON_HOURS         LogonHours;
    LARGE_INTEGER       TimeSupplied, 
                        AccountExpires,
                        LockoutTime;



    //
    // Initialize any data that we may free later
    //

    RtlSecureZeroMemory(&NewPassword, sizeof(UNICODE_STRING));

    //
    // Increment the active thread count, so we will consider this
    // thread at shutdown time
    // 

    NtStatus = SampIncrementActiveThreads();
    if (!NT_SUCCESS(NtStatus))
    {
        return( NtStatus );
    }


    // 
    // Set the desired access based upon which attributes the caller
    // is trying to modify
    // 
    for ( i = 0; i< cCallMap; i++ )
    {
        if (!rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore)
        {
            continue;
        }
        
        switch (rSamAttributeMap[ rCallMap[i].iAttr ].SamAttributeType)
        {
        case SAMP_USER_ACCOUNT_NAME:
        case SAMP_USER_ADMIN_COMMENT:
        case SAMP_USER_WORKSTATIONS:
        case SAMP_USER_LOGON_HOURS:
        case SAMP_FIXED_USER_ACCOUNT_EXPIRES:

            DesiredAccess |= USER_WRITE_ACCOUNT;
            break;

        case SAMP_FIXED_USER_PRIMARY_GROUP_ID:

            PrimaryGroupIdChange = TRUE;
            DesiredAccess |= USER_WRITE_ACCOUNT;
            break;

        case SAMP_FIXED_USER_ACCOUNT_CONTROL:

            AccountControlChange = TRUE;
            DesiredAccess |= USER_WRITE_ACCOUNT;
            break;


        case SAMP_FIXED_USER_COUNTRY_CODE:
        case SAMP_FIXED_USER_CODEPAGE:

            DesiredAccess |= USER_WRITE_PREFERENCES;
            break;

        case SAMP_USER_UNICODE_PWD:
        case SAMP_FIXED_USER_PWD_LAST_SET:
        case SAMP_USER_PASSWORD:
            DesiredAccess |= USER_FORCE_PASSWORD_CHANGE;
            break;

        default:
            break; 
        }
    }

    //
    // Validate type of, and access to object
    // 

    NtStatus = SampLookupContext(UserContext,
                                 DesiredAccess,
                                 SampUserObjectType,
                                 &FoundType
                                 );

    if (!NT_SUCCESS(NtStatus))
    {
        goto CleanupBeforeReturn;
    }

    DomainIndex = UserContext->DomainIndex;
    Domain = &SampDefinedDomains[ DomainIndex ];

    //
    // Get the user's rid. This is used for notifying other
    // packages of a password change.
    //

    UserRid = UserContext->TypeBody.User.Rid;


    // 
    // Retrieve V1aFixed information
    // 

    NtStatus = SampRetrieveUserV1aFixed(UserContext,
                                        &V1aFixed
                                        );

    if (NT_SUCCESS(NtStatus))
    {
        //
        // Store away the old account control flags for cache update
        //

        OldUserAccountControl = V1aFixed.UserAccountControl;

        //
        // Store away the old Primary Group Id for detecting wether we need
        // to modify the user's membership
        //
        OldPrimaryGroupId = V1aFixed.PrimaryGroupId;
    }
    else
    {
        goto Error;
    }

    NtStatus = SampGetUnicodeStringAttribute(
                  UserContext,
                  SAMP_USER_ACCOUNT_NAME,
                  TRUE,    // Make copy
                  &AccountName
                  );    

    if (!NT_SUCCESS(NtStatus)) {
        goto Error;
    }

    for ( i = 0; i < cCallMap; i++ )
    {
        ATTR        *pAttr = NULL;

        if ( !rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore )
        {
            continue;
        }

        //
        // Get the attribute address
        // 

        pAttr = &(rCallMap[i].attr); 

        //
        // case on the attribute
        // 
        switch (rSamAttributeMap[ rCallMap[i].iAttr ].SamAttributeType)
        {
        case SAMP_USER_WORKSTATIONS:
            //
            // Get Unicode String attribute value 
            // 
            NtStatus = SampGetUnicodeStringFromAttrVal( 
                            i, rCallMap, TRUE, &Workstations );
            if (NT_SUCCESS(NtStatus))
            {

                NtStatus = SampConvertUiListToApiList(
                                    &Workstations,
                                    &ApiList,
                                    FALSE
                                    );

                if (NT_SUCCESS(NtStatus))
                {
                    NtStatus = SampSetUnicodeStringAttribute(
                                    UserContext,
                                    SAMP_USER_WORKSTATIONS,
                                    &ApiList
                                    );
                }
            }
            break;

        case SAMP_USER_ACCOUNT_NAME:

            NtStatus = SampGetUnicodeStringFromAttrVal(
                            i, rCallMap, FALSE, &NewAccountName);
            if (NT_SUCCESS(NtStatus))
            {

                NtStatus = SampChangeUserAccountName(
                                    UserContext,
                                    &NewAccountName,
                                    V1aFixed.UserAccountControl,
                                    &OldAccountName
                                    );

                if (NT_SUCCESS(NtStatus))
                {
                   AccountNameChanged = RtlCompareUnicodeString(&OldAccountName, 
                                                                &NewAccountName, 
                                                                TRUE 
                                                                ) == 1 ? TRUE:FALSE;
                }
                else 
                {
                    OldAccountName.Buffer = NULL;
                }
            }
            break;

        case SAMP_USER_ADMIN_COMMENT:

            NtStatus = SampGetUnicodeStringFromAttrVal(
                               i, rCallMap, TRUE, &AdminComment);
            if (NT_SUCCESS(NtStatus))
            {

                NtStatus = SampSetUnicodeStringAttribute(
                                    UserContext,
                                    SAMP_USER_ADMIN_COMMENT,
                                    &AdminComment
                                    );
            }
            break;

        case SAMP_USER_LOGON_HOURS:

            if ( (AT_CHOICE_REMOVE_ATT == rCallMap[i].choice) ||
                 (0 == pAttr->AttrVal.valCount) || 
                 (0 == pAttr->AttrVal.pAVal[0].valLen) )
            {
                LogonHours.UnitsPerWeek = 0;
                LogonHours.LogonHours = NULL;
            }
            else
            {
                LogonHours.UnitsPerWeek = 
                    (USHORT) (pAttr->AttrVal.pAVal[0].valLen * 8);
                LogonHours.LogonHours = 
                    (PUCHAR) pAttr->AttrVal.pAVal[0].pVal;
            }

            NtStatus = SampReplaceUserLogonHours(
                                    UserContext,
                                    &LogonHours
                                    );

            break;

        case SAMP_FIXED_USER_COUNTRY_CODE:

             NtStatus = SampGetUShortFromAttrVal(
                            i,
                            rCallMap,
                            FALSE,
                            &V1aFixed.CountryCode
                            );

            if (NT_SUCCESS(NtStatus))
            {

                NtStatus = SampReplaceUserV1aFixed(
                                UserContext,
                                &V1aFixed
                                );
            }

            break;

        case SAMP_FIXED_USER_CODEPAGE:

            

            NtStatus = SampGetUShortFromAttrVal(
                            i,
                            rCallMap,
                            FALSE,
                            &V1aFixed.CodePage
                            );

            if (NT_SUCCESS(NtStatus))
            {
   

                NtStatus = SampReplaceUserV1aFixed(
                                UserContext,
                                &V1aFixed
                                );
            }

            break;

        case SAMP_FIXED_USER_PWD_LAST_SET:

            SampGetLargeIntegerFromAttrVal(i,rCallMap,FALSE,&TimeSupplied);

            NtStatus = SampValidateUserPwdLastSet(UserContext,
                                                  TimeSupplied,
                                                  &PasswordExpired
                                                  );


            //
            // if the parameter is valid, check whether the client 
            // can unexpire userPassword on users (computer accounts 
            // are not subject to this access check).
            // 
            // Only UnExpire Password will be checked. No additional 
            // access CK for ExpirePassword operation.
            // 

            if ( NT_SUCCESS(NtStatus) && !PasswordExpired )
            {
                NtStatus = SampValidatePwdSettingAttempt(
                                UserContext,    // account context
                                NULL,           // client token
                                V1aFixed.UserAccountControl,
                                (GUID *) &GUID_CONTROL_UnexpirePassword
                                );
            }


            //
            // If the PasswordExpired field is passed in,
            // Only update PasswordLastSet if the password is being
            // forced to expire or if the password is currently forced
            // to expire.
            //
            // Avoid setting the PasswordLastSet field to the current
            // time if it is already non-zero.  Otherwise, the field
            // will slowly creep forward each time this function is
            // called and the password will never expire.
            //
            if ( NT_SUCCESS(NtStatus) &&
                 (PasswordExpired ||
                  (SampHasNeverTime.QuadPart == V1aFixed.PasswordLastSet.QuadPart)) ) 
            {

                NtStatus = SampComputePasswordExpired(
                                PasswordExpired,
                                &V1aFixed.PasswordLastSet
                                );

                if (NT_SUCCESS(NtStatus))
                {
                    NtStatus = SampReplaceUserV1aFixed(
                                        UserContext,
                                        &V1aFixed
                                        );
                }
            }

            break;

        case SAMP_USER_UNICODE_PWD:

            // Get the clear text password to be set.

            NtStatus = SampGetNewUnicodePasswordFromAttrVal(i,rCallMap, &NewPassword);

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = SampDsSetPasswordUser(UserHandle,
                                                 &NewPassword
                                                 );
            }

            break;

        case SAMP_USER_PASSWORD:

            // User password is supported only when the behavior version is whistler

            if (SampDefinedDomains[UserContext->DomainIndex].BehaviorVersion 
                    < DS_BEHAVIOR_WIN_DOT_NET )
            {
                NtStatus = STATUS_NOT_SUPPORTED;
                break;
            }

            // Get the clear text password to be set.

            NtStatus = SampGetNewUTF8PasswordFromAttrVal(i,rCallMap, &NewPassword);

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = SampDsSetPasswordUser(UserHandle,
                                                 &NewPassword
                                                 );
                FreePassword = TRUE;
            }


            break;

        case SAMP_FIXED_USER_PRIMARY_GROUP_ID:

            SampGetUlongFromAttrVal(i,rCallMap,FALSE,&PrimaryGroupId);

            NtStatus = SampValidatePrimaryGroupId(UserContext,
                                                  V1aFixed,
                                                  PrimaryGroupId
                                                  );

            if (NT_SUCCESS(NtStatus) &&
                (PrimaryGroupId != V1aFixed.PrimaryGroupId) )  
            {
                KeepOldPrimaryGroupMembership = TRUE;
                V1aFixed.PrimaryGroupId = PrimaryGroupId;

                NtStatus = SampReplaceUserV1aFixed(
                                    UserContext,
                                    &V1aFixed
                                    );
            } 

            break;

        case SAMP_FIXED_USER_ACCOUNT_CONTROL:
            
            SampGetUlongFromAttrVal(i,rCallMap,FALSE,&UserAccountControlFlag);
            NtStatus = SampFlagsToAccountControl(
                                UserAccountControlFlag,
                                &UserAccountControl
                                );

            if (!PrimaryGroupIdChange)
            {
                SystemChangesPrimaryGroupId = TRUE;
            }

            NtStatus = SampSetUserAccountControl(
                                UserContext, 
                                UserAccountControl,
                                &V1aFixed,
                                SystemChangesPrimaryGroupId,
                                &AccountUnlocked,
                                &AccountGettingMorphed,
                                &KeepOldPrimaryGroupMembership
                                );

            if (NT_SUCCESS(NtStatus))
            {
                if (AccountGettingMorphed && 
                    (V1aFixed.UserAccountControl & USER_SERVER_TRUST_ACCOUNT)
                   )
                {
                    //
                    // in this case, system will automatically change the
                    // primary group id.
                    // 
                    SystemChangesPrimaryGroupId = TRUE;
                }
                
                NtStatus = SampReplaceUserV1aFixed(
                                    UserContext,
                                    &V1aFixed
                                    );
            }

            break;

        case SAMP_FIXED_USER_ACCOUNT_EXPIRES:

            SampGetLargeIntegerFromAttrVal(i,rCallMap,TRUE,&AccountExpires);

            NtStatus = SampValidateUserAccountExpires(
                                    UserContext,
                                    AccountExpires
                                    );

            if (NT_SUCCESS(NtStatus))
            {
                V1aFixed.AccountExpires = AccountExpires;

                NtStatus = SampReplaceUserV1aFixed(
                                    UserContext,
                                    &V1aFixed
                                    );
            }

            break;

        case SAMP_USER_SID_HISTORY:

            //
            // Modify SID History 
            // 

            NtStatus = SampWriteSidHistory(
                                    UserHandle,
                                    i,
                                    pObject,
                                    cCallMap,
                                    rCallMap
                                    );

            break;

        case SAMP_FIXED_USER_LOCKOUT_TIME:

            SampGetLargeIntegerFromAttrVal(i,rCallMap,FALSE,&LockoutTime);

            NtStatus = SampWriteLockoutTime(
                            UserContext,
                            &V1aFixed,
                            LockoutTime
                            );

            if (NT_SUCCESS(NtStatus)) {
                //
                // Via LDAP, the user can get unlocked out two ways:
                // either by setting a user account control or by directly
                // setting the lockoutTime to 0
                //
                ASSERT(LockoutTime.QuadPart == 0i64);
                AccountUnlocked = TRUE;
            }

            break;

        case SAMP_FIXED_USER_SITE_AFFINITY:
        case SAMP_FIXED_USER_CACHED_MEMBERSHIP_TIME_STAMP:
        case SAMP_FIXED_USER_CACHED_MEMBERSHIP:

            //
            // Modify no-gc logon attributes 
            // 

            NtStatus = SampWriteNoGCLogonAttrs(
                                    UserHandle,
                                    rSamAttributeMap[ rCallMap[i].iAttr ].SamAttributeType,
                                    i,
                                    pObject,
                                    cCallMap,
                                    rCallMap
                                    );

            break;

        default:
            ASSERT(FALSE && "Unknonw SAM attribute");
            ;
        }

        if (!NT_SUCCESS(NtStatus))
        {
            break;
        }
    }

    //
    // If the primary group Id has been changed then explicitly modify the
    // user's membership to include the old primary group as a member.
    // 

    if (NT_SUCCESS(NtStatus) &&
        (V1aFixed.PrimaryGroupId != OldPrimaryGroupId) 
       )
    {
        NtStatus = SampMaintainPrimaryGroupIdChange(
                                    UserContext,
                                    V1aFixed.PrimaryGroupId,
                                    OldPrimaryGroupId,
                                    KeepOldPrimaryGroupMembership
                                    );
    }


Error:

    //
    // Loopback is complicated and one of its complexities is the loopback
    // merge process. What this involves is that when SAM issues the first
    // write ( ie DirModifyEntry ) in response to an update on a SAM attribute
    // the modifications to the non SAM attributes are merged into this DirModifyEntry
    // by the loopback code in ntdsa. This created a class of bugs -- there are
    // some modifications that the client can issue to SAM attributes, which depending
    // on the curent state may effectively be no ops. An example is unexpiring
    // the password when the password is already valid. In these cases SAM will not
    // issue a DirModifyEntry as effectively no write needs to be performed 
    // ( at least from SAM's perspective ). However if the client combined this
    // operation along with writes of other non SAM attributes, the writes to the other
    // non SAM attributes will be skipped. The following  lines of code is a 
    // firewall that effectively forces a write of all the SAM "fixed" attributes
    // in such cases to cause a dummy write.
    //

    if ((NT_SUCCESS(NtStatus)) &&
       ( !UserContext->VariableDirty && !UserContext->FixedDirty))
    {
        NtStatus = SampReplaceUserV1aFixed(
                                    UserContext,
                                    &V1aFixed
                                    );
    }

    if (NT_SUCCESS(NtStatus)
    && !(V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK)
    && (PasswordExpired ||  AccountUnlocked)) {

        //
        // We want these changes to travel fast within a site
        //
        UserContext->ReplicateUrgently = TRUE;

    }

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampDeReferenceContext(UserContext, TRUE);
    }
    else {

        IgnoreStatus = SampDeReferenceContext(UserContext, FALSE);
    }

    //
    // Generate audit if necessary
    // 
    // a more generic audit event will be generated when processing notification 
    // list in SampNotifyReplicatedinChange()
    //

    if (NT_SUCCESS(NtStatus) &&
        SampDoAccountAuditing(UserContext->DomainIndex) )
    {
        //
        // audit account name change
        // 

        if (AccountNameChanged)
        {
            SampAuditAccountNameChange(UserContext, &NewAccountName, &OldAccountName);
        }

        //
        // account been disabled or enabled 
        // 

        if ((OldUserAccountControl & USER_ACCOUNT_DISABLED) !=
            (V1aFixed.UserAccountControl & USER_ACCOUNT_DISABLED))
        {

            SampAuditAccountEnableDisableChange(UserContext,
                                                V1aFixed.UserAccountControl,
                                                OldUserAccountControl,
                                                &AccountName
                                                );
        }
    }

    if ( NT_SUCCESS(NtStatus) ) {

        ULONG NotifyFlags = 0;

        //
        // If this ends up committing, tell the PDC about this originating
        // change
        //
        if (PasswordExpired) {
            NotifyFlags |= SAMP_PWD_NOTIFY_MANUAL_EXPIRE;
        }
        if (AccountUnlocked) {
            NotifyFlags |= SAMP_PWD_NOTIFY_UNLOCKED;
        }
        if (NewPassword.Length > 0) {
            NotifyFlags |= SAMP_PWD_NOTIFY_PWD_CHANGE;
        }
        if (NotifyFlags != 0) {

            if (V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK) {
                NotifyFlags |= SAMP_PWD_NOTIFY_MACHINE_ACCOUNT;
            }
    
            SampPasswordChangeNotify(NotifyFlags,
                                     AccountNameChanged ? &NewAccountName : &AccountName,
                                     UserRid,
                                    &NewPassword,
                                     TRUE  // loopback
                                    );
        }
    }


CleanupBeforeReturn:

    //
    // Let shutdown handling logic know that we are done
    // 

    SampDecrementActiveThreads();


    //
    // Cleanup 
    // 

    SampFreeUnicodeString( &OldAccountName );

    SampFreeUnicodeString( &AccountName );

    if (NewPassword.Length > 0) {
        RtlSecureZeroMemory(NewPassword.Buffer, NewPassword.Length);
    }
    if (FreePassword) {
        LocalFree(NewPassword.Buffer);
    }

    return( NtStatus );
}


NTSTATUS
SamIDsSetObjectInformation(
    IN SAMPR_HANDLE ObjectHandle,
    IN DSNAME       *pObject,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG cCallMap,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN SAMP_ATTRIBUTE_MAPPING *rSamAttributeMap 
    )
/*++

Routine Description:

    This routine takes a DS-Loopback attribute block (rCallMap), first 
    validates each Loopback attribute, then writes them to the Object 
    Context. After finishing all loopback attributes, commit the changes. 
    This function is a thin wrapper, the functionality are implemented in 
    the lower routine - SampDsSetInformation*  (* can be Domain, Group, 
    Alias or User).

Parameters:

    ObjectHandle - SAM Object Handle (context)      
    
    ObjectType - Indicate the SAM object type 
                    Domain
                    Group
                    Alias
                    User

    cCallMap - indicate how many items in the loopback attribute block
    
    rCallMap - pointer to the loopback attribute block (an array)                    

    rSamAttributeMap - pointer to the SAM attribute ID <==> DS ATT ID map

Return Value:

    STATUS_SUCCES
    or any error code

--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    ASSERT((SampDomainObjectType == ObjectType) ||
           (SampGroupObjectType == ObjectType) ||
           (SampAliasObjectType == ObjectType) ||
           (SampUserObjectType == ObjectType) );

    switch (ObjectType)
    {
    case SampDomainObjectType:

        NtStatus = SampDsSetInformationDomain(ObjectHandle,
                                              pObject,
                                              cCallMap,
                                              rCallMap,
                                              rSamAttributeMap
                                              );
        break;

    case SampGroupObjectType:

        NtStatus = SampDsSetInformationGroup(ObjectHandle,
                                             pObject,
                                             cCallMap,
                                             rCallMap,
                                             rSamAttributeMap
                                             );
        break;

    case SampAliasObjectType:

        NtStatus = SampDsSetInformationAlias(ObjectHandle,
                                             pObject,
                                             cCallMap,
                                             rCallMap,
                                             rSamAttributeMap
                                             );
        break;

    case SampUserObjectType:

        NtStatus = SampDsSetInformationUser(ObjectHandle,
                                            pObject,
                                            cCallMap,
                                            rCallMap,
                                            rSamAttributeMap
                                            );
        break;

    default:

        ASSERT(FALSE && "Invalid object type");

        NtStatus = STATUS_UNSUCCESSFUL;
        break;
    }

    return(NtStatus);
}

NTSTATUS
SamIHandleObjectUpdate(
    IN SAM_HANDLE_OBJECT_UPDATE_OPTYPE OpType,
    IN PVOID                           UpdateInfo,        
    IN ATTRBLOCK                       *AttrBlockIn,
    OUT ATTRBLOCK                      *AttrBlockOut
    )
/*++

Routine Description:

    This routine is a called from the DS to let SAM process a special
    attribute during a modify.  The attribute is noted in the UpdateInfo 
    structure. 

Parameters:

    Optype     -- Operation to be preformed on the object
                                 
    UpdateInfo -- a pointer to SAMP_OBJECT_UPDATE_INFO
    
    AttrBlockIn -- extra attributes on the object that have been applied
                   to the object
                   
    AttrBlockOut -- attribute SAM wants to apply to the object                           


Return Values:

    STATUS_SUCCESS, resource error otherwise.


--*/
{

    switch (OpType) {
    case eSamObjectUpdateOpCreateSupCreds:

        return SampCreateSupplementalCredentials(UpdateInfo,
                                                 AttrBlockIn,
                                                 AttrBlockOut);
    default:

        return ERROR_INVALID_PARAMETER;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\enckey.c ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997-1997
//
// File:        enckey.c
//
// Contents:    Password based key encryption/decryption library.
//
// History:     17-Apr-97      terences created
//
//---------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <rc4.h>
#include <md5.h>
#include <crypt.h>
#include <enckey.h>

// --------------------------------------------
// EncryptKey
//
//  Caller passes in hash of unicode password, struct to get the enc key,
//  and struct to get the clear key.
//  The hash of the password is passed in a KEClearKey struct so that this
//  can be changed in the future.
//
//  EncryptKey generates a random salt, random key, builds the encryption
//  structure, and returns the clear key.
//
//  WARNING:  Eat the clear key as soon after use as possible!
//            Also, not threadsafe.
//
//      return code:
//          always returns success

DWORD
KEEncryptKey(
    IN KEClearKey       *pPassword,
    OUT KEEncKey        *pEncBlock,
    OUT KEClearKey      *pSAMKey,
    IN DWORD            dwFlags)
{
    MD5_CTX         LocalHash;
    struct RC4_KEYSTRUCT    LocalRC4Key;

    if ((pPassword == NULL) || (pEncBlock == NULL) || (pSAMKey == NULL))
        return 0;

    if (pPassword->dwVersion != KE_CUR_VERSION)
        return 0;

    // Fill in the structs with versions and sizes.

    pEncBlock->dwVersion = KE_CUR_VERSION;
    pEncBlock->dwLength = sizeof(KEEncKey);

    pSAMKey->dwVersion = KE_CUR_VERSION;
    pSAMKey->dwLength = sizeof(KEClearKey);

    // Gen the keying material

    RtlGenRandom(pEncBlock->Salt, KE_KEY_SIZE);
    RtlGenRandom(pEncBlock->EncKey, KE_KEY_SIZE);

    // Copy out the clear key

    memcpy(pSAMKey->ClearKey, pEncBlock->EncKey, KE_KEY_SIZE);

    // Generate the confirmer.

    MD5Init(&LocalHash);
    MD5Update(&LocalHash, pEncBlock->EncKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_1, sizeof(MAGIC_CONST_1));
    MD5Update(&LocalHash, pEncBlock->EncKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_2, sizeof(MAGIC_CONST_2));
    MD5Final(&LocalHash);

    memcpy(pEncBlock->Confirm, &(LocalHash.digest), KE_KEY_SIZE);
    RtlSecureZeroMemory(&(LocalHash), sizeof(LocalHash));

    // Encrypt the key and the confirmer

    MD5Init(&LocalHash);
    MD5Update(&LocalHash, pEncBlock->Salt, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_2, sizeof(MAGIC_CONST_2));
    MD5Update(&LocalHash, pPassword->ClearKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_1, sizeof(MAGIC_CONST_1));
    MD5Final(&LocalHash);
    rc4_key(&LocalRC4Key, KE_KEY_SIZE, (BYTE *)&(LocalHash.digest));
    rc4(&LocalRC4Key, KE_KEY_SIZE * 2, (BYTE *)&(pEncBlock->EncKey));

    RtlSecureZeroMemory(&(LocalRC4Key), sizeof(LocalRC4Key));
    RtlSecureZeroMemory(&(LocalHash), sizeof(LocalHash));

    // return success!

    return KE_OK;
}

//---------------------------------------------
// DecryptKey
//
//  Caller passes in hash of unicode password, enc key struct, struct to
//  get the clear key
//
//  DecryptKey will return the clear key if the password matches.  Note that
//  this function is ALWAYS destructive to the passed encryption block.  In
//  the case of a decrypt, it will be zeroed out.
//
//  return codes:
//      KE_BAD_PASSWORD     Password will not decrypt key
//      KE_OK               Password decrypted key

DWORD KEDecryptKey(
    IN KEClearKey   *pPassword,
    IN KEEncKey     *pEncBlock,
    OUT KEClearKey  *pSAMKey,
    IN DWORD        dwFlags)
{
    MD5_CTX         LocalHash;
    struct RC4_KEYSTRUCT   LocalRC4Key;

    if ((pPassword == NULL) || (pEncBlock == NULL) || (pSAMKey == NULL))
        return KE_FAIL;

    if ((pEncBlock->dwVersion != KE_CUR_VERSION) ||
        (pPassword->dwVersion != KE_CUR_VERSION))
        return KE_FAIL;

    pSAMKey->dwVersion = KE_CUR_VERSION;
    pSAMKey->dwLength = sizeof(KEClearKey);

    // Decrypt the key and the confirmer
    MD5Init(&LocalHash);
    MD5Update(&LocalHash, pEncBlock->Salt, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_2, sizeof(MAGIC_CONST_2));
    MD5Update(&LocalHash, pPassword->ClearKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_1, sizeof(MAGIC_CONST_1));
    MD5Final(&LocalHash);
    rc4_key(&LocalRC4Key, KE_KEY_SIZE, (BYTE *) &(LocalHash.digest));
    rc4(&LocalRC4Key, KE_KEY_SIZE * 2, (BYTE *)&(pEncBlock->EncKey));

    // Clean up immediately

    RtlSecureZeroMemory(&(LocalHash), sizeof(LocalHash));
    RtlSecureZeroMemory(&(LocalRC4Key), sizeof(LocalRC4Key));

    // Generate the confirmer.

    MD5Init(&LocalHash);
    MD5Update(&LocalHash, pEncBlock->EncKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_1, sizeof(MAGIC_CONST_1));
    MD5Update(&LocalHash, pEncBlock->EncKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_2, sizeof(MAGIC_CONST_2));
    MD5Final(&LocalHash);

    // Check that the confirmer matches

    if (memcmp(&(LocalHash.digest), &(pEncBlock->Confirm), KE_KEY_SIZE))
    {
        // Failed.  Zero and leave.
        // No need to zero the block, since rc4 trashed it.

        RtlSecureZeroMemory(&(LocalHash), sizeof(LocalHash));
        return KE_BAD_PASSWORD;
    }

    // Confirmer matched.

    RtlSecureZeroMemory(&(LocalHash), sizeof(LocalHash));
    memcpy(pSAMKey->ClearKey, pEncBlock->EncKey, KE_KEY_SIZE);
    RtlSecureZeroMemory(pEncBlock, sizeof(KEEncKey));

    return KE_OK;
}


//---------------------------------------------
// ChangeKey
//
//  Caller passes in hash of old unicode password, hash of new password,
//  enc key struct, enc key struct is reencrypted with the new password.
//
//  return codes:
//      KE_BAD_PASSWORD     Password will not decrypt key
//      KE_OK               Password decrypted key

DWORD KEChangeKey(
    IN KEClearKey       *pOldPassword,
    IN KEClearKey       *pNewPassword,
    IN OUT KEEncKey     *pEncBlock,
    IN DWORD            dwFlags)
{
    MD5_CTX         LocalHash;
    struct RC4_KEYSTRUCT   LocalRC4Key;

    if ((pOldPassword == NULL) || (pEncBlock == NULL)||(pNewPassword == NULL))
        return KE_FAIL;

    if ((pEncBlock->dwVersion != KE_CUR_VERSION) ||
        (pOldPassword->dwVersion != KE_CUR_VERSION) ||
                (pNewPassword->dwVersion != KE_CUR_VERSION))
        return KE_FAIL;

    // Decrypt the key and the confirmer

    MD5Init(&LocalHash);
    MD5Update(&LocalHash, pEncBlock->Salt, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_2, sizeof(MAGIC_CONST_2));
    MD5Update(&LocalHash, pOldPassword->ClearKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_1, sizeof(MAGIC_CONST_1));
    MD5Final(&LocalHash);
    rc4_key(&LocalRC4Key, KE_KEY_SIZE, (BYTE *)&(LocalHash.digest));
    rc4(&LocalRC4Key, KE_KEY_SIZE * 2, (BYTE *)&(pEncBlock->EncKey));

    // Clean up immediately

    RtlSecureZeroMemory(&(LocalHash), sizeof(LocalHash));
    RtlSecureZeroMemory(&(LocalRC4Key), sizeof(LocalRC4Key));

    // Generate the confirmer.

    MD5Init(&LocalHash);
    MD5Update(&LocalHash, pEncBlock->EncKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_1, sizeof(MAGIC_CONST_1));
    MD5Update(&LocalHash, pEncBlock->EncKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_2, sizeof(MAGIC_CONST_2));
    MD5Final(&LocalHash);

    // Check that the confirmer matches

    if (memcmp(&(LocalHash.digest), &(pEncBlock->Confirm), KE_KEY_SIZE))
    {
        // Failed.  Zero and leave.
        // No need to zero the block, since rc4 trashed it.

        RtlSecureZeroMemory(&(LocalHash), sizeof(LocalHash));
        return KE_BAD_PASSWORD;
    }

    // Confirmer matched.

    RtlSecureZeroMemory(&(LocalHash), sizeof(LocalHash));

    // Reencrypt with the new password.

    MD5Init(&LocalHash);
    MD5Update(&LocalHash, pEncBlock->Salt, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_2, sizeof(MAGIC_CONST_2));
    MD5Update(&LocalHash, pNewPassword->ClearKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_1, sizeof(MAGIC_CONST_1));
    MD5Final(&LocalHash);
    rc4_key(&LocalRC4Key, KE_KEY_SIZE, (BYTE *)&(LocalHash.digest));
    rc4(&LocalRC4Key, KE_KEY_SIZE * 2, (BYTE *)&(pEncBlock->EncKey));

    // Clean up immediately

    RtlSecureZeroMemory(&(LocalHash), sizeof(LocalHash));
    RtlSecureZeroMemory(&(LocalRC4Key), sizeof(LocalRC4Key));

    return KE_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\enum.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    enum.c

Abstract:

    This file contains the core account enumeration services

Author:

    Murli Satagopan    (MURLIS) 

Environment:

    User Mode - Win32

Revision History:

  6-19-96: MURLIS Created.


--*/


/////////////////////////////////////////////////////////////////////////////
/*
 
  ENUMERATION ROUTINES IMPLEMENTATION

    The Entry Points for the core Enumeration routines are

        SampEnumerateAcountNamesCommon -- 

            Called By the Samr RPC routines

        SampEnumerateAccountNames2 -- 

            Called by the above SampEnumerateAccountNamesCommon
            and internal routines that need enumeration.

        SampEnumerateAccountNames

            Called by old Registry Mode routines only, that require enumeration
            EnumerateAccountNames is called with the TransactionDomain Set
            and Read lock Held. It can also be called in DS mode as long as
            the above 2 conditions are met.

         
    SampEnumerateAccountNames2 does the actual work of enumerating account 
    names. the transaction domain to be set . SampEnumerateAccountNames 
    looks at the current current transaction domain and makes the decision
    wether it is DS or Registry and then Calls either DS or Registry version.
    While the way enumeration is done from the registry is unaltered the 
    way it is done from the DS is as follows:

    Enumerating Accounts in DS uses the DS Search mechanism along with 
    the Paged Results extension. The First time the client calls the Enumerate
    accounts routine, the value of EnumerationHandle is set to 0. 
    This results in the code building a DS Filter structure and set up a 
    new search. If More entries are turned up the search, than memory 
    restrictions will warrant, then the DS will turn return a PagedResults 
    Structure. This paged results structure is used to determine if more entries
    are present. The restart handle given out by the DS is the RID. The top 2 bits
    are used to represent the account type of the user ( user, machine, trust ) for 
    user enumeration. Index ranges set on NC_acctype_sid index are used to restart
    the search given the account type and the RID.
    
   

*/
////////////////////////////////////////////////////////////////////////////

//
//  Includes
// 
#include <samsrvp.h>
#include <mappings.h>
#include <dslayer.h>
#include <filtypes.h>
#include <dsdsply.h>
#include <dsconfig.h>
#include <malloc.h>
#include <lmcons.h>

//
//
// The Maximum Number of Enumerations a Client can simultaneously do. Since
// we keep around some state in memory per enumeration operation and since
// we are the security system, we cannot alow a malicious client from running
// us out of memory. So limit on a per client basis. Our state info is size is
// qpprox 1K byte. 
//

#define SAMP_MAX_CLIENT_ENUMERATIONS 16

//
// DS limits the number of items that a given search can find. While in the
// SAM API, the approximate amount of memory is specified. This factor is
// is used in computing the number of entries required fro memory specified
//

#define AVERAGE_MEMORY_PER_ENTRY    (sizeof(SAM_RID_ENUMERATION) + LM20_UNLEN * sizeof(WCHAR) + sizeof(WCHAR))



//
// In DS mode the max size of the buffer that can be returned by the enumeration
// API's
//

#define SAMP_MAXIMUM_MEMORY_FOR_DS_ENUMERATION (AVERAGE_MEMORY_PER_ENTRY * 512) 

//
//  Prototypes of Private Functions
//

NTSTATUS
SampEnumerateAccountNamesDs(
    IN DSNAME * DomainObjectName,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN          BuiltinDomain,
    IN OUT PULONG EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned,
    IN BOOLEAN TrustedClient
    );

NTSTATUS
SampBuildDsEnumerationFilter(
   IN SAMP_OBJECT_TYPE  ObjectType,
   IN ULONG             UserAccountControlFilter,
   OUT FILTER         * DsFilter,
   OUT PULONG         SamAccountTypeLo,
   OUT PULONG         SamAccountTypeHi
   );

VOID
SampFreeDsEnumerationFilter(
    FILTER * DsFilter
    );


NTSTATUS
SampEnumerateAccountNamesRegistry(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned,
    IN BOOLEAN TrustedClient
    );


NTSTATUS
SampPackDsEnumerationResults(
    IN PSID     DomainPrefix,
    IN BOOLEAN  BuiltinDomain,
    SEARCHRES   *SearchRes,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG    ExpectedAttrCount,
    IN ULONG    Filter,
    ULONG       * Count,
    PSAMPR_RID_ENUMERATION  *RidEnumerationList
    );

NTSTATUS
SampDoDsSearchContinuation(
    IN  SEARCHRES * SearchRes,
    IN OUT PULONG EnumerationContext,
    IN  BOOLEAN   CanEnumerateEntireDomain,
    OUT BOOLEAN * MoreEntries
    );
    
NTSTATUS
SampGetLastEntryRidAndAccountControl(
    IN  SEARCHRES * SearchRes, 
    IN  SAMP_OBJECT_TYPE ObjectType,
    IN  ULONG     ExpectedAttrCount,
    OUT ULONG     * Rid,
    OUT ULONG     * LastAccountControlValue
    );
    

NTSTATUS
SampEnumerateAccountNames2(
    IN PSAMP_OBJECT     DomainContext,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned,
    IN BOOLEAN TrustedClient
    );

ULONG
Ownstrlen(
    CHAR * Sz
   );


NTSTATUS
SampEnumerateAccountNamesCommon(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationHandle,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned
    )

/*++

Routine Description:

    This routine enumerates names of either user, group or alias accounts.
    This routine is intended to directly support

        SamrEnumerateGroupsInDomain(),
        SamrEnumerateAliasesInDomain() and
        SamrEnumerateUsersInDomain().

    This routine performs database locking, and context lookup (including
    access validation).




    All allocation for OUT parameters will be done using MIDL_user_allocate.



Arguments:

    DomainHandle - The domain handle whose users or groups are to be enumerated.

    ObjectType - Indicates whether users or groups are to be enumerated.

    EnumerationHandle - API specific handle to allow multiple calls.  The
        caller should return this value in successive calls to retrieve
        additional information.

    Buffer - Receives a pointer to the buffer containing the
        requested information.  The information returned is
        structured as an array of SAM_ENUMERATION_INFORMATION data
        structures.  When this information is no longer needed, the
        buffer must be freed using SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    Filter - if ObjectType is users, the users can optionally be filtered
        by setting this field with bits from the AccountControlField that
        must match.  Otherwise ignored.

    CountReturned - Receives the number of entries returned.


Return Value:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.  Entries may or may not have been
        returned from this call.  The CountReturned parameter indicates
        whether any were.

    STATUS_MORE_ENTRIES - There are more entries which may be obtained
        using successive calls to this API.  This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have access to request the data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.


--*/
{
    NTSTATUS                    NtStatus;
    NTSTATUS                    IgnoreStatus;
    PSAMP_OBJECT                Context;
    SAMP_OBJECT_TYPE            FoundType;
    ACCESS_MASK                 DesiredAccess;
    BOOLEAN                     fLockAcquired = FALSE;

    SAMTRACE("SampEnumerateAccountNamesCommon");

    //
    // Update DS performance statistics
    //

    SampUpdatePerformanceCounters(
        DSSTAT_ENUMERATIONS,
        FLAG_COUNTER_INCREMENT,
        0
        );


    ASSERT( (ObjectType == SampGroupObjectType) ||
            (ObjectType == SampAliasObjectType) ||
            (ObjectType == SampUserObjectType)    );

    if ((ObjectType!=SampGroupObjectType) 
        && (ObjectType!=SampUserObjectType)
        && (ObjectType!=SampAliasObjectType))
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        return NtStatus;
    }

    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (DomainHandle != NULL);
    ASSERT (EnumerationHandle != NULL);
    ASSERT (  Buffer  != NULL);
    ASSERT ((*Buffer) == NULL);
    ASSERT (CountReturned != NULL);


    //
    // Establish type-specific information
    //

    DesiredAccess = DOMAIN_LIST_ACCOUNTS;


    SampAcquireReadLock();
    fLockAcquired = TRUE;


    //
    // Validate type of, and access to object.
    //

    Context = (PSAMP_OBJECT)DomainHandle;
    NtStatus = SampLookupContext(
                   Context,
                   DesiredAccess,
                   SampDomainObjectType,
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {
   
        //
        // If We are in DS Mode then release the READ lock
        // DS enumeration routines do not require the READ lock
        //

        if (IsDsObject(Context))
        {
            SampReleaseReadLock();
            fLockAcquired = FALSE;
        }


        //
        // Call our private worker routine
        //

        NtStatus = SampEnumerateAccountNames2(
                        Context,
                        ObjectType,
                        EnumerationHandle,
                        Buffer,
                        PreferedMaximumLength,
                        Filter,
                        CountReturned,
                        Context->TrustedClient
                        );

        //
        // Re-Acquire the Lock again
        //

        if (!fLockAcquired)
        {
            SampAcquireReadLock();
            fLockAcquired = TRUE;
        }    

        //
        // De-reference the object, discarding changes
        //

        IgnoreStatus = SampDeReferenceContext( Context, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Free the read lock
    //

    ASSERT(fLockAcquired);

    SampReleaseReadLock();

    return(NtStatus);
}

NTSTATUS
SampEnumerateAccountNames(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned,
    IN BOOLEAN TrustedClient
    )

/*++

  Routine Description

    This routine is a wrapper aroung SampEnumerateAccountNames2, so that
    old Registry mode callers can continue to use this entry point. 
    Parameters to this are identical to SampEnumerateAccountNames2

--*/
{
    ASSERT(SampCurrentThreadOwnsLock());
    ASSERT(SampTransactionWithinDomain);

    return(SampEnumerateAccountNames2(
                SampDefinedDomains[SampTransactionDomainIndex].Context,
                ObjectType,
                EnumerationContext,
                Buffer,
                PreferedMaximumLength,
                Filter,
                CountReturned,
                TrustedClient
                ));
}

NTSTATUS
SampEnumerateAccountNames2(
    IN PSAMP_OBJECT     DomainContext,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned,
    IN BOOLEAN TrustedClient
    )
/*++

Routine Description:

    This is the wrapper around the worker routine used to enumerate user,
    group or alias accounts. This determines wether the domain is in the
    DS or Registry, and then depending upon the outcome calls the 
    appropriate flavour of the routine


    Note:  IN REGISTRY MODE ONLY THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN.
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseReadLock() in registry mode. In DS mode this
           routine is completely thread safe.



    All allocation for OUT parameters will be done using MIDL_user_allocate.



Arguments:

    DomainContext - Pointer to SAM object.

    ObjectType - Indicates whether users or groups are to be enumerated.

    EnumerationContext - API specific handle to allow multiple calls.  The
        caller should return this value in successive calls to retrieve
        additional information.

    Buffer - Receives a pointer to the buffer containing the
        requested information.  The information returned is
        structured as an array of SAM_ENUMERATION_INFORMATION data
        structures.  When this information is no longer needed, the
        buffer must be freed using SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    Filter - if ObjectType is users, the users can optionally be filtered
        by setting this field with bits from the AccountControlField that
        must match.  Otherwise ignored.

    CountReturned - Receives the number of entries returned.

    TrustedClient - says whether the caller is trusted or not.  If so,
        we'll ignore the SAMP_MAXIMUM_MEMORY_TO_USE restriction on data
        returns.


Return Value:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.  Entries may or may not have been
        returned from this call.  The CountReturned parameter indicates
        whether any were.

    STATUS_MORE_ENTRIES - There are more entries which may be obtained
        using successive calls to this API.  This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have access to request the data.


--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;


    if (SampUseDsData)
    {
        //
        // DS Object - Do the DS thing
        //
        do
        {
        
            NtStatus = SampEnumerateAccountNamesDs(
                                        DomainContext->ObjectNameInDs,
                                        ObjectType,
                                        IsBuiltinDomain(DomainContext->DomainIndex),
                                        (PULONG)
                                            EnumerationContext,
                                        Buffer,
                                        PreferedMaximumLength,
                                        Filter,
                                        CountReturned,
                                        TrustedClient
                                        );
           
          
            if ((0 == *CountReturned) && (STATUS_MORE_ENTRIES == NtStatus))
            {
                if (*Buffer)
                {
                    MIDL_user_free(*Buffer);
                    *Buffer = NULL;
                }
            }
            
            // 
            // The above routine will first do a DS search, then apply the 
            // bit mask Filter on all the entries returned from core DS search. 
            // Only reture those objects which satisfy the bitmask filter. In 
            // the unfortuante case that no object matching the bitmask is found, 
            // and we still have more objects to look through into the core DS, 
            // we end up returning STATUS_MORE_ENTRIES with 0 count of entries.
            // To address this problem, we should continue to search until we
            // have at least one entry to return or nothing to return.
            // 
                                        
        } while ((0 == *CountReturned) && (STATUS_MORE_ENTRIES == NtStatus));
    }
    else
    {

        ASSERT(SampCurrentThreadOwnsLock());
        ASSERT(SampTransactionWithinDomain);
        ASSERT(SampTransactionDomainIndex==DomainContext->DomainIndex);

        //
        // Registry Object - Do the Registry thing
        //
        NtStatus = SampEnumerateAccountNamesRegistry(
                                    ObjectType,
                                    EnumerationContext,
                                    Buffer,
                                    PreferedMaximumLength,
                                    Filter,
                                    CountReturned,
                                    TrustedClient
                                    );
    }

    return NtStatus;
 
}
   
NTSTATUS
SamIEnumerateInterdomainTrustAccountsForUpgrade(
    IN OUT PULONG   EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG       PreferredMaximumLength,
    OUT PULONG     CountReturned
    )
/*++

   Routine Description

   This is packaged export for in process callers to enumerate
   accounts from the DS that can be called when upgrading from
   NT4. Specification of the domain is not required as we know
   the domain that we are upgrading.

   Parameters

      See SampEnumerateAccountNamesDs below
 
   Return Values
 
      See SampEnumerateAccountNamesDs below
--*/
{
    PDSNAME      DomainDn=NULL;
    ULONG        Length = 0;
    NTSTATUS     NtStatus = STATUS_SUCCESS;


    //
    // Get the root domain
    //

    NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                &Length,
                                NULL
                                );


    if (STATUS_BUFFER_TOO_SMALL == NtStatus)
    {
        SAMP_ALLOCA(DomainDn,Length );
        if (NULL==DomainDn)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                    &Length,
                                    DomainDn
                                    );

       ASSERT(NT_SUCCESS(NtStatus));
       
    }

    if (!NT_SUCCESS(NtStatus))
    {
       return(NtStatus);
    }

    return(SampEnumerateAccountNamesDs(
                  DomainDn,
                  SampUserObjectType,
                  FALSE,
                  EnumerationContext,
                  Buffer,
                  0xFFFFFFFF,
                  USER_INTERDOMAIN_TRUST_ACCOUNT,
                  CountReturned,
                  TRUE  // Trusted client
                  ));
}
                  

NTSTATUS
SampEnumerateAccountNamesDs(
    IN DSNAME   * DomainObjectName,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN    BuiltinDomain,
    IN OUT PULONG EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned,
    IN BOOLEAN TrustedClient
    )
/*++

Routine Description:

    This routine does the work of enumeration for the DS case.

    All allocation for OUT parameters will be done using MIDL_user_allocate.



Arguments:

    ObjectType - Indicates whether users or groups are to be enumerated.

    BuiltinDomain - Indicates the the domain is a builtin domain

    EnumerationContext - API specific handle to allow multiple calls.  The
        caller should return this value in successive calls to retrieve
        additional information. The Enumeration context returned is the RID of
        the account

    Buffer - Receives a pointer to the buffer containing the
        requested information.  The information returned is
        structured as an array of SAM_ENUMERATION_INFORMATION data
        structures.  When this information is no longer needed, the
        buffer must be freed using SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    Filter - if ObjectType is users, the users can optionally be filtered
        by setting this field with bits from the AccountControlField that
        must match.  Otherwise ignored.

    CountReturned - Receives the number of entries returned.

    TrustedClient - says whether the caller is trusted or not.  If so,
        we'll ignore the SAMP_MAXIMUM_MEMORY_TO_USE restriction on data
        returns.


Return Value:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.  Entries may or may not have been
        returned from this call.  The CountReturned parameter indicates
        whether any were.

    STATUS_MORE_ENTRIES - There are more entries which may be obtained
        using successive calls to this API.  This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have access to request the data.


--*/
{
    //
    // Amount of memory that we may use.
    //

    ULONG       MemoryToUse = PreferedMaximumLength;

    //
    // Specify the attributes that we want to read as part of the search.
    // The Attributes specified in GenericReadAttrTypes are read from the DS, 
    // except for user objects ( due to filter on account control bits )
    // account control bits. 
    //
    // NOTE 
    // The Ordering of the Rid and the Name 
    // must be the same for both User and Generic Attr Types. 
    // Further they should be the First two attributes.
    //

    ATTRTYP     GenericReadAttrTypes[]=
                {
                    SAMP_UNKNOWN_OBJECTRID,
                    SAMP_UNKNOWN_OBJECTNAME,
                }; 
    ATTRVAL     GenericReadAttrVals[]=
                {
                    {0,NULL},
                    {0,NULL}
                };
                  
    DEFINE_ATTRBLOCK2(
                      GenericReadAttrs,
                      GenericReadAttrTypes,
                      GenericReadAttrVals
                      );

    ATTRTYP     UserReadAttrTypes[]=
                {
                    SAMP_FIXED_USER_USERID,
                    SAMP_USER_ACCOUNT_NAME,
                    SAMP_FIXED_USER_ACCOUNT_CONTROL,
                };
    ATTRVAL     UserReadAttrVals[]=
                {
                    {0,NULL},
                    {0,NULL},
                    {0,NULL}
                };

    DEFINE_ATTRBLOCK3(
                        UserReadAttrs,
                        UserReadAttrTypes,
                        UserReadAttrVals
                      );

    //
    // Specify other local variables that we need
    //
    ATTRBLOCK  *AttrsToRead;
    NTSTATUS   Status = STATUS_SUCCESS;
    PSAMPR_RID_ENUMERATION  RidEnumerationList = NULL;
    SEARCHRES   *SearchRes;
    BOOLEAN     MoreEntries = FALSE;
    BOOLEAN     CanEnumerateEntireDomain = TRUE;
    ULONG       MaximumNumberOfEntries;
    SAMP_OBJECT_TYPE    ObjectTypeForConversion;
    FILTER      DsFilter;
    ULONG       SamAccountTypeLo, SamAccountTypeHi;
    ULONG       StartingRid = 0;
    PSID        StartingSid = NULL;
    PSID        EndingSid = NULL;
    PSID        DomainSid = &DomainObjectName->Sid;
    ULONG       LastAccountControlValue;

#define TOP_2_FOR_MACHINE_ACCOUNT  ((ULONG)0x80000000)
#define TOP_2_FOR_TRUST_ACCOUNT    ((ULONG)0xC0000000)


    //
    // init local variable and return value, in case of error condition.
    // 

    *Buffer = NULL;
    RtlZeroMemory(&DsFilter,sizeof(FILTER));

    //
    // The Passed in Domain Object Must have a SID in it
    //

    ASSERT(DomainObjectName->SidLen>0);
    ASSERT(RtlValidSid(&DomainObjectName->Sid));

    if ( !((DomainObjectName->SidLen > 0) && (RtlValidSid(&DomainObjectName->Sid))) )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    //
    // Allocate memory to hold the result
    //

    *Buffer = MIDL_user_allocate(sizeof(SAMPR_ENUMERATION_BUFFER));
    if (NULL==*Buffer)
    {
        Status = STATUS_NO_MEMORY;
        goto Error;
    }

  

    //
    // Check for Memory Restrictions
    //

    if ( (!TrustedClient) && 
         (PreferedMaximumLength > SAMP_MAXIMUM_MEMORY_FOR_DS_ENUMERATION))
    {
        MemoryToUse = SAMP_MAXIMUM_MEMORY_FOR_DS_ENUMERATION;
    }

    //
    // For Builtin Domain, no matter what, try maximum 
    // entries we can search.  
    //
    // That is because 
    // 1. We do not set the index hints for builtin domain. 
    // 2. And We do not support continue enumeration for builtin domain 
    // 
    // So the caller will never get all alias groups if the 
    // PreferedMaximumLength was set too small. 
    // fortunatelty, there are only couple of alias groups in 
    // builtin domain. (say less than 10, maybe 9 only)
    //

    if (BuiltinDomain)
    {
        MemoryToUse = SAMP_MAXIMUM_MEMORY_FOR_DS_ENUMERATION;
    }

    //
    // Compute the maximim number of entries we want based on 
    // memory restrictions. Add plus 1 , so that at least 1 entry
    // will be returned.
    //

    MaximumNumberOfEntries = MemoryToUse/AVERAGE_MEMORY_PER_ENTRY + 1;


    //
    // Run special check (introduced for Windows 2000 SP2).
    // 
    // The goal is to stop enumerate everyone behaviour. This hotfix
    // allows an administrator to shut down this API's alone to everyone
    // except a subset of people. 
    // 
    
    Status = SampExtendedEnumerationAccessCheck( TrustedClient, &CanEnumerateEntireDomain );

    if (!NT_SUCCESS(Status))
    {
        goto Error;
    }

    if ((!CanEnumerateEntireDomain) && (0!=*EnumerationContext))
    {
        //
        // Enumerating whole domain and no rights bail
        //

        Status = STATUS_SUCCESS;
        MoreEntries = FALSE;
        *CountReturned = 0;
        RidEnumerationList = NULL;
        goto Error;

    }

    //
    // Specify the Apropriate Attributes to Read
    //

    if (ObjectType == SampUserObjectType)
    {
        AttrsToRead = &UserReadAttrs;
        ObjectTypeForConversion = SampUserObjectType;
    }
    else
    {
        AttrsToRead = &GenericReadAttrs;
        ObjectTypeForConversion = SampUnknownObjectType;
    }
    
    //
    // Build the correct filter
    //


    Status = SampBuildDsEnumerationFilter(
                ObjectType, 
                Filter, 
                &DsFilter,
                &SamAccountTypeLo,
                &SamAccountTypeHi
                );

    if (!NT_SUCCESS(Status))
        goto Error;

    //
    // Compute the starting and ending Sid Ranges
    // The top 2 bits of the Enumeration Context indicate the account type
    // value ( need to preserve it in the enumeration context, cannot do read that
    // again from database as object could have been deleted.
    // SO mask the top 2 bits.

   
    StartingRid = ((*EnumerationContext) &0x3FFFFFFF) + 1;
   
    Status = SampCreateFullSid(
                    DomainSid,
                    StartingRid,
                    &StartingSid
                    );

    if (!NT_SUCCESS(Status))
        goto Error;

    Status = SampCreateFullSid(
                    DomainSid,
                    0x7fffffff,
                    &EndingSid
                    );

    if (!NT_SUCCESS(Status))
        goto Error;

  
    //
    // Start a transaction if one did not exist.
    //

    Status = SampMaybeBeginDsTransaction(TransactionRead);
    if (!NT_SUCCESS(Status))
        goto Error;

    //
    // If this were a restarted search, then we may need to modify
    // SamAccountTypeLo to be the SAM account type of the object we
    // gave out. So find the object and get its SamAccount type in 
    // here. We that only in the case of the user object as that is
    // the only category where we will traverse multiple values of
    // SAM account type in the same enumeration
    //

    if ((0!=*EnumerationContext)
        && (SampUserObjectType == ObjectType))
    {
        ULONG Top2Bits = ((*EnumerationContext) & 0xC0000000);

        switch(Top2Bits)
        {
        case TOP_2_FOR_TRUST_ACCOUNT:
                SamAccountTypeLo = SAM_TRUST_ACCOUNT;
                break;
        case TOP_2_FOR_MACHINE_ACCOUNT:
                SamAccountTypeLo = SAM_MACHINE_ACCOUNT;
                break;
        default:
                SamAccountTypeLo = SAM_NORMAL_USER_ACCOUNT;
                break;

        }
    }
                


    //
    // if not Trusted Client, Turn off fDSA
    //
    if (!TrustedClient) {
        SampSetDsa(FALSE);
    }

   
    //
    // Set the Index hints for the DS. If it is the builtin domain do not
    // set the index hints to the DS. The DS will simply choose the PDNT
    // index for the builtin domain
    //

    ASSERT((!BuiltinDomain) || (*EnumerationContext==0));
    if (!BuiltinDomain)
    {
        Status = SampSetIndexRanges(
                    SAM_SEARCH_NC_ACCTYPE_SID,
                    sizeof(ULONG),
                    &SamAccountTypeLo,
                    RtlLengthSid(StartingSid),
                    StartingSid,
                    sizeof(ULONG),
                    &SamAccountTypeHi,
                    RtlLengthSid(EndingSid),
                    EndingSid,
                    FALSE
                    );

        if (!NT_SUCCESS(Status))
            goto Error;
    }

    //
    // Perform the Search by calling DirSearch
    //

    Status = SampDsDoSearch2(
                          0,
                          NULL, 
                          DomainObjectName, 
                          &DsFilter,
                          0,
                          ObjectTypeForConversion,
                          AttrsToRead,
                          MaximumNumberOfEntries,
                          TrustedClient?0:(15 * 60 * 1000 ),
                                // 15 min timeout for non trusted client. 
                          &SearchRes
                          );

    if (!NT_SUCCESS(Status))
        goto Error;

    // 
    // DsFilter will be freed before exit
    // 
   

    //
    // Handle any paged results returned by the DS.
    //

    Status =  SampDoDsSearchContinuation(
                    SearchRes,
                    EnumerationContext,
                    CanEnumerateEntireDomain,
                    &MoreEntries
                    );

    if (!NT_SUCCESS(Status))
        goto Error;
        
  
    if (MoreEntries)
    {
        //
        // Set the Enumeration handle to the value of the last 
        // entry's RID
        //
        
        ULONG   LastRid = 0;
        
        //
        // Get last entry's Rid, and AccountControl if applicable.
        // 
        
        Status = SampGetLastEntryRidAndAccountControl(
                                     SearchRes, 
                                     ObjectType, 
                                     AttrsToRead->attrCount,
                                     &LastRid, 
                                     &LastAccountControlValue
                                     );
        
        if (!NT_SUCCESS(Status))
            goto Error;
            
        //
        // Check, if we did get something from above, then fill the 
        // enumeration context. 
        //
            
        if (0 != LastRid)
        {
            *EnumerationContext = LastRid;

            if (SampUserObjectType==ObjectType)
            {
                //
                // for User Object, the LastAccountControlValue should 
                // always be the correct one corresponding to the RID.
                //
                 
                //
                // No One's AccountControl is 0, assert it. 
                // 
                ASSERT((0 != LastAccountControlValue) && "LastAccountControlValue is 0. Impossible");
                
                if (LastAccountControlValue & USER_INTERDOMAIN_TRUST_ACCOUNT)
                {
                    (*EnumerationContext)|=TOP_2_FOR_TRUST_ACCOUNT;
                }
                else if (LastAccountControlValue & USER_MACHINE_ACCOUNT_MASK)
                {
                    (*EnumerationContext)|=TOP_2_FOR_MACHINE_ACCOUNT;
                }
            }
        }
        else
        {
            // 
            // The only case we would fall into here is that
            //  1. there are more entries in DS we should look through.
            //  2. No entry in the current search results is passed DS access check
            // 
            // In this case, we really should do an additional read against the the 
            // last entry (while turn on fDSA, without DS access check), get the last 
            // entry's AccountControl and Rid, set the enumeration context correctly. 
            // 
            // However, when the client falls into this case, it seems that most likely
            // the client does not enough right to enumeration this domain. To less 
            // this additional read on Domain Controller, we vote to return access 
            // deny, even this means minor DownLevel imcopatibility problem. 
            // 
            
            Status = STATUS_ACCESS_DENIED;
            
            goto Error;
        }
    }
    else
    {
        *EnumerationContext = 0;
    }

    //
    // Search Succeeded. Pack the results into appropriate
    // Rid Enumeration Buffers.
    //

    Status = SampPackDsEnumerationResults(
                    &DomainObjectName->Sid,
                    BuiltinDomain,
                    SearchRes,
                    ObjectType,
                    AttrsToRead->attrCount,
                    Filter,
                    CountReturned,
                    &RidEnumerationList
                    );

   


  
Error:

    if (!NT_SUCCESS(Status))
    {
        //
        // Error return, do the cleanup work.
        //

        *EnumerationContext = 0;
        
        *CountReturned = 0;

        if (*Buffer)
        {
            MIDL_user_free(*Buffer);
            *Buffer = NULL;
        }

    }
    else
    {
        //
        // More Entry, set the Status 
        // 
        if (MoreEntries)
        {
            Status = STATUS_MORE_ENTRIES;
        }
        
        
        (*Buffer)->EntriesRead = *CountReturned;
        (*Buffer)->Buffer = RidEnumerationList;
    }

    //
    // End Any DS transactions
    //

    SampMaybeEndDsTransaction(TransactionCommit);

    //
    // Free starting and ending SIDs
    //

    SampFreeDsEnumerationFilter(&DsFilter);

    if (StartingSid)
        MIDL_user_free(StartingSid);

    if (EndingSid)
        MIDL_user_free(EndingSid);


    return Status;
}


NTSTATUS
SampPackDsEnumerationResults(
    IN  PSID        DomainPrefix,
    IN  BOOLEAN     BuiltinDomain,
    IN  SEARCHRES   *SearchRes,
    IN  SAMP_OBJECT_TYPE ObjectType,
    IN  ULONG       ExpectedAttrCount,
    IN  ULONG       Filter,
    OUT ULONG       * Count,
    OUT PSAMPR_RID_ENUMERATION  *RidEnumerationList
    )
/*++

  Routine Description:

    This routine Packs the complex structures 
    returned by the core DS, into the Rid Enumeration 
    Structures required by SAM.

  Arguments:

        DomainPrefix The SID of the domain in question. 

        SearchRes SearchRes strucure as obtained from the DS.

        ExpectedAttrCount -- Passed by the caller. This is the count
                  of Attrs which the caller expects from the SearchRes
                  on a per search entry basis. Used to validate results
                  from the DS.

        Filter    For User Accounts bits of the AccountControlId.

        Count     Returned Count of Structures.

        RidEnumerationList - Array of structures of type 
                    SAMP_RID_ENUMERATION passed back in this.


--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    PSAMPR_RID_ENUMERATION  RidEnumerationListToReturn = NULL;
    ULONG       FilteredCount = 0;

    //
    // Initialize what we plan to return.
    //
    *RidEnumerationList = NULL;
    *Count = 0;

    //
    //  Look if search turned up any results.
    //  If so stuff them in Rid Enumeration Array ( or whatever )
    //
    if (SearchRes->count)
    {
        //
        // Search Did Turn up Results
        //

        ULONG Index;
        ENTINFLIST * CurrentEntInf;
        PSID        ReturnedSid;

        //
        // Allocate memory for an array of Rid Enumerations
        //
        RidEnumerationListToReturn = MIDL_user_allocate(
                                    SearchRes->count 
                                      * sizeof(SAMPR_RID_ENUMERATION)
                                    );
        if (NULL==RidEnumerationListToReturn)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        //
        // Zero Memory just what we alloced. Useful for freeing up stuff
        // in case we error'd out
        //
        RtlZeroMemory(RidEnumerationListToReturn,SearchRes->count 
                                      * sizeof(SAMPR_RID_ENUMERATION)
                                      );

        //
        // Walk through the List turned up by the search and 
        // build the RidEnumeration Buffer    
        //
        for (CurrentEntInf = &(SearchRes->FirstEntInf);
                CurrentEntInf!=NULL;
                    CurrentEntInf=CurrentEntInf->pNextEntInf)
        {
          PSID   DomainSid = NULL;

          if (CurrentEntInf->Entinf.AttrBlock.attrCount!=
                    ExpectedAttrCount)
          {
              //
              // Fails the access check executed by core DS
              // skip this entry.
              continue;
          }

          //
          // Assert that the Rid is in the right place,
          // Remember the DS will return us a SID.
          //

          ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr[0].attrTyp ==
                    SampDsAttrFromSamAttr(SampUnknownObjectType, 
                        SAMP_UNKNOWN_OBJECTSID));
          //
          // Assert that  the Name is in the right place
          //

          ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr[1].attrTyp ==
                    SampDsAttrFromSamAttr(SampUnknownObjectType, 
                        SAMP_UNKNOWN_OBJECTNAME));

          if (ObjectType == SampUserObjectType)
          {

              //
              // For User objects we need to filter based on account-control
              // field
              //

              ULONG     AccountControlValue;
              NTSTATUS  IgnoreStatus;
              //
              // Assert that the Account control is in the right place
              //

              ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr[2].attrTyp ==
                      SampDsAttrFromSamAttr(SampUserObjectType, 
                           SAMP_FIXED_USER_ACCOUNT_CONTROL));

              //
              // Get account control value and skip past if does
              // not match the filter criteria. Remember DS stores
              // Flags, so transalate it to account control
              // Using BIT wise OR logic
              //

              IgnoreStatus = SampFlagsToAccountControl(
                                *((ULONG *)(CurrentEntInf->Entinf.AttrBlock.
                                    pAttr[2].AttrVal.pAVal[0].pVal)),
                                    &AccountControlValue);

              ASSERT(NT_SUCCESS(IgnoreStatus));

              if ((Filter!=0) && 
                    ((Filter & AccountControlValue) == 0))
              {
                    //
                    // Fails the Filter Test, skip this one
                    //

                    continue;
              }

          }

          //
          // Stuff this entry in the buffer to be returned.
          //

          //
          // Copy the RID, Remember DS returns us a SID, so get the Rid Part out
          //

          
          ReturnedSid = CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal;
          Status = SampSplitSid(
                        ReturnedSid,
                        &DomainSid,
                        &(RidEnumerationListToReturn[FilteredCount].RelativeId)
                        );
          if (!NT_SUCCESS(Status))
          {
              goto Error;
          }


          // 
          // Case 1. For Account Domain 
          // Since we provide StartSid and EndSid to core DS core, 
          // they should not return any objects which belong to 
          // another domain. No need to check the Domain SID
          //
          // Case 2. For Builtin Domain 
          // Did not set SID index range, so still need to 
          // Compare Domain SID for any enumeration in Builtin Domain
          // 
          if (BuiltinDomain)
          {
              if (!RtlEqualSid(DomainSid, DomainPrefix))
              {
                  // 
                  // Sids are not the same, filter this account out
                  // 

                  MIDL_user_free(DomainSid);
                  DomainSid = NULL;
                  continue;
              }
          }

#if DBG
          else      // Account Domain
          {
              if (!RtlEqualSid(DomainSid, DomainPrefix))
              {
                  ASSERT(FALSE && "Account is not in Account Domain");
                  MIDL_user_free(DomainSid);
                  DomainSid = NULL;
                  continue;
              }

          }
#endif // DBG


          //
          // Free the Domain Sid, got from SampSplitSid
          //

          MIDL_user_free(DomainSid);
          DomainSid = NULL;

          //
          // Copy the Name
          //

          RidEnumerationListToReturn[FilteredCount].Name.Length = (USHORT)
                  (CurrentEntInf->Entinf.AttrBlock.pAttr[1].AttrVal.
                        pAVal[0].valLen);
          RidEnumerationListToReturn[FilteredCount].Name.MaximumLength = (USHORT) 
                  (CurrentEntInf->Entinf.AttrBlock.pAttr[1].AttrVal.
                        pAVal[0].valLen);

          
          RidEnumerationListToReturn[FilteredCount].Name.Buffer =  
                  MIDL_user_allocate(CurrentEntInf->Entinf.AttrBlock.pAttr[1].
                                            AttrVal.pAVal[0].valLen);

          if (NULL== (RidEnumerationListToReturn[FilteredCount]).Name.Buffer)
          {
              Status = STATUS_NO_MEMORY;
              goto Error;
          }
          
          RtlCopyMemory( RidEnumerationListToReturn[FilteredCount].Name.Buffer,
                         CurrentEntInf->Entinf.AttrBlock.pAttr[1].AttrVal.
                                    pAVal[0].pVal,
                         CurrentEntInf->Entinf.AttrBlock.pAttr[1].AttrVal.
                                    pAVal[0].valLen
                        );

          //
          // Increment the Count
          //

          FilteredCount++;

        }

        //
        // End of For Loop
        //    
        
        // 
        // if we filter all the entries out. need to release the allocated memory  
        // 
        
        if (0 == FilteredCount)
        {
            MIDL_user_free(RidEnumerationListToReturn);
            RidEnumerationListToReturn = NULL;
        }
        
    }
    //
    // Fill in the count and return buffer correctly
    //

    *Count = FilteredCount;
    *RidEnumerationList = RidEnumerationListToReturn;


Error:

    if (!NT_SUCCESS(Status))
    {
        //
        // We Errored out, need to free all that we allocated
        //

        if (NULL!=RidEnumerationListToReturn)
        {
            //
            // We did allocate something
            //

            ULONG Index;

            //
            // First free all possible Names that we alloc'ed.
            //

            for (Index=0;Index<SearchRes->count;Index++)
            {
                if (RidEnumerationListToReturn[Index].Name.Buffer)
                    MIDL_user_free(
                        RidEnumerationListToReturn[Index].Name.Buffer);
            }

            //
            // Free the buffer that we alloc'ed
            //

            MIDL_user_free(RidEnumerationListToReturn);
            RidEnumerationListToReturn = NULL;
            *RidEnumerationList = NULL;
        }
    }

    return Status;

}



NTSTATUS
SampGetLastEntryRidAndAccountControl(
    IN  SEARCHRES * SearchRes, 
    IN  SAMP_OBJECT_TYPE ObjectType,
    IN  ULONG     ExpectedAttrCount,
    OUT ULONG     * Rid,
    OUT ULONG     * LastAccountControlValue
    )
/*++
Routine Description:

    This routine scans the search results, finds the last qualified entry (with all 
    expected attributes), returns its RID and AccountControl if applicable (for User 
    Object)
    
Parameters:

    SearchRes -- Pointer to Search Results, returned by core DS
    
    ObjectType -- Specify client desired object.
    
    ExpectedAttrCount -- Used to exam each entry in search results, since DS access
                         check may not return all attributes we asked for.
                         
    Rid -- Used to return last entry's (with all expected attributes) Relative ID
    
    LastAccountControlValue -- Return last entry's AccountControl if applicable 
                               (User object only). For other object, 
                               LastAccountControlValue is useless.
    
    
Return Value:

    STATUS_SUCCESS
    STATUS_NO_MEMORY
    
--*/    
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ENTINFLIST  * CurrentEntInf = NULL;
    ENTINFLIST  * NextEntInf = NULL;
    ENTINFLIST  * LastQualifiedEntInf = NULL;
    PSID        DomainSid = NULL;
    PSID        ReturnedSid = NULL;
    
    //
    // Initialize what we plan to return 
    //     
    
    *Rid = 0;
    *LastAccountControlValue = 0;
    
    //
    // this routine is only called when we have more entried to look
    // into. So that means we have at least one entry in this search 
    // result.
    // 
    
    ASSERT(SearchRes->count);
    
    if (SearchRes->count)
    {
        //
        // Locate the last entry  
        // 
        
        NextEntInf = &(SearchRes->FirstEntInf);
        
        do
        {
            CurrentEntInf = NextEntInf;
            NextEntInf = CurrentEntInf->pNextEntInf;
            
            //
            // Find the last entry with all expected attributes
            // This logic is linked with SampPackDsEnumerationResults() when
            // we filter the DS returned entries. 
            //
            // Actually, at here we only care about RID and AccountControl 
            //
            
            if (CurrentEntInf->Entinf.AttrBlock.attrCount == 
                    ExpectedAttrCount)
            {
                LastQualifiedEntInf = CurrentEntInf;
            }
        
        } while (NULL != NextEntInf);
        
        
        //
        // LastQualifiedEntInf points to the entry with all expected attributes. 
        // if it's NULL, it means none of the returned entries should be 
        // exposed to client. Thus Rid and LastAccountControlValue left to be 0 
        //   
        
        if (NULL != LastQualifiedEntInf)
        {
            // 
            // Get AccountControl for User Object
            //
        
            if (SampUserObjectType == ObjectType)
            {
                NTSTATUS    IgnoreStatus;
            
                //
                // Assert that the Account Control is in the right place 
                // 
            
                ASSERT(LastQualifiedEntInf->Entinf.AttrBlock.pAttr[2].attrTyp ==
                        SampDsAttrFromSamAttr(SampUserObjectType, 
                                              SAMP_FIXED_USER_ACCOUNT_CONTROL));
                                          
                // 
                // Get the account control value, need to map the DS flag to SAM 
                // account control.                                   
                //
            
                IgnoreStatus = SampFlagsToAccountControl(
                                  *((ULONG *)(LastQualifiedEntInf->Entinf.AttrBlock.
                                      pAttr[2].AttrVal.pAVal[0].pVal)), 
                                      LastAccountControlValue);
                                  
                ASSERT(NT_SUCCESS(IgnoreStatus));
            
            }
        
            // 
            // Assert that the SID is in the right place
            // DS will return us SID instead of RID 
            //  
        
            ASSERT(LastQualifiedEntInf->Entinf.AttrBlock.pAttr[0].attrTyp ==
                      SampDsAttrFromSamAttr(SampUnknownObjectType, 
                          SAMP_UNKNOWN_OBJECTSID));
                      
                      
            ReturnedSid = LastQualifiedEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal;
                      
            Status = SampSplitSid(ReturnedSid, 
                                  &DomainSid, 
                                  Rid
                                  );
        }                              
    }
    
    if (NULL != DomainSid)
    {
        MIDL_user_free(DomainSid);
    }
    
    return Status;
}



NTSTATUS
SampDoDsSearchContinuation(
    IN  SEARCHRES * SearchRes,
    IN OUT PULONG EnumerationContext,
    IN  BOOLEAN   CanEnumerateEntireDomain,
    OUT BOOLEAN * MoreEntries
    )
/*++
    Routine Description

        This routine will look if a PagedResults is present in
        the Search Res argument that is passed in. If so, then it
        will Try creating and EnumerationContext if NULL was passed
        in the handle. Else it will free the old restart structure 
        from the Enumeration Context and copy in the new one passed
        by the DS.

  Arguments:
        SearchRes - Pointer to Search Results structure returned by
                    the DS.

        EnumerationContext - Holds a pointer to the enumeration Context
                            Structure

        MoreEntries - Inidicates that more entries are present.

  Return Values:

        STATUS_SUCCESS
        STATUS_NO_MEMORY


-*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
  

    //
    // Initialize this to False
    //

    *MoreEntries = FALSE;

    //
    // Now look at the Paged Results part of Search Results
    // And create enumeration contexts as necessary.
    //

    if ((SearchRes->PagedResult.fPresent) 
         && (SearchRes->PagedResult.pRestart) 
         && CanEnumerateEntireDomain
         )
    {
        
        //
        // Search has more entries to it and therefore retrned
        // a restart structure
        //

        *MoreEntries = TRUE;

    }
    else
    {
        //
        // Search is Over, DS did not indicate that we have to come 
        // back for more entries. Free any state information that we
        // created for this search
        //

       *EnumerationContext = 0;
    }

    return Status;
        



}
 
NTSTATUS
SampBuildDsEnumerationFilter(
    IN SAMP_OBJECT_TYPE  ObjectType,
    IN ULONG             UserAccountControlFilter,
    OUT FILTER         * DsFilter,
    OUT PULONG           SamAccountTypeLo,
    OUT PULONG           SamAccountTypeHi
    )
/*++

  Routine Description:

        Builds a Filter structure for use in enumeration operations.

  Arguments:

        ObjectType - Type of SAM objects we want enumerated
        UserAcountControlFilter - Bitmaks of bits to be set in Account Control field
                                  when enumerating user objects
        DsFilter    -- Filter structure is built in here.

            NOTE This routine must be kept in sync with 
            SampFreeDsEnumerationFilter

    Return Values

        STATUS_SUCCESS
        STATUS_NO_MEMORY

--*/
{
   
    NTSTATUS    Status = STATUS_SUCCESS;
    PULONG      FilterValue = NULL;

    //
    // Initialize the defaults for the filter
    //

    DsFilter->choice = FILTER_CHOICE_ITEM;
    DsFilter->FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    DsFilter->FilterTypes.
        Item.FilTypes.ava.type = SampDsAttrFromSamAttr(
                                    SampUnknownObjectType, 
                                    SAMP_UNKNOWN_ACCOUNT_TYPE
                                    );

    DsFilter->FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(ULONG);
    
    FilterValue = MIDL_user_allocate(sizeof(ULONG));
    if (NULL==FilterValue)
    {
        Status = STATUS_NO_MEMORY;
        goto Error;
    }

    DsFilter->FilterTypes.Item.FilTypes.ava.Value.pVal =  (UCHAR *)FilterValue;

    //
    // Build the Appropriate Filter by ovewrting the defaults
    //

    switch(ObjectType)
    {
    case SampUserObjectType:

        if (UserAccountControlFilter!=0)
        {
            //
            // Filtering on Account control field  is Specified
            //
            // There are 4 cases
            //
            //     1. Client wants machine accounts
            //     2. Client wants inter-domain trust accounts
            //     3. Client wants normal user accounts
            //     4. Client wants some arbitary bits

            if ((USER_WORKSTATION_TRUST_ACCOUNT == UserAccountControlFilter)
                || (USER_SERVER_TRUST_ACCOUNT == UserAccountControlFilter))
            {
                //
                // Case1 machine accounts are needed
                //

                *SamAccountTypeLo = SAM_MACHINE_ACCOUNT;
                *SamAccountTypeHi = SAM_MACHINE_ACCOUNT;
                *FilterValue = SAM_MACHINE_ACCOUNT;
            }
            else if (USER_INTERDOMAIN_TRUST_ACCOUNT == UserAccountControlFilter)
            {
                //
                // Case2 inter-domain trust accounts
                // 
                *SamAccountTypeLo = SAM_TRUST_ACCOUNT;
                *SamAccountTypeHi = SAM_TRUST_ACCOUNT;
                *FilterValue = SAM_TRUST_ACCOUNT;
            }
            else if ((USER_NORMAL_ACCOUNT == UserAccountControlFilter) ||
                     (USER_TEMP_DUPLICATE_ACCOUNT == UserAccountControlFilter))
            {
                //
                // Case3 normal user accounts
                // 
                *SamAccountTypeLo = SAM_NORMAL_USER_ACCOUNT;
                *SamAccountTypeHi = SAM_NORMAL_USER_ACCOUNT;
                *FilterValue = SAM_NORMAL_USER_ACCOUNT;
            }
            else
            {
                     
                //
                // Case4 arbitary bits
                //

                ULONG   AccountType;
                AccountType = UserAccountControlFilter & USER_ACCOUNT_TYPE_MASK;

                if ((AccountType == USER_TEMP_DUPLICATE_ACCOUNT) ||
                    (AccountType == USER_NORMAL_ACCOUNT) ||
                    (AccountType == USER_INTERDOMAIN_TRUST_ACCOUNT) ||
                    (AccountType == USER_WORKSTATION_TRUST_ACCOUNT) ||
                    (AccountType == USER_SERVER_TRUST_ACCOUNT) )
                {
                    //
                    // Case4.1 Only one Account Type is specified.
                    // 
                    DsFilter->FilterTypes.Item.choice = FI_CHOICE_BIT_OR;
                    DsFilter->FilterTypes.
                        Item.FilTypes.ava.type = SampDsAttrFromSamAttr(
                                                    SampUserObjectType, 
                                                    SAMP_FIXED_USER_ACCOUNT_CONTROL
                                                    );

                    // Remember DS uses Flags, instead of Account Control. So Translate
                    // to Flags
                    *FilterValue = SampAccountControlToFlags(UserAccountControlFilter);
            
                    //
                    // Index ranges on Sam account type will also be set intelligently
                    // depending upon bits present in the user account control field
                    //
                    if  ((USER_WORKSTATION_TRUST_ACCOUNT & UserAccountControlFilter)
                    || (USER_SERVER_TRUST_ACCOUNT & UserAccountControlFilter))
                    {
                        *SamAccountTypeLo = SAM_MACHINE_ACCOUNT;
                        *SamAccountTypeHi = SAM_MACHINE_ACCOUNT;
                    }
                    else if (USER_INTERDOMAIN_TRUST_ACCOUNT & UserAccountControlFilter)
                    {
                        *SamAccountTypeLo = SAM_TRUST_ACCOUNT;
                        *SamAccountTypeHi = SAM_TRUST_ACCOUNT;
                    }
                    else 
                    {       
                        *SamAccountTypeLo = SAM_NORMAL_USER_ACCOUNT;
                        *SamAccountTypeHi = SAM_NORMAL_USER_ACCOUNT;
                    }
                }
                else
                {
                    //
                    // Case4.2 Multiple Account Types are desired.
                    //         Do not use DS Filter
                    // 
                    DsFilter->FilterTypes.Item.choice = FI_CHOICE_TRUE;
                    *SamAccountTypeLo = SAM_NORMAL_USER_ACCOUNT;
                    *SamAccountTypeHi = SAM_ACCOUNT_TYPE_MAX; 
                }
            }
        }
        else
        {
            //
            //   Non User Account Control filter case
            //
            *SamAccountTypeLo = SAM_NORMAL_USER_ACCOUNT;
            *SamAccountTypeHi = SAM_TRUST_ACCOUNT;
            *FilterValue = SAM_NORMAL_USER_ACCOUNT;
            DsFilter->FilterTypes.Item.choice = FI_CHOICE_GREATER_OR_EQ;
        }

        break;

    case SampGroupObjectType:
        *SamAccountTypeLo = SAM_GROUP_OBJECT;
        *SamAccountTypeHi = SAM_GROUP_OBJECT;
        *FilterValue = SAM_GROUP_OBJECT;
        break;

    case SampAliasObjectType:
        *SamAccountTypeLo = SAM_ALIAS_OBJECT;
        *SamAccountTypeHi = SAM_ALIAS_OBJECT;
        *FilterValue = SAM_ALIAS_OBJECT;
        break;

    default:
                            
        ASSERT(FALSE && "Invalid Object Type Specified");
        Status = STATUS_INTERNAL_ERROR;
    }

Error:
    return Status;

}


VOID
SampFreeDsEnumerationFilter(
    FILTER * DsFilter
    )
/*++

  Routine Description:

        This routine frees a DS Filter as built by SampBuildDsEnumerationFilter

  NOTE: This routine must be kept in sync with SampBuildDsEnumerationFilter

  Argumements:
    
      DsFilter  -- Pointer to a DS Filter Structure

  --*/
{
    //
    // For Now, Hopefully forever, our filters do not have anything hanging
    // of them
    //

    MIDL_user_free(DsFilter->FilterTypes.Item.FilTypes.ava.Value.pVal);
    DsFilter->FilterTypes.Item.FilTypes.ava.Value.pVal = NULL;

}



NTSTATUS
SampEnumerateAccountNamesRegistry(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned,
    IN BOOLEAN TrustedClient
    )

/*++

Routine Description:

    This is the worker routine used to enumerate user, group or alias accounts


    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseReadLock().



    All allocation for OUT parameters will be done using MIDL_user_allocate.



Arguments:

    ObjectType - Indicates whether users or groups are to be enumerated.

    EnumerationContext - API specific handle to allow multiple calls.  The
        caller should return this value in successive calls to retrieve
        additional information.

    Buffer - Receives a pointer to the buffer containing the
        requested information.  The information returned is
        structured as an array of SAM_ENUMERATION_INFORMATION data
        structures.  When this information is no longer needed, the
        buffer must be freed using SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    Filter - if ObjectType is users, the users can optionally be filtered
        by setting this field with bits from the AccountControlField that
        must match.  Otherwise ignored.

    CountReturned - Receives the number of entries returned.

    TrustedClient - says whether the caller is trusted or not.  If so,
        we'll ignore the SAMP_MAXIMUM_MEMORY_TO_USE restriction on data
        returns.


Return Value:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.  Entries may or may not have been
        returned from this call.  The CountReturned parameter indicates
        whether any were.

    STATUS_MORE_ENTRIES - There are more entries which may be obtained
        using successive calls to this API.  This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have access to request the data.


--*/
{
    SAMP_V1_0A_FIXED_LENGTH_USER   UserV1aFixed;
    NTSTATUS                    NtStatus, TmpStatus;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    HANDLE                      TempHandle = NULL;
    ULONG                       i, NamesToReturn = 0, MaxMemoryToUse;
    ULONG                       TotalLength,NewTotalLength;
    PSAMP_OBJECT                UserContext = NULL;
    PSAMP_ENUMERATION_ELEMENT   SampHead = NULL,
                                NextEntry = NULL,
                                NewEntry = NULL,
                                SampTail = NULL;
    BOOLEAN                     MoreNames = FALSE;
    BOOLEAN                     LengthLimitReached = FALSE;
    BOOLEAN                     FilteredName;
    PSAMPR_RID_ENUMERATION      ArrayBuffer = NULL;
    ULONG                       ArrayBufferLength;
    LARGE_INTEGER               IgnoreLastWriteTime;
    UNICODE_STRING              AccountNamesKey;
    SID_NAME_USE                IgnoreUse;

    SAMTRACE("SampEnumerateAccountNames");


    //
    // Open the registry key containing the account names
    //

    NtStatus = SampBuildAccountKeyName(
                   ObjectType,
                   &AccountNamesKey,
                   NULL
                   );

    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Now try to open this registry key so we can enumerate its
        // sub-keys
        //


        InitializeObjectAttributes(
            &ObjectAttributes,
            &AccountNamesKey,
            OBJ_CASE_INSENSITIVE,
            SampKey,
            NULL
            );

        SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

        NtStatus = RtlpNtOpenKey(
                       &TempHandle,
                       (KEY_READ),
                       &ObjectAttributes,
                       0
                       );

        if (NT_SUCCESS(NtStatus)) {

            //
            // Read names until we have exceeded the preferred maximum
            // length or we run out of names.
            //

            NamesToReturn = 0;
            SampHead      = NULL;
            SampTail      = NULL;
            MoreNames     = TRUE;

            NewTotalLength = 0;
            TotalLength    = 0;

            if ( TrustedClient ) {

                //
                // We place no restrictions on the amount of memory used
                // by a trusted client.  Rely on their
                // PreferedMaximumLength to limit us instead.
                //

                MaxMemoryToUse = 0xffffffff;

            } else {

                MaxMemoryToUse = SAMP_MAXIMUM_MEMORY_TO_USE;
            }

            while (MoreNames) {

                UNICODE_STRING SubKeyName;
                USHORT LengthRequired;

                //
                // Try reading with a DEFAULT length buffer first.
                //

                LengthRequired = 32;

                NewTotalLength = TotalLength +
                                 sizeof(UNICODE_STRING) +
                                 LengthRequired;

                //
                // Stop if SAM or user specified length limit reached
                //

                if ( ( (TotalLength != 0) &&
                       (NewTotalLength  >= PreferedMaximumLength) ) ||
                     ( NewTotalLength  > MaxMemoryToUse )
                   ) {

                    NtStatus = STATUS_SUCCESS;
                    break; // Out of while loop, MoreNames = TRUE
                }

                NtStatus = SampInitUnicodeString(&SubKeyName, LengthRequired);
                if (!NT_SUCCESS(NtStatus)) {
                    break; // Out of while loop
                }

                NtStatus = RtlpNtEnumerateSubKey(
                               TempHandle,
                               &SubKeyName,
                               *EnumerationContext,
                               &IgnoreLastWriteTime
                               );

                SampDumpRtlpNtEnumerateSubKey(&SubKeyName,
                                              EnumerationContext,
                                              IgnoreLastWriteTime);

                if (NtStatus == STATUS_BUFFER_OVERFLOW) {

                    //
                    // The subkey name is longer than our default size,
                    // Free the old buffer.
                    // Allocate the correct size buffer and read it again.
                    //

                    SampFreeUnicodeString(&SubKeyName);

                    LengthRequired = SubKeyName.Length;

                    NewTotalLength = TotalLength +
                                     sizeof(UNICODE_STRING) +
                                     LengthRequired;

                    //
                    // Stop if SAM or user specified length limit reached
                    //

                    if ( ( (TotalLength != 0) &&
                           (NewTotalLength  >= PreferedMaximumLength) ) ||
                         ( NewTotalLength  > MaxMemoryToUse )
                       ) {

                        NtStatus = STATUS_SUCCESS;
                        break; // Out of while loop, MoreNames = TRUE
                    }

                    //
                    // Try reading the name again, we should be successful.
                    //

                    NtStatus = SampInitUnicodeString(&SubKeyName, LengthRequired);
                    if (!NT_SUCCESS(NtStatus)) {
                        break; // Out of while loop
                    }

                    NtStatus = RtlpNtEnumerateSubKey(
                                   TempHandle,
                                   &SubKeyName,
                                   *EnumerationContext,
                                   &IgnoreLastWriteTime
                                   );

                    SampDumpRtlpNtEnumerateSubKey(&SubKeyName,
                                                  EnumerationContext,
                                                  IgnoreLastWriteTime);

                }


                //
                // Free up our buffer if we failed to read the key data
                //

                if (!NT_SUCCESS(NtStatus)) {

                    SampFreeUnicodeString(&SubKeyName);

                    //
                    // Map a no-more-entries status to success
                    //

                    if (NtStatus == STATUS_NO_MORE_ENTRIES) {

                        MoreNames = FALSE;
                        NtStatus  = STATUS_SUCCESS;
                    }

                    break; // Out of while loop
                }

                //
                // We've allocated the subkey and read the data into it
                // Stuff it in an enumeration element.
                //

                NewEntry = MIDL_user_allocate(sizeof(SAMP_ENUMERATION_ELEMENT));
                if (NewEntry == NULL) {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                } else {

                    *(PUNICODE_STRING)&NewEntry->Entry.Name = SubKeyName;

                    //
                    // Now get the Rid value of this named
                    // account.  We must be able to get the
                    // name or we have an internal database
                    // corruption.
                    //

                    NtStatus = SampLookupAccountRidRegistry(
                                   ObjectType,
                                   (PUNICODE_STRING)&NewEntry->Entry.Name,
                                   STATUS_INTERNAL_DB_CORRUPTION,
                                   &NewEntry->Entry.RelativeId,
                                   &IgnoreUse
                                   );

                    ASSERT(NtStatus != STATUS_INTERNAL_DB_CORRUPTION);

                    if (NT_SUCCESS(NtStatus)) {

                        FilteredName = TRUE;

                        if ( ( ObjectType == SampUserObjectType ) &&
                            ( Filter != 0 ) ) {

                            //
                            // We only want to return users with a
                            // UserAccountControl field that matches
                            // the filter passed in.  Check here.
                            //

                            NtStatus = SampCreateAccountContext(
                                           SampUserObjectType,
                                           NewEntry->Entry.RelativeId,
                                           TRUE, // Trusted client
                                           FALSE,
                                           TRUE, // Account exists
                                           &UserContext
                                           );

                            if ( NT_SUCCESS( NtStatus ) ) {

                                NtStatus = SampRetrieveUserV1aFixed(
                                               UserContext,
                                               &UserV1aFixed
                                               );

                                if ( NT_SUCCESS( NtStatus ) ) {

                                    if ( ( UserV1aFixed.UserAccountControl &
                                        Filter ) == 0 ) {

                                        FilteredName = FALSE;
                                        SampFreeUnicodeString( &SubKeyName );
                                    }
                                }

                                SampDeleteContext( UserContext );
                            }
                        }

                        *EnumerationContext += 1;

                        if ( NT_SUCCESS( NtStatus ) && ( FilteredName ) ) {

                            NamesToReturn += 1;

                            TotalLength = TotalLength + (ULONG)
                                          NewEntry->Entry.Name.MaximumLength;

                            NewEntry->Next = NULL;

                            if( SampHead == NULL ) {

                                ASSERT( SampTail == NULL );

                                SampHead = SampTail = NewEntry;
                            }
                            else {

                                //
                                // add this new entry to the list end.
                                //

                                SampTail->Next = NewEntry;
                                SampTail = NewEntry;
                            }

                        } else {

                            //
                            // Entry was filtered out, or error getting
                            // filter information.
                            //

                            MIDL_user_free( NewEntry );
                        }

                    } else {

                        //
                        // Error looking up the RID
                        //

                        MIDL_user_free( NewEntry );
                    }
                }


                //
                // Free up our subkey name
                //

                if (!NT_SUCCESS(NtStatus)) {

                    SampFreeUnicodeString(&SubKeyName);
                    break; // Out of whle loop
                }

            } // while



            TmpStatus = NtClose( TempHandle );
            ASSERT( NT_SUCCESS(TmpStatus) );

        }


        SampFreeUnicodeString( &AccountNamesKey );
    }




    if ( NT_SUCCESS(NtStatus) ) {




        //
        // If we are returning the last of the names, then change our
        // enumeration context so that it starts at the beginning again.
        //

        if (!( (NtStatus == STATUS_SUCCESS) && (MoreNames == FALSE))) {

            NtStatus = STATUS_MORE_ENTRIES;
        }



        //
        // Set the number of names being returned
        //

        (*CountReturned) = NamesToReturn;


        //
        // Build a return buffer containing an array of the
        // SAM_ENUMERATION_INFORMATIONs pointed to by another
        // buffer containing the number of elements in that
        // array.
        //

        (*Buffer) = MIDL_user_allocate( sizeof(SAMPR_ENUMERATION_BUFFER) );

        if ( (*Buffer) == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        } else {

            (*Buffer)->EntriesRead = (*CountReturned);

            ArrayBufferLength = sizeof( SAM_RID_ENUMERATION ) *
                                 (*CountReturned);
            ArrayBuffer  = MIDL_user_allocate( ArrayBufferLength );
            (*Buffer)->Buffer = ArrayBuffer;

            if ( ArrayBuffer == NULL) {

                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                MIDL_user_free( (*Buffer) );

            }   else {

                //
                // Walk the list of return entries, copying
                // them into the return buffer
                //

                NextEntry = SampHead;
                i = 0;
                while (NextEntry != NULL) {

                    NewEntry = NextEntry;
                    NextEntry = NewEntry->Next;

                    ArrayBuffer[i] = NewEntry->Entry;
                    i += 1;

                    MIDL_user_free( NewEntry );
                }

            }

        }



    }

    if ( !NT_SUCCESS(NtStatus) ) {

        //
        // Free the memory we've allocated
        //

        NextEntry = SampHead;
        while (NextEntry != NULL) {

            NewEntry = NextEntry;
            NextEntry = NewEntry->Next;

            if (NewEntry->Entry.Name.Buffer != NULL ) MIDL_user_free( NewEntry->Entry.Name.Buffer );
            MIDL_user_free( NewEntry );
        }

        (*EnumerationContext) = 0;
        (*CountReturned)      = 0;
        (*Buffer)             = NULL;

    }

    return(NtStatus);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\gclookup.c ===
/*++

Copyright (C) 1996 Microsoft Corporation

Module Name:

    gclookup.c

Abstract:
    
    Contains routines to perform GC lookups for clients within samsrv.dll's
    process space.
    
Author:
    
    ColinBr

Revision History


--*/

#include <winerror.h>
#include <stdlib.h>
#include <samsrvp.h>
#include <ntdsa.h>
#include <dslayer.h>
#include <mappings.h>
#include <objids.h>
#include <filtypes.h>
#include <dsdsply.h>
#include <fileno.h>
#include <dsconfig.h>
#include <mdlocal.h>
#include <malloc.h>
#include <errno.h>
#include <mdcodes.h>


VOID
SampSplitSamAccountName(
    IN  UNICODE_STRING *AccountName,
    OUT UNICODE_STRING *DomainName,
    OUT UNICODE_STRING *UserName
    )
/*++

Routine Description

    This routine separates Account name into a Domain and User portion.
    DomainName and UserName are not allocated -- they point to the buffer
    in AccountName.         
    
    The Domain is consider the part before the first L'\\'.  If this character
    doesn't exist, then UserName == AccountName
    

Parameters:

    AccountName -- the name to parse
    
    DomainName  -- the domain name portion
    
    UserName    -- the user name portion

Return Values:

    None.

--*/
{
    USHORT i;
    USHORT Length;

    ASSERT( AccountName );
    ASSERT( DomainName );
    ASSERT( UserName );

    Length = (AccountName->Length/sizeof(WCHAR));

    for (i = 0; i < Length; i++ ) {
        if ( L'\\' == AccountName->Buffer[i] ) {
            break;
        }
    }

    if ( i < Length ) {
        UserName->Buffer = &AccountName->Buffer[i+1];
        UserName->Length = UserName->MaximumLength = (AccountName->Length - (i+1));
        DomainName->Buffer = AccountName->Buffer;
        DomainName->Length = DomainName->MaximumLength = i;
    } else {
        RtlCopyMemory( UserName, AccountName, sizeof(UNICODE_STRING));
        RtlInitUnicodeString( DomainName, NULL );
    }

    return;

}

SID_NAME_USE
SampAccountTypeToNameUse(
    ULONG AccountType 
    )
{
    switch ( AccountType ) {
        
        case SAM_DOMAIN_OBJECT:
            return SidTypeDomain;

        case SAM_NON_SECURITY_GROUP_OBJECT:
        case SAM_GROUP_OBJECT:
            return SidTypeGroup;

        case SAM_NON_SECURITY_ALIAS_OBJECT:
        case SAM_ALIAS_OBJECT:
        case SAM_APP_BASIC_GROUP:
        case SAM_APP_QUERY_GROUP:
            return SidTypeAlias;

        case SAM_USER_OBJECT:
        case SAM_MACHINE_ACCOUNT:
        case SAM_TRUST_ACCOUNT:
            return SidTypeUser;

        default:

            ASSERT( FALSE && "Unexpected Account Type!" );
            return SidTypeUnknown;
    }

    ASSERT( FALSE && "Unexpected control flow" );
    return SidTypeUnknown;
}

BOOLEAN
SampSidWasFoundSimply(
    ULONG status
    )
//
// status is return code from the name cracking API.  see ntdsapi.h
//
{
    switch (status) {
        case DS_NAME_ERROR_IS_SID_USER:
        case DS_NAME_ERROR_IS_SID_GROUP:
        case DS_NAME_ERROR_IS_SID_ALIAS:
        case DS_NAME_ERROR_IS_SID_UNKNOWN:
            return TRUE;
    }

    return FALSE;
}
    
BOOLEAN
SampSidWasFoundByHistory(
    ULONG status
    )
//
// status is return code from the name cracking API.  see ntdsapi.h
//
{
    switch (status) {
        case DS_NAME_ERROR_IS_SID_HISTORY_USER:
        case DS_NAME_ERROR_IS_SID_HISTORY_GROUP:
        case DS_NAME_ERROR_IS_SID_HISTORY_ALIAS:
        case DS_NAME_ERROR_IS_SID_HISTORY_UNKNOWN:
            return TRUE;
    }

    return FALSE;
}

NTSTATUS
SamIGCLookupSids(
    IN ULONG            cSids,
    IN PSID            *SidArray,
    IN ULONG            Options,
    OUT ULONG           *Flags,
    OUT SID_NAME_USE   *SidNameUse,
    OUT PSAMPR_RETURNED_USTRING_ARRAY Names
    )
/*++

Routine Description

    This routine, exported to in-proc clients, translates a list of sids
    into sam account names as well as find thier sam object type (user, alias ... )


Parameters:

    cSids    -- the number of sids
    
    SidArray -- the array of sids
    
    Options  -- flags to control this functions behavoir.  Currently only
                SAMP_LOOKUP_BY_SID_HISTORY is supported.
    
    SidNameUse -- a preallocated array to be filled with each sid's use. 
                  SidTypeUnknown is used if the sid can't be resolved
    Names -- a preallocated array of empty unicode strings to be filled in
             The string is set to blank if the name could not be resolved.                  

Return Values:

    STATUS_SUCCESS
    
    STATUS_DS_GC_NOT_AVAILABLE: the GC was not available, no names were translated
    
    Standard resource errors    
    
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    DsErr = 0;

    PDS_NAME_RESULTW Results = NULL;

    BOOL     fKillThreadState = FALSE;

    BOOLEAN  fDoSidHistory = (Options & SAMP_LOOKUP_BY_SID_HISTORY) ? TRUE : FALSE;

    ULONG i, j;


    //
    // We should not be called in registry mode or if we have a transaction
    //
    ASSERT( SampUseDsData );

    // Parameter check
    ASSERT( SidNameUse );
    ASSERT( Names );

    //
    // Start a thread state if need be
    //
    if ( !THQuery() ) {
        
        if ( THCreate( CALLERTYPE_SAM ) ) {

            NtStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        fKillThreadState = TRUE;
    }
    // We should not be in a transaction
    ASSERT(!SampExistsDsTransaction());

    // Init the out params
    for (i = 0; i < cSids; i++ ) {
        SidNameUse[i] = SidTypeUnknown;
        Flags[i] = 0;
    }
    Names->Count = 0;
    Names->Element = (PSID) MIDL_user_allocate( sizeof(RPC_UNICODE_STRING) * cSids );
    if ( !Names->Element ) {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    Names->Count = cSids;
    RtlZeroMemory( Names->Element, sizeof(RPC_UNICODE_STRING) * cSids );

    //
    // Hit the GC if possible
    //
    DsErr = SampGCLookupSids(cSids,
                             SidArray,
                            &Results);

    if ( 0 != DsErr )
    {
        //
        // Assume any error implies a GC could not be reached
        //
        NtStatus = STATUS_DS_GC_NOT_AVAILABLE;
        goto Cleanup;
    }
    ASSERT( cSids = Results->cItems );

    //
    // Now interpret the results
    //
    for ( i = 0; i < cSids; i++ ) {

        //
        // See if the sid was resolved
        //
        if (  SampSidWasFoundSimply( Results->rItems[i].status ) 
          || (fDoSidHistory
          && SampSidWasFoundByHistory( Results->rItems[i].status ) ) ) {

            ULONG Length;
            WCHAR *Name;

            //
            // Set the sid name use
            //
            switch ( Results->rItems[i].status ) {
                
                case DS_NAME_ERROR_IS_SID_USER:
                case DS_NAME_ERROR_IS_SID_HISTORY_USER:
                    SidNameUse[i] = SidTypeUser;
                    break;
                case DS_NAME_ERROR_IS_SID_GROUP:
                case DS_NAME_ERROR_IS_SID_HISTORY_GROUP:
                    SidNameUse[i] = SidTypeGroup;
                    break;
                case DS_NAME_ERROR_IS_SID_ALIAS:
                case DS_NAME_ERROR_IS_SID_HISTORY_ALIAS:
                    SidNameUse[i] = SidTypeAlias;
                    break;
                default:
                    SidNameUse[i] = SidTypeUnknown;
                    break;
            }

            if ( SampSidWasFoundByHistory( Results->rItems[i].status ) )
            {
                Flags[i] |= SAMP_FOUND_BY_SID_HISTORY;
            }

            //
            // Set up the name
            //
            Length = (wcslen( Results->rItems[i].pName ) + 1) * sizeof(WCHAR);
            Name = (WCHAR*) MIDL_user_allocate( Length );
            if ( !Name ) {
                NtStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }
            wcscpy( Name, Results->rItems[i].pName );
            RtlInitUnicodeString( (UNICODE_STRING *)&Names->Element[i], Name );

         } else if ( (Results->rItems[i].status == DS_NAME_ERROR_TRUST_REFERRAL)
                  && (Results->rItems[i].pDomain != NULL) ) {
             //
             // This is a routing hint indicating that the SID belongs to
             // a cross forest domain.
             //
             Flags[i] |= SAMP_FOUND_XFOREST_REF;
         }
    }

Cleanup:

    if ( !NT_SUCCESS( NtStatus ) ) {

        // Release all allocated memory
        SamIFree_SAMPR_RETURNED_USTRING_ARRAY( Names );
        
        // reset out params just to be clean
        for (i = 0; i < cSids; i++ ) {
            SidNameUse[i] = SidTypeUnknown;
        }
        RtlZeroMemory( Names, sizeof(SAMPR_RETURNED_USTRING_ARRAY) );
    }

    if ( fKillThreadState ) {

        THDestroy();
    }



    return NtStatus;
}

NTSTATUS
SamIGCLookupNames(
    IN ULONG           cNames,
    IN PUNICODE_STRING Names,
    IN ULONG           Options,
    IN OUT ULONG         *Flags,
    OUT SID_NAME_USE  *SidNameUse,
    OUT PSAMPR_PSID_ARRAY *pSidArray
    )
/*++

Routine Description

    This routine, exported to in-proc clients, translates a list of 
    names into sids as well as find thier sam object type (user, alias ... )

Parameters:

    cNames    -- the number of names
    Names     -- the array of names
    
    Options   -- flags to indicate what names to include. Currently only
                 SAMP_LOOKUP_BY_UPN supported
                 
    Flags     -- Flags to indicate to the caller how the name was found.
                 SAMP_FOUND_BY_SAM_ACCOUNT_NAME -- the name passed in is
                                                   a sam account name
                 SAMP_FOUND_XFOREST_REF -- the name belongs to an trusted
                                            forest
                 
                 Note: this array is allocated by the caller.                 
                  
    
    SidNameUse -- a preallocated array to be filled with each sid's use. 
                  SidTypeUnknown is used if the sid can't be resolved
                  
    SidArray -- a pointer to the structure to hold the sids.  While usual SAM
                practice would have this just be a pointer rather than 
                a pointer to a pointer, the exported "free" routines for SAM
                don't handle this, so we'll make it a pointer to a pointer.
                
Return Values:

    STATUS_SUCCESS
    
    STATUS_DS_GC_NOT_AVAILABLE: the GC was not available, no names were translated
    
    Standard resource errors    
    
--*/
{
    ULONG    DsErr = 0;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    ENTINF   *ReturnedEntInf = 0;

    BOOL     fKillThreadState = FALSE;

    ULONG i, j;

    DWORD err;

    PSAMPR_PSID_ARRAY SidArray = NULL;

    UNICODE_STRING ReturnedName;
    UNICODE_STRING DomainName1, DomainName2;
    UNICODE_STRING UserName1, UserName2;

    //
    // We should not be called in registry mode or if we have a transaction
    //
    ASSERT( SampUseDsData );

    // Parameter check
    ASSERT( SidNameUse );
    ASSERT( Names );
    ASSERT( pSidArray );
    ASSERT( Flags );

    //
    // Start a thread state if need be
    //
    if ( !THQuery() ) {
        
        if ( THCreate( CALLERTYPE_SAM ) ) {
            NtStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        fKillThreadState = TRUE;
    }
    ASSERT(!SampExistsDsTransaction());

    // Init the out params
    for (i = 0; i < cNames; i++ ) {
        SidNameUse[i] = SidTypeUnknown;
    }
    *pSidArray = NULL;
    SidArray = MIDL_user_allocate( sizeof( SAMPR_PSID_ARRAY ) );
    if ( !SidArray ) {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    *pSidArray = SidArray;

    SidArray->Count = 0;
    SidArray->Sids = MIDL_user_allocate( cNames * sizeof( SAMPR_SID_INFORMATION ) );
    if ( !SidArray->Sids ) {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    SidArray->Count = cNames;
    RtlZeroMemory( SidArray->Sids, cNames * sizeof( SAMPR_SID_INFORMATION ) );


    RtlZeroMemory( Flags, cNames * sizeof(ULONG) );


    //
    // Hit the GC if possible
    //
    DsErr = SampGCLookupNames(cNames,
                              Names,
                             &ReturnedEntInf);

    if ( 0 != DsErr )
    {
        //
        // Assume any error implies a GC could not be reached
        //
        NtStatus = STATUS_DS_GC_NOT_AVAILABLE;
        goto Cleanup;
    }


    //
    // Now interpret the results
    //
    for ( i = 0; i < cNames; i++ ) {
        
        PSID   Sid = NULL;
        DWORD  AccountType = 0;
        BOOLEAN fAccountTypeFound = FALSE;
        ULONG  Length;
        ENTINF *pEntInf = &ReturnedEntInf[i];
        WCHAR  *AccountName = NULL;

        RtlZeroMemory(  &ReturnedName, sizeof(ReturnedName) );

        //
        // If the object could not be resolved then no attributes
        // we be set in the attr block, so we will fall through
        // and the sidnameuse will remain "Unknown"

        //
        // Iterate through the ATTRBLOCK
        //
        for (j = 0; j < pEntInf->AttrBlock.attrCount; j++ ) {

            ATTR *pAttr;

            pAttr = &pEntInf->AttrBlock.pAttr[j];

            switch ( pAttr->attrTyp ) {
                
                case ATT_OBJECT_SID:

                    ASSERT( 1 == pAttr->AttrVal.valCount );
                    ASSERT( NULL != pAttr->AttrVal.pAVal[0].pVal  );
                    Sid = (WCHAR*) pAttr->AttrVal.pAVal[0].pVal;
                    break;

                case ATT_SAM_ACCOUNT_TYPE:

                    ASSERT( 1 == pAttr->AttrVal.valCount);
                    AccountType = *((DWORD*) pAttr->AttrVal.pAVal[0].pVal);
                    fAccountTypeFound = TRUE;
                    break;

                case ATT_SAM_ACCOUNT_NAME:

                    ASSERT( 1 == pAttr->AttrVal.valCount);
                    AccountName = (WCHAR*) pAttr->AttrVal.pAVal[0].pVal;

                    ReturnedName.Buffer = (WCHAR*) pAttr->AttrVal.pAVal[0].pVal;
                    ReturnedName.Length = ReturnedName.MaximumLength = (USHORT)pAttr->AttrVal.pAVal[0].valLen;
                    break;

            case FIXED_ATT_EX_FOREST:

                    //
                    // This indicates that the name belongs to a cross
                    // forest trust
                    //
                    Flags[i] |= SAMP_FOUND_XFOREST_REF;
                    break;

                default:
                
                    ASSERT( FALSE && !"Unexpected switch statement" );
            }
        }
            
        if (   Sid 
            && fAccountTypeFound ) {

            if ( AccountName ) {

                ASSERT( ReturnedName.Length > 0 );

                SampSplitSamAccountName( &Names[i], &DomainName1, &UserName1 );
                SampSplitSamAccountName( &ReturnedName, &DomainName2, &UserName2 );
                if ((CSTR_EQUAL == CompareString(DS_DEFAULT_LOCALE,
                                                 DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                                 UserName1.Buffer,
                                                 UserName1.Length/sizeof(WCHAR),
                                                 UserName2.Buffer,
                                                 UserName2.Length/sizeof(WCHAR) ))){
    
                    //
                    // The user name portion is the same we can use this value
                    // to cache
                    //
                    Flags[i] |= SAMP_FOUND_BY_SAM_ACCOUNT_NAME;
    
                }

            }

            //
            // Ok, we found something and we can use it
            //
            Length = RtlLengthSid( Sid );
            SidArray->Sids[i].SidPointer = (PSID) midl_user_allocate( Length );
            if ( !SidArray->Sids[i].SidPointer ) {
                NtStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }
            RtlCopySid( Length, SidArray->Sids[i].SidPointer, Sid );

            SidNameUse[i] = SampAccountTypeToNameUse( AccountType );

        }

    }

Cleanup:

    if ( !NT_SUCCESS( NtStatus ) ) {

        // Release any allocated memory 
        SamIFreeSidArray( *pSidArray );
        *pSidArray = NULL;

        // Reset parameters to be clean
        for (i = 0; i < cNames; i++ ) {
            SidNameUse[i] = SidTypeUnknown;
        }

    }

    if ( ReturnedEntInf ) {
        
        THFree( ReturnedEntInf );
    }

    if ( fKillThreadState ) {

        THDestroy();
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\gentab2.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gentab2.c

Abstract:

    GenericTable2 package

    Generic table services for maintaining data sets.  The primary
    characteristic of this generic table package is that it maintains
    a relatively balanced tree, which provides for good (O(log(N))
    performance.
                                                                      
    The GenericTable2 routines are similar to the original 
    GenericTable routines provided by Gary Kimure except that the 
    GenericTable2 routines use a 2-3-tree rather than a splay tree.
    2-3-trees are described in "Data Structures And Algorithms", by 
    Aho, Hopcroft, and Ullman, published by Addison Wesley Publishing 
    Company.

    Another difference between this package and the original Generic 
    Table package is that this one references element buffers that are 
    inserted rather than copying the data (as in the orignal package).  
    This characteristic is nice if you have to sort large numbers of 
    records by multiple keys 
                                                                        
    2-3-trees have better characteristics than splay-trees when the     
    data being maintained is not random.  For example, maintaining a    
    dictionary, in which the data quite often is provided in an orderly 
    manner, is an ideal application for 2-3-trees.                       
                                                                        
    This package does not support the retrieval of elements in inserted 
    order that is supported in the original Generic Table package.      
                                                                        
    Differences between the algorithm outlined in Aho, et al and what   
    is coded here are:                                                  

        1) I provide an additional means of obtaining the elements
           in the tree in sorted order (for enumeration performance).
           I keep a linked list of elements in addition to the tree
           structure.

        1) Aho et al point directly to elements in the tree from
           nodes in the tree.  In order to allow me to keep the linked
           list mentioned in (1), I have a separate leaf element pointed
           to from nodes which point to the element values.  This leaf
           component has the LIST_ENTRY structures used to link the
           elements together.

        3) Aho et al's algorithms ignore the fact that they may fail
           to allocate memory (that is, they assume the Pascal "new"
           function always succeeds).  This package assumes that
           any memory allocation may fail and will always leave the
           tree in a valid form (although an insertion may fail in
           this case).


Author:

    Jim Kelly (JimK)  20-Jan-1994

Environment:

    Run time library, user or kernel mode.

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


#include <nt.h>
#include <ntrtl.h>
#include <samsrvp.h>




//////////////////////////////////////////////////////////////////////////
//                                                                      //
//  defines ...                                                         //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

//
// The following define controls the diagnostic capabilities that     
// are built into this package.
//

#if DBG
#define GTBP_DIAGNOSTICS 1
#endif // DBG


//
// These definitions are useful diagnostics aids
//

#if GTBP_DIAGNOSTICS

//
// defining the following symbol causes significant amounts of
// development assistance code to be built
//

//#define GTBP_DEVELOPER_BUILD 1

//
// Global Diagnostics Flags
//

ULONG GtbpGlobalFlag;

//
// Test for diagnostics enabled
//

#define IF_GTBP_GLOBAL( FlagName ) \
    if (GtbpGlobalFlag & (GTBP_DIAG_##FlagName))

//
// Diagnostics print statement
//

#define GtbpDiagPrint( FlagName, _Text_ )                               \
    IF_GTBP_GLOBAL( FlagName )                                          \
        DbgPrint _Text_
    

#else

//
// No diagnostics included in build
//

//
// Test for diagnostics enabled
//

#define IF_GTBP_GLOBAL( FlagName ) if (FALSE)


//
// Diagnostics print statement (nothing)
//

#define GtbpDiagPrint( FlagName, Text )     ;


#endif // GTBP_DIAGNOSTICS

//
// The following flags enable or disable various diagnostic
// capabilities within SAM.  These flags are set in
// GtbpGlobalFlag.
//
//      INSERT - print diagnostic messages related to insertion
//          operations.
//
//      DELETION - print diagnostic messages related to deletion
//          operations.
//
//      LEAF_AND_NODE_ALLOC - print diagnostic messages related
//          to allocation of leaf and node objects for insertion
//          operations.
//
//      ENUMERATE - print diagnostic messages related to enumeration
//          operations.  This includes getting restart keys.
//
//      LOOKUP - print diagnostic messages related to element lookup
//          operations.
//
//      COLLISIONS - print diagnostic messages indicating when collisions
//          occur on insert.
//
//      VALIDATE - print diagnostic messages to be printed during table
//          validations.
//

#define GTBP_DIAG_INSERT                    ((ULONG) 0x00000001L)
#define GTBP_DIAG_DELETION                  ((ULONG) 0x00000002L)
#define GTBP_DIAG_LEAF_AND_NODE_ALLOC       ((ULONG) 0x00000004L)
#define GTBP_DIAG_ENUMERATE                 ((ULONG) 0X00000008L)
#define GTBP_DIAG_LOOKUP                    ((ULONG) 0X00000010L)
#define GTBP_DIAG_COLLISIONS                ((ULONG) 0X00000020L)
#define GTBP_DIAG_VALIDATE                  ((ULONG) 0X00000040L)


//////////////////////////////////////////////////////////////////////////
//                                                                      //
//  Macros ...                                                          //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

//
//  GtbpChildrenAreLeaves(
//      IN GTB_TWO_THREE_NODE  N
//      )
//  Returns TRUE if children of N are leaves.
//  Otherwise returns FALSE.
//

#define GtbpChildrenAreLeaves( N ) ((((N)->Control) & GTB_CHILDREN_ARE_LEAVES) != 0)


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private structures and definitions                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// GTB_TWO_THREE_NODE.Control field values
//

#define GTB_CHILDREN_ARE_LEAVES           (0x00000001)



//////////////////////////////////////////////////////////////////////////
//                                                                      //
//  Internal Routine Definitions ...                                    //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
GtbpDeleteFromSubTree (
    IN  PRTL_GENERIC_TABLE2         Table,
    IN  PGTB_TWO_THREE_NODE         Node,
    IN  PVOID                       Element,
    OUT PGTB_TWO_THREE_LEAF         *LowOfNode,
    OUT BOOLEAN                     *ElementDeleted,
    OUT BOOLEAN                     *OnlyOneChildLeft
    );

BOOLEAN
GtbpInsertIntoSubTree (
    PRTL_GENERIC_TABLE2             Table,
    IN  PGTB_TWO_THREE_NODE         Node,
    IN  BOOLEAN                     NodeIsLeaf,
    IN  PVOID                       Element,
    IN  ULONG                       SplitCount,
    IN  PVOID                       *FoundElement,
    OUT PGTB_TWO_THREE_NODE         *ExtraNode,
    OUT PGTB_TWO_THREE_LEAF         *LowLeaf,
    OUT PLIST_ENTRY                 *AllocatedNodes
    );

ULONG
GtbpNumberOfChildren(
    IN  PGTB_TWO_THREE_NODE         Node
    );

VOID
GtbpGetSubTreeOfElement(
    IN  PRTL_GENERIC_TABLE2         Table,
    IN  PGTB_TWO_THREE_NODE         Node,
    IN  PVOID                       Element,
    OUT PGTB_TWO_THREE_NODE         *SubTreeNode,
    OUT ULONG                       *SubTree
    );

VOID
GtbpCoalesceChildren(
    IN  PRTL_GENERIC_TABLE2         Table,
    IN  PGTB_TWO_THREE_NODE         Node,
    IN  ULONG                       SubTree,
    OUT BOOLEAN                     *OnlyOneChildLeft
    );

VOID
GtbpSplitNode(
    IN  PGTB_TWO_THREE_NODE         Node,
    IN  PGTB_TWO_THREE_NODE         NodePassedBack,
    IN  PGTB_TWO_THREE_LEAF         LowPassedBack,
    IN  ULONG                       SubTree,
    IN  PLIST_ENTRY                 AllocatedNodes,
    OUT PGTB_TWO_THREE_NODE         *NewNode,
    OUT PGTB_TWO_THREE_LEAF         *LowLeaf
    );

PGTB_TWO_THREE_LEAF
GtbpAllocateLeafAndNodes(
    IN  PRTL_GENERIC_TABLE2     Table,
    IN  ULONG                   SplitCount,
    OUT PLIST_ENTRY             *AllocatedNodes
    );

PGTB_TWO_THREE_NODE
GtbpGetNextAllocatedNode(
    IN PLIST_ENTRY      AllocatedNodes
    );




//////////////////////////////////////////////////////////////////////////
//                                                                      //
//  Exported Services ...                                               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


VOID
RtlInitializeGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PRTL_GENERIC_2_COMPARE_ROUTINE  CompareRoutine,
    PRTL_GENERIC_2_ALLOCATE_ROUTINE AllocateRoutine,
    PRTL_GENERIC_2_FREE_ROUTINE     FreeRoutine
    )

/*++

Routine Description:

    Initialize the table by initializing the corresponding
    (empty) two-three tree and the extra linked-list we have
    going through the tree.

    Two-three trees are described in "Data Structures And Algorithms"
    by Alfred Aho, John Hopcroft, and Jeffrey Ullman (Addison Wesley
    publishing).

Arguments:

    Table - Pointer to the generic table to be initialized.  This gets
        typecast internally, but we export this so that we don't have to
        invent another type of generic table for users to worry about.

    CompareRoutine - User routine to be used to compare to keys in the
                     table.

    AllocateRoutine - Used by the table package to allocate memory
        when necessary.

    FreeRoutine - Used by the table package to free memory previously
        allocated using the AllocateRoutine.

Return Value:

    None.

--*/
{


    //
    // Tree is empty.
    //

    Table->Root = NULL;
    Table->ElementCount = 0;

    Table->Compare  = CompareRoutine;
    Table->Allocate = AllocateRoutine;
    Table->Free     = FreeRoutine;

    InitializeListHead(&Table->SortOrderHead);

    return;
}


PVOID
RtlInsertElementGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element,
    PBOOLEAN NewElement
    )

/*++

Routine Description:


    This function inserts an element into the table.

    If the element is successfully inserted into the table
    then NewElement will be returned as TRUE and the function will
    return the value passed via the Element parameter.

    If the element already exists in the table, then NewElement
    is returned as FALSE and the function will return the value
    of the element already found in the table.


    The caller is responsible for ensuring that an element referenced by
    the table is not modified or deallocated while it is still in the
    table.

Arguments:

    Table - Pointer to the generic table to which the Element is to
        be inserted.

    Element - Pointer to the element to be entered into the table.

    NewElement - Receives TRUE if the element was added to the table.
        Receives FALSE if the element collided with an element already
        in the table (that is, an element with the same comparison
        value already exists in the table).


Return Value:

    Pointer to the element inserted, or the element that was already
    in the table with the same value as the one being inserted.

    If NULL is returned, then memory could not be allocated to add
    the new element.

--*/
{

    RTL_GENERIC_COMPARE_RESULTS
        CompareResult;


    PGTB_TWO_THREE_NODE
        NodePassedBack,
        NewNode,
        SubTreeNode,
        Node;

    PGTB_TWO_THREE_LEAF
        Leaf,
        LowLeaf,
        LowPassedBack;

    ULONG
        SplitCount,
        SubTree;

    PVOID
        FoundElement;

    PLIST_ENTRY
        AllocatedNodes;

    BOOLEAN
        NodeIsLeaf;


    GtbpDiagPrint( INSERT,
                 ("GTB: Inserting Element 0x%lx into table 0x%lx\n", Element, Table));

    //
    // Except for errors, one of the following will occur:
    //
    //  o There is no root ==>
    //      1) Allocate a root and leaf
    //      2) put the element in the leaf and make it the
    //      3) first child of the root
    //
    //  o There is a root with only one child ==>
    //      1) If the elements are equal, return without new entry
    //      2) If the new element is less, move child 1 to 2 and
    //         make new leaf child 1.
    //      3) Otherwise element is greater, allocate it a leaf
    //         and make it child 2.
    //
    //  o There is a root with at least two children ==>
    //      1) If there are already 3 children, then set split
    //         count = 2, otherwise set it to 1.
    //      2) Call normal insertion routine to insert into
    //         appropriate SubTree.
    //      3) If there is a split needed, then establish
    //         a newly allocated node as the root, and make it the
    //         parent of the current node.  Then use the normal
    //         split routine.
    //          





    //
    // If empty, then create a root node and add the element.
    //

    if (Table->ElementCount == 0) {

        GtbpDiagPrint( INSERT, 
                 ("GTB:   Table empty.  Creating root node.\n"));

        NewNode = (PGTB_TWO_THREE_NODE)
                  ((*Table->Allocate)( sizeof(GTB_TWO_THREE_NODE) ));
        if (NewNode == NULL) {
            GtbpDiagPrint(INSERT,
                 ("GTB:   Couldn't allocate memory for root node.\n"));
                 (*NewElement) = FALSE;
                 return( NULL );
        }
        GtbpDiagPrint( INSERT, 
                 ("GTB:   New root node is: 0x%lx\n", NewNode));


        NewNode->ParentNode  = NULL;  // Doesn't have a parent.  Special case.
        NewNode->Control     = GTB_CHILDREN_ARE_LEAVES;
        NewNode->SecondChild = NULL;
        NewNode->ThirdChild  = NULL;

        //
        // Allocate a leaf and put the element in it.
        //

        Leaf = (PGTB_TWO_THREE_LEAF)
               ((*Table->Allocate)( sizeof(GTB_TWO_THREE_LEAF) ));

        if (Leaf == NULL) {
            GtbpDiagPrint(INSERT,
                ("GTB:   Couldn't allocate memory for leaf.\n"));
            ((*Table->Free)( NewNode ));
            (*NewElement) = FALSE;
            return( NULL );
        }


        InsertHeadList( &Table->SortOrderHead, &Leaf->SortOrderEntry );
        Leaf->Element = Element;
        NewNode->FirstChild = (PGTB_TWO_THREE_NODE)Leaf;

        Table->Root = NewNode;
        Table->ElementCount++;
        ASSERT(Table->ElementCount == 1);
        (*NewElement) = TRUE;
        return(Element);
    }


    //
    // We have a root with at least one child in it.
    //

    if (Table->Root->SecondChild == NULL) {

        //
        // The root doesn't have two children.
        // If it didn't have any children it would have been
        // deallocated.  So, it must have a degenerate case of
        // only one child.
        //

        Leaf = (PGTB_TWO_THREE_LEAF)Table->Root->FirstChild;
        CompareResult = (*Table->Compare)( Element, Leaf->Element );

        if (CompareResult == GenericEqual) {
            (*NewElement) = FALSE;

            GtbpDiagPrint( COLLISIONS,
                           ("GTB: Insertion attempt resulted in collision.\n"
                            "     Element NOT being inserted.\n"
                            "     Elements in table: %d\n",
                            Table->ElementCount));
            return( Leaf->Element );
        }


        //
        // Need a new leaf
        //

        Leaf = (PGTB_TWO_THREE_LEAF)
               ((*Table->Allocate)( sizeof(GTB_TWO_THREE_LEAF) ));

        if (Leaf == NULL) {
            GtbpDiagPrint(INSERT,
                ("GTB:   Couldn't allocate memory for leaf.\n"));
            (*NewElement) = FALSE;
            return( NULL );
        }
        Leaf->Element = Element;

        //
        // it is either the first child or second
        //

        if (CompareResult == GenericLessThan) {

            //
            // Move the first child to be the second child and make
            // a new first child leaf for the new element.
            //
            
            InsertHeadList( &Table->SortOrderHead, &Leaf->SortOrderEntry );
        


            Table->Root->SecondChild = Table->Root->FirstChild;
            Table->Root->LowOfSecond = (PGTB_TWO_THREE_LEAF)
                                       Table->Root->SecondChild;  //it is the leaf

            Table->Root->FirstChild = (PGTB_TWO_THREE_NODE)Leaf;


        } else {

            //
            // new element is greater than existing element.
            // make it the second child.
            //

            InsertTailList( &Table->SortOrderHead, &Leaf->SortOrderEntry );
            
            Table->Root->SecondChild = (PGTB_TWO_THREE_NODE)Leaf;
            Table->Root->LowOfSecond = Leaf;

        }

        Table->ElementCount++;
        ASSERT(Table->ElementCount == 2);

        (*NewElement) = TRUE;                   //Set return value
        return(Element);
            
    }

    //
    // Normal insertion.
    // If we get an ExtraNode coming back, then we may have to
    // split the root.  Normally for a node with three children
    // you would need to allow for one node in a split.  However,
    // we will need a new root as well, so allow for two new nodes.
    //

    if (Table->Root->ThirdChild != NULL) {
        SplitCount = 2;
    } else {
        SplitCount = 0;
    }

    GtbpGetSubTreeOfElement( Table, Table->Root, Element, &SubTreeNode, &SubTree);
    NodeIsLeaf = GtbpChildrenAreLeaves(Table->Root);

    (*NewElement) = GtbpInsertIntoSubTree ( Table,
                                            SubTreeNode,
                                            NodeIsLeaf,
                                            Element,
                                            SplitCount,
                                            &FoundElement,
                                            &NodePassedBack,
                                            &LowPassedBack,
                                            &AllocatedNodes
                                            );

    //
    // One of several things could have happened:
    //
    //      1) We didn't have enough memory to add the new element.
    //         In this case we are done and simply return.
    //
    //      2) The element was added, and no-rearrangement to this
    //         node is needed.  In this case we are done and simply
    //         return.
    //
    //      3) The element was added and caused a node to be pushed
    //         out of the SubTree.  We have some work to do.
    //


    if ( (FoundElement == NULL)  ||         // Insufficient memory, or
         (NodePassedBack == NULL)  ) {      // no work for this node

        return(FoundElement);
    }


    Node = Table->Root;
    if (Node->ThirdChild == NULL) {

        //
        // Root doesn't yet have a third child, so use it.
        // This might require shuffling the second child to the
        // be the third child.
        //

        if (SubTree == 2) {

            //
            // NodePassedBack fell out of second SubTree and root does't 
            // have a third SubTree.  Make that node the third SubTree.
            //

            Node->ThirdChild = NodePassedBack;
            Node->LowOfThird = LowPassedBack;

        } else {

            //
            // Node fell out of first SubTree.
            // Make the second SubTree the third SubTree and
            // then make the passed back node the second SubTree.
            //

            ASSERT(SubTree == 1);

            Node->ThirdChild  = Node->SecondChild;
            Node->LowOfThird  = Node->LowOfSecond;
            Node->SecondChild = NodePassedBack;
            Node->LowOfSecond = LowPassedBack;

        }
    } else {

        //
        // Node already has three children - split it.
        // Do this by setting a new parent first.
        //

        NewNode = GtbpGetNextAllocatedNode( AllocatedNodes );
        ASSERT(NewNode != NULL);

        Table->Root = NewNode;
        NewNode->ParentNode  = NULL;
        NewNode->Control     = 0;
        NewNode->FirstChild  = Node;
        NewNode->SecondChild = NULL;
        NewNode->ThirdChild  = NULL;

        Node->ParentNode = NewNode;


        GtbpSplitNode( Node,
                       NodePassedBack,
                       LowPassedBack,
                       SubTree,
                       AllocatedNodes,
                       &NewNode,
                       &LowLeaf
                       );

        Table->Root->SecondChild = NewNode;
        Table->Root->LowOfSecond = LowLeaf;
    }

    return(FoundElement);
}


BOOLEAN
RtlDeleteElementGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element
    )

/*++

Routine Description:

    The function DeleteElementGenericTable2 will find and delete an element
    from a generic table.  If the element is located and deleted the return
    value is TRUE, otherwise if the element is not located the return value
    is FALSE.  The user supplied input buffer is only used as a key in
    locating the element in the table.

    The value of the passed element is compared to elements in the table
    to determine whether or not the element is in the table.  Therefore,
    the Element passed in may be the address of the element in the table
    to delete, or it may be an element with the same value that is not
    in the table.

Arguments:

    Table - Pointer to the table in which to (possibly) delete the
            element referenced by the buffer.

    Element - Passed to the user comparasion routine.  Its contents are
             up to the user but one could imagine that it contains some
             sort of key value.

Return Value:

    BOOLEAN - If the table contained the Element then TRUE, otherwise FALSE.

--*/
{

    RTL_GENERIC_COMPARE_RESULTS
        CompareResult;

    PGTB_TWO_THREE_NODE
        Node,
        SubTreeNode;

    PGTB_TWO_THREE_LEAF
        Leaf,
        LowOfNode;

    BOOLEAN
        ElementDeleted,
        OnlyOneChildLeft;

    ULONG
        SubTree;

    GtbpDiagPrint( DELETION,
                   ("GTB: Request received to delete element 0x%lx\n", Element));


    //
    // There are the following special cases:
    //
    //      1) The table is empty.
    //      2) The table has only one leaf
    //
    // Otherwise, all operations work the same.
    //

    if (Table->ElementCount == 0) {
        GtbpDiagPrint( DELETION,
                       ("GTB: No elements in table to delete.\n"));
        return(FALSE);
    }

    if (GtbpChildrenAreLeaves(Table->Root)) {


        //
        // See if any of the elements match the one passed in.
        // If so, delete the element and shift larger elements
        // to take up the free'd child's spot (unless it is the
        // third child).
        //

        if (Table->Root->ThirdChild != NULL) {
            Leaf = (PGTB_TWO_THREE_LEAF)Table->Root->ThirdChild;
            CompareResult = (*Table->Compare)( Element, Leaf->Element );

            if (CompareResult == GenericEqual) {

                GtbpDiagPrint( DELETION,
                               ("GTB:     Deleting child 3 (0x%lx) from root node.\n"
                                "         Element count before deletion: %d\n",
                               Leaf, Table->ElementCount));

                RemoveEntryList( &Leaf->SortOrderEntry );
                (*Table->Free)(Leaf);
                Table->Root->ThirdChild = NULL;

                Table->ElementCount--;
                ASSERT(Table->ElementCount == 2);


                return(TRUE);
            }
        }

        //
        // Try second child
        //

        if (Table->Root->SecondChild != NULL) {
            Leaf = (PGTB_TWO_THREE_LEAF)Table->Root->SecondChild;
            CompareResult = (*Table->Compare)( Element, Leaf->Element );

            if (CompareResult == GenericEqual) {

                GtbpDiagPrint( DELETION,
                               ("GTB:     Deleting child 2 (0x%lx) from root node.\n"
                                "         Element count before deletion: %d\n",
                               Leaf, Table->ElementCount));

                RemoveEntryList( &Leaf->SortOrderEntry );
                (*Table->Free)(Leaf);
                Table->Root->SecondChild = Table->Root->ThirdChild;
                Table->Root->ThirdChild  = NULL;

                Table->Root->LowOfSecond = Table->Root->LowOfThird;

                Table->ElementCount--;
                ASSERT(Table->ElementCount <= 2);

                return(TRUE);
            }
        }

        //
        // Try first child
        //

        ASSERT(Table->Root->FirstChild != NULL);
        Leaf = (PGTB_TWO_THREE_LEAF)Table->Root->FirstChild;
        CompareResult = (*Table->Compare)( Element, Leaf->Element );

        if (CompareResult == GenericEqual) {    

            GtbpDiagPrint( DELETION,
                           ("GTB:     Deleting child 1 (0x%lx) from root node.\n"
                            "         Element count before deletion: %d\n",
                           Leaf, Table->ElementCount));

            RemoveEntryList( &Leaf->SortOrderEntry );
            (*Table->Free)(Leaf);
            Table->Root->FirstChild  = Table->Root->SecondChild;
            Table->Root->SecondChild = Table->Root->ThirdChild;
            Table->Root->LowOfSecond = Table->Root->LowOfThird;
            Table->Root->ThirdChild = NULL;


            Table->ElementCount--;
            ASSERT(Table->ElementCount <= 2);

            //
            // If that was the last element, then free the root as well.
            //

            if (Table->ElementCount == 0) {
                (*Table->Free)(Table->Root);
                Table->Root = NULL;

                GtbpDiagPrint( DELETION,
                               ("GTB: Deleted last element.  Deleting Root node.\n"));

            }

            return(TRUE);
        }

        //
        // Didn't match any of the leaves
        //

        GtbpDiagPrint( DELETION,
                       ("GTB: No matching element found on DELETE attempt.\n"));
        return(FALSE);

    }





    //
    // We have:
    //
    //  - Root with at least two children
    //  - Root's children are not leaves.
    //

    //
    // Find which sub-tree the element might be in.
    //

    Node = Table->Root;
    GtbpGetSubTreeOfElement( Table, Node, Element, &SubTreeNode, &SubTree );

    GtbpDeleteFromSubTree( Table,
                           SubTreeNode,
                           Element,
                           &LowOfNode,
                           &ElementDeleted,
                           &OnlyOneChildLeft
                           );


    //
    // If we deleted an entry from either the second or third
    // subtree, then we may need to set a new LowOfXxx value.
    // If it was the first subtree, then we simply have to return
    // the LowLeaf value we received.
    //

    if (LowOfNode != 0) {
        if (SubTree == 2) {
            Node->LowOfSecond = LowOfNode;
        } else if (SubTree == 3) {
            Node->LowOfThird = LowOfNode;
        }

    }


    //
    // If the SubTreeNode has only one child left, then some
    // adjustments are going to be necessary.  Otherwise,
    // we are done.
    //

    if (OnlyOneChildLeft) {

        GtbpDiagPrint( DELETION,
                       ("GTB:    Only one child left in 0x%lx\n", SubTreeNode));
        
        //
        // We are at the root and one of our children has only one
        // child.  Re-shuffle our kid's kids.
        //
        
        GtbpCoalesceChildren(  Table,
                               Node,
                               SubTree,
                               &OnlyOneChildLeft
                               );
        
        //
        // After coellescing our children, the root may have only one child
        // left.  Since we are the root node, we can't pass responsibility
        // for fixing this problem to our caller.
        //
        
        if (OnlyOneChildLeft) {
        
            GtbpDiagPrint( DELETION,
                           ("GTB:    Root has only one child. \n"
                           "        Replacing root with child: 0x%lx\n", Node->FirstChild));
            Table->Root = Table->Root->FirstChild;
            Table->Root->ParentNode = NULL;
        
            (*Table->Free)((PVOID)Node);
        }
    }

    return(ElementDeleted);

}


PVOID
RtlLookupElementGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element
    )

/*++

Routine Description:


    The function LookupElementGenericTable2 will find an element in a
    generic table.  If the element is located the return value is a
    pointer to the user defined structure associated with the element,
    otherwise if the element is not located the return value is NULL.
    The user supplied input buffer is only used as a key in locating
    the element in the table.


Arguments:

    Table - Pointer to the users generic table.

    Element - Used for the comparison.

Return Value:

    PVOID - returns a pointer to the user data if found, otherwise NULL.

--*/

{
    RTL_GENERIC_COMPARE_RESULTS
        CompareResult;

    PGTB_TWO_THREE_NODE
        Node;

    PGTB_TWO_THREE_LEAF
        Leaf;

    ULONG
        SubTree;


    GtbpDiagPrint( LOOKUP,
                   ("GTB: Looking up element 0x%lx in table 0x%lx\n",
                    Element, Table));
    //
    // If the table is empty, then no possible match.
    //

    if (Table->ElementCount == 0) {
        GtbpDiagPrint( LOOKUP,
                       ("GTB: Element not found.  No elements in table.\n"));
        return(NULL);
    }

    Node = Table->Root;

    //
    // traverse the tree until we reach a node that has leaves as
    // children.
    //
    // We don't need to use recursion here because there
    // is no tree re-structuring necessary.  That is, there
    // is no need to perform any operations back up the tree
    // once we find the element, so it is much more efficient
    // not to use recursion (which uses lots of push, call,
    // pop, and ret instructions rather than short loop
    // termination tests).
    //

    while (!GtbpChildrenAreLeaves(Node)) {
        GtbpGetSubTreeOfElement( Table, Node, Element, &Node, &SubTree );
    }

    //
    // We are at the node which "might" contain the element.
    // See if any of the children match.
    //

    //
    // Try first child
    //

    Leaf = (PGTB_TWO_THREE_LEAF)Node->FirstChild;
    CompareResult = (*Table->Compare)( Element, Leaf->Element );

    if (CompareResult == GenericEqual) {
        GtbpDiagPrint( LOOKUP,
                       ("GTB: Element found: 2nd child (0x%lx) of node 0x%lx\n",
                       Leaf, Node));
        return(Leaf->Element);
    }

    //
    // Try second child
    //

    if (Node->SecondChild != NULL) {    // Must allow for Root node case
        Leaf = (PGTB_TWO_THREE_LEAF)Node->SecondChild;
        CompareResult = (*Table->Compare)( Element, Leaf->Element );

        if (CompareResult == GenericEqual) {
            GtbpDiagPrint( LOOKUP,
                           ("GTB: Element found: 2nd child (0x%lx) of node 0x%lx\n",
                           Leaf, Node));
            return(Leaf->Element);
        }
    }
    //
    // Try third child
    //

    if (Node->ThirdChild != NULL) {
        Leaf = (PGTB_TWO_THREE_LEAF)Node->ThirdChild;
        CompareResult = (*Table->Compare)( Element, Leaf->Element );

        if (CompareResult == GenericEqual) {
            GtbpDiagPrint( LOOKUP,
                           ("GTB: Element found: 3rd child (0x%lx) of node 0x%lx\n",
                           Leaf, Node));
            return(Leaf->Element);
        }
    }

    
    GtbpDiagPrint( LOOKUP,
                   ("GTB: Element NOT found in node 0x%lx\n", Node));

    return(NULL);

}


PVOID
RtlEnumerateGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID *RestartKey
    )

/*++

Routine Description:


    The function EnumerateGenericTable2 will return to the
    caller, one-by-one, the elements of a table (in sorted order).
    The return value is a pointer to the user defined structure
    associated with the element.
    
    The input parameter RestartKey indicates where the enumeration should
    proceed from.  If there are no more new elements to return the return
    value is NULL.
    
    A RestartKey value of NULL will cause the enumeration to proceed
    from the beginning of the list.
    
    As an example of its use, to enumerate all of the elements in a table
    the user would write:
    
        RestartKey = NULL;
        for (ptr = EnumerateGenericTable2(Table, &RestartKey);
             ptr != NULL;
             ptr = EnumerateGenericTable2(Table, &RestartKey)) {
                :
        }
    
    
    If you wish to initiate an enumeration at a point other than the first
    entry, you may use RestartKeyByIndexGenericTable2() or
    RestartKeyByValueGenericTable2().  If a RestartKey
    for the I'th entry was obtained via RestartKeyByIndexGenericTable2(),
    then passing that RestartKey to this routine will cause the (I+1)th
    element to be returned.  If a RestartKey was obtained matching
    a value passed to RestartKeyByValueGenericTable2(), then passing
    that RestartKey to this routine will cause the entry with the
    next higher value to be returned.
    
                               ! WARNING !
    A RestartKey value may become invalid and cause an access violation
    if any entries have been removed from the table.  If enumeration
    is to be carried out and it is unknown whether or not the table
    contents have changed, it is best to obtain a RestartKey using
    RestartKeyByIndexGenericTable2() or
    RestartKeyByValueGenericTable2().
  

Arguments:

    Table - Pointer to the generic table to enumerate.

    RestartKey - Upon call, indicates where the enumeration is to
        begin.  Upon return, receives context that may be used to
        continue enumeration in a successive call.  NULL indicates
        enumeration should start at the beginning of the table.
        A return value of NULL indicates the last entry has been
        returned.

Return Value:

    PVOID - Pointer to the next enumerated element or NULL.
        NULL is returned if the entire table has already been
        enumerated.

--*/

{
    PLIST_ENTRY
        ListEntry;

    PGTB_TWO_THREE_LEAF
        Leaf;

    ListEntry = (PLIST_ENTRY)(*RestartKey);

    //
    // The restart key is a pointer to our leaf element.
    // Since all leaves are linked together in the SortOrderList,
    // this makes it really trivial to return the next element.
    //

    if (ListEntry == NULL) {
        ListEntry = &Table->SortOrderHead;  //Point to previous element
    }

    //
    // RestartKey pointed to the last enumerated leaf.
    // Advance to the new one.
    //

    ListEntry = ListEntry->Flink;

    //
    // See if we have reached the end of the list
    //

    if (ListEntry == &Table->SortOrderHead) {
        (*RestartKey) = NULL;
        return(NULL);
    }

    //
    // Otherwise, return the address of the element from this leaf.
    //

    Leaf = (PGTB_TWO_THREE_LEAF)((PVOID)ListEntry);

    (*RestartKey) = (PVOID)Leaf;
    return(Leaf->Element);

}



PVOID
RtlRestartKeyByIndexGenericTable2(
    PRTL_GENERIC_TABLE2 Table,
    ULONG I,
    PVOID *RestartKey
    )

/*++

Routine Description:

    
    The function RestartKeyByIndexGenericTable2 will return a RestartKey
    which may then be passed to EnumerateGenericTable2() to perform
    an enumeration of sorted elements following the I'th sorted element
    (zero based).

    This routine also returns a pointer to the I'th element.
    
    I = 0 implies restart at the second sorted element.

    I = (RtlNumberGenericTable2Elements(Table)-1) will return the last
    sorted element in the generic table.

    Values of I greater than (NumberGenericTableElements(Table)-1) 
    will return NULL and the returned RestartKey will cause an 
    enumeration to be performed from the beginning of the sorted list 
    if passed to EnumerateGenericTable2().

        WARNING - You may be tempted to use this routine, passing 
                  first 0, then 1, then 2, et cetera, to perform
                  enumerations.  DON'T.  This is a very expensive
                  operation compared to the enumeration call.

Arguments:

    Table - Pointer to the generic table.

    I - Indicates the point following which you wish to be able
        to resume enumeration.  For example, if you pass 7 for I,
        then a RestartKey will be returned that continues enumeration
        at the 8th element (skipping elements 0 through 6).

    RestartKey - Receives context that may be used to continue 
        enumeration in a successive call.  If there is no I'th
        element, then NULL is returned.

 Return Value:

    PVOID - Pointer to the I'th Element.  If there is no I'th element,
        then returns NULL.

--*/

{
    PLIST_ENTRY
        ListEntry;

    PGTB_TWO_THREE_LEAF
        Leaf;

    ULONG
        i;

    if (I >= Table->ElementCount) {
        (*RestartKey) = NULL;
        return(NULL);
    }

    //
    // Point to the first entry on the list.
    //

    ListEntry = Table->SortOrderHead.Flink;

    //
    // Move to the desired index
    //

    for (i=0; i<I; i++) {
        ListEntry = ListEntry->Flink;
    }


    //
    // Found the I'th element .
    //

    (*RestartKey) = (PVOID)ListEntry;
    Leaf = (PGTB_TWO_THREE_LEAF)((PVOID)ListEntry);
    return(Leaf->Element);

}


PVOID
RtlRestartKeyByValueGenericTable2(
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element,
    PVOID *RestartKey
    )

/*++

Routine Description:

    
    The function RestartKeyByValueGenericTable2 will return a RestartKey
    which may then be passed to EnumerateGenericTable2() to perform
    an enumeration of sorted elements.  The RestartKey will have a
    value that will cause the enumeration to begin starting with
    the first element whose value is greater than the passed in element
    value.

    There does not have to be an element in the tree whose value
    exactly matches the passed in value.  A pointer to the element
    with the largest value that is less than or equal to the passed
    in value will be returned and serve as the continuation point
    for the enumeration.



Arguments:

    Table - Pointer to the generic table.

    Value - points to an element whose value indicates where you
        wish enumeration to continue.

    RestartKey - Receives context that may be used to continue 
        enumeration in a successive call.

 Return Value:

    PVOID - Pointer to the element with the largest value less than
        or equal to the element value passed in.  If there are no
        elements in the table less than or equal to the passed value,
        then a value of NULL will be returned.

--*/

{
    RTL_GENERIC_COMPARE_RESULTS
        CompareResult;

    PGTB_TWO_THREE_NODE
        Node;

    PGTB_TWO_THREE_LEAF
        Leaf;

    ULONG
        Children,
        SubTree;

    BOOLEAN
        LargestElementPath;

    //
    // This routine is real similar to LookupElement
    //

    //
    // handle the special "table is empty" case.
    //

    if (Table->ElementCount == 0) {
        (*RestartKey) = NULL;
        return(NULL);
    }


    Node = Table->Root;

    //
    // traverse the tree until we reach a node that has leaves as
    // children.
    //
    // We don't need to use recursion here because there
    // is no tree re-structuring necessary.  That is, there
    // is no need to perform any operations back up the tree
    // once we find the element, so it is much more efficient
    // not to use recursion (which uses lots of push, call,
    // pop, and ret instructions rather than short loop
    // termination tests).
    //

    LargestElementPath = TRUE;
    while (!GtbpChildrenAreLeaves(Node)) {
        Children = GtbpNumberOfChildren( Node );
        GtbpGetSubTreeOfElement( Table, Node, Element, &Node, &SubTree );
        if (Children > SubTree) { //did we take the highest value path?
            LargestElementPath = FALSE;
        }
    }

    Children = GtbpNumberOfChildren(Node);

    //
    // We are at the node which "might" contain the element.
    // See if any of the children match.
    //
    //      MUST compare 3rd, then 2nd, then 1st child !!
    //

    //
    // Try third child...
    // If we are evaluating the largest element in the
    // table, then the RestartKey will be set to continue
    // at the beginning of the table.  Otherwise, it is
    // set to continue from here.
    //

    if (Children == 3) {
        Leaf = (PGTB_TWO_THREE_LEAF)Node->ThirdChild;
        CompareResult = (*Table->Compare)( Leaf->Element, Element );

        if ( (CompareResult == GenericEqual)  ||
             (CompareResult == GenericLessThan)  ) {
            if (LargestElementPath && (Children == 3)) {
                (*RestartKey) = NULL; // Restart at beginning of list
            } else {
                (*RestartKey) = (PVOID)(Leaf); // Restart here
            }
            return(Leaf->Element);
        }
    }

    //
    // Try second child
    //

    if (Children >= 2) {    // Must allow for Root node case
        Leaf = (PGTB_TWO_THREE_LEAF)Node->SecondChild;
        CompareResult = (*Table->Compare)( Leaf->Element, Element );

        if ( (CompareResult == GenericEqual)  ||
             (CompareResult == GenericLessThan)  ) {
            if (LargestElementPath && (Children == 2)) {
                (*RestartKey) = NULL; // Restart at beginning of list
            } else {
                (*RestartKey) = (PVOID)(Leaf); // Restart here
            }
            return(Leaf->Element);
        }
    }

    //
    // Try first child
    //

    Leaf = (PGTB_TWO_THREE_LEAF)Node->FirstChild;
    CompareResult = (*Table->Compare)( Leaf->Element, Element );

    if ( (CompareResult == GenericEqual)  ||
         (CompareResult == GenericLessThan)  ) {
        if (LargestElementPath && (Children == 1)) {
            (*RestartKey) = NULL; // Restart at beginning of list
        } else {
            (*RestartKey) = (PVOID)(Leaf); // Restart here
        }
        return(Leaf->Element);
    }


    
    (*RestartKey) = NULL;
    return(NULL);
}


ULONG
RtlNumberElementsGenericTable2(
    PRTL_GENERIC_TABLE2 Table
    )

/*++

Routine Description:

    The function NumberGenericTableElements returns a ULONG value 
    which is the number of generic table elements currently inserted
    in the generic table.                                         
    

Arguments:

    Table - Pointer to the generic table.


 Return Value:

    ULONG - The number of elements in the table.

--*/

{   
    return Table->ElementCount;
}


BOOLEAN
RtlIsGenericTable2Empty (
    PRTL_GENERIC_TABLE2 Table
    )
/*++

Routine Description:

    The function IsGenericTableEmpty will return to the caller TRUE if
    the generic table is empty (i.e., does not contain any elements) 
    and FALSE otherwise.
    

Arguments:

    Table - Pointer to the generic table.


 Return Value:

    BOOLEAN - True if table is empty, otherwise FALSE.

--*/

{   
    return (Table->ElementCount == 0);
}



//////////////////////////////////////////////////////////////////////////
//                                                                      //
//  Internal (private) Services ...                                     //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


VOID
GtbpDeleteFromSubTree (
    IN  PRTL_GENERIC_TABLE2         Table,
    IN  PGTB_TWO_THREE_NODE         Node,
    IN  PVOID                       Element,
    OUT PGTB_TWO_THREE_LEAF         *LowOfNode,
    OUT BOOLEAN                     *ElementDeleted,
    OUT BOOLEAN                     *OnlyOneChildLeft
    )

/*++

Routine Description:

    Delete an element from a SubTree.


Arguments:

    Table - Points to the table.  This is needed for comparison
        and memory-free routine.

    Node - Points to the child node within which the element to
        delete resides (if it is in the tree at all).

    Element - points to an element.  We are to delete any element
        found to be equal to this element.

    LowOfNode - If the first child of Node isn't changed, then
        a zero will be returned to this parameter, signifying that
        the caller doesn't have to worry about updating LowOfXxx values.
        However, if the first child of Node does change, then this
        value will point to the new Low Leaf for the node's subtrees.

    ElementDeleted - Receives a boolean value indicating whether or
        not an element was actually deleted.  TRUE is returned if
        an element was deleted.  FALSE is returned if no element
        was deleted.

    OnlyOneChildLeft - Receives a boolean value indicating whether or
        not ChildNode was reduced to having only a single child.
        TRUE indicates ChildNode now has only one child.
        FALSE indicates ChildNode has at least two children.

Return Value:

    None.

--*/

{
    RTL_GENERIC_COMPARE_RESULTS
        CompareResult;

    PGTB_TWO_THREE_NODE
        SubTreeNode;

    PGTB_TWO_THREE_LEAF
        Leaf;

    ULONG
        SubTree;

    (*LowOfNode) = 0;   // Default is no change
    (*OnlyOneChildLeft) = FALSE;  // Default return value
    

    //
    // If we are a parent of leaves, then we can look for an
    // element to delete.  Otherwise, just find the subtree
    // to continue or search in and recurse.
    //

    if (GtbpChildrenAreLeaves(Node)) {

        (*ElementDeleted) = FALSE;  // Default return value

        //
        // See if any of the elements match the one passed in.
        // If so, delete the element and shift larger elements
        // to take up the free'd child's spot (unless it is the
        // third child).
        //

        if (Node->ThirdChild != NULL) {
            Leaf = (PGTB_TWO_THREE_LEAF)Node->ThirdChild;
            CompareResult = (*Table->Compare)( Element, Leaf->Element );

            if (CompareResult == GenericEqual) {

                GtbpDiagPrint( DELETION,
                               ("GTB: Deleting 3rd child (0x%lx) of node 0x%lx\n"
                               "     ElementCount before deletion: %d\n",
                               Leaf, Node, Table->ElementCount));

                RemoveEntryList( &Leaf->SortOrderEntry );
                (*Table->Free)(Leaf);
                Node->ThirdChild = NULL;

                Table->ElementCount--;

                (*ElementDeleted) = TRUE;
                return;
            }
        }

        //
        // Try second child
        //

        Leaf = (PGTB_TWO_THREE_LEAF)Node->SecondChild;
        CompareResult = (*Table->Compare)( Element, Leaf->Element );

        if (CompareResult == GenericEqual) {

            GtbpDiagPrint( DELETION,
                           ("GTB: Deleting 2nd child (0x%lx) of node 0x%lx\n"
                           "     ElementCount before deletion: %d\n",
                           Leaf, Node, Table->ElementCount));

            RemoveEntryList( &Leaf->SortOrderEntry );
            (*Table->Free)(Leaf);
            Node->SecondChild = Node->ThirdChild;
            Node->LowOfSecond = Node->LowOfThird;
            Node->ThirdChild  = NULL;


            //
            // If we are down to the last element, let that
            // be known.
            //
            
            if (Node->SecondChild == NULL) {
                GtbpDiagPrint( DELETION,
                               ("GTB: Only one child left in node (0x%lx).\n",
                                Node));
                (*OnlyOneChildLeft) = TRUE;
            }

            Table->ElementCount--;
            (*ElementDeleted) = TRUE;
            return;
        }

        //
        // Try first child
        //

        Leaf = (PGTB_TWO_THREE_LEAF)Node->FirstChild;
        CompareResult = (*Table->Compare)( Element, Leaf->Element );

        if (CompareResult == GenericEqual) {

            GtbpDiagPrint( DELETION,
                           ("GTB: Deleting 1st child (0x%lx) of node 0x%lx\n"
                           "     ElementCount before deletion: %d\n",
                           Leaf, Node, Table->ElementCount));

            RemoveEntryList( &Leaf->SortOrderEntry );
            (*Table->Free)(Leaf);
            Node->FirstChild  = Node->SecondChild;
            (*LowOfNode)      = Node->LowOfSecond;

            Node->SecondChild = Node->ThirdChild;
            Node->LowOfSecond = Node->LowOfThird;

            Node->ThirdChild = NULL;


            //
            // If we are down to the last element, let that
            // be known.
            //

            if (Node->SecondChild == NULL) {
                GtbpDiagPrint( DELETION,
                               ("GTB: Only one child left in node (0x%lx).\n",
                                Node));
                (*OnlyOneChildLeft) = TRUE;
            }

            Table->ElementCount--;
            (*ElementDeleted) = TRUE;
            return;
        }

        //
        // Didn't match any of the leaves
        //

        GtbpDiagPrint( DELETION,
                       ("GTB:    No matching element found on DELETE attempt.\n"));

        return; // Default value already set
    }

    //
    // Find a subtree to continue our search...
    //

    GtbpGetSubTreeOfElement( Table, Node, Element, &SubTreeNode, &SubTree );

    GtbpDeleteFromSubTree( Table,
                           SubTreeNode,
                           Element,
                           LowOfNode,
                           ElementDeleted,
                           OnlyOneChildLeft
                           );


    //
    // If we deleted an entry from either the second or third
    // subtree, then we may need to set a new LowOfXxx value.
    // If it was the first subtree, then we simply have to return
    // the LowLeaf value we received.
    //

    if ((*LowOfNode) != 0) {
        if (SubTree == 2) {
            Node->LowOfSecond = (*LowOfNode);
            (*LowOfNode) = NULL;
        } else if (SubTree == 3) {
            Node->LowOfThird = (*LowOfNode);
            (*LowOfNode) = NULL;
        } 
    }


    //
    // If the SubTreeNode has only one child left, then some
    // adjustments are going to be necessary.  Otherwise,
    // we are done.
    //

    if ((*OnlyOneChildLeft)) {

        GtbpDiagPrint( DELETION,
                       ("GTB:    Only one child left in 0x%lx\n", SubTreeNode));
        
        //
        // One of our children has only one child.
        // Re-shuffle our kid's kids.
        //
        
        GtbpCoalesceChildren(  Table,
                               Node,
                               SubTree,
                               OnlyOneChildLeft
                               );
    }

    return;
}


BOOLEAN
GtbpInsertIntoSubTree (
    PRTL_GENERIC_TABLE2             Table,
    IN  PGTB_TWO_THREE_NODE         Node,
    IN  BOOLEAN                     NodeIsLeaf,
    IN  PVOID                       Element,
    IN  ULONG                       SplitCount,
    IN  PVOID                       *FoundElement,
    OUT PGTB_TWO_THREE_NODE         *ExtraNode,
    OUT PGTB_TWO_THREE_LEAF         *LowLeaf,
    OUT PLIST_ENTRY                 *AllocatedNodes
    )

/*++

Routine Description:

    Insert an element into the SubTree specified by Node.

    Special note:

            if FoundElement is returned as NULL, that means we
            couldn't allocate memory to add the new element.

Arguments:

    Table - Points to the table being inserted into.  This is needed
        for its allocation routine.
        

    Node - Points to the root node of the SubTree into
        which the element is to be inserted.

    NodeIsLeaf - TRUE if the node passed in is a leaf.  FALSE
        if it is an internal node.

    Element - Points to the element to be inserted.

    SplitCount - indicates how many nodes have been traversed since
        a node with only two children.  When inserting a new element
        that causes nodes to be split, this will indicate how many
        nodes will split.  This allows all memory that will be required
        to split nodes to be allocated at the very bottom routine
        (before any changes to the tree are made).  See the description
        of the AllocatedNodes parameter for more information.

    FoundElement - Receives a pointer to the element that
        was either inserted, or one already in the table
        but found to match the one being inserted.
        If null is returned, then not enough memory could be
        allocated to insert the new element.

    ExtraNode - If it was necessary to create a new node to
        accomodate the insertion, then ExtraNode will receive
        a pointer to that node, otherwise ExtraNode will receive
        NULL.

    LowLeaf - This value points to the lowest value leaf of the
        SubTree starting at Node.

    AllocatedNodes - This is a tricky parameter.  We have the problem
        that when we insert an element in the tree, we may need to
        allocate additional internal nodes further up the tree as
        we return out of our recursive calls.  We must avoid the
        situation where we start making changes to the tree only to
        find we can't allocate memory to re-arrange higher levels of
        the tree.  To accomodate this situation, we always allocate
        all the nodes we will need at the very bottom of the call
        chain and pass back a linked list of GTB_TWO_THREE_NODEs using
        this parameter.  We know how many nodes we will need to
        allocate because it is the number of nodes between the leaf
        and the lowest level node in the path between the leaf and the
        root that has only 2 children.  That is, all nodes directly
        above the leaf that have 3 children will need to be split.
        Example:

                                  3
                                / | \
                         +-----+  |  +----
        Won't split -->  2        ...      ...
                       / |
                +-----+  |
              ...        3 <-- Will split 
                       / | \
                +-----+  |  +----+
              ...                3  <--- Will split
                               / | \
                        +-----+  |  +----+
                       Leaf     Leaf    Leaf   <- Add fourth leaf here.

        Adding a fourth leaf where indicated will cause a split at the
        two nodes indicated.  So, you can see that keeping a count of
        the nodes with three children since the last encountered node
        with only two children will tell us how many nodes will split.







Return Value:

    TRUE - if element was added.
    FALSE - if element not added (due to collision or out-of-memory)

--*/

{
    RTL_GENERIC_COMPARE_RESULTS
        CompareResult;

    ULONG
        SubTree;        // To track which SubTree an element is being placed in.


    PGTB_TWO_THREE_NODE
        SubTreeNode,
        NodePassedBack;


    PGTB_TWO_THREE_LEAF
        NewLeaf,
        LowPassedBack;

    BOOLEAN
        Inserted,
        SubNodeIsLeaf;


    //
    // Don't have an extra node to pass back yet.
    //

    (*ExtraNode) = NULL;


    //
    // We are either at a leaf, or an internal node.
    //

    if (NodeIsLeaf) {

        //
        // Typecast the Node into a leaf
        //

        PGTB_TWO_THREE_LEAF Leaf = (PGTB_TWO_THREE_LEAF)((PVOID)Node);

        //
        // See if the value matches.
        //

        CompareResult = (*Table->Compare)( Element, Leaf->Element );

        if (CompareResult == GenericEqual) {
            (*LowLeaf)      = Leaf;
            (*FoundElement) = Leaf->Element;

            GtbpDiagPrint( COLLISIONS,
                           ("GTB: Insertion attempt resulted in collision.\n"
                            "     Element NOT being inserted.\n"
                            "     Elements in table: %d\n",
                            Table->ElementCount));

            return(FALSE);
        }  //end_if equal

        //
        // The new element isn't in the tree.
        // Allocate a new leaf for it.
        //

        NewLeaf = GtbpAllocateLeafAndNodes( Table, SplitCount, AllocatedNodes );
        if (NewLeaf == NULL) {

            //
            // The following (unusual) return value indicates we
            // couldn't allocate memory to add the entry into the
            // tree.
            //

            (*FoundElement) = NULL;
            return(FALSE);

        }  //end_if (NewLeaf == NULL)

        switch (CompareResult) {

        case GenericLessThan: {

            //
            // Move the original element into the new leaf.  Notice
            // that the SortOrderEntry of the existing leaf is
            // still in the right place in the linked-list, even
            // though the leaf now points at a different element.
            //

            NewLeaf->Element    = Leaf->Element;
            Leaf->Element       = Element;

            break;
        } //end_case

        case GenericGreaterThan: {

            //
            // The new element does not supplant the existing element.
            // Put it in the new leaf.
            //

            NewLeaf->Element    = Element;
            break;
        } //end_case


        } //end_switch

        //
        // At this point, the lower-value element is in Leaf
        // and the higher-value element is in NewLeaf.  The
        // caller is responsible to putting NewLeaf someplace
        // else in the tree.
        //

        //
        // Now link the new leaf into our sort-order list.
        // The new leaf immediately follows our existing leaf,
        // regardless of which element is in the new leaf (original
        // or new element).
        //

        InsertHeadList(&Leaf->SortOrderEntry, &NewLeaf->SortOrderEntry);
        Table->ElementCount++;  // Increment the element count

        (*ExtraNode)    = (PGTB_TWO_THREE_NODE)((PVOID)NewLeaf);
        (*LowLeaf)      = NewLeaf;
        (*FoundElement) = Element;

        return(TRUE);

    }  //end_if NodeIsLeaf

    //
    // Node is internal (not a leaf)
    //

    //
    // See if we should re-set or increment the SplitCount.
    //

    if (Node->ThirdChild == NULL) {
        SplitCount = 0;
    } else {
        SplitCount += 1;
    }

    GtbpGetSubTreeOfElement( Table, Node, Element, &SubTreeNode, &SubTree);
    SubNodeIsLeaf = GtbpChildrenAreLeaves(Node);

    Inserted = GtbpInsertIntoSubTree ( Table,
                                       SubTreeNode,
                                       SubNodeIsLeaf,
                                       Element,
                                       SplitCount,
                                       FoundElement,
                                       &NodePassedBack,
                                       &LowPassedBack,
                                       AllocatedNodes
                                       );

    //
    // One of several things could have happened:
    //
    //      1) We didn't have enough memory to add the new element.
    //         In this case we are done and simply return.
    //
    //      2) The element was added, and no-rearrangement to this
    //         node is needed.  In this case we are done and simply
    //         return.
    //
    //      3) The element was added and caused a leaf to be pushed
    //         out of the SubTree.  We have some work to do.
    //

    if ( (FoundElement == NULL)  ||         // Insufficient memory, or
         (NodePassedBack == NULL)  ) {      // no work for this node
        return(Inserted);
    }

    if (Node->ThirdChild == NULL) {

        if (!GtbpChildrenAreLeaves(Node)) {
            NodePassedBack->ParentNode = Node;
        }

        //
        // Node doesn't yet have a third child, so use it.
        // This might require shuffling the second child to the
        // be the third child.
        //

        if (SubTree == 2) {

            //
            // Node fell out of second SubTree and we don't have a
            // third SubTree.  Make that node the third SubTree.
            //

            Node->ThirdChild = NodePassedBack;
            Node->LowOfThird = LowPassedBack;

        } else {

            //
            // Node fell out of first SubTree.
            // Make the second SubTree the third SubTree and
            // then make the passed back node the second SubTree.
            //

            ASSERT(SubTree == 1);

            Node->ThirdChild  = Node->SecondChild;
            Node->LowOfThird  = Node->LowOfSecond;
            Node->SecondChild = NodePassedBack;
            Node->LowOfSecond = LowPassedBack;

            //
            //

        }
    } else {

        //
        // Node already has three children - split it.
        //

        GtbpSplitNode( Node,
                       NodePassedBack,
                       LowPassedBack,
                       SubTree,
                       (*AllocatedNodes),
                       ExtraNode,
                       LowLeaf
                       );

    }

    return(Inserted);
}


ULONG
GtbpNumberOfChildren(
    IN  PGTB_TWO_THREE_NODE         Node
    )

/*++

Routine Description:

    Return the number of children of a specified node.

Arguments:

    Node - points to the node whose children are to be counted.

Return Values:

    0, 1, 2, or 3.

--*/
{
    if (Node->ThirdChild != NULL) {
        return(3);
    }
    if (Node->SecondChild != NULL) {
        return(2);
    }
    if (Node->FirstChild != NULL) {
        return(1);
    }
    return(0);

}


VOID
GtbpGetSubTreeOfElement(
    IN  PRTL_GENERIC_TABLE2         Table,
    IN  PGTB_TWO_THREE_NODE         Node,
    IN  PVOID                       Element,
    OUT PGTB_TWO_THREE_NODE         *SubTreeNode,
    OUT ULONG                       *SubTree
    )

/*++

Routine Description:

    Find which SubTree of Node that Element might be in (or should be
    in, if being inserted).

Arguments:

    Table - Points to the table  This is needed for its comparison routine.

    Node - Is the node, one of whose SubTrees is to be chosen as the
        subtree in which Element could/should reside.

    Element - is the element we are interested in placing or locating.

    SubTreeNode - Receives a pointer to the node of the SubTree in
        which the element could/should reside.

    SubTree - Receives the index (1, 2, or 3) of the subtree of Node
        in which the element could/should reside.

Return Values:

    None.

--*/
{
    RTL_GENERIC_COMPARE_RESULTS
        CompareResult;

    CompareResult = (*Table->Compare)( Element, Node->LowOfSecond->Element );

    if (CompareResult == GenericLessThan) {

        (*SubTree) = 1;
        (*SubTreeNode) = Node->FirstChild;

    } else {

        //
        // default to the second subtree, but
        // if there is a subtree we may change it.
        //

        (*SubTree) = 2;
        (*SubTreeNode) = Node->SecondChild;

        if (Node->ThirdChild != NULL) {

            CompareResult = (*Table->Compare)( Element, Node->LowOfThird->Element );
            if ( (CompareResult == GenericGreaterThan)  ||
                 (CompareResult == GenericEqual)          ) {

                (*SubTree) = 3;
                (*SubTreeNode) = Node->ThirdChild;
            }
        }
    }
    
    return;

}



VOID
GtbpCoalesceChildren(
    IN  PRTL_GENERIC_TABLE2         Table,
    IN  PGTB_TWO_THREE_NODE         Node,
    IN  ULONG                       SubTree,
    OUT BOOLEAN                     *OnlyOneChildLeft
    )

/*++

Routine Description:

    This routine is called following a deletion that leaves a child
    node with only one child of its own.  That is, a child of the
    Node parameter has only one child.  The SubTree parameter indicates
    which child of Node has only one child.


                    

Arguments:

    Table - Points to the table.

    Node - Is the node, one of whose children has only one child.

        NOTE: The ParentNode field of this node must be valid.
              The Low values of ParentNode will be referenced.

    SubTree - Indicates which child of Node (1, 2, or 3) has only one
        child.

    OnlyOneChildLeft - Receives a boolean indicating whether or not
        Node itself has been left with only one child due to the
        coalescing.

Return Values:

    None.

--*/
{
    PGTB_TWO_THREE_NODE
        A,
        B,
        C;

    (*OnlyOneChildLeft) = FALSE;    // Default return value

    //
    // For the following discussion, using the following:
    //
    //      N is the parent node
    //      S is the node which has only one child
    //        (S is a child of N)
    //
    //      A is the first child of N
    //      B is the second child of N
    //      C is the third child of N
    //
    // If S is the first child of N (meaning S is A)
    // then:
    //
    //      if B has three children (let A adopt the smallest)
    //      then:
    //
    //              Move B(1) to A(2)
    //              Move B(2) to B(1)
    //              Move B(3) to B(2)
    //
    //      else (B has two children)
    //
    //              (move the orphan into B)
    //              Move B(2) to B(3)
    //              Move B(1) to B(2)
    //              Move A(1) to B(1)
    //              
    //              Free A
    //              Make B the first child of N
    //              if (C is a real child)
    //              then:
    //                  Make C the second child of N
    //              else (N only has one child now)
    //                  (*OnlyOneChildLeft) = TRUE;
    //
    // else if S is the second child of N (meaning S is B)
    // then:
    //
    //      if A has three children
    //      then:
    //              Move B(1) to B(2)
    //              Move A(3) to B(1)
    //
    //      else if C exists and has three children
    //           then:
    //
    //                  Move C(1) to B(2)
    //                  Move C(2) to C(1)
    //                  Move C(3) to C(2)
    //
    //           else: (no other child of N has three children)
    //
    //                  (Move the orphan into A)
    //                  Move B(1) to A(3)
    //              
    //                  Free B
    //                  if (C is a real child)
    //                  then:
    //                          Make C the second child of N
    //                  else: (N only has one child now)
    //                          (*OnlyOneChildLeft) = TRUE;
    //
    // else: (S is the third child of N (meaning S is C))
    //
    //      if B has three children
    //      then:
    //              (move one into C)
    //              Move C(1) to C(2)
    //              Move B(3) to C(1)
    //
    //      else: (B only has two children)
    //
    //              (move the orphan into B)
    //              Move C(1) to B(3)
    //              Free C
    // Wow!


    A = Node->FirstChild;
    B = Node->SecondChild;
    C = Node->ThirdChild;


    //
    // SubTree indicates which child has the orphan.
    //

    if (SubTree == 1) {

        //
        // First child has the orphan
        //

        if (B->ThirdChild != NULL) {

            // (B has three children - let A adopt the smallest)
            //
            //      Move B(1) to A(2)
            //      Move B(2) to B(1)
            //      Move B(3) to B(2)
            //

            A->SecondChild = B->FirstChild;
            A->LowOfSecond = Node->LowOfSecond;

            B->FirstChild  = B->SecondChild;
            Node->LowOfSecond = B->LowOfSecond;

            B->SecondChild = B->ThirdChild;
            B->LowOfSecond = B->LowOfThird;
            B->ThirdChild = NULL;

        } else {

            //
            // (B has two children)
            //  
            //        (move the orphan into B)
            //        Move B(2) to B(3)
            //        Move B(1) to B(2)
            //        Move A(1) to B(1)
            //

            B->ThirdChild  = B->SecondChild;
            B->LowOfThird  = B->LowOfSecond;

            B->SecondChild = B->FirstChild;
            B->LowOfSecond = Node->LowOfSecond;

            B->FirstChild  = A->FirstChild;
            //Node->LowOfSecond = Node->LowOfFirst;  // This gets moved back in a few steps

            //        Free A
            //        Make B the first child of N
            //        if (C is a real child)
            //        then:
            //            Make C the second child of N
            //        else (N only has one child now)
            //            (*OnlyOneChildLeft) = TRUE;
            //

            (*Table->Free)(A);
            Node->FirstChild = B;
            //Node->LowOfFirst = Node->LowOfSecond;  // See comment a few lines up

            if (C != NULL) {
                Node->SecondChild = C;
                Node->LowOfSecond = Node->LowOfThird;
                Node->ThirdChild = NULL;
            } else {
                Node->SecondChild = NULL;
                (*OnlyOneChildLeft) = TRUE;
            }
        }


    } else if (SubTree == 2) {

        //
        // Second child has the orphan
        //

        if (A->ThirdChild != NULL) {

            //
            // (A has three children)
            //
            //      Move B(1) to B(2)
            //      Move A(3) to B(1)
            //

            B->SecondChild = B->FirstChild;
            B->LowOfSecond = Node->LowOfSecond;

            B->FirstChild  = A->ThirdChild;
            Node->LowOfSecond = A->LowOfThird;
            A->ThirdChild = NULL;

        } else {

            if (C != NULL  &&
                C->ThirdChild != NULL) {

                //
                // (C exists and has three children)
                // (move the smallest into B)
                //
                //      Move C(1) to B(2)
                //      Move C(2) to C(1)
                //      Move C(3) to C(2)
                //

                B->SecondChild = C->FirstChild;
                B->LowOfSecond = Node->LowOfThird;

                C->FirstChild  = C->SecondChild;
                Node->LowOfThird = C->LowOfSecond;

                C->SecondChild = C->ThirdChild;
                C->LowOfSecond = C->LowOfThird;
                C->ThirdChild = NULL;





            } else {

                //
                // (no other child of N has three children)
                // (Move the orphan into A)
                //
                //      Move B(1) to A(3)
                //      
                //      Free B
                //      if (C is a real child)
                //      then:
                //              Make C the second child of N
                //      else: (N only has one child now)
                //              (*OnlyOneChildLeft) = TRUE;
                //

                A->ThirdChild = B->FirstChild;
                A->LowOfThird = Node->LowOfSecond;

                (*Table->Free)(B);

                if (C != NULL) {
                    Node->SecondChild = C;
                    Node->LowOfSecond = Node->LowOfThird;
                    Node->ThirdChild  = NULL;
                } else {
                    Node->SecondChild = NULL;
                    (*OnlyOneChildLeft) = TRUE;
                }
            }
        }



    } else {

        //
        // Third child has the orphan
        //

        ASSERT(SubTree == 3);
        ASSERT(C != NULL);
        ASSERT(B != NULL);

        if (B->ThirdChild != NULL) {

            //
            // (B has three children)
            // (move the largest of them into C)
            // Move C(1) to C(2)
            // Move B(3) to C(1)
            //

            C->SecondChild = C->FirstChild;
            C->LowOfSecond = Node->LowOfThird;

            C->FirstChild  = B->ThirdChild;
            Node->LowOfThird = B->LowOfThird;
            B->ThirdChild = 0;
        } else {

            //
            // (B only has two children)
            // (move the orphan into B)
            // Move C(1) to B(3)
            // Free C
            //

            B->ThirdChild = C->FirstChild;
            B->LowOfThird = Node->LowOfThird;
            Node->ThirdChild = NULL;

            (*Table->Free)(C);

        }
    }
    
    return;

}


VOID
GtbpSplitNode(
    IN  PGTB_TWO_THREE_NODE         Node,
    IN  PGTB_TWO_THREE_NODE         NodePassedBack,
    IN  PGTB_TWO_THREE_LEAF         LowPassedBack,
    IN  ULONG                       SubTree,
    IN  PLIST_ENTRY                 AllocatedNodes,
    OUT PGTB_TWO_THREE_NODE         *NewNode,
    OUT PGTB_TWO_THREE_LEAF         *LowLeaf
    )

/*++

Routine Description:
    
    This routine splits a node that already has three children.
    Memory necessary to perform the split is expected to have
    already been allocated and available via the AllocatedNodes
    parameter.
    

Parameters:

    Node - The node to be split.

    NodePassedBack - The 4th node passed back from an insertion operation
        into the SubTree of Node specified by the SubTree parameter.
        NOTE: that this may, in fact, be a GTB_TWO_THREE_LEAF !!!

    LowPassedBack - points the the low leaf value passed back by the
        insertion operation that is causing the split.

    SubTree - Indicates which SubTree of Node an element was inserted
        into which is causing the split.

    AllocatedNodes - Contains a list of allocated GTB_TWO_THREE_NODE
        blocks for use in an insertion operation (which this split
        is assumed to be part of).

    NewNode - Receives a pointer to the node generated by the split.

    LowLeaf - receives a pointer to the low leaf of the NewNode's SubTree.


Return Values:

    None.

--*/
{

    PGTB_TWO_THREE_NODE
        LocalNode;



    // Make a new node and split things up.
    // The node has already been allocated and passed back to
    // this routine via the AllocatedNodes parameter.
    //

    LocalNode = GtbpGetNextAllocatedNode( AllocatedNodes );
    ASSERT( LocalNode != NULL);
    (*NewNode) = LocalNode;

    //
    // Set known fields of new node
    //

    LocalNode->ParentNode  = Node->ParentNode;
    LocalNode->Control     = Node->Control;
    LocalNode->ThirdChild  = NULL; //Low of third is left undefined

    //
    // Now move around children...
    //

    if (SubTree == 3) {

        //
        // We were inserting into the 3rd SubTree.  This implies:
        //
        //            Node(child 3) moves to  new(child 1)
        //            Back          is put in new(child 2)
        //
      
        LocalNode->FirstChild  = Node->ThirdChild;
        LocalNode->SecondChild = NodePassedBack;
        LocalNode->LowOfSecond = LowPassedBack;
        (*LowLeaf)             = Node->LowOfThird;  // low of the new node is low of old third

        Node->ThirdChild       = NULL; //Low of third is left undefined



    } else {

        //
        // We inserted into either SubTree 1 or 2.
        // These cases cause:
        //
        //      1 =>  Node(child 3) moves to new(child 2)
        //            Node(child 2) moves to New(child 1)
        //            Back          is put in Node(child 2)
        //
        //      2 =>  Node(child 3) moves to new(child 2)
        //            Back          is put in New(child 1)
        //
        // In both these cases, Node(child 3) moves to New(child 2)
        // and there are no third children.  So do that.
        //
      
        LocalNode->SecondChild  = Node->ThirdChild;
        LocalNode->LowOfSecond  = Node->LowOfThird;


        if (SubTree == 2) {

            LocalNode->FirstChild  = NodePassedBack;
            (*LowLeaf)             = LowPassedBack;

            if (!GtbpChildrenAreLeaves(Node)) {
                NodePassedBack->ParentNode = LocalNode;
            }

        } else {

            //
            // SubTree == 1
            //

            LocalNode->FirstChild  = Node->SecondChild;
            (*LowLeaf)             = Node->LowOfSecond;

            Node->SecondChild          = NodePassedBack;
            Node->LowOfSecond          = LowPassedBack;
            if (!GtbpChildrenAreLeaves(Node)) {
                NodePassedBack->ParentNode = Node;
            }

        }
    }

    //
    // Neither node has a third child anymore
    //

    LocalNode->ThirdChild  = NULL; //Low of third is left undefined
    Node->ThirdChild       = NULL;

    //
    // Set the ParentNodes only if the children aren't leaves.
    //

    if (!GtbpChildrenAreLeaves(Node)) {

        Node->FirstChild->ParentNode  = Node;
        Node->SecondChild->ParentNode = Node;

        LocalNode->FirstChild->ParentNode  = LocalNode;
        LocalNode->SecondChild->ParentNode = LocalNode;
    }


    return;
}



PGTB_TWO_THREE_LEAF
GtbpAllocateLeafAndNodes(
    IN  PRTL_GENERIC_TABLE2     Table,
    IN  ULONG                   SplitCount,
    OUT PLIST_ENTRY             *AllocatedNodes
    )
/*++

Routine Description:

    Allocate a leaf and some number of internal nodes.  This is
    used in conjunction with GtbpGetNextAllocatedNode() when splitting
    nodes following an insertion.  These two routines allow all necessary
    memory to be allocated all at once, rather than trying to deal with
    memory allocation failures once changes to the tree have begun.


Arguments:

    Table - the table into which the nodes will be added.  This
        provides the allocation routine.

    SplitCount - indicates how many nodes will need splitting, and,
        thus, how many nodes need to be allocated.


Return Value:

    Pointer to the leaf if successful.
    NULL if unsuccessful.

--*/
{

    PGTB_TWO_THREE_LEAF
        Leaf;

    PLIST_ENTRY
        NodeRoot,
        NextNode;

    ULONG
        i;

#ifdef GTBP_DIAGNOSTICS
    PGTB_TWO_THREE_NODE
        N;
#endif //GTBP_DIAGNOSTICS

    NodeRoot = NULL;

    //
    // Allocate a chain of Nodes, if necessary
    //

    if (SplitCount > 0) {

        NodeRoot = (PLIST_ENTRY)
                   ((*Table->Allocate)( sizeof(GTB_TWO_THREE_NODE)));
        if (NodeRoot == NULL) {
            goto error_return;
        }

        InitializeListHead( NodeRoot );

#ifdef GTBP_DIAGNOSTICS

        GtbpDiagPrint(LEAF_AND_NODE_ALLOC,
                      ("GTB: Allocating %d nodes with leaf, root: 0x%lx\n",
                      SplitCount, NodeRoot));
        N = (PGTB_TWO_THREE_NODE)NodeRoot;
        N->Control = 10000;     //Used as a diagnostic allocation counter/index

#endif //GTBP_DIAGNOSTICS

        for (i=1; i<SplitCount; i++) {
            NextNode = (PLIST_ENTRY)
                       ((*Table->Allocate)( sizeof(GTB_TWO_THREE_NODE)));
            if (NextNode == NULL) {
                goto error_return;
            }
            InsertTailList( NodeRoot, NextNode );

#ifdef GTBP_DIAGNOSTICS

            N = (PGTB_TWO_THREE_NODE)NextNode;
            N->Control = 10000+i;     //Used as a diagnostic allocation counter/index

#endif //GTBP_DIAGNOSTICS
        }
    }


    //
    // Finally, allocate the leaf
    //

    Leaf = (PGTB_TWO_THREE_LEAF)
           ((*Table->Allocate)( sizeof(GTB_TWO_THREE_LEAF)));

    if (Leaf == NULL) {
        goto error_return;
    }

    (*AllocatedNodes) = NodeRoot;
    return(Leaf);

error_return:

    GtbpDiagPrint(LEAF_AND_NODE_ALLOC,
                  ("GTB:    ** error allocating leaf and nodes - insufficient memory.\n"));
    //
    // Deallocate any nodes that have already been allocated.
    //

    if (NodeRoot != NULL) {

        NextNode = NodeRoot->Flink;
        while (NextNode != NodeRoot) {
            RemoveEntryList( NextNode );
            (*Table->Free)( NextNode );
        
        
        }
        
        (*Table->Free)( NodeRoot );
    }

    return(NULL);
}


PGTB_TWO_THREE_NODE
GtbpGetNextAllocatedNode(
    IN PLIST_ENTRY      AllocatedNodes
    )
/*++

Routine Description:

    Take the next node off of the list of allocated nodes and
    return its address.


Arguments:

    AllocatedNodes - Points to the list of nodes allocated using
        GtbpAllocateLeafAndNodes().


Return Value:

    Pointer to the node.
    any other return value indicates an error in the caller.

--*/
{
    PLIST_ENTRY
        NextNode;

#ifdef GTBP_DIAGNOSTICS
    PGTB_TWO_THREE_NODE
        N;
#endif //GTBP_DIAGNOSTICS

    //
    // Remove the first entry on the list.
    // This ensures that the passed in root is the last entry
    // returned.
    //

    NextNode = AllocatedNodes->Flink;
    RemoveEntryList( NextNode );

#ifdef GTBP_DIAGNOSTICS

    NextNode->Flink = NULL;     //Just to prevent accidental re-use
    N = (PGTB_TWO_THREE_NODE)NextNode;
    ASSERT(N->Control >= 10000);    //under 10000 mplies it has already been allocated.


    GtbpDiagPrint(LEAF_AND_NODE_ALLOC,
                  ("GTB: Allocating node (index: %d) from root: 0x%lx\n",
                  (N->Control-10000), AllocatedNodes));
#endif //GTBP_DIAGNOSTICS

    return( (PGTB_TWO_THREE_NODE)((PVOID)NextNode) );
}



//////////////////////////////////////////////////////////////////////////
//                                                                      //
//  Diagnostic (Developer) routines ...                                 //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#ifdef GTBP_DEVELOPER_BUILD

#include <string.h>

//
// This routine is expected to dump an element's value
//

typedef
VOID
(NTAPI *PGTBP_DEV_DUMP_ELEMENT_ROUTINE) (
    PVOID Element
    );


VOID
GtbpDevIndent(
    ULONG Depth
    )
{
    UNICODE_STRING
        Indent;

    RtlInitUnicodeString( &Indent,
    L"                                                                     +");

    Indent.Length = (USHORT)(Depth*4);
    if (Indent.Length > Indent.MaximumLength) {
        Indent.Length = Indent.MaximumLength;
    }

    DbgPrint("\n%wZ%d: ", &Indent, Depth);
    return;
}


VOID
GtbpDevDumpNode(
    PGTB_TWO_THREE_NODE             Parent,
    PGTB_TWO_THREE_NODE             N,
    PGTB_TWO_THREE_LEAF             Low,
    ULONG                           Depth,
    PGTBP_DEV_DUMP_ELEMENT_ROUTINE  DumpElement
    )
/*++

Routine Description:

    Dump the 2-3 tree starting at the specified node.
    
Arguments:

    N - Points to the node to start the dump at.

    Depth - Indicates the depth of the tree prior to this node.
        This is used to indent the printing.

Return Value:

    None.

--*/
{
    ASSERT(Parent == N->ParentNode);


    GtbpDevIndent( Depth );
    DbgPrint("0x%lx ", N);
    if (ARGUMENT_PRESENT(Low)) {
        DbgPrint("(LowElement): ");
        DumpElement( Low->Element );
    }

    Depth++;

    if (GtbpChildrenAreLeaves(N)) {

        GtbpDevIndent( Depth );
        DumpElement( ((PGTB_TWO_THREE_LEAF)N->FirstChild)->Element );

        if (N->SecondChild != NULL) {
            GtbpDevIndent( Depth );
            DumpElement( ((PGTB_TWO_THREE_LEAF)N->SecondChild)->Element );

            if (N->ThirdChild != NULL) {
                GtbpDevIndent( Depth );
                DumpElement( ((PGTB_TWO_THREE_LEAF)N->ThirdChild)->Element );
            }
        }
    } else {

        GtbpDevDumpNode( N, N->FirstChild, NULL, Depth, DumpElement );

        if (N->SecondChild != NULL) {
            GtbpDevDumpNode( N, N->SecondChild, N->LowOfSecond, Depth, DumpElement );

            if (N->ThirdChild != NULL) {
                GtbpDevDumpNode( N, N->ThirdChild, N->LowOfThird, Depth, DumpElement );
            }
        }
    }

    return;
}


VOID
GtbpDevDumpTwoThreeTree(
    PRTL_GENERIC_TABLE2 Table,
    PGTBP_DEV_DUMP_ELEMENT_ROUTINE  DumpElement
    )
/*++

Routine Description:

    This routine causes the entire 2-3 tree to be dumped.


Arguments:

    Table - The table containing the 2-3 tree to dump.

    DumpElement - A caller supplied routine that may be called
        to dump element values.

Return Value:

    None.

--*/
{
    PLIST_ENTRY
        Next;

    
    DbgPrint("\n\n\n ****    Dump Of Generic Table2 (2-3 tree)    **** \n\n");

    DbgPrint("Table        : 0x%lx\n", Table);
    DbgPrint("Element Count: %d\n", Table->ElementCount);
    

    DbgPrint("\n\nSort Order Of Elements...");

    Next = Table->SortOrderHead.Flink;
    if (Next == &(Table->SortOrderHead)) {
        DbgPrint("Sorted list is empty.\n");
    } else {
    
        while (Next != &(Table->SortOrderHead)) {
            DbgPrint("\n0x%lx: ", Next);
            (*DumpElement)( ((PGTB_TWO_THREE_LEAF)((PVOID)Next))->Element );
            Next = Next->Flink;
        } //end_while
    } //end_if

    DbgPrint("\n\n\nTree Structure...");

    if (Table->Root == NULL) {
        DbgPrint("  Root of table is NULL - no tree present\n");
    } else {

        //
        // Walk the tree first-SubTree, second-SubTree, third-SubTree order
        //

        GtbpDevDumpNode(NULL, Table->Root, NULL, 0, DumpElement);
    }

    DbgPrint("\n\n");


    return;
}



BOOLEAN
GtbpDevValidateLeaf(
    IN     PGTB_TWO_THREE_LEAF  Leaf,
    IN     PLIST_ENTRY          ListHead,
    IN OUT ULONG                *ElementCount,
    IN OUT PLIST_ENTRY          *ListEntry
    )

/*++

Routine Description:

    Validate the specified leaf matches the next leaf in the
    SortOrder list.


Arguments:

    Leaf - Points to the leaf to validate.

    ListHead - Points to the head of the SortOrderList.

    ElementCount - Contains a count of elements already validated.
        This parameter will be incremented by 1 if the leaf is
        found to be valid.
    
    ListEntry - Points to the next element in the SortOrderList.
        This pointer will be updated to point to the next element
        in the list if the leaf is found to be valid.

Return Value:

    TRUE - Leaf is valid.

    FALSE - Leaf is not valid.

--*/
{

    if ((*ListEntry) == ListHead) {
        GtbpDiagPrint( VALIDATE,
                       ("GTB: Exhausted entries in SortOrderList while there are still\n"
                        "     entries in the tree.\n"));
    }


    if ((PVOID)Leaf == (PVOID)(*ListEntry)) {
        (*ElementCount)++;
        (*ListEntry) = (*ListEntry)->Flink;
        return(TRUE);
    } else {
        GtbpDiagPrint( VALIDATE,
                       ("GTB: Tree leaf doesn't match sort order leaf.\n"
                        "         Tree Leaf      : 0x%lx\n"
                        "         sort order leaf: 0x%lx\n",
                        Leaf, (*ListEntry)));
        return(FALSE);
    }
}


BOOLEAN
GtbpDevValidateTwoThreeSubTree(
    IN     PGTB_TWO_THREE_NODE  Node,
    IN     PLIST_ENTRY          ListHead,
    IN OUT ULONG                *ElementCount,
    IN OUT PLIST_ENTRY          *ListEntry
    )

/*++

Routine Description:

    Validate the specified subtree of a 2-3 tree.

    The ParentNode of the tree is expected to already have been
    validated by the caller of this routine.


Arguments:

    Node - Pointer to the root node of the subtree to validate.
    Validate the specified leaf matches the next leaf in the
    SortOrder list.


Arguments:

    Leaf - Points to the leaf to validate.

    ListHead - points to the SortOrderList's listhead.

    ElementCount - Contains a count of elements already validated.
        This parameter will be incremented by the number of elements
        in this subtree.

    ListEntry - Points to the next element in the SortOrderList.
        This pointer will be updated as elements are encountered and
        compared to the elements in the SortOrderList.

Return Value:

    TRUE - SubTree structure is valid.

    FALSE - SubTree structure is not valid.

--*/
{

    BOOLEAN
        Result;


    //
    // Must have at least two children unless we are the root node.
    //

    if (Node->ParentNode != NULL) {
        if  (Node->SecondChild == NULL)  {
            GtbpDiagPrint( VALIDATE,
                           ("GTB: Non-root node has fewer than two children.\n"
                            "         Node       : 0x%lx\n"
                            "         FirstChild : 0x%lx\n"
                            "         SecondChild: 0x%lx\n"
                            "         ThirdChild : 0x%lx\n",
                            Node, Node->FirstChild, Node->SecondChild,
                            Node->ThirdChild));
            return(FALSE);
        }
    }

    if  (Node->FirstChild == NULL)  {
        GtbpDiagPrint( VALIDATE,
                       ("GTB: Non-root node does not have first child.\n"
                        "         Node       : 0x%lx\n"
                        "         FirstChild : 0x%lx\n"
                        "         SecondChild: 0x%lx\n"
                        "         ThirdChild : 0x%lx\n",
                        Node, Node->FirstChild, Node->SecondChild,
                        Node->ThirdChild));
        return(FALSE);
    }



    if (!GtbpChildrenAreLeaves(Node)) {


        Result = GtbpDevValidateTwoThreeSubTree( Node->FirstChild,
                                                 ListHead,
                                                 ElementCount,
                                                 ListEntry);

        if ( Result && (Node->SecondChild != NULL) ) {
            Result = GtbpDevValidateTwoThreeSubTree( Node->SecondChild,
                                                     ListHead,
                                                     ElementCount,
                                                     ListEntry);
            if ( Result && (Node->ThirdChild != NULL) ) {
                Result = GtbpDevValidateTwoThreeSubTree( Node->ThirdChild,
                                                         ListHead,
                                                         ElementCount,
                                                         ListEntry);
            }
        }

        return(Result);
    }


    //
    // We are at a leaf node
    // Check that we have a SortOrderList entry matching each
    // leaf.
    //

    Result = GtbpDevValidateLeaf( (PGTB_TWO_THREE_LEAF)Node->FirstChild,
                                  ListHead,
                                  ElementCount,
                                  ListEntry);

    if (Result && (Node->SecondChild != NULL)) {
        Result = GtbpDevValidateLeaf( (PGTB_TWO_THREE_LEAF)Node->SecondChild,
                                      ListHead,
                                      ElementCount,
                                      ListEntry);
    if (Result && (Node->ThirdChild != NULL)) {
        Result = GtbpDevValidateLeaf( (PGTB_TWO_THREE_LEAF)Node->ThirdChild,
                                      ListHead,
                                      ElementCount,
                                      ListEntry);
        }
    }

    if (!Result) {
        GtbpDiagPrint( VALIDATE,
                       ("GTB: previous error in child analysis prevents further\n"
                        "     validation of node: 0x%lx\n", Node));
    }

    return(Result);
}

BOOLEAN
GtbpDevValidateGenericTable2(
    PRTL_GENERIC_TABLE2 Table
    )
/*++

Routine Description:

    This routine causes the entire 2-3 tree's structure to be
    validated.

        !!   DOESN'T YET VALIDATE LowOfChild VALUES    !!

Arguments:

    Table - The table containing the 2-3 tree to validate.


Return Value:

    TRUE - Table structure is valid.

    FALSE - Table structure is not valid.

--*/
{
    ULONG
        ElementCount,
        ElementsInList;

    PGTB_TWO_THREE_NODE
        Node;

    PLIST_ENTRY
        ListEntry;

    BOOLEAN
        Result;

    //
    // Walk the tree and the linked list simultaneously.
    // Walk the tree first-child, second-child, third-child
    // order to get ascending values that match the linked list.
    //


    if (Table->ElementCount == 0) {
        if (Table->Root != NULL) {
            GtbpDiagPrint( VALIDATE,
                           ("GTB: ElementCount is zero, but root node is not null.\n"
                            "     Table: 0x%lx     Root: 0x%lx\n", Table, Table->Root));
            Result = FALSE;
        } else {
            return(TRUE);
        }


    } else {
        if (Table->Root == NULL) {
            GtbpDiagPrint( VALIDATE,
                           ("GTB: ElementCount is non-zero, but root node is null.\n"
                            "     Table: 0x%lx    ElementCount: %d\n",
                            Table, Table->ElementCount));
            Result = FALSE;
        }


        if (Table->SortOrderHead.Flink == &Table->SortOrderHead) {
            GtbpDiagPrint( VALIDATE,
                           ("GTB: ElementCount is non-zero, but sort order list is empty.\n"
                            "     Table: 0x%lx    ElementCount: %d\n",
                            Table, Table->ElementCount));
            Result = FALSE;
        }

    }

    if (Result) {

        ListEntry = Table->SortOrderHead.Flink;
        Node = Table->Root;
        
        //
        // Verify parent pointer (responsibility of caller)
        //
        
        if (Node->ParentNode != NULL) {
            GtbpDiagPrint( VALIDATE,
                           ("GTB: Root parent pointer is non-null.\n"
                            "     Table: 0x%lx    Root: 0x%lx    ParentNode: 0x%lx\n",
                            Table, Node, Node->ParentNode));
            Result = FALSE;
        }

        if (Result) {

            ElementCount = 0;
            Result = GtbpDevValidateTwoThreeSubTree( Node,
                                                     &Table->SortOrderHead,
                                                     &ElementCount,
                                                     &ListEntry);
            if (Result) {
            
                ElementsInList = ElementCount;
                while (ListEntry != &Table->SortOrderHead) {
                    ElementsInList++;
                    ListEntry = ListEntry->Flink;
                }
                if ( (ElementCount != Table->ElementCount) ||
                     (ElementsInList != ElementCount) ) {
                    GtbpDiagPrint( VALIDATE,
                                   ("GTB: Table is valid except either the ElementCount doesn't match\n"
                                    "     the number of elements in the table or there were entries on\n"
                                    "     the SortOrderList that weren't in the table.\n"
                                    "           Table           :  0x%lx\n"
                                    "           Root            :  0x%lx\n"
                                    "           ElementCount    :  %d\n"
                                    "           Elements In Tree:  %d\n"
                                    "           Elements In List:  %d\n",
                                        Table, Node, Table->ElementCount,
                                        ElementCount, ElementsInList));
                    Result = FALSE;
                }
            } else {
                GtbpDiagPrint( VALIDATE,
                               ("GTB: previous validation error in table 0x%lx prevents\n"
                                "     further processing.\n", Table));
            }
        }
    }

    if (!Result) {
        DbgBreakPoint();
    }


    return(Result);
}
#endif //GTBP_DEVELOPER_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\extsid.c ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:

    extsid.c

Abstract:

    This file contains routines to support an Extended Sid.

Author:

    Colin Brace    (ColinBr)  27-March-2000

Environment:

    User Mode - Nt


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#include <stdlib.h>
#include <samsrvp.h>
#include <samrpc.h>
#include <samisrv.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Theory of Operation                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// The server side behavoir of the large SID emluation behavoir is governed
// by the contents of the global SampExtendedSidOptions.
//
// Current bit field values are
//
// SAM_EXTENDED_SID_DOMAIN
// SAM_EXTENDED_SID_DOMAIN_COMPAT_1
// SAM_EXTENDED_SID_DOMAIN_COMPAT_2
//
// SAM_EXTENDED_SID_DOMAIN is set whenever the account domain hosts domain
// that is in extended sid mode.  When set, the client will call SamrRidToSid
// to obtain the SID of an account given just the RID.
//
// SAM_EXTENDED_SID_DOMAIN_COMPAT_1 implies the following behavoir:
//
// 1. the NET API client should return a 0 for the RID in user and group 
//    information levels that return a rid
//
// 2. that SAM clients older than SAM_NETWORK_REVISION_3 will not be allowed
//    to connect if the account domain is in extended sid mode
//
// 3. that SAM clients will not be able to write to the primary group id
//    attribute
//
// SAM_EXTENDED_SID_DOMAIN_COMPAT_2 implies the following behavoir:
//
// 1. the NET API client should return ERROR_NOT_SUPPORTED for information
//    levels that return a rid
//
// 2. that SAM clients older than SAM_NETWORK_REVISION_3 will not be allowed
//    to connect if the account domain is in extended sid mode
//
// 3. that SAM clients will not be able to write to the primary group id
//    attribute
//
//
//
// Until large SID support is supported, applications can put a server in 
// "Emulation Mode" via a registry key. This causes the SAM server to behavoir
// as if the account domain is in ExtendedSid mode but the account doesn't
// really allocate SID's in a large sid fashion.  This emulation is controlled
// by the registry key ExtendedSidEmulationMode: a value of 1 indicates
// compatibility mode 1; a value of 2 indicates  compatibility mode 2; any other
// value is ignored.
//
//
// For more details, see the Extending the Rid spec.
//
//

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private declarations                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD SampExtendedSidOptions;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Routines                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
SamrRidToSid(
    IN  SAMPR_HANDLE  ObjectHandle,
    IN  ULONG         Rid,
    OUT PRPC_SID     *Sid
    )
/*++

Description:

    This routine translates the "temporary" Rid of an account to its actual
    Sid.

Parameters:

    ObjectHandle -- the SAM handle from which the RID was obtained
    
    Rid          -- the "temporary" ID of the account
    
    Sid          -- on success, the SID of the account

Return Values:

    STATUS_SUCCESS - The service completed successfully.
    
    STATUS_NOT_FOUND -- no such RID could be located
    
    other NT resource errors

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus;

    PSAMP_OBJECT            Context = (PSAMP_OBJECT) ObjectHandle;
    PSAMP_DEFINED_DOMAINS   Domain = NULL;
    SAMP_OBJECT_TYPE        ObjectType;

    BOOLEAN fLock = FALSE;
    BOOLEAN fContext = FALSE;

    if (NULL == Sid) {
        return STATUS_INVALID_PARAMETER;
    }

   
    //
    // RPC gaurentees a non-NULL context
    //              
    ASSERT( Context );

    //
    // Acquire the read lock
    //
    SampMaybeAcquireReadLock(Context,
                             DEFAULT_LOCKING_RULES, 
                             &fLock);

    NtStatus = SampLookupContext(
                   Context,
                   0,                     // No special access necessary
                   SampUnknownObjectType, // ExpectedType
                   &ObjectType
                   );

    if ( !NT_SUCCESS(NtStatus) ) {
        goto Cleanup;
    }
    fContext = TRUE;

    switch (ObjectType) 
    {
    case SampDomainObjectType:
    case SampGroupObjectType:
    case SampAliasObjectType:
    case SampUserObjectType:
        // These are valid object types for this call
        break;
    default: 
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Note: no security check is necessary -- the security check required
    // to obtain a handle is sufficient
    //

    //
    // Now that we have a good SAM handle, find the related Domain sid
    //
    Domain = &SampDefinedDomains[ Context->DomainIndex ];
    ASSERT(RtlValidSid(Domain->Sid));

    NtStatus = SampCreateFullSid(Domain->Sid,
                                 Rid,
                                 (PSID)Sid);

Cleanup:

    if ( fContext ) {
        IgnoreStatus = SampDeReferenceContext( Context, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    SampMaybeReleaseReadLock(fLock);

    return NtStatus;
}

VOID
SampInitEmulationSettings(
    IN HKEY LsaKey 
    )
/*++

Description:

    This routine reads some configuration information from the registry to
    determine if SAM should behave in extended SID emulation.
    
Parameters:

    LsaKey -- an open key to Control\LSA
    
Return Values:

    None.
    
--*/
{
    DWORD WinError = ERROR_SUCCESS;
    DWORD dwSize, dwValue, dwType;
    DWORD TempValue = 0;

    dwSize = sizeof(dwValue);
    WinError = RegQueryValueExA(LsaKey,
                                "ExtendedSidEmulationMode",
                                NULL,
                                &dwType,
                                (LPBYTE)&dwValue,
                                &dwSize);
    if ((ERROR_SUCCESS == WinError) && 
        (REG_DWORD == dwType)) {

        TempValue |= SAM_EXTENDED_SID_DOMAIN;
        if ( dwValue == 1 ) {
            TempValue |= SAM_EXTENDED_SID_DOMAIN_COMPAT_1;
        } else if ( dwValue == 2 ) {
            TempValue |= SAM_EXTENDED_SID_DOMAIN_COMPAT_2;
        } else {
            // Wierd value
            TempValue = 0;
        }
    }

    //
    // Set the global value
    //
    SampExtendedSidOptions = TempValue;


    //
    // Reset the values on SampDefinedDomains
    //
    if (SampServiceState == SampServiceEnabled) {
        ULONG Index;

        for (Index = 0; Index < SampDefinedDomainsCount; Index++) {
            if (!SampDefinedDomains[Index].IsBuiltinDomain) {
                //
                // Note -- when the extended SID support is complete, this will be
                // replaced with domain wide state, not a registry setting
                //
                SampDefinedDomains[Index].IsExtendedSidDomain = SampIsExtendedSidModeEmulated(NULL);
            }
        }
    }


    return;
}

BOOLEAN
SampIsExtendedSidModeEmulated(
    IN ULONG *Mode OPTIONAL
    )
/*++

Description:

    This routine reads some configuration information from the registry to
    determine if SAM should behave in extended SID emulation.
    
Parameters:

    Mode -- set to the specific emulation mode 
    
Return Values:

    TRUE if in emulation mode; FALSE otherwise
    
--*/
{
    if ( Mode ) {
        *Mode = SampExtendedSidOptions;
    }

    return !!(SampExtendedSidOptions & SAM_EXTENDED_SID_DOMAIN);
}


BOOLEAN
SamIIsExtendedSidMode(
    SAMPR_HANDLE ObjectHandle
    )
/*++

Description:

    This routine is exported outside the DLL for other security DLL's to 
    know what emulation mode we are in.           
    
Parameters:

    ObjectHandle -- a non-server SAM handle                           
    
Return Values:

    TRUE if object is from an extended SID domain
    
    FALSE otherwise
    
--*/
{
    PSAMP_OBJECT Context = (PSAMP_OBJECT)ObjectHandle;
    ASSERT( NULL != Context );
    ASSERT( Context->ObjectType != SampServerObjectType );

    return SampIsContextFromExtendedSidDomain(Context);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\enckey.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997-1997
//
// File:        enckey.h
//
// Contents:    Password based key encryption/decryption library.
//
// History:     17-Apr-97      terences created
//
//---------------------------------------------------------------------------



// consts

#define KE_KEY_SIZE     16
#define KE_CUR_VERSION  1

#define MAGIC_CONST_1   "0123456789012345678901234567890123456789"
#define MAGIC_CONST_2   "!@#$%^&*()qwertyUIOPAzxcvbnmQQQQQQQQQQQQ)(*@&%"

// error codes

#define KE_OK           0
#define KE_FAIL         1
#define KE_BAD_PASSWORD 2

typedef struct _EncKey {
    DWORD   dwVersion;      // 00000001 = 128 bit RC4
    DWORD   dwLength;       // = sizeof(KEEncKey)
    BYTE    Salt[16];       // 16 bytes of random salt
    BYTE    EncKey[KE_KEY_SIZE];     // Key encrypted with PW + Salt
    BYTE    Confirm[16];    // MD5(Key) encrypted with PW+Salt
} KEEncKey;

typedef struct _ClearKey {
    DWORD   dwVersion;          // 00000001 = 128 bit plain key
    DWORD   dwLength;           // = sizeof(KEClearKey)
    BYTE    ClearKey[KE_KEY_SIZE];   // 128 bits of key data
} KEClearKey;

// --------------------------------------------
// EncryptKey
//
//  Caller passes in hash of unicode password, struct to get the enc key,
//  and struct to get the clear key.
//  The hash of the password is passed in a KEClearKey struct so that this
//  can be changed in the future.
//
//  EncryptKey generates a random salt, random key, builds the encryption
//  structure, and returns the clear key.
//
//  WARNING:  Eat the clear key as soon after use as possible!
//
//      return code:
//          always returns success

DWORD
KEEncryptKey(
    IN KEClearKey       *pszPassword,
    OUT KEEncKey        *pEncBlock,
    OUT KEClearKey      *pSAMKey,
    IN DWORD            dwFlags);

//---------------------------------------------
// DecryptKey
//
//  Caller passes in hash of unicode password, enc key struct, struct to
//  get the clear key
//
//  DecryptKey will return the clear key if the password matches.
//
//  return codes:
//      KE_BAD_PASSWORD     Password will not decrypt key
//      KE_OK               Password decrypted key

DWORD KEDecryptKey(
    IN KEClearKey       *pszPassword,
    IN KEEncKey     *pEncBlock,
    OUT KEClearKey      *pSAMKey,
    IN DWORD            dwFlags);

//---------------------------------------------
// ChangeKey
//
//  Caller passes in hash of old unicode password, hash of new password,
//  enc key struct, enc key struct is reencrypted with the new password.
//
//  return codes:
//      KE_BAD_PASSWORD     Password will not decrypt key
//      KE_OK               Password decrypted key

DWORD KEChangeKey(
    IN KEClearKey       *pOldPassword,
    IN KEClearKey       *pNewPassword,
    IN OUT KEEncKey     *pEncBlock,
    IN DWORD            dwFlags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\global.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    global.c

Abstract:

    This file contains global variables for the SAM server program.

    Note: There are also some global variables in the files generated
          by the RPC midl compiler.  These variables start with the
          prefix "samr_".

Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:

    08-Oct-1996 ChrisMay
        Added global flag SampUseDsData for crash recovery.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



#if SAMP_DIAGNOSTICS
//
// SAM Global Controls - see flags in samsrvp.h
//

ULONG SampGlobalFlag = 0;
#endif //SAMP_DIAGNOSTICS


//
// Internal data structure and Registry database synchronization lock
//
// The SampTransactionWithinDomainGlobal field is used to track whether a
// lock held for exclusive WRITE access is for a transaction within
// a single domain.  If so, then SampTransactionDomainIndex contains
// the index into SampDefinedDomains of the domain being modified.
//

RTL_RESOURCE SampLock;
BOOLEAN SampTransactionWithinDomainGlobal;
ULONG SampTransactionDomainIndexGlobal;


//
// This critical section is used to protect SampContextListHead (double link list) - active context list
// 

RTL_CRITICAL_SECTION    SampContextListCritSect;

//
// This critical section is used to protect SampAccounttNameTable
// 

RTL_CRITICAL_SECTION    SampAccountNameTableCriticalSection;
PRTL_CRITICAL_SECTION   SampAccountNameTableCritSect;


RTL_GENERIC_TABLE2      SampAccountNameTable;

//
// Set limit on number of contexts a non-trusted client can open
// 

RTL_GENERIC_TABLE2      SampActiveContextTable;
RTL_CRITICAL_SECTION    SampActiveContextTableLock; 

//
// The type of product this SAM server is running in
//

NT_PRODUCT_TYPE SampProductType;

//
// SampUseDsData is TRUE whenever SAM reads or writes data from/to the
// directory service. It is set to FALSE whenever the data resides in the
// registry. Under normal operation, a domain controller always references
// data in the DS, while workstations and member servers reference data
// in the registry. Additionally, in the event of a DS failure (such as
// a problem starting or accessing the DS), a DC will fall back to using
// the registry in order to allow an administrator to logon and repair the
// DS.
//

BOOLEAN SampUseDsData = FALSE;

//
// SampRidManager Initialized is used to keep track of the state of
// the Rid manager. When the Rid manager has been successfully initilized
// this variable is set to true. Else it is set to false
//
BOOLEAN SampRidManagerInitialized = FALSE;


//
// Used to indicate whether the SAM service is currently processing
// normal client calls.  If not, then trusted client calls will still
// be processed, but non-trusted client calls will be rejected.
//

//
// SAM Service operation states.
// Valid state transition diagram is:
//
//    Initializing ----> Enabled <====> Disabled ---> Shutdown -->Terminating
//                               <====> Demoted  ---> Shutdown -->Terminating
//
// Explicitly initialize it to 0 (none of the above values, the valid value
// start from 1).
// 


SAMP_SERVICE_STATE SampServiceState = 0;


//
// This boolean is set to TRUE if the LSA auditing policy indicates
// account auditing is enabled.  Otherwise, this will be FALSE.
//
// This enables SAM to skip all auditing processing unless auditing
// is currently enabled.
//

BOOLEAN SampSuccessAccountAuditingEnabled;
BOOLEAN SampFailureAccountAuditingEnabled;


//
// This is a handle to the root of the SAM backstore information in the
// registry.   This is the level at which the RXACT information is
// established.  This key can not be closed if there are any SERVER object
// context blocks active.
// ("SAM")
//

HANDLE SampKey;


//
// This is the pointer to the RXactContext structure that will be created
// when RXact is initialized.  It must be passed into each RXact call.
//

PRTL_RXACT_CONTEXT SampRXactContext;


//
// Keep a list of server and domain contexts
//

LIST_ENTRY SampContextListHead;

//
// This array contains information about each domain known to this
// SAM server.  Reference and Modification of this array is protected
// by the SampLock.
//

ULONG SampDefinedDomainsCount=0;
PSAMP_DEFINED_DOMAINS SampDefinedDomains=NULL;





//
// Object type-independent information for each of the various
// SAM defined objects.
// This information is READ-ONLY once initialized.

SAMP_OBJECT_INFORMATION SampObjectInformation[ SampUnknownObjectType ];






//
//  Address of DLL routine to do password filtering.
//

//PSAM_PF_PASSWORD_FILTER    SampPasswordFilterDllRoutine;



//
// Unicode strings containing well known registry key names.
// These are read-only values once initialized.
//

UNICODE_STRING SampNameDomains;
UNICODE_STRING SampNameDomainGroups;
UNICODE_STRING SampNameDomainAliases;
UNICODE_STRING SampNameDomainAliasesMembers;
UNICODE_STRING SampNameDomainUsers;
UNICODE_STRING SampNameDomainAliasesNames;
UNICODE_STRING SampNameDomainGroupsNames;
UNICODE_STRING SampNameDomainUsersNames;
UNICODE_STRING SampCombinedAttributeName;
UNICODE_STRING SampFixedAttributeName;
UNICODE_STRING SampVariableAttributeName;



//
// A plethora of other useful characters or strings
//

UNICODE_STRING SampBackSlash;           // "/"
UNICODE_STRING SampNullString;          // Null string
UNICODE_STRING SampSamSubsystem;        // "Security Account Manager"
UNICODE_STRING SampServerObjectName;    // Name of root SamServer object


//
// Useful times
//

LARGE_INTEGER SampImmediatelyDeltaTime;
LARGE_INTEGER SampNeverDeltaTime;
LARGE_INTEGER SampHasNeverTime;
LARGE_INTEGER SampWillNeverTime;

//
// checked build only. If CurrentControlSet\Control\Lsa\UpdateLastLogonTSByMinute
// is set, the value of LastLogonTimeStampSyncInterval will be a "unit" by minute
// instead of "days", which helps to test this feature.   So checked build only.
// 

#if DBG
BOOLEAN SampLastLogonTimeStampSyncByMinute = FALSE;
#endif 

//
// Useful encryption constants
//

LM_OWF_PASSWORD SampNullLmOwfPassword;
NT_OWF_PASSWORD SampNullNtOwfPassword;


//
// Useful Sids
//

PSID SampWorldSid;
PSID SampAnonymousSid;
PSID SampLocalSystemSid;
PSID SampAdministratorUserSid;
PSID SampAdministratorsAliasSid;
PSID SampAccountOperatorsAliasSid;
PSID SampAuthenticatedUsersSid;
PSID SampPrincipalSelfSid;
PSID SampBuiltinDomainSid;
PSID SampNetworkSid;
PSID SampDomainAdminsGroupSid;
PSID SampEnterpriseDomainControllersSid;
PSID SampNetworkServiceSid;


//
//  Variables for the thread that flushes changes to the registry.
//
//  LastUnflushedChange - if there are no changes to be flushed, this
//      has a value of "Never".  If there are changes to be flushed,
//      this is the time of the last change that was made.  The flush
//      thread will flush if a SampFlushThreadMinWaitSeconds has passed
//      since the last change.
//
//  FlushThreadCreated - set TRUE as soon as the flush thread is created,
//      and FALSE when the thread exits.  A new thread will be created
//      when this is FALSE, unless FlushImmediately is TRUE.
//
//  FlushImmediately - an important event has occurred, so we want to
//      flush the changes immediately rather than waiting for the flush
//      thread to do it.  LastUnflushedChange should be set to "Never"
//      so the flush thread knows it doesn't have to flush.
//

LARGE_INTEGER LastUnflushedChange;
BOOLEAN FlushThreadCreated;
BOOLEAN FlushImmediately;

//
// These should probably be #defines, but we want to play with them.
//
//  SampFlushThreadMinWaitSeconds - The unit of time that the flush thread
//      waits.  If one of these has passed since the last unflushed change,
//      the changes will be flushed.
//
//  SampFlushThreadMaxWaitSeconds - If this amount of time has passed since
//      the flush thread was created or last flushed, the thread will force
//      a flush even if the database is still being changed.
//
//  SampFlushThreadExitDelaySeconds - How long the flush thread waits
//      around after a flush to see if any more changes occur.  If they
//      do, it starts waiting again; but if they don't, it will exit
//      to keep down thread overhead.
//

LONG   SampFlushThreadMinWaitSeconds;
LONG   SampFlushThreadMaxWaitSeconds;
LONG   SampFlushThreadExitDelaySeconds;

//
// Special SIDs
//

PSID SampBuiltinDomainSid = NULL;
PSID SampAccountDomainSid = NULL;


//
// Null token handle.  This is used when clients connect via unauthenticated
// RPC instead of authenticated RPC or named pipes.  Since they can't be
// authenticated, we impersonate this pre-built Null sesssion token.
//

HANDLE SampNullSessionToken;

//
// Flag indicating whether Netware server installed.
//

BOOLEAN SampNetwareServerInstalled = FALSE;

//
// Flag indicating whether to start listening on TCP/IP
//

BOOLEAN SampIpServerInstalled = FALSE;

//
// Flag indicating whether to start listening on apple talk
//

BOOLEAN SampAppletalkServerInstalled = FALSE;

//
// Flag indicating whether to start listening on Vines
//

BOOLEAN SampVinesServerInstalled = FALSE;

//
// Session key for encrypting all secret (sensitive data).
//

UCHAR SampSecretSessionKey[SAMP_SESSION_KEY_LENGTH];
UCHAR SampSecretSessionKeyPrevious[SAMP_SESSION_KEY_LENGTH];


//
// Flag indicating whether or not secret encryption is enabled
//

BOOLEAN SampSecretEncryptionEnabled = FALSE;

//
// Flag indicating whether or not upgrade is in process so as to allow
// calls to succeed.
//

BOOLEAN SampUpgradeInProcess;

//
// Flag indicating whether current global lock is for read or write.
// Used by dslayer routines to optimize DS transaction.
//

SAMP_DS_TRANSACTION_CONTROL SampDsTransactionType = TransactionWrite;
BOOLEAN SampLockHeld = FALSE;


//
// This flag is TRUE when DS failed to initialize. 
// SAM use it to display correct error message, saying "Directory Service 
// can not start..."
// 

BOOLEAN SampDsInitializationFailed = FALSE;


//
// This flag is TRUE when the DS has been successfully initialized
//

BOOLEAN SampDsInitialized = FALSE;

//
// Global pointer (to heap memory) to store DSNAME of the (single) authoritative
// domain name
//

DSNAME *RootObjectName = NULL;


//
// Variable to hold the Server Object's Name
//

DSNAME * SampServerObjectDsName = NULL;

//
// SAM Trace Levels, disable tracing by default. See dbgutilp.h for the
// details of how to enable tracing from the debugger. These flags are
// used for runtime debugging.
//

ULONG SampTraceTag = 0;
ULONG SampTraceFileTag = 0;




//
// Flags to determine if particular containers which were added piecemeal in 
// the development cycle exist.
//
BOOLEAN SampDomainControllersOUExists = TRUE;
BOOLEAN SampUsersContainerExists = TRUE;
BOOLEAN SampComputersContainerExists = TRUE;


//
// 
// Global pointer (to heap memory) to store well known container's 
// distinguished name
//
DSNAME * SampDomainControllersOUDsName = NULL;
DSNAME * SampUsersContainerDsName = NULL;
DSNAME * SampComputersContainerDsName = NULL;
DSNAME * SampComputerObjectDsName = NULL;



//
// Global Set at startup to determine whether we have a hard/soft attitude
// to GC downs
//
BOOLEAN SampIgnoreGCFailures = FALSE;

//
// This flag indicates that we should not store the LM hash. This is based
// upon a registry key setting.
//

BOOLEAN SampNoLmHash = FALSE;

//
// Flag to indicate NT4 PDC upgrade is in progressing
// 
//
BOOLEAN SampNT4UpgradeInProgress = FALSE;

//
// This flag indicates whether null sessions (world) should be allowed to
// list users in the domain and members of groups.
//

BOOLEAN SampRestrictNullSessions;

//
// This flag when set disables netlogon notifications
//

BOOLEAN SampDisableNetlogonNotification = FALSE;

//
// This flag indicates whether or not to enforce giving site affinity to
// clients outside our site by looking at the client's IP address.
//
BOOLEAN SampNoGcLogonEnforceKerberosIpCheck = FALSE;

//
// This flag indicates whether or not to enforce that only interactive
// logons via NTLM are to be given site affinity
//
BOOLEAN SampNoGcLogonEnforceNTLMCheck = FALSE;

//
// This flags indicates whether or not to replicate password set/change
// operations urgently.
//
BOOLEAN SampReplicatePasswordsUrgently = FALSE;

//
// This flag is enabled in personal and can be enabled in professional
// machines to force network access to guest account levels.
//
BOOLEAN SampForceGuest = FALSE;

//
// This flag indicates whether or not the local machine is joined to a domain
// 
BOOLEAN SampIsMachineJoinedToDomain = FALSE;

//
// This flag tells if we are running Personal SKU
// 
BOOLEAN SampPersonalSKU = FALSE;

//
// This flag is enabled in personal and can be enabled in professional
// machines to limit password changes where existing password on an account
// is a blank password
//
BOOLEAN SampLimitBlankPasswordUse = FALSE;

//
// This flag is used to control what gets printed to the sam.log file
// for deployment diagnostics.
//
ULONG SampLogLevel = 0;

//
// Globals to maintain state on Key IDs
//

ULONG SampCurrentKeyId;
ULONG SampPreviousKeyId;

//
// This flag controls SAM's behavior with respect to Account Lockout.
// When on, the act of an account being locked out will be audited but the 
// account won't actually be locked out.
//
BOOLEAN SampAccountLockoutTestMode = FALSE;

//
// This flag is set to TRUE when the appropriate Domain Operation GUID
// is created in the DomainUpdates container in the DS.  The operation
// indicates that all computer objects are correctly ACL'ed for netjoin
// to work, thus SAM no longer needs to grant extra access on computer
// objects for thier effective owner.
//
BOOLEAN SampComputerObjectACLApplied = FALSE;


//
// This flag controls the single object replication that can occur when 
// an authentication fails locally, but succeeds at the PDC
//
BOOLEAN SampDisableSingleObjectRepl = FALSE;


//
// This global variable controls how SAM restricts OWF password change API.
// 
// 0 - old behavior, client can change password through OWF password change API,
//     and the new password remains unexpired.
// 
// 1 - .NET Server default behavior, client can change password through 
//     OWF password change API (SamrChangePasswordUser), but the password
//     expires immediately.
// 
// 2 - more secure behavior, client cann't use OWF password change API.
//     this API (SamrChangePasswordUser) will be totally shutted down.
//
// Default value for .NET server is 1. 
// 
// The value of this global variable will be based on REGISTRY KEY setting
// System\\CurrentControlSet\\Control\\Lsa\\SamRestrictOwfPasswordChange 
//
// 
// NOTE: All restrictions are NOT applied to SYSTEM or members of Builtin 
//       Administrators Alias Group.
//
ULONG   SampRestrictOwfPasswordChange = 1;

//
// This flag indicates whether the default objects and memberships needed 
// WS03 exist.  Note, future releases can benefit by making this a revision
// instead of a flag.
//
BOOLEAN SampWS03DefaultsApplied = FALSE;



//
// Latency counters
//
SAMP_LATENCY SampResourceGroupsLatencyInfo;
SAMP_LATENCY SampAccountGroupsLatencyInfo;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\group.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    group.c

Abstract:

    This file contains services related to the SAM "group" object.


Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <msaudite.h>
#include <dslayer.h>
#include <dsmember.h>
#include <ridmgr.h>
#include <malloc.h>
#include <dsevent.h>
#include <gcverify.h>
#include <attids.h>
#include <samtrace.h>
#include "validate.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampDeleteGroupKeys(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampReplaceGroupMembers(
    IN PSAMP_OBJECT GroupContext,
    IN ULONG MemberCount,
    IN PULONG Members
    );

NTSTATUS
SampAddAccountToGroupMembers(
    IN PSAMP_OBJECT GroupContext,
    IN ULONG UserRid,
    IN DSNAME * MemberDsName OPTIONAL
    );

NTSTATUS
SampRemoveAccountFromGroupMembers(
    IN PSAMP_OBJECT GroupContext,
    IN ULONG AccountRid,
    IN DSNAME * MemberDsName OPTIONAL
    );


NTSTATUS
SampRemoveMembershipGroup(
    IN ULONG GroupRid,
    IN ULONG MemberRid,
    IN SAMP_MEMBERSHIP_DELTA AdminGroup,
    IN SAMP_MEMBERSHIP_DELTA OperatorGroup
    );

NTSTATUS
SampAddSameDomainMemberToGlobalOrUniversalGroup(
    IN  PSAMP_OBJECT AccountContext,
    IN  ULONG        MemberId,
    IN  ULONG        Attributes,
    IN  DSNAME       *MemberDsName OPTIONAL
    );

NTSTATUS
SampRemoveSameDomainMemberFromGlobalOrUniversalGroup(
    IN  PSAMP_OBJECT AccountContext,
    IN  ULONG        MemberId,
    IN  DSNAME       *MemberDsName OPTIONAL
    );




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Exposed RPC'able Services                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////






NTSTATUS
SamrOpenGroup(
    IN SAMPR_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG GroupId,
    OUT SAMPR_HANDLE *GroupHandle
    )

/*++

Routine Description:

    This API opens an existing group in the account database.  The group
    is specified by a ID value that is relative to the SID of the
    domain.  The operations that will be performed on the group must be
    declared at this time.

    This call returns a handle to the newly opened group that may be
    used for successive operations on the group.  This handle may be
    closed with the SamCloseHandle API.



Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the group.  These access types are reconciled
        with the Discretionary Access Control list of the group to
        determine whether the accesses will be granted or denied.

    GroupId - Specifies the relative ID value of the group to be
        opened.

    GroupHandle - Receives a handle referencing the newly opened
        group.  This handle will be required in successive calls to
        operate on the group.

Return Values:

    STATUS_SUCCESS - The group was successfully opened.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_NO_SUCH_GROUP - The specified group does not exist.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.

--*/
{
    NTSTATUS            NtStatus;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrOpenGroup");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidOpenGroup
                   );


    NtStatus = SampOpenAccount(
                   SampGroupObjectType,
                   DomainHandle,
                   DesiredAccess,
                   GroupId,
                   FALSE,
                   GroupHandle
                   );


    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidOpenGroup
                   );

    return(NtStatus);
}


NTSTATUS
SamrQueryInformationGroup(
    IN SAMPR_HANDLE GroupHandle,
    IN GROUP_INFORMATION_CLASS GroupInformationClass,
    OUT PSAMPR_GROUP_INFO_BUFFER *Buffer
    )

/*++

Routine Description:

    This API retrieves information on the group specified.



Parameters:

    GroupHandle - The handle of an opened group to operate on.

    GroupInformationClass - Class of information to retrieve.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        -----------------------         ----------------------

        GroupGeneralInformation         GROUP_READ_INFORMATION
        GroupNameInformation            GROUP_READ_INFORMATION
        GroupAttributeInformation       GROUP_READ_INFORMATION
        GroupAdminInformation           GROUP_READ_INFORMATION

    Buffer - Receives a pointer to a buffer containing the requested
        information.  When this information is no longer needed, this
        buffer must be freed using SamFreeMemory().

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

--*/
{

    NTSTATUS                NtStatus;
    NTSTATUS                IgnoreStatus;
    PSAMP_OBJECT            AccountContext;
    SAMP_OBJECT_TYPE        FoundType;
    ACCESS_MASK             DesiredAccess;
    ULONG                   i;
    SAMP_V1_0A_FIXED_LENGTH_GROUP V1Fixed;

    //
    // Used for tracking allocated blocks of memory - so we can deallocate
    // them in case of error.  Don't exceed this number of allocated buffers.
    //
    PVOID                   AllocatedBuffer[10];
    ULONG                   AllocatedBufferCount = 0;
    BOOLEAN                 fLockAcquired = FALSE;
    DECLARE_CLIENT_REVISION(GroupHandle) ;

    SAMTRACE_EX("SamrQueryInformationGroup");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidQueryInformationGroup
                   );

    #define RegisterBuffer(Buffer)                                      \
        {                                                               \
            if ((Buffer) != NULL) {                                     \
                                                                        \
                ASSERT(AllocatedBufferCount <                           \
                       sizeof(AllocatedBuffer) / sizeof(*AllocatedBuffer)); \
                                                                        \
                AllocatedBuffer[AllocatedBufferCount++] = (Buffer);     \
            }                                                           \
        }

    #define AllocateBuffer(NewBuffer, Size)                             \
        {                                                               \
            (NewBuffer) = MIDL_user_allocate(Size);                     \
            RegisterBuffer(NewBuffer);                                  \
        }                                                               \


    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (Buffer != NULL);
    ASSERT ((*Buffer) == NULL);

    if (!((Buffer!=NULL)&&(*Buffer==NULL)))
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }


    //
    // Set the desired access based upon the Info class
    //

    switch (GroupInformationClass) {

    case GroupGeneralInformation:
    case GroupNameInformation:
    case GroupAttributeInformation:
    case GroupAdminCommentInformation:
    case GroupReplicationInformation:

        DesiredAccess = GROUP_READ_INFORMATION;
        break;

    default:
        (*Buffer) = NULL;
        NtStatus = STATUS_INVALID_INFO_CLASS;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    } // end_switch





    //
    // Allocate the info structure
    //

    (*Buffer) = MIDL_user_allocate( sizeof(SAMPR_GROUP_INFO_BUFFER) );
    if ((*Buffer) == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }

    RegisterBuffer(*Buffer);


    //
    // Acquire the Read lock if necessary
    //

    AccountContext = (PSAMP_OBJECT)GroupHandle;
    SampMaybeAcquireReadLock(AccountContext,
                             DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                             &fLockAcquired);

    //
    // Validate type of, and access to object.
    //


    NtStatus = SampLookupContext(
               AccountContext,
               DesiredAccess,
               SampGroupObjectType,           // ExpectedType
               &FoundType
               );


    if (NT_SUCCESS(NtStatus)) {


        //
        // If the information level requires, retrieve the V1_FIXED record
        // from the registry.
        //

        switch (GroupInformationClass) {

        case GroupGeneralInformation:
        case GroupReplicationInformation:
        case GroupAttributeInformation:

            NtStatus = SampRetrieveGroupV1Fixed(
                           AccountContext,
                           &V1Fixed
                           );
            break; //out of switch

        default:
            NtStatus = STATUS_SUCCESS;

        } // end_switch

        if (NT_SUCCESS(NtStatus)) {

            //
            // case on the type information requested
            //

            switch (GroupInformationClass) {

            case GroupGeneralInformation:
            case GroupReplicationInformation:


                (*Buffer)->General.Attributes  = V1Fixed.Attributes;


                if (GroupGeneralInformation==GroupInformationClass)
                {



                    //
                    // Get the member count
                    //

                    NtStatus = SampRetrieveGroupMembers(
                                   AccountContext,
                                   &(*Buffer)->General.MemberCount,
                                   NULL                                 // Only need members
                                );
                }
                else
                {
                    //
                    // Do not query the member count. Netlogon will get this
                    // while querying the group membership ( Saves redundant
                    // computation
                    //

                    (*Buffer)->General.MemberCount=0;
                }


                if (NT_SUCCESS(NtStatus)) {


                    //
                    // Get copies of the strings we must retrieve from
                    // the registry.
                    //

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_GROUP_NAME,
                                   TRUE,    // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->General.Name)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->General.Name.Buffer);

                        NtStatus = SampGetUnicodeStringAttribute(
                                       AccountContext,
                                       SAMP_GROUP_ADMIN_COMMENT,
                                       TRUE,    // Make copy
                                       (PUNICODE_STRING)&((*Buffer)->General.AdminComment)
                                       );

                        if (NT_SUCCESS(NtStatus)) {

                            RegisterBuffer((*Buffer)->General.AdminComment.Buffer);
                        }
                    }
                }


                break;


            case GroupNameInformation:

                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_GROUP_NAME,
                               TRUE,    // Make copy
                               (PUNICODE_STRING)&((*Buffer)->Name.Name)
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->Name.Name.Buffer);
                }


                break;


            case GroupAdminCommentInformation:

                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_GROUP_ADMIN_COMMENT,
                               TRUE,    // Make copy
                               (PUNICODE_STRING)&((*Buffer)->AdminComment.AdminComment)
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->AdminComment.AdminComment.Buffer);
                }


                break;


            case GroupAttributeInformation:


                (*Buffer)->Attribute.Attributes  = V1Fixed.Attributes;

                break;

            }   // end_switch


        } // end_if



        //
        // De-reference the object, discarding changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));

    }

    //
    // Free the read lock if necessary
    //


    SampMaybeReleaseReadLock(fLockAcquired);




    //
    // If we didn't succeed, free any allocated memory
    //

    if (!NT_SUCCESS(NtStatus)) {
        for ( i=0; i<AllocatedBufferCount ; i++ ) {
            MIDL_user_free( AllocatedBuffer[i] );
        }

        (*Buffer) = NULL;
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidQueryInformationGroup
                   );

    return(NtStatus);
}



NTSTATUS
SamrSetInformationGroup(
    IN SAMPR_HANDLE GroupHandle,
    IN GROUP_INFORMATION_CLASS GroupInformationClass,
    IN PSAMPR_GROUP_INFO_BUFFER Buffer
    )

/*++

Routine Description:

    This API allows the caller to modify group information.


Parameters:

    GroupHandle - The handle of an opened group to operate on.

    GroupInformationClass - Class of information to retrieve.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        ------------------------        -------------------------

        GroupGeneralInformation         (can't write)

        GroupNameInformation            GROUP_WRITE_ACCOUNT
        GroupAttributeInformation       GROUP_WRITE_ACCOUNT
        GroupAdminInformation           GROUP_WRITE_ACCOUNT

    Buffer - Buffer where information retrieved is placed.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_GROUP - The group specified is unknown.

    STATUS_SPECIAL_GROUP - The group specified is a special group and
        cannot be operated on in the requested fashion.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

--*/
{

    NTSTATUS                NtStatus,
                            TmpStatus,
                            IgnoreStatus;

    PSAMP_OBJECT            AccountContext;

    SAMP_OBJECT_TYPE        FoundType;

    ACCESS_MASK             DesiredAccess;

    SAMP_V1_0A_FIXED_LENGTH_GROUP V1Fixed;

    UNICODE_STRING          OldAccountName,
                            NewAdminComment,
                            NewAccountName,
                            NewFullName;

    ULONG                   ObjectRid,
                            OldGroupAttributes = 0;

    BOOLEAN                 Modified = FALSE,
                            RemoveAccountNameFromTable = FALSE,
                            AccountNameChanged = FALSE;
    DECLARE_CLIENT_REVISION(GroupHandle);

    SAMTRACE_EX("SamrSetInformationGroup");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidSetInformationGroup
                   );

    //
    // Reset any strings that we'll be freeing in clean-up code
    //

    RtlInitUnicodeString(&OldAccountName, NULL);
    RtlInitUnicodeString(&NewAccountName, NULL);
    RtlInitUnicodeString(&NewFullName, NULL);
    RtlInitUnicodeString(&NewAdminComment, NULL);

    //
    // Set the desired access based upon the Info class
    //

    switch (GroupInformationClass) {

    case GroupNameInformation:
    case GroupAttributeInformation:
    case GroupAdminCommentInformation:

        DesiredAccess = GROUP_WRITE_ACCOUNT;
        break;


    case GroupGeneralInformation:
    default:

        NtStatus = STATUS_INVALID_INFO_CLASS;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;

    } // end_switch



    //
    // Grab the lock
    //

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }



    //
    // Validate type of, and access to object.
    //

    AccountContext = (PSAMP_OBJECT)GroupHandle;
    ObjectRid = AccountContext->TypeBody.Group.Rid;
    NtStatus = SampLookupContext(
                   AccountContext,
                   DesiredAccess,
                   SampGroupObjectType,           // ExpectedType
                   &FoundType
                   );


    if( NT_SUCCESS( NtStatus ) ) {

        //
        // Check input parameters
        //

        NtStatus = SampValidateGroupInfoBuffer(
                        Buffer,
                        GroupInformationClass,
                        AccountContext->TrustedClient
                        );

    }

    if (NT_SUCCESS(NtStatus)) {


        //
        // If the information level requires, retrieve the V1_FIXED record
        // from the registry.  This includes anything that will cause
        // us to update the display cache.
        //

        switch (GroupInformationClass) {

        case GroupAdminCommentInformation:
        case GroupNameInformation:
        case GroupAttributeInformation:

            NtStatus = SampRetrieveGroupV1Fixed(
                           AccountContext,
                           &V1Fixed
                           );

            OldGroupAttributes = V1Fixed.Attributes;
            break; //out of switch


        default:
            NtStatus = STATUS_SUCCESS;

        } // end_switch

        if (NT_SUCCESS(NtStatus)) {

            //
            // case on the type information requested
            //

            switch (GroupInformationClass) {

            case GroupNameInformation:

                NtStatus = SampChangeGroupAccountName(
                                AccountContext,
                                (PUNICODE_STRING)&(Buffer->Name.Name),
                                &OldAccountName
                                );
                if (!NT_SUCCESS(NtStatus)) {
                      OldAccountName.Buffer = NULL;
                }

                //
                // RemoveAccountNameFromTable tells us whether
                // the caller (this routine) is responsible
                // to remove the name from the table.
                //
                RemoveAccountNameFromTable =
                    AccountContext->RemoveAccountNameFromTable;

                //
                // Reset to FALSE
                //
                AccountContext->RemoveAccountNameFromTable = FALSE;

                //
                // Don't free OldAccountName yet; we'll need it at the
                // very end.
                //

                AccountNameChanged = TRUE;

                break;


            case GroupAdminCommentInformation:

                //
                // build the key name
                //

                NtStatus = SampSetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_GROUP_ADMIN_COMMENT,
                               (PUNICODE_STRING)&(Buffer->AdminComment.AdminComment)
                               );

                break;


            case GroupAttributeInformation:

                V1Fixed.Attributes = Buffer->Attribute.Attributes;

                NtStatus = SampReplaceGroupV1Fixed(
                           AccountContext,             // ParentKey
                           &V1Fixed
                           );

                break;


            } // end_switch


        }  // end_if


        //
        // Go fetch any data we'll need to update the display cache
        // Do this before we dereference the context
        //

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_GROUP_NAME,
                               TRUE,    // Make copy
                               &NewAccountName
                               );

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_GROUP_ADMIN_COMMENT,
                               TRUE, // Make copy
                               &NewAdminComment
                               );
                //
                // If the account name has changed, then OldAccountName
                // is already filled in. If the account name hasn't changed
                // then the OldAccountName is the same as the new!
                //

                if (NT_SUCCESS(NtStatus) && (OldAccountName.Buffer == NULL)) {

                    NtStatus = SampDuplicateUnicodeString(
                                   &OldAccountName,
                                   &NewAccountName);
                }
            }
        }


        //
        // Dereference the account context
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // De-reference the object, write out any change to current xaction.
            //

            NtStatus = SampDeReferenceContext( AccountContext, TRUE );

        } else {

            //
            // De-reference the object, ignore changes
            //

            TmpStatus = SampDeReferenceContext( AccountContext, FALSE );
            ASSERT(NT_SUCCESS(TmpStatus));
        }



    } //end_if



    //
    // Commit the transaction, update the display cache,
    // and notify netlogon of the changes
    //

    if ( NT_SUCCESS(NtStatus) ) {

        NtStatus = SampCommitAndRetainWriteLock();

        //
        // Generate audit if necessary if still success
        //

        if (NT_SUCCESS(NtStatus) &&
            SampDoAccountAuditing(AccountContext->DomainIndex)) {

            // audit account name change
            if (AccountNameChanged)
            {
                SampAuditAccountNameChange(AccountContext,
                                           (PUNICODE_STRING)&(Buffer->Name.Name),
                                           &OldAccountName
                                           );
            }

            //
            // Generate a general change audit in the registry mode case.
            // In DS mode, the same audit is handled via audit notifications
            // and is processed in SampNotifyAuditChange()
            //
            SampAuditGroupChange(AccountContext->DomainIndex,
                                 AccountContext,
                                 (PVOID)&GroupInformationClass,
                                 FALSE,
                                 &NewAccountName,
                                 &(AccountContext->TypeBody.Group.Rid),
                                 (GROUP_TYPE_SECURITY_ENABLED
                                  | GROUP_TYPE_ACCOUNT_GROUP),
                                 NULL,
                                 FALSE    // Group change
                                 );
        }

        if ( NT_SUCCESS(NtStatus) ) {



            //
            // Update the display information if the cache may be affected
            //

            if ( !IsDsObject(AccountContext) ) {

                SAMP_ACCOUNT_DISPLAY_INFO OldAccountInfo;
                SAMP_ACCOUNT_DISPLAY_INFO NewAccountInfo;

                OldAccountInfo.Name = OldAccountName;
                OldAccountInfo.Rid = ObjectRid;
                OldAccountInfo.AccountControl = OldGroupAttributes;
                RtlInitUnicodeString(&OldAccountInfo.Comment, NULL);
                RtlInitUnicodeString(&OldAccountInfo.FullName, NULL);  // Not used for groups

                NewAccountInfo.Name = NewAccountName;
                NewAccountInfo.Rid = ObjectRid;
                NewAccountInfo.AccountControl = V1Fixed.Attributes;
                NewAccountInfo.Comment = NewAdminComment;
                NewAccountInfo.FullName = NewFullName;

                IgnoreStatus = SampUpdateDisplayInformation(&OldAccountInfo,
                                                            &NewAccountInfo,
                                                            SampGroupObjectType);
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }

            if (AccountContext->TypeBody.Group.SecurityEnabled)
            {

                if ( GroupInformationClass == GroupNameInformation ) {

                    SampNotifyNetlogonOfDelta(
                        SecurityDbRename,
                        SecurityDbObjectSamGroup,
                        ObjectRid,
                        &OldAccountName,
                        (DWORD) FALSE,  // Replicate immediately
                        NULL            // Delta data
                        );

                } else {

                    SampNotifyNetlogonOfDelta(
                        SecurityDbChange,
                        SecurityDbObjectSamGroup,
                        ObjectRid,
                        (PUNICODE_STRING) NULL,
                        (DWORD) FALSE,  // Replicate immediately
                        NULL            // Delta data
                        );
                }
            }


        }
    }


    //
    // Remove the New Account Name from the Global
    // SAM Account Name Table
    //
    if (RemoveAccountNameFromTable)
    {
        IgnoreStatus = SampDeleteElementFromAccountNameTable(
                            (PUNICODE_STRING)&(Buffer->Name.Name),
                            SampGroupObjectType
                            );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Release the write lock
    //

    TmpStatus = SampReleaseWriteLock( FALSE );

    if (NT_SUCCESS(NtStatus)) {
        NtStatus = TmpStatus;
    }


    //
    // Clean up strings
    //

    SampFreeUnicodeString( &OldAccountName );
    SampFreeUnicodeString( &NewAccountName );
    SampFreeUnicodeString( &NewFullName );
    SampFreeUnicodeString( &NewAdminComment );

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidSetInformationGroup
                   );

    return(NtStatus);

}


NTSTATUS
SamrAddMemberToGroup(
    IN SAMPR_HANDLE GroupHandle,
    IN ULONG MemberId,
    IN ULONG Attributes
    )

/*++

Routine Description:

    This API adds a member to a group.  Note that this API requires the
    GROUP_ADD_MEMBER access type for the group.


Parameters:

    GroupHandle - The handle of an opened group to operate on.

    MemberId - Relative ID of the member to add.

    Attributes - The attributes of the group assigned to the user.
        The attributes assigned here may have any value.  However,
        at logon time these attributes are minimized by the
        attributes of the group as a whole.

          Mandatory -    If the Mandatory attribute is assigned to
                    the group as a whole, then it will be assigned to
                    the group for each member of the group.

          EnabledByDefault - This attribute may be set to any value
                    for each member of the group.  It does not matter
                    what the attribute value for the group as a whole
                    is.

          Enabled - This attribute may be set to any value for each
                    member of the group.  It does not matter what the
                    attribute value for the group as a whole is.

          Owner -   If the Owner attribute of the group as a
                    whole is not set, then the value assigned to
                    members is ignored.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.


    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_MEMBER - The member specified is unknown.

    STATUS_MEMBER_IN_GROUP - The member already belongs to the group.

    STATUS_INVALID_GROUP_ATTRIBUTES - Indicates the group attribute
        values being assigned to the member are not compatible with
        the attribute values of the group as a whole.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.




--*/
{

    NTSTATUS         NtStatus, TmpStatus;
    PSAMP_OBJECT     AccountContext;
    SAMP_OBJECT_TYPE FoundType;
    UNICODE_STRING   GroupName;
    DECLARE_CLIENT_REVISION(GroupHandle);

    SAMTRACE_EX("SamrAddMemberToGroup");

    //
    // Do a start type WMI event Trace.
    //

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidAddMemberToGroup
                   );

    SampUpdatePerformanceCounters(
        DSSTAT_MEMBERSHIPCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );

    //
    // Initialize buffers we will cleanup at the end
    //

    RtlInitUnicodeString(&GroupName, NULL);

    //
    // Grab the lock
    //

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto SamrAddMemberToGroupError;
    }

    //
    // Validate type of, and access to object.
    //

    AccountContext = (PSAMP_OBJECT)(GroupHandle);
    NtStatus = SampLookupContext(
                   AccountContext,
                   GROUP_ADD_MEMBER,
                   SampGroupObjectType,           // ExpectedType
                   &FoundType
                   );



    if (NT_SUCCESS(NtStatus)) {


        //
        // Call the worker routine
        //

        NtStatus = SampAddSameDomainMemberToGlobalOrUniversalGroup(
                        AccountContext,
                        MemberId,
                        Attributes,
                        NULL
                        );

        if (NT_SUCCESS(NtStatus)) {

            //
            // Get and save the account name for
            // I_NetNotifyLogonOfDelta.
            //

            NtStatus = SampGetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_GROUP_NAME,
                           TRUE,    // Make copy
                           &GroupName
                           );

            if (!NT_SUCCESS(NtStatus)) {
                RtlInitUnicodeString(&GroupName, NULL);
            }
        }


        //
        // Dereference the account context
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // De-reference the object, write out any change to current xaction.
            //

            NtStatus = SampDeReferenceContext( AccountContext, TRUE );

        } else {

            //
            // De-reference the object, ignore changes
            //

            TmpStatus = SampDeReferenceContext( AccountContext, FALSE );
            ASSERT(NT_SUCCESS(TmpStatus));
        }

        //
        // Commit the transaction and notify net logon of the changes
        //

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampCommitAndRetainWriteLock();

            if (( NT_SUCCESS( NtStatus ) )
                && (AccountContext->TypeBody.Group.SecurityEnabled))
            {

                SAM_DELTA_DATA DeltaData;

                //
                // Fill in id of member being added
                //

                DeltaData.GroupMemberId.MemberRid = MemberId;


                if (AccountContext->TypeBody.Group.SecurityEnabled)
                {
                    SampNotifyNetlogonOfDelta(
                        SecurityDbChangeMemberAdd,
                        SecurityDbObjectSamGroup,
                        AccountContext->TypeBody.Group.Rid,
                        &GroupName,
                        (DWORD) FALSE,      // Replicate immediately
                        &DeltaData
                        );
                }
            }
        }


        //
        // Free up the group name
        //

        SampFreeUnicodeString(&GroupName);

    }

    //
    // Release the Lock
    //


    TmpStatus = SampReleaseWriteLock( FALSE );
    ASSERT(NT_SUCCESS(TmpStatus));

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);


SamrAddMemberToGroupError:

    //
    // Do a WMI end type event trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidAddMemberToGroup
                   );

    return(NtStatus);
}



NTSTATUS
SamrDeleteGroup(
    IN SAMPR_HANDLE *GroupHandle
    )

/*++

Routine Description:

    This API removes a group from the account database.  There may be no
    members in the group or the deletion request will be rejected.  Note
    that this API requires DELETE access to the specific group being
    deleted.


Parameters:

    GroupHandle - The handle of an opened group to operate on.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.  This may be
        because someone has deleted the group while it was open.

    STATUS_SPECIAL_ACCOUNT - The group specified is a special group and
        cannot be operated on in the requested fashion.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{

    UNICODE_STRING          GroupName;
    NTSTATUS                NtStatus, TmpStatus;
    PSAMP_OBJECT            AccountContext = (PSAMP_OBJECT)(*GroupHandle);
    PSAMP_DEFINED_DOMAINS   Domain;
    PSID                    AccountSid=NULL;
    SAMP_OBJECT_TYPE        FoundType;
    PULONG                  PrimaryMembers=NULL;
    BOOLEAN                 fLockAcquired = FALSE;
    ULONG                   MemberCount,
                            ObjectRid,
                            DomainIndex,
                            PrimaryMemberCount=0;
    DECLARE_CLIENT_REVISION(*GroupHandle);


    SAMTRACE_EX("SamrDeleteGroup");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidDeleteGroup
                   );

    //
    // Grab the lock
    //

    NtStatus = SampMaybeAcquireWriteLock(AccountContext, &fLockAcquired);
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }



    //
    // Validate type of, and access to object.
    //

    NtStatus = SampLookupContext(
                   AccountContext,
                   DELETE,
                   SampGroupObjectType,           // ExpectedType
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {

        ObjectRid = AccountContext->TypeBody.Group.Rid;

        //
        // Get a pointer to the domain this object is in.
        // This is used for auditing.
        //

        DomainIndex = AccountContext->DomainIndex;
        Domain = &SampDefinedDomains[ DomainIndex ];

        //
        // Make sure the account is one that can be deleted.
        // Can't be a built-in account, unless the caller is trusted.
        //

        if ( !AccountContext->TrustedClient ) {

            NtStatus = SampIsAccountBuiltIn( ObjectRid );
        }


        if (NT_SUCCESS( NtStatus)) {


            if (!IsDsObject(AccountContext))
            {
                //
                // and it can't have any members
                //

                NtStatus = SampRetrieveGroupMembers(
                           AccountContext,
                           &MemberCount,
                           NULL              // Only need member count (not list)
                           );

                if (MemberCount != 0)
                {
                    NtStatus = STATUS_MEMBER_IN_GROUP;
                }
            }
            else
            {
                //
                // In DS mode we should have no primary members
                //

                 NtStatus = SampDsGetPrimaryGroupMembers(
                                DomainObjectFromAccountContext(AccountContext),
                                AccountContext->TypeBody.Group.Rid,
                                &PrimaryMemberCount,
                                &PrimaryMembers
                                );

                if ((NT_SUCCESS(NtStatus)) && (PrimaryMemberCount>0))
                {
                    //
                    // We should ideally add a new error code to distinguish
                    // this behaviour but applications only know to deal with
                    // STATUS_MEMBER_IN_GROUP. Secondly we do not want to
                    // Create any special Caveats for "Primary members" as we
                    // want to remove that concept anyway in the long term.
                    //

                    NtStatus = STATUS_MEMBER_IN_GROUP;

                }
            }
        }



        if (NT_SUCCESS(NtStatus)) {

            //
            // Remove this account from all aliases, for the Registry Case
            //


            NtStatus = SampCreateAccountSid(AccountContext, &AccountSid);

            if ((NT_SUCCESS(NtStatus)) && (!IsDsObject(AccountContext))) {

                //
                // Only for the Registry case , go and remove all the references
                // to the Account Sid , in the given domain.
                //

                NtStatus = SampRemoveAccountFromAllAliases(
                               AccountSid,
                               NULL,
                               FALSE,
                               NULL,
                               NULL,
                               NULL );
            }
        }


        //
        // Looks promising.

        if (NT_SUCCESS(NtStatus)) {

            //
            // First get and save the account name for
            // I_NetNotifyLogonOfDelta.
            //

            NtStatus = SampGetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_GROUP_NAME,
                           TRUE,    // Make copy
                           &GroupName
                           );

            if (NT_SUCCESS(NtStatus)) {

                //
                // This must be done before we invalidate contexts, because our
                // own handle to the group gets closed as well.
                //

                if (IsDsObject(AccountContext))
                {
                    //
                    // For Ds Case Delete the Object in the Ds.
                    //

                    NtStatus = SampDsDeleteObject(AccountContext->ObjectNameInDs,
                                                  0         //  delete the object itself
                                                  );

                    //
                    // In Windows 2000 (NT5), an object has children cannot be
                    // deleted till its children are deleted first. Thus for
                    // Net API compatibility, we have to change the
                    // delete behavior from a delete object to delete tree.
                    //

                    if ((!AccountContext->LoopbackClient) &&
                        (STATUS_DS_CANT_ON_NON_LEAF == NtStatus)
                       )
                    {
                        //
                        // We only checked the right and access control for
                        // deleting the object itself, not check the right to
                        // delete all the children underneath, so turn off fDSA
                        // here, let core DS do the rest of check.
                        //

                        SampSetDsa(FALSE);

                        NtStatus = SampDsDeleteObject(AccountContext->ObjectNameInDs,
                                                      SAM_DELETE_TREE
                                                      );
                    }

                    if (NT_SUCCESS(NtStatus) && (!IsDsObject(AccountContext)) )
                    {
                        //
                        // Decrement the group count
                        //

                        NtStatus = SampAdjustAccountCount(SampGroupObjectType, FALSE);
                    }


                }
                else
                {

                    //
                    // Registry Case Delete Keys
                    //

                    NtStatus = SampDeleteGroupKeys( AccountContext );
                }

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // We must invalidate any open contexts to this group.
                    // This will close all handles to the group's keys.
                    // THIS IS AN IRREVERSIBLE PROCESS.
                    //

                    SampInvalidateObjectContexts( AccountContext, ObjectRid );


                    //
                    // Commit the whole mess
                    //

                    NtStatus = SampCommitAndRetainWriteLock();

                    if ( NT_SUCCESS( NtStatus ) ) {

                        SAMP_ACCOUNT_DISPLAY_INFO AccountInfo;

                        //
                        // Update the Cached Alias Information in Registry Mode
                        // In DS Mode, Alias Information is invalidated through
                        // SampNotifyReplicatedInChange
                        //

                        if (!IsDsObject(AccountContext))
                        {
                            NtStatus = SampAlRemoveAccountFromAllAliases(
                                           AccountSid,
                                           FALSE,
                                           NULL,
                                           NULL,
                                           NULL
                                           );

                            //
                            // Update the display information ONLY in Registry Case
                            //

                            AccountInfo.Name = GroupName;
                            AccountInfo.Rid = ObjectRid;
                            AccountInfo.AccountControl = 0; // Don't care about this value for delete
                            RtlInitUnicodeString(&AccountInfo.Comment, NULL);
                            RtlInitUnicodeString(&AccountInfo.FullName, NULL);

                            TmpStatus = SampUpdateDisplayInformation(
                                                        &AccountInfo,
                                                        NULL,
                                                        SampGroupObjectType
                                                        );
                            ASSERT(NT_SUCCESS(TmpStatus));
                        }

                        //
                        // Audit the deletion before we free the write lock
                        // so that we have access to the context block.
                        //

                        //
                        // N.B. Deletion audits in the DS are performed in
                        // the notification routine on transaction commit.
                        //
                        if (SampDoAccountAuditing(DomainIndex) &&
                            (!IsDsObject(AccountContext)) &&
                            NT_SUCCESS(NtStatus) ) {

                            SampAuditGroupDelete(DomainIndex,
                                                 &GroupName,
                                                 &ObjectRid,
                                                 GROUP_TYPE_ACCOUNT_GROUP |
                                                 GROUP_TYPE_SECURITY_ENABLED);

                        }

                        //
                        // Do delete auditing
                        //

                        if (NT_SUCCESS(NtStatus)) {

                            SampDeleteObjectAuditAlarm(AccountContext);
                        }

                        //
                        // Notify netlogon of the change
                        //

                        if (AccountContext->TypeBody.Group.SecurityEnabled)
                        {
                            SampNotifyNetlogonOfDelta(
                                SecurityDbDelete,
                                SecurityDbObjectSamGroup,
                                ObjectRid,
                                &GroupName,
                                (DWORD) FALSE,   // Replicate immediately
                                NULL             // Delta data
                                );
                        }
                    }


                }

                SampFreeUnicodeString( &GroupName );
            }
        }



        //
        // De-reference the object, discarding changes
        //

        TmpStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(TmpStatus));


        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // If we actually deleted the group, delete the context and
            // let RPC know that the handle is invalid.
            //

            SampDeleteContext( AccountContext );

            (*GroupHandle) = NULL;
        }

    } //end_if

    //
    // Free the lock -
    //
    // Everything has already been committed above, so we must indicate
    // no additional changes have taken place.
    //
    //
    //


    TmpStatus = SampMaybeReleaseWriteLock( fLockAcquired, FALSE );

    if (NtStatus == STATUS_SUCCESS) {
        NtStatus = TmpStatus;
    }

    if (AccountSid!=NULL)
        MIDL_user_free(AccountSid);

    if (NULL!=PrimaryMembers)
        MIDL_user_free(PrimaryMembers);

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidDeleteGroup
                   );

    return(NtStatus);

}


NTSTATUS
SamrRemoveMemberFromGroup(
    IN SAMPR_HANDLE GroupHandle,
    IN ULONG MemberId
    )

/*++

Routine Description:

    This service

Arguments:

    ????

Return Value:


    ????


--*/
{
    NTSTATUS                NtStatus, TmpStatus;
    PSAMP_OBJECT            AccountContext;
    SAMP_OBJECT_TYPE        FoundType;
    UNICODE_STRING         GroupName;
    DECLARE_CLIENT_REVISION(GroupHandle);



    SAMTRACE_EX("SamrRemoveMemberFromGroup");

    //
    // Do a start type WMI event trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidRemoveMemberFromGroup
                   );

    SampUpdatePerformanceCounters(
        DSSTAT_MEMBERSHIPCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );

    //
    // Initialize buffers we will cleanup at the end
    //

    RtlInitUnicodeString(&GroupName, NULL);

    //
    // Grab the lock
    //

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto SamrRemoveMemberFromGroupError;
    }

    //
    // Validate type of, and access to object.
    //

    AccountContext = (PSAMP_OBJECT)(GroupHandle);

    NtStatus = SampLookupContext(
                   AccountContext,
                   GROUP_REMOVE_MEMBER,
                   SampGroupObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Call the actual worker routine
        //

        NtStatus = SampRemoveSameDomainMemberFromGlobalOrUniversalGroup(
                        AccountContext,
                        MemberId,
                        NULL
                        );

         if (NT_SUCCESS(NtStatus)) {

            //
            // Get and save the account name for
            // I_NetNotifyLogonOfDelta.
            //

            NtStatus = SampGetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_GROUP_NAME,
                           TRUE,    // Make copy
                           &GroupName
                           );

            if (!NT_SUCCESS(NtStatus)) {
                RtlInitUnicodeString(&GroupName, NULL);
            }
        }


        //
        // Dereference the account context
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // De-reference the object, write out any change to current xaction.
            //

            NtStatus = SampDeReferenceContext( AccountContext, TRUE );

        } else {

            //
            // De-reference the object, ignore changes
            //

            TmpStatus = SampDeReferenceContext( AccountContext, FALSE );
            ASSERT(NT_SUCCESS(TmpStatus));
        }
    }


    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampCommitAndRetainWriteLock();

        if (( NT_SUCCESS( NtStatus ) )
            && (AccountContext->TypeBody.Group.SecurityEnabled)) {

            SAM_DELTA_DATA DeltaData;

            //
            // Fill in id of member being deleted
            //

            DeltaData.GroupMemberId.MemberRid = MemberId;


            if (AccountContext->TypeBody.Group.SecurityEnabled)
            {
                SampNotifyNetlogonOfDelta(
                    SecurityDbChangeMemberDel,
                    SecurityDbObjectSamGroup,
                    AccountContext->TypeBody.Group.Rid,
                    &GroupName,
                    (DWORD) FALSE,  // Replicate immediately
                    &DeltaData
                    );
            }
        }
    }


    //
    // Free up the group name
    //

    SampFreeUnicodeString(&GroupName);

     //
    // Release the Lock
    //


    TmpStatus = SampReleaseWriteLock( FALSE );
    ASSERT(NT_SUCCESS(TmpStatus));

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

SamrRemoveMemberFromGroupError:

    //
    // Do a end type WMI event trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidRemoveMemberFromGroup
                   );

    return(NtStatus);
}



NTSTATUS
SamrGetMembersInGroup(
    IN SAMPR_HANDLE GroupHandle,
    OUT PSAMPR_GET_MEMBERS_BUFFER *GetMembersBuffer
    )

/*++

Routine Description:

    This API lists all the members in a group.  This API may be called
    repeatedly, passing a returned context handle, to retrieve large
    amounts of data.  This API requires GROUP_LIST_MEMBERS access to the
    group.




Parameters:

    GroupHandle - The handle of an opened group to operate on.
        GROUP_LIST_MEMBERS access is needed to the group.

    GetMembersBuffer - Receives a pointer to a set of returned structures
        with the following format:

                         +-------------+
               --------->| MemberCount |
                         |-------------+                    +-------+
                         |  Members  --|------------------->| Rid-0 |
                         |-------------|   +------------+   |  ...  |
                         |  Attributes-|-->| Attribute0 |   |       |
                         +-------------+   |    ...     |   | Rid-N |
                                           | AttributeN |   +-------+
                                           +------------+

        Each block individually allocated with MIDL_user_allocate.



Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no addition entries.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.
    This service



--*/
{

    NTSTATUS                    NtStatus;
    NTSTATUS                    IgnoreStatus;
    ULONG                       i;
    ULONG                       ObjectRid;
    PSAMP_OBJECT                AccountContext;
    SAMP_OBJECT_TYPE            FoundType;
    BOOLEAN                     fLockAcquired = FALSE;
    DECLARE_CLIENT_REVISION(GroupHandle);

    SAMTRACE_EX("SamrGetMembersInGroup");

    //
    // Do a start type WMI event trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidGetMembersInGroup
                   );

    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (GetMembersBuffer != NULL);

    if ((*GetMembersBuffer) != NULL) {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }




    //
    // Allocate the first of the return buffers
    //

    (*GetMembersBuffer) = MIDL_user_allocate( sizeof(SAMPR_GET_MEMBERS_BUFFER) );

    if ( (*GetMembersBuffer) == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }

    RtlZeroMemory((*GetMembersBuffer), sizeof(SAMPR_GET_MEMBERS_BUFFER));

    //
    // Acquire the Read lock if necessary
    //
    AccountContext = (PSAMP_OBJECT)GroupHandle;
    SampMaybeAcquireReadLock(AccountContext,
                             DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                             &fLockAcquired);

    //
    // Validate type of, and access to object.
    //


    ObjectRid = AccountContext->TypeBody.Group.Rid;
    NtStatus = SampLookupContext(
                   AccountContext,
                   GROUP_LIST_MEMBERS,
                   SampGroupObjectType,           // ExpectedType
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampRetrieveGroupMembers(
                       AccountContext,
                       &(*GetMembersBuffer)->MemberCount,
                       &(*GetMembersBuffer)->Members
                       );

        if (NT_SUCCESS(NtStatus)) {

            //
            // Allocate a buffer for the attributes - which we get from
            // the individual user records
            //

            (*GetMembersBuffer)->Attributes = MIDL_user_allocate((*GetMembersBuffer)->MemberCount * sizeof(ULONG) );
            if ((*GetMembersBuffer)->Attributes == NULL) {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }

            for ( i=0; (i<((*GetMembersBuffer)->MemberCount) && NT_SUCCESS(NtStatus)); i++) {

                if (IsDsObject(AccountContext))
                {
                    //
                    // Currently the attributes of the group are hardwired.
                    // Therefore instead of calling the UserGroupAttributes
                    // function whack the attrbutes straight away. In case of
                    // it becomes necessary to support these attributes the
                    // retrive group members will obtain the attributes also
                    // making one pass on the DS
                    //

                    (*GetMembersBuffer)->Attributes[i] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED;

                }
                else
                {
                    NtStatus = SampRetrieveUserGroupAttribute(
                                   (*GetMembersBuffer)->Members[i],
                                   ObjectRid,
                                   &(*GetMembersBuffer)->Attributes[i]
                                );

                    if ( STATUS_NO_SUCH_USER == NtStatus )
                    {
                        (*GetMembersBuffer)->Attributes[i] = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED;
                        NtStatus = STATUS_SUCCESS;
                    }
                }
            }

        }


        //
        // De-reference the object, discarding changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));

    }

    //
    // Free the read lock
    //

    SampMaybeReleaseReadLock(fLockAcquired);


    if (!NT_SUCCESS(NtStatus) || ((*GetMembersBuffer)->MemberCount == 0)){

        (*GetMembersBuffer)->MemberCount = 0;
        if ((*GetMembersBuffer)->Members)
        {
            MIDL_user_free((*GetMembersBuffer)->Members);
            (*GetMembersBuffer)->Members     = NULL;
        }

        if ((*GetMembersBuffer)->Attributes)
        {
            MIDL_user_free((*GetMembersBuffer)->Attributes);
            (*GetMembersBuffer)->Attributes  = NULL;
        }
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    //
    // Do an end type WMI event trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidGetMembersInGroup
                   );

    return( NtStatus );
}


NTSTATUS
SamrSetMemberAttributesOfGroup(
    IN SAMPR_HANDLE GroupHandle,
    IN ULONG MemberId,
    IN ULONG Attributes
    )

/*++

Routine Description:


    This routine modifies the group attributes of a member of the group.
    This routine is a NO - OP for the DS case



Parameters:

    GroupHandle - The handle of an opened group to operate on.

    MemberId - Contains the relative ID of member whose attributes
        are to be modified.

    Attributes - The group attributes to set for the member.  These
        attributes must not conflict with the attributes of the group
        as a whole.  See SamAddMemberToGroup() for more information
        on compatible attribute settings.

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no addition entries.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_USER - The user specified does not exist.

    STATUS_MEMBER_NOT_IN_GROUP - Indicates the specified relative ID
        is not a member of the group.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/

{

    NTSTATUS                NtStatus, TmpStatus;
    PSAMP_OBJECT            AccountContext;
    SAMP_OBJECT_TYPE        FoundType;
    ULONG                   ObjectRid;
    DECLARE_CLIENT_REVISION(GroupHandle);



    SAMTRACE_EX("SamrSetMemberAttributesOfGroup");

    //
    // WMI event trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidSetMemberAttributesOfGroup
                   );


    //
    // Grab the lock
    //

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }




    //
    // Validate type of, and access to object.
    //

    AccountContext = (PSAMP_OBJECT)(GroupHandle);
    ObjectRid = AccountContext->TypeBody.Group.Rid;
    NtStatus = SampLookupContext(
                   AccountContext,
                   GROUP_ADD_MEMBER,
                   SampGroupObjectType,           // ExpectedType
                   &FoundType
                   );

    if ((NT_SUCCESS(NtStatus))&& (!IsDsObject(AccountContext))) {

        //
        // Update user object
        //

        NtStatus = SampSetGroupAttributesOfUser(
                       ObjectRid,
                       Attributes,
                       MemberId
                       );

        //
        // Dereference the account context
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // De-reference the object, write out any change to current xaction.
            //

            NtStatus = SampDeReferenceContext( AccountContext, TRUE );

        } else {

            //
            // De-reference the object, ignore changes
            //

            TmpStatus = SampDeReferenceContext( AccountContext, FALSE );
            ASSERT(NT_SUCCESS(TmpStatus));
        }

    }


    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampCommitAndRetainWriteLock();

        if (( NT_SUCCESS( NtStatus ) )
            && (AccountContext->TypeBody.Group.SecurityEnabled)) {

            SampNotifyNetlogonOfDelta(
                SecurityDbChange,
                SecurityDbObjectSamGroup,
                ObjectRid,
                (PUNICODE_STRING) NULL,
                (DWORD) FALSE,  // Replicate immediately
                NULL            // Delta data
                );
        }
    }

    TmpStatus = SampReleaseWriteLock( FALSE );

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    //
    // WMI event trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidSetMemberAttributesOfGroup
                   );

    return(NtStatus);
}




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Internal Services Available For Use in Other SAM Modules                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampValidateDSName(
    IN PSAMP_OBJECT AccountContext,
    IN DSNAME * DSName,
    OUT PSID    * Sid,
    OUT DSNAME  **ImprovedDSName
    )
/*++

    Routine Description:

        Validates a DSNAME, and improves it based upon any lookups either 
        performed locally or on the G.C.

    Arguments:

        AccountContext    The Account Context of the group or Alias Object 
                          that the DSName is being made a member of.
                            
        DSName            The DSNAME to be validated
        
        Sid               Is filled in with a pointer to the SID of the 
                          object upon return

        ImprovedDSName    If the DSName was found in the GC Verify Cache, the 
                          improved DSName from the GC Verify Cache is passed 
                          back here.  Otherwise, this is filled in with the 
                          input DSName.
                           
    Return Values:

        STATUS_SUCCESS   Successful validation
        
        STATUS_INVALID_MEMBER - No name, Guid or Sid was found.

--*/

{

    NTSTATUS    NtStatus = STATUS_SUCCESS;
    DSNAME      * GCVerifiedName = NULL;
    ENTINF      *EntInf = NULL;
    PDSNAME     *rgDSNames = NULL;

    //
    // Initialize return Values
    //
   
    *Sid = NULL;
    *ImprovedDSName = DSName;

    //
    // Lookup the name in the GC Verify Cache
    //

    EntInf = GCVerifyCacheLookup(DSName);
    if (NULL!=EntInf)
    {
        GCVerifiedName = EntInf->pName;
    }

    if ((NULL!=GCVerifiedName) && (GCVerifiedName->SidLen>0))
    {
        //
        // Found in the cache, This name corresponds to a DS Name
        // that has been verified at the G.C. Therefore this
        // DS Name corresponds to an Object belonging to a Domain
        // in the enterprise.

        //
        // Fill in the improved DS Name. The core DS expects that
        // the string name is present when a DS Named valued attribute
        // is specified. The input name need not have a string name,
        // but the name in the GC verify cache will have all components
        // of the name. So pass this back to the caller, so that he may
        // use this name while making core DS calls
        //

        *ImprovedDSName = GCVerifiedName;


        //
        // Try to obtain the SID of the object
        // from the SID field in the DS Name
        //

        if (GCVerifiedName->SidLen > 0)
        {
            
            *Sid = &(GCVerifiedName->Sid);
        }
    }
    else
    {
        NTSTATUS IgnoreStatus;
        
        //
        // Not Found in the Cache. This name is a name that either
        // did not resolve at the G.C, or is a local name that
        // was never remoted to the G.C, or a SID describing a foreign
        // object on which no resolution was attempted.
        //
        
        IgnoreStatus = SampFillGuidAndSid(DSName);  
             
        //
        // Best effort for Guid and Sid, we'll ignore errors and
        // validate what we get back.
        //
        
        if ((DSName->SidLen > 0) && RtlValidSid(&DSName->Sid))
        {
            //
            // Name contains a valid SID, keep that SID
            //
            
            *Sid = &DSName->Sid;
        }
        else if (fNullUuid(&DSName->Guid) && (0 == DSName->NameLen)) 
        {
            //
            // No name, guid, or valid SID
            //
            
            NtStatus = STATUS_INVALID_MEMBER;  
            goto Error;
        }   
    }   
 
Error:


    return NtStatus;
}


NTSTATUS
SampAddUserToGroup(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG GroupRid,
    IN ULONG UserRid
    )

/*++

Routine Description:

    This service is expected to be used when a user is being created.
    It is used to add that user as a member to a specified group.
    This is done by simply adding the user's ID to the list of IDs
    in the MEMBERS sub-key of the the specified group.


    The caller of this service is expected to be in the middle of a
    RXACT transaction.  This service simply adds some actions to that
    RXACT transaction.


    If the group is the DOMAIN_ADMIN group, the caller is responsible
    for updating the ActiveAdminCount (if appropriate).



Arguments:

    GroupRid - The RID of the group the user is to be made a member of.

    UserRid - The RID of the user being added as a new member.

Return Value:


    STATUS_SUCCESS - The user has been added.



--*/
{
    NTSTATUS                NtStatus;
    PSAMP_OBJECT            GroupContext;

    SAMTRACE("SampAddUserToGroup");


    NtStatus = SampCreateAccountContext2(
                    AccountContext,             // Passedin Context
                    SampGroupObjectType,        // object type
                    GroupRid,                   // object ID
                    NULL,                       // user account control
                    (PUNICODE_STRING)NULL,      // account name
                    AccountContext->ClientRevision, // Client Revision
                    TRUE,                           // We're trusted
                    AccountContext->LoopbackClient, // Loopback client
                    FALSE,                      // createdByPrivilege
                    TRUE,                       // account exists
                    FALSE,                      // OverrideLockGroupCheck
                    NULL,                       // group type
                    &GroupContext               // returned context
                    );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Turn Off Buffer Writes, so that member ship change won't be cached.
        // And we don't need to CommitBufferedWrites()
        //
        GroupContext->BufferWrites = FALSE;


        //
        // Add the user to the group member list.
        //

        NtStatus = SampAddAccountToGroupMembers(
                        GroupContext,
                        UserRid,
                        NULL
                        );

        //
        // Write out any changes to the group account
        // Don't use the open key handle since we'll be deleting the context.
        //

        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampStoreObjectAttributes(GroupContext, FALSE);
        }

        //
        // Clean up the group context
        //

        SampDeleteContext(GroupContext);

    }

    return(NtStatus);
}



NTSTATUS
SampRemoveUserFromGroup(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG GroupRid,
    IN ULONG UserRid
    )

/*++

Routine Description:

    This routine is used to Remove a user from a specified group.
    This is done by simply Removing the user's ID From the list of IDs
    in the MEMBERS sub-key of the the specified group.

    It is the caller's responsibility to know that the user is, in fact,
    currently a member of the group.


    The caller of this service is expected to be in the middle of a
    RXACT transaction.  This service simply adds some actions to that
    RXACT transaction.


    If the group is the DOMAIN_ADMIN group, the caller is responsible
    for updating the ActiveAdminCount (if appropriate).



Arguments:

    GroupRid - The RID of the group the user is to be removed from.

    UserRid - The RID of the user being Removed.

Return Value:


    STATUS_SUCCESS - The user has been Removed.



--*/
{
    NTSTATUS                NtStatus;
    PSAMP_OBJECT            GroupContext;

    SAMTRACE("SampRemoveUserFromGroup");

    NtStatus = SampCreateAccountContext2(
                    AccountContext,         // Context
                    SampGroupObjectType,    // Object Type
                    GroupRid,               // Object ID
                    NULL,                   // UserAccountControl,
                    (PUNICODE_STRING) NULL, // AccountName,
                    AccountContext->ClientRevision, // Client Revision
                    TRUE,                   // Trusted Client
                    AccountContext->LoopbackClient, // Loopback Client
                    FALSE,                  // Create by Privilege
                    TRUE,                   // Account exists
                    FALSE,                  // OverrideLocalGroupCheck
                    NULL,                   // Group Type
                    &GroupContext           // return Context
                    );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Turn Off Buffer Writes, so that member ship change won't be cached.
        // And we don't need to CommitBufferedWrites()
        //
        GroupContext->BufferWrites = FALSE;

        //
        // Remove the user from the group member list.
        //

        NtStatus = SampRemoveAccountFromGroupMembers(
                        GroupContext,
                        UserRid,
                        NULL
                        );

        //
        // Write out any changes to the group account
        // Don't use the open key handle since we'll be deleting the context.
        //

        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampStoreObjectAttributes(GroupContext, FALSE);
        }

        //
        // Clean up the group context
        //

        SampDeleteContext(GroupContext);

    }

    return(NtStatus);
}




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Services Private to this file                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampRetrieveGroupV1Fixed(
    IN PSAMP_OBJECT GroupContext,
    IN PSAMP_V1_0A_FIXED_LENGTH_GROUP V1Fixed
    )

/*++

Routine Description:

    This service retrieves the V1 fixed length information related to
    a specified group.


Arguments:

    GroupRootKey - Root key for the group whose V1_FIXED information is
        to be retrieved.

    V1Fixed - Is a buffer into which the information is to be returned.



Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    Other status values that may be returned are those returned
    by:

            SampGetFixedAttributes()



--*/
{
    NTSTATUS    NtStatus;
    PVOID       FixedData;

    SAMTRACE("SampRetrieveGroupV1Fixed");


    NtStatus = SampGetFixedAttributes(
                   GroupContext,
                   FALSE, // Don't make copy
                   &FixedData
                   );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Copy data into return buffer
        // *V1Fixed = *((PSAMP_V1_0A_FIXED_LENGTH_GROUP)FixedData);
        //

        RtlMoveMemory(
            V1Fixed,
            FixedData,
            sizeof(SAMP_V1_0A_FIXED_LENGTH_GROUP)
            );
    }


    return( NtStatus );

}




NTSTATUS
SampReplaceGroupV1Fixed(
    IN PSAMP_OBJECT Context,
    IN PSAMP_V1_0A_FIXED_LENGTH_GROUP V1Fixed
    )

/*++

Routine Description:

    This service replaces the current V1 fixed length information related to
    a specified group.

    The change is made to the in-memory object data only.


Arguments:

    Context - Points to the account context whose V1_FIXED information is
        to be replaced.

    V1Fixed - Is a buffer containing the new V1_FIXED information.



Return Value:


    STATUS_SUCCESS - The information has been replaced.

    Other status values that may be returned are those returned
    by:

            SampSetFixedAttributes()



--*/
{
    NTSTATUS    NtStatus;

    SAMTRACE("SampReplaceGroupV1Fixed");

    NtStatus = SampSetFixedAttributes(
                   Context,
                   (PVOID)V1Fixed
                   );

    return( NtStatus );
}



NTSTATUS
SampRetrieveGroupMembers(
    IN PSAMP_OBJECT GroupContext,
    IN PULONG MemberCount,
    IN PULONG  *Members OPTIONAL
    )

/*++
Routine Description:

    This service retrieves the number of members in a group.  If desired,
    it will also retrieve an array of RIDs of the members of the group.


Arguments:

    GroupContext - Group context block

    MemberCount - Receives the number of members currently in the group.

    Members - (Optional) Receives a pointer to a buffer containing an array
        of member Relative IDs.  If this value is NULL, then this information
        is not returned.  The returned buffer is allocated using
        MIDL_user_allocate() and must be freed using MIDL_user_free() when
        no longer needed.

        The Members array returned always includes space for one new entry.


Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated for the
        string to be returned in.

    Other status values that may be returned are those returned
    by:

            SampGetUlongArrayAttribute()



--*/
{
    NTSTATUS    NtStatus;
    PULONG      Array;
    ULONG       LengthCount;

    SAMTRACE("SampRetrieveGroupMembers");

    //
    // Do Different things for DS and Registry Cases
    //

    if (IsDsObject(GroupContext))
    {
        //
        // DS case, this routine in DS layer does all the
        // work
        //

        if (ARGUMENT_PRESENT(Members))
        {
        *Members = NULL;
        };

        *MemberCount = 0;

      
        NtStatus = SampDsGetGroupMembershipList(
                        DomainObjectFromAccountContext(GroupContext),
                        GroupContext->ObjectNameInDs,
                        GroupContext->TypeBody.Group.Rid,
                        Members,
                        MemberCount
                        );    
    }
    else
    {

        //
        // Registry Case
        //


        NtStatus = SampGetUlongArrayAttribute(
                            GroupContext,
                            SAMP_GROUP_MEMBERS,
                            FALSE, // Reference data directly
                            &Array,
                            MemberCount,
                            &LengthCount
                            );

        if (NT_SUCCESS(NtStatus)) {

            //
            // Fill in return info
            //

            if (Members != NULL) {

                //
                // Allocate a buffer large enough to hold the existing membership
                // data plus one.
                //

                ULONG BytesNow = (*MemberCount) * sizeof(ULONG);
                ULONG BytesRequired = BytesNow + sizeof(ULONG);

                *Members = MIDL_user_allocate(BytesRequired);

                if (*Members == NULL) {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    RtlCopyMemory(*Members, Array, BytesNow);
                }
            }
        }
    }

    return( NtStatus );
}



NTSTATUS
SampReplaceGroupMembers(
    IN PSAMP_OBJECT GroupContext,
    IN ULONG MemberCount,
    IN PULONG Members
    )

/*++
Routine Description:

    This service sets the members of a group.

    The information is updated in the in-memory copy of the group's data only.
    The data is not written out by this routine.


Arguments:

    GroupContext - The group whose member list is to be replaced

    MemberCount - The number of new members

    Membership - A pointer to a buffer containing an array of account rids.


Return Value:


    STATUS_SUCCESS - The information has been set.

    Other status values that may be returned are those returned
    by:

            SampSetUlongArrayAttribute()



--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PULONG      LocalMembers;
    ULONG       LengthCount;
    ULONG       SmallListGrowIncrement = 25;
    ULONG       BigListGrowIncrement = 250;
    ULONG       BigListSize = 800;

    SAMTRACE("SampReplaceGroupMembers");

    //
    // ASSERT that this is never called on a  DS case
    //

    ASSERT(!(IsDsObject(GroupContext)));


    //
    // These group user lists can get pretty big, and grow many
    // times by a very small amount as each user is added.  The
    // registry doesn't like that kind of behaviour (it tends to
    // eat up free space something fierce) so we'll try to pad
    // out the list size.
    //

    if ( MemberCount < BigListSize ) {

        //
        // If less than 800 users, make the list size the smallest
        // possible multiple of 25 users.
        //

        LengthCount = ( ( MemberCount + SmallListGrowIncrement - 1 ) /
                      SmallListGrowIncrement ) *
                      SmallListGrowIncrement;

    } else {

        //
        // If 800 users or more, make the list size the smallest
        // possible multiple of 250 users.
        //

        LengthCount = ( ( MemberCount + BigListGrowIncrement - 1 ) /
                      BigListGrowIncrement ) *
                      BigListGrowIncrement;
    }

    ASSERT( LengthCount >= MemberCount );

    if ( LengthCount == MemberCount ) {

        //
        // Just the right size.  Use the buffer that was passed in.
        //

        LocalMembers = Members;

    } else {

        //
        // We need to allocate a larger buffer before we set the attribute.
        //

        LocalMembers = MIDL_user_allocate( LengthCount * sizeof(ULONG));

        if ( LocalMembers == NULL ) {

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            //
            // Copy the old buffer to the larger buffer, and zero out the
            // empty stuff at the end.
            //

            RtlCopyMemory( LocalMembers, Members, MemberCount * sizeof(ULONG));

            RtlZeroMemory(
                (LocalMembers + MemberCount),
                (LengthCount - MemberCount) * sizeof(ULONG)
                );
        }
    }

    if ( NT_SUCCESS( NtStatus ) ) {

        NtStatus = SampSetUlongArrayAttribute(
                            GroupContext,
                            SAMP_GROUP_MEMBERS,
                            LocalMembers,
                            MemberCount,
                            LengthCount
                            );
    }

    if ( LocalMembers != Members ) {

        //
        // We must have allocated a larger local buffer, so free it.
        //

        MIDL_user_free( LocalMembers );
    }

    return( NtStatus );
}



NTSTATUS
SampDeleteGroupKeys(
    IN PSAMP_OBJECT Context
    )

/*++
Routine Description:

    This service deletes all registry keys related to a group object.


Arguments:

    Context - Points to the group context whose registry keys are
        being deleted.


Return Value:


    STATUS_SUCCESS - The information has been retrieved.


    Other status values that may be returned by:

        RtlAddActionToRXact()



--*/
{

    NTSTATUS                NtStatus;
    ULONG                   Rid;
    UNICODE_STRING          AccountName, KeyName;

    SAMTRACE("SampDeleteGroupKeys");


    Rid = Context->TypeBody.Group.Rid;


    //
    // Groups are arranged as follows:
    //
    //  +-- Groups [Count]
    //      ---+--
    //         +--  Names
    //         |    --+--
    //         |      +--  (GroupName) [GroupRid,]
    //         |
    //         +--  (GroupRid) [Revision,SecurityDescriptor]
    //               ---+-----
    //                  +--  V1_Fixed [,SAM_V1_0A_FIXED_LENGTH_GROUP]
    //                  +--  Name [,Name]
    //                  +--  AdminComment [,unicode string]
    //                  +--  Members [Count,(Member0Rid, (...), MemberX-1Rid)]
    //
    // This all needs to be deleted from the bottom up.
    //


    //
    // Decrement the group count
    //

    NtStatus = SampAdjustAccountCount(SampGroupObjectType, FALSE);




    //
    // Delete the registry key that has the group's name to RID mapping.
    //

    if (NT_SUCCESS(NtStatus)) {

        //
        // Get the name
        //

        NtStatus = SampGetUnicodeStringAttribute(
                       Context,
                       SAMP_GROUP_NAME,
                       TRUE,    // Make copy
                       &AccountName
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampBuildAccountKeyName(
                           SampGroupObjectType,
                           &KeyName,
                           &AccountName
                           );

            SampFreeUnicodeString( &AccountName );


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = RtlAddActionToRXact(
                               SampRXactContext,
                               RtlRXactOperationDelete,
                               &KeyName,
                               0,
                               NULL,
                               0
                               );

                SampFreeUnicodeString( &KeyName );
            }
        }
    }




    //
    // Delete the attribute keys
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampDeleteAttributeKeys(
                        Context
                        );
    }




    //
    // Delete the RID key
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampBuildAccountSubKeyName(
                       SampGroupObjectType,
                       &KeyName,
                       Rid,
                       NULL
                       );

        if (NT_SUCCESS(NtStatus)) {


            NtStatus = RtlAddActionToRXact(
                           SampRXactContext,
                           RtlRXactOperationDelete,
                           &KeyName,
                           0,
                           NULL,
                           0
                           );
            SampFreeUnicodeString( &KeyName );
        }


    }



    return( NtStatus );

}




NTSTATUS
SampChangeGroupAccountName(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING NewAccountName,
    OUT PUNICODE_STRING OldAccountName
    )

/*++
Routine Description:

    This routine changes the account name of a group account.

    IN THE REGISTRY CASE THIS SERVICE MUST BE
    CALLED WITH THE TRANSACTION DOMAIN SET.

Arguments:

    Context - Points to the group context whose name is to be changed.

    NewAccountName - New name to give this account

    OldAccountName - old name is returned here. The buffer should be freed
                     by calling MIDL_user_free.

Return Value:


    STATUS_SUCCESS - The information has been retrieved.


    Other status values that may be returned by:

        SampGetUnicodeStringAttribute()
        SampSetUnicodeStringAttribute()
        SampValidateAccountNameChange()
        RtlAddActionToRXact()



--*/
{

    NTSTATUS        NtStatus;
    UNICODE_STRING  KeyName;

    SAMTRACE("SampChangeGroupAccountName");

    /////////////////////////////////////////////////////////////
    // There are two copies of the name of each account.       //
    // one is under the DOMAIN\(domainName)\GROUP\NAMES key,   //
    // one is the value of the                                 //
    // DOMAIN\(DomainName)\GROUP\(rid)\NAME key                //
    /////////////////////////////////////////////////////////////

    //
    // Get the current name so we can delete the old Name->Rid
    // mapping key.
    //

    NtStatus = SampGetUnicodeStringAttribute(
                   Context,
                   SAMP_GROUP_NAME,
                   TRUE, // Make copy
                   OldAccountName
                   );

    //
    // Make sure the name is valid and not already in use
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampValidateAccountNameChange(
                       Context,
                       NewAccountName,
                       OldAccountName,
                       SampGroupObjectType
                       );

        if (!IsDsObject(Context))
        {
            //
            // For Registry Case Re-Create Keys
            //

            //
            // Delete the old name key
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampBuildAccountKeyName(
                               SampGroupObjectType,
                               &KeyName,
                               OldAccountName
                               );

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = RtlAddActionToRXact(
                                   SampRXactContext,
                                   RtlRXactOperationDelete,
                                   &KeyName,
                                   0,
                                   NULL,
                                   0
                                   );
                    SampFreeUnicodeString( &KeyName );
                }

            }

            //
            //
            // Create the new Name->Rid mapping key
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampBuildAccountKeyName(
                               SampGroupObjectType,
                               &KeyName,
                               NewAccountName
                               );

                if (NT_SUCCESS(NtStatus)) {

                    ULONG GroupRid = Context->TypeBody.Group.Rid;

                    NtStatus = RtlAddActionToRXact(
                                   SampRXactContext,
                                   RtlRXactOperationSetValue,
                                   &KeyName,
                                   GroupRid,
                                   (PVOID)NULL,
                                   0
                                   );
                    SampFreeUnicodeString( &KeyName );
                }
            }

        }


        //
        // replace the account's name
        //

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampSetUnicodeStringAttribute(
                           Context,
                           SAMP_GROUP_NAME,
                           NewAccountName
                           );
        }

        //
        // Free up the old account name if we failed
        //

        if (!NT_SUCCESS(NtStatus)) {
            SampFreeUnicodeString(OldAccountName);
        }

    }


    return(NtStatus);
}


NTSTATUS
SampAddAccountToGroupMembers(
    IN PSAMP_OBJECT GroupContext,
    IN ULONG AccountRid,
    IN DSNAME * MemberDsName OPTIONAL
    )

/*++

Routine Description:

    This service adds the specified account rid to the member list
    for the specified group. This is a low-level function that
    simply edits the member attribute of the group context passed.

Arguments:

    GroupContext - The group whose member list will be modified

    AccountRid - The RID of the account being added as a new member.

    MemberDsName -- Optional Parameter specifies the DS Name of the
                    member, if already known. Saves a Search.

Return Value:


    STATUS_SUCCESS - The account has been added.

    STATUS_MEMBER_IN_GROUP - The account is already a member

--*/
{
    NTSTATUS                NtStatus=STATUS_SUCCESS;
    ULONG                   MemberCount, i;
    PULONG                  MemberArray;
    PWCHAR                  MemberStringName = NULL;

    SAMTRACE("SampAddAccountToGroupMembers");

    //
    // Do different things for DS and Registry
    //

    if (IsDsObject(GroupContext))
    {
        DSNAME * DsNameOfAccount = NULL;

        //
        // DS based Domain, either the RID or the DSNAME should be
        // present
        //

        ASSERT((ARGUMENT_PRESENT(MemberDsName)) || (0!=AccountRid));


        if (!ARGUMENT_PRESENT(MemberDsName))
        {

            //
            // Get the DSNAME corresponding to the given SID.
            //

            NtStatus = SampDsLookupObjectByRid(
                            DomainObjectFromAccountContext(GroupContext),
                            AccountRid,
                            &DsNameOfAccount
                            );

            if (NT_SUCCESS(NtStatus))
            {
                MemberDsName = DsNameOfAccount;
            }
        }

        if NT_SUCCESS(NtStatus)
        {
            //
            // Get Member String Name if available
            //
            if (MemberDsName->NameLen && MemberDsName->StringName)
            {
                MemberStringName = MemberDsName->StringName;
            }
            //
            // Add this entry to the Ds. In Lookback case, buffer the membership operaion in
            // object context. By doing so, we can speed up multiple membership add / remove
            // operaions.
            //

            if (GroupContext->BufferWrites)
            {
                NtStatus = SampDsAddMembershipOperationToCache(
                                            GroupContext,
                                            SAMP_GROUP_MEMBERS,
                                            ADD_VALUE,
                                            MemberDsName
                                            );
            }
            else
            {
                NtStatus = SampDsAddMembershipAttribute(
                                GroupContext->ObjectNameInDs,
                                0,
                                SAMP_GROUP_MEMBERS,
                                SampGroupObjectType,
                                MemberDsName
                                );
            }

            //
            // Re-Map any necessary Error Codes
            //

            if (STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS==NtStatus)
            {
                NtStatus = STATUS_MEMBER_IN_GROUP;
            }

            if (NULL!=DsNameOfAccount)
            {
                MIDL_user_free(DsNameOfAccount);
            }
        }

    }
    else
    {
        //
        // Registry Case
        //

        //
        // Get the existing member list
        // Note that the member array always includes space
        // for one new member
        //

        NtStatus = SampRetrieveGroupMembers(
                        GroupContext,
                        &MemberCount,
                        &MemberArray
                        );

        if (NT_SUCCESS(NtStatus)) {

            //
            // Fail if the account is already a member
            //

            for (i = 0; i<MemberCount ; i++ ) {

                if ( MemberArray[i] == AccountRid ) {

                    ASSERT(FALSE);
                    NtStatus = STATUS_MEMBER_IN_GROUP;
                }
            }


            if (NT_SUCCESS(NtStatus)) {

                //
                // Add the user's RID to the end of the list
                //

                MemberArray[MemberCount] = AccountRid;
                MemberCount += 1;

                //
                // Set the new group member list
                //

                NtStatus = SampReplaceGroupMembers(
                                GroupContext,
                                MemberCount,
                                MemberArray
                                );


            }

            //
            // Free up the member list
            //

            MIDL_user_free( MemberArray );

        }
    }

    //
    // audit this, if necessary.
    //

    if (NT_SUCCESS(NtStatus) &&
        SampDoAccountAuditing(GroupContext->DomainIndex)) {

        SampAuditGroupMemberChange(GroupContext,    // Group Context
                                   TRUE,            // Add member
                                   MemberStringName,// Member Name
                                   &AccountRid,     // Member RID
                                   NULL             // Member SID
                                   );
    }


    return(NtStatus);
}


NTSTATUS
SampRemoveAccountFromGroupMembers(
    IN PSAMP_OBJECT GroupContext,
    IN ULONG AccountRid,
    IN DSNAME * MemberDsName OPTIONAL
    )

/*++

Routine Description:

    This service removes the specified account from the member list
    for the specified group. This is a low-level function that
    simply edits the member attribute of the group context passed.
    The change is audited in the SAM account management audit.

Arguments:

    GroupContext - The group whose member list will be modified

    AccountRid - The RID of the account being added as a new member.

    MemberDsName -- The DS Name of the member if already known

Return Value:


    STATUS_SUCCESS - The account has been added.

    STATUS_MEMBER_NOT_IN_GROUP - The account is not a member of the group.

--*/
{
    NTSTATUS                NtStatus=STATUS_SUCCESS;
    ULONG                   MemberCount, i;
    PULONG                  MemberArray;
    PWCHAR                  MemberStringName = NULL;

    SAMTRACE("SampRemoveAccountFromGroupMembers");

    //
    // Do different things for registry and DS cases
    //

    if (IsDsObject(GroupContext))
    {
        DSNAME * DsNameOfAccount = NULL;

        //
        // DS based Domain
        //

        ASSERT((ARGUMENT_PRESENT(MemberDsName)) || (0!=AccountRid));

        if (!ARGUMENT_PRESENT(MemberDsName))
        {
            //
            // Get the DSNAME corresponding to the given SID.
            // This may result in a call to the GC server.
            //

            NtStatus = SampDsLookupObjectByRid(
                        DomainObjectFromAccountContext(GroupContext),
                        AccountRid,
                        &DsNameOfAccount
                        );

            if (NT_SUCCESS(NtStatus))
            {
                MemberDsName = DsNameOfAccount;
            }
        }
        if NT_SUCCESS(NtStatus)
        {
            //
            //  Get the Member Name if it is available.
            //
            if (MemberDsName->NameLen && MemberDsName->StringName)
            {
                MemberStringName = MemberDsName->StringName;
            }

            //
            // Add this entry to the Ds
            //

            if (GroupContext->BufferWrites)
            {
                NtStatus = SampDsAddMembershipOperationToCache(
                                            GroupContext,
                                            SAMP_GROUP_MEMBERS,
                                            REMOVE_VALUE,
                                            MemberDsName
                                            );
            }
            else
            {
                NtStatus = SampDsRemoveMembershipAttribute(
                            GroupContext->ObjectNameInDs,
                            SAMP_GROUP_MEMBERS,
                            SampGroupObjectType,
                            MemberDsName
                            );
            }

            //
            // Re-Map any necessary Error Codes
            //

            if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus)
            {
                NtStatus = STATUS_MEMBER_NOT_IN_GROUP;
            }

            if (NULL!=DsNameOfAccount)
            {
                MIDL_user_free(DsNameOfAccount);
            }
        }

    }

    else
    {

        //
        // Registry based Domain
        //

        //
        // Get the existing member list
        //


        NtStatus = SampRetrieveGroupMembers(
                        GroupContext,
                        &MemberCount,
                        &MemberArray
                        );

        if (NT_SUCCESS(NtStatus)) {

            //
            // Remove the account
            //

            NtStatus = STATUS_MEMBER_NOT_IN_GROUP;

            for (i = 0; i<MemberCount ; i++ ) {

                if (MemberArray[i] == AccountRid) {

                    MemberArray[i] = MemberArray[MemberCount-1];
                    MemberCount -=1;

                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            if (NT_SUCCESS(NtStatus)) {

                //
                // Set the new group member list
                //

                NtStatus = SampReplaceGroupMembers(
                                GroupContext,
                                MemberCount,
                                MemberArray
                                );

            }

        //
        // Free up the member list
        //

        MIDL_user_free( MemberArray );
        }

    }

    //
    // audit this, if necessary.
    //

    if (NT_SUCCESS(NtStatus) &&
        SampDoAccountAuditing(GroupContext->DomainIndex)) {

        SampAuditGroupMemberChange(GroupContext,    // Group Context
                                   FALSE,           // Remove Member
                                   MemberStringName,// Member Name
                                   &AccountRid,     // Member RID
                                   NULL             // Member SID (not used)
                                   );

    }


    return(NtStatus);
}


NTSTATUS
SampEnforceSameDomainGroupMembershipChecks(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG MemberRid
    )
/*++

  Routine Description:

   Validates wether the (potential) group object ( of may be any type
   in the same domain ) can be a member of the group ( of may be any
   type ) described by AccountContext
   This routine checks the account/ resource / unversal / local group
   restrictions

  Arguments:

    AccountContext -- The Object that is being operated upon. Can be a group
                      or alias context

    MemberRid - The relative ID of the user.

  Return Values

     STATUS_SUCCESS
     Various error codes to describe that group membership and nesting
     rules are being violated. Each unique group nesting rule has its own
     error code

  --*/
{

    NTSTATUS        NtStatus = STATUS_SUCCESS;
    PSAMP_OBJECT    MemberContext=NULL;
    NT4_GROUP_TYPE  NT4GroupType;
    NT5_GROUP_TYPE  NT5GroupType;
    BOOLEAN         SecurityEnabled;


    ASSERT(IsDsObject(AccountContext));

    if ( AccountContext->TrustedClient )
    {
        return(STATUS_SUCCESS);
    }

    if (SampAliasObjectType==AccountContext->ObjectType)
    {
        NT4GroupType = AccountContext->TypeBody.Alias.NT4GroupType;
        NT5GroupType = AccountContext->TypeBody.Alias.NT5GroupType;
        SecurityEnabled = AccountContext->TypeBody.Alias.SecurityEnabled;
    }
    else if (SampGroupObjectType == AccountContext->ObjectType)
    {
        NT4GroupType = AccountContext->TypeBody.Group.NT4GroupType;
        NT5GroupType = AccountContext->TypeBody.Group.NT5GroupType;
        SecurityEnabled = AccountContext->TypeBody.Group.SecurityEnabled;
    }
    else
    {
        ASSERT(FALSE && "Invalid Object Type");
        return STATUS_INTERNAL_ERROR;
    }


    //
    // At this point we know that the member specified is not a User.
    // The member specified may be a group .
    //

    NtStatus = SampCreateAccountContext2(
                    AccountContext,         // Group Context
                    SampGroupObjectType,    // Member Object Type
                    MemberRid,              // Member Object Id
                    NULL,                   // User Account Control
                    NULL,                   // Account Name
                    AccountContext->ClientRevision, // Client Revision
                    TRUE,                   // We're trusted
                    AccountContext->LoopbackClient, // Loopback client
                    FALSE,                  // Create by privilege
                    TRUE,                   // Account exists
                    TRUE,                   // Override local group check
                    NULL, // No creation involved, don't specify a group type
                    &MemberContext
                    );

    if (STATUS_NO_SUCH_GROUP==NtStatus)
    {
        //
        // If the operation failed because the group did not exist
        // whack the status code to STATUS_NO_SUCH_USER. This error code
        // will be better understood by downlevel clients. This is because
        // the actual position at this time is that neither a user, nor a
        // group of the given RID exists. The check for the user was done
        // by an earlier routine. This position is equally well described by
        // an error code that informs that the user does not exist.
        //

        NtStatus = STATUS_NO_SUCH_USER;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        //
        // Group Object Could not be created. This may be because either
        // no group / localgroup corresponding to Rid exists or because of
        // resource failures
        //

        goto Error;
    }

    //
    // Now several checks
    //

    //
    // In mixed domain no nesting of global groups if group is security enabled
    //
     if ((DownLevelDomainControllersPresent(AccountContext->DomainIndex))
          && (SecurityEnabled)
          && (NT4GroupType == NT4GlobalGroup))
    {
        //
        // We can concievably add a new error code. However that will still confuse
        // down level clients
        //

        NtStatus = STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN;
        goto Error;
    }

    //
    // In a mixed domain mode, cannot nest local groups with other local groups.
    // if the group is security enabled
    //

    if ((DownLevelDomainControllersPresent(AccountContext->DomainIndex))
          && (SecurityEnabled)
          && (MemberContext->TypeBody.Group.NT4GroupType == NT4LocalGroup)
          && (NT4GroupType == NT4LocalGroup))
    {
        //
        // We can concievably add a new error code. However that will still confuse
        // down level clients
        //

        NtStatus = STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN;
        goto Error;
    }

    //
    // Cannot ever add a resource(local) group as a member of an
    // account(global) group
    //

    if ((NT5GroupType==NT5AccountGroup)
        && (MemberContext->TypeBody.Group.NT5GroupType == NT5ResourceGroup))
    {
        NtStatus = STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER;
        goto Error;
    }

    //
    // Global groups can't have app groups
    //
    if ((NT5GroupType==NT5AccountGroup)
        && ((MemberContext->TypeBody.Group.NT5GroupType == NT5AppBasicGroup)
         || (MemberContext->TypeBody.Group.NT5GroupType == NT5AppQueryGroup))
        )
    {
        NtStatus = STATUS_INVALID_MEMBER;
        goto Error;
    }

    //
    // Cannot ever add a universal group as a member of an account group
    //

    if ((NT5GroupType==NT5AccountGroup)
        && (MemberContext->TypeBody.Group.NT5GroupType==NT5UniversalGroup))
    {
        NtStatus = STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER;
        goto Error;
    }

    //
    // Cannot add a resource group as a member of a  universal group
    //

     if ((NT5GroupType==NT5UniversalGroup)
        && (MemberContext->TypeBody.Group.NT5GroupType==NT5ResourceGroup))
    {
        NtStatus = STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER;
        goto Error;
    }

    //
    // Universal groups can't have app groups
    //
    if ((NT5GroupType==NT5UniversalGroup)
       && ((MemberContext->TypeBody.Group.NT5GroupType == NT5AppBasicGroup)
       ||  (MemberContext->TypeBody.Group.NT5GroupType == NT5AppQueryGroup)))
   {
       NtStatus = STATUS_INVALID_MEMBER;
       goto Error;
   }

Error:

    if (NULL!=MemberContext)
    {

        SampDeleteContext(MemberContext);
    }

    return NtStatus;
}


NTSTATUS
SampEnforceCrossDomainGroupMembershipChecks(
    IN PSAMP_OBJECT     AccountContext,
    IN PSID             MemberSid,
    IN DSNAME           *MemberName
    )
/*++

    This routine enforces cross domain group membership checks
    by looking up the member in the GC verify cache, obtaining the
    group Type and enforcing the checks pertaining to "limited groups".

    Parameters:
        AccountContext  SAM context to the account
        MemberSid       The Sid of the member
        MemberName      The DSNAME of the member. Note that we pass in
                        both DSNAME and Sid. This is because there is
                        no DSNAME in the workstation case. Passing in the
                        SID allows the routine to be easily extended to
                        the workstation case if necessary, in which case
                        the MemberName parameter will become an OPTIONAL
                        parameter.

    Return Values

        STATUS_SUCCESS
        STATUS_INVALID_MEMBER --- Note Comment above regarding downlevel
                                  compatibility applies here too.

--*/

{
    NTSTATUS        NtStatus;
    NT4_GROUP_TYPE  NT4GroupType;
    NT5_GROUP_TYPE  NT5GroupType;
    BOOLEAN         SecurityEnabled;
    ENTINF          *pEntinf;
    ULONG           MemberGroupType;
    ATTR            *GroupTypeAttr;
    ATTR            *ObjectClassAttr = NULL;
    BOOLEAN         LocalSid=FALSE;
    BOOLEAN         WellKnownSid=FALSE;
    BOOLEAN         ForeignSid = FALSE;
    BOOLEAN         EnterpriseSid = FALSE;
    BOOLEAN         BuiltinDomainSid = FALSE;
    BOOLEAN         IsGroup = FALSE;
    ULONG           i;


    ASSERT(IsDsObject(AccountContext));

    if ( AccountContext->TrustedClient )
    {
        return(STATUS_SUCCESS);
    }

    //
    // Get the type of the group that we are modifying
    //

    if (SampAliasObjectType==AccountContext->ObjectType)
    {
        NT4GroupType = AccountContext->TypeBody.Alias.NT4GroupType;
        NT5GroupType = AccountContext->TypeBody.Alias.NT5GroupType;
        SecurityEnabled = AccountContext->TypeBody.Alias.SecurityEnabled;
    }
    else if (SampGroupObjectType == AccountContext->ObjectType)
    {
        NT4GroupType = AccountContext->TypeBody.Group.NT4GroupType;
        NT5GroupType = AccountContext->TypeBody.Group.NT5GroupType;
        SecurityEnabled = AccountContext->TypeBody.Group.SecurityEnabled;
    }
    else
    {
        ASSERT(FALSE && "Invalid Object Type");
        return STATUS_INTERNAL_ERROR;
    }

    //
    // An account group cannot have a cross domain member
    //

    if (NT5AccountGroup == NT5GroupType)
        return STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER;

    //
    // A security enabled NT4 Global group cannot have cross domain member
    // in a mixed domain
    //

    if ((DownLevelDomainControllersPresent(AccountContext->DomainIndex))
        && (NT4GlobalGroup == NT4GroupType)
        && (SecurityEnabled))
        return STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER;

    //
    // Examine the SID of the member
    //

    NtStatus = SampDsExamineSid(
                    MemberSid,
                    &WellKnownSid,
                    &BuiltinDomainSid,
                    &LocalSid,
                    &ForeignSid,
                    &EnterpriseSid
                    );

    if (!NT_SUCCESS(NtStatus))
        return NtStatus;

    if ((WellKnownSid) && (!IsBuiltinDomain(AccountContext->DomainIndex)))
    {
        //
        // A SID like everyone sid cannot be
        // a member of a group other than the builtin domain groups
        //

        return (STATUS_INVALID_MEMBER);
    }
    else if ( BuiltinDomainSid)
    {
        //
        // Group like Administrators etc cannot be a member of
        // anything else
        //

        return ( STATUS_INVALID_MEMBER);
    }
    else if ((ForeignSid) || (WellKnownSid))
    {

        if ( (NT5ResourceGroup==NT5GroupType)
          || (NT5AppBasicGroup==NT5GroupType)
          || (NT5AppQueryGroup==NT5GroupType) )
        {
            //
            // These will be added as an FPO to resource groups
            //

            return (STATUS_SUCCESS);
        }
        else if (NT5UniversalGroup==NT5GroupType)
        {
            //
            // Universal groups cannot have foriegn Security
            // prinicpals as members
            //

            return (STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS);
        }
        else
        {
            //
            // Must be a account group, no memberships from other
            // domains
            //

            return(STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER);
        }
    }


    //
    // By the time we reach here the member cannot be
    // anything other than the 2 below
    //

    ASSERT(LocalSid||EnterpriseSid);

    //
    // The DS Name of the member must be known
    //

    ASSERT(NULL!=MemberName);

    //
    // If either the member is local or if we are a GC, then
    // do the check locally
    //

    if ((SampAmIGC()) || (LocalSid))
    {
        ATTRTYP RequiredAttrTyp[] = {
                                     SAMP_FIXED_GROUP_OBJECTCLASS,
                                     SAMP_FIXED_GROUP_TYPE
                                    };
        ATTRVAL RequiredAttrVal[] = {{0,NULL},{0,NULL}};
        DEFINE_ATTRBLOCK2(RequiredAttrs,RequiredAttrTyp,RequiredAttrVal);
        ATTRBLOCK   ReadAttrs;

        //
        // If we are the GC ourselves try to read the group type
        // and object class properties from the local DS.
        //

        NtStatus = SampDsRead(
                    MemberName,
                    0,
                    SampGroupObjectType,
                    &RequiredAttrs,
                    &ReadAttrs
                    );

        if (!NT_SUCCESS(NtStatus))
        {
            return STATUS_DS_INVALID_GROUP_TYPE;
        }

        GroupTypeAttr = SampDsGetSingleValuedAttrFromAttrBlock(
                            SAMP_FIXED_GROUP_TYPE,
                            &ReadAttrs
                            );
        for (i=0;i<ReadAttrs.attrCount;i++)
        {
            if (ReadAttrs.pAttr[i].attrTyp==SAMP_FIXED_GROUP_OBJECTCLASS)
            {
               ObjectClassAttr = &(ReadAttrs.pAttr[i]);
               break;
            }
        }


    }
    else
    {

        //
        // Check the verify cache for the attributes
        //

        pEntinf = GCVerifyCacheLookup(MemberName);
        if (NULL==pEntinf)
        {
            //
            // Verfiy Cache lookup failed
            //

            return STATUS_DS_INVALID_GROUP_TYPE;
        }

        GroupTypeAttr = SampDsGetSingleValuedAttrFromAttrBlock(
                            SampDsAttrFromSamAttr(SampGroupObjectType,
                                            SAMP_FIXED_GROUP_TYPE),
                            &pEntinf->AttrBlock
                            );

        for (i=0;i<pEntinf->AttrBlock.attrCount;i++)
        {
            if (pEntinf->AttrBlock.pAttr[i].attrTyp==ATT_OBJECT_CLASS)
            {
               ObjectClassAttr = &(pEntinf->AttrBlock.pAttr[i]);
               break;
            }
        }
    }

    ASSERT(NULL!=ObjectClassAttr);

    //
    // Check if the object is derived from group or is of class group
    //

    for (i=0;i<ObjectClassAttr->AttrVal.valCount;i++)
    {
        if ((ObjectClassAttr->AttrVal.pAVal[i].valLen) &&
           (NULL!=ObjectClassAttr->AttrVal.pAVal[i].pVal) &&
           (CLASS_GROUP == * ((UNALIGNED ULONG *)ObjectClassAttr->AttrVal.pAVal[i].pVal)) )
        {
            IsGroup = TRUE;
            break;
        }
    }

    if (!IsGroup)
    {
        //
        // Assume for now that the member is not a group.
        // therefore return success.
        //

        return STATUS_SUCCESS;
    }

    ASSERT(NULL!=GroupTypeAttr && "Groups must have a group type");
    if (NULL==GroupTypeAttr)
    {
         return(STATUS_INVALID_MEMBER);
    }

    MemberGroupType = * ((UNALIGNED ULONG *)GroupTypeAttr->AttrVal.pAVal[0].pVal);

    //
    // An universal group cannot have a resource group as a member
    //

    if ((NT5UniversalGroup==NT5GroupType)
            && (MemberGroupType & GROUP_TYPE_RESOURCE_BEHAVOIR))
    {
        return STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER;
    }

    //
    // A Resource group cannot have another cross domain resource
    // group as a member
    //


    if ((NT5ResourceGroup==NT5GroupType)
            && (MemberGroupType & GROUP_TYPE_RESOURCE_BEHAVOIR))
    {
        return STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER;
    }

    //
    // App groups can't have resource-type groups from other domains
    //

    if ( ((NT5AppBasicGroup==NT5GroupType)
      ||  (NT5AppQueryGroup==NT5GroupType))
            && (MemberGroupType & GROUP_TYPE_RESOURCE_BEHAVOIR))
    {
        return STATUS_INVALID_MEMBER;
    }

    return STATUS_SUCCESS;
}




NTSTATUS
SampAddSameDomainMemberToGlobalOrUniversalGroup(
    IN  PSAMP_OBJECT AccountContext,
    IN  ULONG        MemberId,
    IN  ULONG        Attributes,
    IN  DSNAME       *MemberDsName OPTIONAL
    )
/*++
    Routine Description:

    This routine is used add a member from the
    same domain for globalgroups and universal groups. It performs
    the same domain group consistency checks and the primary group
    id related optimization/consistency checks.


Parameters:

    AccountContext - The handle of an opened group to operate on.

    MemberId - Relative ID of the member to add.

    Attributes - The attributes of the group assigned to the user.
        The attributes assigned here may have any value.  However,
        at logon time these attributes are minimized by the
        attributes of the group as a whole.

    MemberDsName -- The DS name of the member if already known. Saves
                    a lookup by RID

Return Values:

    STATUS_SUCCESS - The Service completed successfully.


    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_MEMBER - The member specified is unknown.

    STATUS_MEMBER_IN_GROUP - The member already belongs to the group.

    STATUS_INVALID_GROUP_ATTRIBUTES - Indicates the group attribute
        values being assigned to the member are not compatible with
        the attribute values of the group as a whole.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    SAMP_V1_0A_FIXED_LENGTH_GROUP  GroupV1Fixed;
    NTSTATUS                NtStatus, TmpStatus;
    BOOLEAN                 UserAccountActive;
    BOOLEAN                 PrimaryGroup;
    ULONG                   ObjectRid = AccountContext->TypeBody.Group.Rid;



    NtStatus = SampRetrieveGroupV1Fixed(
                   AccountContext,
                   &GroupV1Fixed
                   );


    if (NT_SUCCESS(NtStatus)) {

        //
        // Perform the user object side of things
        //

        //
        // Add Group to User Membership Checks for the existance of the user
        // and then depending upon DS/Registry case adds the group to the
        // user's reverse membership. The reverse membership addition is not
        // done in the DS case
        //

        NtStatus = SampAddGroupToUserMembership(
                       AccountContext,
                       ObjectRid,
                       Attributes,
                       MemberId,
                       (GroupV1Fixed.AdminCount == 0) ? NoChange : AddToAdmin,
                       (GroupV1Fixed.OperatorCount == 0) ? NoChange : AddToAdmin,
                       &UserAccountActive,
                       &PrimaryGroup
                       );

       if ((NtStatus == STATUS_NO_SUCH_USER)
            &&  ( IsDsObject(AccountContext)))
       {
           //
           // It is not an User Object. It can be a group Object
           // as from NT5 Onwards we support adding groups to group
           // memberships. This must be done only for the DS case.
           // There are several restrictions depending upon the type of
           // the group, and these will need to be check for
           //

           NtStatus = SampEnforceSameDomainGroupMembershipChecks(
                            AccountContext,
                            MemberId
                            );
       }
       else if (   (NT_SUCCESS(NtStatus))
                && (IsDsObject(AccountContext))
                && (PrimaryGroup))
       {
           //
           // In the DS the group membership in the primary group is
           // maintained implicitly in the primary group Id property.
           // therefore we will fail the call with a status member in
           // group
           //

           NtStatus = STATUS_MEMBER_IN_GROUP;
       }


        //
        // Now perform the group side of things
        //

        if (NT_SUCCESS(NtStatus)) {


            //
            // Add the user to the group (should not fail)
            // This addition is not done in the DS case, if the group
            // specified is the primary group of the user. This is because the
            // primarly group membership is maintained implicitly in the primary
            // group id property.
            //



            NtStatus = SampAddAccountToGroupMembers(
                           AccountContext,
                           MemberId,
                           MemberDsName
                           );

        }
    }

    return NtStatus;
}


NTSTATUS
SampRemoveSameDomainMemberFromGlobalOrUniversalGroup(
    IN  PSAMP_OBJECT AccountContext,
    IN  ULONG        MemberId,
    IN  DSNAME       *MemberDsName OPTIONAL
    )
/*++
    Routine Description:

    This is the actual worker routine for removing a member from a
    global/universal group in the same domain.


    WARNING : THIS ROUTINE MUST BE CALLED WITH THE WRITELOCK HELD
              IN THE REGISTY CASE
Parameters:

    AccountContext - The handle of an opened group to operate on.

    MemberId - Relative ID of the member to add.

    MemberDsName -- The DS Name of the member, if already known

Return Values:

    STATUS_SUCCESS - The Service completed successfully.


    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_MEMBER - The member specified is unknown.

    STATUS_MEMBER_IN_GROUP - The member already belongs to the group.



    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    SAMP_V1_0A_FIXED_LENGTH_GROUP  GroupV1Fixed;
    NTSTATUS                NtStatus, TmpStatus;
    ULONG                   ObjectRid;
    BOOLEAN                 UserAccountActive;
    UNICODE_STRING          GroupName;





    ObjectRid = AccountContext->TypeBody.Group.Rid;


    NtStatus = SampRetrieveGroupV1Fixed(
                   AccountContext,
                   &GroupV1Fixed
                   );


    if (NT_SUCCESS(NtStatus)) {


        //
        // Perform the user object side of things
        //

        NtStatus = SampRemoveMembershipUser(
                       AccountContext,
                       ObjectRid,
                       MemberId,
                       (GroupV1Fixed.AdminCount == 0) ? NoChange : RemoveFromAdmin,
                       (GroupV1Fixed.OperatorCount == 0) ? NoChange : RemoveFromAdmin,
                       &UserAccountActive
                       );
       if ((NtStatus == STATUS_NO_SUCH_USER)
                && (IsDsObject(AccountContext)))
       {
           //
           // It is not an User Object. It can be a group Object
           // as from win2k onwards, Therefore reset the status
           // code
           //



            NtStatus = STATUS_SUCCESS;
       }


        //
        // Now perform the group side of things
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // Remove the user from the group
            //

            NtStatus = SampRemoveAccountFromGroupMembers(
                           AccountContext,
                           MemberId,
                           MemberDsName
                           );
        }
    }




    return NtStatus;
}

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  Services Available to NT5 SAM In process clients                        //
//                                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

NTSTATUS
SamIAddDSNameToGroup(
    IN SAMPR_HANDLE GroupHandle,
    IN DSNAME   *   DSName
    )
/*
    Routine Description

        Adds the given DSNAME to membership list of the group specified by
        Group Handle

    Arguments:

        GroupHandle -- SAMPR_HANDLE returned by an Open Group
        DSName      -- Pointer to a DSNAME structure. The caller is responsible for
                       Allocating / freeing this structure

    Return Values:

            STATUS_SUCCESS
            Other error codes from DsLayer

*/
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    NTSTATUS            TmpStatus;
    PSAMP_OBJECT        AccountContext;
    SAMP_OBJECT_TYPE    FoundType;
    PSID                Sid = NULL;
    DSNAME              *ImprovedDSName = NULL;


    SAMTRACE("SamIAddDSNameToGroup");


    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidAddMemberToGroup
                   );

    SampUpdatePerformanceCounters(
        DSSTAT_MEMBERSHIPCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );



    //
    // Reference the context
    //

    AccountContext = (PSAMP_OBJECT)(GroupHandle);
    SampReferenceContext(AccountContext);


    if (IsDsObject(AccountContext))
    {
       //
       // See what the DSNAME represents.
       //

       NtStatus = SampValidateDSName(
                    AccountContext,
                    DSName,
                    &Sid,
                    &ImprovedDSName
                    );

       if ( NT_SUCCESS(NtStatus))
       {

           if (NULL!=Sid)
           {

               //
               // This is the case of a security prinicipal,
               // split the SID into a DomainSid and a Rid.
               //

               ULONG Rid;
               PSID  DomainSid = NULL;

               NtStatus = SampSplitSid(Sid, &DomainSid, &Rid);


               if (NT_SUCCESS(NtStatus))
               {

                   if (RtlEqualSid(DomainSid,
                        DomainSidFromAccountContext(AccountContext)))
                   {

                        //
                        // Member to be added is in the same domain.
                        // Add the member to the group
                        // The below routine is common code path with
                        // the downlevel SamrAddMemberToGroup routine.
                        // Specifically the routine will call the
                        // Same Domain Consistency Check routine,
                        // enforce constraints such as primary group etc
                        // and then add the member to the group.
                        //

                        NtStatus =
                           SampAddSameDomainMemberToGlobalOrUniversalGroup(
                                        AccountContext,
                                        Rid,
                                        0,
                                        ImprovedDSName
                                        );


                   }
                   else
                   {
                         //
                        // The member to be added belongs to a different
                        // domain than which the group belongs to
                        //

                        NtStatus = SampEnforceCrossDomainGroupMembershipChecks(
                                        AccountContext,
                                        Sid,
                                        ImprovedDSName
                                        );

                        //
                        // Add the member to the group
                        //

                        if (NT_SUCCESS(NtStatus))
                        {

                            NtStatus = SampAddAccountToGroupMembers(
                                            AccountContext,
                                            0,
                                            ImprovedDSName
                                            );
                        }
                   }


                   MIDL_user_free(DomainSid);
                   DomainSid = NULL;
               }

           }
           else
           {


               //
               // No further checks are performed for the case of a non security
               // principal, simply add the member and audit
               //

               NtStatus = SampAddAccountToGroupMembers(
                                AccountContext,
                                0,
                                ImprovedDSName
                                );
           }

       }
    }
    else
    {
       //
       // Should never expect to hit this call in registry mode
       //

       ASSERT(FALSE && "SamIAddDSNameToGroup in Registry Mode !!!!");

       NtStatus = STATUS_INVALID_PARAMETER;
    }



    //
    // Dereference the context
    //

    if (NT_SUCCESS(NtStatus))
    {
        SampDeReferenceContext(AccountContext,TRUE);
    }
    else
    {
        SampDeReferenceContext(AccountContext,FALSE);
    }


    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidAddMemberToGroup
                   );

    return NtStatus;

}

NTSTATUS
SamIRemoveDSNameFromGroup(
    IN SAMPR_HANDLE GroupHandle,
    IN DSNAME   *   DSName
    )
/*
    Routine Description

        Removes the given DSNAME to membership list of the group specified by
        Group Handle

    Arguments:

        GroupHandle -- SAMPR_HANDLE returned by an Open Group
        DSName      -- Pointer to a DSNAME structure. The caller is responsible for
                       Allocating / freeing this structure

    Return Values:

            STATUS_SUCCESS
            Other error codes from DsLayer

*/
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    NTSTATUS            TmpStatus;
    PSAMP_OBJECT        AccountContext;
    SAMP_OBJECT_TYPE    FoundType;
    PSID                Sid = NULL;
    DSNAME              *ImprovedDSName = NULL;


    SAMTRACE("SamIRemoveDSNameFromGroup");


    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidRemoveMemberFromGroup
                   );


    SampUpdatePerformanceCounters(
        DSSTAT_MEMBERSHIPCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );



    //
    // Reference the context. The handle is being assumed to be
    // valid -- called from ntdsa - trusted code.
    //
    AccountContext = (PSAMP_OBJECT)(GroupHandle);
    SampReferenceContext(AccountContext
                     );

   if (IsDsObject(AccountContext))
   {

       //
       // See what the DSNAME represents.
       //

       NtStatus = SampValidateDSName(
                    AccountContext,
                    DSName,
                    &Sid,
                    &ImprovedDSName
                    );

       if ( NT_SUCCESS(NtStatus))
       {
           BOOLEAN fMemberRemoved = FALSE;

           if (NULL!=Sid)
           {
               PSID DomainSid = NULL;
               ULONG Rid;


               //
               // This is a security principal
               //

               NtStatus = SampSplitSid(Sid,&DomainSid,&Rid);


               if (NT_SUCCESS(NtStatus))
               {

                    if ( RtlEqualSid(DomainSid,
                            DomainSidFromAccountContext(AccountContext)))
                    {


                      //
                      // Member to be removed is in the same domain.
                      // In this case do exactly what the downlevel
                      // API SamrRemoveMemberFromGroup did.
                      //



                      NtStatus =
                      SampRemoveSameDomainMemberFromGlobalOrUniversalGroup(
                                        GroupHandle,
                                        Rid,
                                        ImprovedDSName
                                        );
                      fMemberRemoved = TRUE;
                    }


                    MIDL_user_free(DomainSid);
                    DomainSid = NULL;
               }
           }


           if ((NT_SUCCESS(NtStatus))
               && (!fMemberRemoved))
           {


               //
               // This is the case of either a security principal from a
               // different domain , or a non security principal
               // Remove the Membership by making direct calls to the DS.
               //



               NtStatus = SampRemoveAccountFromGroupMembers(
                                AccountContext,
                                0,
                                ImprovedDSName
                                );


           }

       }
   }
   else
   {
       //
       // Should never expect to hit this call in registry mode
       //

       ASSERT(FALSE && "SamIAddDSNameToGroup in Registry Mode !!!!");
       NtStatus = STATUS_INVALID_PARAMETER;
   }

    //
    // Dereference the context
    //

    if (NT_SUCCESS(NtStatus))
    {
        SampDeReferenceContext(AccountContext,TRUE);
    }
    else
    {
        SampDeReferenceContext(AccountContext,FALSE);
    }

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidRemoveMemberFromGroup
                   );

    return NtStatus;

}


NTSTATUS
SampCheckAccountToUniversalConversion(
    DSNAME * GroupToBeConverted
    )
/*++

    Routine Description

        This routine Looks at the group membership list and determines
        if the group can be converted from a Account to a Universal Group.


    Parameters

        GroupToBeConverted - This is the group that we will change from an  account group
                             To a universal group.

    Return Values

        STATUS_SUCCESS
        STATUS_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER
--*/
{
    NTSTATUS    NtStatus = STATUS_NOT_SUPPORTED;
    ATTRTYP     MemberType[] = {SAMP_FIXED_GROUP_MEMBER_OF};
    ATTRVAL     MemberVal[] = {0,NULL};
    DEFINE_ATTRBLOCK1(MemberAttrBlock,MemberType,MemberVal);
    ATTRTYP     GroupTypeAttrs[]  = {SAMP_FIXED_GROUP_TYPE,
                                     SAMP_FIXED_GROUP_OBJECTCLASS };
    ATTRVAL     GroupTypeVal[] = {{0,NULL},{0,NULL}};
    DEFINE_ATTRBLOCK2(GroupTypeAttrBlock,GroupTypeAttrs,GroupTypeVal);
    ATTRBLOCK    ReadMemberAttrBlock, ReadGroupAttrBlock;
    ULONG        memberCount;
    ULONG        i;



    // Get the membership list of the group
    //

    NtStatus = SampDsRead(
                GroupToBeConverted,
                0,
                SampGroupObjectType,
                &MemberAttrBlock,
                &ReadMemberAttrBlock
                );


    if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus)
    {
        //
        // For the case of the empty group no further checks need
        // be enforced.
        //

        NtStatus = STATUS_SUCCESS;
        goto Error;
    }

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    ASSERT(ReadMemberAttrBlock.pAttr[0].attrTyp == SAMP_FIXED_GROUP_MEMBER_OF);
    ASSERT(ReadMemberAttrBlock.attrCount==1);
    ASSERT(ReadMemberAttrBlock.pAttr[0].AttrVal.valCount>0);

    memberCount = ReadMemberAttrBlock.pAttr[0].AttrVal.valCount;
    ASSERT(memberCount>=1);

    //
    // For each of the members in the membership list read the
    // group type and Object Class
    //

    for (i=0; (i<memberCount);i++)
    {
        DSNAME * MemberName;

        MemberName = (DSNAME *)ReadMemberAttrBlock.pAttr[0].AttrVal.pAVal[i].pVal;

        NtStatus = SampDsRead(
                     MemberName,
                     0,
                     SampGroupObjectType,
                     &GroupTypeAttrBlock,
                     &ReadGroupAttrBlock
                    );

        if ((NT_SUCCESS(NtStatus))
            && (2==ReadGroupAttrBlock.attrCount))
        {

            //
            // Must be a group, read both Group type and object class,
            // member must be a group
            //

            ULONG            GroupType;
            ULONG            ObjectClass;
            NT4_GROUP_TYPE   Nt4GroupType;
            NT5_GROUP_TYPE   Nt5GroupType;
            BOOLEAN          SecurityEnabled;

            //
            // Assert that DS results are consistent with what we expect
            //

            ASSERT(ReadGroupAttrBlock.pAttr[0].attrTyp == SAMP_FIXED_GROUP_TYPE);
            ASSERT(ReadGroupAttrBlock.pAttr[1].attrTyp == SAMP_FIXED_GROUP_OBJECTCLASS);

            ASSERT(ReadGroupAttrBlock.pAttr[0].AttrVal.valCount==1);
            ASSERT(ReadGroupAttrBlock.pAttr[1].AttrVal.valCount>=1);

            ASSERT(ReadGroupAttrBlock.pAttr[0].AttrVal.pAVal[0].valLen==sizeof(ULONG));
            ASSERT(ReadGroupAttrBlock.pAttr[1].AttrVal.pAVal[0].valLen==sizeof(ULONG));

            GroupType =
                *((ULONG *) ReadGroupAttrBlock.pAttr[0].AttrVal.pAVal[0].pVal);
            ObjectClass =
                *((ULONG *) ReadGroupAttrBlock.pAttr[1].AttrVal.pAVal[0].pVal);

            //
            // Compute the type of the group
            //

            NtStatus = SampComputeGroupType(
                            ObjectClass,
                            GroupType,
                            &Nt4GroupType,
                            &Nt5GroupType,
                            &SecurityEnabled
                            );

            if (NT_SUCCESS(NtStatus))
            {
                if (NT5AccountGroup == Nt5GroupType)
                {
                    NtStatus = STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER;
                    break;
                }
            }
        }

    } // End of For

Error:

    return NtStatus;

}

NTSTATUS
SampCheckResourceToUniversalConversion(
    DSNAME * GroupToBeConverted
    )
/*++

    Routine Description

        This routine Looks at the group membership list and determines
        if the group can be converted from a Resource to a Universal Group.

        An Universal group can have as members anything except resource groups
        and can be the member of any group.

        A resource group can have account and universal groups from anywhere and
        resource groups from the same domain.

        For a resource group to be converted to a universal group, it is only
        necessary to check that none of the members are resource groups

    Parameters

        GroupObjectToBeConveted -- The DSNAME of the group object to be converted

    Return Values

        STATUS_SUCCESS
        STATUS_NOT_SUPPORTED
--*/
{
    NTSTATUS    NtStatus = STATUS_NOT_SUPPORTED;
    ATTRTYP     MemberType[] = {SAMP_GROUP_MEMBERS};
    ATTRVAL     MemberVal[] = {0,NULL};
    DEFINE_ATTRBLOCK1(MemberAttrBlock,MemberType,MemberVal);
    ATTRTYP     GroupTypeAttrs[]  = {SAMP_FIXED_GROUP_TYPE,
                                SAMP_FIXED_GROUP_OBJECTCLASS };
    ATTRVAL     GroupTypeVal[] = {{0,NULL},{0,NULL}};
    DEFINE_ATTRBLOCK2(GroupTypeAttrBlock,GroupTypeAttrs,GroupTypeVal);
    ATTRBLOCK    ReadMemberAttrBlock, ReadGroupAttrBlock;
    ULONG        memberCount;
    ULONG        i;



    // Get the membership list of the group
    //

    NtStatus = SampDsRead(
                GroupToBeConverted,
                0,
                SampGroupObjectType,
                &MemberAttrBlock,
                &ReadMemberAttrBlock
                );


    if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus)
    {
        //
        // For the case of the empty group no further checks need
        // be enforced.
        //

        NtStatus = STATUS_SUCCESS;
        goto Error;
    }

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    ASSERT(ReadMemberAttrBlock.pAttr[0].attrTyp == SAMP_GROUP_MEMBERS);
    ASSERT(ReadMemberAttrBlock.attrCount==1);
    ASSERT(ReadMemberAttrBlock.pAttr[0].AttrVal.valCount>0);

    memberCount = ReadMemberAttrBlock.pAttr[0].AttrVal.valCount;
    ASSERT(memberCount>=1);

    //
    // For each of the members in the membership list read the
    // group type and Object Class
    //

    for (i=0; (i<memberCount);i++)
    {
        DSNAME * MemberName;

        MemberName = (DSNAME *)ReadMemberAttrBlock.pAttr[0].AttrVal.pAVal[i].pVal;

        NtStatus = SampDsRead(
                     MemberName,
                     0,
                     SampGroupObjectType,
                     &GroupTypeAttrBlock,
                     &ReadGroupAttrBlock
                    );

        if ((NT_SUCCESS(NtStatus))
            && (2==ReadGroupAttrBlock.attrCount))
        {

            //
            // Must be a group, read both Group type and object class,
            // member must be a group
            //

            ULONG            GroupType;
            ULONG            ObjectClass;
            NT4_GROUP_TYPE   Nt4GroupType;
            NT5_GROUP_TYPE   Nt5GroupType;
            BOOLEAN          SecurityEnabled;

            //
            // Assert that DS results are consistent with what we expect
            //

            ASSERT(ReadGroupAttrBlock.pAttr[0].attrTyp == SAMP_FIXED_GROUP_TYPE);
            ASSERT(ReadGroupAttrBlock.pAttr[1].attrTyp == SAMP_FIXED_GROUP_OBJECTCLASS);

            ASSERT(ReadGroupAttrBlock.pAttr[0].AttrVal.valCount==1);
            ASSERT(ReadGroupAttrBlock.pAttr[1].AttrVal.valCount>=1);

            ASSERT(ReadGroupAttrBlock.pAttr[0].AttrVal.pAVal[0].valLen==sizeof(ULONG));
            ASSERT(ReadGroupAttrBlock.pAttr[1].AttrVal.pAVal[0].valLen==sizeof(ULONG));

            GroupType =
                *((ULONG *) ReadGroupAttrBlock.pAttr[0].AttrVal.pAVal[0].pVal);
            ObjectClass =
                *((ULONG *) ReadGroupAttrBlock.pAttr[1].AttrVal.pAVal[0].pVal);

            //
            // Compute the type of the group
            //

            NtStatus = SampComputeGroupType(
                            ObjectClass,
                            GroupType,
                            &Nt4GroupType,
                            &Nt5GroupType,
                            &SecurityEnabled
                            );

            if (NT_SUCCESS(NtStatus))
            {
                if (NT5ResourceGroup == Nt5GroupType)
                {
                    NtStatus = STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER;
                    break;
                }

                //
                // Universal can't contain app groups
                //
                if (  (NT5AppQueryGroup == Nt5GroupType)
                   || (NT5AppBasicGroup == Nt5GroupType))
                {
                    NtStatus = STATUS_NOT_SUPPORTED;
                    break;
                }
            }
        }
        else if (((NT_SUCCESS(NtStatus))
                   && (1==ReadGroupAttrBlock.attrCount)))
        {

            //
            // The read succeeded. Must be able to retrive the object class
            // but not the group type
            //

            ULONG            ObjectClass;

            ASSERT(1==ReadGroupAttrBlock.attrCount);
            ASSERT(ReadGroupAttrBlock.pAttr[0].attrTyp == SAMP_FIXED_GROUP_OBJECTCLASS);

            ObjectClass =
                *((ULONG *) ReadGroupAttrBlock.pAttr[0].AttrVal.pAVal[0].pVal);


            if (CLASS_FOREIGN_SECURITY_PRINCIPAL==ObjectClass)
            {
                NtStatus = STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS;
                break;
            }
            else
            {
                NtStatus  = STATUS_SUCCESS;
            }
        }
        else if ((STATUS_OBJECT_NAME_NOT_FOUND==NtStatus)
                 || (STATUS_NOT_FOUND==NtStatus))
        {
            //
            // We have positioned on a phantom maybe, its O.K proceed through
            //

            NtStatus = STATUS_SUCCESS;
        }
        else
        {
            //
            // Some other resource failure has occured. Fail the operation
            //

            break;
        }
    } // End of For

Error:

    return NtStatus;

}

NTSTATUS
SampCheckUniversalToAccountConversion(
    DSNAME * GroupToBeConverted
    )
/*++

    Routine Description

        This routine Looks at the group membership list and determines
        if the group can be converted from a Universal Group to an account group.

        An account group can have only other account group and users from the
        same domain as members.

        An universal group can have account and universal groups and users from anywhere
        as members.

        For a universal group to be converted to a account group, it is necessary
        to check that its members are
            1. From the same domain
            2. Are account groups/users

    Parameters

        GroupObjectToBeConveted -- The DSNAME of the group object to be converted

    Return Values

        STATUS_SUCCESS
        STATUS_NOT_SUPPORTED
--*/
{
    NTSTATUS    NtStatus = STATUS_NOT_SUPPORTED;
    ATTRTYP     MemberType[] = {SAMP_GROUP_MEMBERS};
    ATTRVAL     MemberVal[] = {0,NULL};
    DEFINE_ATTRBLOCK1(MemberAttrBlock,MemberType,MemberVal);
    ATTRTYP     GroupTypeAttrs[]  = {SAMP_FIXED_GROUP_TYPE,
                                SAMP_FIXED_GROUP_OBJECTCLASS };
    ATTRVAL     GroupTypeVal[] = {{0,NULL},{0,NULL}};
    DEFINE_ATTRBLOCK2(GroupTypeAttrBlock,GroupTypeAttrs,GroupTypeVal);
    ATTRBLOCK    ReadMemberAttrBlock, ReadGroupAttrBlock;
    ULONG        memberCount;
    ULONG        i;



    // Get the membership list of the group
    //

    NtStatus = SampDsRead(
                GroupToBeConverted,
                0,
                SampGroupObjectType,
                &MemberAttrBlock,
                &ReadMemberAttrBlock
                );


    if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus)
    {
        //
        // For the case of the empty group no further checks need
        // be enforced.
        //

        NtStatus = STATUS_SUCCESS;
        goto Error;
    }

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    ASSERT(ReadMemberAttrBlock.pAttr[0].attrTyp == SAMP_GROUP_MEMBERS);
    ASSERT(ReadMemberAttrBlock.attrCount==1);
    ASSERT(ReadMemberAttrBlock.pAttr[0].AttrVal.valCount>0);

    memberCount = ReadMemberAttrBlock.pAttr[0].AttrVal.valCount;
    ASSERT(memberCount>=1);

    //
    // For each of the members in the membership list read the
    // group type and Object Class
    //

    for (i=0; (i<memberCount);i++)
    {
        DSNAME * MemberName;

        MemberName = (DSNAME *)ReadMemberAttrBlock.pAttr[0].AttrVal.pAVal[i].pVal;

        //
        // First do the SID check
        //

        if (MemberName->SidLen>0)
        {
            //
            // Member is a security principal, as the member has a SID.
            //

            if (!RtlEqualPrefixSid(&MemberName->Sid,&GroupToBeConverted->Sid))
            {
                //
                // Have a member from a different domain, cannot be converted
                //

                NtStatus = STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER;
                goto Error;
            }
        }
        else
        {
            //
            // Member has no SID, no need for further checks on this member
            //

            continue;
        }

        //
        // Read the group type attribute
        //

        NtStatus = SampDsRead(
                     MemberName,
                     0,
                     SampGroupObjectType,
                     &GroupTypeAttrBlock,
                     &ReadGroupAttrBlock
                    );

        if ((NT_SUCCESS(NtStatus))
            && (2==ReadGroupAttrBlock.attrCount))
        {

            ULONG            GroupType;
            ULONG            ObjectClass;
            NT4_GROUP_TYPE   Nt4GroupType;
            NT5_GROUP_TYPE   Nt5GroupType;
            BOOLEAN          SecurityEnabled;

            //
            // Assert that DS results are consistent with what we expect
            //

            ASSERT(ReadGroupAttrBlock.pAttr[0].attrTyp == SAMP_FIXED_GROUP_TYPE);
            ASSERT(ReadGroupAttrBlock.pAttr[1].attrTyp == SAMP_FIXED_GROUP_OBJECTCLASS);

            ASSERT(ReadGroupAttrBlock.pAttr[0].AttrVal.valCount==1);
            ASSERT(ReadGroupAttrBlock.pAttr[1].AttrVal.valCount>=1);

            ASSERT(ReadGroupAttrBlock.pAttr[0].AttrVal.pAVal[0].valLen==sizeof(ULONG));
            ASSERT(ReadGroupAttrBlock.pAttr[1].AttrVal.pAVal[0].valLen==sizeof(ULONG));

            GroupType =
                *((ULONG *) ReadGroupAttrBlock.pAttr[0].AttrVal.pAVal[0].pVal);
            ObjectClass =
                *((ULONG *) ReadGroupAttrBlock.pAttr[1].AttrVal.pAVal[0].pVal);

            //
            // Compute the type of the group
            //

            NtStatus = SampComputeGroupType(
                            ObjectClass,
                            GroupType,
                            &Nt4GroupType,
                            &Nt5GroupType,
                            &SecurityEnabled
                            );

            if (NT_SUCCESS(NtStatus))
            {
                if (NT5AccountGroup != Nt5GroupType)
                {

                    //
                    // Universal groups should only have other universal groups
                    // and global groups as members
                    //

                    ASSERT(NT5UniversalGroup==Nt5GroupType);

                    if (NT5UniversalGroup==Nt5GroupType)
                    {
                        NtStatus = STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER;
                    }
                    else if (NT5ResourceGroup == Nt5GroupType)
                    {
                        NtStatus = STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER;
                    }
                    else
                    {
                        NtStatus = STATUS_NOT_SUPPORTED;
                    }

                    break;
                }
            }
        }
        else
        {
            //
            // member is not a group, continue iterating over other members
            //

            NtStatus  = STATUS_SUCCESS;
        }
    } // End of For

Error:

    return NtStatus;

}

NTSTATUS
SampCheckUniversalToResourceConversion(
    DSNAME * GroupToBeConverted
    )
/*++

    Routine Description

        This routine Looks at the group's  is member of attribue and determines
        if the group can be converted from a Universal Group to an resource group.

        A resource group can be a member of only other resource groups in the same
        domain

        A universal group can be a member of any universal / resource group anywhere

        For a universal group to be converted to a resource group, it is necessary
        to check that its a member of same domain resource groups only. Since the
        entire reverse membership is available only at a GC, this conversion can be
        performed only on a G.C


    Parameters

        GroupObjectToBeConveted -- The DSNAME of the group object to be converted

    Return Values

        STATUS_SUCCESS
        STATUS_NOT_SUPPORTED
--*/
{
    NTSTATUS    NtStatus = STATUS_NOT_SUPPORTED;
    ATTRTYP     MemberType[] = {SAMP_FIXED_GROUP_MEMBER_OF};
    ATTRVAL     MemberVal[] = {0,NULL};
    DEFINE_ATTRBLOCK1(MemberAttrBlock,MemberType,MemberVal);
    ATTRTYP     GroupTypeAttrs[]  = {SAMP_FIXED_GROUP_TYPE,
                                SAMP_FIXED_GROUP_OBJECTCLASS };
    ATTRVAL     GroupTypeVal[] = {{0,NULL},{0,NULL}};
    DEFINE_ATTRBLOCK2(GroupTypeAttrBlock,GroupTypeAttrs,GroupTypeVal);
    ATTRBLOCK    ReadMemberAttrBlock, ReadGroupAttrBlock;
    ULONG        memberCount;
    ULONG        i;



    //
    // Am I a GC ?
    //

    if (!SampAmIGC())
    {
        NtStatus = STATUS_DS_GC_REQUIRED;
        goto Error;
    }

    //
    // Get the membership list of the group
    //

    NtStatus = SampDsRead(
                GroupToBeConverted,
                0,
                SampGroupObjectType,
                &MemberAttrBlock,
                &ReadMemberAttrBlock
                );


    if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus)
    {
        //
        // For the case of the empty reverse membership no further checks need
        // be enforced.
        //

        NtStatus = STATUS_SUCCESS;
        goto Error;
    }

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    ASSERT(ReadMemberAttrBlock.pAttr[0].attrTyp == SAMP_FIXED_GROUP_MEMBER_OF);
    ASSERT(ReadMemberAttrBlock.attrCount==1);
    ASSERT(ReadMemberAttrBlock.pAttr[0].AttrVal.valCount>0);

    memberCount = ReadMemberAttrBlock.pAttr[0].AttrVal.valCount;
    ASSERT(memberCount>=1);

    //
    // For each of the members in the membership list read the
    // group type and Object Class
    //

    for (i=0; (i<memberCount);i++)
    {
        DSNAME * MemberName;

        MemberName = (DSNAME *)ReadMemberAttrBlock.pAttr[0].AttrVal.pAVal[i].pVal;

        //
        // First do the SID check
        //

        if (MemberName->SidLen>0)
        {
            //
            // Member is a security principal, as the member has a SID.
            //

            if (!RtlEqualPrefixSid(&MemberName->Sid,&GroupToBeConverted->Sid))
            {
                //
                // This group is a member of a  group in a different domain.
                // A resource group can be a member of only resource groups in
                // the same domain. Therefore fail this call.
                //

                NtStatus = STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY;
                goto Error;
            }
        }
        else
        {
            //
            // Member has no SID, no need for further checks on this member
            //

            continue;
        }

        //
        // Read the group type attribute
        //

        NtStatus = SampDsRead(
                     MemberName,
                     0,
                     SampGroupObjectType,
                     &GroupTypeAttrBlock,
                     &ReadGroupAttrBlock
                    );

        if ((NT_SUCCESS(NtStatus))
            && (2==ReadGroupAttrBlock.attrCount))
        {

            ULONG            GroupType;
            ULONG            ObjectClass;
            NT4_GROUP_TYPE   Nt4GroupType;
            NT5_GROUP_TYPE   Nt5GroupType;
            BOOLEAN          SecurityEnabled;

            //
            // Assert that DS results are consistent with what we expect
            //

            ASSERT(ReadGroupAttrBlock.pAttr[0].attrTyp == SAMP_FIXED_GROUP_TYPE);
            ASSERT(ReadGroupAttrBlock.pAttr[1].attrTyp == SAMP_FIXED_GROUP_OBJECTCLASS);

            ASSERT(ReadGroupAttrBlock.pAttr[0].AttrVal.valCount==1);
            ASSERT(ReadGroupAttrBlock.pAttr[1].AttrVal.valCount>=1);

            ASSERT(ReadGroupAttrBlock.pAttr[0].AttrVal.pAVal[0].valLen==sizeof(ULONG));
            ASSERT(ReadGroupAttrBlock.pAttr[1].AttrVal.pAVal[0].valLen==sizeof(ULONG));

            GroupType =
                *((ULONG *) ReadGroupAttrBlock.pAttr[0].AttrVal.pAVal[0].pVal);
            ObjectClass =
                *((ULONG *) ReadGroupAttrBlock.pAttr[1].AttrVal.pAVal[0].pVal);

            //
            // Compute the type of the group
            //

            NtStatus = SampComputeGroupType(
                            ObjectClass,
                            GroupType,
                            &Nt4GroupType,
                            &Nt5GroupType,
                            &SecurityEnabled
                            );

            if (NT_SUCCESS(NtStatus))
            {
                //
                // This group is a member of something other than a resource
                // group in the same domain. Fail the call saying a resource
                // can be members of only other resource groups in the same
                // domain
                //
                if (   (NT5ResourceGroup != Nt5GroupType)
                    && (NT5AppBasicGroup != Nt5GroupType)
                    && (NT5AppQueryGroup != Nt5GroupType))
                {
                    NtStatus = STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY;
                    break;
                }
            }
        }
        else
        {
            //
            // member is not a group, continue iterating over other members
            //

            NtStatus  = STATUS_SUCCESS;
        }
    } // End of For







Error:

    return NtStatus;

}

NTSTATUS
SampCheckAppGroupConversion(
    IN ULONG OldGroupType,
    IN ULONG NewGroupType,
    IN DSNAME *Group
    )
/*++

Routine Description

    This routine verifies that Group can be converted from OldGroupType
    to NewGroupType, for app (ldap and basic) group types.

    Current enforcement includes:

    1) both members, and non-memberships attributes must be empty
    2) the LDAP string must be empty

Parameters:

    OldGroupType -- previous group type (either NT5AppQueryGroup or
                    NT5AppQueryGroup

    NewGroupType -- requested group type (either NT5AppQueryGroup or
                    NT5AppQueryGroup

    Group -- the group on which the operation is occurring.

Return Values:

    STATUS_SUCCESS, STATUS_NOT_SUPPORTED, a resource error otherwise

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG i;
    ATTRVAL ValuesDesired[] =
    {
        { 0, NULL },
        { 0, NULL },
        { 0, NULL }
    };
    ATTRTYP TypesDesired[]=
    {
        SAMP_ALIAS_MEMBERS,
        SAMP_ALIAS_NON_MEMBERS,
        SAMP_ALIAS_LDAP_QUERY
    };
    ATTRBLOCK AttrsRead;
    DEFINE_ATTRBLOCK3(AttrsDesired,TypesDesired,ValuesDesired);

    //
    // Get the required attributes of the alias
    //
    NtStatus = SampDsRead(
                    Group,
                    0,
                    SampAliasObjectType,
                    &AttrsDesired,
                    &AttrsRead
                    );

    if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus)
    {
        NtStatus = STATUS_SUCCESS;
        goto Exit;
    }

    if (!NT_SUCCESS(NtStatus))
        goto Exit;

    for (i = 0;
            i < AttrsRead.attrCount && NT_SUCCESS(NtStatus);
                i++)
    {
        switch (AttrsRead.pAttr[i].attrTyp)
        {
            case SAMP_ALIAS_MEMBERS:
            case SAMP_ALIAS_NON_MEMBERS:
            case SAMP_ALIAS_LDAP_QUERY:
                if (AttrsRead.pAttr[i].AttrVal.valCount > 0)
                {
                    NtStatus = STATUS_DS_GROUP_CONVERSION_ERROR;
                    break;
                }
                break;
            default:
                ASSERT("Wrong attributes returned");
        }
    }

    if (!NT_SUCCESS(NtStatus))
        goto Exit;

Exit:

    return NtStatus;
}

NTSTATUS
SampCheckGroupTypeBits(
    IN ULONG   DomainIndex,
    IN ULONG   GroupType
    )
/*++
    Routine Description

    This routine checks whether the group type bits are
    really valid.

    Parameters:

    DomainIndex -- the domain of the group in question
    GroupType   -- The grouptype that is being set.

    Return Values

    STATUS_SUCCESS
    STATUS_INVALID_PARAMETER

--*/
{

    //
    // One and only one group type bit can be set
    //

    switch(GroupType & (GROUP_TYPE_RESOURCE_GROUP  |
                        GROUP_TYPE_ACCOUNT_GROUP   |
                        GROUP_TYPE_UNIVERSAL_GROUP |
                        GROUP_TYPE_APP_BASIC_GROUP |
                        GROUP_TYPE_APP_QUERY_GROUP) )
    {
    case GROUP_TYPE_RESOURCE_GROUP:
    case GROUP_TYPE_ACCOUNT_GROUP:
    case GROUP_TYPE_UNIVERSAL_GROUP:
    case GROUP_TYPE_APP_BASIC_GROUP:
    case GROUP_TYPE_APP_QUERY_GROUP:
        break;
    default:
        return (STATUS_DS_INVALID_GROUP_TYPE);
    }

    //
    // In Mixed domains dis-allow security enabled universal group creation
    //

    if ((GroupType & GROUP_TYPE_UNIVERSAL_GROUP) && (GroupType & GROUP_TYPE_SECURITY_ENABLED)
        && (SampDefinedDomains[DomainIndex].IsMixedDomain))
    {
        return(STATUS_DS_INVALID_GROUP_TYPE);
    }

    //
    // Clients cannot set the BUILTIN_LOCAL_GROUP bit
    //

    if (GroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
    {
        return(STATUS_DS_INVALID_GROUP_TYPE);
    }

    //
    // App groups can't be security enabled or created in a non-DOT_NET release
    //
    if ( ((GroupType & GROUP_TYPE_APP_QUERY_GROUP)
     ||   (GroupType & GROUP_TYPE_APP_BASIC_GROUP))) {

        if (SampDefinedDomains[DomainIndex].BehaviorVersion
                < DS_BEHAVIOR_WIN_DOT_NET )
        {
            return(STATUS_NOT_SUPPORTED);
        }

        if (GroupType & GROUP_TYPE_SECURITY_ENABLED) {
            return(STATUS_DS_INVALID_GROUP_TYPE);
        }
    }

    return(STATUS_SUCCESS);
}



NTSTATUS
SampWriteGroupType(
    IN SAMPR_HANDLE GroupHandle,
    IN ULONG    GroupType,
    BOOLEAN     SkipChecks
    )
/*++

    Routine Description

        This routine first validates the group type and
        then writes it as part of the database for the group
        in question. It then updates the handle with the appropriate
        information. No action is taken on other open group Handles.
        In addition the sam account type property is changed such that
        groups that are not security enabled do not show up in any of
        the SAM enumeration or Display Information API. This is so that
        NT4 domain controllers do not recieve any information about
        non security enabled groups.

    Parameters:

        GroupHandle -- Handle to the Group ( or Local Group) in Question
        GroupType   -- Value of the Group Type property
        SkipChecks  -- Used by trusted callers to skip checks

    Return Values

        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER

--*/

{
    PSAMP_OBJECT GroupContext = (PSAMP_OBJECT) GroupHandle;
    NTSTATUS     NtStatus=STATUS_SUCCESS, IgnoreStatus;
    ULONG        SamAccountType;
    ATTRTYP      GroupTypeAttr[] = {SAMP_FIXED_GROUP_TYPE,
                                    SAMP_GROUP_ACCOUNT_TYPE};
    ATTRVAL      GroupTypeAttrVal[] = {
                                        {sizeof(ULONG), (UCHAR *)&GroupType},
                                        {sizeof(ULONG), (UCHAR *) &SamAccountType}
                                      };
    DEFINE_ATTRBLOCK2(GroupTypeAttrBlock,GroupTypeAttr,GroupTypeAttrVal);

    NT4_GROUP_TYPE NewNT4GroupType;
    NT5_GROUP_TYPE NewNT5GroupType;
    BOOLEAN        NewSecurityEnabled;
    NT4_GROUP_TYPE *OldNT4GroupType = NULL;
    NT5_GROUP_TYPE *OldNT5GroupType = NULL;
    BOOLEAN         *OldSecurityEnabled = NULL;
    BOOLEAN         fWriteLockAcquired = FALSE;
    BOOLEAN         fDeReferenceContext = FALSE;
    SAMP_OBJECT_TYPE ActualObjectType;
    ULONG             Rid;
    ULONG             PrimaryMemberCount=0;
    PULONG            PrimaryMembers=NULL;

    NtStatus = SampMaybeAcquireWriteLock(GroupContext, &fWriteLockAcquired);
    if (!NT_SUCCESS(NtStatus))
        goto Error;

    NtStatus = SampLookupContext(
                    GroupContext,
                    0,
                    SampGroupObjectType,
                    &ActualObjectType
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        NtStatus = SampLookupContext(
                      GroupContext,
                      0,
                      SampAliasObjectType,
                      &ActualObjectType
                      );
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    fDeReferenceContext = TRUE;


    if (!IsDsObject(GroupContext))
    {
        //
        // We should be getting this call only in
        // DS Mode
        //

        ASSERT(FALSE && "DS Mode Required");
        NtStatus = STATUS_INTERNAL_ERROR;
        goto Error;
    }



    if (!SkipChecks)
    {
        //
        // Check for Valid Combinations of Group Type Bits
        //

        NtStatus = SampCheckGroupTypeBits(
                    GroupContext->DomainIndex,
                    GroupType
                    );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }
    }

    if (SampGroupObjectType==GroupContext->ObjectType)
    {
        OldNT4GroupType = &GroupContext->TypeBody.Group.NT4GroupType;
        OldNT5GroupType = &GroupContext->TypeBody.Group.NT5GroupType;
        OldSecurityEnabled = &GroupContext->TypeBody.Group.SecurityEnabled;
        Rid = GroupContext->TypeBody.Group.Rid;
    }
    else
    {
        OldNT4GroupType = &GroupContext->TypeBody.Alias.NT4GroupType;
        OldNT5GroupType = &GroupContext->TypeBody.Alias.NT5GroupType;
        OldSecurityEnabled = &GroupContext->TypeBody.Alias.SecurityEnabled;
        Rid = GroupContext->TypeBody.Alias.Rid;
    }


    NtStatus = SampComputeGroupType(
                GroupContext->DsClassId,
                GroupType,
                &NewNT4GroupType,
                &NewNT5GroupType,
                &NewSecurityEnabled
                );

    if (!NT_SUCCESS(NtStatus))
        goto Error;


    if (!SkipChecks)
    {
        //
        // Cannot do anything in a mixed domain environment
        //

        if (DownLevelDomainControllersPresent(GroupContext->DomainIndex))
        {

            //
            // Mixed domain case cannot do anything
            //

            if ((*OldSecurityEnabled!=NewSecurityEnabled)
                || (*OldNT4GroupType!=NewNT4GroupType)
                || (*OldNT5GroupType!=NewNT5GroupType))
            {
                NtStatus = STATUS_DS_INVALID_GROUP_TYPE;
                goto Error;
            }
        }
        else
        {

            //
            // Check if some changes are attempted
            //

            if ((*OldSecurityEnabled!=NewSecurityEnabled)
                || (*OldNT4GroupType!=NewNT4GroupType)
                || (*OldNT5GroupType!=NewNT5GroupType))
            {

                //
                // If changes are attempted then
                // Check to see that it is not a builtin account
                // If the caller is a trusted client then he is granted
                // the privilege of modifying even builtin groups
                //
                // Allow the cert admins group to be converted
                // as this may be required in upgrade cases -- the cert
                // group goofed their initial choice of group -- chose a
                // global instead of a domain local and hence we require this
                // change
                //

                if ((!GroupContext->TrustedClient) && (Rid!=DOMAIN_GROUP_RID_CERT_ADMINS))
                {

                    NtStatus = SampIsAccountBuiltIn(Rid);
                    if (!NT_SUCCESS(NtStatus))
                    {
                        goto Error;
                    }
                }

                //
                // If we are going from a Security Enabled to a
                // Security Disabled Group, check that we have no
                // primary members
                //

                if ((*OldSecurityEnabled)
                     && (!NewSecurityEnabled))
                {
                    NtStatus = SampDsGetPrimaryGroupMembers(
                                    DomainObjectFromAccountContext(GroupContext),
                                    Rid,
                                    &PrimaryMemberCount,
                                    &PrimaryMembers
                                    );

                    if (!NT_SUCCESS(NtStatus))
                        goto Error;

                    if (PrimaryMemberCount>0)
                    {

                        NtStatus = STATUS_DS_HAVE_PRIMARY_MEMBERS;
                        goto Error;
                    }

                    //
                    // AZ groups can't be security enabled
                    //
                    if (((*OldNT5GroupType == NT5AppBasicGroup)
                     ||  (*OldNT5GroupType == NT5AppQueryGroup)))
                    {
                        // Should always be security disabled
                        ASSERT(*OldSecurityEnabled);
                        NtStatus = STATUS_NOT_SUPPORTED;
                        goto Error;
                    }
                }
                //
                // Changing Security Enabled is always a legal change
                // Check wether the NT5GroupType changes and whether
                // the change is legal. The NT4GroupType will always
                // depend upon the NT5GroupType, and therefore verifying
                // NT5 GroupType should be sufficient
                //

                if (*OldNT5GroupType!=NewNT5GroupType)
                {
                    if ((*OldNT5GroupType == NT5AccountGroup)
                        && (NewNT5GroupType == NT5UniversalGroup))
                    {
                        //
                        // Account==> Universal;
                        // Need to check the membership lists
                        //

                        NtStatus = SampCheckAccountToUniversalConversion(
                                   GroupContext->ObjectNameInDs
                                   );

                        if (!NT_SUCCESS(NtStatus))
                            goto Error;
                    }
                    else if ((*OldNT5GroupType == NT5ResourceGroup)
                        && (NewNT5GroupType == NT5UniversalGroup))
                    {
                        //
                        // Resource ==> Universal;
                        // Need to check the membership lists
                        //

                        NtStatus = SampCheckResourceToUniversalConversion(
                                        GroupContext->ObjectNameInDs
                                        );

                        if (!NT_SUCCESS(NtStatus))
                            goto Error;
                    }
                    else if  ((*OldNT5GroupType == NT5UniversalGroup)
                        && (NewNT5GroupType == NT5AccountGroup))
                    {
                        //
                        // Universal = > account
                        // Need to check the membership list to see
                        // if there are any cross domain members
                        //

                        NtStatus = SampCheckUniversalToAccountConversion(
                                        GroupContext->ObjectNameInDs
                                        );
                        if (!NT_SUCCESS(NtStatus))
                            goto Error;
                    }
                    else if  ((*OldNT5GroupType == NT5UniversalGroup)
                        && (NewNT5GroupType == NT5ResourceGroup))
                    {
                        NtStatus = SampCheckUniversalToResourceConversion(
                                        GroupContext->ObjectNameInDs
                                        );
                        if (!NT_SUCCESS(NtStatus))
                            goto Error;
                    }
                    else if  ( ((*OldNT5GroupType == NT5AppBasicGroup) &&
                                (NewNT5GroupType == NT5AppQueryGroup))     ||
                               ((*OldNT5GroupType == NT5AppQueryGroup) &&
                                (NewNT5GroupType == NT5AppBasicGroup)))
                    {
                        //
                        // Basic to Query, or vis versa
                        //
                        NtStatus = SampCheckAppGroupConversion(
                                       *OldNT5GroupType,
                                       NewNT5GroupType,
                                       GroupContext->ObjectNameInDs
                                        );
                        if (!NT_SUCCESS(NtStatus))
                            goto Error;
                    }
                    else
                    {
                        NtStatus = STATUS_NOT_SUPPORTED;
                        goto Error;
                    }
                }
            }
        }
    }


    //
    // Set the correct Sam account type, to match the security enabl'd
    // ness and local'group ness of the object
    //
    SamAccountType = SampGetAccountTypeFromGroupType(GroupType);

    NtStatus = SampDsSetAttributes(
                    GroupContext->ObjectNameInDs,
                    0,
                    REPLACE_ATT,
                    SampGroupObjectType,
                    &GroupTypeAttrBlock
                    );


Error:

    if ( (NT_SUCCESS(NtStatus)) &&
         (SampDoAccountAuditing(GroupContext->DomainIndex)) &&
         ((NULL != OldSecurityEnabled) && (NULL != OldNT5GroupType)) &&
         ((*OldSecurityEnabled != NewSecurityEnabled) ||
                   (*OldNT5GroupType != NewNT5GroupType))
       )
    {
        SampAuditGroupTypeChange(GroupContext,
                                 *OldSecurityEnabled,
                                 NewSecurityEnabled,
                                 *OldNT5GroupType,
                                 NewNT5GroupType
                                 );
    }


    if (fDeReferenceContext)
    {
        if (NT_SUCCESS(NtStatus)) {
            IgnoreStatus = SampDeReferenceContext(GroupContext,TRUE);
        } else {
            IgnoreStatus = SampDeReferenceContext(GroupContext,FALSE);
        }

        ASSERT(NT_SUCCESS(IgnoreStatus));
    }


    IgnoreStatus = SampMaybeReleaseWriteLock(fWriteLockAcquired, FALSE);
    ASSERT(NT_SUCCESS(IgnoreStatus));


    // cleanup

    if (NULL!=PrimaryMembers)
    {
        MIDL_user_free(PrimaryMembers);
        PrimaryMembers = NULL;
    }

    return NtStatus;
}


ULONG
SampGetAccountTypeFromGroupType(
    IN ULONG GroupType
    )
{
    ULONG SamAccountType = 0;

    if (GroupType & GROUP_TYPE_SECURITY_ENABLED) {

        if (GroupType & GROUP_TYPE_ACCOUNT_GROUP) {
            SamAccountType = SAM_GROUP_OBJECT;

        } else if (GroupType & GROUP_TYPE_RESOURCE_GROUP) {
            SamAccountType = SAM_ALIAS_OBJECT;

        } else if (GroupType & GROUP_TYPE_BUILTIN_LOCAL_GROUP) {
            SamAccountType = SAM_ALIAS_OBJECT;

        } else {
            // default to group
            SamAccountType = SAM_GROUP_OBJECT;
        }
    } else {

        // Security disabled
        if (GroupType & GROUP_TYPE_ACCOUNT_GROUP) {
            SamAccountType = SAM_NON_SECURITY_GROUP_OBJECT;

        } else if (GroupType & GROUP_TYPE_RESOURCE_GROUP) {
            SamAccountType = SAM_NON_SECURITY_ALIAS_OBJECT;

        } else if (GroupType & GROUP_TYPE_APP_BASIC_GROUP) {
            SamAccountType = SAM_APP_BASIC_GROUP;

        } else if (GroupType & GROUP_TYPE_APP_QUERY_GROUP) {
            SamAccountType = SAM_APP_QUERY_GROUP;

        } else {
            // default to group
            SamAccountType = SAM_NON_SECURITY_GROUP_OBJECT;
        }
    }

    ASSERT(0 != SamAccountType);

    return SamAccountType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\notify.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    notify.h

Abstract:

    This file contains the byte stream definition used by SAM to pass
    information from a BDC to a PDC. The byte stream is passed along
    netlogon's secure channel mechanism.

    Currently, only password notification uses this stream.

Author:

    Colin Brace      (ColinBr)    28-April-98

Environment:

    User Mode - Win32

Revision History:


--*/

//
// This is the type data contained in the stream.  Each type
// is responsible for its own versioning.
//
typedef enum
{
    SamPdcPasswordNotification,
    SamPdcResetBadPasswordCount

} SAMI_BLOB_TYPE;


typedef struct _SAMI_SECURE_CHANNEL_BLOB
{
    SAMI_BLOB_TYPE  Type;      // One of the enums above
    ULONG           DataSize;  // sizeof Data in bytes
    DWORD           Data[1];   // The start of the data

} SAMI_SECURE_CHANNEL_BLOB, *PSAMI_SECURE_CHANNEL_BLOB;

//
// Password notification blobs
//

//
// Complementary flags defining what fields are present in the
// password notification
//
#define SAM_ACCOUNT_NAME_PRESENT        ((ULONG)0x00000001)
#define SAM_CLEAR_TEXT_PRESENT          ((ULONG)0x00000002)
#define SAM_LM_OWF_PRESENT              ((ULONG)0x00000004)
#define SAM_NT_OWF_PRESENT              ((ULONG)0x00000008)
#define SAM_ACCOUNT_UNLOCKED            ((ULONG)0x00000010)
#define SAM_MANUAL_PWD_EXPIRY           ((ULONG)0x00000020)

#define SAM_VALID_PDC_PUSH_FLAGS        (SAM_ACCOUNT_NAME_PRESENT |     \
                                         SAM_CLEAR_TEXT_PRESENT   |     \
                                         SAM_LM_OWF_PRESENT       |     \
                                         SAM_NT_OWF_PRESENT       |     \
                                         SAM_ACCOUNT_UNLOCKED     |     \
                                         SAM_MANUAL_PWD_EXPIRY)
typedef struct _SAMI_PASSWORD_INDEX
{
    ULONG               Offset;  // offset from SAMI_PASSWORD_INFO::Data
    ULONG               Length;  // length in bytes

} SAMI_PASSWORD_INDEX, *PSAMI_PASSWORD_INDEX;

typedef struct _SAMI_PASSWORD_INFO
{
    ULONG               Flags;         // Bits describing what fields are filled in
    ULONG               Size;          // Size in bytes of this header, including
                                       // tailing dynamic array
    ULONG               AccountRid;
    BOOLEAN             PasswordExpired;
    SAMI_PASSWORD_INDEX DataIndex[1];  // Dynamic array of SAMI_PASSWORD_INDEX

} SAMI_PASSWORD_INFO, *PSAMI_PASSWORD_INFO;

typedef struct _SAMI_BAD_PWD_COUNT_INFO
{
    GUID                ObjectGuid;
} SAMI_BAD_PWD_COUNT_INFO, *PSAMI_BAD_PWD_COUNT_INFO;

//
// moved out from notify.c
// private service type, used by notify.c and usrparms.c only.
// 

typedef struct _SAMP_CREDENTIAL_UPDATE_NOTIFY_PARAMS
{
    UNICODE_STRING CredentialName;

}SAMP_CREDENTIAL_UPDATE_NOTIFY_PARAMS, *PSAMP_CREDENTIAL_UPDATE_NOTIFY_PARAMS;

typedef struct _SAMP_NOTIFICATION_PACKAGE {
    struct _SAMP_NOTIFICATION_PACKAGE * Next;
    UNICODE_STRING PackageName;

    union {

        SAMP_CREDENTIAL_UPDATE_NOTIFY_PARAMS CredentialUpdateNotify;

    } Parameters;

    PSAM_PASSWORD_NOTIFICATION_ROUTINE PasswordNotificationRoutine;
    PSAM_DELTA_NOTIFICATION_ROUTINE DeltaNotificationRoutine;
    PSAM_PASSWORD_FILTER_ROUTINE PasswordFilterRoutine;
    PSAM_USERPARMS_CONVERT_NOTIFICATION_ROUTINE UserParmsConvertNotificationRoutine;
    PSAM_USERPARMS_ATTRBLOCK_FREE_ROUTINE UserParmsAttrBlockFreeRoutine;
    PSAM_CREDENTIAL_UPDATE_NOTIFY_ROUTINE CredentialUpdateNotifyRoutine;
    PSAM_CREDENTIAL_UPDATE_FREE_ROUTINE CredentialUpdateFreeRoutine;
} SAMP_NOTIFICATION_PACKAGE, *PSAMP_NOTIFICATION_PACKAGE;


extern PSAMP_NOTIFICATION_PACKAGE SampNotificationPackages;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\lock.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    lock.c

Abstract:

    This file contains routines to manage SAM Lock, these services (acquire / 
    release lock) are used by the rest of SAM.

    Below is the theory which describes the transaction mode 

    1) For loopback clients, they are limited to 3 SAM operations only,

            1. Account Creation
            2. Account Modification 
            3. Account Removal

        Because the transaction is originated and committed / aborted 
        (controlled) by DS, so SAM doesn't need to maintain the transaction. 
        Therefore SAM Lock is not required when doing the above three loopback 
        operations.  

        So in the corresponding SAM code path, we should always use 
        SampMaybeAcquireWriteLock() and SampMaybeReleaseWriteLock(). 

        In the middle of transaction (for loopback client), if the caller 
        needs to read account information, SampMaybeAcquireReadLock() and
        SampMaybeReleaseReadLock() should be used. 

        However, loopback clients still need to access certain SAM global 
        (or in memory) information, such as SampDefinedDomains[]. If the 
        information is initialized during system startup time, and never
        change afterworth, loopback clients can retrieve them without SAM
        lock. Otherwise, if the global information could be updated by 
        other threads, then loopback clients has to grab SAM lock before 
        any read / write operation. In this case, SampAcquireSamLockExclusive()
        and SampReleaseSamLockExclusive() should be used.  

            Correct Sequence
                
                Begin DS transaction (by Loopback)
                SampMaybeAcquireWriteLock() 
                SampMaybeReleaseWriteLock() pair
                End DS transaction (by loopback) 

            Usually, caller should not try to acquire SAM lock if he has 
            an open DS transaction. If SAM lock is required to hold to 
            access SAM database, then SampAcquireSamLockExclusive() should
            be used. 

        Note: Should not SampTransactionWithinDomain in loopback case.
         

    2) For all the other clients

       The transaction is maintained by SAM.

       READ - If the service doesn't refer to any global (or in memory) SAM
              information, such as SampDefinedDomains[], the caller needs to 
              use SampMaybeAcquireReadLock() and SampMaybeReleaseReadLock().
              In the other words, those callers do not set 
              TransactionWithinDomain. described in detail 

                  Registry Mode: 

                      SAM Lock is always acquired 

                  DS Mode:

                      user / group / alias object are marked NotSharedByMultiThreads, 
                      so SAM Lock is not required. Also SAM Lock is not required 
                      for reading domain object info. 


              If the service DOES refer to the global SAM variables and
              requires the SampTransactionWithinDomain to be set. Then in 
              those code path, SampAcquireReadLock() and SampReleaseReadLock()
              need to be used. So that we can make sure 
              1. no other thread will update the variables being referenced. 
              2. SAM maintains the transaction for the whole READ operation.
              

       WRITE - Since SAM is responsible to maintain the transaction, either
               commit if success or rollback for any failure. SAM Lock is 
               always a requirement. It will simplify the following problems

               1. usage of SampTransactionWithinDomain
               2. Write Conflict of global SAM variable

           Correct Sequence
           
               SampAcquireReadLock() or SampAcquireWriteLock()
               Begin Transaction (RXAct or DS Transaction)
               End Transaction (either commit or abort)
               SampReleaseReadLock() or SampReleaseWriteLock()

        For the correct usage of SampTransactionWithinDomain, please refer to 
        SampTransactionWithinDomainFn() in utility.c  
         
              
               
    

Author:

    Shaohua Yin    (ShaoYin)  01-March-2000

Environment:

    User Mode - Win32

Revision History:

    01-March-2000: SHAOYIN  Moved SAM Lock routines from utility.c


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dsutilp.h>
#include <dslayer.h>
#include <dsmember.h>
#include <attids.h>
#include <mappings.h>
#include <ntlsa.h>
#include <nlrepl.h>
#include <dsevent.h>             // (Un)ImpersonateAnyClient()
#include <sdconvrt.h>
#include <ridmgr.h>
#include <malloc.h>
#include <setupapi.h>
#include <crypt.h>
#include <wxlpc.h>
#include <rc4.h>
#include <md5.h>
#include <enckey.h>
#include <rng.h>




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Globals                                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
// Variables for tracking Sam Lock Usage
//

ULONG   SamLockQueueLength=0;
ULONG   SamLockAverageWaitingTime=0; // in ticks
ULONG   SamLockTotalAquisitions=0;
ULONG   SamCumulativeWaitTime=0;
ULONG   SamCumulativeHoldTime=0;
ULONG   SamLockCurrentHoldStartTime=0; // Tickcount just after acquire
ULONG   SamLockAverageHoldTime=0; // in ticks



//
// Macros for acquring Sam lock statistics
//

#define SAMLOCK_STATISTICS_BEFORE_ACQUIRE(WaitInterval)\
    _SamLockStatisticsBeforeAcquire(WaitInterval)

VOID
_SamLockStatisticsBeforeAcquire(PULONG WaitInterval)
{
    *WaitInterval = GetTickCount();
    InterlockedIncrement(&SamLockQueueLength);
}

#define SAMLOCK_STATISTICS_AFTER_ACQUIRE(WaitInterval)\
    _SamLockStatisticsAfterAcquire(WaitInterval)

VOID
_SamLockStatisticsAfterAcquire(ULONG WaitInterval)
{
    InterlockedDecrement(&SamLockQueueLength);
    SamLockCurrentHoldStartTime = GetTickCount();
    WaitInterval = SamLockCurrentHoldStartTime-WaitInterval;
    SamLockTotalAquisitions++;
    if ((WaitInterval>0) && (SamLockTotalAquisitions!=0))
    {
        SamCumulativeWaitTime+=WaitInterval;
        SamLockAverageWaitingTime=
            SamCumulativeWaitTime/SamLockTotalAquisitions;
    }
}

#define SAMLOCK_STATISTICS_BEFORE_RELEASE _SamLockStatisticsBeforeRelease()

VOID
_SamLockStatisticsBeforeRelease()
{
    LONG HoldInterval = GetTickCount();
    HoldInterval = HoldInterval - SamLockCurrentHoldStartTime;
    if ((HoldInterval>0) && (SamLockTotalAquisitions!=0))
    {
        SamCumulativeHoldTime+=HoldInterval;
        SamLockAverageHoldTime=
            SamCumulativeHoldTime/SamLockTotalAquisitions;
    }
}





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Database/registry access lock services                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




VOID
SampAcquireReadLock(
    VOID
    )

/*++

Routine Description:

    This routine obtains read access to the SAM data structures and
    backing store.

    Despite its apparent implications, read access is an exclusive access.
    This is to support the model set up in which global variables are used
    to track the "current" domain.  In the future, if performance warrants,
    a read lock could imply shared access to SAM data structures.

    The primary implication of a read lock at this time is that no
    changes to the SAM database will be made which require a backing
    store update.


Arguments:

    None.

Return Value:


    None.


--*/
{
    BOOLEAN Success;

    SAMTRACE("SampAcquireReadLock");

    if ( !SampUseDsData || !SampIsWriteLockHeldByDs() ) {

        //
        // Before changing this to a non-exclusive lock, the display information
        // module must be changed to use a separate locking mechanism. Davidc 5/12/92
        //
        LONG WaitInterval;
        SAMLOCK_STATISTICS_BEFORE_ACQUIRE(&WaitInterval);

        Success = RtlAcquireResourceExclusive( &SampLock, TRUE );

        SAMLOCK_STATISTICS_AFTER_ACQUIRE(WaitInterval);

        ASSERT(Success);
        ASSERT(SampLockHeld==FALSE);
        ASSERT((!SampUseDsData)||(!SampExistsDsTransaction()));
        SampLockHeld = TRUE;

        SampDsTransactionType = TransactionRead;

    }

    return;
}


VOID
SampReleaseReadLock(
    VOID
    )

/*++

Routine Description:

    This routine releases shared read access to the SAM  data structures and
    backing store.


Arguments:

    None.

Return Value:


    None.


--*/
{

    NTSTATUS   IgnoreStatus;

    SAMTRACE("SampReleaseReadLock");

    ASSERT(SampLockHeld==TRUE);

    if ( SampUseDsData && SampIsWriteLockHeldByDs() ) {

        //
        // If write lock is held, only reset domain transaction flag.
        //

        SampSetTransactionWithinDomain(FALSE);

    } else {

        SampSetTransactionWithinDomain(FALSE);
        SampLockHeld = FALSE;

        //
        // Commit the transaction, Commit is faster than Rollback
        // so we always prefer a commit even though there are no
        // changes
        //

        if (SampDsInitialized) {
            IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

        SAMLOCK_STATISTICS_BEFORE_RELEASE ;

        RtlReleaseResource( &SampLock );
    }

    return;
}

VOID
SampMaybeAcquireReadLock(
    IN PSAMP_OBJECT Context,
    IN ULONG  Control,
    OUT BOOLEAN * fLockAcquired
    )
/*++

Routine Description

    This routine encapsulate all the logic for a conditional SAM lock acquire. If the
    following conditions are satisfied, then we do not acquire the lock. 
    
    1. Context that is passed in is marked NotSharedByMultiThreads in DS Mode.
       
    2. OR it is a domain object in DS case and the caller routine explicitly 
       indicates the lock is not required. 
    
Parameters

    Context - SAM context, used to decide if the lock is supposed to be acquired

    Control - Runtime variable that allow the caller to control how SAM lock is 
              acquired 
    
    fLockAcquired -- Out parameter, a boolean indicating whether the SAM lock was indeed acquired

Return Value

    None    

--*/
{
    NTSTATUS NtStatus;
    BOOLEAN NoNeedToAcquireLock = FALSE;
    BOOLEAN ContextValid = TRUE;

    *fLockAcquired = FALSE;

    //
    // Make sure the passed context address is (still) valid.
    //

    NtStatus = SampValidateContextAddress( Context );
    if ( !NT_SUCCESS(NtStatus) ) {
        ContextValid = FALSE;
    }

    //
    // The lock is aquired provided any of the following is satisfied
    //


    if (ContextValid)
    {
        //
        // NotSharedByMultiTheads is always set for loopback client
        //

        ASSERT( !Context->LoopbackClient || Context->NotSharedByMultiThreads );

        // 
        // NotSharedByMultiThreads will be set for all User, Group and Alias contexts, 
        // and all domain and server contexts that do not originate from in 
        // process callers that share handles amongst threads. Routines 
        // manipulating a domain context that is shared across multiple threads, 
        // but do no real work on the domain context can still choose not to 
        // lock and be careful about Derefernce, those callers should use 
        // SampDeReferenceContext2.
        // 

        //
        // Based upon the above definition of NotSharedByMultiThreads, we
        // will not acquire SAM Lock for NotSharedByMultiThreads Contexts in DS mode. 
        // Lock is still acquired in Registry Mode to achieve transaction control. 
        // 
        // For routines manipulating a domain context that is shared across 
        // multi threads, they can choose not to acquire lock by indicating so, 
        // but they need to be very careful.
        // 

        NoNeedToAcquireLock = ((IsDsObject(Context) && Context->NotSharedByMultiThreads) || 
                               (IsDsObject(Context) 
                                    && (Control == DOMAIN_OBJECT_DONT_ACQUIRELOCK_EVEN_IF_SHARED) 
                                    && (SampDomainObjectType == Context->ObjectType))
                               );
    }

    if (!NoNeedToAcquireLock || !ContextValid )
    {

        //
        // Its not a thread safe context, so just acquire the lock
        //

        SampAcquireReadLock();
        *fLockAcquired = TRUE;
    }
    else
    {
        //
        // We must be in DS mode
        //

        ASSERT(SampUseDsData);

        //
        // The context must be a DS mode context
        //

        ASSERT(IsDsObject(Context));


        ASSERT(!SampIsWriteLockHeldByDs());

        //
        // Increment the active thread count, so that we consider this thread
        // at shutdown time
        //

        SampIncrementActiveThreads();

    }
}





VOID
SampMaybeReleaseReadLock(
    IN BOOLEAN fLockAcquired
    )
/*++

    Releases the Read Lock if it had been acquired. Also ends any open transactions subject to
    loopback. This is the complementary function for SampMaybeReleaseReadLock

    Parameters

    fLockAcquired -- Tells if the lock had been acquired

--*/
{
    NTSTATUS    IgnoreStatus;

    if (fLockAcquired)
    {
        //
        // If the lock was acquired then just release the lock
        //

        SampReleaseReadLock();
    }
    else
    {
        //
        // Case of a thread Safe context.
        //

        //
        // We must be in DS mode
        //

        ASSERT(SampUseDsData);

        //
        // End the transaction. We should never fail to commit a
        // read only transaction.
        //

        IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Let shutdown handling logic know that we are done
        //

        SampDecrementActiveThreads();
    }
}



NTSTATUS
SampAcquireWriteLock(
    VOID
    )

/*++

Routine Description:

    This routine acquires exclusive access to the SAM  data structures and
    backing store.

    This access is needed to perform a write operation.

    This routine also initiates a new transaction for the write operation.


    NOTE:  It is not acceptable to acquire this lock recursively.  An
           attempt to do so will fail.


Arguments:

    None.

Return Value:

    STATUS_SUCCESS - Indicates the write lock was acquired and the transaction
        was successfully started.

    Other values may be returned as a result of failure to initiate the
    transaction.  These include any values returned by RtlStartRXact().



--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    SAMTRACE("SampAcquireWriteLock");

    if ( SampUseDsData && SampIsWriteLockHeldByDs() ) {

        //
        // If write lock is held, only reset domain transaction flag.
        //

        SampSetTransactionWithinDomain(FALSE);

    } else {

        LONG WaitInterval;
        SAMLOCK_STATISTICS_BEFORE_ACQUIRE(&WaitInterval);

        (VOID)RtlAcquireResourceExclusive( &SampLock, TRUE );

        SAMLOCK_STATISTICS_AFTER_ACQUIRE(WaitInterval);

        ASSERT(SampLockHeld==FALSE);
        ASSERT((!SampUseDsData)||(!SampExistsDsTransaction()));

        SampLockHeld = TRUE;
        SampDsTransactionType = TransactionWrite;

        SampSetTransactionWithinDomain(FALSE);

        //
        // if we are not in DS mode Start the registry Transaction
        //

        if (!SampUseDsData)
        {
            NtStatus = RtlStartRXact( SampRXactContext );

            if (!NT_SUCCESS(NtStatus))
                goto Error;
        }

        return(NtStatus);


    Error:

        //
        // If the transaction failed, release the lock.
        //

        SampLockHeld = FALSE;

        SAMLOCK_STATISTICS_BEFORE_RELEASE ;

        (VOID)RtlReleaseResource( &SampLock );

        DbgPrint("SAM: StartRxact failed, status = 0x%lx\n", NtStatus);
    }

    return(NtStatus);
}



NTSTATUS
SampReleaseWriteLock(
    IN BOOLEAN Commit
    )

/*++

Routine Description:

    This routine releases exclusive access to the SAM  data structures and
    backing store.

    If any changes were made to the backstore while exclusive access
    was held, then this service commits those changes.  Otherwise, the
    transaction started when exclusive access was obtained is rolled back.

    If the operation was within a domain (which would have been indicated
    via the SampSetTransactionDomain() api), then the CurrentFixed field for
    that domain is added to the transaction before the transaction is
    committed.

    NOTE: Write operations within a domain do not have to worry about
          updating the modified count for that domain.  This routine
          will automatically increment the ModifiedCount for a domain
          when a commit is requested within that domain.



Arguments:

    Commit - A boolean value indicating whether modifications need to be
        committed in the backing store.  A value of TRUE indicates the
        transaction should be committed.  A value of FALSE indicates the
        transaction should be aborted (rolled-back).

Return Value:

    STATUS_SUCCESS - Indicates the write lock was released and the transaction
        was successfully commited or rolled back.

    Other values may be returned as a result of failure to commit or
    roll-back the transaction.  These include any values returned by
    RtlApplyRXact() or RtlAbortRXact().  In the case of a commit, it
    may also represent errors returned by RtlAddActionToRXact().




--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    ULONG           i;

    SAMTRACE("SampReleaseWriteLock");


    if ( SampUseDsData && SampIsWriteLockHeldByDs() ) {


        //
        // Logic should be same as commit and retain write lock
        //

        if (Commit)
            NtStatus = SampCommitAndRetainWriteLock();

        //
        // Reset domain transaction flag.
        //

        SampSetTransactionWithinDomain(FALSE);

    } else {

        //
        // Commit or rollback the transaction based upon the Commit parameter...
        //

        ASSERT(SampLockHeld==TRUE);

        if (Commit == TRUE) {

            NtStatus = SampCommitChanges();

        } else {

            // Rollback in either DS and registry
            if (SampUseDsData)
            {
                NtStatus = SampMaybeEndDsTransaction(TransactionAbort);
                ASSERT(NT_SUCCESS(NtStatus));
            }
            else
            {
                NtStatus = RtlAbortRXact( SampRXactContext );
                ASSERT(NT_SUCCESS(NtStatus));
            }
        }

        SampSetTransactionWithinDomain(FALSE);

        //
        // And free the  lock...
        //

        SampLockHeld = FALSE;

        SAMLOCK_STATISTICS_BEFORE_RELEASE ;

        (VOID)RtlReleaseResource( &SampLock );
    }

    return(NtStatus);
}



NTSTATUS
SampMaybeAcquireWriteLock(
    IN PSAMP_OBJECT Context,
    OUT BOOLEAN * fLockAcquired
    )
/*++

Routine Description


    This routine encapsulate all the logic for a conditional SAM lock acquire. If the
    following conditions are satisfied, then we do not acquire the lock. 
    
    1. Context that is passed in is marked Loopback Client then we do not 
       acquire the lock.
    
    This routine acquires exclusive access to the SAM  data structures and
    backing store if it is desired.


    If SAM Write Lock is required, this routine will also initiates a new 
    transaction for the write operation. 
    
    If SAM lock is not required, then we will increment SAM active thread count, 
    so that this thread will be considered at shutdown time. 
    

Parameters

    Context - SAM context, used to decide if the lock is supposed to be acquired
    fLockAcquired -- Out parameter, a boolean indicating whether the SAM 
                     lock was indeed acquired

Return Value

    NTSTATUS Code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    BOOLEAN     NoNeedToAcquireLock = FALSE;
    BOOLEAN     ContextValid = TRUE;

    *fLockAcquired = FALSE;

    //
    // Make sure teh passed context address is (still) valid
    // 

    NtStatus = SampValidateContextAddress( Context );
    if (!NT_SUCCESS(NtStatus)) {
        ContextValid = FALSE;
    }

    //
    // The lock is acquired provided any of the following is satisfied
    //

    if (ContextValid)
    {
        NoNeedToAcquireLock = IsDsObject(Context) && (Context->LoopbackClient);
    }

    if (!NoNeedToAcquireLock || !ContextValid)
    {
        //
        // It's not a thread safe context, so just aquire the lock
        // 

        NtStatus = SampAcquireWriteLock();
        if (NT_SUCCESS(NtStatus))
        {
            *fLockAcquired = TRUE;
        }
    }
    else
    {
        //
        // We must be in DS mode
        // 
        ASSERT(SampUseDsData);

        //
        // The context must be a DS mode context
        // 
        ASSERT(IsDsObject(Context));


        // 
        // Increment the active thread count, so that we consider this thread
        // at shutdown time
        // 

        NtStatus = SampIncrementActiveThreads();
    }

    return( NtStatus );
}

NTSTATUS
SampMaybeReleaseWriteLock(
    IN BOOLEAN fLockAcquired,
    IN BOOLEAN Commit
    )
/*++

Routine Description:

    Releases the exclusive Write Lock if it had been acquired. 
    Also ends (either commit or abort) any open transactions.
    This is the complementary function for SampMaybeReleaseWriteLock

    If Commit is TRUE, then this service commits all changes. Otherwise, 
    all changes since the transaction is started would be rolled back. 


Arguments:

    fLockAcquired -- Tells if the lock had been acquired

    Commit - A boolean value indicating whether modifications need to be
        committed in the backing store.  A value of TRUE indicates the
        transaction should be committed.  A value of FALSE indicates the
        transaction should be aborted (rolled-back).

Return Value:

    STATUS_SUCCESS - Indicates the write lock was released and the transaction
        was successfully commited or rolled back.

    Other values may be returned as a result of failure to commit or
    roll-back the transaction.  These include any values returned by
    RtlApplyRXact() or RtlAbortRXact().  In the case of a commit, it
    may also represent errors returned by RtlAddActionToRXact().


--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    NTSTATUS    IgnoreStatus = STATUS_SUCCESS;

    if (fLockAcquired)
    {
        //
        // if the lock was acquired then just release the write lock
        //

        ASSERT(SampCurrentThreadOwnsLock());

        NtStatus = SampReleaseWriteLock( Commit );;
    }
    else
    {
        //
        // Case of thread safe context.
        //  

        //
        // We must be in DS mode
        // 

        ASSERT(SampUseDsData);
        
        //
        // We do not hold lock
        // 

        ASSERT(!SampCurrentThreadOwnsLock());

        //
        // Commit or rollback the transaction based on the Commit parameter.
        // 

        if (TRUE == Commit)
        {
            NtStatus = SampCommitChanges();
        }
        else
        {
            NtStatus = SampMaybeEndDsTransaction(TransactionAbort);
            ASSERT(NT_SUCCESS(NtStatus));
        }

        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Let shutdown handling logic know that we are done
        // 
        
        SampDecrementActiveThreads();
    }

    return( NtStatus );
}


VOID
SampAcquireSamLockExclusive()
/*++
    Routine Description:

    This function grabs the SAM lock for exclusive access. It is different
    from the SampAcquireWriteLock function by the fact that it has no
    transaction semantics associated with it.

    Parameters;
        None

    Return Values:
        None
--*/
{
    if ( !SampUseDsData || !SampIsWriteLockHeldByDs() )
    {
        LONG WaitInterval;

        SAMLOCK_STATISTICS_BEFORE_ACQUIRE(&WaitInterval);

        (VOID) RtlAcquireResourceExclusive(&SampLock,TRUE);

        SAMLOCK_STATISTICS_AFTER_ACQUIRE(WaitInterval);

        ASSERT(SampLockHeld==FALSE);
        SampLockHeld = TRUE;
    }
}


VOID
SampReleaseSamLockExclusive()
/*++
    Routine Description:

    This function releases the SAM lock from exclusive access. It is different
    from the SampReleaseWriteLock function by the fact that it has no
    transaction semantics associated with it.

    Parameters;
        None

    Return Values:
        None
--*/
{
    if ( !SampUseDsData || !SampIsWriteLockHeldByDs() )
    {

        ASSERT(SampLockHeld==TRUE);
        SampLockHeld = FALSE;

        SAMLOCK_STATISTICS_BEFORE_RELEASE ;

        (VOID) RtlReleaseResource(&SampLock);
    }
}






NTSTATUS
SampCommitChanges(
    )

/*++

Routine Description:

    Thie service commits any changes made to the backstore while exclusive
    access was held.

    If the operation was within a domain (which would have been indicated
    via the SampSetTransactionDomain() api), then the CurrentFixed field for
    that domain is added to the transaction before the transaction is
    committed.

    NOTE: Write operations within a domain do not have to worry about
          updating the modified count for that domain.  This routine
          will automatically increment the ModifiedCount for a domain
          when a commit is requested within that domain.

    NOTE: When this routine returns any transaction will have either been
          committed or aborted. i.e. there will be no transaction in progress.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - Indicates the transaction was successfully commited.

    Other values may be returned as a result of commital failure.

--*/

{
    NTSTATUS NtStatus, IgnoreStatus;
    BOOLEAN DomainInfoChanged = FALSE;
    BOOLEAN AbortDone = FALSE;
    BOOLEAN DsTransaction = FALSE;


    SAMTRACE("SampCommitChanges");

    NtStatus = STATUS_SUCCESS;

    //
    // If this transaction was within a domain then we have to:
    //
    //         (1) Update the ModifiedCount of that domain,
    //
    //         (2) Write out the CurrentFixed field for that
    //             domain (using RtlAddActionToRXact(), so that it
    //             is part of the current transaction).
    //
    //         (3) Commit the RXACT.
    //
    //         (4) If the commit is successful, then update the
    //             in-memory copy of the un-modified fixed-length data.
    //
    // Otherwise, we just do the commit.
    //

    if (SampTransactionWithinDomain == TRUE) {


            // It is a DS transaction if Its a Transaction within Domain
            // and the Domain object is a DS Object

        DsTransaction = IsDsObject(((SampDefinedDomains[SampTransactionDomainIndex]).Context));

        if ((SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed.ServerRole
            != DomainServerRoleBackup) && (!DsTransaction)) {

            //
            // Don't update the netlogon change log serial number on backup controllers;
            // the replicator will explicitly set the modified count. Do not update them
            // in DS mode either. The DS will provide change notifcations when the change
            // is actually commited. This will provide us with the notification.
            //

            SampDefinedDomains[SampTransactionDomainIndex].NetLogonChangeLogSerialNumber.QuadPart =
                SampDefinedDomains[SampTransactionDomainIndex].NetLogonChangeLogSerialNumber.QuadPart +
                1;




            //
            // Need to update the domain modified count
            //

            SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed.ModifiedCount =
                     SampDefinedDomains[SampTransactionDomainIndex].NetLogonChangeLogSerialNumber;


        }

        //
        // See if the domain information changed - if it did, we
        // need to add code to flush the change to disk
        //

        if ( RtlCompareMemory(
            &SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed,
            &SampDefinedDomains[SampTransactionDomainIndex].UnmodifiedFixed,
            sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN) ) !=
                sizeof( SAMP_V1_0A_FIXED_LENGTH_DOMAIN) ) {

            DomainInfoChanged = TRUE;
        }

        if ( DomainInfoChanged ) {

            //
            // The domain object's fixed information has changed, so set
            // the changes in the domain object's private data.
            //

            NtStatus = SampSetFixedAttributes(
                           SampDefinedDomains[SampTransactionDomainIndex].
                               Context,
                           &SampDefinedDomains[SampTransactionDomainIndex].
                               CurrentFixed
                           );

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // Normally when we dereference the context,
                // SampStoreObjectAttributes() is called to add the
                // latest change to the RXACT.  But that won't happen
                // for the domain object's change since this is the
                // commit code, so we have to flush it by hand here.
                //

                NtStatus = SampStoreObjectAttributes(
                      SampDefinedDomains[SampTransactionDomainIndex].Context,
                               TRUE // Use the existing key handle
                               );

            }
        }
    }


    //
    // If we still have no errors, try to commit the whole mess

    if ( NT_SUCCESS(NtStatus))
    {

        // We have the following cases here
        // 1. SampTransactionWithin Domain is never set. A commit with this condition
        //    will happens in upgrade of pre 4.0 NT databases in Registry Mode.
        //    In DS mode this will occur when the
        //    final call from loopback commits
        // 2. DS mode SampTransactionWithinDomain is set. This is the normal commit
        //    path in DS mode through SAM.
        // 3. Registry Mode SampTransactionWithinDomain Is Set.

        if (!SampTransactionWithinDomain)
        {

            if (!SampUseDsData)
            {
                //
                // Registry Case, this happens while upgrading an NT 3.51 Database
                // The 3.51 Upgrader code resets the SampTransactionDomain flag
                // in order to prevent changes from propagating to Other domain
                // controllers that replicate via Pre NT 5.0 Replication.
                //

                SampCommitChangesToRegistry(&AbortDone);
            }
            else
            {

                // Ds Case, this can happen during loopback
                // At this moment a thread state exists, but open transactions
                // may not exist depending upon the logic in clean return in
                // the DS.


                NtStatus = SampMaybeEndDsTransaction(TransactionCommit);

            }
        }
        else if (DsTransaction)
        {
            // case 2 , commit the DS transaction. The DS transaction
            // may or may not exist. It may not exist on cases where a change
            // is made to the domain object and the changed value is the same
            // as the previous value. The domain object is flushed only on
            // cases where a change is detected on an explicit memory comparison.

            ASSERT(TRUE==SampUseDsData);

            NtStatus = SampMaybeEndDsTransaction(TransactionCommit);

            if (NT_SUCCESS(NtStatus))
            {
                //
                // The transaction was successfully commited. Set the Unmodified
                // fixed field in the domain object to the current fixed field
                //

                SampDefinedDomains[SampTransactionDomainIndex].UnmodifiedFixed =
                    SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed;
            }


        }
        else
        {
            // case 3, commit the Registry Transaction

            ASSERT(FALSE==SampUseDsData);

            NtStatus = SampCommitChangesToRegistry(&AbortDone);
        }
    }

    //
    // Always abort the transaction on failure
    //


    if ( !NT_SUCCESS(NtStatus) && !AbortDone) {


        if (!SampUseDsData)
        {
            //
            // In registry mode, abort the Registry Transaction
            //

            IgnoreStatus = RtlAbortRXact( SampRXactContext );
        }
        else
        {
            // In DS mode Abort the DS transaction, if the writelock is not
            // held by the DS. In the case where the write lock is held by
            // the DS, the DS will abort the transaction, when it releases the
            // write lock

            if (!SampIsWriteLockHeldByDs())
            {
                IgnoreStatus = SampMaybeEndDsTransaction(TransactionAbort);
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }
        }

    }

    return( NtStatus );
}





NTSTATUS
SampCommitAndRetainWriteLock(
    VOID
    )

/*++

Routine Description:

    This routine attempts to commit all changes made so far.  The write-lock
    is held for the duration of the commit and is retained by the caller upon
    return.

    The transaction domain is left intact as well.

    NOTE: Write operations within a domain do not have to worry about
          updating the modified count for that domain.  This routine
          will automatically increment the ModifiedCount for a domain
          when a commit is requested within that domain.



Arguments:

    None.

Return Value:

    STATUS_SUCCESS - Indicates the transaction was successfully commited.


    Other values may be returned as a result of failure to commit or
    roll-back the transaction.  These include any values returned by
    RtlApplyRXact() or RtlAddActionToRXact().




--*/

{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    NTSTATUS        TempStatus = STATUS_SUCCESS;

    SAMTRACE("SampCommitAndRetainWriteLock");

    NtStatus = SampCommitChanges();

    //
    // If we are in registry mode start another transaction
    //

    if (!SampUseDsData)
    {

        //
        // Start another transaction, since we're retaining the write lock.
        // Note we do this even if the commit failed so that cleanup code
        // won't get confused by the lack of a transaction.  This is true
        // for the registry transaction but not for DS transactions.  In
        // the DS case, once you commit, the transaction and threads state
        // are gone for good.
        //

        TempStatus = RtlStartRXact( SampRXactContext );
        ASSERT(NT_SUCCESS(TempStatus));

        //
        // Return the worst status
        //

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = TempStatus;
        }

    }



    return(NtStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\log.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    log.c

Abstract:

    Implementation of the internal debug and support routines

Author:

    Colin Brace              April 26, 2001

Environment:

    User Mode

Revision History:

--*/

#include <samsrvp.h>

//
// Global handle to the log file
//
HANDLE SampLogFile = NULL;
CRITICAL_SECTION SampLogFileCriticalSection;

#define LockLogFile()    RtlEnterCriticalSection( &SampLogFileCriticalSection );
#define UnlockLogFile()  RtlLeaveCriticalSection( &SampLogFileCriticalSection );

NTSTATUS
SampEnableLogging(
    VOID
    );

VOID
SampDisableLogging(
    VOID
    );

//
// log file name
//
#define SAMP_LOGNAME L"\\debug\\sam.log"


NTSTATUS
SampInitLogging(
    VOID
    )
/*++

Routine Description:

    This routine initalizes the resources necessary for logging support.

Arguments:

    None.

Return Value:

    None.            

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    __try
    {
        NtStatus = RtlInitializeCriticalSection(
                        &SampLogFileCriticalSection
                        );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return NtStatus;
}

VOID
SampLogLevelChange(
    HANDLE hLsaKey
    )
/*++

Routine Description:

    This routine is called when the configuration section in the registry
    for SAM is changed.  The logging level is read in and adjusted in
    memory if necessary.

Arguments:

    hLsaKey -- a valid registry key

Return Value:

    None.

--*/
{
    DWORD WinError;
    DWORD dwSize, dwType, dwValue;
    ULONG PreviousLogLevel = SampLogLevel;

    dwSize = sizeof(dwValue);
    WinError = RegQueryValueExA(hLsaKey,
                               "SamLogLevel",
                               NULL,
                               &dwType,
                               (LPBYTE)&dwValue,
                               &dwSize);
    if ((ERROR_SUCCESS == WinError) &&
        (REG_DWORD == dwType)) {
    
        SampLogLevel = dwValue;

    } else {

        SampLogLevel = 0;

    }

    if (PreviousLogLevel != SampLogLevel) {

        //
        // Settings have changed
        //
        if (SampLogLevel == 0) {
    
            //
            // Logging has been turned off; close log file
            //
            SampDisableLogging();

        } else if (PreviousLogLevel == 0) {
            //
            // Logging has been turned on; open log file
            //
            SampEnableLogging();
        }
    }

    return;

}


NTSTATUS
SampEnableLogging(
    VOID
    )
/*++

Routine Description:

    Initializes the debugging log file.
    
Arguments:

    None

Returns:

    STATUS_SUCCESS, STATUS_UNSUCCESSFUL
    
--*/
{
    DWORD WinError = ERROR_SUCCESS;

    WCHAR LogFileName[ MAX_PATH + 1 ];
    BOOLEAN fSuccess;

    LockLogFile();

    if (SampLogFile == NULL) {

        //
        // Construct the log file name
        //
        if ( !GetWindowsDirectoryW(LogFileName, ARRAY_COUNT(LogFileName))) {
            WinError = GetLastError();
            goto Exit;
        }
        if ( wcslen(LogFileName) + (sizeof(SAMP_LOGNAME) / sizeof(WCHAR)) + 1
           > ARRAY_COUNT(LogFileName)) {
            WinError = ERROR_BAD_PATHNAME;
            goto Exit;
        }
        wcscat( LogFileName, SAMP_LOGNAME );
    
        //
        // Open the file, ok if it already exists
        //
        SampLogFile = CreateFileW( LogFileName,
                                   GENERIC_WRITE,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   NULL,
                                   OPEN_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL );
    
        if ( SampLogFile == INVALID_HANDLE_VALUE ) {
            WinError = GetLastError();
            SampLogFile = NULL;
            goto Exit;
        }
    
        //
        // Goto to the end of the file
        //
        if( SetFilePointer( SampLogFile,
                            0, 
                            0,
                            FILE_END ) == 0xFFFFFFFF ) {
    
            WinError = GetLastError();
            goto Exit;
        }
    }

Exit:

    if ( (ERROR_SUCCESS != WinError)
      && (NULL != SampLogFile)   ) {

        CloseHandle( SampLogFile );
        SampLogFile = NULL;
        
    }

    UnlockLogFile();

    return (WinError == ERROR_SUCCESS ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}

VOID
SampDisableLogging(
    VOID
    )
/*++

Routine Description:

    Closes the debugging log file.

Arguments:

    None.

Returns:

    None.

--*/
{
    LockLogFile();

    if (SampLogFile != NULL) {
        FlushFileBuffers( SampLogFile );
        CloseHandle( SampLogFile );
        SampLogFile = NULL;
    }

    UnlockLogFile();
}

VOID
SampDebugDumpRoutine(
    IN ULONG LogLevel,
    IN LPSTR Format,
    va_list arglist
    )
/*++

Routine Description:

    This routine dumps the string specified by the caller to the log file
    if open.
    
Arguments:

    LogLevel -- the component making to request
                          
    Format, arglist -- arguments for a formatted output routine.

Return Value:

    None.
    
--*/

{
    CHAR OutputBuffer[1024];
    int length;
    int result;
    DWORD BytesWritten;
    SYSTEMTIME SystemTime;
    static BeginningOfLine = TRUE;

    length = 0;


    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        CHAR  *Prolog;

        if (LogLevel & SAMP_LOG_ACCOUNT_LOCKOUT) {
            Prolog = "Lockout: ";
        } else {
            Prolog = "";
        }

        //
        // Put the timestamp at the begining of the line.
        //
        GetLocalTime( &SystemTime );
        result = _snprintf( &OutputBuffer[length],
                             ARRAY_COUNT(OutputBuffer) - length,
                             "%02u/%02u %02u:%02u:%02u %s",
                             SystemTime.wMonth,
                             SystemTime.wDay,
                             SystemTime.wHour,
                             SystemTime.wMinute,
                             SystemTime.wSecond,
                             Prolog );

        if (result < 0) {
            goto Exit;
        }
        length += result;

    }

    //
    // Put a the information requested by the caller onto the line
    //
    result = _vsnprintf(&OutputBuffer[length],
                        ARRAY_COUNT(OutputBuffer) - length, 
                        Format, 
                        arglist);

    if (result < 0) {
        goto Exit;
    }
    length += result;

    BeginningOfLine = (length > 0 && OutputBuffer[length-1] == L'\n' );
    if ( BeginningOfLine && (length < (ARRAY_COUNT(OutputBuffer) - 2))) {

        OutputBuffer[length-1] = L'\r';
        OutputBuffer[length] = L'\n';
        OutputBuffer[length+1] = L'\0';
        length++;
    }

    //
    // Grab the lock
    //
    LockLogFile();

    //
    // Write the debug info to the log file.
    //
    if (SampLogFile) {

        WriteFile( SampLogFile,
                   OutputBuffer,
                   length*sizeof(CHAR),
                   &BytesWritten,
                   NULL 
                   );
    }

    //
    // Release the lock
    //
    UnlockLogFile();

Exit:

    return;

}

VOID
SampLogPrint(
    IN ULONG LogLevel,
    IN LPSTR Format,
    ...
    )
/*++

Routine Description:
    
    This routine is small variable argument wrapper for SampDebugDumpRoutine.        

Arguments:

    LogLevel -- the component making the logging request
                          
    Format, ... -- input to a format string routine.

Return Value:

    None.
    
--*/
{
    va_list arglist;

    va_start(arglist, Format);

    SampDebugDumpRoutine( LogLevel, Format, arglist );
    
    va_end(arglist);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\notify.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    notify.c

Abstract:

    This file contains services which load notification packages and call
    them when passwords are changed using the SamChangePasswordUser2 API.


Author:

    Mike Swift      (MikeSw)    30-December-1994

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <nlrepl.h>
#include <dbgutilp.h>
#include <attids.h>
#include <dslayer.h>
#include <sddl.h> 
#include "notify.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private prototypes                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
SampConfigurePackage(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
SampConfigurePackageFromRegistry(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

NTSTATUS
SampPasswordChangeNotifyWorker(
    IN ULONG Flags,
    IN PUNICODE_STRING UserName,
    IN ULONG RelativeId,
    IN PUNICODE_STRING NewPassword
    );

NTSTATUS
SampSetPasswordInfoOnPdcWorker(
    IN SAMPR_HANDLE SamDomainHandle,
    IN PSAMI_PASSWORD_INFO PasswordInfo,
    IN ULONG BufferLength
    );

NTSTATUS
SampResetBadPwdCountOnPdcWorker(
    IN SAMPR_HANDLE SamDomainHandle,
    IN PSAMI_BAD_PWD_COUNT_INFO BadPwdCountInfo
    );

NTSTATUS
SampPrivatePasswordUpdate(
    IN SAMPR_HANDLE     SamDomainHandle,
    IN ULONG            Flags,
    IN ULONG            AccountRid,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN BOOLEAN          PasswordExpired
    );


NTSTATUS
SampIncreaseBadPwdCountLoopback(
    IN PUNICODE_STRING  UserName
    );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service data and types                                            //
// move typedef SAMP_NOTIFICATION_PACKAGE to notify.h
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



PSAMP_NOTIFICATION_PACKAGE SampNotificationPackages = NULL;

RTL_QUERY_REGISTRY_TABLE SampRegistryConfigTable [] = {
    {SampConfigurePackageFromRegistry, 0, L"Notification Packages",
        NULL, REG_NONE, NULL, 0},
    {NULL, 0, NULL,
        NULL, REG_NONE, NULL, 0}
    };

//
// This table enumerates the package names for notification packages
// that are always loaded by the system.
//
LPWSTR SampMandatoryNotificationPackages[] = {
    L"KDCSVC",
    L"WDIGEST"
};

typedef enum
{
    SampNotifyPasswordChange = 0,
    SampIncreaseBadPasswordCount,
    SampDeleteAccountNameTableElement,
    SampGenerateLoopbackAudit

} SAMP_LOOPBACK_TASK_TYPE;

typedef struct
{
    ULONG           Flags;
    UNICODE_STRING  UserName;
    ULONG           RelativeId;
    UNICODE_STRING  NewPassword;

} SAMP_PASSWORD_CHANGE_INFO, *PSAMP_PASSWORD_CHANGE_INFO;

typedef struct
{
    UNICODE_STRING  UserName;
} SAMP_BAD_PASSWORD_COUNT_INFO, *PSAMP_BAD_PASSWORD_COUNT_INFO;

typedef struct
{
    UNICODE_STRING  AccountName;
    SAMP_OBJECT_TYPE    ObjectType;
} SAMP_ACCOUNT_INFO, *PSAMP_ACCOUNT_INFO;

typedef struct
{
    NTSTATUS             NtStatus;      // Event Type
    ULONG                AuditId;       // Audit ID
    PSID                 DomainSid;     // Domain SID
    PUNICODE_STRING      AdditionalInfo;// Additional Info
    PULONG               MemberRid;     // Member Rid
    PSID                 MemberSid;     // Member Sid
    PUNICODE_STRING      AccountName;   // Account Name
    PUNICODE_STRING      DomainName;    // Domain Name
    PULONG               AccountRid;    // Account Rid  
    PPRIVILEGE_SET       Privileges;    // Privilege
    PVOID                AlteredState;  // New Value Information

} SAMP_AUDIT_INFO, *PSAMP_AUDIT_INFO;


typedef struct
{
    SAMP_LOOPBACK_TASK_TYPE  Type;

    BOOLEAN fCommit:1;

    union
    {
        SAMP_PASSWORD_CHANGE_INFO       PasswordChange;
        SAMP_BAD_PASSWORD_COUNT_INFO    BadPasswordCount;
        SAMP_ACCOUNT_INFO               Account;
        SAMP_AUDIT_INFO                 AuditInfo;

    } NotifyInfo;

} SAMP_LOOPBACK_TASK_ITEM, *PSAMP_LOOPBACK_TASK_ITEM;


VOID
SampFreeLoopbackAuditInfo(
    PSAMP_AUDIT_INFO    AuditInfo
    );



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SampConfigurePackage(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

    This routine loads a notification package by loading its DLL and getting
    the address of the notification routine.

Arguments:
    ValueName - Contains the name of the registry value, ignored.
    ValueType - Contains type of Value, must be REG_SZ.
    ValueData - Contains the package name null-terminated string.
    ValueLength - Length of package name and null terminator, in bytes.
    Context - Passed from caller of RtlQueryRegistryValues, ignored
    EntryContext - Ignored



Return Value:

    STATUS_SUCCESS - Package load operation succeeded.
    
    Error status returned from a called routine.

--*/
{
    UNICODE_STRING PackageName;
    STRING NotificationRoutineName;
    PSAMP_NOTIFICATION_PACKAGE NewPackage = NULL;
    PVOID ModuleHandle = NULL;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG PackageSize;
    PSAM_INIT_NOTIFICATION_ROUTINE InitNotificationRoutine = NULL;
    PSAM_CREDENTIAL_UPDATE_REGISTER_ROUTINE CredentialRegisterRoutine = NULL;
    UNICODE_STRING CredentialName;
    SAMTRACE("SampConfigurePackage");

    RtlInitUnicodeString(&CredentialName, NULL);
    
    //
    // Build the package name from the value data.
    //

    PackageName.Buffer = (LPWSTR) ValueData;
    PackageName.Length = (USHORT) (ValueLength - sizeof( UNICODE_NULL ));
    PackageName.MaximumLength = (USHORT) ValueLength;

    //
    // Build the package structure.
    //

    PackageSize = sizeof(SAMP_NOTIFICATION_PACKAGE) + ValueLength;
    NewPackage = (PSAMP_NOTIFICATION_PACKAGE) RtlAllocateHeap(
                                                RtlProcessHeap(),
                                                0,
                                                PackageSize
                                                );
    if (NewPackage == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlSecureZeroMemory(
        NewPackage,
        PackageSize
        );

    //
    // Copy in the package name.
    //

    NewPackage->PackageName = PackageName;

    NewPackage->PackageName.Buffer = (LPWSTR) (NewPackage + 1);


        RtlCopyUnicodeString(
            &NewPackage->PackageName,
            &PackageName
            );

    //
    // Load the notification library.
    //

    NtStatus = LdrLoadDll(
                NULL,
                NULL,
                &PackageName,
                &ModuleHandle
                );


    if (NT_SUCCESS(NtStatus)) {

        RtlInitString(
            &NotificationRoutineName,
            SAM_INIT_NOTIFICATION_ROUTINE
            );

        NtStatus = LdrGetProcedureAddress(
                        ModuleHandle,
                        &NotificationRoutineName,
                        0,
                        (PVOID *) &InitNotificationRoutine
                        );
        if (NT_SUCCESS(NtStatus)) {
            ASSERT(InitNotificationRoutine != NULL);

            //
            // Call the init routine. If it returns false, unload this
            // DLL and continue on.
            //

            if (!InitNotificationRoutine()) {
                NtStatus = STATUS_INTERNAL_ERROR;
            }

        } else {
            //
            // This call isn't required, so reset the status to
            // STATUS_SUCCESS.
            //

            NtStatus = STATUS_SUCCESS;
        }

    }



    //
    // Get the Password Notification Routine
    //

    if (NT_SUCCESS(NtStatus)) {

        RtlInitString(
            &NotificationRoutineName,
            SAM_PASSWORD_CHANGE_NOTIFY_ROUTINE
            );

        (void) LdrGetProcedureAddress(
                    ModuleHandle,
                    &NotificationRoutineName,
                    0,
                    (PVOID *) &NewPackage->PasswordNotificationRoutine
                    );

    }

    //
    // Get the Delta Change Notification Routine
    //

    if (NT_SUCCESS(NtStatus)) {
        RtlInitString(
            &NotificationRoutineName,
            SAM_DELTA_NOTIFY_ROUTINE
            );

        (void) LdrGetProcedureAddress(
                    ModuleHandle,
                    &NotificationRoutineName,
                    0,
                    (PVOID *) &NewPackage->DeltaNotificationRoutine
                    );
    }

    //
    // Get the Password Filter Routine
    //

    if (NT_SUCCESS(NtStatus)) {
        RtlInitString(
            &NotificationRoutineName,
            SAM_PASSWORD_FILTER_ROUTINE
            );

        (void) LdrGetProcedureAddress(
                    ModuleHandle,
                    &NotificationRoutineName,
                    0,
                    (PVOID *) &NewPackage->PasswordFilterRoutine
                    );
    }

    //
    // Get the UserParms Convert Notification Routine
    //     and UserParms Attribute Block Free Routine
    //

    if (NT_SUCCESS(NtStatus)) {

        RtlInitString(
            &NotificationRoutineName,
            SAM_USERPARMS_CONVERT_NOTIFICATION_ROUTINE
            );

        (void) LdrGetProcedureAddress(
                    ModuleHandle,
                    &NotificationRoutineName,
                    0,
                    (PVOID *) &NewPackage->UserParmsConvertNotificationRoutine
                    );

        RtlInitString(
            &NotificationRoutineName,
            SAM_USERPARMS_ATTRBLOCK_FREE_ROUTINE
            );

        (void) LdrGetProcedureAddress(
                    ModuleHandle,
                    &NotificationRoutineName,
                    0,
                    (PVOID *) &NewPackage->UserParmsAttrBlockFreeRoutine
                    );

    }

    //
    // See if it supports the Credential Update Notify registration
    //
    if (NT_SUCCESS(NtStatus)) {

        RtlInitString(
            &NotificationRoutineName,
            SAM_CREDENTIAL_UPDATE_REGISTER_ROUTINE
            );

        NtStatus = LdrGetProcedureAddress(
                        ModuleHandle,
                        &NotificationRoutineName,
                        0,
                        (PVOID *) &CredentialRegisterRoutine
                        );
        if (NT_SUCCESS(NtStatus)) {

            BOOLEAN fStatus;
            ASSERT(CredentialRegisterRoutine != NULL);

            //
            // Call the init routine. If it returns false, unload this
            // DLL and continue on.
            //
            fStatus = CredentialRegisterRoutine(&CredentialName);

            if (!fStatus) {
                NtStatus = STATUS_INTERNAL_ERROR;
            }

        } else {
            //
            // This call isn't required, so reset the status to
            // STATUS_SUCCESS.
            //

            NtStatus = STATUS_SUCCESS;
        }
    }

    //
    // Get the Credential Update routine
    //

    if ( NT_SUCCESS(NtStatus) 
     && CredentialRegisterRoutine ) {

        RtlInitString(
            &NotificationRoutineName,
            SAM_CREDENTIAL_UPDATE_NOTIFY_ROUTINE
            );

        (void) LdrGetProcedureAddress(
                    ModuleHandle,
                    &NotificationRoutineName,
                    0,
                    (PVOID *) &NewPackage->CredentialUpdateNotifyRoutine
                    );
    }

    if ( NT_SUCCESS(NtStatus) 
     && CredentialRegisterRoutine ) {

        RtlInitString(
            &NotificationRoutineName,
            SAM_CREDENTIAL_UPDATE_FREE_ROUTINE
            );

        (void) LdrGetProcedureAddress(
                    ModuleHandle,
                    &NotificationRoutineName,
                    0,
                    (PVOID *) &NewPackage->CredentialUpdateFreeRoutine
                    );
    }

    if (NewPackage->CredentialUpdateNotifyRoutine) {

        //
        // There should be a CredentialName and a Free routine
        //
        if (   (NULL == CredentialName.Buffer)
            || (0 == CredentialName.Length) 
            || (NULL == NewPackage->CredentialUpdateFreeRoutine)) {
            NtStatus = STATUS_INTERNAL_ERROR;
        }


        if (NT_SUCCESS(NtStatus)) {
            NewPackage->Parameters.CredentialUpdateNotify.CredentialName = CredentialName;
        }
    }


    //
    //  At least one of the 4 functions must be present
    //  also we require the UserParmsConvertNotificationRoutine
    //  and UserParmsAttrBlockFreeRoutine must be present together.
    //

    if ((NewPackage->PasswordNotificationRoutine == NULL) &&
        (NewPackage->DeltaNotificationRoutine == NULL) &&
        (NewPackage->CredentialUpdateNotifyRoutine == NULL) &&
        (NewPackage->PasswordFilterRoutine == NULL) &&
        ((NewPackage->UserParmsConvertNotificationRoutine == NULL) ||
         (NewPackage->UserParmsAttrBlockFreeRoutine == NULL))
       )
    {

        NtStatus = STATUS_INTERNAL_ERROR;
    }

    //
    // If all this succeeded, add the routine to the global list.
    //


    if (NT_SUCCESS(NtStatus)) {


        NewPackage->Next = SampNotificationPackages;
        SampNotificationPackages = NewPackage;

        //
        // Notify the auditing code to record this event.
        //

        (VOID)LsaIAuditNotifyPackageLoad(
                  &PackageName
                  );


    } else {

        //
        // Otherwise delete the entry.
        //

        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            NewPackage
            );

        if (ModuleHandle != NULL) {
            (VOID) LdrUnloadDll( ModuleHandle );
        }
    }

    return(STATUS_SUCCESS);
    
}


NTSTATUS
SampConfigurePackageFromRegistry(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

    This routine is a wrapper for the notificaton package loading routine.  It
    ensures we do not load any mandatory notification packages that might be 
    configured in the registry, thus preventing duplicate notifications.
    
    Mandatory packages are loaded separately.
    
Arguments:

    ValueName - Contains the name of the registry value, ignored.
    ValueType - Contains type of Value, must be REG_SZ.
    ValueData - Contains the package name null-terminated string.
    ValueLength - Length of package name and null terminator, in bytes.
    Context - Passed from caller of RtlQueryRegistryValues, ignored
    EntryContext - Ignored

Return Value:

    STATUS_SUCCESS - Package load operation succeeded.
                                                    
    Error status returned from SampConfigurePackage.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    
    SAMTRACE("SampConfigurePackageEx");
    
    //
    // Make sure we got a string.
    //              
    if (ValueType != REG_SZ) {
        goto Cleanup;
    }
    
    //
    // Skip manadatory packages on DCs, they were already loaded separately.
    //              
    if (SampUseDsData) {
        
        ULONG i = 0;
        
        for (; i < RTL_NUMBER_OF(SampMandatoryNotificationPackages); i++) {
                
            if (0 == _wcsicmp((LPWSTR)ValueData, 
                              SampMandatoryNotificationPackages[i])) {
                goto Cleanup;
            }
        }
    }
    
    NtStatus = SampConfigurePackage(
                   ValueName,
                   ValueType,
                   ValueData,
                   ValueLength,
                   Context,
                   EntryContext
                   );
    
Cleanup:
    
    return NtStatus;
    
}                   


NTSTATUS
SampLoadNotificationPackages(
    )
/*++

Routine Description:

    This routine loads the mandatory password change notification packages 
    on domain controllers only.  Then it loads the list of password change 
    packages configured in the registry.  Care is take to ensure packages 
    are loaded only once.

Arguments:

    none


Return Value:

    STATUS_SUCCESS -- We always return success as failure to load a 
                      notification package is not a reason to prevent
                      the system from booting.

--*/
{
    NTSTATUS IgnoreNtStatus;
    
    SAMTRACE("SampLoadNotificationPackages");
    
    //
    // We always want to load these system authentication package 
    // notification DLLs on a DC.
    //
    
    if (SampUseDsData) {
        
        ULONG i = 0;
        
        for (; i < RTL_NUMBER_OF(SampMandatoryNotificationPackages); i++) {
        
            ULONG StrLen = (wcslen(SampMandatoryNotificationPackages[i]) + 1) * 
                               sizeof(WCHAR);
            
            IgnoreNtStatus = SampConfigurePackage(
                                 L"Notification Packages",
                                 REG_SZ,
                                 SampMandatoryNotificationPackages[i],
                                 StrLen,
                                 NULL,
                                 NULL
                                 );
        
            ASSERT(NT_SUCCESS(IgnoreNtStatus));
        }
    }
    
    //
    // Load registry configured notification packages
    //
    
    IgnoreNtStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_CONTROL,
                L"Lsa",
                SampRegistryConfigTable,
                NULL,   // no context
                NULL    // no enviroment
                );
    
    //
    // Always return STATUS_SUCCESS so we don't block the system from
    // booting.
    //

    return(STATUS_SUCCESS);
    
}

NTSTATUS
SamISetPasswordInfoOnPdc(
    IN SAMPR_HANDLE SamDomainHandle,
    IN LPBYTE OpaqueBuffer,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    When an account changes its password on a BDC, the password change is
    propagated to the PDC as quickly as possible, via NetLogon. NetLogon
    calls this routine in order to change the password on the PDC.

    This routine unbundles the opaque buffer from NetLogon, on the PDC, and
    sets the SAM password information accordingly.

Arguments:

    SamHandle - Handle, an open and valid SAM context block.

    OpaqueBuffer - Pointer, password-change information from the BDC.

    BufferLength - Length of the buffer in bytes.

Return Value:

    STATUS_SUCCESS if the password was successfully sent to the PDC, else
        error codes from SamrSetInformationUser.

    STATUS_UNKNOWN_REVISION: this server doesn't understand the blob that
    was send to us

    STATUS_REVISION_MISMATCH: this server understands the blob but not
    the revision of the particular blob


--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMI_SECURE_CHANNEL_BLOB SecureChannelBlob = NULL;

    //
    // Sanity check some parameters
    //
    if ((NULL == SamDomainHandle) ||
        (NULL == OpaqueBuffer) ||
        (0 == BufferLength))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    SecureChannelBlob = (PSAMI_SECURE_CHANNEL_BLOB)OpaqueBuffer;

    //
    // See what message is being passed to us
    //
    switch ( SecureChannelBlob->Type )
    {
        case SamPdcPasswordNotification:

            NtStatus =  SampSetPasswordInfoOnPdcWorker( SamDomainHandle,
                                                        (PSAMI_PASSWORD_INFO) SecureChannelBlob->Data,
                                                        SecureChannelBlob->DataSize );

            break;

        case SamPdcResetBadPasswordCount:

            NtStatus = SampResetBadPwdCountOnPdcWorker( SamDomainHandle,
                                                        (PSAMI_BAD_PWD_COUNT_INFO) SecureChannelBlob->Data
                                                        );

            break;

        default:

            NtStatus = STATUS_UNKNOWN_REVISION;

            break;
    }

    return NtStatus;

}


NTSTATUS
SamIResetBadPwdCountOnPdc(
    IN SAMPR_HANDLE SamUserHandle
    )
/*++
Routine Description: 

    When a client successfully logon on a BDC, and if the previous bad
    password count of this account is not zero (mistakenly type the 
    wrong password, etc), authentication package will need to reset
    the bad password count to 0 on both BDC and PDC.

    In Windows 2000, NTLM and Kerberos reset the bad password count 
    to zero on PDC by forwarding the authentication to PDC, which 
    is expensive. To eliminate the extra authentication, we will send 
    a bad password count reset operation request to PDC directly, 
    through Net Logon Secure Channel. On the PDC side, once NetLogon 
    receives this request, it will let SAM modify bad password count to 
    zero on this particular account.


Parameter:

    SamUserHandle - Handle to the SAM User Account

Return Value:

    NTSTATUS Code
    STATUS_UNKNONW_REVISION - PDC is still running Windows 2000

    Caller can choose to ignore the return code, but they need to 
    deal with STATUS_UNKNOWN_REVISION and switch to the old behavior.

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    PSAMP_OBJECT    UserContext = NULL;
    NT_PRODUCT_TYPE NtProductType = 0;
    ULONG           TotalSize;
    PSAMI_BAD_PWD_COUNT_INFO    BadPwdCountInfo;
    PSAMI_SECURE_CHANNEL_BLOB   SecureChannelBlob = NULL;

    //
    // Check parameter
    // 
    if (NULL == SamUserHandle)
    {
        ASSERT(FALSE && "Invalid SAM Handle\n");
        goto Error;
    }
    UserContext = (PSAMP_OBJECT) SamUserHandle;



    // 
    // Only allow this call to be made from a BDC to the PDC.
    // 

    RtlGetNtProductType(&NtProductType);

    if ( (!IsDsObject(UserContext)) ||
         (NtProductLanManNt != NtProductType) || 
         (DomainServerRoleBackup != SampDefinedDomains[DOMAIN_START_DS + 1].ServerRole) )
    {
        // if this isn't a BDC,  there's nothing to do here. fail silently.
        NtStatus = STATUS_SUCCESS;
        goto Error;
    }
    

    //
    // prepare the secure channel blob 
    // 

    TotalSize = sizeof(SAMI_SECURE_CHANNEL_BLOB) +      // size of the header 
                sizeof(SAMI_BAD_PWD_COUNT_INFO) -       // size of the real data
                sizeof(DWORD);                          // minus the first dword taken by the Data[0]

    SecureChannelBlob = MIDL_user_allocate( TotalSize );

    if (NULL == SecureChannelBlob)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }
    memset(SecureChannelBlob, 0, TotalSize);

    SecureChannelBlob->Type = SamPdcResetBadPasswordCount;
    SecureChannelBlob->DataSize = sizeof(SAMI_BAD_PWD_COUNT_INFO);

    BadPwdCountInfo = (PSAMI_BAD_PWD_COUNT_INFO) &SecureChannelBlob->Data[0];
    BadPwdCountInfo->ObjectGuid = UserContext->ObjectNameInDs->Guid;

    //
    // Send the bad password count reset request to PDC. This routine is 
    // synchronous and may take a few minutes, in the worst case, to return.
    // Caller might choose to ignore the error code, because the PDC may 
    // not be available, or the account may not yet exist on the PDC due
    // to replicataion latency, etc. But Failure like STATUS_UNKNOWN_REVISION
    // should be taken cared of by caller, thus that caller can switch 
    // to the old behavior.
    // 

    NtStatus = I_NetLogonSendToSamOnPdc(NULL, 
                                        (PUCHAR)SecureChannelBlob, 
                                        TotalSize
                                        );


    SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                   (SAMP_LOG_ACCOUNT_LOCKOUT,
                   "UserId:0x%x sending BadPasswordCount reset to PDC (status 0x%x)\n",
                   UserContext->TypeBody.User.Rid,
                   NtStatus));
Error:

    if (SecureChannelBlob) {
        MIDL_user_free( SecureChannelBlob );
    }

    return( NtStatus );
}


NTSTATUS
SampResetBadPwdCountOnPdcWorker(
    IN SAMPR_HANDLE SamDomainHandle,
    IN PSAMI_BAD_PWD_COUNT_INFO BadPwdCountInfo
    )
/*++
Routine Description:

    This is the worker routine to set account bad password count to zero
    on PDC. 

    It does it by starting a DS transaction, modifying bad password
    count to zero on the DS object.
    
Parameters:

    SamDomainHandle - SAM Domain Handle, igonred by this routine.
    
    BadPwdCountInfo - Indicate which account (by object GUID)

Return Value:

    NTSTATUS Code

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    MODIFYARG       ModArg;
    MODIFYRES       *pModRes = NULL;
    COMMARG         *pCommArg = NULL;
    ULONG           RetCode;
    ULONG           BadPasswordCount = 0;
    ATTR            Attr;
    ATTRVAL         AttrVal;
    ATTRVALBLOCK    AttrValBlock;
    DSNAME          ObjectDsName;

    if (NULL == BadPwdCountInfo)
    {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    // begin a new DS transaction
    // 

    NtStatus = SampMaybeBeginDsTransaction(TransactionWrite);

    if (!NT_SUCCESS(NtStatus))
    {
        return( NtStatus );
    }

    //
    // get the object GUID and prepare DSName
    // 
    memset( &ObjectDsName, 0, sizeof(ObjectDsName) );
    ObjectDsName.structLen = DSNameSizeFromLen( 0 ); 
    ObjectDsName.Guid = BadPwdCountInfo->ObjectGuid; 

    //
    // prepare modify arg
    // 
    memset( &ModArg, 0, sizeof(ModArg) );
    ModArg.pObject = &ObjectDsName;

    ModArg.FirstMod.pNextMod = NULL;
    ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;

    AttrVal.valLen = sizeof(ULONG);
    AttrVal.pVal = (PUCHAR) &BadPasswordCount;

    AttrValBlock.valCount = 1;
    AttrValBlock.pAVal = &AttrVal;

    Attr.attrTyp = ATT_BAD_PWD_COUNT;
    Attr.AttrVal = AttrValBlock;

    ModArg.FirstMod.AttrInf = Attr;
    ModArg.count = 1;

    pCommArg = &(ModArg.CommArg);
    
    BuildStdCommArg(pCommArg);

    //
    // using lazy commit
    // 
    pCommArg->fLazyCommit = TRUE;


    //
    // this request is coming from subauth packages, they are trusted clients
    // 
    SampSetDsa( TRUE );

    //
    // call into DS routine
    // 
    RetCode = DirModifyEntry(&ModArg, &pModRes);

    if (NULL == pModRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetCode,&pModRes->CommRes);
    }

    //
    // end the DS transaction 
    // 
    NtStatus = SampMaybeEndDsTransaction(NT_SUCCESS(NtStatus) ? 
                                         TransactionCommit:TransactionAbort
                                         );

    {
        //
        // Log that the Bad Password Count has been zero'ed
        // 
        LPSTR UserString = NULL;
        LPSTR UnknownUser = "Unknown";
        BOOL  fLocalFree = FALSE;
        if (  (ModArg.pObject->SidLen > 0)
           && ConvertSidToStringSidA(&ModArg.pObject->Sid, &UserString) ) {
            fLocalFree = TRUE;
        } else {
            DWORD err;
            err  = UuidToStringA(&ModArg.pObject->Guid, &UserString);
            if (err) {
                UserString = NULL;
            }
        }
        if (UserString == NULL) {
            UserString = UnknownUser;
        }

        SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                       (SAMP_LOG_ACCOUNT_LOCKOUT,
                       "UserId: %s  BadPasswordCount reset to 0 (status : 0x%x)\n",
                       UserString, NtStatus));

        if (UserString != UnknownUser) {
            if (fLocalFree) {
                LocalFree(UserString);
            } else {
                RpcStringFreeA(&UserString);
            }
        }
    }

    return( NtStatus );
}




NTSTATUS
SampSetPasswordInfoOnPdcWorker(
    IN SAMPR_HANDLE SamDomainHandle,
    IN PSAMI_PASSWORD_INFO PasswordInfo,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    When an account changes its password on a BDC, the password change is
    propagated to the PDC as quickly as possible, via NetLogon. NetLogon
    calls this routine in order to change the password on the PDC.

    This routine unbundles the opaque buffer from NetLogon, on the PDC, and
    sets the SAM password information accordingly.

Arguments:

    SamHandle - Handle, an open and valid SAM context block.

    PasswordInfo - Pointer, password-change information from the BDC.

    BufferLength - Length of the buffer in bytes.

Return Value:

    STATUS_SUCCESS if the password was successfully sent to the PDC, else
        error codes from SamrSetInformationUser.

    STATUS_REVISION_MISMATCH - not enough fields were present for us to
                               make sense of

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG Index = 0;
    USHORT Offset = 0;
    USHORT Length = 0;
    PLM_OWF_PASSWORD LmOwfPassword;
    PNT_OWF_PASSWORD NtOwfPassword;
    ACCESS_MASK DesiredAccess = USER_WRITE_ACCOUNT | USER_CHANGE_PASSWORD;
    SAMPR_HANDLE UserHandle=NULL;
    ULONG Flags = 0;
    PSAMI_PASSWORD_INDEX PasswordIndex = NULL;
    UCHAR *DataStart = NULL;

    if ((NULL == SamDomainHandle) ||
        (NULL == PasswordInfo) ||
        (0 == BufferLength))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    Flags = PasswordInfo->Flags;

    if ( 0 == Flags )
    {
        // Boundary case; the caller did not send any info!
        return STATUS_SUCCESS;
    }

    if ((Flags & SAM_VALID_PDC_PUSH_FLAGS) != Flags) {
        //
        // The caller is requesting something we can't support
        //
        return STATUS_REVISION_MISMATCH;
    }

    //
    // We have enough information to set the password
    //
    
    PasswordIndex = (PSAMI_PASSWORD_INDEX) &PasswordInfo->DataIndex[0];
    DataStart = ((UCHAR*)PasswordInfo) + PasswordInfo->Size;
    
    //
    // Setup the LM OWF password.
    //
    Index = SampPositionOfHighestBit( SAM_LM_OWF_PRESENT ) - 1;
    Length = (USHORT)(PasswordIndex[Index].Length);
    Offset = (USHORT)(PasswordIndex[Index].Offset);
    LmOwfPassword = (PLM_OWF_PASSWORD)(DataStart + Offset);
    
    //
    // Setup the NT OWF password.
    //
    Index = SampPositionOfHighestBit( SAM_NT_OWF_PRESENT ) - 1;
    Length = (USHORT)(PasswordIndex[Index].Length);
    Offset = (USHORT)(PasswordIndex[Index].Offset);
    NtOwfPassword = (PNT_OWF_PASSWORD)(DataStart + Offset);
    
    NtStatus = SampPrivatePasswordUpdate( SamDomainHandle,
                                          Flags,
                                          PasswordInfo->AccountRid,
                                          LmOwfPassword,
                                          NtOwfPassword,
                                          PasswordInfo->PasswordExpired);


    SampDiagPrint( DISPLAY_LOCKOUT,
                 ( "SAMSS: PDC password notify for rid %d, status: 0x%x\n",
                 PasswordInfo->AccountRid,
                 NtStatus ));


    return(NtStatus);
}

NTSTATUS
SampPasswordChangeNotifyPdc(
    IN ULONG Flags,
    IN PUNICODE_STRING UserName,
    IN ULONG RelativeId,
    IN PUNICODE_STRING NewPassword
    )

/*++

Routine Description:

    This routine forwards password modifications from a BDC to the domain PDC
    so that the PDC's notion of the account password is synchronized with the
    recent change. The user name, account ID, clear-text password, LM and NT
    OWF passwords are sent to the PDC via NetLogon.

Arguments:

    UserName - Pointer, SAM account name.

    RelativeId - SAM account identifier.

    NewPassword - Pointer, clear-text password, from which LM and NT OWF pass-
        words are calculated.

Return Value:

    STATUS_SUCCESS if the password was successfully sent to the PDC, else
        error codes from SampCalculateLmAndNtOwfPasswords or NetLogon.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    ULONG NameBufferLength = 0;                     // Aligned buffer length
    ULONG NameLength = UserName->Length;            // Actual data length

    ULONG BufferLength = 0;                         // Aligned buffer length
    ULONG DataLength = 0;                           // Actual data length

    ULONG LmBufferLength = 0;                       // Aligned buffer length
    ULONG LmDataLength = sizeof(LM_OWF_PASSWORD);   // Actual data length

    ULONG NtBufferLength = 0;                       // Aligned buffer length
    ULONG NtDataLength = sizeof(NT_OWF_PASSWORD);   // Actual data length

    ULONG PasswordHeaderSize = 0;
    ULONG BlobHeaderSize = 0;
    ULONG TotalSize = 0;
    PSAMI_PASSWORD_INDEX PasswordIndex = 0;
    ULONG DataSize = 0;

    ULONG CurrentOffset = 0;
    ULONG ElementCount = 0;
    ULONG Index = 0;

    ULONG Where = 0;

    LM_OWF_PASSWORD LmOwfPassword;
    NT_OWF_PASSWORD NtOwfPassword;

    PSAMI_SECURE_CHANNEL_BLOB SecureChannelBlob = NULL;
    PSAMI_PASSWORD_INFO PasswordInfo = NULL;
    PBYTE DataPtr = NULL, DataStart = NULL;

    BOOLEAN LmPasswordPresent = FALSE;


    // This is bogus, but SAM calls itself passing a NULL UNICODE_STRING arg
    // from SamrChangePasswordUser, instead of passing the clear-text pwd or
    // a valid UNICODE_STRING with zero length. Just return an error in this
    // case as the NULL is meaningless for purposes of notification.
    //
    // Also return an error if the new-password buffer happens to be NULL, so
    // that it is not referenced below in RtlCopyMemory.
    if ( (Flags & SAM_NT_OWF_PRESENT) 
      && (!NewPassword || !NewPassword->Buffer) )
    {
        return STATUS_SUCCESS;
    }

    if ( 0 == Flags )
    {
        return STATUS_SUCCESS;
    }

    //
    // Get the name length
    //
    ASSERT( UserName );
    NameLength = UserName->Length;

    if (Flags & SAM_NT_OWF_PRESENT) {

        // Calculate the Lanman and NT one-way function (LmOwf, NtOwf) passwords
        // from the clear-text password.

        //
        // NTRAID#NTBUG9-457724-2002/0610-colinbr, win2k DC's always write the 
        // LM password when the password is pushed to the PDC, even when no LM 
        // password exists.  To compensate for the scenario where the PDC is 
        // win2k, fill the buffer with the NullLmOwf so that the value is not
        // actually written on the PDC (the NullLmOwf is not stored).
        // The NT hash will be correct.
        //
        RtlCopyMemory(&LmOwfPassword, &SampNullLmOwfPassword, LmDataLength);

        RtlSecureZeroMemory(&NtOwfPassword, NtDataLength);
    
        NtStatus = SampCalculateLmAndNtOwfPasswords(NewPassword,
                                                    &LmPasswordPresent,
                                                    &LmOwfPassword,
                                                    &NtOwfPassword);
        if ( !NT_SUCCESS( NtStatus ) )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampCalculateLmAndNtOwfPasswords status = 0x%lx\n",
                       NtStatus));
    
            goto Exit;
        }
    } else {

        //
        // No passwords to send
        //
        LmDataLength = 0;
        NtDataLength = 0;
    }
    
    //
    // Get the aligned sizes
    //
    NameBufferLength = SampDwordAlignUlong(NameLength);
    LmBufferLength   = SampDwordAlignUlong(LmDataLength);
    NtBufferLength   = SampDwordAlignUlong(NtDataLength);

    //
    // Calculate the size of the entire buffer
    //

    // The secure channel blob
    BlobHeaderSize = sizeof( SAMI_SECURE_CHANNEL_BLOB );

    // The header info for the password
    ElementCount = SampPositionOfHighestBit( Flags );
    ASSERT( ElementCount > 0 );

    //
    // N.B. ElementCount-1 is used since SAMI_PASSWORD_INFO already has
    // one SAMI_PASSWORD_INDEX
    //
    PasswordHeaderSize = sizeof( SAMI_PASSWORD_INFO )
                      + (sizeof( SAMI_PASSWORD_INDEX ) * (ElementCount-1));

    // The data of the password change
    DataSize = 0;
    DataSize += NameBufferLength;
    DataSize += LmBufferLength;
    DataSize += NtBufferLength;

    // That's it
    TotalSize =  BlobHeaderSize
               + PasswordHeaderSize
               + DataSize;

    SecureChannelBlob = MIDL_user_allocate(TotalSize);

    if ( !SecureChannelBlob )
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Exit;
    }
    RtlSecureZeroMemory(SecureChannelBlob, TotalSize);

    //
    // Set up the SecureChannelBlob
    //
    SecureChannelBlob->Type = SamPdcPasswordNotification;
    SecureChannelBlob->DataSize = PasswordHeaderSize + DataSize;

    //
    // Set up the password info
    //
    PasswordInfo = (PSAMI_PASSWORD_INFO) &SecureChannelBlob->Data[0];
    PasswordInfo->Flags = Flags;
    PasswordInfo->Size = PasswordHeaderSize;
    PasswordInfo->AccountRid = RelativeId;
    PasswordInfo->PasswordExpired = (Flags & SAM_MANUAL_PWD_EXPIRY) ? TRUE : FALSE;

    //
    // Set up the indices
    //

    //
    // First the lengths
    //
    PasswordIndex = &PasswordInfo->DataIndex[0];
    PasswordIndex[ SampPositionOfHighestBit(SAM_ACCOUNT_NAME_PRESENT)-1 ].Length
         = NameBufferLength;
    PasswordIndex[ SampPositionOfHighestBit(SAM_NT_OWF_PRESENT)-1 ].Length
         = NtBufferLength;
    PasswordIndex[ SampPositionOfHighestBit(SAM_LM_OWF_PRESENT)-1 ].Length
         = LmBufferLength;

    //
    // Now the offsets
    //
    CurrentOffset = 0;
    for ( Index = 0; Index < ElementCount; Index++ )
    {
        PasswordIndex[ Index ].Offset = CurrentOffset;
        CurrentOffset += PasswordIndex[ Index ].Length;
    }

    //
    // Copy in the data
    //
    DataStart = ((UCHAR*)PasswordInfo) + PasswordHeaderSize;

    Index = SampPositionOfHighestBit(SAM_ACCOUNT_NAME_PRESENT)-1;
    DataPtr = DataStart + PasswordIndex[Index].Offset;
    RtlCopyMemory( DataPtr, UserName->Buffer, NameLength );

    Index = SampPositionOfHighestBit(SAM_LM_OWF_PRESENT)-1;
    DataPtr = DataStart + PasswordIndex[ Index ].Offset;
    RtlCopyMemory( DataPtr, &LmOwfPassword, LmDataLength );

    Index = SampPositionOfHighestBit(SAM_NT_OWF_PRESENT)-1;
    DataPtr = DataStart + PasswordIndex[ Index ].Offset;
    RtlCopyMemory( DataPtr, &NtOwfPassword, NtDataLength );

    // Send the password information to the PDC. This routine is
    // synchronous and may take a few minutes, in the worst case,
    // to return. The error code is ignored (except for debug
    // message purposes) because it is benign. This call can fail
    // because the PDC is unavailable, the account may not yet
    // exist on the PDC due to replication latency, etc. Failure
    // to propagate the password to the PDC is not a critical
    // error.

    NtStatus = I_NetLogonSendToSamOnPdc(NULL,
                                       (PUCHAR)SecureChannelBlob,
                                       TotalSize);


    SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                   (SAMP_LOG_ACCOUNT_LOCKOUT,
                   "UserId: 0x%x  PDC forward, Password=%s, Expire=%s, Unlock=%s  (status 0x%x)\n",
                   RelativeId, 
                   ((Flags & SAM_NT_OWF_PRESENT) ? "TRUE" : "FALSE"),
                   ((Flags & SAM_MANUAL_PWD_EXPIRY) ? "TRUE" : "FALSE"),
                   ((Flags & SAM_ACCOUNT_UNLOCKED) ? "TRUE" : "FALSE"),
                   NtStatus));

    if (!NT_SUCCESS(NtStatus))
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: I_NetLogonSendToSamOnPdc status = 0x%lx\n",
                   NtStatus));

        NtStatus = STATUS_SUCCESS;
    }

    MIDL_user_free(SecureChannelBlob);


Exit:

    return(NtStatus);
}


NTSTATUS
SampPasswordChangeNotify(
    IN ULONG            Flags,
    IN PUNICODE_STRING  UserName,
    IN ULONG            RelativeId,
    IN PUNICODE_STRING  NewPassword,
    IN BOOLEAN          Loopback
    )
/*++

Routine Description:

    This routine notifies packages of a password change.  It requires that
    the user no longer be locked so that other packages can write to the
    user parameters field.


Arguments:

    Flags - what has changed

    UserName - Name of user whose password changed

    RelativeId - RID of the user whose password changed

    NewPassword - Cleartext new password for the user
    
    Loopback    - Indicates that this is loopback ... ie transaction may not
                  have committed and will be commited by ntdsa later.

Return Value:

    STATUS_SUCCESS only - errors from packages are ignored.

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOL     fStatus;

    PSAMP_LOOPBACK_TASK_ITEM  Item = NULL;
    PUNICODE_STRING           TempUserName = NULL;
    PUNICODE_STRING           TempNewPassword = NULL;
    ULONG                     Size;

    if ( SampUseDsData && Loopback )
    {
        //
        // The ds has the lock. Can't talk to the pdc right now. Store the
        // information in the thread state to be processed when all
        // transactions and locks  are freed.
        //

        //
        // Allocate the space
        //
        Item = THAlloc( sizeof( SAMP_LOOPBACK_TASK_ITEM ) );
        if ( !Item )
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        RtlSecureZeroMemory( Item, sizeof( SAMP_LOOPBACK_TASK_ITEM ) );

        TempUserName    = &(Item->NotifyInfo.PasswordChange.UserName);
        TempNewPassword = &(Item->NotifyInfo.PasswordChange.NewPassword);
        //
        // Setup the name
        //
        Size = UserName->MaximumLength;
        TempUserName->Buffer = THAlloc( Size );
        if (NULL == TempUserName->Buffer)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        TempUserName->Length = 0;
        TempUserName->MaximumLength = (USHORT) Size;
        RtlCopyUnicodeString( TempUserName, UserName );
        //
        // Setup the password, if present
        //
        if (Flags & SAMP_PWD_NOTIFY_PWD_CHANGE) {

            Size = NewPassword->MaximumLength;
            TempNewPassword->Buffer = THAlloc( Size );
            TempNewPassword->Length = 0;
            TempNewPassword->MaximumLength = (USHORT) Size;
            RtlCopyUnicodeString( TempNewPassword, NewPassword );

        }
        //
        // Set the item up
        //
        Item->Type = SampNotifyPasswordChange;
        Item->fCommit = TRUE;

        //
        // And the rid
        //
        Item->NotifyInfo.PasswordChange.RelativeId = RelativeId;
        Item->NotifyInfo.PasswordChange.Flags = Flags;

        fStatus = SampAddLoopbackTask( Item );

        if ( !fStatus )
        {
            NtStatus = STATUS_NO_MEMORY;
        }

    }
    else
    {
        NtStatus = SampPasswordChangeNotifyWorker( Flags,
                                                   UserName,
                                                   RelativeId,
                                                   NewPassword );

        SampDiagPrint( DISPLAY_LOCKOUT,
                     ( "SAMSS: Password notify for %ls (%d) status: 0x%x\n",
                     UserName->Buffer,
                     RelativeId,
                     NtStatus ));
    }

Cleanup:

    if ( !NT_SUCCESS( NtStatus ) )
    {
        if ( TempUserName && TempUserName->Buffer )
        {
            THFree( TempUserName->Buffer );
        }
        if ( TempNewPassword && TempNewPassword->Buffer )
        {
            THFree( TempNewPassword->Buffer );
        }
        if ( Item )
        {
            THFree( Item );
        }
    }

    return NtStatus;
}

NTSTATUS
SampPasswordChangeNotifyWorker(
    IN ULONG Flags,
    IN PUNICODE_STRING UserName,
    IN ULONG RelativeId,
    IN PUNICODE_STRING NewPassword
    )
/*++

Routine Description:

    This routine notifies packages of a password change.  It requires that
    the user no longer be locked so that other packages can write to the
    user parameters field.


Arguments:

    Flags -    //
               // Indicates that what has changed
               //
            SAMP_PWD_NOTIFY_MANUAL_EXPIRE
            SAMP_PWD_NOTIFY_UNLOCKED
            SAMP_PWD_NOTIFY_PWD_CHANGE
            SAMP_PWD_NOTIFY_MACHINE_ACCOUNT
                     
    UserName - Name of user whose password changed

    RelativeId - RID of the user whose password changed

    NewPassword - Cleartext new password for the user
    
Return Value:

    STATUS_SUCCESS only - errors from packages are ignored.

--*/
{
    NTSTATUS NtStatus;
    PSAMP_NOTIFICATION_PACKAGE Package;
    NT_PRODUCT_TYPE NtProductType = 0;
    PSAMP_OBJECT DomainContext = NULL;
    PVOID *pTHState = NULL;

    SAMTRACE("SampPasswordChangeNotify");

    //
    // Suspend the thread state since the packages may call back into
    // SAM
    //
    if ( SampUseDsData
      && THQuery() ) {
        pTHState = THSave();
        ASSERT( pTHState );
    }

    //
    // The lock should not be held
    //
    ASSERT( !SampCurrentThreadOwnsLock() );

    if (Flags & SAMP_PWD_NOTIFY_PWD_CHANGE) {

        //
        // Notify the packages
        //
        Package = SampNotificationPackages;
    
        while (Package != NULL) {
            if ( Package->PasswordNotificationRoutine != NULL ) {
                try {
                    NtStatus = Package->PasswordNotificationRoutine(
                                    UserName,
                                    RelativeId,
                                    NewPassword
                                    );
                    if (!NT_SUCCESS(NtStatus)) {
                        KdPrintEx((DPFLTR_SAMSS_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "Package %wZ failed to accept password change for user %wZ\n",
                                   &Package->PackageName, UserName));
                    }
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "Exception thrown in Password Notification Routine: 0x%x (%d)\n",
                               GetExceptionCode(),
                               GetExceptionCode()));
    
                    NtStatus = STATUS_ACCESS_VIOLATION;
                }
            }
    
            Package = Package->Next;
    
        }

    }

    // Errors from packages are ignored; always notify the PDC of a password
    // change. Because the PDC may not be available, or reachable, the return
    // status can be ignored here. It is not essential that the PDC receive
    // the password-change information right away--replication will ultimately
    // get the information to the PDC. Only make this call on a BDC in order
    // to propagate the password information to the PDC. Since the routine
    // SampPasswordChangeNotify is also called on the PDC when the password
    // information is set there, we don't want to recursively call the routine
    // SampPasswordChangeNotifyPdc on the PDC.

    //
    // Don't notify the PDC on password set.  A common situation is for an
    // admin to reset the password and then expire it (which writes to the
    // PasswordLastSet attributes).  Pushing the password to the PDC will
    // cause the PasswordLastSet to have an originating write which can 
    // overwrite the expiration attempt.  (Windows bug 352242).
    //

    RtlGetNtProductType(&NtProductType);

    if ( (NtProductLanManNt == NtProductType)
     &&  ((Flags & SAMP_PWD_NOTIFY_MACHINE_ACCOUNT) == 0)
     &&  (DomainServerRoleBackup == SampDefinedDomains[DOMAIN_START_DS + 1].ServerRole) )
    {
        // Only allow this call to be made from a BDC to the PDC.
        ULONG PdcFlags = SAM_ACCOUNT_NAME_PRESENT;
        
        
        if (Flags & SAMP_PWD_NOTIFY_PWD_CHANGE) {
            //
            // It is a bug that the client always passes in SAM_LM_OWF_PRESENT
            // even if no LM hash is present.  However win2k DC's only 
            // accept the password update request if the SAM_LM_OWF_PRESENT 
            // bit is set.  .NET and beyond don't have this requirement.
            //
            PdcFlags |= SAM_NT_OWF_PRESENT | SAM_LM_OWF_PRESENT;
        }
        if (Flags & SAMP_PWD_NOTIFY_UNLOCKED) {
            PdcFlags |= SAM_ACCOUNT_UNLOCKED;
        }
        if (Flags & SAMP_PWD_NOTIFY_MANUAL_EXPIRE) {
            PdcFlags |= SAM_MANUAL_PWD_EXPIRY;
        }

        NtStatus = SampPasswordChangeNotifyPdc(PdcFlags,
                                               UserName,
                                               RelativeId,
                                               NewPassword);
    }

    //
    // Restore the thread state
    //
    if ( pTHState ) {

        THRestore( pTHState );

    }

    // Failure return codes from SampPasswordChangeNotifyPdc or from the
    // security packages are treated as benign errors. These errors should
    // should not prevent the password from being changed locally on this
    // DC.

    return(STATUS_SUCCESS);
}

NTSTATUS
SampPasswordChangeFilterWorker(
    IN PUNICODE_STRING FullName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NewPassword,
    IN OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfo OPTIONAL,
    IN BOOLEAN SetOperation
    )
/*++

Routine Description:

    This routine notifies packages of a password change.  It requires that
    the user no longer be locked so that other packages can write to the
    user parameters field.


Arguments:

    FullName - Name of the user

    UserName - User (Account) name
    
    NewPassword - Cleartext new password for the user

    SetOperation - TRUE if the password was SET rather than CHANGED

Return Value:

    Status codes from the notification packages.

--*/
{
    PSAMP_NOTIFICATION_PACKAGE Package;
    NTSTATUS Status;
    BOOLEAN Result;
    
    Package = SampNotificationPackages;

    while (Package != NULL) {
        if ( Package->PasswordFilterRoutine != NULL ) {
            try {
                Result = Package->PasswordFilterRoutine(
                            UserName,
                            FullName,
                            NewPassword,
                            SetOperation
                            );
                if (!Result)
                {
                    Status = STATUS_PASSWORD_RESTRICTION;
                }
            } except (EXCEPTION_EXECUTE_HANDLER) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "Exception thrown in Password Filter Routine: 0x%x (%d)\n",
                           GetExceptionCode(),
                           GetExceptionCode() ));

                //
                // Set result to FALSE so the change fails.
                //

                Status = STATUS_ACCESS_VIOLATION;
                Result = FALSE;
            }

            if (!Result) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "Package %wZ failed to accept password change for user %wZ: 0x%x\n",
                           &Package->PackageName,
                           UserName,
                           Status));

                if (ARGUMENT_PRESENT(PasswordChangeFailureInfo))
                {
                    NTSTATUS    IgnoreStatus;

                    PasswordChangeFailureInfo->ExtendedFailureReason 
                                        = SAM_PWD_CHANGE_FAILED_BY_FILTER;
                    RtlInitUnicodeString(&PasswordChangeFailureInfo->FilterModuleName,
                                         NULL);
                    IgnoreStatus = SampDuplicateUnicodeString(
                                        &PasswordChangeFailureInfo->FilterModuleName,
                                        &Package->PackageName
                                        );
                }

                return(Status);
            }

        }

        Package = Package->Next;


    }
    return(STATUS_SUCCESS);
}

NTSTATUS
SampPasswordChangeFilter(
    IN PSAMP_OBJECT    UserContext,
    IN PUNICODE_STRING NewPassword,
    IN OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfo OPTIONAL,
    IN BOOLEAN SetOperation
    )
/*++

Routine Description:

    This routine notifies packages of a password change.  It requires that
    the user no longer be locked so that other packages can write to the
    user parameters field.


Arguments:

    UserContext - handle to the user object

    NewPassword - Cleartext new password for the user

    SetOperation - TRUE if the password was SET rather than CHANGED

Return Value:

    Status codes from the notification packages.

--*/
{
    UNICODE_STRING FullName;
    UNICODE_STRING UserName;
    NTSTATUS Status;

    //
    // Get the account name and full name to pass
    // to the password filter.
    //

     Status = SampGetUnicodeStringAttribute(
                    UserContext,                 // Context
                    SAMP_USER_ACCOUNT_NAME,  // AttributeIndex
                    FALSE,                   // MakeCopy
                    &UserName                // UnicodeAttribute
                    );

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    Status = SampGetUnicodeStringAttribute(
                    UserContext,              // Context
                    SAMP_USER_FULL_NAME,  // AttributeIndex
                    FALSE,                // MakeCopy
                    &FullName             // UnicodeAttribute
                    );

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    Status = SampPasswordChangeFilterWorker(
                 &FullName,
                 &UserName,
                 NewPassword,
                 PasswordChangeFailureInfo,
                 SetOperation
                 );
    
    return Status;
}

NTSTATUS
SampDeltaChangeNotify(
    IN PSID DomainSid,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PUNICODE_STRING ObjectName,
    IN PLARGE_INTEGER ModifiedCount,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    )
/*++

Routine Description:

    This routine notifies packages of a change to the SAM database.  The
    database is still locked for write access so it requires that nothing
    it calls try to lock the database.

Arguments:

    DomainSid - SID of domain for delta

    DeltaType - Type of delta (change, add ,delete)

    ObjectType - Type of object changed (user, alias, group ...)

    ObjectRid - ID of object changed

    ObjectName - Name of object changed

    ModifiedCount - Serial number of database after this last change

    DeltaData - Data describing the exact modification.

Return Value:

    STATUS_SUCCESS only - errors from packages are ignored.

--*/
{
    PSAMP_NOTIFICATION_PACKAGE Package;
    NTSTATUS NtStatus;

    SAMTRACE("SampDeltaChangeNotify");

    Package = SampNotificationPackages;

    while (Package != NULL) {


        if (Package->DeltaNotificationRoutine != NULL) {
            try {
                NtStatus = Package->DeltaNotificationRoutine(
                                DomainSid,
                                DeltaType,
                                ObjectType,
                                ObjectRid,
                                ObjectName,
                                ModifiedCount,
                                DeltaData
                                );
            } except (EXCEPTION_EXECUTE_HANDLER) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "Exception thrown in Delta Notificateion Routine: 0x%x (%d)\n",
                           GetExceptionCode(),
                           GetExceptionCode()));

                NtStatus = STATUS_ACCESS_VIOLATION;
            }

            if (!NT_SUCCESS(NtStatus)) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "Package %wZ failed to accept deltachange for object %wZ\n",
                           &Package->PackageName,
                           ObjectName));
            }
        }

        Package = Package->Next;


    }
    return(STATUS_SUCCESS);
}



NTSTATUS
SampAbortSingleLoopbackTask(
    IN OUT PVOID * VoidNotifyItem
    )
/*++
Routine Description:

    this routine marks fCommit (of the passed in Loopback Task Item) to FALSE.
    
Parameters:
    
    VoidNotifyItem - pointer to a SAM Loopback task item
    
Return Values:

    STATUS_SUCCESS or STATUS_INVALID_PARAMETER

--*/
{
    PSAMP_LOOPBACK_TASK_ITEM NotifyItem;

    if ( !VoidNotifyItem )
    {
        return STATUS_INVALID_PARAMETER;
    }

    NotifyItem = (PSAMP_LOOPBACK_TASK_ITEM) VoidNotifyItem;

    switch (NotifyItem->Type)
    {
    case SampIncreaseBadPasswordCount:
    case SampNotifyPasswordChange:
    case SampDeleteAccountNameTableElement:
    case SampGenerateLoopbackAudit:
        NotifyItem->fCommit = FALSE;
        break;
    default:
        ASSERT( !"Invalid switch statement" );
        return( STATUS_INVALID_PARAMETER );
    }

    return( STATUS_SUCCESS );
}


NTSTATUS
SampProcessSingleLoopbackTask(
    IN PVOID   *VoidNotifyItem
    )
/*++

Routine Description:

    This rouinte handles the passed in Loopback Task Item. Depends on fCommit 
    in each item's structure, SAM will either ignore it or do the task. 
 

Arguments:

    VoidNotifyItem - pointer to a SAM Loopback task item

Return Value:

    STATUS_SUCCESS only - errors from packages are ignored.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_LOOPBACK_TASK_ITEM NotifyItem;

    if ( !VoidNotifyItem )
    {
        return STATUS_INVALID_PARAMETER;
    }

    NotifyItem = (PSAMP_LOOPBACK_TASK_ITEM) VoidNotifyItem;

    switch ( NotifyItem->Type )
    {
        case SampNotifyPasswordChange:
        {
            PSAMP_PASSWORD_CHANGE_INFO PasswordChangeInfo;

            PasswordChangeInfo = (PSAMP_PASSWORD_CHANGE_INFO)
                                 &(NotifyItem->NotifyInfo.PasswordChange);

            // 
            // process NotifyPasswordChange Task Item ONLY when fCommit if TRUE
            // 
            if ( NotifyItem->fCommit )
            {
                NtStatus = SampPasswordChangeNotifyWorker(
                                                PasswordChangeInfo->Flags,
                                                &PasswordChangeInfo->UserName,
                                                PasswordChangeInfo->RelativeId,
                                                &PasswordChangeInfo->NewPassword
                                                );

                SampDiagPrint( DISPLAY_LOCKOUT,
                             ( "SAMSS: Loopback password notify for %ls (%d) status: 0x%x\n",
                             PasswordChangeInfo->UserName.Buffer,
                             PasswordChangeInfo->RelativeId,
                             NtStatus ));
            }

            if ( PasswordChangeInfo->UserName.Buffer )
            {
                THFree( PasswordChangeInfo->UserName.Buffer );
            }

            if ( PasswordChangeInfo->NewPassword.Buffer )
            {
                RtlSecureZeroMemory(PasswordChangeInfo->NewPassword.Buffer,
                                    PasswordChangeInfo->NewPassword.Length); 
                THFree( PasswordChangeInfo->NewPassword.Buffer );
            }
        }
        break;

        case SampIncreaseBadPasswordCount:
        {
            PSAMP_BAD_PASSWORD_COUNT_INFO   BadPwdCountInfo = NULL;

            BadPwdCountInfo = (PSAMP_BAD_PASSWORD_COUNT_INFO)
                                &(NotifyItem->NotifyInfo.BadPasswordCount);

            //
            // Always Increase Bad Password Count no matter commit or not.
            // 

            NtStatus = SampIncreaseBadPwdCountLoopback(
                                &(BadPwdCountInfo->UserName)
                                );

            //
            // Note: 
            // We don't sleep 3 second to prevent dictionary attacks. 
            // that is due to limited # of ATQ threads in ldap. 
            // If the thread doesn't return asap, then we will block
            // other ldap client. 
            // 

            if (BadPwdCountInfo->UserName.Buffer)
            {
                THFree( BadPwdCountInfo->UserName.Buffer );
                BadPwdCountInfo->UserName.Buffer = NULL;
            }
        }
        break;

        case SampDeleteAccountNameTableElement:
        {
            PSAMP_ACCOUNT_INFO      AccountInfo = NULL;

            AccountInfo = (PSAMP_ACCOUNT_INFO)
                            &(NotifyItem->NotifyInfo.Account);

            NtStatus = SampDeleteElementFromAccountNameTable(
                            &(AccountInfo->AccountName),
                            AccountInfo->ObjectType
                            );

            if (AccountInfo->AccountName.Buffer)
            {
                THFree( AccountInfo->AccountName.Buffer );
                AccountInfo->AccountName.Buffer = NULL;
            }
                        
        }
        break;

        //
        // See samaudit.c file header for information on the SAM auditing model.
        //
        
        case SampGenerateLoopbackAudit:
        {
            PSAMP_AUDIT_INFO    AuditInfo = NULL;

            AuditInfo = (PSAMP_AUDIT_INFO)
                            &(NotifyItem->NotifyInfo.AuditInfo);

            if ( NotifyItem->fCommit )
            {
                //
                // Audit this SAM event only if the 
                // transaction was committed
                // 

                LsaIAuditSamEvent(AuditInfo->NtStatus,
                                  AuditInfo->AuditId,
                                  AuditInfo->DomainSid,
                                  AuditInfo->AdditionalInfo,
                                  AuditInfo->MemberRid,
                                  AuditInfo->MemberSid,
                                  AuditInfo->AccountName,
                                  AuditInfo->DomainName,
                                  AuditInfo->AccountRid,
                                  AuditInfo->Privileges,
                                  NULL                      // extended info
                                  );
            }

            //
            // Free memory
            //

            SampFreeLoopbackAuditInfo(AuditInfo);
        }
        break;

        default:
            ASSERT( !"Invalid switch statement" );
            NtStatus =  STATUS_INVALID_PARAMETER;
    }


    THFree( NotifyItem );

    return NtStatus;
}


NTSTATUS
SampPrivatePasswordUpdate(
    SAMPR_HANDLE     DomainHandle,
    ULONG            Flags,
    ULONG            AccountRid,
    PLM_OWF_PASSWORD LmOwfPassword,
    PNT_OWF_PASSWORD NtOwfPassword,
    BOOLEAN          PasswordExpired
    )
/*++

Routine Description:

    This routine writes the passwords to the user's account without
    updating the password history

    It will also set if the password is expired or if the account has
    become unlocked.

Arguments:

    DomainHandle : the handle of the domain of AccountRid

    AccountRid : the account to apply the change

    LmOwfPassword : non-NULL pointer to the lm password

    NtOwfPassword : non-NULL pointer to the nt password

    PasswordExpired : is the password expired
    
Return Value:

    STATUS_SUCCESS if the password was successfully set

--*/
{
    NTSTATUS NtStatus  = STATUS_SUCCESS;
    BOOLEAN  fLockHeld = FALSE;
    BOOLEAN  fCommit   = FALSE;
    BOOLEAN  fDerefDomain = FALSE;

    PSAMP_OBJECT        AccountContext = 0;
    PSAMP_OBJECT        DomainContext = 0;
    SAMP_OBJECT_TYPE    FoundType;

    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;

    ASSERT( NULL != DomainHandle );

    //
    // Grab lock
    //
    NtStatus = SampAcquireWriteLock();
    if ( !NT_SUCCESS( NtStatus ) )
    {
        SampDiagPrint( DISPLAY_LOCKOUT,
                     ( "SAMSS: SampAcquireWriteLock returned 0x%x\n",
                      NtStatus ));

        goto Cleanup;
    }
    fLockHeld = TRUE;

    //
    // Reference the domain so SampCreateAccountContext has the correct
    // transactional domain.
    //
    DomainContext = (PSAMP_OBJECT)DomainHandle;
    NtStatus = SampLookupContext(
                   DomainContext,
                   0,                   // DesiredAccess
                   SampDomainObjectType,            // ExpectedType
                   &FoundType
                   );
    if ( !NT_SUCCESS( NtStatus ) )
    {
        SampDiagPrint( DISPLAY_LOCKOUT,
                     ( "SAMSS: SampLookupContext returned 0x%x\n",
                      NtStatus ));

        goto Cleanup;
    }
    fDerefDomain = TRUE;

    //
    // Create a context
    //
    NtStatus = SampCreateAccountContext( SampUserObjectType,
                                         AccountRid,
                                         TRUE,  // trusted client
                                         FALSE, // loopback
                                         TRUE,  // account exists
                                         &AccountContext );

    if ( !NT_SUCCESS( NtStatus ) )
    {
        SampDiagPrint( DISPLAY_LOCKOUT,
                ( "SAMSS: SampCreateAccountContext for rid 0x%x returned 0x%x\n",
                      AccountRid, NtStatus ));

        goto Cleanup;
    }

    SampReferenceContext( AccountContext );


    if (Flags & SAM_NT_OWF_PRESENT) {

        BOOLEAN FreeRandomizedPasswordIgnored;
        DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;

        NtStatus = SampObtainEffectivePasswordPolicy(&DomainPasswordInfo,
                                                     AccountContext,
                                                     TRUE);

        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }

        //
        // Store the passwords
        //
        NtStatus = SampStoreUserPasswords( AccountContext,
                                           LmOwfPassword,
                                           (Flags & SAM_LM_OWF_PRESENT) ? TRUE : FALSE,
                                           NtOwfPassword,
                                           TRUE,   // NtOwfPassword present
                                           FALSE,  // don't check password restrictions
                                           PasswordPushPdc,
                                           &DomainPasswordInfo,
                                           NULL,
                                           NULL,
                                           NULL,
                                           NULL
                                           );
    
        if ( !NT_SUCCESS( NtStatus ) )
        {
            SampDiagPrint( DISPLAY_LOCKOUT,
                         ( "SAMSS: SampStoreUserPasswords returned 0x%x\n",
                          NtStatus ));
    
            goto Cleanup;
        }
    }

    //
    // Set the password last set
    //
    if ((Flags & SAM_NT_OWF_PRESENT)
     || (Flags & SAM_MANUAL_PWD_EXPIRY)  ) {
        NtStatus = SampRetrieveUserV1aFixed( AccountContext,
                                             &V1aFixed );
    
        if ( NT_SUCCESS( NtStatus ) ) {
        
            NtStatus = SampComputePasswordExpired(PasswordExpired,
                                                  &V1aFixed.PasswordLastSet);
    
            if (NT_SUCCESS(NtStatus)) {
    
                NtStatus = SampReplaceUserV1aFixed( AccountContext,
                                                   &V1aFixed );
            }
        }

        if ( !NT_SUCCESS( NtStatus ) )
        {
            SampDiagPrint( DISPLAY_LOCKOUT,
                         ( "SAMSS: Setting the last time returned 0x%x\n",
                          NtStatus ));
    
            goto Cleanup;
        }
    }

    //
    // Finally see if we need to unlock the account
    //
    if (Flags & SAM_ACCOUNT_UNLOCKED) {

        RtlSecureZeroMemory(&AccountContext->TypeBody.User.LockoutTime,sizeof(LARGE_INTEGER) );
        
        NtStatus = SampDsUpdateLockoutTimeEx(AccountContext, FALSE);

        if ( !NT_SUCCESS( NtStatus ) )
        {
            SampDiagPrint( DISPLAY_LOCKOUT,
                         ( "SAMSS: Setting the last time returned 0x%x\n",
                          NtStatus ));
    
            goto Cleanup;
        }
    }

    fCommit = TRUE;

    //
    //  That's it; fall through to cleanup
    //

Cleanup:

    if ( AccountContext )
    {
        //
        //  Dereference the context to make the changes
        //
        NtStatus = SampDeReferenceContext( AccountContext, fCommit );
        if ( !NT_SUCCESS( NtStatus ) )
        {
            SampDiagPrint( DISPLAY_LOCKOUT,
                         ( "SAMSS: SampDeReferenceContext returned 0x%x\n",
                          NtStatus ));

            if ( fCommit )
            {
                // Since we couldn't write the changes, don't commit
                // the transaction
                fCommit = FALSE;
            }
        }

        SampDeleteContext( AccountContext );
        AccountContext = 0;
    }

    if ( fDerefDomain )
    {
        SampDeReferenceContext( DomainContext, FALSE );
    }

    if ( fLockHeld )
    {
        SampReleaseWriteLock( fCommit );
        fLockHeld = FALSE;
    }


    SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                   (SAMP_LOG_ACCOUNT_LOCKOUT,
                   "UserId: 0x%x  PDC update, Password=%s, Expire=%s, Unlock=%s  (status 0x%x)\n",
                   AccountRid, 
                   (Flags & SAM_NT_OWF_PRESENT ? "TRUE" : "FALSE"),
                   (PasswordExpired ? "TRUE" : "FALSE"),
                   ((Flags & SAM_ACCOUNT_UNLOCKED) ? "TRUE" : "FALSE"),
                   NtStatus));

    return NtStatus;

}


VOID
SampAddLoopbackTaskForBadPasswordCount(
    IN PUNICODE_STRING AccountName
    )
/*++
Routine Description:

    This routine adds a work item (increment Bad Password Count) 
    into the SAM Loopback tasks. Also this routine stores all necessary
    informatin (AccountName). The reasons why we have to add a task item
    into loopback tasks are: 
    
    1) sleep 3 seconds after releasing SAM lock. 
    2) open a new transaction after Changing Password transaction aborted, 
       if we increase bad password count in the same transaction as 
       changing password. Everything will be aborted. So we have to do it
       in a separate transaction, but still in the same thread 
       (synchronously). 

Arguments:

    AccountName - User Account Name.

Return Values:

    none.

--*/
{
    PSAMP_LOOPBACK_TASK_ITEM    Item = NULL;
    WCHAR   *Temp = NULL;

    SAMTRACE("SampAddLoopbackTaskForBadPasswordCount");


    ASSERT(SampUseDsData);

    Item = THAlloc( sizeof( SAMP_LOOPBACK_TASK_ITEM ) );
    if (Item)
    {
        RtlSecureZeroMemory(Item, sizeof( SAMP_LOOPBACK_TASK_ITEM ));

        Temp = THAlloc( AccountName->MaximumLength );

        if (Temp)
        {
            Item->NotifyInfo.BadPasswordCount.UserName.Buffer = Temp;
            Item->NotifyInfo.BadPasswordCount.UserName.Length = 0;
            Item->NotifyInfo.BadPasswordCount.UserName.MaximumLength = 
                                     AccountName->MaximumLength;

            //
            // copy the account name
            // 
            RtlCopyUnicodeString( &(Item->NotifyInfo.BadPasswordCount.UserName), 
                                  AccountName);

            Item->Type = SampIncreaseBadPasswordCount;
            Item->fCommit = TRUE;

            // 
            // add to the thread state
            // 
            SampAddLoopbackTask( Item );
        }
    }

    return;
}

NTSTATUS
SampAddLoopbackTaskDeleteTableElement(
    IN PUNICODE_STRING AccountName,
    IN SAMP_OBJECT_TYPE ObjectType
    )
{
    PSAMP_LOOPBACK_TASK_ITEM    Item = NULL;
    WCHAR   *Temp = NULL;

    SAMTRACE("SampAddLoopbackTaskDeleteTableElement");

    Item = THAlloc( sizeof( SAMP_LOOPBACK_TASK_ITEM ) );

    if (Item)
    {
        RtlSecureZeroMemory(Item, sizeof(SAMP_LOOPBACK_TASK_ITEM));

        Temp = THAlloc( AccountName->MaximumLength );

        if (Temp)
        {
            Item->NotifyInfo.Account.AccountName.Buffer = Temp;
            Item->NotifyInfo.Account.AccountName.Length = 0;
            Item->NotifyInfo.Account.AccountName.MaximumLength = 
                                AccountName->MaximumLength;

            Item->NotifyInfo.Account.ObjectType = ObjectType;

            //
            // copy the account name
            // 
            RtlCopyUnicodeString( &(Item->NotifyInfo.Account.AccountName), 
                                  AccountName );

            Item->Type = SampDeleteAccountNameTableElement;
            Item->fCommit = TRUE;

            //
            // Add to the thread state
            // 
            if ( !SampAddLoopbackTask(Item) )
            {
                return( STATUS_INTERNAL_ERROR );
            }
        }
        else
        {
            return( STATUS_INSUFFICIENT_RESOURCES );
        }
    }
    else
    {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    return( STATUS_SUCCESS );
}

NTSTATUS
SampIncreaseBadPwdCountLoopback(
    IN PUNICODE_STRING  UserName
    )
/*++
Routine Description:

Parameters:

Return Values:



--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    NTSTATUS        IgnoreStatus = STATUS_SUCCESS;
    SAMPR_HANDLE    UserHandle = NULL;
    PSAMP_OBJECT    AccountContext = NULL;
    BOOLEAN         AccountLockedOut;
    SAMP_OBJECT_TYPE FoundType;
    SAMP_V1_0A_FIXED_LENGTH_USER    V1aFixed;
    PVOID           *pTHState = NULL;
    BOOLEAN         fLockAcquired = FALSE;

    SAMTRACE("SampIncreaseBadPwdCountLoopback");

    //
    // Suspend the thread state
    // 
    if ( SampUseDsData && THQuery() )
    {
        pTHState = THSave();
        ASSERT( pTHState );
    }

    //
    // The lock should not be held
    // 
    ASSERT( !SampCurrentThreadOwnsLock() );

    //
    // Open the User
    // 

    NtStatus = SampOpenUserInServer(UserName, 
                                    TRUE,       // Unicode String, not OEM
                                    TRUE,       // TrustedClient
                                    &UserHandle
                                    );
                    
    if (!NT_SUCCESS(NtStatus)) {
        goto RestoreAndLeave;
    }

    //
    // Grab the lock
    // 

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        goto RestoreAndLeave;
    }
    fLockAcquired = TRUE;

    //
    // Validate type of, and access to object.
    // 

    AccountContext = (PSAMP_OBJECT) UserHandle;

    NtStatus = SampLookupContext(AccountContext, 
                                 USER_CHANGE_PASSWORD,
                                 SampUserObjectType,
                                 &FoundType
                                 );

    if (!NT_SUCCESS(NtStatus)) {
        goto RestoreAndLeave;
    }

    //
    // Get the V1aFixed so we can update the bad password count
    // 

    NtStatus = SampRetrieveUserV1aFixed(AccountContext, 
                                        &V1aFixed
                                        );

    if (NT_SUCCESS(NtStatus)) 
    {

        //
        // Increment BadPasswordCount (might lockout account)
        // 

        AccountLockedOut = SampIncrementBadPasswordCount(
                               AccountContext,
                               &V1aFixed,
                               NULL
                               );

        //
        // update V1aFixed 
        //      

        NtStatus = SampReplaceUserV1aFixed(AccountContext, 
                                           &V1aFixed
                                           );

    }

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = SampDeReferenceContext( AccountContext, TRUE );

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampCommitAndRetainWriteLock();
        }
    }
    else
    {
        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

RestoreAndLeave:
    //
    // Release the write lock if necessary
    // 
    if (fLockAcquired)
    {
        IgnoreStatus = SampReleaseWriteLock( FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    if (UserHandle) 
    {
        SamrCloseHandle(&UserHandle);
    }

    ASSERT(!SampExistsDsTransaction());

    if ( pTHState )
    {
        THRestore( pTHState );
    }

    //
    // The lock should be released
    // 
    ASSERT( !SampCurrentThreadOwnsLock() );

    return( NtStatus );
}


NTSTATUS
SampLoopbackTaskDupSid(
    PSID    *ppSid,
    PSID    sourceSid OPTIONAL
    )
{
    PSID       Temp = NULL;
    ULONG       Length;

    *ppSid = NULL;

    if (!ARGUMENT_PRESENT(sourceSid))
        return(STATUS_SUCCESS);

    Length = RtlLengthSid(sourceSid);

    Temp = THAlloc(Length);
    if (!Temp)
        return(STATUS_INSUFFICIENT_RESOURCES);

    RtlSecureZeroMemory(Temp, Length);
    RtlCopyMemory(Temp, sourceSid, Length);

    *ppSid = Temp;

    return(STATUS_SUCCESS);
}


NTSTATUS
SampLoopbackTaskDupUlong(
    PULONG  *ppULong,
    PULONG  sourceUlong OPTIONAL
    )
{
    PULONG   Temp = NULL;

    *ppULong = NULL;

    if (!ARGUMENT_PRESENT(sourceUlong))
        return(STATUS_SUCCESS);

    Temp = THAlloc(sizeof(ULONG));
    if (!Temp)
        return(STATUS_INSUFFICIENT_RESOURCES);


    *Temp = *sourceUlong;
    *ppULong = Temp;

    return(STATUS_SUCCESS);
}

NTSTATUS
SampLoopbackTaskDupUnicodeString(
    PUNICODE_STRING *ppUnicodeString,
    PUNICODE_STRING sourceUnicodeString OPTIONAL
    )
{
    PUNICODE_STRING   Temp = NULL;
    PWSTR   Buffer = NULL;

    *ppUnicodeString = NULL;

    if (!ARGUMENT_PRESENT(sourceUnicodeString))
        return(STATUS_SUCCESS);

    Temp = THAlloc(sizeof(UNICODE_STRING));
    if (!Temp)
        return(STATUS_INSUFFICIENT_RESOURCES);

    RtlSecureZeroMemory(Temp, sizeof(UNICODE_STRING));

    Buffer = THAlloc(sourceUnicodeString->Length);
    if (!Buffer)
    {
        THFree(Temp);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    RtlSecureZeroMemory(Buffer, sourceUnicodeString->Length);
    RtlCopyMemory(Buffer, 
                  sourceUnicodeString->Buffer, 
                  sourceUnicodeString->Length);

    Temp->Buffer = Buffer;
    Temp->Length = sourceUnicodeString->Length;
    Temp->MaximumLength = sourceUnicodeString->MaximumLength;

    *ppUnicodeString = Temp;

    return(STATUS_SUCCESS);
}

NTSTATUS
SampLoopbackTaskDupPrivileges(
    PPRIVILEGE_SET  *ppPrivileges,
    PPRIVILEGE_SET sourcePrivileges OPTIONAL
    )
{
    ULONG   Length = 0;
    PPRIVILEGE_SET  Temp = NULL;

    *ppPrivileges = NULL;

    if (!ARGUMENT_PRESENT(sourcePrivileges))
        return( STATUS_SUCCESS );

    Length = sizeof(PRIVILEGE_SET) + 
             sourcePrivileges->PrivilegeCount * sizeof(LUID_AND_ATTRIBUTES);

    Temp = THAlloc(Length);
    if (!Temp)
        return(STATUS_INSUFFICIENT_RESOURCES);

    RtlSecureZeroMemory(Temp, Length);
    RtlCopyMemory(Temp, sourcePrivileges, Length);
    

    *ppPrivileges = Temp;

    return( STATUS_SUCCESS );
}

VOID
SampFreeLoopbackAuditInfo(
    PSAMP_AUDIT_INFO    AuditInfo
    )
{
    if (AuditInfo)
    {
        if (AuditInfo->DomainSid)
        {
            THFree(AuditInfo->DomainSid);
            AuditInfo->DomainSid = NULL;
        }

        if (AuditInfo->AdditionalInfo)
        {
            if (AuditInfo->AdditionalInfo->Buffer)
            {
                THFree(AuditInfo->AdditionalInfo->Buffer);
                AuditInfo->AdditionalInfo->Buffer = NULL;
            }
            THFree(AuditInfo->AdditionalInfo);
            AuditInfo->AdditionalInfo = NULL;
        }

        if (AuditInfo->MemberRid)
        {
            THFree(AuditInfo->MemberRid);
            AuditInfo->MemberRid = NULL;
        }

        if (AuditInfo->MemberSid)
        {
            THFree(AuditInfo->MemberSid);
            AuditInfo->MemberSid = NULL;
        }

        if (AuditInfo->AccountName)
        {
            if (AuditInfo->AccountName->Buffer)
            {
                THFree(AuditInfo->AccountName->Buffer);
                AuditInfo->AccountName->Buffer = NULL;
            }
            THFree(AuditInfo->AccountName);
            AuditInfo->AccountName = NULL;
        }

        if (AuditInfo->DomainName)
        {
            if (AuditInfo->DomainName->Buffer)
            {
                THFree(AuditInfo->DomainName->Buffer);
                AuditInfo->DomainName->Buffer = NULL;
            }
            THFree(AuditInfo->DomainName);
            AuditInfo->DomainName = NULL;
        }

        if (AuditInfo->AccountRid)
        {
            THFree(AuditInfo->AccountRid);
            AuditInfo->AccountRid = NULL;
        }

        if (AuditInfo->Privileges)
        {
            THFree(AuditInfo->Privileges);
            AuditInfo->Privileges = NULL;
        }

        RtlSecureZeroMemory(AuditInfo, sizeof(SAMP_AUDIT_INFO));

    }
}


NTSTATUS
SampAddLoopbackTaskForAuditing(
    IN NTSTATUS             PassedStatus,
    IN ULONG                AuditId,
    IN PSID                 DomainSid,
    IN PUNICODE_STRING      AdditionalInfo    OPTIONAL,
    IN PULONG               MemberRid         OPTIONAL,
    IN PSID                 MemberSid         OPTIONAL,
    IN PUNICODE_STRING      AccountName       OPTIONAL,
    IN PUNICODE_STRING      DomainName,
    IN PULONG               AccountRid        OPTIONAL,
    IN PPRIVILEGE_SET       Privileges        OPTIONAL,
    IN PVOID                AlteredState      OPTIONAL
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSAMP_LOOPBACK_TASK_ITEM    Item = NULL;
    WCHAR       *Temp = NULL;
    ULONG       Length;
    

    Item = THAlloc( sizeof(SAMP_LOOPBACK_TASK_ITEM) );

    if (Item)
    {
        RtlSecureZeroMemory(Item, sizeof(SAMP_LOOPBACK_TASK_ITEM));

        Item->fCommit = TRUE;

        Item->Type = SampGenerateLoopbackAudit;

        Item->NotifyInfo.AuditInfo.NtStatus = PassedStatus;

        Item->NotifyInfo.AuditInfo.AuditId = AuditId;

        ASSERT(NULL!=DomainSid);
        NtStatus = SampLoopbackTaskDupSid(
                        &(Item->NotifyInfo.AuditInfo.DomainSid),
                        DomainSid
                        );
        if (!NT_SUCCESS(NtStatus))
            goto Error;


        NtStatus = SampLoopbackTaskDupUnicodeString(
                        &(Item->NotifyInfo.AuditInfo.AdditionalInfo),
                        AdditionalInfo
                        );
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        NtStatus = SampLoopbackTaskDupUlong(
                        &(Item->NotifyInfo.AuditInfo.MemberRid),
                        MemberRid
                        );
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        NtStatus = SampLoopbackTaskDupSid(
                        &(Item->NotifyInfo.AuditInfo.MemberSid),
                        MemberSid
                        );
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        NtStatus = SampLoopbackTaskDupUnicodeString(
                        &(Item->NotifyInfo.AuditInfo.AccountName),
                        AccountName
                        );
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        ASSERT(NULL != DomainName);
        NtStatus = SampLoopbackTaskDupUnicodeString(
                        &(Item->NotifyInfo.AuditInfo.DomainName),
                        DomainName
                        );
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        NtStatus = SampLoopbackTaskDupUlong(
                        &(Item->NotifyInfo.AuditInfo.AccountRid),
                        AccountRid
                        );
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        NtStatus = SampLoopbackTaskDupPrivileges(
                        &(Item->NotifyInfo.AuditInfo.Privileges),
                        Privileges
                        );

        if (!NT_SUCCESS(NtStatus))
            goto Error;
        
        Item->NotifyInfo.AuditInfo.AlteredState = AlteredState;
        
        
        //
        // Add to the thread state
        // 
        if ( !SampAddLoopbackTask(Item) )
        {
            NtStatus = STATUS_INTERNAL_ERROR;
        }
    }
    else
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

Error:

    if (!NT_SUCCESS(NtStatus) && Item)
    {
        SampFreeLoopbackAuditInfo(&(Item->NotifyInfo.AuditInfo));
        THFree(Item);
    }

    return( NtStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\nametbl.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    nametbl.c

Abstract:

    This file contains routines to manage SAM Account Name Table

    SAM Account Name Table is used to maintain SAM Account Name Uniqueness.
    The way it works is described as follows. 
    
    We will use SAM AccountNameTable to store the AccountNames which are 
    picked up by those non-committed threads. When a client wants to create a 
    new SAM account with name A, SAM server should first scan AccountNameTable, 
    to see whether name A has been in the table already or not yet. 
    If name A has been in AccountNameTable already, that means the this 
    particular account Name has been used by another client, even the other 
    client doesn't commit yet. Then SAM returns STATUS_USER_EXISTS (or 
    STATUS_GROUP_EXISTS respectly) immediately. Otherwise if the account name 
    is not in the table, we will insert Name A into the AccountNameTable. 
    Then continue to do a DS Search based on the new AccountName ( Name A )
    against the DS database. 

    Once we have done with the account creation, either succeed or fail for
    some reason, SAM needs to remove the account name from AccountNameTable
    if necessary.

    1. The above scheme works in both loopback case and down-level APIs.
    
    2. SAM Account Name Table is only being used in DS case

    3. The AccountNameTable should be protected by a critical section to 
       serialize all in-memory operation.  The actual implementation will use 
       RtlGenericTable2. 


Author:

    Shaohua Yin    (ShaoYin)  01-March-2000

Environment:

    User Mode - Win32

Revision History:

    01-March-2000: SHAOYIN  Create init file


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dsutilp.h>
#include <dslayer.h>
#include <dsmember.h>
#include <attids.h>
#include <mappings.h>
#include <ntlsa.h>
#include <nlrepl.h>
#include <dsevent.h>             // (Un)ImpersonateAnyClient()
#include <sdconvrt.h>
#include <ridmgr.h>
#include <malloc.h>
#include <setupapi.h>
#include <crypt.h>
#include <wxlpc.h>
#include <rc4.h>
#include <md5.h>
#include <enckey.h>
#include <rng.h>





PVOID
SampAccountNameTableAllocate(
    ULONG   BufferSize
    )
/*++
Routine Description:

    This routine is used by RtlGenericTable2 to allocate memory
    
Parameters:

    BufferSize
    
Return Value:

    Address of the allocated memory        
--*/
{
    PVOID   Buffer = NULL;

    Buffer = MIDL_user_allocate(BufferSize);

    return( Buffer );
}

VOID
SampAccountNameTableFree(
    PVOID   Buffer
    )
/*++

Routine Description:

    RtlGenericTable2 memory release routine

--*/
{
    MIDL_user_free(Buffer);

    return;
}


RTL_GENERIC_COMPARE_RESULTS
SampAccountNameTableCompare(
    PVOID   Node1,
    PVOID   Node2
    )
/*++

Routine Description:

    RtlGenericTable2 node comparsion routine
    
Parameters:

    Node1 - pointer to the first element 
    
    Node2 - pointer the the second element to compare

Return Value:

    GenericGreaterThan
    GenericLessThan
    GenericEqual    

--*/
{
    PUNICODE_STRING AccountName1 = NULL;
    PUNICODE_STRING AccountName2 = NULL;
    LONG    NameComparison;

    AccountName1 = (PUNICODE_STRING) 
                    &(((SAMP_ACCOUNT_NAME_TABLE_ELEMENT *)Node1)->AccountName);
    AccountName2 = (PUNICODE_STRING) 
                    &(((SAMP_ACCOUNT_NAME_TABLE_ELEMENT *)Node2)->AccountName);

    NameComparison = SampCompareDisplayStrings(AccountName1, 
                                               AccountName2, 
                                               TRUE
                                               );

    if (NameComparison > 0) {
        return(GenericGreaterThan);
    }

    if (NameComparison < 0) {
        return(GenericLessThan);
    }

    return(GenericEqual);

}



NTSTATUS
SampInitializeAccountNameTable(
    )
/*++
Routine Description:

    This routine initializes the SAM AccountNameTable
    
    1. Initialize Critical Section
    
    2. Initialize AccountNameTable

Parameter:

    None
    
Return Value:

    NTSTATUS Code    

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    NTSTATUS    IgnoreStatus = STATUS_SUCCESS;

    SampAccountNameTableCritSect = &SampAccountNameTableCriticalSection;

    __try
    {
        NtStatus = RtlInitializeCriticalSectionAndSpinCount(
                        SampAccountNameTableCritSect,
                        100
                        );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        return( NtStatus );
    }

    IgnoreStatus = RtlEnterCriticalSection( SampAccountNameTableCritSect );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    RtlInitializeGenericTable2(
                &SampAccountNameTable, 
                SampAccountNameTableCompare, 
                SampAccountNameTableAllocate,
                SampAccountNameTableFree
                );

    IgnoreStatus = RtlLeaveCriticalSection( SampAccountNameTableCritSect );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    return( NtStatus );
}


NTSTATUS
SampDeleteElementFromAccountNameTable(
    IN PUNICODE_STRING AccountName,
    IN SAMP_OBJECT_TYPE ObjectType
    )
/*++

Routine Description:

    This routine deletes an element from the SAMAccountNameTable based upon
    the account name. So find the element first based on the account name, 
    then remove it. Don't forget to release memory.    

    
Parameters:

    AccountName -- AccountName of the element to remove     

    ObjectType -- Object Type of the element to remove

Return Value:
    
    NTSTATUS Code    

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    BOOLEAN     Success = FALSE;


    NtStatus = RtlEnterCriticalSection( SampAccountNameTableCritSect );
    ASSERT(NT_SUCCESS(NtStatus));

    if (!NT_SUCCESS(NtStatus))
    {
        return(NtStatus);
    }

    __try
    {
        SAMP_ACCOUNT_NAME_TABLE_ELEMENT Element;
        SAMP_ACCOUNT_NAME_TABLE_ELEMENT *TempElement = NULL;

        //
        // fill the Element need to be looked up
        // 
        Element.AccountName.Length = AccountName->Length;
        Element.AccountName.Buffer = AccountName->Buffer;
        Element.AccountName.MaximumLength = AccountName->MaximumLength;
        Element.ObjectType = ObjectType;

        //
        // Lookup the AccountName in table
        // 
        TempElement = RtlLookupElementGenericTable2(
                            &SampAccountNameTable,
                            &Element
                            );
        ASSERT(TempElement && "Account Name is not in the AccountNameTable");

        if (TempElement)
        {
            //
            // We got the Account Name, it should match the object type
            // 
            ASSERT(ObjectType == TempElement->ObjectType);

            //
            // go ahead remove the element from the table
            // 
            Success = RtlDeleteElementGenericTable2(
                            &SampAccountNameTable,
                            &Element 
                            );
            ASSERT(Success);
            
            //
            // free memory
            // 
            MIDL_user_free(TempElement->AccountName.Buffer);
            MIDL_user_free(TempElement);
        }
    }
    __finally
    {
        RtlLeaveCriticalSection( SampAccountNameTableCritSect );
    }

    return(NtStatus);
}



NTSTATUS
SampCheckAccountNameTable(
    IN PSAMP_OBJECT    Context,
    IN PUNICODE_STRING AccountName,
    IN SAMP_OBJECT_TYPE ObjectType
    )
/*++

Routine Description:

    This routines checks the existence of the AccountName against the 
    SAMAccountNameTable by inserting the AccountName into the table. 

    if the insertion succeeded, that means no duplicate AccountName 
    in the table, return success after registrying "remove account name
    from table" task. 
    
    if the insertion failed, then lookup the duplicate element, get it's
    object type, return error code based upon the object type. 
    
    Explanation about "remove account name from table" task. Once this 
    routine inserts the AccountName into the table, we have to remember
    to clean it up once we finish this transaction no matter the 
    transaction is committed or aborted. 
        

Paramenters:

    Context - Object Context
    
    AccountName - Account Name of the target object
    
    ObjectType - Object Type of the target object 

Return Values:

    NTSTATUS Code

    STATUS_SUCCESS
    STATUS_USER_EXISTS
    STATUS_GROUP_EXISTS
    STATUS_ALIAS_EXISTS
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    BOOLEAN     fNewElement = FALSE;
    BOOLEAN     Success = FALSE;
    SAMP_ACCOUNT_NAME_TABLE_ELEMENT *Element = NULL;
    PVOID       ReturnElement = NULL;

    //
    // allocate memory
    // 
    Element = MIDL_user_allocate(sizeof(SAMP_ACCOUNT_NAME_TABLE_ELEMENT));
    
    if (NULL == Element)
    {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }
    RtlZeroMemory(Element, sizeof(SAMP_ACCOUNT_NAME_TABLE_ELEMENT));

    //
    // dup the account name
    // 
    NtStatus = SampDuplicateUnicodeString(&(Element->AccountName), 
                                          AccountName
                                          );
    
    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // Set the object Type
    // 
    Element->ObjectType = ObjectType;


    // 
    // enter critical section
    // 
    NtStatus = RtlEnterCriticalSection( SampAccountNameTableCritSect );
    ASSERT(NT_SUCCESS(NtStatus));

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    __try {

        ReturnElement = RtlInsertElementGenericTable2(
                            &SampAccountNameTable, 
                            Element,
                            &fNewElement
                            );

        // 
        // leave now if insertion failed
        // 
        if (NULL == ReturnElement)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
        }



        if (!fNewElement)
        {
            //
            // A duplicate Account Name already exists in the table
            // 

            switch ( ((SAMP_ACCOUNT_NAME_TABLE_ELEMENT *)ReturnElement)->ObjectType )
            {
            case SampUserObjectType:

                NtStatus = STATUS_USER_EXISTS;
                break;

            case SampGroupObjectType:

                NtStatus = STATUS_GROUP_EXISTS;
                break;

            case SampAliasObjectType:

                NtStatus = STATUS_ALIAS_EXISTS;
                break;

            default:

                ASSERT(FALSE && "Wrong Object Type in Account Name Table");
                NtStatus = STATUS_USER_EXISTS;
            }
        }
        else
        {
            //
            // the new Account Name has been successfully inserted 
            // into the table. so the value of fNewElement is TRUE.
            // Also, we need to ensure that the entry (referenced 
            // by the table) is not modified or deallocated while 
            // it is still in the table. (Ensure this by setting 
            // pointer to the entry to NULL -- set value of Element to NULL)
            // 

            if (Context->LoopbackClient)
            {
                //
                // Loopback clients need to remove the account name
                // from the table when they either commit or abort 
                // the DS transaction. 
                // The caller of this routine should do the job
                //

                NtStatus = SampAddLoopbackTaskDeleteTableElement(
                                AccountName, 
                                ObjectType
                                );

                if (!NT_SUCCESS(NtStatus))
                {
                    //
                    // if failed to add the deletion task to Loopback 
                    // task queue. We need to remove the account name 
                    // from the table now.
                    // 

                    Success = RtlDeleteElementGenericTable2(
                                    &SampAccountNameTable,
                                    Element
                                    );
                    ASSERT(Success);
                }
                else
                {
                    // do not deallocated the memory still referenced by the table
                    Element = NULL;
                }
            }
            else
            {
                // 
                // Mark the variable in Context to TRUE, so that
                // the caller will remove the name from table 
                // before exit.
                //  
                Context->RemoveAccountNameFromTable = TRUE;

                // 
                // do not deallocated the memory still referenced by the table
                // 
                Element = NULL;
            }
        }
    }
    __finally
    {
        RtlLeaveCriticalSection( SampAccountNameTableCritSect );
    }

Cleanup:

    //
    // free memory only if the Element is not inserted into the table
    // 

    if ( NULL != Element )
    {
        if (NULL != Element->AccountName.Buffer)
        {
            MIDL_user_free(Element->AccountName.Buffer);
            Element->AccountName.Buffer = NULL;
        }

        MIDL_user_free(Element);
        Element = NULL;
    }

    return( NtStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\lsathunk.h ===
/*++

lsathunk.h

Header file for the thunk layer for accessing the LSA through the 
published NTLSAPI when SAM runs in user mode. User mode SAM is acomplished
by building with USER_MODE_SAM enabled. This causes all the SAM calls to
the LSA be remoted through the published NTLSAPI.

Author: Murlis 4/30/96

Revision History
   Murlis 4/30/96  
        Created

--*/

#ifndef	_LSATHUNK_
#define _LSATHUNK_

#ifdef USER_MODE_SAM


#define LSAPR_HANDLE      LSA_HANDLE
#define PLSAPR_HANDLE     PLSA_HANDLE
// Why is this void'ed?
// #define PLSAPR_POLICY_INFORMATION       PVOID

//++ Function prototypes for the Thunk Layer.

NTSTATUS	LsaThunkIAuditSamEvent(
						IN NTSTATUS             PassedStatus,
						IN ULONG                AuditId,
						IN PSID                 DomainSid,
						IN PULONG               MemberRid         OPTIONAL,
						IN PSID                 MemberSid         OPTIONAL,
						IN PUNICODE_STRING      AccountName       OPTIONAL,
						IN PUNICODE_STRING      DomainName,
						IN PULONG               AccountRid        OPTIONAL,
						IN PPRIVILEGE_SET       Privileges        OPTIONAL,
						IN PVOID                ExtendedInfo      OPTIONAL
						);

NTSTATUS	LsaThunkIOpenPolicyTrusted(
						OUT PLSAPR_HANDLE PolicyHandle
						);


NTSTATUS	LsaThunkIFree_LSAPR_POLICY_INFORMATION(
						POLICY_INFORMATION_CLASS InformationClass,
						PLSAPR_POLICY_INFORMATION PolicyInformation
						);

 
NTSTATUS	LsaThunkIAuditNotifyPackageLoad(
						PUNICODE_STRING PackageFileName
						);


NTSTATUS	LsaThunkrQueryInformationPolicy(
						IN LSAPR_HANDLE PolicyHandle,
						IN POLICY_INFORMATION_CLASS InformationClass,
						OUT PLSAPR_POLICY_INFORMATION *Buffer
						);

NTSTATUS	LsaThunkrClose(
						IN OUT LSAPR_HANDLE *ObjectHandle
						);

NTSTATUS	LsaThunkIQueryInformationPolicyTrusted(
						IN POLICY_INFORMATION_CLASS InformationClass,
						OUT PLSAPR_POLICY_INFORMATION *Buffer
						);

NTSTATUS	LsaThunkIHealthCheck(
						IN  ULONG CallerId
						);

// Redifine the SAM functions that call LSA to go through
// the thunk layer.


#define LsaIAuditSamEvent(\
                            PassedStatus,\
                            AuditId,\
                            DomainSid,\
                            MemberRid,\
                            MemberSid,\
                            AccountName,\
                            Domain,\
                            AccountRid,\
                            Privileges,\
                            ExtendedInfo)\
        LsaThunkIAuditSamEvent(\
                            PassedStatus,\
                            AuditId,\
                            DomainSid,\
                            MemberRid,\
                            MemberSid,\
                            AccountName,\
                            Domain,\
                            AccountRid,\
                            Privileges,\
                            ExtendedInfo)

#define LsaIOpenPolicyTrusted(\
							PolicyHandle)\
		LsaThunkIOpenPolicyTrusted(\
							PolicyHandle)

	
#define LsaIFree_LSAPR_POLICY_INFORMATION(\
							InformationClass,\
							PolicyInformation)\
		LsaThunkIFree_LSAPR_POLICY_INFORMATION(\
							InformationClass,\
							PolicyInformation)
 
	
#define LsaIAuditNotifyPackageLoad(\
							PackageFileName)\
		LsaThunkIAuditNotifyPackageLoad(\
							PackageFileName)
 
	
#define LsarQueryInformationPolicy(\
							PolicyHandle,\
							InformationClass,\
							Buffer)\
		LsaThunkrQueryInformationPolicy(\
							PolicyHandle,\
							InformationClass,\
							Buffer)


	 
#define LsarClose(\
			ObjectHandle)\
		LsaThunkrClose(\
			ObjectHandle)
    
#define LsaIQueryInformationPolicyTrusted(\
									InformationClass,\
									Buffer)\
		LsaThunkIQueryInformationPolicyTrusted(\
									InformationClass,\
									Buffer)
#define LsaIHealthCheck(\
			CallerId)\
		LsaThunkIHealthCheck(\
			CallerId)

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\password.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    password.c

Abstract:

    This file contains routines related to Password Checking API.

Author:

    Umit AKKUS (umita) 16-Nov-2001

Environment:

    User Mode - Win32

Revision History:

--*/

#include <samsrvp.h>
#include <msaudite.h>
#include <winsock2.h>
#include "validate.h"

#define SAFE_DOMAIN_INDEX \
    ( SampUseDsData ? \
        ( DOMAIN_START_DS + 1 ) :\
        SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX \
    )

#if DBG
VOID
SamValidateAssertOutputFields(
    IN PSAM_VALIDATE_STANDARD_OUTPUT_ARG OutputArg,
    IN PASSWORD_POLICY_VALIDATION_TYPE ValidationType
)
{
    PSAM_VALIDATE_PERSISTED_FIELDS OutputFields = &( OutputArg->ChangedPersistedFields );
    ULONG PresentFields = OutputFields->PresentFields;
    BOOLEAN LockoutTimeChanged = FALSE;

    if( PresentFields & SAM_VALIDATE_LOCKOUT_TIME ) {

        LockoutTimeChanged = TRUE;
        PresentFields &= ~SAM_VALIDATE_LOCKOUT_TIME;
    }

    switch(OutputArg->ValidationStatus){

        case SamValidateSuccess:

            switch(ValidationType){

                case SamValidateAuthentication:
                    ASSERT( PresentFields == 0 );
                    break;

                case SamValidatePasswordChange:
                    ASSERT( PresentFields & SAM_VALIDATE_PASSWORD_LAST_SET );
                    ASSERT( PresentFields & SAM_VALIDATE_PASSWORD_HISTORY );
                    ASSERT( PresentFields & SAM_VALIDATE_PASSWORD_HISTORY_LENGTH );
                    ASSERT( PresentFields ==
                               ( SAM_VALIDATE_PASSWORD_LAST_SET |
                                    SAM_VALIDATE_PASSWORD_HISTORY |
                                    SAM_VALIDATE_PASSWORD_HISTORY_LENGTH
                               )
                        );

                    ASSERT( OutputFields->PasswordLastSet.QuadPart != SampHasNeverTime.QuadPart );
//                    ASSERT( OutputFields->PasswordHistoryLength > 0 );
//                    ASSERT( OutputFields->PasswordHistory != NULL );
                    break;

                case SamValidatePasswordReset:
                    ASSERT( PresentFields & SAM_VALIDATE_PASSWORD_LAST_SET );
                    ASSERT( PresentFields & SAM_VALIDATE_PASSWORD_HISTORY );
                    ASSERT( PresentFields & SAM_VALIDATE_PASSWORD_HISTORY_LENGTH );

//                    ASSERT( OutputFields->PasswordLastSet.QuadPart != SampHasNeverTime.QuadPart );
//                    ASSERT( OutputFields->PasswordHistoryLength > 0 );
//                    ASSERT( OutputFields->PasswordHistory != NULL );
                    break;
            }
            break;

        case SamValidatePasswordMustChange:
            ASSERT( PresentFields == 0 );
            break;

        case SamValidateAccountLockedOut:
            ASSERT( !LockoutTimeChanged );
            ASSERT( PresentFields == 0 );
            break;

        case SamValidatePasswordExpired:
            ASSERT( PresentFields == 0 );
            break;

        case SamValidatePasswordIncorrect:
            ASSERT( PresentFields & SAM_VALIDATE_BAD_PASSWORD_TIME );
            ASSERT( PresentFields & SAM_VALIDATE_BAD_PASSWORD_COUNT );
            ASSERT( PresentFields ==
                        ( SAM_VALIDATE_BAD_PASSWORD_TIME |
                             SAM_VALIDATE_BAD_PASSWORD_COUNT )
                  );
            ASSERT( OutputFields->BadPasswordTime.QuadPart != SampHasNeverTime.QuadPart );
            ASSERT( OutputFields->BadPasswordCount > 0 );
            break;

        case SamValidatePasswordIsInHistory:
            ASSERT( PresentFields == 0 );
            break;

        case SamValidatePasswordTooShort:
            ASSERT( PresentFields == 0 );
            break;

        case SamValidatePasswordTooLong:
            ASSERT( PresentFields == 0 );
            break;

        case SamValidatePasswordNotComplexEnough:
            ASSERT( PresentFields == 0 );
            break;

        case SamValidatePasswordTooRecent:
            ASSERT( PresentFields == 0 );
            break;

        case SamValidatePasswordFilterError:
            ASSERT( PresentFields == 0 );
            break;

        default:
            ASSERT(!"INVALID VALIDATION STATUS VALUE");
            break;
    }
}

#endif

NTSTATUS
SampCheckStrongPasswordRestrictions(
    PUNICODE_STRING AccountName,
    PUNICODE_STRING FullName,
    PUNICODE_STRING Password,
    OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION  PasswordChangeFailureInfo OPTIONAL
    );

LARGE_INTEGER
SampGetPasswordMustChange(
    IN ULONG UserAccountControl,
    IN LARGE_INTEGER PasswordLastSet,
    IN LARGE_INTEGER MaxPasswordAge
    );

NTSTATUS
SampObtainLockoutInfoWithDomainIndex(
   OUT PDOMAIN_LOCKOUT_INFORMATION LockoutInformation,
   IN ULONG DomainIndex,
   IN BOOLEAN WriteLockAcquired
   );

NTSTATUS
SampObtainEffectivePasswordPolicyWithDomainIndex(
   OUT PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo,
   IN ULONG DomainIndex,
   IN BOOLEAN WriteLockAcquired
   );

NTSTATUS
SampPasswordChangeFilterWorker(
    IN PUNICODE_STRING FullName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NewPassword,
    IN OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfo OPTIONAL,
    IN BOOLEAN SetOperation
    );

NTSTATUS
SampGetClientIpAddr(
    OUT LPSTR *NetworkAddr
);


NTSTATUS
SampValidateCheckPasswordRestrictions(
    IN PUNICODE_STRING Password,
    IN PUNICODE_STRING UserAccountName,
    IN PDOMAIN_PASSWORD_INFORMATION PasswordInformation,
    IN BOOLEAN SetOperation,
    OUT PSAM_VALIDATE_VALIDATION_STATUS ValidationStatus
)
/*++

Routine Description:

    This routine checks the password complexity

Parameters:

    Password - Clear password

    UserAccountName -Name of the account

    PasswordInformation - Domain Policy for password

    ValidationStatus - Result of the check
        SamValidatePasswordTooShort
        SamValidatePasswordTooLong
        SamValidatePasswordNotComplexEnough
        SamValidatePasswordFilterError

Return Values:

    STATUS_SUCCESS
        Password checked successfully

    STATUS_PASSWORD_RESTRICTION
        Password did not pass the complexity check, see ValidationStatus

    STATUS_NO_MEMORY
        Cannot check the password, not enough memory

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING FullName;
    RtlInitUnicodeString(&FullName, NULL);


    // Min Length Check
    if(Password->Length / sizeof(WCHAR) < PasswordInformation->MinPasswordLength){

        *ValidationStatus = SamValidatePasswordTooShort;
        Status = STATUS_PASSWORD_RESTRICTION;
        goto Exit;
    }

    // Max Length Check
    if(Password->Length / sizeof(WCHAR) > PWLEN){

        *ValidationStatus = SamValidatePasswordTooLong;
        Status = STATUS_PASSWORD_RESTRICTION;
        goto Exit;
    }

    // Complexity Check

    if(FLAG_ON(PasswordInformation->PasswordProperties, DOMAIN_PASSWORD_COMPLEX)){

        Status = SampCheckStrongPasswordRestrictions(
                     UserAccountName,
                     &FullName,
                     Password,
                     NULL   // don't need failure info
                     );

        if(Status == STATUS_PASSWORD_RESTRICTION){

            *ValidationStatus = SamValidatePasswordNotComplexEnough;
            goto Exit;
        }

        if(!NT_SUCCESS(Status)){

            goto Error;
        }
    }

    Status = SampPasswordChangeFilterWorker(
                 &FullName,
                 UserAccountName,
                 Password,
                 NULL,    // don't need failure info
                 SetOperation
                 );

    if( Status == STATUS_PASSWORD_RESTRICTION ) {

        *ValidationStatus = SamValidatePasswordFilterError;
        goto Exit;
    }

    if( !NT_SUCCESS( Status ) ) {

        goto Error;
    }

Exit:
    return Status;

Error:
    goto Exit;
}


NTSTATUS
SampValidateCopyPasswordHash(
    OUT PSAM_VALIDATE_PASSWORD_HASH To,
    IN PSAM_VALIDATE_PASSWORD_HASH From
)
/*++

Routine Description:

    This routine copies one passwordhash to another

Parameters:

    To - PasswordHash to be copied on

    From - PasswordHash to be copied from

Return Values:

    STATUS_SUCCESS
        Copied successfully

    STATUS_NO_MEMORY
        Cannot copy, out of memory

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    To->Length = From->Length;

    if(To->Length == 0){

        To->Hash = NULL;
        goto Exit;
    }

    To->Hash = MIDL_user_allocate(sizeof(BYTE) * To->Length);

    if(To->Hash == NULL){

        Status = STATUS_NO_MEMORY;
        goto Error;
    }

    RtlCopyMemory(To->Hash, From->Hash, sizeof(BYTE) * To->Length);

Exit:
    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ) );

    if( To->Hash != NULL ) {

        MIDL_user_free( To->Hash );
        To->Hash = NULL;
    }

    To->Length = 0;
    goto Exit;
}


NTSTATUS
SampValidateInsertPasswordInPassHash(
    OUT PSAM_VALIDATE_PERSISTED_FIELDS OutputFields,
    IN PSAM_VALIDATE_PERSISTED_FIELDS InputFields,
    IN PSAM_VALIDATE_PASSWORD_HASH HashedPassword,
    IN ULONG DomainPasswordHistoryLength,
    IN PLARGE_INTEGER PasswordChangeTime
)
/*++

Routine Description:

    This routine changes the password and inserts the hashed password
        into the password history of the outputfields with regards to domain
        password history length.

Parameters:

    OutputFields - changes to be made into

    InputFields - changes to be made from

    HashedPassword - the new password hash to be copied

    DomainPasswordHistoryLength - Maximum password history length to be
        considered

    PasswordChangeTime - when the password is changed

Return Values:

    STATUS_SUCCESS
        Copied successfully

    STATUS_NO_MEMORY
        Cannot copy, out of memory

--*/
{
    ULONG Index;
    ULONG i = 0;
    NTSTATUS Status = STATUS_SUCCESS;

    OutputFields->PasswordLastSet = *PasswordChangeTime;

    OutputFields->PasswordHistory = NULL;
    OutputFields->PasswordHistoryLength = 0;


    if(DomainPasswordHistoryLength != 0){

        if(InputFields->PasswordHistoryLength >= DomainPasswordHistoryLength){

            Index = InputFields->PasswordHistoryLength - DomainPasswordHistoryLength + 1;
            OutputFields->PasswordHistoryLength = DomainPasswordHistoryLength;
        }
        else{

            Index = 0;
            OutputFields->PasswordHistoryLength = InputFields->PasswordHistoryLength + 1;
        }

        OutputFields->PasswordHistory = MIDL_user_allocate(
            sizeof(SAM_VALIDATE_PASSWORD_HASH) * OutputFields->PasswordHistoryLength
            );

        if(OutputFields->PasswordHistory == NULL){

            Status = STATUS_NO_MEMORY;
            goto Error;
        }


        RtlSecureZeroMemory(OutputFields->PasswordHistory,
            sizeof(SAM_VALIDATE_PASSWORD_HASH) * OutputFields->PasswordHistoryLength
            );

        for(i = 0; i < OutputFields->PasswordHistoryLength - 1; i++){

            Status = SampValidateCopyPasswordHash(OutputFields->PasswordHistory + i,
                InputFields->PasswordHistory + i + Index);

            if(!NT_SUCCESS(Status)){

                goto Error;
            }
        }

        Status = SampValidateCopyPasswordHash(OutputFields->PasswordHistory + i,
            HashedPassword);

        if(!NT_SUCCESS(Status)){

            goto Error;
        }

    }

    OutputFields->PresentFields |=
        SAM_VALIDATE_PASSWORD_LAST_SET |
        SAM_VALIDATE_PASSWORD_HISTORY_LENGTH |
        SAM_VALIDATE_PASSWORD_HISTORY;


Exit:
    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ) );

    while(i-->0){

        MIDL_user_free(OutputFields->PasswordHistory[i].Hash);
        OutputFields->PasswordHistory[i].Hash = NULL;
    }

    if(OutputFields->PasswordHistory != NULL){

        MIDL_user_free(OutputFields->PasswordHistory);
        OutputFields->PasswordHistory = NULL;
    }

    OutputFields->PasswordHistoryLength = 0;
    goto Exit;
}

VOID
SampValidatePasswordNotMatched(
    IN PSAM_VALIDATE_PERSISTED_FIELDS InputFields,
    IN PDOMAIN_LOCKOUT_INFORMATION LockoutInformation,
    IN PLARGE_INTEGER SystemTime,
    OUT PSAM_VALIDATE_PERSISTED_FIELDS OutputFields,
    OUT PSAM_VALIDATE_VALIDATION_STATUS ValidationStatus
)
/*++

Routine Description:

    This routine updates bad password time and check if the account is
        going to be locked.

Parameters:

    InputFields - changes to be made from

    LockoutInformation - Domain Lockout Information

    SystemTime - System time

    OutputFields - changes to be made into

    ValidationStatus - result of the check

Return Values:
    Void

--*/
{
    LARGE_INTEGER EndOfWindow;

    OutputFields->BadPasswordCount = InputFields->BadPasswordCount + 1;

    EndOfWindow = SampAddDeltaTime(InputFields->BadPasswordTime,
                      LockoutInformation->LockoutObservationWindow);

    if(RtlLargeIntegerGreaterThanOrEqualTo(EndOfWindow, *SystemTime)){

        if(OutputFields->BadPasswordCount >= LockoutInformation->LockoutThreshold &&
            LockoutInformation->LockoutThreshold != 0){

            OutputFields->LockoutTime = *SystemTime;
            OutputFields->PresentFields |=
                SAM_VALIDATE_LOCKOUT_TIME;
        }
    }
    else{

        OutputFields->BadPasswordCount = 1;
    }

    *ValidationStatus = SamValidatePasswordIncorrect;

    OutputFields->BadPasswordTime = *SystemTime;
    OutputFields->PresentFields |=
        SAM_VALIDATE_BAD_PASSWORD_COUNT |
        SAM_VALIDATE_BAD_PASSWORD_TIME;

}

NTSTATUS
SampValidateAuthentication(
    IN PSAM_VALIDATE_AUTHENTICATION_INPUT_ARG InputArg,
    OUT PSAM_VALIDATE_STANDARD_OUTPUT_ARG OutputArg
)
/*++

Routine Description:

    This routine checks if user can be authenticated.

Parameters:

    InputArg - Information about password

    OutputArg - Result of the validation

Return Values:

    STATUS_SUCCESS:
        CHECK OutputArg->ValidationStatus

    return codes of NtQuerySystemTime

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;    // Result of the operation
    LARGE_INTEGER SystemTime; // Time of the system
    LARGE_INTEGER PasswordChangeTime; // Time to change password
    DOMAIN_LOCKOUT_INFORMATION  LockoutInformation;      // Domain Policy information
    DOMAIN_PASSWORD_INFORMATION PasswordInformation;
    PSAM_VALIDATE_PERSISTED_FIELDS InputFields;   // For easy access to InputPersistedFields in InputArg
    PSAM_VALIDATE_PERSISTED_FIELDS OutputFields;    // For easy access to ChangedPersistedFields in OutputArg
    LARGE_INTEGER EndOfWindow;

    // Initialization of the local variables
    InputFields = &(InputArg->InputPersistedFields);
    OutputFields = &(OutputArg->ChangedPersistedFields);

    Status = SampObtainLockoutInfoWithDomainIndex(
                 &LockoutInformation,
                 SAFE_DOMAIN_INDEX,
                 FALSE
                 );

    if(!NT_SUCCESS(Status)){

        goto Error;
    }

    Status = SampObtainEffectivePasswordPolicyWithDomainIndex(
                 &PasswordInformation,
                 SAFE_DOMAIN_INDEX,
                 FALSE
                 );

    if(!NT_SUCCESS(Status)){

        goto Error;
    }

    Status = NtQuerySystemTime(&SystemTime);

    if(!NT_SUCCESS(Status)){

        goto Error;
    }


    // 4 Checks are to be made
    //      1 - Check if account is locked out
    //      2 - Check if password must be changed before authentication
    //      3 - Check if password is expired
    //      4 - Check if password is correct (update Lockout info)
    //      5 - Authenticate

    //1 1 - Check if account is locked out

    if(InputFields->LockoutTime.QuadPart != SampHasNeverTime.QuadPart){

        EndOfWindow = SampAddDeltaTime(InputFields->LockoutTime,
                          LockoutInformation.LockoutDuration);

        if(RtlLargeIntegerGreaterThan(EndOfWindow, SystemTime)){

            OutputArg->ValidationStatus = SamValidateAccountLockedOut;
            goto Exit;
        }
        else{

            OutputFields->LockoutTime = SampHasNeverTime;
            OutputFields->PresentFields |= SAM_VALIDATE_LOCKOUT_TIME;
        }
    }

    //1 2 - Check if password must be changed before authentication

    if(InputFields->PasswordLastSet.QuadPart == SampHasNeverTime.QuadPart){

        OutputArg->ValidationStatus = SamValidatePasswordMustChange;
        goto Exit;
    }

    //1 3 - Check if password is expired

    PasswordChangeTime = SampGetPasswordMustChange(
                             0, // No user account control is needed
                             InputFields->PasswordLastSet,
                             PasswordInformation.MaxPasswordAge
                             );

    if(RtlLargeIntegerGreaterThan(SystemTime, PasswordChangeTime)){

        OutputArg->ValidationStatus = SamValidatePasswordExpired;
        goto Exit;
    }


    //1 4 - Check if password is correct (update Lockout info)

    if(!InputArg->PasswordMatched){

        SampValidatePasswordNotMatched(
            InputFields,
            &LockoutInformation,
            &SystemTime,
            OutputFields,
            &(OutputArg->ValidationStatus)
            );

        goto Exit;
    }

    //1 5 - Authenticate
    OutputArg->ValidationStatus = SamValidateSuccess;

Exit:
    return Status;

Error:

    ASSERT( ! NT_SUCCESS( Status ) );
    goto Exit;
}

NTSTATUS
SampValidatePasswordChange(
    IN PSAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG InputArg,
    OUT PSAM_VALIDATE_STANDARD_OUTPUT_ARG OutputArg
)
/*++

Routine Description:

    This routine checks if the password can be changed

Parameters:

    InputArg - Information about password

    OutputArg - Result of the validation

Return Values:

    STATUS_SUCCESS:
        CHECK OutputArg->ValidationStatus

    return codes of NtQuerySystemTime

    STATUS_NO_MEMORY:
        not enough memory to change the password

    STATUS_INVALID_PARAMETER:
        one of the parameters is invalid

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;     // Result of the operation
    DOMAIN_PASSWORD_INFORMATION PasswordInformation;   // Domain Policy information
    DOMAIN_LOCKOUT_INFORMATION  DomainInformation;
    ULONG Min;     // Min of Password History length of domain policy and the input password
    ULONG Index;   // Index used for traversing the history of the passwords
    PSAM_VALIDATE_PERSISTED_FIELDS InputFields;   // For easy access to the InputPersistedFields of InputArg
    PSAM_VALIDATE_PERSISTED_FIELDS OutputFields;    // For easy access to ChangedPersistedFields in OutputArg
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER PasswordChangeTime;
    LARGE_INTEGER PasswordCanChangeTime;
    LARGE_INTEGER EndOfWindow;

    // Validation of input parameter
    Status = RtlValidateUnicodeString( 0, &( InputArg->ClearPassword ) );

    if(!NT_SUCCESS(Status)){

        goto Error;
    }

    Status = RtlValidateUnicodeString( 0, &( InputArg->UserAccountName ) );

    if(!NT_SUCCESS(Status)){

        goto Error;
    }

    // Initialization of local variables
    InputFields = &(InputArg->InputPersistedFields);
    OutputFields = &(OutputArg->ChangedPersistedFields);

    Status = SampObtainLockoutInfoWithDomainIndex(
                 &DomainInformation,
                 SAFE_DOMAIN_INDEX,
                 FALSE
                 );

    if(!NT_SUCCESS(Status)){

        goto Error;
    }

    Status = SampObtainEffectivePasswordPolicyWithDomainIndex(
                 &PasswordInformation,
                 SAFE_DOMAIN_INDEX,
                 FALSE
                 );

    if(!NT_SUCCESS(Status)){

        goto Error;
    }

    Status = NtQuerySystemTime(&SystemTime);

    if(!NT_SUCCESS(Status)){

        goto Error;
    }

    // 5 Checks are to be made
    //      1 - Check if account is locked out
    //      2 - Check if the password was changed recently
    //      3 - Check if password is correct (update Lockout info)
    //      4 - Check that HashedPassword is not in the history
    //      5 - Complexity Check

    //1 1 - Check if account is locked out

    if(InputFields->LockoutTime.QuadPart != SampHasNeverTime.QuadPart){

        EndOfWindow = SampAddDeltaTime(InputFields->LockoutTime,
                          DomainInformation.LockoutDuration);

        if(RtlLargeIntegerGreaterThan(EndOfWindow, SystemTime)){

            OutputArg->ValidationStatus = SamValidateAccountLockedOut;
            goto Exit;
        }
        else{

            OutputFields->LockoutTime = SampHasNeverTime;
            OutputFields->PresentFields |= SAM_VALIDATE_LOCKOUT_TIME;
        }
    }

    //1 2 - Check if the password was changed recently

    PasswordCanChangeTime = SampAddDeltaTime(InputFields->PasswordLastSet,
                                PasswordInformation.MinPasswordAge);

    if(RtlLargeIntegerLessThan(SystemTime, PasswordCanChangeTime)){

        OutputArg->ValidationStatus = SamValidatePasswordTooRecent;
        goto Exit;
    }

    //1 3 - Check if password is correct (update Lockout info)

    if(!InputArg->PasswordMatch){

        SampValidatePasswordNotMatched(
            InputFields,
            &DomainInformation,
            &SystemTime,
            OutputFields,
            &(OutputArg->ValidationStatus)
            );

        goto Exit;
    }

    //1 4 - Check that HashedPassword is not in the history

    Index = InputFields->PasswordHistoryLength - 1;

    if(InputFields->PasswordHistoryLength < PasswordInformation.PasswordHistoryLength){

        Min = InputFields->PasswordHistoryLength;
    }
    else{

        Min = PasswordInformation.PasswordHistoryLength;
    }

    while(Min-->0){

        if(InputFields->PasswordHistory[Index].Length == InputArg->HashedPassword.Length){

            if(RtlEqualMemory(InputFields->PasswordHistory[Index].Hash,
                    InputArg->HashedPassword.Hash,
                    InputArg->HashedPassword.Length)){

                OutputArg->ValidationStatus = SamValidatePasswordIsInHistory;
                goto Exit;
            }
        }
        Index--;
    }

    //1 5 - Complexity Check

    Status = SampValidateCheckPasswordRestrictions(
                 &(InputArg->ClearPassword),
                 &(InputArg->UserAccountName),
                 &PasswordInformation,
                 FALSE,
                 &(OutputArg->ValidationStatus)
                 );

    if(Status == STATUS_PASSWORD_RESTRICTION){

        Status = STATUS_SUCCESS;
        goto Exit;
    }

    if(!NT_SUCCESS(Status)){

        goto Error;
    }

    //1 6 - Change Password

    Status = SampValidateInsertPasswordInPassHash(
                 OutputFields,
                 InputFields,
                 &(InputArg->HashedPassword),
                 PasswordInformation.PasswordHistoryLength,
                 &SystemTime
                 );

    if(!NT_SUCCESS(Status)){

        goto Error;
    }

    OutputArg->ValidationStatus = SamValidateSuccess;

Exit:
    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ) );
    goto Exit;
}

NTSTATUS
SampValidatePasswordReset(
    IN PSAM_VALIDATE_PASSWORD_RESET_INPUT_ARG InputArg,
    OUT PSAM_VALIDATE_STANDARD_OUTPUT_ARG OutputArg
)
/*++

Routine Description:

    This routine resets the password to the given value

Parameters:

    InputArg - Information about password

    OutputArg - Result of the validation

Return Values:

    STATUS_SUCCESS:
        CHECK OutputArg->ValidationStatus

    return codes of NtQuerySystemTime

    STATUS_NO_MEMORY:
        not enough memory to change the password

    STATUS_INVALID_PARAMETER:
        one of the parameters is invalid

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;     // Result of the operation
    DOMAIN_PASSWORD_INFORMATION PasswordInformation;   // Domain Policy information
    PSAM_VALIDATE_PERSISTED_FIELDS InputFields;   // For easy access to the InputPersistedFields of InputArg
    PSAM_VALIDATE_PERSISTED_FIELDS OutputFields;    // For easy access to ChangedPersistedFields in OutputArg
    LARGE_INTEGER PasswordLastSet;

    // Validation of input parameter
    Status = RtlValidateUnicodeString( 0, &( InputArg->ClearPassword ) );

    if(!NT_SUCCESS(Status)){

        goto Error;
    }

    Status = RtlValidateUnicodeString( 0, &( InputArg->UserAccountName ) );

    if(!NT_SUCCESS(Status)){

        goto Error;
    }

    // Initialization of local variables
    InputFields = &(InputArg->InputPersistedFields);
    OutputFields = &(OutputArg->ChangedPersistedFields);

    Status = SampObtainEffectivePasswordPolicyWithDomainIndex(
                 &PasswordInformation,
                 SAFE_DOMAIN_INDEX,
                 FALSE
                 );

    if(!NT_SUCCESS(Status)){

        goto Error;
    }

    // Only 1 check is to be made
    //      1 - Complexity Check

    //1 1 - Complexity Check

    Status = SampValidateCheckPasswordRestrictions(
                 &(InputArg->ClearPassword),
                 &(InputArg->UserAccountName),
                 &PasswordInformation,
                 TRUE,
                 &(OutputArg->ValidationStatus)
                 );

    if(Status == STATUS_PASSWORD_RESTRICTION){

        Status = STATUS_SUCCESS;
        goto Exit;
    }

    if(!NT_SUCCESS(Status)){

        goto Error;
    }

    //1 2 - Password Must Change At Next Logon

    if(InputArg->PasswordMustChangeAtNextLogon){

        PasswordLastSet = SampHasNeverTime;
    }
    else{

        Status = NtQuerySystemTime(&PasswordLastSet);

        if(!NT_SUCCESS(Status)){

            goto Error;
        }
    }

    //1 3 - Clear Lockout

    if(InputArg->ClearLockout){

        OutputFields->LockoutTime = SampHasNeverTime;
        OutputFields->PresentFields |= SAM_VALIDATE_LOCKOUT_TIME;
    }

    //1 4 - PasswordChange

    Status = SampValidateInsertPasswordInPassHash(
                 OutputFields,
                 InputFields,
                 &(InputArg->HashedPassword),
                 PasswordInformation.PasswordHistoryLength,
                 &PasswordLastSet
                 );

    if(!NT_SUCCESS(Status)){

        goto Error;
    }

    OutputArg->ValidationStatus = SamValidateSuccess;

Exit:
    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ) );
    goto Exit;

}

VOID
SampValidateAuditThisCall(
    IN NTSTATUS Status,
    IN PSAM_VALIDATE_INPUT_ARG InputArg,
    IN PASSWORD_POLICY_VALIDATION_TYPE ValidationType
    )
/*++

Routine Description:

    This routine audits the call to SamrValidatePassword.

Arguments:

    Status          -- What was the Status in SamrValidatePassword when this function
                        is called, and it must be what SamrValidatePassword will return.
    InputArg        -- What was the input arg provided to SamrValidatePassword, need to
                        extract the username, if validation type is not
                        SamValidateAuthentication.
    ValidationType  -- What was the validation type? Need to know to decide whether extract
                        the username or not.

Return Value:

    VOID

--*/
{
    UNICODE_STRING WorkstationName;
    UNICODE_STRING AccountName;
    PSTR NetAddr = NULL;
    PVOID AllInformation[] = {
                                &WorkstationName,
                                &AccountName,
                             };

    //
    // Are we supposed to make an audit?
    //

    if( !SampDoSuccessOrFailureAccountAuditing( SAFE_DOMAIN_INDEX, Status ) ) {

        return;
    }

    RtlInitUnicodeString( &WorkstationName, NULL );
    RtlInitUnicodeString( &AccountName, NULL );

    //
    // Extract workstation name
    //

    if( NT_SUCCESS( SampGetClientIpAddr( &NetAddr ) ) ) {

        RtlCreateUnicodeStringFromAsciiz( &WorkstationName, NetAddr );
        RpcStringFreeA( &NetAddr );
    }

    //
    // Extract AccountName provided in the input
    //

    switch( ValidationType ) {

        case SamValidatePasswordChange:

            AccountName = ( ( PSAM_VALIDATE_PASSWORD_CHANGE_INPUT_ARG ) InputArg )->UserAccountName;
            break;

        case SamValidatePasswordReset:

            AccountName = ( ( PSAM_VALIDATE_PASSWORD_RESET_INPUT_ARG ) InputArg )->UserAccountName;
            break;
    }

    if( !SampValidateRpcUnicodeString( ( PRPC_UNICODE_STRING ) &AccountName ) ) {

        RtlInitUnicodeString( &AccountName, NULL );
    }

    //
    // Return code is unimportant
    // What can we do if it fails?
    //
    ( VOID ) LsaIAuditSamEvent(
                Status,
                SE_AUDITID_PASSWORD_POLICY_API_CALLED,
                NULL,   // No information is passed explicitly
                NULL,   // all information has to be in
                NULL,   // extended information
                NULL,   // because the caller information
                NULL,   // has to be before any other information
                NULL,
                NULL,
                NULL,
                AllInformation
                );

    RtlFreeUnicodeString( &WorkstationName );
}

NTSTATUS
SamrValidatePassword(
    IN handle_t Handle,
    IN PASSWORD_POLICY_VALIDATION_TYPE ValidationType,
    IN PSAM_VALIDATE_INPUT_ARG InputArg,
    OUT PSAM_VALIDATE_OUTPUT_ARG *OutputArg
    )
/*++

Routine Description:

    This routine checks the password against the policy of the domain,
    according to the validation type.

Parameters:

    Handle - Handle gained from SampSecureBind

    ValidationType -The type of validation to be made

        -SamValidateAuthentication
        -SamValidatePasswordChange
        -SamValidatePasswordReset

    InputArg - Information about what type of validation is to be made

    OutputArg - Result of the validation

Return Values:

    STATUS_SUCCESS
        CHECK OutputArg->ValidationStatus for details

    return codes of NtQuerySystemTime

    STATUS_NO_MEMORY
        not enough memory to complete the task

    STATUS_INVALID_PARAMETER
        one of the parameters is invalid

    STATUS_ACCESS_DENIED
        Caller doesn't have access to password policy

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SAMPR_HANDLE ServerHandle = NULL;
    SAMPR_HANDLE DomainHandle = NULL;

    //
    // Is RPC helping us?
    //
    ASSERT( OutputArg != NULL );
    ASSERT( *OutputArg == NULL );
    ASSERT( InputArg != NULL );

    //
    // Check input parameters
    //
    if( OutputArg == NULL  ||
        *OutputArg != NULL ||
        InputArg == NULL   ||
        ( ValidationType != SamValidateAuthentication &&
          ValidationType != SamValidatePasswordChange &&
          ValidationType != SamValidatePasswordReset )
      ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    Status = SampValidateValidateInputArg( InputArg, ValidationType, TRUE );

    if( !NT_SUCCESS( Status ) ) {

        goto Error;
    }
    //
    // Check if the user has access to password policy
    //
    Status = SamrConnect(
                 NULL,
                 &ServerHandle,
                 SAM_SERVER_LOOKUP_DOMAIN
                 );

    if( !NT_SUCCESS( Status ) ) {

        goto Error;
    }

    Status = SamrOpenDomain(
                 ServerHandle,
                 DOMAIN_READ_PASSWORD_PARAMETERS,
                 ( PRPC_SID ) SampDefinedDomains[ SAFE_DOMAIN_INDEX ].Sid,
                 &DomainHandle
                 );

    if( !NT_SUCCESS( Status ) ) {

        goto Error;
    }

    //
    // if different output args will be used for different type
    //      of checks then each type should allocate
    //      its space
    //
    *OutputArg = MIDL_user_allocate( sizeof( SAM_VALIDATE_STANDARD_OUTPUT_ARG ) );

    if(*OutputArg == NULL ){

        Status = STATUS_NO_MEMORY;
        goto Error;
    }


    RtlSecureZeroMemory( *OutputArg, sizeof( SAM_VALIDATE_STANDARD_OUTPUT_ARG ) );

    switch(ValidationType){

        case SamValidateAuthentication:
            Status = SampValidateAuthentication(
                         &(InputArg->ValidateAuthenticationInput),
                         &((*OutputArg)->ValidateAuthenticationOutput)
                         );
            break;

        case SamValidatePasswordChange:
            Status = SampValidatePasswordChange(
                         &(InputArg->ValidatePasswordChangeInput),
                         &((*OutputArg)->ValidatePasswordChangeOutput)
                         );
            break;

        case SamValidatePasswordReset:
            Status = SampValidatePasswordReset(
                         &(InputArg->ValidatePasswordResetInput),
                         &((*OutputArg)->ValidatePasswordResetOutput)
                         );
            break;

        default:
            ASSERT( FALSE );
            break;
    }

    if( !NT_SUCCESS( Status ) ) {

        goto Error;
    }

#if DBG
    if( NT_SUCCESS( Status ) ) {

        SamValidateAssertOutputFields(
            (PSAM_VALIDATE_STANDARD_OUTPUT_ARG)(*OutputArg),
            ValidationType
            );
    }
#endif

Exit:

    SampValidateAuditThisCall( Status, InputArg, ValidationType );

    if( DomainHandle != NULL ) {

        SamrCloseHandle( &DomainHandle );
    }

    if( ServerHandle != NULL ) {

        SamrCloseHandle( &ServerHandle );
    }

    ASSERT( !NT_SUCCESS( Status ) ||
        NT_SUCCESS( SampValidateValidateOutputArg( *OutputArg, ValidationType, TRUE ) ) );

    return Status;
Error:

    ASSERT( !NT_SUCCESS( Status ) );

    if( ARGUMENT_PRESENT( OutputArg ) ) {

        if( *OutputArg != NULL ) {
            MIDL_user_free( *OutputArg );
        }

        *OutputArg = NULL;
    }
    goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\oldstub.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    oldstub.c

Abstract:

    This file contains functions generated by midl v1.0.  These
    function were designed to only be called by the stubs, but
    these paticular functions are called by user code.  This
    file is needed in order to compile sam with midl v2.0 which
    doesn't generated these paticular functions anymore.

Author:

    Mario Goertzel      (MarioGo)    Jan 10, 1994

Environment:

    User Mode - Win32

Revision History:


--*/

#include <samrpc.h>

/* routine that frees graph for struct _RPC_UNICODE_STRING */
void _fgs__RPC_UNICODE_STRING (RPC_UNICODE_STRING  * _source)
  {
  if (_source->Buffer !=0)
    {
    MIDL_user_free((void  *)(_source->Buffer));
    }
  }

/* routine that frees a string containing security sensitive info */

void SampFreeSensitiveUnicodeString(RPC_UNICODE_STRING  * _source)
 {
 if (_source->Buffer!=0)
    {
    memset(_source->Buffer,0,_source->Length);
    _fgs__RPC_UNICODE_STRING (_source);
    }
 }

/* routine that frees graph for struct _SAMPR_RID_ENUMERATION */
void _fgs__SAMPR_RID_ENUMERATION (SAMPR_RID_ENUMERATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Name);
  }

/* routine that frees graph for struct _SAMPR_ENUMERATION_BUFFER */
void _fgs__SAMPR_ENUMERATION_BUFFER (SAMPR_ENUMERATION_BUFFER  * _source)
  {
  if (_source->Buffer !=0)
    {
      {
      unsigned long _sym9;
      for (_sym9 = 0; _sym9 < (unsigned long )(0 + _source->EntriesRead); _sym9++)
        {
        _fgs__SAMPR_RID_ENUMERATION ((SAMPR_RID_ENUMERATION *)&_source->Buffer[_sym9]);
        }
      }
    MIDL_user_free((void  *)(_source->Buffer));
    }
  }

/* routine that frees graph for struct _SAMPR_SR_SECURITY_DESCRIPTOR */
void _fgs__SAMPR_SR_SECURITY_DESCRIPTOR (SAMPR_SR_SECURITY_DESCRIPTOR  * _source)
  {
  if (_source->SecurityDescriptor !=0)
    {
    MIDL_user_free((void  *)(_source->SecurityDescriptor));
    }
  }

/* routine that frees graph for struct _SAMPR_GET_GROUPS_BUFFER */
void _fgs__SAMPR_GET_GROUPS_BUFFER (SAMPR_GET_GROUPS_BUFFER  * _source)
  {
  if (_source->Groups !=0)
    {
    MIDL_user_free((void  *)(_source->Groups));
    }
  }

/* routine that frees graph for struct _SAMPR_GET_MEMBERS_BUFFER */
void _fgs__SAMPR_GET_MEMBERS_BUFFER (SAMPR_GET_MEMBERS_BUFFER  * _source)
  {
  if (_source->Members !=0)
    {
    MIDL_user_free((void  *)(_source->Members));
    }
  if (_source->Attributes !=0)
    {
    MIDL_user_free((void  *)(_source->Attributes));
    }
  }

/* routine that frees graph for struct _SAMPR_LOGON_HOURS */
void _fgs__SAMPR_LOGON_HOURS (SAMPR_LOGON_HOURS  * _source)
  {
  if (_source->LogonHours !=0)
    {
    MIDL_user_free((void  *)(_source->LogonHours));
    }
  }

/* routine that frees graph for struct _SAMPR_ULONG_ARRAY */
void _fgs__SAMPR_ULONG_ARRAY (SAMPR_ULONG_ARRAY  * _source)
  {
  if (_source->Element !=0)
    {
    MIDL_user_free((void  *)(_source->Element));
    }
  }

/* routine that frees graph for struct _SAMPR_SID_INFORMATION */
void _fgs__SAMPR_SID_INFORMATION (SAMPR_SID_INFORMATION  * _source)
  {
  if (_source->SidPointer !=0)
    {
    MIDL_user_free((void  *)(_source->SidPointer));
    }
  }

/* routine that frees graph for struct _SAMPR_PSID_ARRAY */
void _fgs__SAMPR_PSID_ARRAY (SAMPR_PSID_ARRAY  * _source)
  {
  if (_source->Sids !=0)
    {
    MIDL_user_free((void  *)(_source->Sids));
    }
  }


/* routine that frees graph for struct _SAMPR_RETURNED_USTRING_ARRAY */
void _fgs__SAMPR_RETURNED_USTRING_ARRAY (SAMPR_RETURNED_USTRING_ARRAY  * _source)
  {
  if (_source->Element !=0)
    {
      {
      unsigned long _sym26;
      for (_sym26 = 0; _sym26 < (unsigned long )(0 + _source->Count); _sym26++)
        {
        _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Element[_sym26]);
        }
      }
    MIDL_user_free((void  *)(_source->Element));
    }
  }

/* routine that frees graph for struct _SAMPR_DOMAIN_GENERAL_INFORMATION */
void _fgs__SAMPR_DOMAIN_GENERAL_INFORMATION (SAMPR_DOMAIN_GENERAL_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->OemInformation);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->DomainName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->ReplicaSourceNodeName);
  }

/* routine that frees graph for struct _SAMPR_DOMAIN_GENERAL_INFORMATION2 */
void _fgs__SAMPR_DOMAIN_GENERAL_INFORMATION2 (SAMPR_DOMAIN_GENERAL_INFORMATION2  * _source)
  {
  _fgs__SAMPR_DOMAIN_GENERAL_INFORMATION ((SAMPR_DOMAIN_GENERAL_INFORMATION *)&_source->I1);
  }

/* routine that frees graph for struct _SAMPR_DOMAIN_OEM_INFORMATION */
void _fgs__SAMPR_DOMAIN_OEM_INFORMATION (SAMPR_DOMAIN_OEM_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->OemInformation);
  }

/* routine that frees graph for struct _SAMPR_DOMAIN_NAME_INFORMATION */
void _fgs__SAMPR_DOMAIN_NAME_INFORMATION (SAMPR_DOMAIN_NAME_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->DomainName);
  }

/* routine that frees graph for struct SAMPR_DOMAIN_REPLICATION_INFORMATION */
void _fgs_SAMPR_DOMAIN_REPLICATION_INFORMATION (SAMPR_DOMAIN_REPLICATION_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->ReplicaSourceNodeName);
  }

/* routine that frees graph for union _SAMPR_DOMAIN_INFO_BUFFER */
void _fgu__SAMPR_DOMAIN_INFO_BUFFER (SAMPR_DOMAIN_INFO_BUFFER  * _source, DOMAIN_INFORMATION_CLASS _branch)
  {
  switch (_branch)
    {
    case DomainPasswordInformation :
      {
      break;
      }
    case DomainGeneralInformation :
      {
      _fgs__SAMPR_DOMAIN_GENERAL_INFORMATION ((SAMPR_DOMAIN_GENERAL_INFORMATION *)&_source->General);
      break;
      }
    case DomainLogoffInformation :
      {
      break;
      }
    case DomainOemInformation :
      {
      _fgs__SAMPR_DOMAIN_OEM_INFORMATION ((SAMPR_DOMAIN_OEM_INFORMATION *)&_source->Oem);
      break;
      }
    case DomainNameInformation :
      {
      _fgs__SAMPR_DOMAIN_NAME_INFORMATION ((SAMPR_DOMAIN_NAME_INFORMATION *)&_source->Name);
      break;
      }
    case DomainServerRoleInformation :
      {
      break;
      }
    case DomainReplicationInformation :
      {
      _fgs_SAMPR_DOMAIN_REPLICATION_INFORMATION ((SAMPR_DOMAIN_REPLICATION_INFORMATION *)&_source->Replication);
      break;
      }
    case DomainModifiedInformation :
      {
      break;
      }
    case DomainStateInformation :
      {
      break;
      }
    case DomainGeneralInformation2 :
      {
      _fgs__SAMPR_DOMAIN_GENERAL_INFORMATION2 ((SAMPR_DOMAIN_GENERAL_INFORMATION2 *)&_source->General2);
      break;
      }
    case DomainLockoutInformation :
      {
      break;
      }
    case DomainModifiedInformation2 :
      {
      break;
      }
    }
  }

/* routine that frees graph for struct _SAMPR_GROUP_GENERAL_INFORMATION */
void _fgs__SAMPR_GROUP_GENERAL_INFORMATION (SAMPR_GROUP_GENERAL_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Name);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->AdminComment);
  }

/* routine that frees graph for struct _SAMPR_GROUP_NAME_INFORMATION */
void _fgs__SAMPR_GROUP_NAME_INFORMATION (SAMPR_GROUP_NAME_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Name);
  }

/* routine that frees graph for struct _SAMPR_GROUP_ADM_COMMENT_INFORMATION */
void _fgs__SAMPR_GROUP_ADM_COMMENT_INFORMATION (SAMPR_GROUP_ADM_COMMENT_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->AdminComment);
  }

/* routine that frees graph for union _SAMPR_GROUP_INFO_BUFFER */
void _fgu__SAMPR_GROUP_INFO_BUFFER (SAMPR_GROUP_INFO_BUFFER  * _source, GROUP_INFORMATION_CLASS _branch)
  {
  switch (_branch)
    {
    case GroupGeneralInformation :
    case GroupReplicationInformation :
      {
      _fgs__SAMPR_GROUP_GENERAL_INFORMATION ((SAMPR_GROUP_GENERAL_INFORMATION *)&_source->General);
      break;
      }
    case GroupNameInformation :
      {
      _fgs__SAMPR_GROUP_NAME_INFORMATION ((SAMPR_GROUP_NAME_INFORMATION *)&_source->Name);
      break;
      }
    case GroupAttributeInformation :
      {
      break;
      }
    case GroupAdminCommentInformation :
      {
      _fgs__SAMPR_GROUP_ADM_COMMENT_INFORMATION ((SAMPR_GROUP_ADM_COMMENT_INFORMATION *)&_source->AdminComment);
      break;
      }
    }
  }

/* routine that frees graph for struct _SAMPR_ALIAS_GENERAL_INFORMATION */
void _fgs__SAMPR_ALIAS_GENERAL_INFORMATION (SAMPR_ALIAS_GENERAL_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Name);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->AdminComment);
  }

/* routine that frees graph for struct _SAMPR_ALIAS_NAME_INFORMATION */
void _fgs__SAMPR_ALIAS_NAME_INFORMATION (SAMPR_ALIAS_NAME_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Name);
  }

/* routine that frees graph for struct _SAMPR_ALIAS_ADM_COMMENT_INFORMATION */
void _fgs__SAMPR_ALIAS_ADM_COMMENT_INFORMATION (SAMPR_ALIAS_ADM_COMMENT_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->AdminComment);
  }

/* routine that frees graph for union _SAMPR_ALIAS_INFO_BUFFER */
void _fgu__SAMPR_ALIAS_INFO_BUFFER (SAMPR_ALIAS_INFO_BUFFER  * _source, ALIAS_INFORMATION_CLASS _branch)
  {
  switch (_branch)
    {
    case AliasGeneralInformation :
    case AliasReplicationInformation :
      {
      _fgs__SAMPR_ALIAS_GENERAL_INFORMATION ((SAMPR_ALIAS_GENERAL_INFORMATION *)&_source->General);
      break;
      }
    case AliasNameInformation :
      {
      _fgs__SAMPR_ALIAS_NAME_INFORMATION ((SAMPR_ALIAS_NAME_INFORMATION *)&_source->Name);
      break;
      }
    case AliasAdminCommentInformation :
      {
      _fgs__SAMPR_ALIAS_ADM_COMMENT_INFORMATION ((SAMPR_ALIAS_ADM_COMMENT_INFORMATION *)&_source->AdminComment);
      break;
      }
    }
  }

/* routine that frees graph for struct _SAMPR_USER_ALL_INFORMATION */
void _fgs__SAMPR_USER_ALL_INFORMATION (SAMPR_USER_ALL_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->UserName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->FullName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->HomeDirectory);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->HomeDirectoryDrive);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->ScriptPath);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->ProfilePath);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->AdminComment);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->WorkStations);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->UserComment);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Parameters);


  //
  // Password info should be zero'd before freeing.
  //

  //_fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->LmOwfPassword);

  SampFreeSensitiveUnicodeString((RPC_UNICODE_STRING *)&_source->LmOwfPassword);

  //_fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->NtOwfPassword);

  SampFreeSensitiveUnicodeString((RPC_UNICODE_STRING *)&_source->NtOwfPassword);

  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->PrivateData);
  _fgs__SAMPR_SR_SECURITY_DESCRIPTOR ((SAMPR_SR_SECURITY_DESCRIPTOR *)&_source->SecurityDescriptor);
  _fgs__SAMPR_LOGON_HOURS ((SAMPR_LOGON_HOURS *)&_source->LogonHours);
  }

/* routine that frees graph for struct _SAMPR_USER_INTERNAL3_INFORMATION */
void _fgs__SAMPR_USER_INTERNAL3_INFORMATION (SAMPR_USER_INTERNAL3_INFORMATION  * _source)
  {
  _fgs__SAMPR_USER_ALL_INFORMATION ((SAMPR_USER_ALL_INFORMATION *)&_source->I1);
  }

/* routine that frees graph for struct _SAMPR_USER_GENERAL_INFORMATION */
void _fgs__SAMPR_USER_GENERAL_INFORMATION (SAMPR_USER_GENERAL_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->UserName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->FullName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->AdminComment);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->UserComment);
  }

/* routine that frees graph for struct _SAMPR_USER_PREFERENCES_INFORMATION */
void _fgs__SAMPR_USER_PREFERENCES_INFORMATION (SAMPR_USER_PREFERENCES_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->UserComment);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Reserved1);
  }

/* routine that frees graph for struct _SAMPR_USER_PARAMETERS_INFORMATION */
void _fgs__SAMPR_USER_PARAMETERS_INFORMATION (SAMPR_USER_PARAMETERS_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Parameters);
  }

/* routine that frees graph for struct _SAMPR_USER_LOGON_INFORMATION */
void _fgs__SAMPR_USER_LOGON_INFORMATION (SAMPR_USER_LOGON_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->UserName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->FullName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->HomeDirectory);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->HomeDirectoryDrive);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->ScriptPath);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->ProfilePath);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->WorkStations);
  _fgs__SAMPR_LOGON_HOURS ((SAMPR_LOGON_HOURS *)&_source->LogonHours);
  }

/* routine that frees graph for struct _SAMPR_USER_ACCOUNT_INFORMATION */
void _fgs__SAMPR_USER_ACCOUNT_INFORMATION (SAMPR_USER_ACCOUNT_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->UserName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->FullName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->HomeDirectory);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->HomeDirectoryDrive);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->ScriptPath);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->ProfilePath);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->AdminComment);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->WorkStations);
  _fgs__SAMPR_LOGON_HOURS ((SAMPR_LOGON_HOURS *)&_source->LogonHours);
  }

/* routine that frees graph for struct _SAMPR_USER_A_NAME_INFORMATION */
void _fgs__SAMPR_USER_A_NAME_INFORMATION (SAMPR_USER_A_NAME_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->UserName);
  }

/* routine that frees graph for struct _SAMPR_USER_F_NAME_INFORMATION */
void _fgs__SAMPR_USER_F_NAME_INFORMATION (SAMPR_USER_F_NAME_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->FullName);
  }

/* routine that frees graph for struct _SAMPR_USER_NAME_INFORMATION */
void _fgs__SAMPR_USER_NAME_INFORMATION (SAMPR_USER_NAME_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->UserName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->FullName);
  }

/* routine that frees graph for struct _SAMPR_USER_HOME_INFORMATION */
void _fgs__SAMPR_USER_HOME_INFORMATION (SAMPR_USER_HOME_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->HomeDirectory);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->HomeDirectoryDrive);
  }

/* routine that frees graph for struct _SAMPR_USER_SCRIPT_INFORMATION */
void _fgs__SAMPR_USER_SCRIPT_INFORMATION (SAMPR_USER_SCRIPT_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->ScriptPath);
  }

/* routine that frees graph for struct _SAMPR_USER_PROFILE_INFORMATION */
void _fgs__SAMPR_USER_PROFILE_INFORMATION (SAMPR_USER_PROFILE_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->ProfilePath);
  }

/* routine that frees graph for struct _SAMPR_USER_ADMIN_COMMENT_INFORMATION */
void _fgs__SAMPR_USER_ADMIN_COMMENT_INFORMATION (SAMPR_USER_ADMIN_COMMENT_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->AdminComment);
  }

/* routine that frees graph for struct _SAMPR_USER_WORKSTATIONS_INFORMATION */
void _fgs__SAMPR_USER_WORKSTATIONS_INFORMATION (SAMPR_USER_WORKSTATIONS_INFORMATION  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->WorkStations);
  }

/* routine that frees graph for struct _SAMPR_USER_LOGON_HOURS_INFORMATION */
void _fgs__SAMPR_USER_LOGON_HOURS_INFORMATION (SAMPR_USER_LOGON_HOURS_INFORMATION  * _source)
  {
  _fgs__SAMPR_LOGON_HOURS ((SAMPR_LOGON_HOURS *)&_source->LogonHours);
  }

/* routine that frees graph for union _SAMPR_USER_INFO_BUFFER */
void _fgu__SAMPR_USER_INFO_BUFFER (SAMPR_USER_INFO_BUFFER  * _source, USER_INFORMATION_CLASS _branch)
  {
  switch (_branch)
    {
    case UserGeneralInformation :
      {
      _fgs__SAMPR_USER_GENERAL_INFORMATION ((SAMPR_USER_GENERAL_INFORMATION *)&_source->General);
      break;
      }
    case UserPreferencesInformation :
      {
      _fgs__SAMPR_USER_PREFERENCES_INFORMATION ((SAMPR_USER_PREFERENCES_INFORMATION *)&_source->Preferences);
      break;
      }
    case UserLogonInformation :
      {
      _fgs__SAMPR_USER_LOGON_INFORMATION ((SAMPR_USER_LOGON_INFORMATION *)&_source->Logon);
      break;
      }
    case UserLogonHoursInformation :
      {
      _fgs__SAMPR_USER_LOGON_HOURS_INFORMATION ((SAMPR_USER_LOGON_HOURS_INFORMATION *)&_source->LogonHours);
      break;
      }
    case UserAccountInformation :
      {
      _fgs__SAMPR_USER_ACCOUNT_INFORMATION ((SAMPR_USER_ACCOUNT_INFORMATION *)&_source->Account);
      break;
      }
    case UserNameInformation :
      {
      _fgs__SAMPR_USER_NAME_INFORMATION ((SAMPR_USER_NAME_INFORMATION *)&_source->Name);
      break;
      }
    case UserAccountNameInformation :
      {
      _fgs__SAMPR_USER_A_NAME_INFORMATION ((SAMPR_USER_A_NAME_INFORMATION *)&_source->AccountName);
      break;
      }
    case UserFullNameInformation :
      {
      _fgs__SAMPR_USER_F_NAME_INFORMATION ((SAMPR_USER_F_NAME_INFORMATION *)&_source->FullName);
      break;
      }
    case UserPrimaryGroupInformation :
      {
      break;
      }
    case UserHomeInformation :
      {
      _fgs__SAMPR_USER_HOME_INFORMATION ((SAMPR_USER_HOME_INFORMATION *)&_source->Home);
      break;
      }
    case UserScriptInformation :
      {
      _fgs__SAMPR_USER_SCRIPT_INFORMATION ((SAMPR_USER_SCRIPT_INFORMATION *)&_source->Script);
      break;
      }
    case UserProfileInformation :
      {
      _fgs__SAMPR_USER_PROFILE_INFORMATION ((SAMPR_USER_PROFILE_INFORMATION *)&_source->Profile);
      break;
      }
    case UserAdminCommentInformation :
      {
      _fgs__SAMPR_USER_ADMIN_COMMENT_INFORMATION ((SAMPR_USER_ADMIN_COMMENT_INFORMATION *)&_source->AdminComment);
      break;
      }
    case UserWorkStationsInformation :
      {
      _fgs__SAMPR_USER_WORKSTATIONS_INFORMATION ((SAMPR_USER_WORKSTATIONS_INFORMATION *)&_source->WorkStations);
      break;
      }
    case UserControlInformation :
      {
      break;
      }
    case UserExpiresInformation :
      {
      break;
      }
    case UserInternal1Information :
      {
      break;
      }
    case UserInternal2Information :
      {
      break;
      }
    case UserParametersInformation :
      {
      _fgs__SAMPR_USER_PARAMETERS_INFORMATION ((SAMPR_USER_PARAMETERS_INFORMATION *)&_source->Parameters);
      break;
      }
    case UserAllInformation :
      {
      _fgs__SAMPR_USER_ALL_INFORMATION ((SAMPR_USER_ALL_INFORMATION *)&_source->All);
      break;
      }
    case UserInternal3Information :
      {
      _fgs__SAMPR_USER_INTERNAL3_INFORMATION ((SAMPR_USER_INTERNAL3_INFORMATION *)&_source->Internal3);
      break;
      }
    }
  }

/* routine that frees graph for struct _SAMPR_DOMAIN_DISPLAY_USER */
void _fgs__SAMPR_DOMAIN_DISPLAY_USER (SAMPR_DOMAIN_DISPLAY_USER  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->LogonName);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->AdminComment);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->FullName);
  }

/* routine that frees graph for struct _SAMPR_DOMAIN_DISPLAY_MACHINE */
void _fgs__SAMPR_DOMAIN_DISPLAY_MACHINE (SAMPR_DOMAIN_DISPLAY_MACHINE  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Machine);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Comment);
  }

/* routine that frees graph for struct _SAMPR_DOMAIN_DISPLAY_GROUP */
void _fgs__SAMPR_DOMAIN_DISPLAY_GROUP (SAMPR_DOMAIN_DISPLAY_GROUP  * _source)
  {
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Group);
  _fgs__RPC_UNICODE_STRING ((RPC_UNICODE_STRING *)&_source->Comment);
  }

/* routine that frees graph for struct _SAMPR_DOMAIN_DISPLAY_USER_BUFFER */
void _fgs__SAMPR_DOMAIN_DISPLAY_USER_BUFFER (SAMPR_DOMAIN_DISPLAY_USER_BUFFER  * _source)
  {
  if (_source->Buffer !=0)
    {
      {
      unsigned long _sym32;
      for (_sym32 = 0; _sym32 < (unsigned long )(0 + _source->EntriesRead); _sym32++)
        {
        _fgs__SAMPR_DOMAIN_DISPLAY_USER ((SAMPR_DOMAIN_DISPLAY_USER *)&_source->Buffer[_sym32]);
        }
      }
    MIDL_user_free((void  *)(_source->Buffer));
    }
  }

/* routine that frees graph for struct _SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER */
void _fgs__SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER (SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER  * _source)
  {
  if (_source->Buffer !=0)
    {
      {
      unsigned long _sym38;
      for (_sym38 = 0; _sym38 < (unsigned long )(0 + _source->EntriesRead); _sym38++)
        {
        _fgs__SAMPR_DOMAIN_DISPLAY_MACHINE ((SAMPR_DOMAIN_DISPLAY_MACHINE *)&_source->Buffer[_sym38]);
        }
      }
    MIDL_user_free((void  *)(_source->Buffer));
    }
  }

/* routine that frees graph for struct _SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER */
void _fgs__SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER (SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER  * _source)
  {
  if (_source->Buffer !=0)
    {
      {
      unsigned long _sym44;
      for (_sym44 = 0; _sym44 < (unsigned long )(0 + _source->EntriesRead); _sym44++)
        {
        _fgs__SAMPR_DOMAIN_DISPLAY_GROUP ((SAMPR_DOMAIN_DISPLAY_GROUP *)&_source->Buffer[_sym44]);
        }
      }
    MIDL_user_free((void  *)(_source->Buffer));
    }
  }

/* routine that frees graph for union _SAMPR_DISPLAY_INFO_BUFFER */
void _fgu__SAMPR_DISPLAY_INFO_BUFFER (SAMPR_DISPLAY_INFO_BUFFER  * _source, DOMAIN_DISPLAY_INFORMATION _branch)
  {
  switch (_branch)
    {
    case DomainDisplayUser :
      {
      _fgs__SAMPR_DOMAIN_DISPLAY_USER_BUFFER ((SAMPR_DOMAIN_DISPLAY_USER_BUFFER *)&_source->UserInformation);
      break;
      }
    case DomainDisplayMachine :
      {
      _fgs__SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER ((SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER *)&_source->MachineInformation);
      break;
      }
    case DomainDisplayGroup :
      {
      _fgs__SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER ((SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER *)&_source->GroupInformation);
      break;
      }
    }
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\promote.c ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:

    promote.c

Abstract:

    This file contains the dll entrypoints that handle the SAM account
    transitions for promotion and demotion. See spec\nt5\ds\promote.doc
    and spec\nt5\ds\install.doc for high level details.


    Promotion
    ---------

    The following role transitions are supported by SAM

    Nt5 stand alone server -> Nt5 DC, first in new domain
    Nt5 member server      -> Nt5 DC, replica in existing domain

    Nt4 PDC upgrade        -> Nt5 DC, first in existing NT4 domain
    Nt5 BDC upgrade        -> Nt5 DC, replica in mixed domain

    The arrows are performed by initiated a promotion.

    Promotion is a two phase operation for SAM.

    Phase 1 is completed by SamIPromote().  It initializes the directory service,
    upgrades any existing security pricipals (creates new ones if necessary)
    and then leaves the directory service running so the LSA can do what it has
    to do to the ds and then the lsa shuts the directory service down.  Also
    a registry key is created so the function SampIsRebootAfterPromotion() can
    return TRUE on the next reboot.  SampIsRebootAfterPromotion() is called during
    SampInitialize() so SampPerformPromotePhase2() can be called.

    1) verifies the current enviroment supports the requested operation
      (listed above)

    2) initializes the ds, via SampDsInitialize()

    3)a) if this is a new domain, SamIPromote creates new Lsa Primary and
         Account domain information structures to define the new domain.  This
         involves creating a new guid.  SampInitializeRegistry() is then called
         with this information, and a new set of registry hives are created.
         These hives are then read, placed into the DS, and deleted.

      b) if this is an Nt4 PDC upgrade, the existing hives are placed into
         the DS

      c) all other cases are replica installs; nothing SAM wise is done here.

    4) create a well known registry key so SAM will know to perform phase 2
    after the reboot.  The function SampIsRebootAfterPromotion() is called from
    SampInitialize so phase2 can be performed.

    Phase 2, SampPerformPromotePhase2(), occurs on the reboot after
    SamIPromote() has successfully run. This phase does the following

    For the first dc in a domain:

    1) creates a (SAM) machine account for the server if one does not exist
    2) creates a krbtgt account (for the kerberos security system).  There is
    only one of these accounts per domain.

    For a replica dc in a domain:

    1) nothing!


    Demotion
    ________


    1) create a registry sam account database for either a standalone or
       member server


Author:

    Colin Brace    (ColinBr)  6-May-1997

Environment:

    User Mode - Nt

Revision History:

    ColinBrace        6-May-97
        Created initial file.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#include <stdlib.h>
#include <samsrvp.h>
#include <dslayer.h>
#include <dsconfig.h>
#include <ntverp.h>
#include <samisrv.h>
#include <dns.h>
#include <setupapi.h>
#include <attids.h>
#include <malloc.h>
#include <dsmember.h>
#include <pek.h>
#include <lmcons.h>
#include <logonmsv.h>
#include <cryptdll.h>
#include <Accctrl.h>
#include <Aclapi.h>
#include <seopaque.h>
#include <sddlp.h>       // SDDL_REVISION_1

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private declarations                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// This defines the currect role of the server
//
typedef enum
{
    SampMemberServer = 0,
    SampStandaloneServer,

    SampDownlevelPDC,         // downlevel means Nt4 and below
    SampDownlevelBDC,

    SampDSDC,                 // DSDC means NT5 and above DC

    SampInvalidRoleConfiguration

}SAMP_ROLE_CONFIGURATION, *PSAMP_ROLE_CONFIGURATION;

//
// Local constants
//

//
// Miscellaneous string values for saving and loading downlevel hives
//

// This is the hive created by SamISaveDownlevelDatabase by the replace
#define SAMP_DOWNLEVEL_DB_FILENAME         L"\\SAM.UPG"

// This is the new account database created in SamISaveDownlevelDatabase
#define SAMP_NEW_DB_FILENAME               L"\\SAM.TMP"

// This is the hive created by base nt setup - we use it as a backup
#define SAMP_DOWNLEVEL_DB_FILENAME_BACKUP  L"\\SAM.SAV"

// This is the registry key that is used to load the saved hive into the
// registry
#define SAMP_DOWNLEVEL_DB_KEYNAME          L"SAMUPGRADE"

//
// This is used to store the value name for the admin's password to be set
// during the reboot of a promoted server
//
#define SAMP_ADMIN_INFO_NAME L"AdminInfo"

//
// This is used to store the ds directories to be deleted after a demote
//
#define SAMP_DS_DIRS_INFO_NAME L"DsDirs"

//
// This is the location of where information that SAM needs at the next reboot
// is keep (in the registry)
//
#define SAMP_REBOOT_INFO_KEY  L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\SAMSS"

//
// Password for krbtgt account
//

WCHAR DOMAIN_KRBTGT_ACCOUNT_NAME_W[] = L"krbtgt";

//
// These strings exist in case the resource retrieval fails
//
WCHAR SampDefaultKrbtgtWarningString[] =
     L"The account krbtgt was renamed to %ws to allow NT5 Kerberos to install.";

WCHAR SampDefaultKrbtgtCommentString[] =
     L"Key Distribution Center Service Account";

WCHAR SampDefaultBlankAdminPasswordWarningString[] =
    L"Setting the administrator's password to the string you specified failed.\
      Upon reboot the password will be blank; please reset once logged on.";

VOID
BuildStdCommArg(
    IN OUT COMMARG * pCommArg
    );

NTSTATUS
SampMapDsErrorToNTStatus(
    ULONG   DsRetVal,
    COMMRES *ComRes
    );

NTSTATUS
SampCheckPromoteEnvironment(
    IN  ULONG PromoteFlags
    );

NTSTATUS
SampCreateFirstMachineAccount(
    IN SAMPR_HANDLE DomainHandle
    );

NTSTATUS
SampAddWellKnownAccounts(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMPR_HANDLE BuiltinDomainHandle,
    IN ULONG        Flags
    );

NTSTATUS
SampApplyWellKnownMemberships(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMPR_HANDLE BuiltinDomainHandle,
    IN PSID         DomainSid,
    IN ULONG        Flags
    );

NTSTATUS
SampAddAnonymousOrAuthUsersToPreW2KCompAlias(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMPR_HANDLE BuiltinDomainHandle
    );

NTSTATUS
SampAddAccountsAndApplyMemberships(
    IN SAMPR_HANDLE AccountDomainHandle,
    IN SAMPR_HANDLE BuiltinDomainHandle,
    IN PSID         DomainSid,
    IN ULONG        PromoteFlags
    );


NTSTATUS
SampCreateKeyForPostBootPromote(
    IN ULONG PromoteFlags
    );

NTSTATUS
SampRetrieveKeyForPostBootPromote(
    OUT PULONG PromoteFlags
    );

NTSTATUS
SampDeleteKeyForPostBootPromote(
    VOID
    );

NTSTATUS
SampSetPassword(
    IN SAMPR_HANDLE    UserHandle,
    IN PUNICODE_STRING AccountName,
    IN ULONG           AccountRid, OPTIONAL
    IN WCHAR          *Password
    );

NTSTATUS
SampPerformFirstDcPromotePhase2(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMPR_HANDLE BuiltinDomainHandle,
    IN ULONG        Flags
    );

NTSTATUS
SampPerformReplicaDcPromotePhase2(
    SAMPR_HANDLE DomainHandle
    );

NTSTATUS
SampRegistryDelnode(
    IN WCHAR* KeyPath
    );

NTSTATUS
SampRenameKrbtgtAccount(
    VOID
    );

WCHAR*
SampGetKrbtgtRenameWarning(
    WCHAR* NewName
    );

WCHAR*
SampGetKrbtgtCommentString(
    VOID
    );


NTSTATUS
SampSetAdminPasswordInRegistry(
    IN BOOLEAN         fUseCurrentAdmin,
    IN PUNICODE_STRING Password
    );


NTSTATUS
SampSetAdminPassword(
    IN SAMPR_HANDLE DomainHandle
    );

NTSTATUS
SampRemoveAdminPasswordFromRegistry(
    VOID
    );

NTSTATUS
SampPerformNewServerPhase2(
    SAMPR_HANDLE DomainHandle,
    BOOLEAN      fMemberServer
    );

NTSTATUS
SampPerformTempUpgradeWork(
    SAMPR_HANDLE DomainHandle
    );

WCHAR*
SampGetBlankAdminPasswordWarning(
    VOID
    );

NTSTATUS
SampSetSingleWellKnownAccountMembership(
    IN HANDLE            AccountHandle,
    IN SAMP_OBJECT_TYPE  GroupType,  // group or alias
    IN PSID              GroupSid
    );

NTSTATUS
SampStoreDsDirsToDelete(
    VOID
    );

NTSTATUS
SampProcessDsDirsToDelete(
    IN WCHAR *pPathArray,
    IN DWORD  Size
    );

NTSTATUS
SampCreateDsDirsToDeleteKey(
    IN WCHAR *PathArray,
    IN DWORD Size
    );

NTSTATUS
SampRetrieveDsDirsToDeleteKey(
    OUT WCHAR **PathArray,
    OUT DWORD *Size
    );

NTSTATUS
SampDeleteDsDirsToDeleteKey(
    VOID
    );

DWORD
SampClearDirectory(
    IN WCHAR *DirectoryName
    );

DWORD
SampSetMachineAccountSecret(
    LPWSTR SecretValue
    );

NTSTATUS
SampAddEnterpriseAdminsToAdministrators(
    VOID
    );

NTSTATUS
SampSetSafeModeAdminPassword(
    VOID
    );

//
// from dsupgrad/convert.cxx
//

NTSTATUS
GetRdnForSamObject(IN WCHAR* SamAccountName,
                   IN SAMP_OBJECT_TYPE SampObjectType,
                   OUT WCHAR* RdnBuffer,
                   IN OUT ULONG* Size
                   );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Routines                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
NTSTATUS
SamIGetDefaultComputersContainer(
    OUT PVOID *DefaultComputersContainer
    )
/*++

Description:

    This routine performs will return the Dsname of the
    default computers container.

Parameters:

    DefaultComputersContainer :  Will return a pointer to the DsName
                                 of the default computers container.
                                 Needs to be free'd by the caller

Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    if (!SampUseDsData)
    {
        return STATUS_NOT_SUPPORTED;
    }

    ASSERT(DefaultComputersContainer);
    ASSERT(SampComputersContainerDsName);

    *DefaultComputersContainer = LocalAlloc(0,
                                            SampComputersContainerDsName->structLen);
    if (!*DefaultComputersContainer) {

        status = STATUS_NO_MEMORY;
        goto Cleanup;

    }

    memcpy(*DefaultComputersContainer,
           SampComputersContainerDsName,
           SampComputersContainerDsName->structLen);

Cleanup:

    if (*DefaultComputersContainer && !NT_SUCCESS(status)) {

        LocalFree(*DefaultComputersContainer);
        *DefaultComputersContainer = NULL;

    }

    return status;
}


NTSTATUS
SamIPromote(
    IN  ULONG                        PromoteFlags,
    IN  PPOLICY_PRIMARY_DOMAIN_INFO  NewPrimaryDomainInfo  OPTIONAL,
    IN  PUNICODE_STRING              AdminPassword         OPTIONAL,
    IN  PUNICODE_STRING              SafeModeAdminPassword OPTIONAL
    )
/*++

Description:

    This routine performs phase 1 of a promotion.  See module header
    for more details.

Parameters:

    PromoteFlags            : Flags indicating the type of the promotion

    NewPrimaryDomainInfo    : new security information, if PrincipalAction is
                              to create new security principals

    AdminPassword           : password for new domain;

    SafeModeAdminPassword   : password for safe mode boot: NOT CURRENTLY SUPPORTED

Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_INVALID_SERVER_STATE - illegal promotion was requested

--*/
{
    NTSTATUS NtStatus, IgnoreStatus;
    DWORD    WinError;
    DWORD    hRes = S_OK;

    OBJECT_ATTRIBUTES TempSamKey;
    UNICODE_STRING    TempSamKeyName;
    HANDLE            TempSamKeyHandle;

    WCHAR             wszLocalMachineName[MAX_COMPUTERNAME_LENGTH+2]; // need +1 for NULL and +1 for L'$'
    DWORD             cchLocalMachineName = MAX_COMPUTERNAME_LENGTH+1;
    UNICODE_STRING    LocalMachineName;

    NT_PRODUCT_TYPE        DatabaseProductType;
    POLICY_LSA_SERVER_ROLE DatabaseServerRole;

    POLICY_ACCOUNT_DOMAIN_INFO  NewAccountDomainInfo;

    PSID                   Sid;

    WCHAR                 *WarningString = NULL;
    BOOLEAN                fStatus;

    WCHAR                 SamUpgradeKeyPath[ MAX_PATH +1 ];


    SAMTRACE_EX("SamIPromote");

    //
    // If the SAM server is not initialized, reject this call
    //

    if (SampServiceState != SampServiceEnabled) {

        return(STATUS_INVALID_SERVER_STATE);
    }

    //
    // Parameter checks
    //

    //
    // check to make sure that the local computer name is not a reserved LSA name.
    //

    if (!GetComputerNameEx(ComputerNameNetBIOS,
                           wszLocalMachineName,
                           &cchLocalMachineName))
    {
        if ( GetLastError() == ERROR_MORE_DATA ) {

            return STATUS_BUFFER_OVERFLOW;

        } else {

            return STATUS_UNSUCCESSFUL;

        }

    }

    RtlInitUnicodeString(&LocalMachineName,wszLocalMachineName);

    if (LsaILookupWellKnownName(&LocalMachineName))
    {
        return STATUS_DS_NAME_NOT_UNIQUE;
    }

    //
    //add a L'$' to the end of the string
    //
    hRes = StringCchCatW(wszLocalMachineName,
                         sizeof(wszLocalMachineName)/sizeof(WCHAR),
                         L"$");
    ASSERT(SUCCEEDED(hRes));
    if (FAILED(hRes)) {

        return STATUS_UNSUCCESSFUL;

    }

    //
    // look for the name again with a $ at the end of it.
    //
    RtlInitUnicodeString(&LocalMachineName,wszLocalMachineName);

    if (LsaILookupWellKnownName(&LocalMachineName))
    {
        return STATUS_DS_NAME_NOT_UNIQUE;
    }

    //
    // Make sure we are in an environment that we can handle.  Also determine
    // the role configuration
    //
    NtStatus = SampCheckPromoteEnvironment(PromoteFlags);
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampCheckPromoteEnvironment failed with 0x%x\n",
                   NtStatus));

        return NtStatus;
    }

    //
    // We are in a state that we understand, and the requested operation
    // is valid.  Attempt to create the security principals
    //
    NtStatus = STATUS_UNSUCCESSFUL;

    if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_REPLICA ) )
    {
        //
        // Replica install, nothing to do
        //
        NtStatus = STATUS_SUCCESS;
    }
    else if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_UPGRADE ) )
    {
        //
        // Set the global variable
        //
        SampNT4UpgradeInProgress = TRUE;

        //
        // Use the previously saved off hives
        //

        //
        // Create the key name
        //
        wcscpy( SamUpgradeKeyPath, L"\\Registry\\Machine\\" );
        wcscat( SamUpgradeKeyPath, SAMP_DOWNLEVEL_DB_KEYNAME );
        wcscat( SamUpgradeKeyPath, L"\\SAM" );

        //
        // Use the existing downlevel hives
        //
        NtStatus = SampRegistryToDsUpgrade( SamUpgradeKeyPath );


        //
        // Unload the hive
        //
        IgnoreStatus = SamIUnLoadDownlevelDatabase( NULL );
        ASSERT( NT_SUCCESS( IgnoreStatus ) );

        //
        // turn off it
        //
        SampNT4UpgradeInProgress = FALSE;

        if ( !NT_SUCCESS(NtStatus) ) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampRegistryToDsUpgrade failed with 0x%x\n",
                       NtStatus));

            return NtStatus;
        }

    } else if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_MIGRATE ) )
    {
        //
        // Prepare the current hives
        //
        NtStatus = SampRenameKrbtgtAccount();

        if ( !NT_SUCCESS(NtStatus) ) {

            //
            // This is not a fatal error
            //
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampRenameKrbtgtAccount failed with 0x%x\n",
                       NtStatus));

            NtStatus = STATUS_SUCCESS;
        }

        NtStatus = NtFlushKey( SampKey );
        if ( !NT_SUCCESS( NtStatus ) )
        {
            //
            // This is not a fatal error
            //
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "NtFlushKey returned 0x%x\n",
                       NtStatus));

            NtStatus = STATUS_SUCCESS;
        }

        NtStatus = SampRegistryToDsUpgrade( L"\\Registry\\Machine\\SAM\\SAM" );

        if ( !NT_SUCCESS(NtStatus) )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampRegistryToDsUpgrade failed with 0x%x\n",
                       NtStatus));

            return NtStatus;
        }

    } else if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_CREATE ))
    {
        //
        // Create new domain hives
        //

        //
        // Make sure there is nothing in the temporary location
        //
        RtlInitUnicodeString(&TempSamKeyName, L"\\Registry\\Machine\\SAM\\NT5");
        InitializeObjectAttributes(&TempSamKey,
                                   &TempSamKeyName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        NtStatus = NtOpenKey(&TempSamKeyHandle,
                             KEY_ALL_ACCESS,
                             &TempSamKey);

        if ( NT_SUCCESS(NtStatus) ) {
            //
            // There is something here - delete it
            //
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Deleting keys under SAM\\NT5\n"));

            NtClose(TempSamKeyHandle);

            NtStatus = SampRegistryDelnode(TempSamKeyName.Buffer);

            if (!NT_SUCCESS(NtStatus)) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: Deletion failed; erroring out\n"));

                return NtStatus;
            }
        }

        DatabaseProductType = NtProductLanManNt;

        //
        // We are the first DC in this domain so make us the primary
        //
        DatabaseServerRole  = PolicyServerRolePrimary;

        //
        // Make the account domain information the same as the
        // primary domain information
        //
        NewAccountDomainInfo.DomainSid = NewPrimaryDomainInfo->Sid;
        NewAccountDomainInfo.DomainName = NewPrimaryDomainInfo->Name;

        //
        // Now create the temporary set of hives
        //
        NtStatus = SampInitializeRegistry(L"\\Registry\\Machine\\SAM\\NT5",
                                          &DatabaseProductType,
                                          &DatabaseServerRole,
                                          &NewAccountDomainInfo,
                                          NewPrimaryDomainInfo,
                                          FALSE
                                          );


        __try
        {

            if (NT_SUCCESS(NtStatus)) {

                //
                // Now transfer these new accounts into the ds
                //

                NtStatus = SampRegistryToDsUpgrade(L"\\Registry\\Machine\\SAM\\NT5\\SAM");
                if (!NT_SUCCESS(NtStatus)) {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: SampRegistryToDsUpgrade failed with 0x%x\n",
                               NtStatus));
                }

            } else {

                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: SampInitializeRegistry failed with 0x%x\n",
                           NtStatus));
            }

        }
        __finally
        {
            //
            // Delete the temporary hive
            //
            IgnoreStatus = SampRegistryDelnode(TempSamKeyName.Buffer);

            if (!NT_SUCCESS(IgnoreStatus)) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: Deletion of temporary hive failed 0x%x; \n",
                           IgnoreStatus));
            }

        }
    } else
    {
        return STATUS_INVALID_PARAMETER;
    }

    if ( NT_SUCCESS(NtStatus) ) {

        UNICODE_STRING p;
        BOOLEAN fUseCurrentAdmin = ((PromoteFlags & SAMP_PROMOTE_DFLT_REPAIR_PWD)
                                   ? TRUE : FALSE);


        //
        // Ok, the principals are in the ds - now set the user supplied
        // admin password if supplied - it will be blank otherwise
        //

        //
        // N.B.  There should always be a value written to the registry
        // this will help determine if the database needs to be
        // recreated
        //

        if ( SafeModeAdminPassword ) {

            RtlCopyMemory( &p, SafeModeAdminPassword, sizeof(UNICODE_STRING) );

        } else {

            RtlSecureZeroMemory( &p, sizeof(UNICODE_STRING) );

        }


        //
        // Setting the password is a difficult operation here because it
        // needs to be set in the ds, but sam is not running on the ds.
        // So, we take the clear text password, owf it and store a blob
        // in the registry containing the owf'ed password.  Upon reboot,
        // this blob will be read in and then set on the admin account
        // just before SamIInitialize() returns.
        //

        NtStatus = SampSetAdminPasswordInRegistry(fUseCurrentAdmin,
                                                  &p);

        if ( !NT_SUCCESS(NtStatus) ) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Unable to save admin password 0x%x; \n",
                       NtStatus));

            //
            // Fail the call.  This is a bit harsh but there is
            // no way to tell the user to use a blank password.
            // The call to set the admin password is not expected
            // to fail.  The password most likely could not
            // be owf'ed.  Encourage the user to try another.
            //
            NtStatus = STATUS_ILL_FORMED_PASSWORD;

        } // set password failed

    } // there is a password to set


    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Everything completed successfully; prepare for phase 2
        // on the next reboot
        //
        NtStatus =  SampCreateKeyForPostBootPromote(PromoteFlags);
        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampCreateKeyForPostBootPromote failed with 0x%x\n",
                       NtStatus));
        }

    }


    return NtStatus;
}


NTSTATUS
SamIPromoteUndo(
    VOID
    )
/*++

Description:

    This routine undoes any persistent data left by SamIPromote.

Parameters:

    None

Return Values:

    An ntstatus resulting from a failure system service

--*/
{
    NTSTATUS NtStatus;

    NtStatus = SampDeleteKeyForPostBootPromote();
    if ( !NT_SUCCESS( NtStatus ) ) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampRemoveKeyForPostBootPromote failed with 0x%x\n",
                   NtStatus));
    }

    NtStatus = SampRemoveAdminPasswordFromRegistry();
    if ( !NT_SUCCESS( NtStatus ) ) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampRemoveAdminPasswordFromRegistry failed with 0x%x\n",
                   NtStatus));
    }



    return STATUS_SUCCESS;
}


NTSTATUS
SamIDemote(
    IN DWORD                        DemoteFlags,
    IN PPOLICY_ACCOUNT_DOMAIN_INFO  NewAccountDomainInfo,
    IN LPWSTR                       AdminPassword  OPTIONAL
    )
/*++

Description:

    This routine prepares SAM to use the registry as its database on the next reboot.

Parameters:

    fLastDcInDomain:  if TRUE then prepare for standalone; otherwise member server

    AdminPassword  :  the admin password upon reboot

    NewAccountDomainInfo :  the identification of the new domain

Return Values:

    An ntstatus resulting from a failure system service

--*/
{
    NTSTATUS               NtStatus = STATUS_SUCCESS;
    UNICODE_STRING         Password;

    //
    // Parameter checks
    //
    if ( !NewAccountDomainInfo )
    {
        //
        // Unused for now
        //
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: Bad parameter to SamIDemote\n" ));

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Sanity check that we are really using the ds
    //
    ASSERT( SampUsingDsData() );

    //
    // Set the admin password  RtlInitUnicodeStringEx
    //
    NtStatus = RtlInitUnicodeStringEx( &Password, AdminPassword );
    if ( !NT_SUCCESS(NtStatus) ) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampSetAdminPasswordInRegistry failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    NtStatus =  SampSetAdminPasswordInRegistry( FALSE, &Password );
    if ( !NT_SUCCESS(NtStatus) ) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampSetAdminPasswordInRegistry failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    //
    // Save off the ds paths to delete
    //
    NtStatus = SampStoreDsDirsToDelete();
    if ( !NT_SUCCESS(NtStatus) ) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampStoreDsDirsToDelete failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    NtStatus = SampCreateKeyForPostBootPromote( DemoteFlags );
    if ( !NT_SUCCESS(NtStatus) ) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampCreateKeyForPostBootPromote failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    //
    // Ok, make sure all current clients have left and then disable SAM
    //
    NtStatus = SampAcquireWriteLock();
    ASSERT( NT_SUCCESS( NtStatus ) );

    //
    // No more clients allowed
    //
    SampServiceState = SampServiceDemoted;

    SampReleaseWriteLock( FALSE );


Cleanup:

    if ( !NT_SUCCESS( NtStatus ) )
    {
        // leave no traces
        SampRemoveAdminPasswordFromRegistry();
        SampDeleteDsDirsToDeleteKey();
        SampDeleteKeyForPostBootPromote();
    }

    return NtStatus;
}


NTSTATUS
SamIDemoteUndo(
    VOID
    )
/*++

Routine Description

    This routine undoes the effect of SamIDemote.

    Currently this means:

    o   Removing the "subsequent boot key"
    o   Removing the admin password stored in the registry
    o   Removing the ds directories to delete

Parameters

    None.

Return Values

    STATUS_SUCCESS, if if an error occurs, the function still continues cleaning
    up as best it can.

--*/
{
    NTSTATUS NtStatus;

    //
    // Keys for managing the registry database
    //
    UNICODE_STRING         SamKeyName;
    OBJECT_ATTRIBUTES      SamKey;
    HANDLE                 SamKeyHandle;

    //
    // Remove the post boot key
    //
    NtStatus =  SampDeleteKeyForPostBootPromote();
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampDeleteKeyForPostBootPromote failed with 0x%x\n",
                   NtStatus));
    }
    ASSERT(NT_SUCCESS(NtStatus));

    // Continue on, regardless of error
    NtStatus = STATUS_SUCCESS;

    //
    // Remove the admin temporarily stored in the registry
    //
    NtStatus = SampRemoveAdminPasswordFromRegistry();
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampRemoveAdminPasswordFromRegistry failed with 0x%x\n",
                   NtStatus));

    }

    NtStatus = SampDeleteDsDirsToDeleteKey();
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampDeleteDsDirsToDeleteKey failed with 0x%x\n",
                   NtStatus));
    }

    // Continue on, regardless of error
    NtStatus = STATUS_SUCCESS;


    //
    // Turn SAM back on
    //
    SampServiceState = SampServiceEnabled;

    return NtStatus;
}


BOOL
SampIsRebootAfterPromotion(
    OUT PULONG PromoteData
    )
/*++

Routine Description

    This routine checks to see if a particular key exists, created by SamIPromote,
    to determine if the current boot sequence is the one just after the ds
    in installed.

Parameters

    PromoteData  : this will hold whatever value was stored in the key

Return Values

    TRUE if such a key was found; FALSE otherwise


--*/
{
    NTSTATUS NtStatus;

    ASSERT(PromoteData);
    *PromoteData = 0;

    NtStatus =  SampRetrieveKeyForPostBootPromote( PromoteData );

    if ( NT_SUCCESS(NtStatus) )
    {
        //
        // Make sure the promote data matches what we think we
        // should be doing
        //
        if (  FLAG_ON( (*PromoteData), SAMP_PROMOTE_DOMAIN )
           || FLAG_ON( (*PromoteData), SAMP_PROMOTE_REPLICA ) )
        {
            //
            // We think we are the reboot after a promotion
            //
            if ( SampProductType == NtProductLanManNt )
            {
                return TRUE;
            }

            //
            // Even if Ds Repair mode there is work to do --
            // namely setting the ds repair admin password
            //
            if ( (SampProductType == NtProductServer)
              &&  LsaISafeMode()  ) {

                return TRUE;

            }
        }
        else if (  FLAG_ON( (*PromoteData), SAMP_DEMOTE_STANDALONE )
                || FLAG_ON( (*PromoteData), SAMP_DEMOTE_MEMBER ) )
        {
            //
            // This is a reboot after demotion
            //
            if ( SampProductType == NtProductServer )
            {
                return TRUE;
            }
        }
        else if ( FLAG_ON( (*PromoteData), SAMP_TEMP_UPGRADE ) )
        {
            //
            // This is a reboot after gui mode setup of nt4 upgrade
            //
            if ( SampProductType == NtProductServer )
            {
                return TRUE;
            }
        }

    }

    return FALSE;

}


NTSTATUS
SamIReplaceDownlevelDatabase(
    IN  PPOLICY_ACCOUNT_DOMAIN_INFO  NewAccountDomainInfo,
    IN  LPWSTR                       NewAdminPassword,
    OUT ULONG                        *ExtendedWinError OPTIONAL
    )
/*++

Routine Description:

    This routine prepares the currently loaded pre-nt5 dc hive to be upgraded
    for the ds in nt5.  Currently this means, renaming any account with
    the name "krbtgt" and then saving the hive off to a file.

    N.B. This function was delibrately not split up into helper functions
    for debugging ease.

Parameters:

    NewAccountDomainInfo : non null pointer to the new account domain info

    NewAdminPassword: the password for the new admin account

    ExtendedWinError : on error the win32 error that caused the problem

Return Values:

    STATUS_SUCCESS, or system service error.

--*/
{
    NTSTATUS NtStatus, IgnoreStatus;
    DWORD    WinError, IgnoreWinError;
    BOOL     fStatus;

    WCHAR    DownLevelDatabaseFilePath[ MAX_PATH +1 ];
    WCHAR    NewDatabaseFilePath[ MAX_PATH +1 ];

    WCHAR*   FileName = SAMP_DOWNLEVEL_DB_FILENAME;
    WCHAR*   NewFileName = SAMP_NEW_DB_FILENAME;

    WCHAR*   SystemRoot = L"systemroot";
    WCHAR*   ConfigDirectoryPath = L"\\system32\\config";

    WCHAR    SystemRootPath[ MAX_PATH +1 ];
    ULONG    Size;

    NT_PRODUCT_TYPE             DatabaseProductType = NtProductServer;
    POLICY_LSA_SERVER_ROLE      DatabaseServerRole  = PolicyServerRolePrimary;
    POLICY_PRIMARY_DOMAIN_INFO  NewPrimaryDomainInfo;

    HKEY KeyHandle;

    BOOLEAN  fWasEnabled;

    UNICODE_STRING  AdminPassword;

    SAMTRACE_EX( "SamISaveDownlevelDatabase" );

    //
    // Clear the extended error
    //
    WinError = ERROR_SUCCESS;

    //
    // Parameter sanity check
    //
    if ( !NewAccountDomainInfo )
    {
        *ExtendedWinError = ERROR_INVALID_PARAMETER;
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Environment sanity check
    //
    if ( !SampIsDownlevelDcUpgrade() )
    {
        *ExtendedWinError = ERROR_INVALID_SERVER_STATE;
        return STATUS_INVALID_SERVER_STATE;
    }

    //
    // Construct the file names
    //
    RtlSecureZeroMemory( SystemRootPath, sizeof( SystemRootPath ) );
    Size = sizeof( SystemRootPath ) / sizeof(WCHAR) ;
    Size = GetEnvironmentVariable( SystemRoot,
                                   SystemRootPath,
                                   Size );

    RtlSecureZeroMemory( DownLevelDatabaseFilePath, sizeof(DownLevelDatabaseFilePath) );
    wcscpy( DownLevelDatabaseFilePath, SystemRootPath );
    wcscat( DownLevelDatabaseFilePath, ConfigDirectoryPath );
    wcscat( DownLevelDatabaseFilePath, FileName );

    wcscpy( NewDatabaseFilePath, SystemRootPath );
    wcscat( NewDatabaseFilePath, ConfigDirectoryPath );
    wcscat( NewDatabaseFilePath, NewFileName );

    //
    // Delete any previous versions of the files
    //
    fStatus = DeleteFile( DownLevelDatabaseFilePath );

    if ( !fStatus )
    {
        WinError = GetLastError();
        if ( ERROR_FILE_NOT_FOUND != WinError )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "Delete File failed with %d\n",
                       GetLastError()));
        }
        //
        // Oh well, continue on
        //
        WinError = ERROR_SUCCESS;

    }

    fStatus = DeleteFile( NewDatabaseFilePath );

    if ( !fStatus )
    {
        WinError = GetLastError();
        if ( ERROR_FILE_NOT_FOUND != WinError )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "Delete File failed with %d\n",
                       GetLastError()));
        }
        //
        // Oh well, continue on
        //
        WinError = ERROR_SUCCESS;
    }

    //
    // Prepare the downlevel hive to be saved off
    //

    //
    //  First rename any krbtgt accounts
    //
    NtStatus = SampRenameKrbtgtAccount();
    if ( !NT_SUCCESS(NtStatus) ) {

        //
        // This is not a fatal error
        //
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampRenameKrbtgtAccount failed with 0x%x\n",
                   NtStatus));

        NtStatus = STATUS_SUCCESS;
    }

    //
    // Make sure the current handle to the database is valid
    //
    ASSERT( SampKey && (INVALID_HANDLE_VALUE != SampKey) );

    //
    // Flush any outstanding changes
    //
    NtStatus = NtFlushKey( SampKey );
    if ( !NT_SUCCESS( NtStatus ) )
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "NtFlushKey returned 0x%x\n",
                   NtStatus));

        NtStatus = STATUS_SUCCESS;
    }

    //
    // Prepare the new member server account database
    //
    IgnoreStatus = SampRegistryDelnode( L"\\Registry\\Machine\\SOFTWARE\\TEMPSAM" );

    //
    // If we are syskeyed DC, we call SampInitializeRegistry with the flag
    // to let us know that we need to preserve the Syskey settings. This results
    // in persisting a flag indicating that we need to hold the syskey in memory
    // next time at reboot and also copying our current syskey type into the new
    // database.
    //

    NtStatus = SampInitializeRegistry(L"\\Registry\\Machine\\SOFTWARE\\TEMPSAM",
                                      &DatabaseProductType,
                                      &DatabaseServerRole,
                                      NewAccountDomainInfo,
                                      NULL,
                                      SampSecretEncryptionEnabled
                                     );  // call into lsa to the primary domain info

    if ( NT_SUCCESS( NtStatus ) )
    {
        //
        // Open a handle to the key
        //
        WinError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                 L"SOFTWARE\\TEMPSAM",
                                 0,  // reserved
                                 KEY_ALL_ACCESS,
                                 &KeyHandle );

        if ( ERROR_SUCCESS == WinError )
        {
            //
            // Save the hive
            //

            IgnoreStatus = RtlAdjustPrivilege( SE_BACKUP_PRIVILEGE,
                                               TRUE,           // Enable
                                               FALSE,          // not client; process wide
                                               &fWasEnabled );
            ASSERT( NT_SUCCESS( IgnoreStatus ) );

            WinError = RegSaveKey( KeyHandle,
                                   NewDatabaseFilePath,
                                   NULL );

            IgnoreStatus = RtlAdjustPrivilege( SE_BACKUP_PRIVILEGE,
                                               FALSE,          // Disable
                                               FALSE,          // not client; process wide
                                               &fWasEnabled );
            ASSERT( NT_SUCCESS( IgnoreStatus ) );

            //
            // We no longer need an open key
            //
            IgnoreWinError = RegCloseKey( KeyHandle );
            ASSERT( IgnoreWinError == ERROR_SUCCESS );

            if ( ERROR_SUCCESS == WinError )
            {

                //
                // Replace the SAM key with the SAM hive
                //
                IgnoreStatus = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                                   TRUE,           // Enable
                                                   FALSE,          // not client; process wide
                                                   &fWasEnabled );
                ASSERT( NT_SUCCESS( IgnoreStatus ) );

                WinError = RegReplaceKey( HKEY_LOCAL_MACHINE,
                                          L"SAM",
                                          NewDatabaseFilePath,
                                          DownLevelDatabaseFilePath );

                IgnoreStatus = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                                   FALSE,          // Disable
                                                   FALSE,          // not client; process wide
                                                   &fWasEnabled );
                ASSERT( NT_SUCCESS( IgnoreStatus ) );

                if ( ERROR_SUCCESS != WinError )
                {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "RegReplaceKey returned %d\n",
                               WinError));
                }
            }
            else
            {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "RegSaveKey returned %d\n",
                           WinError));
            }

            //
            // Delete the temporary hive
            //
            IgnoreStatus = SampRegistryDelnode( L"\\Registry\\Machine\\SOFTWARE\\TEMPSAM" );

        }
        else
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "RegOpenKeyEx returned %d\n",
                       WinError));
        }

        if ( ERROR_SUCCESS != WinError )
        {
            NtStatus = STATUS_UNSUCCESSFUL;
        }
    }
    else
    {
        WinError = RtlNtStatusToDosError( NtStatus );
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SampInitializeRegistry returned 0x%x\n",
                   NtStatus));
    }

    if ( NT_SUCCESS( NtStatus ) && NewAdminPassword )
    {
        NtStatus = RtlInitUnicodeStringEx( &AdminPassword, NewAdminPassword );

        if ( NT_SUCCESS(NtStatus) ) {

            NtStatus = SampSetAdminPasswordInRegistry( FALSE, &AdminPassword );

            if ( NT_SUCCESS( NtStatus ) )
            {
                NtStatus = SampCreateKeyForPostBootPromote( SAMP_TEMP_UPGRADE );
            }
        }

        WinError = RtlNtStatusToDosError( NtStatus );
    }

    //
    // Done
    //
    if ( ExtendedWinError )
    {
        *ExtendedWinError = WinError;
    }

    return NtStatus;
}


NTSTATUS
SamILoadDownlevelDatabase(
    OUT ULONG *ExtendedWinError OPTIONAL
    )
/*++

Routine Description:

    This routine attempts to load the hive saved off by
    SamILoadDownlevelDatabase.

Parameters:

    ExtendedWinError : on error the win32 error that caused the problem

Return Values:

    STATUS_INVALID_SERVER_STATE, STATUS_SUCCESS, or system service error.

--*/
{


    NTSTATUS NtStatus, IgnoreStatus;
    DWORD    WinError;
    BOOL     fStatus;

    WCHAR    FilePath[ MAX_PATH ];
    WCHAR    BackupFilePath[ MAX_PATH ];

    WCHAR*   FileName = SAMP_DOWNLEVEL_DB_FILENAME;
    WCHAR*   BackupFileName = SAMP_DOWNLEVEL_DB_FILENAME_BACKUP;

    WCHAR*   SystemRoot = L"systemroot";
    WCHAR*   ConfigDirectoryPath = L"\\system32\\config";

    WCHAR    SystemRootPath[ MAX_PATH ];
    ULONG    Size;

    WCHAR*   SamUpgradeKey = SAMP_DOWNLEVEL_DB_KEYNAME;
    WCHAR    SamUpgradeKeyPath[ MAX_PATH ];


    BOOLEAN        fWasEnabled;

    SAMTRACE_EX( "SamILoadDownlevelDatabase" );

    wcscpy( SamUpgradeKeyPath, L"\\Registry\\Machine\\" );
    wcscat( SamUpgradeKeyPath, SamUpgradeKey );

    //
    // Delete any old info in registry
    //
    NtStatus = SampRegistryDelnode( SamUpgradeKeyPath );
    if (   !NT_SUCCESS( NtStatus )
        && STATUS_OBJECT_NAME_NOT_FOUND != NtStatus )
    {
        //
        // Oh well, try to continue on
        //
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SampRegistryDelnode failed with 0x%x\n",
                   NtStatus));

    }
    NtStatus = STATUS_SUCCESS;

    //
    // Construct the file names
    //
    RtlSecureZeroMemory( SystemRootPath, sizeof( SystemRootPath ) );
    Size = sizeof( SystemRootPath ) / sizeof(WCHAR);
    Size = GetEnvironmentVariable( SystemRoot,
                                   SystemRootPath,
                                   Size );

    RtlSecureZeroMemory( FilePath, sizeof(FilePath) );
    wcscpy( FilePath, SystemRootPath );
    wcscat( FilePath, ConfigDirectoryPath );
    wcscat( FilePath, FileName );

    RtlSecureZeroMemory( BackupFilePath, sizeof(BackupFilePath) );
    wcscpy( BackupFilePath, SystemRootPath );
    wcscat( BackupFilePath, ConfigDirectoryPath );
    wcscat( BackupFilePath, BackupFileName );

    //
    // Enable restore privilege
    //
    IgnoreStatus = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                       TRUE,           // Enable
                                       FALSE,          // not client; process wide
                                       &fWasEnabled );
    ASSERT( NT_SUCCESS( IgnoreStatus ) );

    //
    // Load the info
    //
    WinError = RegLoadKey(  HKEY_LOCAL_MACHINE,
                            SamUpgradeKey,
                            FilePath );

    if ( ERROR_SUCCESS != WinError )
    {
        //
        // Ok, our attempt to load the hive we created failed
        // Try the base nt saved off copy
        //
        WinError = RegLoadKey(  HKEY_LOCAL_MACHINE,
                                SamUpgradeKey,
                                BackupFilePath );

    }

    //
    // Disable the restore privilege
    //
    IgnoreStatus = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                       FALSE,          // Disable
                                       FALSE,          // not client; process wide
                                       &fWasEnabled );

    ASSERT( NT_SUCCESS( IgnoreStatus ) );

    if ( ERROR_SUCCESS != WinError )
    {
        //
        // This isn't good - what to do?
        //
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "RegLoadKey returned %d\n",
                   WinError));

        NtStatus = STATUS_UNSUCCESSFUL;
    }

    //
    // Done
    //

    if ( ExtendedWinError )
    {
        *ExtendedWinError = WinError;
    }

    return NtStatus;
}


NTSTATUS
SamIUnLoadDownlevelDatabase(
    OUT ULONG *ExtendedWinError OPTIONAL
    )
/*++

Routine Description:

    This routine unloads the "temporarily" loaded downlevel hive from
    the registry.

Parameters:

    ExtendedWinError : on error the win32 error that caused the problem

Return Values:

    STATUS_SUCCESS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus;
    DWORD    WinError;
    BOOLEAN  fWasEnabled;

    //
    // Enable restore privilege
    //
    IgnoreStatus = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                       TRUE,           // Enable
                                       FALSE,          // not client; process wide
                                       &fWasEnabled );
    ASSERT( NT_SUCCESS( IgnoreStatus ) );

    //
    // Unload the hive
    //
    WinError = RegUnLoadKey( HKEY_LOCAL_MACHINE, SAMP_DOWNLEVEL_DB_KEYNAME );
    if ( ERROR_SUCCESS != WinError )
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: RegUnLoadKey failed with %d\n",
                   WinError));

        NtStatus = STATUS_UNSUCCESSFUL;
    }

    //
    // Disble restore privilege
    //
    IgnoreStatus = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                       FALSE,          // Disable
                                       FALSE,          // not client; process wide
                                       &fWasEnabled );
    ASSERT( NT_SUCCESS( IgnoreStatus ) );

    if ( ExtendedWinError )
    {
        *ExtendedWinError = WinError;
    }

    return NtStatus;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private Definitions                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
SampAddWellKnownSecurityPrincipals(
    )
/*++

Routine Description:

    In .NET/XP frame, a few new WellKnown Security Principals are added. (ex: Local System,
    Network Service...) These security principals should exist under "WellKnown Security
    Principals" which is under configuration container, since in Win2K other security
    principals lived there.

    This function must be called when a PDC in the forest root domain is upgraded to .NET
    or a .NET DC in the forest root domain becomes the PDC or in a fresh .NET forest creation.
    Then these new principals will be created.

    If you want to add new principals, just add them to the SidsToBeAdded table.

    Steps
        1. Form DSNAME of WellKnown Security Principals container.
        2. Open a transaction
        3. Create common structures for all principals
        4. Loop over the table to create all principals
        5. If a foreignSecurityPrincipal object with the same sid of the principal object
            we are trying to add exists, skip addition
        6. Commit transaction

Parameters:

    VOID

Return Values:

    VOID - in error cases, an event log will be written.

--*/
{

//
// Security Descriptor on WellKnown Security Principals are harded coded in Win2K schema.ini
//  This is the same security descriptor. All entries in schema.ini for security principals are
//  deleted and added here, therefore the SD moves here as well.
//
#define SD_SECURITY_PRINCIPALS \
    L"O:EAG:EAD:(A;;RPLCLORC;;;WD)(A;;RPWPCRLCLOCCRCWDWOSW;;;EA)(A;;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;SY)"

//
// This container lives under configurations container and is a place to hold all WellKnown Security
//  Principals.
//
#define WELL_KNOWN_SECURITY_PRINCIPALS_CONTAINER \
    L"WellKnown Security Principals"

    struct WELL_KNOWN_SIDS {
        WELL_KNOWN_SID_TYPE Type;
        PWSTR RDN;
    } SidsToBeAdded[] = {
        { WinWorldSid,                  L"Everyone"                 },
        { WinCreatorOwnerSid,           L"Creator Owner"            },
        { WinCreatorGroupSid,           L"Creator Group"            },
        { WinSelfSid,                   L"Self"                     },
        { WinAuthenticatedUserSid,      L"Authenticated Users"      },
        { WinNetworkSid,                L"Network"                  },
        { WinBatchSid,                  L"Batch"                    },
        { WinInteractiveSid,            L"Interactive"              },
        { WinServiceSid,                L"Service"                  },
        { WinAnonymousSid,              L"Anonymous Logon"          },
        { WinDialupSid,                 L"Dialup"                   },
        { WinProxySid,                  L"Proxy"                    },
        { WinEnterpriseControllersSid,  L"Enterprise Domain Controllers" },
        { WinRestrictedCodeSid,         L"Restricted"               },
        { WinLocalSystemSid,            L"Well-Known-Security-Id-System" },
        { WinTerminalServerSid,         L"Terminal Server User"     },
        { WinLocalServiceSid,           L"Local Service"            },
        { WinNetworkServiceSid,         L"Network Service"          },
        { WinThisOrganizationSid,       L"This Organization"        },
        { WinOtherOrganizationSid,      L"Other Organization"       },
        { WinRemoteLogonIdSid,          L"Remote Interactive Logon" },
        { WinNTLMAuthenticationSid,     L"NTLM Authentication"      },
        { WinDigestAuthenticationSid,   L"Digest Authentication"    },
        { WinSChannelAuthenticationSid, L"SChannel Authentication"  },
        };

    ULONG nSidsToBeAdded = sizeof( SidsToBeAdded ) / sizeof( SidsToBeAdded[0] );

    PDSNAME WellKnownSecurityPrincipalsContainer = NULL;
    PDSNAME ConfigurationContainer = NULL;
    ULONG DsNameSize = 0;
    ULONG RetVal;
    ULONG ObjectClass = CLASS_FOREIGN_SECURITY_PRINCIPAL;

    ULONG i;
    NTSTATUS Status = STATUS_SUCCESS;

    ATTRVAL ObjectSidVal;
    ATTRVAL ObjectClassVal = { sizeof( ULONG ), ( PUCHAR ) &ObjectClass };
    ATTRVAL SecurityDescriptorVal;
    ADDARG AddArg;
    ADDRES *AddRes = NULL;
    BOOL TransactionStarted = FALSE;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    ULONG SDSize = 0;
    PSID DomainSid = SampDefinedDomains[DOMAIN_START_DS + 1].Sid;
    SEARCHARG SearchArg;
    SEARCHRES *SearchRes;
    FILTER Filter;
    ENTINFSEL EntInfSel;

    RtlZeroMemory( &Filter, sizeof( Filter ) );
    RtlZeroMemory( &AddArg, sizeof( AddArg ) );
    RtlZeroMemory( &SearchArg, sizeof( SearchArg ) );
    RtlZeroMemory( &EntInfSel, sizeof( EntInfSel ) );

    if( !ConvertStringSDToSDDomainW(
            DomainSid,
            DomainSid,
            SD_SECURITY_PRINCIPALS,
            SDDL_REVISION_1,
            &SecurityDescriptor,
            &SDSize
            ) ) {

            goto Error;
    }

    SecurityDescriptorVal.valLen = SDSize;
    SecurityDescriptorVal.pVal = ( PUCHAR ) SecurityDescriptor;

    //
    // Get configuration container's Dsname
    //

    Status = GetConfigurationName(
                DSCONFIGNAME_CONFIGURATION,
                &DsNameSize,
                NULL
                );

    ASSERTMSG( "Passing nothing so buffer must be too small",
                Status == STATUS_BUFFER_TOO_SMALL );

    ConfigurationContainer = MIDL_user_allocate( DsNameSize );

    if( ConfigurationContainer == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto Error;
    }

    Status = GetConfigurationName(
                DSCONFIGNAME_CONFIGURATION,
                &DsNameSize,
                ConfigurationContainer
                );

    if( !NT_SUCCESS( Status ) ) {

        goto Error;
    }

    //
    // Append WellKnown Security Principals container's CN
    //
    Status = SampAppendCommonName(
                ConfigurationContainer,
                WELL_KNOWN_SECURITY_PRINCIPALS_CONTAINER,
                &WellKnownSecurityPrincipalsContainer
                );

    if( !NT_SUCCESS( Status ) ) {

        goto Error;
    }

    MIDL_user_free( ConfigurationContainer );
    ConfigurationContainer = NULL;

    //
    // Begin the transaction
    //
    Status = SampMaybeBeginDsTransaction( TransactionWrite );

    if( !NT_SUCCESS( Status ) ) {

        goto Error;
    }

    TransactionStarted = TRUE;

    //
    // Build AddArg structure
    //
    BuildStdCommArg( &( AddArg.CommArg ) );

    AddArg.AttrBlock.attrCount = 3;
    AddArg.AttrBlock.pAttr = THAlloc( sizeof( ATTR ) * AddArg.AttrBlock.attrCount );

    if( AddArg.AttrBlock.pAttr == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto Error;
    }

    AddArg.AttrBlock.pAttr[0].attrTyp = ATT_OBJECT_CLASS;
    AddArg.AttrBlock.pAttr[0].AttrVal.valCount = 1;
    AddArg.AttrBlock.pAttr[0].AttrVal.pAVal = &ObjectClassVal;
    AddArg.AttrBlock.pAttr[1].attrTyp = ATT_OBJECT_SID;
    AddArg.AttrBlock.pAttr[1].AttrVal.valCount = 1;
    AddArg.AttrBlock.pAttr[1].AttrVal.pAVal = &ObjectSidVal;
    AddArg.AttrBlock.pAttr[2].attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
    AddArg.AttrBlock.pAttr[2].AttrVal.valCount = 1;
    AddArg.AttrBlock.pAttr[2].AttrVal.pAVal = &SecurityDescriptorVal;

    //
    // Build the SearchArg Structure
    //
    Filter.choice = FILTER_CHOICE_ITEM;
    Filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    Filter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_SID;

    SearchArg.pObject = WellKnownSecurityPrincipalsContainer;
    SearchArg.choice = SE_CHOICE_IMMED_CHLDRN;
    SearchArg.pFilter = &Filter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = &EntInfSel;
    SearchArg.bOneNC = TRUE;

    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.AttrTypBlock.attrCount = 1;

    EntInfSel.AttrTypBlock.pAttr = THAlloc( sizeof( ATTR ) );

    if( EntInfSel.AttrTypBlock.pAttr == NULL ) {

        Status = STATUS_NO_MEMORY;
        goto Error;
    }

    RtlZeroMemory( EntInfSel.AttrTypBlock.pAttr, sizeof( ATTR ) );

    EntInfSel.AttrTypBlock.pAttr[0].attrTyp = ATT_OBJECT_CLASS;

    // Unique search does a Dir Search only in fairly
    // rare error cases. And in these cases it is useful to
    // have the string name for event logging. So ask for
    // string names
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

    //
    // Build the Commarg structure
    //

    BuildStdCommArg( &( SearchArg.CommArg ) );


    //
    // Loop over the elements in the table to create an entry
    //  for each one
    //

    for( i = 0; i < nSidsToBeAdded; i++ ) {

        BOOL Successful;
        ULONG WellKnownSid[ SECURITY_MAX_SID_SIZE / sizeof( ULONG ) ];
        ULONG SidLength = SECURITY_MAX_SID_SIZE;
        PDSNAME ObjectDsName;
        UNICODE_STRING String;
        PUNICODE_STRING pString = &String;

        Status = STATUS_SUCCESS;

        //
        // Create the sid for the well known security principal.
        //

        Successful = CreateWellKnownSid(
                        SidsToBeAdded[i].Type,
                        NULL,
                        WellKnownSid,
                        &SidLength
                        );

        if( !Successful ) {

            goto IterationError;
        }

        ObjectSidVal.pVal = ( PUCHAR ) WellKnownSid;
        ObjectSidVal.valLen = SidLength;

        //
        // If an object with the same sid already exist, we must skip this.
        //  So search for it.
        //
        Filter.FilterTypes.Item.FilTypes.ava.Value = ObjectSidVal;

        RetVal = DirSearch(
                    &SearchArg,
                    &SearchRes
                    );

        if( SearchRes == NULL ) {

            Status = STATUS_NO_MEMORY;

        } else {

            Status = SampMapDsErrorToNTStatus( RetVal, &( SearchRes->CommRes ) );
        }

        THClearErrors();

        if( NT_SUCCESS( Status ) ) {

            ULONG j;
            ENTINFLIST *List = &( SearchRes->FirstEntInf );
            BOOL Found = FALSE;

            //
            // Some objects found. See if one of them is of type foreignSecurityPrincipal.
            //  If so, then skip addition of security principal, somebody has already added
            //  that.
            //

            for( j = 0; j < SearchRes->count && !Found; ++ j ) {

                ULONG k;

                ASSERT( List->Entinf.AttrBlock.attrCount == 1 );
                ASSERT( List->Entinf.AttrBlock.pAttr[0].attrTyp == ATT_OBJECT_CLASS );

                for( k = 0; k < List->Entinf.AttrBlock.pAttr[0].AttrVal.valCount; ++k ) {

                    ASSERT( List->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[k].valLen == sizeof( ULONG ) );

                    if( RtlEqualMemory(
                            List->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[k].pVal,
                            &ObjectClass,
                            sizeof( ULONG ) ) ) {

                            Found = TRUE;
                            break;
                    }
                }
                List = List->pNextEntInf;
            }

            if( Found ) {

                continue;
            }

        }

        //
        // Append its name to the container's name
        //
        Status = SampAppendCommonName(
                    WellKnownSecurityPrincipalsContainer,
                    SidsToBeAdded[i].RDN,
                    &ObjectDsName
                    );

        if( !NT_SUCCESS( Status ) ) {

            goto IterationError;
        }

        AddArg.pObject = ObjectDsName;

        //
        // Add the entry
        //
        RetVal = DirAddEntry(
                    &AddArg,
                    &AddRes
                    );

        //
        // Free object's dsname since it won't be used again
        //
        MIDL_user_free( ObjectDsName );

        if( AddRes == NULL ) {

            Status = STATUS_NO_MEMORY;

        } else {

            Status = SampMapDsErrorToNTStatus( RetVal, &( AddRes->CommRes ) );
        }

        THClearErrors();

        if( !NT_SUCCESS( Status ) ) {

            //
            // Error occured while trying to add, so report it.
            //

            goto IterationError;
        }

        continue;

IterationError:

        ASSERTMSG( "There shouldn't be any problems while adding Well Known Security Principals",
                    FALSE );

        //
        // Write an event log that this security principal was not added
        //

        //
        // We are in error case, either Status or GetLastError has the value
        //  of the error. Check if Status has an error value in it, if so, get
        //  that error, if not GetLastError
        //
        if( NT_SUCCESS( Status ) ) {

            RetVal = GetLastError();

        } else {

            RetVal = RtlNtStatusToDosError( Status );
        }

        ASSERTMSG( "We are going to log an error here. How can it be success?",
                    RetVal != ERROR_SUCCESS );

        RtlInitUnicodeString( pString, SidsToBeAdded[i].RDN );

        SampWriteEventLog(
            EVENTLOG_ERROR_TYPE,
            0,
            SAMMSG_FAILED_TO_ADD_SECURITY_PRINCIPAL,
            NULL,
            1,
            sizeof( ULONG ),
            &pString,
            &RetVal
            );
    }

    //
    // Commit transaction
    //
    Status = SampMaybeEndDsTransaction( TransactionCommit );

    if( !NT_SUCCESS( Status ) ) {

        ASSERTMSG( "Can't do much here, transaction commit failed",
                    FALSE );
        goto Error;
    }

Exit:

    MIDL_user_free( ConfigurationContainer );
    MIDL_user_free( WellKnownSecurityPrincipalsContainer );
    //
    // ConvertStringSDToSDDomainW allocates memory using LocalAlloc so
    // free it with local free
    //
    LocalFree( SecurityDescriptor );

    return;
Error:

    ASSERTMSG( "There shouldn't be any problems while adding Well Known Security Principals",
                FALSE );

    //
    // We are in error case, either Status or GetLastError has the value of the error
    //  Check if Status has an error value in it, if so, get that error, if not GetLastError
    //

    if( NT_SUCCESS( Status ) ) {

        RetVal = GetLastError();

    } else {

        RetVal = RtlNtStatusToDosError( Status );
    }

    ASSERTMSG( "We are going to log an error here. How can it be success?",
                RetVal != ERROR_SUCCESS );

    if( TransactionStarted ) {

        Status = SampMaybeEndDsTransaction( TransactionAbort );
        ASSERTMSG( "We can't even abort the transaction",
                    NT_SUCCESS( Status ) );
    }

    //
    // Write an event log that none of the security principals was added.
    //
    SampWriteEventLog(
        EVENTLOG_ERROR_TYPE,
        0,
        SAMMSG_FAILED_TO_ADD_ALL_SECURITY_PRINCIPALS,
        NULL,
        0,
        sizeof( ULONG ),
        NULL,
        &RetVal
        );

    goto Exit;
}

NTSTATUS
SampAddWellKnownAccountsAndSecurityPrincipals(
    IN SAMPR_HANDLE AccountDomainHandle,
    IN SAMPR_HANDLE BuiltinDomainHandle,
    IN ULONG Flags
    )
/*++

Routine Description:

    This function is simply a wrapper around SampAddWellKnownAccounts &
    SampAddWellKnownSecurityPrincipals. It will call these two and return
    the result of SampAddWellKnownAccounts.

Parameters:

    AccountDomainHandle - Account domain handle to be passed into SampAddWellKnownAccounts
    BuiltinDomainHandle - Builting domain handle to be passed into SampAddWellKnownAccounts
    Flags - Flags to be passed into SampAddWellKnownAccounts

Return Values:

    NTSTATUS code from SampAddWellKnownAccounts

--*/

{
    //
    // Check if we are in the forest root domain
    //  and check if this DC is the PDC before adding well known security principals
    //

    if( SampUseDsData ) {

        PSAMP_DEFINED_DOMAINS AccountDomain = &SampDefinedDomains[DOMAIN_START_DS + 1];

        if( AccountDomain->IsForestRootDomain ) {

            if ( AccountDomain->ServerRole == DomainServerRolePrimary ) {

                //
                // Add well known security principals
                //

                SampAddWellKnownSecurityPrincipals();
            }
        }
    }
    //
    // Add well known accounts
    //
    return SampAddWellKnownAccounts(
                AccountDomainHandle,
                BuiltinDomainHandle,
                Flags
                );
}


NTSTATUS
SampCheckPromoteEnvironment(
    IN  ULONG PromoteFlags
    )
/*++

Routine Description:

    This routine first queries LSA and the system to determine our
    current role.  Then the two operations that are passed in and
    verified to be valid operations for the server's current role.
    See module header for supported promotions.

Parameters:

    PromoteFlags:  the callers desired role change

Return Values:

    STATUS_INVALID_SERVER_STATE, STATUS_SUCCESS, or system service error.

--*/
{


    NTSTATUS                     NtStatus = STATUS_SUCCESS;

    SAMP_ROLE_CONFIGURATION      RoleConfiguration = SampMemberServer;

    OSVERSIONINFO                VersionInformation;
    NT_PRODUCT_TYPE              NtProductType;
    PLSAPR_POLICY_INFORMATION    PolicyInfo;
    BOOLEAN                      fSetupInProgress;
    BOOLEAN                      fUpgradeInProgress;


    //
    // Sanity check the flags
    //
#if DBG

    if  ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_ENTERPRISE ) )
    {
        ASSERT( !FLAG_ON( PromoteFlags, SAMP_PROMOTE_REPLICA ) );
        ASSERT( FLAG_ON( PromoteFlags, SAMP_PROMOTE_DOMAIN ) );
    }
    if  ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_REPLICA ) )
    {
        ASSERT( !FLAG_ON( PromoteFlags, SAMP_PROMOTE_ENTERPRISE ) );
        ASSERT( !FLAG_ON( PromoteFlags, SAMP_PROMOTE_DOMAIN ) );
        ASSERT( !FLAG_ON( PromoteFlags, SAMP_PROMOTE_UPGRADE ) );
        ASSERT( !FLAG_ON( PromoteFlags, SAMP_PROMOTE_MIGRATE ) );
        ASSERT( !FLAG_ON( PromoteFlags, SAMP_PROMOTE_CREATE ) );
    }
    if  ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_DOMAIN ) )
    {
        ASSERT( !FLAG_ON( PromoteFlags, SAMP_PROMOTE_REPLICA ) );
        ASSERT( FLAG_ON( PromoteFlags, SAMP_PROMOTE_UPGRADE )
             || FLAG_ON( PromoteFlags, SAMP_PROMOTE_MIGRATE )
             || FLAG_ON( PromoteFlags, SAMP_PROMOTE_CREATE ) );
    }

#endif

    //
    // Are running during setup?
    //
    fSetupInProgress = SampIsSetupInProgress(&fUpgradeInProgress);

    if (!RtlGetNtProductType(&NtProductType)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: RtlGetNtProductType failed\n"));

        return STATUS_UNSUCCESSFUL;
    }

    switch (NtProductType) {

        case NtProductWinNt:
            //
            // This is a workstation - illegal
            //
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Illegal to promote a workstation\n"));

            NtStatus = STATUS_INVALID_SERVER_STATE;
            break;


        case NtProductLanManNt:

            //
            // This is a DC - only legal when running during gui mode
            // setup.
            //
            ASSERT(fSetupInProgress);
            ASSERT(fUpgradeInProgress);

            if (SampUsingDsData()) {

                //
                // Definately not legal to promote when the ds is already
                // running!
                //

                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: Trying to promote when ds is already running!\n"));

                NtStatus = STATUS_INVALID_SERVER_STATE;
                break;

            }


            //
            // This is domain controller - what role are we?
            //
            NtStatus = LsaIQueryInformationPolicyTrusted(
                                     PolicyLsaServerRoleInformation,
                                     &PolicyInfo);

            if (!NT_SUCCESS(NtStatus)) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "LsaIQueryInformationPolicyTrusted returned 0x%x\n",
                           NtStatus));

                break;
            }

            if (PolicyServerRolePrimary == PolicyInfo->PolicyServerRoleInfo.LsaServerRole) {

                RoleConfiguration = SampDownlevelPDC;

            } else if (PolicyServerRoleBackup == PolicyInfo->PolicyServerRoleInfo.LsaServerRole){

                RoleConfiguration = SampDownlevelBDC;

            } else {

                ASSERT(!"SAMSS: Bad server role from Lsa\n");
                NtStatus = STATUS_UNSUCCESSFUL;
                break;
            }

            LsaIFree_LSAPR_POLICY_INFORMATION(PolicyLsaServerRoleInformation,
                                              PolicyInfo);

            break;


        case NtProductServer:

            //
            // This either a standalone or member server - determine
            // which one
            //

            RtlSecureZeroMemory(&PolicyInfo, sizeof(PolicyInfo));
            NtStatus = LsaIQueryInformationPolicyTrusted(
                                     PolicyPrimaryDomainInformation,
                                     &PolicyInfo);
            if (!NT_SUCCESS(NtStatus)) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "LsaIQueryInformationPolicyTrusted returned 0x%x\n",
                           NtStatus));

                break;
            }

            if (NULL == PolicyInfo->PolicyAccountDomainInfo.DomainSid) {
                //
                // No Domain sid - this is a standalone server
                //
                RoleConfiguration = SampStandaloneServer;
            } else {
                //
                // Domain sid - this is a member server
                //
                RoleConfiguration = SampMemberServer;
            }

            LsaIFree_LSAPR_POLICY_INFORMATION(PolicyPrimaryDomainInformation,
                                              PolicyInfo);

            break;

        default:

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Bad product type\n"));

            NtStatus = STATUS_UNSUCCESSFUL;
    }

    //
    // If error an occured at this point, there is no point in continuing
    //
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // Now some analysis
    //
    NtStatus = STATUS_INVALID_SERVER_STATE;
    switch (RoleConfiguration) {

        case SampStandaloneServer:

            //
            // Can only promote to a DC in a new domain
            //
            if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_DOMAIN ) )
            {
                NtStatus = STATUS_SUCCESS;
            }

            break;

        case SampMemberServer:

            //
            // Can only be a DC in the domain that server is currently
            // joined to
            //
            if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_REPLICA ) )
            {
                NtStatus = STATUS_SUCCESS;
            }

             // In case of a new domain install on a stand-alone
             // server, we set the domain-sid early so that
             // the text SDs from schema.ini, that may have groups
             // like domain-admin etc. that require domain-sids,
             // can be converted correcly by MacM's SD-conversion
             // api's.
             if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_DOMAIN ) )
             {
                 NtStatus = STATUS_SUCCESS;
             }

            break;

        case SampDownlevelPDC:
        case SampDownlevelBDC:

            //
            // Not supported
            //

        default:

            NtStatus = STATUS_INVALID_SERVER_STATE;

    }

    return NtStatus;

}


NTSTATUS
SampGetLocalMachineAccountandSecurityDescriptor(
    OUT PDSNAME              *ppMachineAccount,
    OUT PSECURITY_DESCRIPTOR *ppsd,
    OUT PDWORD                pcbsd
    )
/*++

Routine Description

    This routine is called during all promotion and upgrades of domain controllers.
    It will return the DSNAME of the localMachine account and the Security Descriptor
    of the object back to the caller.

Parameters

    pMachineAccount - the DSNAME of the machine account will be returned here.

    psd - the security descriptor will be returned here.

Return Values

    STATUS_SUCCESS; a system service error otherwise

--*/

{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    SEARCHARG       SearchArg;
    SEARCHRES       *SearchRes;
    ENTINFSEL       EntInfSel;
    ULONG           RetCode;
    FILTER          DsFilter;
    COMMARG         *pCommArg;
    ATTR            Attr;
    WCHAR           MachineAccountName[MAX_COMPUTERNAME_LENGTH+2]; // +2 for NULL and $
    ULONG           ComputerNameLength = ARRAY_COUNT(MachineAccountName);

    // INIT returns to NULL
    *ppMachineAccount = NULL;
    *ppsd = NULL;

    //
    //
    //
    //
    // Get the Machine Account Name
    //

    if (!GetComputerNameW(MachineAccountName, &ComputerNameLength)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: GetComputerName failed with %d\n",
                   GetLastError()));

        NtStatus = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }


    wcscat(MachineAccountName, L"$");

    //
    // build DS Filter
    //
    RtlZeroMemory(&DsFilter, sizeof(FILTER));

    DsFilter.choice = FILTER_CHOICE_ITEM;
    DsFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    DsFilter.FilterTypes.Item.FilTypes.ava.type = ATT_SAM_ACCOUNT_NAME;
    DsFilter.FilterTypes.Item.FilTypes.ava.Value.valLen
        = wcslen(MachineAccountName)*sizeof(WCHAR);
    DsFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (PUCHAR)MachineAccountName;

     //
    // Build the SearchArg Structure
    //

    memset(&SearchArg, 0, sizeof(SEARCHARG));
    SearchArg.pObject       = ROOT_OBJECT;
    SearchArg.choice        = SE_CHOICE_WHOLE_SUBTREE;
    SearchArg.pFilter       = &DsFilter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection    = &EntInfSel;
    SearchArg.bOneNC        = TRUE;

    //
    // Fill the ENTINF Structure
    //

    Attr.attrTyp          = ATT_NT_SECURITY_DESCRIPTOR;
    Attr.AttrVal.valCount = 0;
    Attr.AttrVal.pAVal    = NULL;

    EntInfSel.AttrTypBlock.attrCount = 1;
    EntInfSel.AttrTypBlock.pAttr     = &Attr;
    EntInfSel.attSel                 = EN_ATTSET_LIST;
    EntInfSel.infoTypes              = EN_INFOTYPES_TYPES_VALS;

    //
    // Build the CommArg Structure
    // Build the Commarg structure
    // Get the address of the service control structure
    //

    pCommArg = &(SearchArg.CommArg);
    BuildStdCommArg(pCommArg);

    //
    // Make the Directory call
    //

    SAMTRACE_DS("DirSearch\n");

    RetCode = DirSearch(&SearchArg, &SearchRes);

    SAMTRACE_RETURN_CODE_DS(RetCode);

    //
    // Map Errors
    //

    if (NULL==SearchRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetCode,&SearchRes->CommRes);
        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }
    }

    if ( SearchRes->count != 1 ||
         SearchRes->FirstEntInf.Entinf.AttrBlock.attrCount != 1 )
    {
        NtStatus = STATUS_NOT_FOUND;
        goto Cleanup;
    }

    //
    // Return the Values back to the caller.
    //
    *ppMachineAccount = SearchRes->FirstEntInf.Entinf.pName;
    *ppsd = SearchRes->FirstEntInf.Entinf.AttrBlock.pAttr->AttrVal.pAVal->pVal;
    *pcbsd = SearchRes->FirstEntInf.Entinf.AttrBlock.pAttr->AttrVal.pAVal->valLen;

    Cleanup:

    return NtStatus;
}


NTSTATUS
SampSetMachineAccountSecurityDescriptor(
    IN PDSNAME              pMachineAccount,
    IN SECURITY_DESCRIPTOR *psd,
    IN DWORD                cbSD
    )
/*++

Routine Description

    This routine is called during all promotion and upgrades of domain controllers.
    It will Set the Security descriptor of the machine account passed in to be
    the value of the security descriptor passed in.

Parameters

    pMachineAccount - the DSNAME of the machine account will passed in here.

    psd - the security descriptor will be passed in here.

Return Values

    STATUS_SUCCESS; a system service error otherwise

--*/
{
    MODIFYARG   ModifyArg;
    MODIFYRES   *ModifyRes = NULL;
    ATTRVAL     SecurityDes;
    ULONG       DirErr = 0;
    NTSTATUS    NtStatus = STATUS_SUCCESS;


    SecurityDes.valLen = cbSD;
    SecurityDes.pVal   = (BYTE*) psd;

    memset( &ModifyArg, 0, sizeof(MODIFYARG) );
    ModifyArg.pObject = pMachineAccount;
    ModifyArg.count = 1;
    ModifyArg.FirstMod.pNextMod = NULL;
    ModifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
    ModifyArg.FirstMod.AttrInf.attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
    ModifyArg.FirstMod.AttrInf.AttrVal.valCount = 1;
    ModifyArg.FirstMod.AttrInf.AttrVal.pAVal = &SecurityDes;

    InitCommarg(&ModifyArg.CommArg);
    ModifyArg.CommArg.Svccntl.SecurityDescriptorFlags = DACL_SECURITY_INFORMATION;

    DirErr = DirModifyEntry (&ModifyArg, &ModifyRes);

    if (NULL==ModifyRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(DirErr,&ModifyRes->CommRes);
    }

    return NtStatus;

}


NTSTATUS
SampRemoveAccountOperatorsFullControlFromDACL(
    IN OUT PSECURITY_DESCRIPTOR psd,
    IN OUT PDWORD               pcbsd,
    OUT    PDWORD               pWin32Err,
    OUT    PBOOLEAN             pDACLChanged
    )
/*++

Routine Description

    This routine will remove the Account Operators full control ACE
    from the DACL on the SID passed in.

Parameters

    psd - the security descriptor to modify

Return Values

    STATUS_SUCCESS; a system service error otherwise

--*/
{
    ACL                      *pNewDacl          = NULL;
    EXPLICIT_ACCESS          ea;
    SID_IDENTIFIER_AUTHORITY SIDAuthNT          = SECURITY_NT_AUTHORITY;
    SID                      *pAccountOpsSID    = NULL;

    SECURITY_DESCRIPTOR      AbsoluteSD;
    DWORD                    dwAbsoluteSDSize   = sizeof(AbsoluteSD);
    PACL                     pDacl              = NULL;
    DWORD                    dwDaclSize         = 0;
    PACL                     pSacl              = NULL;
    DWORD                    dwSaclSize         = 0;
    PSID                     pOwner             = NULL;
    DWORD                    dwOwnerSize        = 0;
    PSID                     pPrimaryGroup      = NULL;
    DWORD                    dwPrimaryGroupSize = 0;

    ULONG                    i = 0,AceCount = 0;
    PACE_HEADER              Ace;

    ACCESS_MASK              AccessMask         = DELETE                 |
                                                  READ_CONTROL           |
                                                  WRITE_DAC              |
                                                  WRITE_OWNER            |
                                                  ACTRL_DS_CREATE_CHILD  |
                                                  ACTRL_DS_DELETE_CHILD  |
                                                  ACTRL_DS_LIST          |
                                                  ACTRL_DS_SELF          |
                                                  ACTRL_DS_READ_PROP     |
                                                  ACTRL_DS_WRITE_PROP    |
                                                  ACTRL_DS_DELETE_TREE   |
                                                  ACTRL_DS_LIST_OBJECT   |
                                                  ACTRL_DS_CONTROL_ACCESS;
    /*
     *
     *  Remove ACCOUNT Operators FULL_CONTROL from the DACL
     *  Ace Mask:  0x000f01ff
     *      DELETE
     *      READ_CONTROL
     *      WRITE_DAC
     *      WRITE_OWNER
     *      ACTRL_DS_CREATE_CHILD
     *      ACTRL_DS_DELETE_CHILD
     *      ACTRL_DS_LIST
     *      ACTRL_DS_SELF
     *      ACTRL_DS_READ_PROP
     *      ACTRL_DS_WRITE_PROP
     *      ACTRL_DS_DELETE_TREE
     *      ACTRL_DS_LIST_OBJECT
     *      ACTRL_DS_CONTROL_ACCESS
     *
     *  ACCOUNT Operators SID: S-1-5-32-548
     *
     */

    *pWin32Err = ERROR_SUCCESS;
    *pDACLChanged = FALSE;

    //
    // Create an absolute security descriptor from the self-relative one passed in.
    //
    if ( !MakeAbsoluteSD(psd,
                         NULL,
                         &dwAbsoluteSDSize,
                         NULL,
                         &dwDaclSize,
                         NULL,
                         &dwSaclSize,
                         NULL,
                         &dwOwnerSize,
                         NULL,
                         &dwPrimaryGroupSize) )
    {
        //this should always fail.
        ASSERT(GetLastError() != ERROR_SUCCESS);
    }

    //
    // Allocate memory for the new security Descriptor
    //
    if ( dwDaclSize         > 0 ) SAMP_ALLOCA( pDacl, dwDaclSize  );
    if (dwDaclSize > 0 && !pDacl) {
        *pWin32Err = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    if ( dwSaclSize         > 0 ) SAMP_ALLOCA( pSacl, dwSaclSize );
    if (dwSaclSize > 0 && !pSacl) {
        *pWin32Err = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    if ( dwOwnerSize        > 0 ) SAMP_ALLOCA( pOwner, dwOwnerSize );
    if (dwOwnerSize > 0 && !pOwner) {
        *pWin32Err = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    if ( dwPrimaryGroupSize > 0 ) SAMP_ALLOCA( pPrimaryGroup, dwPrimaryGroupSize );
    if (dwPrimaryGroupSize > 0 && !pPrimaryGroup) {
        *pWin32Err = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Create the Self-Relative SD
    //
    if ( !MakeAbsoluteSD(psd,
                         &AbsoluteSD,
                         &dwAbsoluteSDSize,
                         pDacl,
                         &dwDaclSize,
                         pSacl,
                         &dwSaclSize,
                         pOwner,
                         &dwOwnerSize,
                         pPrimaryGroup,
                         &dwPrimaryGroupSize) )
    {
        *pWin32Err = GetLastError();
        goto Cleanup;
    }

    // Create a SID for the BUILTIN\Account Operators group.
   if(!AllocateAndInitializeSid(&SIDAuthNT,
                                 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 DOMAIN_ALIAS_RID_ACCOUNT_OPS,
                                 0, 0, 0, 0, 0, 0,
                                 &pAccountOpsSID) )
    {
      *pWin32Err = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
   }

    //
    // See if the ACE in the security descriptor
    //
    if (  (NULL == pDacl)
      ||  (AceCount = pDacl->AceCount) == 0) {
        //there are no ace's to check
        goto Cleanup;
    }

    for ( i = 0, Ace = FirstAce( pDacl ) ;
          i < AceCount  ;
          i++, Ace = NextAce( Ace )
        ) {

        if ( (((PACE_HEADER)Ace)->AceType == ACCESS_ALLOWED_ACE_TYPE) ) {

            if ( (RtlEqualSid( pAccountOpsSID, &((PACCESS_ALLOWED_ACE)Ace)->SidStart )) ) {

                if ( AreAllAccessesGranted(((PACCESS_ALLOWED_ACE)Ace)->Mask,
                                           AccessMask) )
                {
                    *pDACLChanged = TRUE;
                    break;
                }

            }
        }

    }

    //
    //  We were not able to find the ACE on the security Descriptor,
    //  so there is nothing to change.
    //
    if (!*pDACLChanged) {
        goto Cleanup;
    }

    ea.grfAccessMode                    = REVOKE_ACCESS;
    ea.grfAccessPermissions             = AccessMask;
    ea.grfInheritance                   = NO_INHERITANCE;
    ea.Trustee.TrusteeForm              = TRUSTEE_IS_SID;
    ea.Trustee.TrusteeType              = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ea.Trustee.ptstrName                = (LPTSTR)pAccountOpsSID;
    ea.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    ea.Trustee.pMultipleTrustee         = NULL;

    //
    // Create the DACL to be placed back on the object.
    //

    *pWin32Err = SetEntriesInAcl(1, // one Entry in the pListofExplicitEntries Array
                                 &ea,
                                 pDacl,
                                 &pNewDacl);
    if ( ERROR_SUCCESS != *pWin32Err) {
        goto Cleanup;
    }

    //
    // Replace the DACL with the new DACL.
    //

    if ( !SetSecurityDescriptorDacl(&AbsoluteSD,
                                    TRUE,
                                    pNewDacl,
                                    FALSE) )
    {
        *pWin32Err = GetLastError();
        goto Cleanup;
    }

    //
    // Writing back the security descriptor into the same memory.  This should never fail
    // due to lack of memory since we are making the security descriptor smaller than it was.
    //
    if ( !MakeSelfRelativeSD(&AbsoluteSD,
                             psd,
                             pcbsd) )
    {
        *pWin32Err = GetLastError();
        goto Cleanup;
    }


    Cleanup:

    //
    // This Memory for the DACL is allocated in
    // SampRemoveAccountOperatorsFullControlFromDACL().
    //
    if (pNewDacl) {
        LocalFree(pNewDacl);
    }

    if (pAccountOpsSID) {
        LocalFree(pAccountOpsSID);
    }

    return (ERROR_SUCCESS == *pWin32Err)?STATUS_SUCCESS:STATUS_UNSUCCESSFUL;

}

NTSTATUS
SampRecordSystemSchemaVerisonInRegistry()
/*++

Routine Description

    This routine is called during upgrades of domain controllers.  It will
    Update the system schema version registry key to reflect the schema
    version from the schema.ini file after the upgrade.

Parameters

    VOID.

Return Values

    STATUS_SUCCESS;

--*/
{

    NTSTATUS     NtStatus = STATUS_SUCCESS;
    NTSTATUS     WinError = ERROR_SUCCESS;
    HRESULT      hr = S_OK;
    WCHAR        IniFileName[MAX_PATH+1];
    HKEY         KeyHandle = NULL;

    WCHAR        *SCHEMASECTION = L"SCHEMA";
    WCHAR        *DEFAULT = L"NOT_FOUND";
    WCHAR        *OBJECTVER = L"objectVersion";

    DWORD        SystemSchemaVersion = 0;

    WCHAR        Buffer[32];
    DWORD        returnChars = 0;

    // Now read the schema version in the ini file.

    // First, form the path to the inifile. This is the schema.ini
    // in the system32 directory

    returnChars = GetSystemDirectoryW(IniFileName,
                                      MAX_PATH+1);
    if (!returnChars) {
        WinError = GetLastError();
        goto Cleanup;
    }
    hr = StringCchCatW(IniFileName,
                       MAX_PATH+1,
                       L"\\schema.ini");
    if (FAILED(hr)) {
        WinError = HRESULT_CODE(hr);
        goto Cleanup;
    }

    GetPrivateProfileStringW(
        SCHEMASECTION,
        OBJECTVER,
        DEFAULT,
        Buffer,
        sizeof(Buffer)/sizeof(WCHAR),
        IniFileName
        );

    if ( wcscmp(Buffer, DEFAULT) ) {
         // Not the default string, so got a value

         SystemSchemaVersion = _wtoi(Buffer);
         // if we fail to convert the value into a string then
         // _wtoi() would have return 0.
         if (!SystemSchemaVersion) {
            WinError = ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE;
            goto Cleanup;
         }
    }
    else {
        // no value in the ini file. This is an error, since all builds
        // must have an objectVersion in the SCHEMA section of schema.ini

        WinError = ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE;
        goto Cleanup;
    }

    WinError = RegCreateKey(HKEY_LOCAL_MACHINE,
                            TEXT(DSA_CONFIG_SECTION),
                            &KeyHandle);

    if (WinError != ERROR_SUCCESS) {

        goto Cleanup;

    }


    //Save the Schema verison from the schema.ini to the registry
    //This will be used during IFM promotions to ensure the backup
    //wasn't taken from an older build.
    WinError = RegSetValueEx(KeyHandle,
                             TEXT(SYSTEM_SCHEMA_VERSION),
                             0,
                             REG_DWORD,
                             (LPBYTE)&SystemSchemaVersion,
                             sizeof (DWORD)
                             );
    if (WinError != ERROR_SUCCESS) {
        goto Cleanup;
    }


Cleanup:

    if (ERROR_SUCCESS != WinError) {

        NtStatus = STATUS_UNSUCCESSFUL;

    }

    WinError = RegCloseKey(KeyHandle);

    if (ERROR_SUCCESS != WinError) {

        NtStatus = STATUS_UNSUCCESSFUL;

    }

    return NtStatus;

}



NTSTATUS
SampSecureLocalMachineAccount(
    PVOID IGNORED
    )
/*++

Routine Description

    This routine is called during all promotion and upgrades of domain controllers.
    It will remove the ace from the security descriptor that allows full control
    to account opertators to the machine account now that it is a domain controller.

Parameters

    VOID.

Return Values

    STATUS_SUCCESS;

--*/
{
    NTSTATUS                 NtStatus         = STATUS_SUCCESS;
    DWORD                    Win32Err         = ERROR_SUCCESS;
    DSNAME                   *pMachineAccount = NULL;
    UNICODE_STRING           UnicodeString;
    PUNICODE_STRING          EventString[1];
    SECURITY_DESCRIPTOR      *psd             = NULL;
    DWORD                    cbSD             = 0;
    BOOLEAN                  DACLChanged      = FALSE;

    ASSERT(ROOT_OBJECT);

    // Start a DS transaction

    NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );

    if ( !NT_SUCCESS(NtStatus) ) {
        goto Cleanup;
    }

    //Get the Dsname of the machine account and the security Descriptor
    NtStatus = SampGetLocalMachineAccountandSecurityDescriptor(&pMachineAccount,
                                                               &psd,
                                                               &cbSD);
    if ( !NT_SUCCESS(NtStatus) ) {
        goto Cleanup;
    }

    //
    // Remove the Modify the Security descriptor so that it no longer
    // contains FULL CONTROL for Account Operators in the DACL
    //
    NtStatus = SampRemoveAccountOperatorsFullControlFromDACL(psd,
                                                             &cbSD,
                                                             &Win32Err,
                                                             &DACLChanged);

    if ( !NT_SUCCESS(NtStatus) ) {
        goto Cleanup;
    }
    if (!DACLChanged) {
        //the Acl has not changed no need to write it back
        goto Cleanup;
    }

    //Write the new security descriptor on to the machine object
    NtStatus = SampSetMachineAccountSecurityDescriptor(pMachineAccount,
                                                       psd,
                                                       cbSD);

    if ( !NT_SUCCESS(NtStatus) ) {
        goto Cleanup;
    }


    Cleanup:

    // End Ds transaction

    if ( pMachineAccount )
    {

        SAMP_ALLOCA(UnicodeString.Buffer,(pMachineAccount->NameLen)*sizeof(WCHAR));
        if ( !UnicodeString.Buffer ) {
            NtStatus = STATUS_NO_MEMORY;
        } else {
            memcpy(UnicodeString.Buffer,pMachineAccount->StringName,(pMachineAccount->NameLen)*sizeof(WCHAR));
            UnicodeString.Length = (USHORT)(pMachineAccount->NameLen)*sizeof(WCHAR);
            UnicodeString.MaximumLength = (USHORT)(pMachineAccount->NameLen)*sizeof(WCHAR);
        }

    } else {

        ASSERT(pMachineAccount && "FAILED to find local machine account" );

    }

    if ( !NT_SUCCESS(NtStatus) ) {
        Win32Err = RtlNtStatusToDosError(NtStatus);
    }

    NtStatus = SampMaybeEndDsTransaction(NT_SUCCESS(NtStatus)?
                        TransactionCommit:TransactionAbort);
    if ( !NT_SUCCESS(NtStatus) ) {
        Win32Err = RtlNtStatusToDosError(NtStatus);
    }

    // if no change was needed do not log anything
    if (!(!DACLChanged && NT_SUCCESS(NtStatus))) {

        //
        // Log Event if we fail to secure the local machine account
        //
        if ( ERROR_SUCCESS != Win32Err )
        {
            if (NtStatus == STATUS_DS_BUSY                ||
                NtStatus == STATUS_DISK_FULL              ||
                NtStatus == STATUS_INSUFFICIENT_RESOURCES ||
                NtStatus == STATUS_NO_MEMORY)
            {
                //
                // Schedule a retry for this
                //
                LsaIRegisterNotification(
                    SampSecureLocalMachineAccount,
                    NULL,
                    NOTIFIER_TYPE_INTERVAL,
                    0,        // no class
                    NOTIFIER_FLAG_ONE_SHOT,
                    30,        // wait for 30 seconds
                    NULL      // no handle
                    );

                //
                // Tell the user to remove ACE
                //

                EventString[0] = &UnicodeString;

                SampWriteEventLog(EVENTLOG_ERROR_TYPE,
                                  0,     // no category
                                  SAMMSG_FAILED_MACHINE_ACCOUNT_SECURE_RETRY,
                                  NULL,  // no sid
                                  1,
                                  sizeof(DWORD),
                                  EventString,
                                  (PVOID)(&Win32Err));

            } else {

                //
                // Tell the user to remove ACE
                //
                EventString[0] = &UnicodeString;

                SampWriteEventLog(EVENTLOG_ERROR_TYPE,
                                  0,     // no category
                                  SAMMSG_FAILED_MACHINE_ACCOUNT_SECURE,
                                  NULL,  // no sid
                                  1,
                                  sizeof(DWORD),
                                  EventString,
                                  (PVOID)(&Win32Err));

            }
        } else {

            //
            // Tell the account was secured
            //
            EventString[0] = &UnicodeString;

            SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                              0,     // no category
                              SAMMSG_MACHINE_ACCOUNT_SECURE,
                              NULL,  // no sid
                              1,
                              sizeof(DWORD),
                              EventString,
                              (PVOID)(&Win32Err));

        }

    }

    return NtStatus;

}


NTSTATUS
SampPerformPromotePhase2(
    IN ULONG PromoteFlags
    )
/*++

Routine Description

    This routine is called during the boot sequence following a successful
    promotion.  If successful, this routine will delete the registry key
    so that SampIsRebootAfterPromotion() will return FALSE.

Parameters

    PromoteFlags:  this is value indicates whether this is the first dc in a
                   new domain or a replica.

Return Values

    STATUS_SUCCESS; a system service error otherwise

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreNtStatus = STATUS_SUCCESS;

    //
    // Resources that need to be cleaned up
    //
    SAMPR_HANDLE ServerHandle = 0;
    SAMPR_HANDLE DomainHandle = 0;
    SAMPR_HANDLE BuiltinDomainHandle = 0;
    PPOLICY_ACCOUNT_DOMAIN_INFO  DomainInfo = NULL;


    //
    // We should not performing operations here in repair mode
    // other than a group upgrade

    ASSERT( (!LsaISafeMode()) || (SAMP_PROMOTE_INTERNAL_UPGRADE==PromoteFlags) );

    //
    //Update the registry to reflect the new schema verison from the schema.ini file

    if ( (FLAG_ON( PromoteFlags, SAMP_PROMOTE_INTERNAL_UPGRADE ) ||
          FLAG_ON( PromoteFlags, SAMP_PROMOTE_UPGRADE ) )        &&
          SampUseDsData ) {

        // On upgrades we want to update the system schema verison in the registry
        // to refect the fact that the machine was upgraded.
        IgnoreNtStatus = SampRecordSystemSchemaVerisonInRegistry();
        //Ignore Errors
        ASSERT(STATUS_SUCCESS == IgnoreNtStatus);

    }


    //
    // Open the server
    //
    NtStatus = SampConnect(NULL,           // server name, this is ignored
                           &ServerHandle,
                           SAM_CLIENT_LATEST,
                           GENERIC_ALL,    // all access
                           TRUE,           // trusted client
                           FALSE,
                           FALSE,          // NotSharedByMultiThreads
                           TRUE
                           );

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamIConnect failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }


    //
    // Get the current domain's sid
    //
    NtStatus = SampGetAccountDomainInfo(&DomainInfo);
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampGetAccountDomainInfo failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }
    ASSERT(DomainInfo);
    ASSERT(DomainInfo->DomainSid);

    //
    // Open the current domain
    //
    NtStatus = SamrOpenDomain(ServerHandle,
                              GENERIC_ALL,
                              DomainInfo->DomainSid,
                              &DomainHandle);
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamrOpenDomain failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    //
    // Open the builtin domain
    //
    NtStatus = SamrOpenDomain(ServerHandle,
                              GENERIC_ALL,
                              SampBuiltinDomainSid,
                              &BuiltinDomainHandle);
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamrOpenDomain (Builtin) failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_REPLICA ) )
    {

        NtStatus = SampPerformReplicaDcPromotePhase2(DomainHandle);
        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampPerformReplicaDcPromotePhase2 function failed with 0x%x\n",
                       NtStatus));
        }
    }
    else if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_DOMAIN ) )
    {
        NtStatus = SampPerformFirstDcPromotePhase2(DomainHandle,
                                                   BuiltinDomainHandle,
                                                   PromoteFlags );

    }
    else if ( FLAG_ON( PromoteFlags, SAMP_DEMOTE_MEMBER ) )
    {
        NtStatus = SampPerformNewServerPhase2( DomainHandle,
                                               TRUE );
        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampPerformNewServerPhase2 function failed with 0x%x\n",
                       NtStatus));
        }
    }
    else if ( FLAG_ON( PromoteFlags, SAMP_DEMOTE_STANDALONE ) )
    {
        NtStatus = SampPerformNewServerPhase2( DomainHandle,
                                               FALSE );
        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampPerformNewServerPhase2 function failed with 0x%x\n",
                       NtStatus));
        }
    }
    else if ( FLAG_ON( PromoteFlags, SAMP_TEMP_UPGRADE ) )
    {
        NtStatus = SampPerformTempUpgradeWork( DomainHandle );
        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampPerformTempUpgradeWork function failed with 0x%x\n",
                       NtStatus));
        }
    }
    else if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_INTERNAL_UPGRADE ) )
    {
        //
        // Only do this on the PDC
        //
        DOMAIN_SERVER_ROLE ServerRole;

        NtStatus = SamIQueryServerRole( DomainHandle, &ServerRole );
        if (  NT_SUCCESS( NtStatus )
          &&  (ServerRole == DomainServerRolePrimary) ) {

            //
            // add well known accounts and apply well known memberhships
            //

            NtStatus = SampAddAccountsAndApplyMemberships(
                                        DomainHandle,
                                        BuiltinDomainHandle,
                                        DomainInfo->DomainSid,
                                        PromoteFlags
                                        );

        }
    }
    else
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: Invalid promote phase 2 data\n"));

        //
        // Oh, well, continue on
        //
        NtStatus = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // For promotions and upgrades secure the machine account.
    //
    if (SampUseDsData &&
        (PromoteFlags & (SAMP_PROMOTE_DOMAIN  |
                         SAMP_PROMOTE_REPLICA |
                         SAMP_PROMOTE_INTERNAL_UPGRADE)
         )
        )
    {
        IgnoreNtStatus = SampSecureLocalMachineAccount(NULL);
        //Ignore Errors
    }

    if ( FLAG_ON( PromoteFlags, SAMP_PROMOTE_UPGRADE ) )
    {
        //
        // At this point, we have successfully booted from
        // the ds and created all our needed security principals.
        // Let's clean up.
        //

        //
        // Delete the saved upgrade hive
        //

        WCHAR*   SystemRoot = L"systemroot";
        WCHAR*   ConfigDirectoryPath = L"\\system32\\config";

        WCHAR *FilesToDelete[] =
        {
            SAMP_DOWNLEVEL_DB_FILENAME,
            SAMP_NEW_DB_FILENAME,
            SAMP_DOWNLEVEL_DB_FILENAME_BACKUP
        };

        WCHAR    SystemRootPath[ MAX_PATH + 1];
        ULONG    Size;

        WCHAR    FilePath[ MAX_PATH + 1];

        DWORD    WinError = ERROR_SUCCESS;

        BOOL     fStatus;

        ULONG i;



        //
        // Construct the file names
        //
        RtlSecureZeroMemory( SystemRootPath, sizeof( SystemRootPath ) );
        Size = sizeof( SystemRootPath ) / sizeof(WCHAR);
        Size = GetEnvironmentVariable( SystemRoot,
                                       SystemRootPath,
                                       Size );

        for ( i = 0 ; i < ARRAY_COUNT( FilesToDelete ); i++ ) {

            wcscpy( FilePath, SystemRootPath );
            wcscat( FilePath, ConfigDirectoryPath );
            wcscat( FilePath, FilesToDelete[i] );

            fStatus = DeleteFile( FilePath );

            if ( !fStatus )
            {
                //
                // Tell the user to delete this file
                //
                PUNICODE_STRING EventString[1];
                UNICODE_STRING  UnicodeString;

                WinError = GetLastError();
                if ( WinError != ERROR_FILE_NOT_FOUND )
                {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: Failed to delete directory %ls; error %d\n",
                               FilePath,
                               WinError));

                    RtlInitUnicodeString( &UnicodeString, FilePath );
                    EventString[0] = &UnicodeString;

                    SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                                      0,     // no category
                                      SAMMSG_DATABASE_FILE_NOT_DELETED,
                                      NULL,  // no sid
                                      1,
                                      sizeof(DWORD),
                                      EventString,
                                      (PVOID)(&WinError));
                }
            }
        }
    }

    //
    // That's it - fall through to clean up
    //

Cleanup:

    if (ServerHandle) {
        SamrCloseHandle(&ServerHandle);
    }

    if (DomainHandle) {
        SamrCloseHandle(&DomainHandle);
    }

    if (BuiltinDomainHandle) {
        SamrCloseHandle(&BuiltinDomainHandle);
    }

    if (DomainInfo) {
        LsaIFree_LSAPR_POLICY_INFORMATION (PolicyAccountDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION)DomainInfo);
    }

    //
    // Everything was successful; get rid of the key
    //
    if (NT_SUCCESS(NtStatus)
     && !FLAG_ON( PromoteFlags, SAMP_PROMOTE_INTERNAL_UPGRADE )  ) {

        NtStatus =  SampDeleteKeyForPostBootPromote();
        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampDeleteKeyForPostBootPromote failed with 0x%x\n",
                       NtStatus));
        }
        ASSERT(NT_SUCCESS(NtStatus));

        // An error here is not fatal
        NtStatus = STATUS_SUCCESS;
    }

    //
    // During the development phase, we want to trap all instances of this
    // path failing.  It should never fail.  If it does then, SamIInitialize
    // fails, indicating a failed boot sequence.
    //

    ASSERT(NT_SUCCESS(NtStatus));

    return NtStatus;
}


NTSTATUS
SampPerformFirstDcPromotePhase2(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMPR_HANDLE BuiltinDomainHandle,
    IN ULONG        Flags
    )
/*++

Routine Description

    This routine performs the steps necessary to complete the promotion
    of a member server to a domain controller.


Parameters

    None.

Return Values

    STATUS_SUCCESS or STATUS_NO_MEMORY

--*/
{
    NTSTATUS                    NtStatus, IgnoreStatus;
    HANDLE                      PolicyHandle = 0;
    POLICY_LSA_SERVER_ROLE_INFO ServerRoleInfo;
    ULONG                       RetryCount;
    PSID                        DomainSid = NULL;
    PSAMP_OBJECT                DomainContext = NULL;

    //
    // Extract the domain sid
    //
    DomainContext = (PSAMP_OBJECT)DomainHandle;
    ASSERT( DomainContext->ObjectNameInDs );
    DomainSid = (PSID) &DomainContext->ObjectNameInDs->Sid;
    ASSERT( DomainSid );

    if ( !SampUseDsData )
    {
        //
        // Guard ourselves against wierd configurations
        //
        return STATUS_SUCCESS;
    }

    //
    // Create the accounts
    //
    RetryCount = 0;
    do
    {
        NtStatus = SampCreateFirstMachineAccount(DomainHandle);

        if ( NtStatus == STATUS_DS_BUSY )
        {
            //
            // There is a problem arising where the ds is "busy"
            // during boot time hence failing this creation.
            //

            //
            // In checked builds, ASSERT so we can figure out why this busy
            // is being caused. Look at the other threads in lsass.exe that
            // would cause this busy state.
            //
            ASSERT( !"SAMSS: DS is busy during machine account creation" );

            if ( RetryCount > 10 )
            {
                //
                // N.B. Potentially spin off a thread to create the account
                //
                break;

            }

            Sleep( 1000 );
            RetryCount++;
        }

    }  while ( NtStatus == STATUS_DS_BUSY );

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampCreateFirstMachineAccount failed with 0x%x\n",
                   NtStatus));

        return NtStatus;
    }


    //
    // Double check there is no existing krbtgt account
    // before we add all well known accounts
    //
    NtStatus = SampRenameKrbtgtAccount();
    if ( !NT_SUCCESS(NtStatus) )
    {
        // Well, let's try to make the account anyway
        NtStatus = STATUS_SUCCESS;
    }


    //
    // add well known accounts and apply well known memberhships
    //

    NtStatus = SampAddAccountsAndApplyMemberships(
                                DomainHandle,
                                BuiltinDomainHandle,
                                DomainSid,
                                Flags
                                );

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampAddAccountsAndApplyMemberships failed with 0x%x\n",
                   NtStatus));
    }

    if ( NT_SUCCESS( NtStatus ) )
    {
        //
        // For new domain, add the ea to the administrators
        //
        NtStatus = SampAddEnterpriseAdminsToAdministrators();
        // SampAddEnterpriseAdminsToAdministrators must handle
        // all cases
        ASSERT( NT_SUCCESS( NtStatus ) );
    }

    return NtStatus;

}

NTSTATUS
SampSetNtDsaLink(
  DSNAME * Object
  )
/*++

  Routine Description

    This routine sets the link between the machine account object
    and the server object.

  Parameters:

       Object Ds Name of the object

  Return Values

    STATUS_SUCCESS
    Other Error Codes from Failed Dir Calls
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    MODIFYARG   ModifyArg;
    MODIFYRES   *pModifyRes;
    ULONG        RetCode = 0;
    DSNAME      *DsaDN = NULL;
    DSNAME      *ServerDN;
    ATTRVAL     AttrVal;
    ULONG       NameSize=0;
    BOOL        fErr = FALSE;



    //
    // Get the DSA object
    //

    NtStatus = GetConfigurationName(
                    DSCONFIGNAME_DSA,
                    &NameSize,
                    NULL
                    );

    if ((NT_SUCCESS(NtStatus))|| (STATUS_BUFFER_TOO_SMALL == NtStatus))
    {
        SAMP_ALLOCA(DsaDN,NameSize);
        if (NULL!=DsaDN)
        {

            NtStatus = GetConfigurationName(
                          DSCONFIGNAME_DSA,
                          &NameSize,
                          DsaDN
                          );
        }
        else
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (!NT_SUCCESS(NtStatus))
        goto Error;


    //
    // Begin a transaction
    //

    NtStatus = SampMaybeBeginDsTransaction(TransactionWrite);
    if (!NT_SUCCESS(NtStatus))
        goto Error;

    //
    // Our gAnchor shouldd be initialize now
    //

    ASSERT(NULL!=DsaDN);

    // Get the server DN from DsaDN

    SAMP_ALLOCA(ServerDN,DsaDN->structLen);
    if (NULL==ServerDN)
    {
         NtStatus = STATUS_INSUFFICIENT_RESOURCES;
         goto Error;
    }

    fErr = TrimDSNameBy(DsaDN, 1, ServerDN);
    if (fErr) {
      // Error from TrimDSNameBy
      KdPrintEx((DPFLTR_SAMSS_ID,
                 DPFLTR_INFO_LEVEL,
                 "Cannot trim DsaDN %d\n",
                 fErr));
    }


    //
    // Build a ModifyArg and perform the Dir Add Entry
    //

    RtlSecureZeroMemory(&ModifyArg,sizeof(ModifyArg));
    BuildStdCommArg(&ModifyArg.CommArg);
    ModifyArg.pObject = ServerDN;
    ModifyArg.count =1;
    ModifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
    ModifyArg.FirstMod.AttrInf.attrTyp = ATT_SERVER_REFERENCE;
    ModifyArg.FirstMod.AttrInf.AttrVal.valCount=1;
    ModifyArg.FirstMod.AttrInf.AttrVal.pAVal = &AttrVal;
    AttrVal.pVal = (UCHAR *) Object;
    AttrVal.valLen = Object->structLen;

    RetCode = DirModifyEntry(&ModifyArg,&pModifyRes);

    if (NULL==pModifyRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetCode,&pModifyRes->CommRes);
    }


Error:

    SampMaybeEndDsTransaction((NT_SUCCESS(NtStatus))?
            TransactionCommit:TransactionAbort);
    return NtStatus;
}



NTSTATUS
SampPerformReplicaDcPromotePhase2(
    SAMPR_HANDLE DomainHandle
    )
/*++

Routine Description

    This routine performs the steps necessary to complete the promotion
    of a member server to a domain controller.

    The following actions are performed:

    1) Set the link from the computer object to the server object

Parameters

    None.

Return Values

    STATUS_SUCCESS

--*/
{
    NTSTATUS    IgnoreStatus, NtStatus = STATUS_SUCCESS;
    WCHAR       MachineAccountName[MAX_COMPUTERNAME_LENGTH+2]; // +2 for NULL and $
    ULONG       ComputerNameLength = ARRAY_COUNT(MachineAccountName);
    RPC_UNICODE_STRING            AccountName;

    //
    // Resources to be cleaned up
    //
    SAMPR_HANDLE              UserHandle = 0;
    PUSER_CONTROL_INFORMATION UserControlInfo = NULL;
    SAMPR_ULONG_ARRAY         Rids;
    SAMPR_ULONG_ARRAY         UseRid;

    //
    // Init resources
    //
    RtlSecureZeroMemory(&Rids, sizeof(Rids));
    RtlSecureZeroMemory(&UseRid, sizeof(UseRid));

    if ( !SampUseDsData )
    {
        //
        // Protect against wierd configurations
        //
        return STATUS_SUCCESS;

    }

    //
    //
    //
    //
    // Get the Machine Account Name
    //

    if (!GetComputerNameW(MachineAccountName, &ComputerNameLength)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: GetComputerName failed with %d\n",
                   GetLastError()));

        NtStatus = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }


    wcscat(MachineAccountName, L"$");
    AccountName.Length = wcslen(MachineAccountName) * sizeof(WCHAR); // don't include the NULL
    AccountName.MaximumLength = AccountName.Length + sizeof(WCHAR);  // include the NULL
    AccountName.Buffer = MachineAccountName;


    //
    // See if the machine account exists
    //

    NtStatus =  SamrLookupNamesInDomain(DomainHandle,
                                        1,
                                        &AccountName,
                                        &Rids,
                                        &UseRid);

    if (NtStatus == STATUS_SUCCESS) {

        //
        // The account exists, open a handle to it, so we can set its
        // password
        //

        ASSERT(TRUE == UseRid.Element[0]);
        NtStatus = SamrOpenUser(DomainHandle,
                                GENERIC_ALL,
                                Rids.Element[0],
                                &UserHandle);

        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SamrOpenUser failed with 0x%x\n",
                       NtStatus));

            goto Cleanup;
        }
    } else {

        //
        // Log this event since it prevents start up
        //
        SampWriteEventLog(EVENTLOG_ERROR_TYPE,
                          0,     // no category
                          SAMMSG_MACHINE_ACCOUNT_MISSING,
                          NULL,  // no sid
                          0,
                          sizeof(DWORD),
                          NULL,
                          (PVOID)(&NtStatus));


        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamrLookupNamesInDomain failed with 0x%x\n",
                   NtStatus));

        //
        // Don't let this fail the boot
        //
        NtStatus = STATUS_SUCCESS;

        goto Cleanup;

    }

    //
    // Set the Link to the our MSFT DSA Object
    //

    NtStatus = SampSetNtDsaLink(
                    ((PSAMP_OBJECT)(UserHandle))->ObjectNameInDs
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampSetNtDsaLink failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

Cleanup:

    if (UserHandle) {
        SamrCloseHandle(&UserHandle);
    }

    if (Rids.Element) {
         MIDL_user_free(Rids.Element);
    }

    if (UseRid.Element) {
        MIDL_user_free(UseRid.Element);
    }

    return NtStatus;
}

NTSTATUS
SampCreateFirstMachineAccount(
    SAMPR_HANDLE DomainHandle
    )
/*++

Routine Description:

    This routine creates a machine object for the first DC in a domain.
    The password is initially set to the name of the account, which is
    <ComputerName>$

Parameters:

    DomainHandle:  this is a valid handle to the account domain object

Return Values:

    STATUS_SUCCESS if success; appropriate NTSTATUS otherwise

--*/
{
    NTSTATUS                      NtStatus = STATUS_SUCCESS;
    RPC_UNICODE_STRING            AccountName;
    ULONG                         AccessGranted;
    ULONG                         Rid = 0;
    USER_SET_PASSWORD_INFORMATION UserPasswordInfo;
    WCHAR                         MachineAccountName[MAX_COMPUTERNAME_LENGTH+2];
                                  // +2 for NULL and $
    ULONG                         ComputerNameLength = ARRAY_COUNT(MachineAccountName);
    WCHAR                         Password[SAMP_RANDOM_GENERATED_PASSWORD_LENGTH +1];
    BOOLEAN                       fStatus;
    ULONG                         Length, i;


    //
    // Resources to be cleaned up
    //
    SAMPR_HANDLE              UserHandle = 0;
    PUSER_CONTROL_INFORMATION UserControlInfo = NULL;
    SAMPR_ULONG_ARRAY         Rids;
    SAMPR_ULONG_ARRAY         UseRid;

    //
    // Parameter checking
    //
    ASSERT(DomainHandle);

    //
    // Stack clearing
    //
    RtlSecureZeroMemory(&UserPasswordInfo, sizeof(UserPasswordInfo));
    RtlSecureZeroMemory(MachineAccountName, sizeof(MachineAccountName));
    RtlSecureZeroMemory(Password, sizeof(Password));
    RtlSecureZeroMemory(&Rids, sizeof(Rids));
    RtlSecureZeroMemory(&UseRid, sizeof(UseRid));


    //
    // Build the account name.
    //
    if (!GetComputerNameW(MachineAccountName, &ComputerNameLength)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: GetComputerName failed with %d\n",
                   GetLastError()));

        NtStatus = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }
    wcscat(MachineAccountName, L"$");

    //
    // Build a random password
    //
    NtStatus = SampGenerateRandomPassword( Password,
                                           ARRAY_COUNT( Password ) );
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // RPC_UNICODE_STRING's are a bit different than UNICODE_STRING's;
    // RPC_UNICODE_STRING count the number of bytes
    //
    AccountName.Length = wcslen(MachineAccountName) * sizeof(WCHAR); // don't include the NULL
    AccountName.MaximumLength = AccountName.Length + sizeof(WCHAR);  // include the NULL
    AccountName.Buffer = MachineAccountName;

    //
    // Sanity check - if this assert is not true, then kerberos will
    // no longer work since it initially depends on the password
    // of the machine account to be the name of the computer
    //
    ASSERT(SAM_MAX_PASSWORD_LENGTH > MAX_COMPUTERNAME_LENGTH);

    //
    // See if the machine account already exists
    //
    NtStatus =  SamrLookupNamesInDomain(DomainHandle,
                                        1,
                                        &AccountName,
                                        &Rids,
                                        &UseRid);

    if (NtStatus == STATUS_NONE_MAPPED) {

        ULONG DomainIndex;
        ULONG GrantedAccess;

        //
        // The account does not exist, create it
        //


        //
        // 1. Allocate a RID for the account ( remember that the
        //    Rid manager is not yet initialized
        //
        DomainIndex = ((PSAMP_OBJECT)DomainHandle)->DomainIndex;
        Rid = SampDefinedDomains[DomainIndex].CurrentFixed.NextRid++;

        //
        // 2. Create the user with the right Rid.
        //
        NtStatus = SampCreateUserInDomain(DomainHandle,
                                  (RPC_UNICODE_STRING *)&AccountName,
                                  USER_SERVER_TRUST_ACCOUNT,
                                  GENERIC_ALL,
                                  FALSE,       //writelock held
                                  FALSE,       //not loopback client
                                  &UserHandle,
                                  &GrantedAccess,
                                  &Rid);

        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SamrCreateUser2InDomain failed with 0x%x\n",
                       NtStatus));

            goto Cleanup;
        }

    } else if (NtStatus == STATUS_SUCCESS) {
        //
        // The account exists, open a handle to it, so we can set its
        // password
        //
        ASSERT(TRUE == UseRid.Element[0]);
        NtStatus = SamrOpenUser(DomainHandle,
                                GENERIC_ALL,
                                Rids.Element[0],
                                &UserHandle);

        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SamrOpenUser failed with 0x%x\n",
                       NtStatus));

            goto Cleanup;
        }
        Rid = Rids.Element[0];
    } else {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamrLookupNamesInDomain failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;

    }
    ASSERT(UserHandle);
    ASSERT( 0 != Rid );

    //
    // Set the appropriate control control fields
    //
    NtStatus = SamrQueryInformationUser2(UserHandle,
                                         UserControlInformation,
                                         (PSAMPR_USER_INFO_BUFFER*)&UserControlInfo);
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamrQueryInformationUser2 failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    UserControlInfo->UserAccountControl &= ~USER_PASSWORD_NOT_REQUIRED;
    UserControlInfo->UserAccountControl &= ~USER_ACCOUNT_DISABLED;
    UserControlInfo->UserAccountControl &= ~USER_ACCOUNT_TYPE_MASK;
    UserControlInfo->UserAccountControl |=  USER_SERVER_TRUST_ACCOUNT;
    UserControlInfo->UserAccountControl |=  USER_TRUSTED_FOR_DELEGATION;

    NtStatus = SamrSetInformationUser(UserHandle,
                                      UserControlInformation,
                                      (PSAMPR_USER_INFO_BUFFER)UserControlInfo);
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamrSetInformationUser failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    //
    // Set the password
    //
    NtStatus = SampSetPassword(UserHandle,
                               (PUNICODE_STRING) &AccountName,
                               Rid,
                               Password);

    if(!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampSetPassword failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    NtStatus  = SampSetMachineAccountSecret( Password );

    if(!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampSetMachineAccountSecret failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    //
    // Set the Link to the our server Object
    //

    NtStatus = SampSetNtDsaLink(
                    ((PSAMP_OBJECT)(UserHandle))->ObjectNameInDs
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampSetNtDsaLink failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }


    //
    // That's it; fall through to cleanup
    //

Cleanup:

    RtlSecureZeroMemory(Password, sizeof(Password));

    if (UserHandle) {
        SamrCloseHandle(&UserHandle);
    }

    if (UserControlInfo) {
        SamIFree_SAMPR_USER_INFO_BUFFER((PSAMPR_USER_INFO_BUFFER)UserControlInfo,
                                        UserControlInformation);
    }

    if (Rids.Element) {
         MIDL_user_free(Rids.Element);
    }

    if (UseRid.Element) {
        MIDL_user_free(UseRid.Element);
    }

    return NtStatus;
}



struct DS_WELL_KNOWN_ACCOUNT_TABLE
{
    ULONG   LocalizedName;
    ULONG   LocalizedComment;
    WCHAR * Password;
    ULONG   Rid;
    SAMP_OBJECT_TYPE ObjectType;
    SAM_ACCOUNT_TYPE AccountType;
    NTSTATUS NotFoundStatus;
    BOOLEAN  fBuiltinAccount;
    BOOLEAN  fEnterpriseOnly;
    BOOLEAN  fOnDC;
    BOOLEAN  fOnProfessional;
    BOOLEAN  fOnServer;
    BOOLEAN  fOnPersonal;
    BOOLEAN  fNewForNt5;    // The account did not exist on NT 3.x - 4.x
                            // versions of Windows NT
}  DsWellKnownAccounts[] =

{
    {
        SAMP_USER_NAME_ADMIN,
        SAMP_USER_COMMENT_ADMIN,
        NULL, // note -- this will cause a random password to be generated
        DOMAIN_USER_RID_ADMIN,
        SampUserObjectType,
        SamObjectUser,
        STATUS_NO_SUCH_USER,
        FALSE, // builitn account
        FALSE, // enterprise only
        TRUE,  // fOnDC
        TRUE,  // fOnProfessional
        TRUE,  // fOnServer
        FALSE, // fOnPersonal
        FALSE  // fNewForNT5
    },
    {
        SAMP_USER_NAME_GUEST,
        SAMP_USER_COMMENT_GUEST,
        L"", // blank password
        DOMAIN_USER_RID_GUEST,
        SampUserObjectType,
        SamObjectUser,
        STATUS_NO_SUCH_USER,
        FALSE, // builtin
        FALSE, // enterprise only
        FALSE, // fOnDC
        TRUE,  // fOnProfessional
        TRUE,  // fOnServer
        FALSE, // fOnPersonal
        FALSE  // fNewForNT5
    },
    {
        SAMP_USER_NAME_KRBTGT,
        SAMP_USER_COMMENT_KRBTGT,
        NULL, // note -- this will cause a random password to be generated
        DOMAIN_USER_RID_KRBTGT,
        SampUserObjectType,
        SamObjectUser,
        STATUS_NO_SUCH_USER,
        FALSE, // builtin
        FALSE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        TRUE// fNewForNT5

    },
    {
        SAMP_GROUP_NAME_COMPUTERS,
        SAMP_GROUP_COMMENT_COMPUTERS,
        NULL,
        DOMAIN_GROUP_RID_COMPUTERS,
        SampGroupObjectType,
        SamObjectGroup,
        STATUS_NO_SUCH_GROUP,
        FALSE,// builtin
        FALSE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        TRUE// fNewForNT5
    },
    {
        SAMP_GROUP_NAME_CONTROLLERS,
        SAMP_GROUP_COMMENT_CONTROLLERS,
        NULL,
        DOMAIN_GROUP_RID_CONTROLLERS,
        SampGroupObjectType,
        SamObjectGroup,
        STATUS_NO_SUCH_GROUP,
        FALSE,// builtin
        FALSE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        TRUE// fNewForNT5
    },
    {
        SAMP_GROUP_NAME_SCHEMA_ADMINS,
        SAMP_GROUP_COMMENT_SCHEMA_ADMINS,
        NULL,
        DOMAIN_GROUP_RID_SCHEMA_ADMINS,
        SampGroupObjectType,
        SamObjectGroup,
        STATUS_NO_SUCH_GROUP,
        FALSE,// builtin
        TRUE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        TRUE// fNewForNT5
    },
    {
        SAMP_GROUP_NAME_ENTERPRISE_ADMINS,
        SAMP_GROUP_COMMENT_ENTERPRISE_ADMINS,
        NULL,
        DOMAIN_GROUP_RID_ENTERPRISE_ADMINS,
        SampGroupObjectType,
        SamObjectGroup,
        STATUS_NO_SUCH_GROUP,
        FALSE,// builtin
        TRUE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        TRUE// fNewForNT5
    },
    {
        SAMP_GROUP_NAME_CERT_ADMINS,
        SAMP_GROUP_COMMENT_CERT_ADMINS,
        NULL,
        DOMAIN_GROUP_RID_CERT_ADMINS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        FALSE,// builtin
        FALSE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        TRUE// fNewForNT5
    },
    {
        SAMP_GROUP_NAME_ADMINS,
        SAMP_GROUP_COMMENT_ADMINS,
        NULL,
        DOMAIN_GROUP_RID_ADMINS,
        SampGroupObjectType,
        SamObjectGroup,
        STATUS_NO_SUCH_GROUP,
        FALSE, // builtin
        FALSE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        FALSE// fNewForNT5
    },
    {
        SAMP_GROUP_NAME_USERS,
        SAMP_GROUP_COMMENT_USERS,
        NULL,
        DOMAIN_GROUP_RID_USERS,
        SampGroupObjectType,
        SamObjectGroup,
        STATUS_NO_SUCH_GROUP,
        FALSE,// builtin
        FALSE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        FALSE// fNewForNT5
    },
    {
        SAMP_GROUP_NAME_GUESTS,
        SAMP_GROUP_COMMENT_GUESTS,
        NULL,
        DOMAIN_GROUP_RID_GUESTS,
        SampGroupObjectType,
        SamObjectGroup,
        STATUS_NO_SUCH_GROUP,
        FALSE,// builtin
        FALSE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        FALSE// fNewForNT5
    },
    {
        SAMP_GROUP_NAME_POLICY_ADMINS,
        SAMP_GROUP_COMMENT_POLICY_ADMINS,
        NULL,
        DOMAIN_GROUP_RID_POLICY_ADMINS,
        SampGroupObjectType,
        SamObjectGroup,
        STATUS_NO_SUCH_GROUP,
        FALSE,// builtin
        FALSE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        TRUE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_RAS_SERVERS,
        SAMP_ALIAS_COMMENT_RAS_SERVERS,
        NULL,
        DOMAIN_ALIAS_RID_RAS_SERVERS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        FALSE,// builtin
        FALSE,// enterprise only
        TRUE,// fOnDC
        FALSE,// fOnProfessional
        FALSE,// fOnServer
        FALSE,// fOnPersonal
        TRUE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_SERVER_OPS,
        SAMP_ALIAS_COMMENT_SERVER_OPS,
        NULL,
        DOMAIN_ALIAS_RID_SYSTEM_OPS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        FALSE,// fOnProfessional,
        FALSE,// fOnServer
        FALSE,// fOnPersonal,
        FALSE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_ACCOUNT_OPS,
        SAMP_ALIAS_COMMENT_ACCOUNT_OPS,
        NULL,
        DOMAIN_ALIAS_RID_ACCOUNT_OPS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        FALSE,// fOnProfessional,
        FALSE,// fOnServer,
        FALSE,// fOnPersonal,
        FALSE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_PRINT_OPS,
        SAMP_ALIAS_COMMENT_PRINT_OPS,
        NULL,
        DOMAIN_ALIAS_RID_PRINT_OPS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        FALSE,// fOnProfessional,
        TRUE,// fOnServer
        FALSE,// fOnPersonal,
        FALSE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_ADMINS,
        SAMP_ALIAS_COMMENT_ADMINS,
        NULL,
        DOMAIN_ALIAS_RID_ADMINS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        TRUE,// fOnProfessional
        TRUE,// fOnServer
        FALSE,// fOnPersonal,
        FALSE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_USERS,
        SAMP_ALIAS_COMMENT_USERS,
        NULL,
        DOMAIN_ALIAS_RID_USERS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        TRUE,// fOnProfessional
        TRUE,// fOnServer
        FALSE,// fOnPersonal,
        FALSE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_GUESTS,
        SAMP_ALIAS_COMMENT_GUESTS,
        NULL,
        DOMAIN_ALIAS_RID_GUESTS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        TRUE,// fOnProfessional
        TRUE,// fOnServer
        FALSE,// fOnPersonal,
        FALSE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_BACKUP_OPS,
        SAMP_ALIAS_COMMENT_BACKUP_OPS,
        NULL,
        DOMAIN_ALIAS_RID_BACKUP_OPS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        TRUE,// fOnProfessional
        TRUE,// fOnServer
        FALSE,// fOnPersonal,
        FALSE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_REPLICATOR,
        SAMP_ALIAS_COMMENT_REPLICATOR,
        NULL,
        DOMAIN_ALIAS_RID_REPLICATOR,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        FALSE,// fOnProfessional,
        TRUE,// fOnServer
        FALSE,// fOnPersonal,
        FALSE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_PREW2KCOMPACCESS,
        SAMP_ALIAS_COMMENT_PREW2KCOMPACCESS,
        NULL,
        DOMAIN_ALIAS_RID_PREW2KCOMPACCESS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        FALSE,// fOnProfessional,
        FALSE,// fOnServer,
        FALSE,// fOnPersonal,
        TRUE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_REMOTE_DESKTOP_USERS,
        SAMP_ALIAS_COMMENT_REMOTE_DESKTOP_USERS,
        NULL,
        DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        TRUE,// fOnProfessional
        TRUE,// fOnServer
        FALSE,// fOnPersonal,
        TRUE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_NETWORK_CONFIGURATION_OPS,
        SAMP_ALIAS_COMMENT_NETWORK_CONFIGURATION_OPS,
        NULL,
        DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        TRUE,// fOnProfessional
        TRUE,// fOnServer
        FALSE,// fOnPersonal,
        TRUE// fNewForNT5
    },
    {
     SAMP_ALIAS_NAME_POWER_USERS,
     SAMP_ALIAS_COMMENT_POWER_USERS,
     NULL,
     DOMAIN_ALIAS_RID_POWER_USERS,
     SampAliasObjectType,
     SamObjectAlias,
     STATUS_NO_SUCH_ALIAS,
     TRUE,  // builtin
     FALSE, // enterprise only,
     FALSE, // fOnDC
     TRUE,  // fOnProfessional
     TRUE, // fOnServer
     FALSE,  // fOnPersonal,
     FALSE  // fNewForNT5
    },
    {
     SAMP_ALIAS_NAME_INCOMING_FOREST_TRUST_BUILDERS,
     SAMP_ALIAS_COMMENT_INCOMING_FOREST_TRUST_BUILDERS,
     NULL,
     DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS,
     SampAliasObjectType,
     SamObjectAlias,
     STATUS_NO_SUCH_ALIAS,
     TRUE,  // builtin
     TRUE, // enterprise only,
     TRUE,  // fOnDC
     FALSE, // fOnProfessional
     FALSE, // fOnServer
     FALSE, // fOnPersonal,
     TRUE   // fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_MONITORING_USERS,
        SAMP_ALIAS_COMMENT_MONITORING_USERS,
        NULL,
        DOMAIN_ALIAS_RID_MONITORING_USERS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        TRUE,// fOnProfessional
        TRUE,// fOnServer
        FALSE,// fOnPersonal,
        TRUE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_LOGGING_USERS,
        SAMP_ALIAS_COMMENT_LOGGING_USERS,
        NULL,
        DOMAIN_ALIAS_RID_LOGGING_USERS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE,// builtin
        FALSE,// enterprise only,
        TRUE,// fOnDC
        TRUE,// fOnProfessional
        TRUE,// fOnServer
        FALSE,// fOnPersonal,
        TRUE// fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_AUTHORIZATIONACCESS,
        SAMP_ALIAS_COMMENT_AUTHORIZATIONACCESS,
        NULL,
        DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE, // builtin
        FALSE,// enterprise only,
        TRUE, // fOnDC
        FALSE,// fOnProfessional,
        FALSE,// fOnServer,
        FALSE,// fOnPersonal,
        TRUE  // fNewForNT5
    },
    {
        SAMP_ALIAS_NAME_TS_LICENSE_SERVERS,
        SAMP_ALIAS_COMMENT_TS_LICENSE_SERVERS,
        NULL,
        DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS,
        SampAliasObjectType,
        SamObjectAlias,
        STATUS_NO_SUCH_ALIAS,
        TRUE, // builtin
        FALSE,// enterprise only,
        TRUE, // fOnDC
        FALSE,// fOnProfessional,
        FALSE,// fOnServer,
        FALSE,// fOnPersonal,
        TRUE  // fNewForNT5
    }
};

//
// Any Sid within builtin domain and account domain
// are not considered as well known SID in this routine,
// because there is a real object in the backing store.
//
// For example  Builtin Domain itself,
//              Administrators Alias,
//              Domain Users Group are NOT well known here
//
// Only those SIDs, which there is no real object to present
// them, are considered Well Known in SAM.
//
// For Example  Anonymous Logon SID
//              Dialup SID
//              Network Service SID are well known SIDs.
//

struct DS_WELL_KNOWN_MEMBERSHIP_TABLE
{
    ULONG            AccountName;
    ULONG            AccountRid;
    SAMP_OBJECT_TYPE AccountType;
    BOOLEAN          fBuiltinAccount;

    ULONG            GroupName;
    ULONG            GroupRid;       // This could be an "alias", too
    SAMP_OBJECT_TYPE GroupType;
    BOOLEAN          fBuiltinGroup;

    BOOLEAN          fEnterpriseOnly;

    USHORT           ReleaseVersion; // The release in which the membership
                                     // was default

#define NT4_RELEASE    (0x0400)
#define WIN2K_RELEASE  (0x0500)
#define XP_RELEASE     (0x0501)
#define WS03_RELEASE   (0x0502)


    BOOLEAN          fDSOnly;       // the membership is only for DS mode

    BOOLEAN          fWellKnownSid;
    PSID             *WellKnownAccountSid;

}  DsWellKnownMemberships[] =
{
    {
      SAMP_GROUP_NAME_ADMINS,
      DOMAIN_GROUP_RID_ADMINS,
      SampGroupObjectType,
      FALSE,
      SAMP_ALIAS_NAME_ADMINS,
      DOMAIN_ALIAS_RID_ADMINS,
      SampAliasObjectType,
      TRUE,
      FALSE,
      NT4_RELEASE,
      TRUE,     //fDSOnly
      FALSE,
      NULL
    },
    {
      SAMP_GROUP_NAME_USERS,
      DOMAIN_GROUP_RID_USERS,
      SampGroupObjectType,
      FALSE,
      SAMP_ALIAS_NAME_USERS,
      DOMAIN_ALIAS_RID_USERS,
      SampAliasObjectType,
      TRUE,
      FALSE,
      NT4_RELEASE,
      TRUE,     //fDSOnly
      FALSE,
      NULL
    },
    {
      SAMP_GROUP_NAME_GUESTS,
      DOMAIN_GROUP_RID_GUESTS,
      SampGroupObjectType,
      FALSE,
      SAMP_ALIAS_NAME_GUESTS,
      DOMAIN_ALIAS_RID_GUESTS,
      SampAliasObjectType,
      TRUE,
      FALSE,
      NT4_RELEASE,
      TRUE,     //fDSOnly
      FALSE,
      NULL
    },
    {
      SAMP_USER_NAME_ADMIN,
      DOMAIN_USER_RID_ADMIN,
      SampUserObjectType,
      FALSE,
      SAMP_GROUP_NAME_ADMINS,
      DOMAIN_GROUP_RID_ADMINS,
      SampGroupObjectType,
      FALSE,
      FALSE,
      NT4_RELEASE,
      TRUE,     //fDSOnly
      FALSE,
      NULL
    },
    {
      SAMP_USER_NAME_GUEST,
      DOMAIN_USER_RID_GUEST,
      SampUserObjectType,
      FALSE,
      SAMP_GROUP_NAME_GUESTS,
      DOMAIN_GROUP_RID_GUESTS,
      SampGroupObjectType,
      FALSE,
      FALSE,
      NT4_RELEASE,
      TRUE,     //fDSOnly
      FALSE,
      NULL
    },
    {
      SAMP_USER_NAME_ADMIN,
      DOMAIN_USER_RID_ADMIN,
      SampUserObjectType,
      FALSE,
      SAMP_GROUP_NAME_SCHEMA_ADMINS,
      DOMAIN_GROUP_RID_SCHEMA_ADMINS,
      SampGroupObjectType,
      FALSE,
      TRUE,
      WIN2K_RELEASE,
      TRUE,     //fDSOnly
      FALSE,
      NULL
    },
    {
      SAMP_USER_NAME_ADMIN,
      DOMAIN_USER_RID_ADMIN,
      SampUserObjectType,
      FALSE,
      SAMP_GROUP_NAME_ENTERPRISE_ADMINS,
      DOMAIN_GROUP_RID_ENTERPRISE_ADMINS,
      SampGroupObjectType,
      FALSE,
      TRUE,
      WIN2K_RELEASE,
      TRUE,     //fDSOnly
      FALSE,
      NULL
    },
    {
      SAMP_USER_NAME_ADMIN,
      DOMAIN_USER_RID_ADMIN,
      SampUserObjectType,
      FALSE,
      SAMP_GROUP_NAME_POLICY_ADMINS,
      DOMAIN_GROUP_RID_POLICY_ADMINS,
      SampGroupObjectType,
      FALSE,
      FALSE,
      WIN2K_RELEASE,
      TRUE,     //fDSOnly
      FALSE,
      NULL
    },
    {
      SAMP_WELL_KNOWN_ALIAS_EVERYONE,
      0,                      // ignored
      SampAliasObjectType,    // ignored
      FALSE,                  // ignored
      SAMP_ALIAS_NAME_PREW2KCOMPACCESS,
      DOMAIN_ALIAS_RID_PREW2KCOMPACCESS,
      SampAliasObjectType,
      TRUE,  // builtin group
      FALSE, // not just enterprise install
      WIN2K_RELEASE, 
      TRUE,  // fDSOnly
      TRUE,  // Well Known Account
      &SampWorldSid
    },
    {
      SAMP_WELL_KNOWN_ALIAS_ANONYMOUS_LOGON,
      0,                      // ignored
      SampAliasObjectType,    // ignored
      FALSE,                  // ignored
      SAMP_ALIAS_NAME_PREW2KCOMPACCESS,
      DOMAIN_ALIAS_RID_PREW2KCOMPACCESS,
      SampAliasObjectType,
      TRUE,  // builtin group
      FALSE, // not just enterprise install
      WS03_RELEASE,
      TRUE,  // fDSOnly
      TRUE,  // Well Known Account
      &SampAnonymousSid
    },
    {
      SAMP_ALIAS_NAME_USERS,
      0,                      // ignored
      SampAliasObjectType,    // ignored
      FALSE,                  // ignored
      SAMP_ALIAS_NAME_PREW2KCOMPACCESS,
      DOMAIN_ALIAS_RID_PREW2KCOMPACCESS,
      SampAliasObjectType,
      TRUE,  // builtin group
      FALSE, // not just enterprise install
      WS03_RELEASE,
      TRUE,  // fDSOnly
      TRUE,  // Well Known Account
      &SampAuthenticatedUsersSid
    },
    {
      SAMP_WELL_KNOWN_ALIAS_NETWORK_SERVICE,
      0,                      // ignored
      SampAliasObjectType,    // ignored
      FALSE,                  // ignored
      SAMP_ALIAS_NAME_LOGGING_USERS,
      DOMAIN_ALIAS_RID_LOGGING_USERS,
      SampAliasObjectType,
      TRUE,  // builtin group
      FALSE, // not just enterprise install
      WS03_RELEASE,
      FALSE, // fDSOnly - this membership will be for both Registry and DS mode
      TRUE,  // Well Known Account
      &SampNetworkServiceSid
    },
    {
      SAMP_WELL_KNOWN_ALIAS_ENTERPRISE_DOMAIN_CONTROLLERS,
      0,                      // ignored
      SampAliasObjectType,    // ignored
      FALSE,                  // ignored
      SAMP_ALIAS_NAME_AUTHORIZATIONACCESS,
      DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS,
      SampAliasObjectType,
      TRUE,  // builtin group
      FALSE, // not just enterprise install
      WS03_RELEASE,
      TRUE,  // fDSOnly
      TRUE,  // Well Known SID
      &SampEnterpriseDomainControllersSid
    },
};




NTSTATUS
SampSetWellKnownAccountProperties(
    SAMPR_HANDLE AccountHandle,
    UNICODE_STRING Comment,
    PUNICODE_STRING Name,
    WCHAR * Password,
    ULONG Index
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    USER_SET_PASSWORD_INFORMATION UserPasswordInfo;
    PUSER_CONTROL_INFORMATION     UserControlInfo = NULL;

    if (SampUserObjectType==DsWellKnownAccounts[Index].ObjectType)
    {
        //
        // Set the appropriate  control fields
        //

        NtStatus = SamrQueryInformationUser2(AccountHandle,
                                             UserControlInformation,
                                             (PSAMPR_USER_INFO_BUFFER*)&UserControlInfo);
        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SamrQueryInformationUser2 failed with 0x%x\n",
                       NtStatus));

            goto Cleanup;
        }


        if ( (DsWellKnownAccounts[Index].Rid == DOMAIN_USER_RID_GUEST)
          || (DsWellKnownAccounts[Index].Rid == DOMAIN_USER_RID_ADMIN)  )
        {
            //
            // Admin and Guest accounts passwords shouldn't expire
            //
            UserControlInfo->UserAccountControl |= USER_DONT_EXPIRE_PASSWORD;
        }

        if ( DsWellKnownAccounts[Index].Rid != DOMAIN_USER_RID_GUEST)
        {
            //
            // Guests don't need passwords
            //
            UserControlInfo->UserAccountControl &= ~USER_PASSWORD_NOT_REQUIRED;
        }


        if (DsWellKnownAccounts[Index].Rid == DOMAIN_USER_RID_ADMIN)
        {
            //
            // Admin account should not be disabled
            //
            UserControlInfo->UserAccountControl &= ~USER_ACCOUNT_DISABLED;
        }

        //
        // Make sure the account is normal
        //
        UserControlInfo->UserAccountControl &= ~USER_ACCOUNT_TYPE_MASK;
        UserControlInfo->UserAccountControl |= USER_NORMAL_ACCOUNT;

        NtStatus = SamrSetInformationUser(AccountHandle,
                                          UserControlInformation,
                                          (PSAMPR_USER_INFO_BUFFER)UserControlInfo);
        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL, "SAMSS: SamrSetInformationUser failed with 0x%x\n",
                       NtStatus));

            goto Cleanup;
        }

        //
        // Set the password
        //

        NtStatus = SampSetPassword(AccountHandle,
                                   Name,
                                   DsWellKnownAccounts[Index].Rid,
                                   Password);

        if(!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampSetPassword failed with 0x%x\n",
                       NtStatus));

            goto Cleanup;
        }

        //
        // Set the Comment String
        //

        NtStatus = SamrSetInformationUser(AccountHandle,
                                          UserAdminCommentInformation,
                                          (PSAMPR_USER_INFO_BUFFER)&Comment);

        if(!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SamrSetInformationUser (admin comment) failed with 0x%x\n",
                       NtStatus));

            // This is not fatal
            NtStatus = STATUS_SUCCESS;
        }
    }
    else if (SampGroupObjectType==DsWellKnownAccounts[Index].ObjectType)
    {
        NtStatus = SamrSetInformationGroup(AccountHandle,
                                          GroupAdminCommentInformation,
                                          (PSAMPR_GROUP_INFO_BUFFER)&Comment);

        if(!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SamrSetInformationUser (admin comment) failed with 0x%x\n",
                       NtStatus));

            // This is not fatal
            NtStatus = STATUS_SUCCESS;
        }
    }
    else if (SampAliasObjectType==DsWellKnownAccounts[Index].ObjectType)
    {
        NtStatus = SamrSetInformationAlias(AccountHandle,
                                          AliasAdminCommentInformation,
                                          (PSAMPR_ALIAS_INFO_BUFFER)&Comment);

        if(!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SamrSetInformationUser (admin comment) failed with 0x%x\n",
                       NtStatus));

            // This is not fatal
            NtStatus = STATUS_SUCCESS;
        }
    }


Cleanup:

    if (UserControlInfo) {
        SamIFree_SAMPR_USER_INFO_BUFFER((PSAMPR_USER_INFO_BUFFER)UserControlInfo,
                                        UserControlInformation);
    }

    return NtStatus;

}

NTSTATUS
SampAddWellKnownAccounts(
    IN SAMPR_HANDLE AccountDomainHandle,
    IN SAMPR_HANDLE BuiltinDomainHandle,
    IN ULONG        Flags
    )
/*++

Routine Description


    This routine creates the set of default NT security principals for a
    domain.  Should an account exist with the same name as the default name
    of a default account, the default account name will be changed to a unique
    value until creation succeeds.  For example, Administrator will become
    Administrator~0.  Again, note that the existing customer name wins.

    The only exception is the KRBTGT account.  This well known account must
    be named exactly KRBTGT for compatibility reasons.  This account should
    have already been renamed by this point in the process (ie in SamIPromote).

Parameters

    AccountDomainHandle, a valid SAM domain handle

    BuiltinDomainHandle, a valid SAM domain handle

Return Values

    STATUS_SUCCESS; a status from a SAM api call

--*/
{
    NTSTATUS                      NtStatus = STATUS_SUCCESS;
    UNICODE_STRING                Name;
    UNICODE_STRING                Comment;
    ULONG                         AccessGranted;
    ULONG                         ConflictingRid;

    WCHAR                         *Password;
    HMODULE                       AccountNamesResource;

    SAMPR_HANDLE                  DomainHandle = 0;

    //
    // Resources to be cleaned up
    //

    SAMPR_HANDLE                  AccountHandle = 0;

    SAMPR_ULONG_ARRAY             Rids;
    SAMPR_ULONG_ARRAY             UseRids;
    ULONG                         i;
    OSVERSIONINFOEXW osvi;
    BOOL fPersonalSKU = FALSE;

    SAMTRACE("CreateBuiltinDomain");





    //
    // Parameter checking
    //
    ASSERT(AccountDomainHandle);
    ASSERT(BuiltinDomainHandle);

    //
    // Determine if we are installing Personal SKU
    //

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
    GetVersionEx((OSVERSIONINFOW*)&osvi);

    fPersonalSKU = ( ( osvi.wProductType == VER_NT_WORKSTATION )
                                    && (osvi.wSuiteMask & VER_SUITE_PERSONAL));


    //
    // Get the message resource we need to get the account names from
    //

    AccountNamesResource = (HMODULE) LoadLibrary( L"SAMSRV.DLL" );
    if (AccountNamesResource == NULL) {

        return(STATUS_RESOURCE_DATA_NOT_FOUND);
    }


    for (i=0;i<ARRAY_COUNT(DsWellKnownAccounts);i++)
    {
        BOOLEAN fSetAttributes = TRUE;


        //
        // Stack clearing
        //
        RtlSecureZeroMemory(&Rids, sizeof(Rids));
        RtlSecureZeroMemory(&UseRids, sizeof(UseRids));


        if (  DsWellKnownAccounts[i].fEnterpriseOnly
           && !FLAG_ON( Flags, SAMP_PROMOTE_ENTERPRISE ) )
        {
            //
            // The account exists only in the root domain,
            // and this is not the root domain creation case, so continue
            //
            continue;
        }


        if  ((( DsWellKnownAccounts[i].fOnDC ) && (SampUseDsData)) ||
                // Create on a DC and the machine is a DC
            ( DsWellKnownAccounts[i].fOnServer && (SampProductType==NtProductLanManNt) &&
                    (!SampUseDsData) && (!SampIsDownlevelDcUpgrade())) ||
                // case of upgrading the safeboot hive when booting to regular DS mode
            ( DsWellKnownAccounts[i].fOnProfessional
                && ((SampProductType==NtProductWinNt) && !fPersonalSKU )) ||
                // Create on a workstation and the machine is a workstation
            ( DsWellKnownAccounts[i].fOnServer && (SampProductType==NtProductServer)) ||
                // Create on a server and the machine is a server
            ( DsWellKnownAccounts[i].fOnPersonal && fPersonalSKU ) )
                // Create on a personal and the machine is a personal flavor
        {
            //
            // Continue the loop and proceed on creating the account
            //
        }
        else
        {
            //
            // Go to the end of the loop and proceed with the next account
            //

            continue;
        }

        AccountHandle = NULL;
        RtlSecureZeroMemory(&Name,sizeof(UNICODE_STRING));
        RtlSecureZeroMemory(&Comment,sizeof(UNICODE_STRING));

        if ( DsWellKnownAccounts[i].fBuiltinAccount )
        {
            DomainHandle = BuiltinDomainHandle;
        }
        else
        {
            DomainHandle = AccountDomainHandle;
        }

        //
        // Build the account name and the comment.  This will also be the initial
        // password. The password requirement is for kerberos.
        //

        NtStatus = SampGetMessageStrings(
                     AccountNamesResource,
                     DsWellKnownAccounts[i].LocalizedName,
                     &Name,
                     DsWellKnownAccounts[i].LocalizedComment,
                     &Comment
                     );
        if (!NT_SUCCESS(NtStatus))
        {
            goto IterationCleanup;
        }


        Password = DsWellKnownAccounts[i].Password;

        //
        // See if an account with the rid already exists
        //

        NtStatus = SampOpenAccount(
                                DsWellKnownAccounts[i].ObjectType,
                                DomainHandle,
                                GENERIC_ALL,
                                DsWellKnownAccounts[i].Rid,
                                FALSE,
                                &AccountHandle
                                );

        if ((DsWellKnownAccounts[i].NotFoundStatus == NtStatus)
         &&  DsWellKnownAccounts[i].Rid == DOMAIN_GROUP_RID_CERT_ADMINS  ) {

            //
            // In the win2k release the Certificate Publishers group was
            // a global group; in .NET and beyond it is a resource group.
            // Thus when upgrading from win2k to .NET, we need to try
            // opening as a group, not an alias.
            //
            ASSERT(DsWellKnownAccounts[i].ObjectType == SampAliasObjectType);
            NtStatus = SampOpenAccount(
                                    SampGroupObjectType,
                                    DomainHandle,
                                    GENERIC_ALL,
                                    DsWellKnownAccounts[i].Rid,
                                    FALSE,
                                    &AccountHandle
                                    );

            if (NtStatus == STATUS_NO_SUCH_GROUP) {
                NtStatus = DsWellKnownAccounts[i].NotFoundStatus;
            }
        }

        if (DsWellKnownAccounts[i].NotFoundStatus == NtStatus)
        {
            ULONG RenameIndex = 0;
            UNICODE_STRING OriginalName;

            RtlCopyMemory( &OriginalName, &Name, sizeof(UNICODE_STRING));

            //
            // The account does not exist. Now check the name
            // is not in use
            //
            NtStatus =  SamrLookupNamesInDomain(AccountDomainHandle,
                                                1,
                                                (RPC_UNICODE_STRING *)&Name,
                                                &Rids,
                                                &UseRids);

            if (STATUS_NONE_MAPPED==NtStatus)
            {

                 NtStatus =  SamrLookupNamesInDomain(BuiltinDomainHandle,
                                                1,
                                                (RPC_UNICODE_STRING *)&Name,
                                                &Rids,
                                                &UseRids);
            }


            while ( NT_SUCCESS( NtStatus )
                && (DsWellKnownAccounts[i].Rid != DOMAIN_USER_RID_KRBTGT) ) {
                // the krbtgt account cannot be renamed

                //
                // The default name exists -- find a unique one
                //

                WCHAR NewAccountName[UNLEN+1];
                ULONG SuffixIndex;
                WCHAR RenameIndexString[11];  // space to hold 32 bit number
                WCHAR Suffix[12];  // ~<32 bit number>
                ULONG Size;
                ULONG SuffixLength;

                if (Rids.Element) {
                    MIDL_user_free(Rids.Element);
                    Rids.Element = NULL;
                }

                if (UseRids.Element) {
                    MIDL_user_free(UseRids.Element);
                    UseRids.Element= NULL;
                }

                // Get the base ready

                RtlSecureZeroMemory( NewAccountName, sizeof(NewAccountName));
                wcsncpy(NewAccountName,
                        OriginalName.Buffer,
                        min(SAMP_MAX_DOWN_LEVEL_NAME_LENGTH, OriginalName.Length/sizeof(WCHAR)));


                // Prepare the unique suffix
                RtlSecureZeroMemory(Suffix, sizeof(Suffix));
                Suffix[0] = L'~';
                _itow(RenameIndex, RenameIndexString, 10);
                wcscat( Suffix, RenameIndexString );

                // Add the suffix to the base
                SuffixIndex = wcslen( NewAccountName );
                SuffixLength = wcslen( Suffix );
                if ( SuffixIndex + SuffixLength > SAMP_MAX_DOWN_LEVEL_NAME_LENGTH ) {
                    SuffixIndex = SAMP_MAX_DOWN_LEVEL_NAME_LENGTH - SuffixLength;
                }
                NewAccountName[SuffixIndex] = L'\0';
                wcscat( NewAccountName, Suffix );

                if ( Name.Buffer != OriginalName.Buffer ) {
                    LocalFree( Name.Buffer );
                }
                Size = (wcslen( NewAccountName ) + 1) * sizeof(WCHAR);
                Name.Buffer = LocalAlloc( 0, Size);
                if ( Name.Buffer ) {
                    wcscpy( Name.Buffer, NewAccountName );
                    RtlInitUnicodeString( &Name, Name.Buffer );

                    NtStatus =  SamrLookupNamesInDomain(AccountDomainHandle,
                                                1,
                                                (RPC_UNICODE_STRING *)&Name,
                                                &Rids,
                                                &UseRids);

                    if (STATUS_NONE_MAPPED==NtStatus)
                    {


                         NtStatus =  SamrLookupNamesInDomain(BuiltinDomainHandle,
                                                        1,
                                                        (RPC_UNICODE_STRING *)&Name,
                                                        &Rids,
                                                        &UseRids);
                    }


                } else {

                    NtStatus = STATUS_NO_MEMORY;
                }

                RenameIndex++;

            }

            if ( OriginalName.Buffer != Name.Buffer ) {
                LocalFree( OriginalName.Buffer );
                OriginalName.Buffer = NULL;
            }

            if (NtStatus == STATUS_NONE_MAPPED) {

                //
                // Good, no account with the rid or the account name
                // exists. Create the account
                //

                NtStatus = SamICreateAccountByRid(DomainHandle,
                                                  DsWellKnownAccounts[i].AccountType,
                                                  DsWellKnownAccounts[i].Rid,
                                                  (RPC_UNICODE_STRING *)&Name,
                                                  GENERIC_ALL,
                                                  &AccountHandle,
                                                  &ConflictingRid);
                if (!NT_SUCCESS(NtStatus)) {

                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: SamICreateAccountByRid failed with 0x%x\n",
                               NtStatus));

                    goto IterationCleanup;

                }

                //
                // If this was an upgrade, the account didn't exist, and the
                // account is not new for NT5, why that is strange.
                // Log an event.
                //
                if (  FLAG_ON( Flags, SAMP_PROMOTE_UPGRADE )
                   && !DsWellKnownAccounts[i].fNewForNt5 ) {

                    PUNICODE_STRING EventString[1];
                    EventString[0] = (PUNICODE_STRING) &Name;

                    if ( SampUserObjectType==DsWellKnownAccounts[i].ObjectType ) {

                        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                          0,     // no category
                                          SAMMSG_WELL_KNOWN_ACCOUNT_RECREATED,
                                          NULL,  // no sid
                                          1,
                                          sizeof(NTSTATUS),
                                          EventString,
                                          (PVOID)(&NtStatus));
                    } else {

                        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                          0,     // no category
                                          SAMMSG_WELL_KNOWN_GROUP_RECREATED,
                                          NULL,  // no sid
                                          1,
                                          sizeof(NTSTATUS),
                                          EventString,
                                          (PVOID)(&NtStatus));
                    }
                }

            }
            else if ( NT_SUCCESS(NtStatus) )
            {

                //
                // Can be here only for the case of the krbtgt account
                //

                ASSERT(  DsWellKnownAccounts[i].Rid==DOMAIN_USER_RID_KRBTGT);

                NtStatus = STATUS_USER_EXISTS;

                goto IterationCleanup;

            }
            else
            {

                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: SamrLookupNamesInDomain failed with 0x%x\n",
                           NtStatus));

                goto Cleanup;

            }


        }
        else if (NT_SUCCESS(NtStatus))
        {

            //
            // Account with the rid already exist.  Since this is a known rid,
            // only system services could have created it.  So, this must be
            // the given well known account
            // ( simply proceed )
            //
            // Don't reset the attributes if the group existed in
            // NT4 or the group already existed on the server configuration
            // or this is a binary upgrade.
            if ( !DsWellKnownAccounts[i].fNewForNt5
            ||   DsWellKnownAccounts[i].fOnServer
            ||   FLAG_ON( Flags, SAMP_PROMOTE_INTERNAL_UPGRADE ) )
            {
                fSetAttributes = FALSE;
            }


        } else
        {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SamrOpenUser failed with 0x%x\n",
                       NtStatus));

            goto Cleanup;
        }

        //
        // We should have an account Handle right Here
        //

        ASSERT(AccountHandle);

        if ( fSetAttributes )
        {
            //
            // 16 + 1 allows for 256 bits of randomness
            //
            WCHAR DummyPassword[SAMP_RANDOM_GENERATED_PASSWORD_LENGTH +1];

            if ( (NULL == Password)
              && (SampUserObjectType==DsWellKnownAccounts[i].ObjectType)   ) {

                //
                // Generate a random password for users if null
                //
                Password = DummyPassword;

                NtStatus = SampGenerateRandomPassword( DummyPassword,
                                                       ARRAY_COUNT(DummyPassword) );
                if (!NT_SUCCESS(NtStatus)) {
                    goto Cleanup;
                }

            }

            NtStatus = SampSetWellKnownAccountProperties(
                            AccountHandle,
                            Comment,
                            &Name,
                            Password,
                            i
                            );
        }

        if (!NT_SUCCESS(NtStatus))
        {
            goto IterationCleanup;
        }

IterationCleanup:

        if ( !NT_SUCCESS( NtStatus ) )
        {
            //
            // Log the error and then reset NtStatus to success
            //
            NTSTATUS IgnoreStatus = STATUS_SUCCESS;
            DWORD    WinError = ERROR_SUCCESS;
            DWORD    WinErrorToLog;
            UNICODE_STRING User, Error;
            PUNICODE_STRING EventStrings[2] = { &User, &Error };
            ULONG           Length;

            RtlSecureZeroMemory( &User, sizeof( UNICODE_STRING ) );
            RtlSecureZeroMemory( &Error, sizeof( UNICODE_STRING ) );

            IgnoreStatus = SampGetMessageStrings( AccountNamesResource,
                                                  DsWellKnownAccounts[i].LocalizedName,
                                                  &User,
                                                  0,
                                                  NULL );

            WinErrorToLog = RtlNtStatusToDosError( NtStatus );
            Length = FormatMessage( (FORMAT_MESSAGE_FROM_SYSTEM |
                                     FORMAT_MESSAGE_ALLOCATE_BUFFER),
                                     NULL, // no source
                                     WinErrorToLog,
                                     0, // let the system decide the language
                                     (LPWSTR)&Error.Buffer,
                                     0, // buffer is to be allocated
                                     NULL // no inserts
                                     );
            if ( Length > 0 ) {
                Error.MaximumLength = (USHORT) (Length + 1)* sizeof(WCHAR);
                Error.Length = (USHORT) Length * sizeof(WCHAR);
                Error.Buffer[Length-2] = L'\0';
            } else {
                WinError = GetLastError();
            }

            if (  (ERROR_SUCCESS == WinError)
                && NT_SUCCESS( IgnoreStatus ) )
            {
                ULONG Msg = SAMMSG_USER_SETUP_ERROR;

                SampWriteEventLog( EVENTLOG_INFORMATION_TYPE,
                                   0,    // no category
                                   Msg,
                                   NULL, // no sid
                                   sizeof(EventStrings)/sizeof(EventStrings[0]), // number of strings
                                   sizeof(DWORD), // size of data
                                   EventStrings,
                                   &WinErrorToLog
                                    );

            }

            if ( User.Buffer )
            {
                LocalFree( User.Buffer );
            }
            if ( Error.Buffer )
            {
                LocalFree( Error.Buffer );
            }

            // handled
            NtStatus = STATUS_SUCCESS;

        }

        if (AccountHandle) {
            SamrCloseHandle(&AccountHandle);
            AccountHandle = NULL;
        }

        if (Rids.Element) {
            MIDL_user_free(Rids.Element);
            Rids.Element = NULL;
        }

        if (UseRids.Element) {
            MIDL_user_free(UseRids.Element);
            UseRids.Element= NULL;
        }

        if ( Name.Buffer ) {
            LocalFree( Name.Buffer );
            Name.Buffer = NULL;
        }

        if ( Comment.Buffer ) {
            LocalFree( Comment.Buffer );
            Comment.Buffer = NULL;
        }

    }

    //
    // That's it; fall through to cleanup
    //

Cleanup:

    if (AccountHandle) {
        SamrCloseHandle(&AccountHandle);
    }

    if (Rids.Element) {
         MIDL_user_free(Rids.Element);
    }

    if (UseRids.Element) {
        MIDL_user_free(UseRids.Element);
    }

    if ( AccountNamesResource ) {
        FreeLibrary( AccountNamesResource );
    }

    ASSERT( NT_SUCCESS( NtStatus ) );

    return NtStatus;
}

NTSTATUS
SampCreateKeyForPostBootPromote(
    IN ULONG PromoteData
    )
/*++

Routine Description

    This routine creates a key used to record the fact that phase two
    of the promotion needs to happed on the next reboot.

Parameters

    PromoteData:  this value is stored in the key; it identifies whether this
                  is a promotion to first DC or a replica DC.

Return Values

    STATUS_SUCCESS; a system service error otherwise

--*/
{
    NTSTATUS          NtStatus, IgnoreStatus;

    OBJECT_ATTRIBUTES SamKey;
    UNICODE_STRING    SamKeyName;
    HANDLE            SamKeyHandle;

    UNICODE_STRING    PromoteKeyName;

    ULONG             DesiredAccess = GENERIC_ALL;

    //
    // Open the parent key
    //
    RtlInitUnicodeString(&SamKeyName, SAMP_REBOOT_INFO_KEY );
    InitializeObjectAttributes(&SamKey,
                               &SamKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&SamKeyHandle,
                         DesiredAccess,
                         &SamKey);

    if (NT_SUCCESS(NtStatus)) {

        //
        // Create the value
        //
        RtlInitUnicodeString(&PromoteKeyName, L"PostPromoteBoot");
        NtStatus = NtSetValueKey(SamKeyHandle,
                                 &PromoteKeyName,
                                 0,               // Title name, optional
                                 REG_DWORD,
                                 &PromoteData,
                                 sizeof(DWORD));

        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtSetValueKey failed with 0x%x\n",
                       NtStatus));
        }

        IgnoreStatus = NtFlushKey(SamKeyHandle);
        if (!NT_SUCCESS(IgnoreStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtFlushKey failed with 0x%x\n",
                       IgnoreStatus));
        }

        IgnoreStatus = NtClose(SamKeyHandle);
        if (!NT_SUCCESS(IgnoreStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtClose failed with 0x%x\n",
                       IgnoreStatus));
        }

    }
    else {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: NtOpenKey failed with 0x%x\n",
                   NtStatus));

    }


    return NtStatus;
}


NTSTATUS
SampRetrieveKeyForPostBootPromote(
    OUT PULONG PromoteData
    )
/*++

Routine Description:

    This routine


Parameters

    None.

Return Values


--*/
{

    NTSTATUS          NtStatus, IgnoreStatus;

    OBJECT_ATTRIBUTES SamKey;
    UNICODE_STRING    SamKeyName;
    HANDLE            SamKeyHandle;

    UNICODE_STRING    PromoteKeyName;

    ULONG             DesiredAccess = GENERIC_ALL;

    PKEY_VALUE_PARTIAL_INFORMATION   KeyPartialInfo;
    ULONG                            KeyPartialInfoSize = 0;

    ASSERT(PromoteData);

    //
    // Open the parent key
    //
    RtlInitUnicodeString(&SamKeyName, SAMP_REBOOT_INFO_KEY );
    InitializeObjectAttributes(&SamKey,
                               &SamKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&SamKeyHandle,
                         DesiredAccess,
                         &SamKey);

    if (NT_SUCCESS(NtStatus)) {

        //
        // Query the value
        //

        RtlInitUnicodeString(&PromoteKeyName, L"PostPromoteBoot");
        NtStatus = NtQueryValueKey(SamKeyHandle,
                                   &PromoteKeyName,
                                   KeyValuePartialInformation,
                                   NULL,
                                   0,
                                   &KeyPartialInfoSize);

        if (STATUS_BUFFER_TOO_SMALL == NtStatus) {
            //
            //  Allocate some space and then read the buffer
            //
            KeyPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)
                             MIDL_user_allocate(KeyPartialInfoSize);

            if (KeyPartialInfo) {

                NtStatus = NtQueryValueKey(SamKeyHandle,
                                           &PromoteKeyName,
                                           KeyValuePartialInformation,
                                           KeyPartialInfo,
                                           KeyPartialInfoSize,
                                           &KeyPartialInfoSize);

                if (NT_SUCCESS(NtStatus)) {
                    //
                    // Analysis the value's data
                    //
                    if (KeyPartialInfo->DataLength == sizeof(DWORD)) {
                        *PromoteData = *(DWORD*)(KeyPartialInfo->Data);
                    } else {
                        SampDiagPrint( PROMOTE,
              ("SAMSS: Post boot promote key found with bogus value length\n"));

                        NtStatus = STATUS_UNSUCCESSFUL;
                    }

                } else {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: NtQueryValueKey failed with 0x%x\n",
                               NtStatus));
                }

                MIDL_user_free(KeyPartialInfo);

            } else {

                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: Memory allocation failed\n"));

                NtStatus = STATUS_NO_MEMORY;

            }

        }  else if (STATUS_OBJECT_NAME_NOT_FOUND == NtStatus ||
                    STATUS_SUCCESS               == NtStatus ) {
            //
            // This is ok, too
            //
            ;

        } else {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtQueryValueKey failed with 0x%x\n",
                       NtStatus));
        }


        IgnoreStatus = NtClose(SamKeyHandle);
        if (!NT_SUCCESS(IgnoreStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtClose failed with 0x%x\n",
                       IgnoreStatus));
        }

    }
    else {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: NtOpenKey failed with 0x%x\n",
                   NtStatus));

    }

    return NtStatus;

}

NTSTATUS
SampDeleteKeyForPostBootPromote(
    VOID
    )
/*++

Routine Description


Parameters

    None.

Return Values


--*/
{
    NTSTATUS          NtStatus, NtStatus2, IgnoreStatus;

    OBJECT_ATTRIBUTES SamKey;
    UNICODE_STRING    SamKeyName;
    HANDLE            SamKeyHandle;

    UNICODE_STRING    KeyName;

    ULONG             DesiredAccess = GENERIC_ALL;

    //
    // Open the parent key
    //
    RtlInitUnicodeString(&SamKeyName, SAMP_REBOOT_INFO_KEY );
    InitializeObjectAttributes(&SamKey,
                               &SamKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&SamKeyHandle,
                         DesiredAccess,
                         &SamKey);

    if (NT_SUCCESS(NtStatus)) {

        //
        // Delete the value
        //
        RtlInitUnicodeString(&KeyName, L"PostPromoteBoot");
        NtStatus = NtDeleteValueKey(SamKeyHandle,
                                    &KeyName);

        if (!NT_SUCCESS(NtStatus)) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtDeleteValueKey failed with 0x%x\n",
                       NtStatus));

        }

        RtlInitUnicodeString(&KeyName, SAMP_ADMIN_INFO_NAME);
        NtStatus2 = NtDeleteValueKey(SamKeyHandle,
                                    &KeyName);
        if (!NT_SUCCESS(NtStatus2)
         && NtStatus2 != STATUS_OBJECT_NAME_NOT_FOUND) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtDeleteValueKey failed with 0x%x\n",
                       NtStatus2));

            if (NT_SUCCESS(NtStatus)) {
                NtStatus = NtStatus2;
            }
        }

        //
        // Make sure we don't run this code again
        //
        IgnoreStatus = NtFlushKey(SamKeyHandle);
        if (!NT_SUCCESS(IgnoreStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtFlushKey failed with 0x%x\n",
                       IgnoreStatus));
        }

        IgnoreStatus = NtClose(SamKeyHandle);
        if (!NT_SUCCESS(IgnoreStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtClose failed with 0x%x\n",
                       IgnoreStatus));
        }

    }
    else {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: NtOpenKey failed with 0x%x\n",
                   NtStatus));

    }

    return NtStatus;

}


NTSTATUS
SampSetPassword(
    IN SAMPR_HANDLE    UserHandle,
    IN PUNICODE_STRING AccountName,
    IN ULONG           AccountRid, OPTIONAL
    IN WCHAR          *Password
    )
/*++

Routine Description:

    This routines sets the clear text password, Password, on the user referred
    to by UserHandle.

Parameters:

    UserHandle : a valid handle to a user account

    AccountName : the account name of UserHandle; if specified, notification packages will be
                  called

    Rid:       : must be specified if AccountName is specified

    Password   : the password to set

Return Values:

    STATUS_SUCCESS; a system service error otherwise

--*/
{
    NTSTATUS NtStatus;
    UNICODE_STRING              ClearNtPassword;

    ASSERT(UserHandle);
    ASSERT(Password);
    ASSERT(AccountName);


    RtlInitUnicodeString(&ClearNtPassword, Password);

    NtStatus = SamIChangePasswordForeignUser(
                    AccountName,
                    &ClearNtPassword,
                    NULL,// ClientToken,
                    0
                    );

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamIChangePasswordForeignUser failed with 0x%x\n",
                   NtStatus));

        return NtStatus;
    }

    return NtStatus;
}

NTSTATUS
SampRegistryDelnode(
    IN WCHAR*  KeyPath
    )
/*++

Routine Description

    This routine recursively deletes the registry key starting at
    and including KeyPath.


Parameters

    KeyPath, null-terminating string

Return Values

    STATUS_SUCCESS or STATUS_NO_MEMORY; system service error otherwise

--*/
{

    NTSTATUS          NtStatus, IgnoreStatus;

    HANDLE            KeyHandle = 0;
    OBJECT_ATTRIBUTES KeyObject;
    UNICODE_STRING    KeyUnicodeName;

    #define EXPECTED_NAME_SIZE  32

    BYTE    Buffer1[sizeof(KEY_FULL_INFORMATION) + EXPECTED_NAME_SIZE];
    PKEY_FULL_INFORMATION FullKeyInfo = (PKEY_FULL_INFORMATION)&Buffer1[0];
    ULONG   FullKeyInfoSize = sizeof(Buffer1);
    BOOLEAN FullKeyInfoAllocated = FALSE;

    PKEY_BASIC_INFORMATION BasicKeyInfo = NULL;
    BOOLEAN                BasicKeyInfoAllocated = FALSE;

    WCHAR                  *SubKeyName = NULL;
    ULONG                  SubKeyNameSize = 0;

    WCHAR                  **SubKeyNameArray = NULL;
    ULONG                  SubKeyNameArrayLength = 0;

    ULONG                  Index;

    if (!KeyPath) {
        return ERROR_INVALID_PARAMETER;
    }

    RtlSecureZeroMemory(&Buffer1, sizeof(Buffer1));

    //
    // Open the root key
    //
    RtlInitUnicodeString(&KeyUnicodeName, KeyPath);
    InitializeObjectAttributes(&KeyObject,
                               &KeyUnicodeName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&KeyHandle,
                         KEY_ALL_ACCESS,
                         &KeyObject);

    if (!NT_SUCCESS(NtStatus)) {

        return NtStatus;

    }

    //
    // Get the number of subkeys
    //
    NtStatus = NtQueryKey(KeyHandle,
                         KeyFullInformation,
                         FullKeyInfo,
                         FullKeyInfoSize,
                         &FullKeyInfoSize);

    if (STATUS_BUFFER_OVERFLOW == NtStatus ||
        STATUS_BUFFER_TOO_SMALL == NtStatus) {

       FullKeyInfo = MIDL_user_allocate( FullKeyInfoSize );
        if (!FullKeyInfo) {
            NtStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        FullKeyInfoAllocated = TRUE;

        NtStatus = NtQueryKey(KeyHandle,
                              KeyFullInformation,
                              FullKeyInfo,
                              FullKeyInfoSize,
                              &FullKeyInfoSize);

    }

    if (!NT_SUCCESS(NtStatus)) {

        goto Cleanup;

    }

    //
    // Make an array for the sub key names - this has to be recorded before
    // any are deleted.
    //
    SubKeyNameArrayLength = FullKeyInfo->SubKeys;
    SubKeyNameArray = MIDL_user_allocate( SubKeyNameArrayLength * sizeof(WCHAR*));
    if (!SubKeyNameArray) {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    RtlSecureZeroMemory(SubKeyNameArray,  SubKeyNameArrayLength*sizeof(WCHAR*));

    //
    // Fill the names in
    //
    for (Index = 0;
            Index < SubKeyNameArrayLength && NT_SUCCESS(NtStatus);
                Index++) {


        BYTE    Buffer2[sizeof(KEY_BASIC_INFORMATION) + EXPECTED_NAME_SIZE];
        ULONG   BasicKeyInfoSize = sizeof(Buffer2);


        BasicKeyInfo = (PKEY_BASIC_INFORMATION) &Buffer2[0];
        BasicKeyInfoAllocated = FALSE;

        RtlSecureZeroMemory(&Buffer2, sizeof(Buffer2));

        NtStatus = NtEnumerateKey(KeyHandle,
                                  Index,
                                  KeyBasicInformation,
                                  BasicKeyInfo,
                                  BasicKeyInfoSize,
                                  &BasicKeyInfoSize);

        if (STATUS_BUFFER_OVERFLOW == NtStatus ||
            STATUS_BUFFER_TOO_SMALL == NtStatus) {

            BasicKeyInfo = MIDL_user_allocate( BasicKeyInfoSize );
            if (!BasicKeyInfo) {
                NtStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }
            BasicKeyInfoAllocated = TRUE;


            NtStatus = NtEnumerateKey(KeyHandle,
                                      Index,
                                      KeyBasicInformation,
                                      BasicKeyInfo,
                                      BasicKeyInfoSize,
                                      &BasicKeyInfoSize);

        }

        if (NT_SUCCESS(NtStatus))  {

            //
            // Construct the key name
            //
            SubKeyNameSize  = BasicKeyInfo->NameLength
                            + (wcslen(KeyPath)*sizeof(WCHAR))
                            + sizeof(L"\\\0");

            SubKeyName = MIDL_user_allocate(SubKeyNameSize);
            if (!SubKeyName) {
                NtStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }
            RtlSecureZeroMemory(SubKeyName, SubKeyNameSize);

            wcscpy(SubKeyName, KeyPath);
            wcscat(SubKeyName, L"\\");
            wcsncat(SubKeyName, BasicKeyInfo->Name, BasicKeyInfo->NameLength/sizeof(WCHAR));

            SubKeyNameArray[Index] = SubKeyName;

        }

        if (BasicKeyInfoAllocated && BasicKeyInfo) {
            MIDL_user_free(BasicKeyInfo);
        }
        BasicKeyInfo = NULL;

    }

    //
    // Now that we have a record of all the subkeys we can delete them!
    //
    if (NT_SUCCESS(NtStatus)) {

        for (Index = 0; Index < SubKeyNameArrayLength; Index++) {

            NtStatus = SampRegistryDelnode(SubKeyNameArray[Index]);

            if (!NT_SUCCESS(NtStatus)) {

                break;

            }
        }
    }


    //
    // Delete the key!
    //
    if (NT_SUCCESS(NtStatus)) {

        NtStatus = NtDeleteKey(KeyHandle);

    }


Cleanup:

    if (SubKeyNameArray) {
        for (Index = 0; Index < SubKeyNameArrayLength; Index++) {
            if (SubKeyNameArray[Index]) {
                MIDL_user_free(SubKeyNameArray[Index]);
            }
        }
        MIDL_user_free(SubKeyNameArray);
    }

    if (BasicKeyInfoAllocated && BasicKeyInfo) {
        MIDL_user_free(BasicKeyInfo);
    }

    if (FullKeyInfoAllocated && FullKeyInfo) {
        MIDL_user_free(FullKeyInfo);
    }

    IgnoreStatus = NtClose(KeyHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    return NtStatus;

}


NTSTATUS
SampRenameKrbtgtAccount(
    VOID
    )
/*++

Routine Description:

    This routine will check the local security database for any user, group,
    or alias named "krbtgt".  If one exists, the account will be renamed
    krbtgt~x, where x will start at 1 and be incremented until the rename
    succeeds.  Since this can only occur during gui mode setup, the user
    is notified via the setup api SetupLogError().

Parameters:

    None.

Return Values:

    STATUS_SUCCESS if no krbtgt was detected or if it was detected and was
    successfully renamed

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus;
    DWORD    WinError;

    SAMPR_HANDLE ServerHandle = 0;
    SAMPR_HANDLE DomainHandle = 0;

    SAMPR_HANDLE KrbtgtAccountHandle = 0;
    SID_NAME_USE KrbtgtAccountType = SidTypeUser;

    PPOLICY_ACCOUNT_DOMAIN_INFO   DomainInfo = NULL;
    USER_ACCOUNT_NAME_INFORMATION UserInfo;
    GROUP_NAME_INFORMATION        GroupInfo;
    ALIAS_NAME_INFORMATION        AliasInfo;

    SAMPR_ULONG_ARRAY         Rids;
    SAMPR_ULONG_ARRAY         UseRid;
    BOOL                      AccountRenamed=FALSE;
    BOOL                      AccountShouldBeRenamed=FALSE;
    BOOL                      Status;

    #define        NEW_ACCOUNT_NAME_LENGTH  (7 + 1 + 10)
                                             // krbtgt plus a NULL
                                             // ~
                                             // a 32 bit number as a string

    WCHAR           NewAccountName[NEW_ACCOUNT_NAME_LENGTH];
    UNICODE_STRING  AccountName;

    ULONG          RenameIndex;
    WCHAR          RenameIndexString[10];

    WCHAR          *WarningString = NULL;

    RtlSecureZeroMemory(&UserInfo, sizeof(UserInfo));
    RtlSecureZeroMemory(&GroupInfo, sizeof(GroupInfo));
    RtlSecureZeroMemory(&AliasInfo, sizeof(AliasInfo));
    RtlSecureZeroMemory(&Rids, sizeof(Rids));
    RtlSecureZeroMemory(&UseRid, sizeof(UseRid));

    //
    // Open the server
    //
    NtStatus = SamIConnect(NULL,           // server name, this is ignored
                           &ServerHandle,
                           GENERIC_ALL,    // all access
                           TRUE);          // trusted client

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamIConnect failed with 0x%x\n",
                   NtStatus));

        return NtStatus;
    }

    //
    // Get the current domain's sid
    //
    NtStatus = SampGetAccountDomainInfo(&DomainInfo);
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampGetAccountDomainInfo failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }
    ASSERT(DomainInfo);
    ASSERT(DomainInfo->DomainSid);

    //
    // Open the current domain
    //
    NtStatus = SamrOpenDomain(ServerHandle,
                              GENERIC_ALL,
                              DomainInfo->DomainSid,
                              &DomainHandle);
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamrOpenDomain failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }


    //
    // Try to open the existing krbtgt account
    //
    RtlInitUnicodeString(&AccountName, DOMAIN_KRBTGT_ACCOUNT_NAME_W);
    NtStatus =  SamrLookupNamesInDomain(DomainHandle,
                                        1,
                                        (RPC_UNICODE_STRING *)&AccountName,
                                        &Rids,
                                        &UseRid);

    if (NtStatus == STATUS_SUCCESS) {

        KrbtgtAccountType = UseRid.Element[0];


        if ((DOMAIN_USER_RID_KRBTGT == Rids.Element[0])
                && (SidTypeUser== KrbtgtAccountType))
        {

            //
            // If the account is a user account with the right rid, then
            // leave it as is
            //

            NtStatus = STATUS_SUCCESS;
            AccountShouldBeRenamed = FALSE;
        }
        else
        {
            //
            // Account exists and does not satisfy the above criterion.
            // Rename it.
            //

            AccountShouldBeRenamed = TRUE;


            switch (KrbtgtAccountType) {

                case SidTypeUser:

                    NtStatus = SamrOpenUser(DomainHandle,
                                            GENERIC_ALL,
                                            Rids.Element[0],
                                            &KrbtgtAccountHandle);

                    break;

                case SidTypeGroup:

                    NtStatus = SamrOpenGroup(DomainHandle,
                                             GENERIC_ALL,
                                             Rids.Element[0],
                                             &KrbtgtAccountHandle);
                    break;

                case SidTypeAlias:

                    NtStatus = SamrOpenAlias(DomainHandle,
                                             GENERIC_ALL,
                                             Rids.Element[0],
                                             &KrbtgtAccountHandle);

                    break;

                default:
                    ASSERT(FALSE);
                    NtStatus = STATUS_UNSUCCESSFUL;

            }
        }

    } else {

        //
        // Account does not exist
        //
        ASSERT(NtStatus == STATUS_NONE_MAPPED);
        if (NtStatus != STATUS_NONE_MAPPED) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Unexpected error from SamrLookupNamesInDomain\n"));
        }
        NtStatus = STATUS_SUCCESS;
        AccountShouldBeRenamed = FALSE;

    }

    RenameIndex = 0;
    AccountRenamed = FALSE;
    while (NT_SUCCESS(NtStatus) && AccountShouldBeRenamed && !AccountRenamed) {

        //
        // Try the next name candidate
        //
        RenameIndex++;
        _itow(RenameIndex, RenameIndexString, 10);

        RtlSecureZeroMemory(NewAccountName, sizeof(NewAccountName));
        wcscpy(NewAccountName, DOMAIN_KRBTGT_ACCOUNT_NAME_W);
        wcscat(NewAccountName, L"~");
        wcscat(NewAccountName, RenameIndexString);

        switch (KrbtgtAccountType) {

            case SidTypeUser:

                RtlInitUnicodeString(&UserInfo.UserName, NewAccountName);

                NtStatus = SamrSetInformationUser(KrbtgtAccountHandle,
                                                  UserAccountNameInformation,
                                                  (PSAMPR_USER_INFO_BUFFER)&UserInfo);

                if (STATUS_USER_EXISTS == NtStatus  ||
                    STATUS_GROUP_EXISTS == NtStatus ||
                    STATUS_ALIAS_EXISTS == NtStatus) {
                    //
                    // Try again
                    //
                    NtStatus = STATUS_SUCCESS;
                } else if (NT_SUCCESS(NtStatus)) {
                    AccountRenamed = TRUE;
                }

                break;

            case SidTypeGroup:

                RtlInitUnicodeString(&GroupInfo.Name, NewAccountName);

                NtStatus = SamrSetInformationGroup(KrbtgtAccountHandle,
                                                  GroupNameInformation,
                                                  (PSAMPR_GROUP_INFO_BUFFER)&GroupInfo);


                if (STATUS_USER_EXISTS == NtStatus  ||
                    STATUS_GROUP_EXISTS == NtStatus ||
                    STATUS_ALIAS_EXISTS == NtStatus) {
                    //
                    // Try again
                    //
                    NtStatus = STATUS_SUCCESS;
                } else if (NT_SUCCESS(NtStatus)) {
                    AccountRenamed = TRUE;
                }

                break;

            case SidTypeAlias:

                RtlInitUnicodeString(&AliasInfo.Name, NewAccountName);
                NtStatus = SamrSetInformationAlias(KrbtgtAccountHandle,
                                                   AliasNameInformation,
                                                   (PSAMPR_ALIAS_INFO_BUFFER)&AliasInfo);


                if (STATUS_USER_EXISTS == NtStatus  ||
                    STATUS_GROUP_EXISTS == NtStatus ||
                    STATUS_ALIAS_EXISTS == NtStatus) {
                    //
                    // Try again
                    //
                    NtStatus = STATUS_SUCCESS;
                } else if (NT_SUCCESS(NtStatus)) {
                    AccountRenamed = TRUE;
                }

                break;

            default:
                ASSERT(FALSE);
                NtStatus = STATUS_UNSUCCESSFUL;

        }
    }


    if (AccountRenamed) {
        //
        // Write a message out to the setup log indicating that the
        // account was renamed
        //
        WarningString = SampGetKrbtgtRenameWarning(NewAccountName);
        if (WarningString) {
            if (SetupOpenLog(FALSE)) { // don't erase
                Status = SetupLogError(WarningString, LogSevWarning);
                ASSERT(Status);
                SetupCloseLog();
            }
            LocalFree(WarningString);
        }
    }

Cleanup:

    if (ServerHandle) {
        SamrCloseHandle(&ServerHandle);
    }

    if (DomainHandle) {
        SamrCloseHandle(&DomainHandle);
    }

    if (KrbtgtAccountHandle) {
        SamrCloseHandle(&KrbtgtAccountHandle);
    }

    if (DomainInfo) {
        LsaIFree_LSAPR_POLICY_INFORMATION (PolicyAccountDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION)DomainInfo);
    }

    if (Rids.Element) {
         MIDL_user_free(Rids.Element);
    }

    if (UseRid.Element) {
        MIDL_user_free(UseRid.Element);
    }

    return NtStatus;
}

WCHAR*
SampGetKrbtgtRenameWarning(
    WCHAR* NewName
    )
/*++

Routine Description:

    This routine queries the resource table in samsrv.dll to get the string
    to show the user if an existing krbtgt account existes.  If an error
    occurs trying to get the message, a default english string is used.

Parameters:

    NewName:  null terminated string used as an insert in the message

Return Values:

    The message string allocated from LocalAlloc; NULL if memory allocation
    failed.

--*/
{
    WCHAR   *InsertArray[2];
    HMODULE ResourceDll;
    WCHAR   *WarningString = NULL;
    ULONG   Length, Size;
    BOOL    Status;

    InsertArray[0] = NewName;
    InsertArray[1] = NULL; // this is the sentinel

    ResourceDll = (HMODULE) LoadLibrary( L"SAMSRV.DLL" );

    if (ResourceDll) {

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        ResourceDll,
                                        SAMMSG_KRBTGT_RENAMED,
                                        0,       // Use caller's language
                                        (LPWSTR)&WarningString,
                                        0,       // routine should allocate
                                        (va_list*)&(InsertArray[0])
                                        );
        if (WarningString) {
            // Messages from a message file have a cr and lf appended
            // to the end
            WarningString[Length-2] = L'\0';
            Length -= 2;
        }

        Status = FreeLibrary(ResourceDll);
        ASSERT(Status);

    }

    if (!WarningString) {

        ASSERT(!"SAMSS: Resource allocation failed - this can be safely ignored");

        Size = (wcslen(SampDefaultKrbtgtWarningString)+
                wcslen(NewName)
                +1)*sizeof(WCHAR);
        WarningString = (WCHAR*)LocalAlloc(0, Size);
        if (WarningString) {

            RtlSecureZeroMemory(WarningString, Size);
            swprintf(WarningString, SampDefaultKrbtgtWarningString, NewName);
        }

    }

    return WarningString;

}


WCHAR*
SampGetKrbtgtCommentString(
    VOID
    )
/*++

Routine Description:

    This routine queries the resource table in samsrv.dll to get the string
    for the krbtgt account admin comment.  If an error occurs trying to get the
    message, a default english string is used.

Parameters:

    None.

Return Values:

    The message string allocated from LocalAlloc; NULL if memory allocation
    failed.

--*/
{
    HMODULE ResourceDll;
    WCHAR   *CommentString=NULL;
    ULONG   Length, Size;
    BOOL    Status;

    ResourceDll = (HMODULE) LoadLibrary( L"SAMSRV.DLL" );

    if (ResourceDll) {

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        ResourceDll,
                                        SAMP_USER_COMMENT_KRBTGT,
                                        0,       // Use caller's language
                                        (LPWSTR)&CommentString,
                                        0,       // routine should allocate
                                        NULL
                                        );
        if (CommentString) {
            // Messages from a message file have a cr and lf appended
            // to the end
            CommentString[Length-2] = L'\0';
            Length -= 2;
        }

        Status = FreeLibrary(ResourceDll);
        ASSERT(Status);

    }

    if (!CommentString) {

        ASSERT(!"SAMSS: Resource allocation failed - this can be safely ignored");

        Size = (wcslen(SampDefaultKrbtgtCommentString)+1)*sizeof(WCHAR);
        CommentString = (WCHAR*)LocalAlloc(0, Size);
        if (CommentString) {
            wcscpy(CommentString, SampDefaultKrbtgtCommentString);
        }
    }

    return CommentString;

}

NTSTATUS
SampSetAdminPassword(
    IN     SAMPR_HANDLE DomainHandle
    )
/*++

Routine Description:

    This routine is called on the reboot of a promoted dc.  It retrieves
    the admin password information from the registry and sets it in the
    ds.

Parameters:

    DomainHandle, a valid SAM domain handle

Return Values:

    A fatal SAM error - STATUS_SUCCESS is expected.

--*/
{

    NTSTATUS                    NtStatus, IgnoreStatus;
    USER_INTERNAL1_INFORMATION  Internal1Info;
    SAMPR_HANDLE                UserHandle = 0;

    ASSERT(DomainHandle);

    NtStatus = SamrOpenUser(DomainHandle,
                            GENERIC_ALL,
                            DOMAIN_USER_RID_ADMIN,
                            &UserHandle);

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampGetAdminPasswordFromRegistry(&Internal1Info);

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SamrSetInformationUser(UserHandle,
                                              UserInternal1Information,
                                              (PSAMPR_USER_INFO_BUFFER)&Internal1Info);

            if (!NT_SUCCESS(NtStatus)) {

                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: SamrSetInformationUser failed with 0x%x\n",
                           NtStatus));

            }
            else
            {

                //
                // This is a success, so we can remove it
                //
                NtStatus = SampRemoveAdminPasswordFromRegistry();
                if ( !NT_SUCCESS(NtStatus) ) {

                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: SampRemoveAdminPasswordFromRegistry failed with 0x%x\n",
                               NtStatus));

                }

            }

        } else {

            if (NtStatus != STATUS_OBJECT_NAME_NOT_FOUND) {
                //
                // This is worth noting
                //
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: SampGetAdminPasswordFromRegistry failed with 0x%x\n",
                           NtStatus));
            }

            //
            // Ok, nothing to set
            //
            NtStatus = STATUS_SUCCESS;
        }

        SamrCloseHandle(&UserHandle);

    } else {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SamrOpenUser failed with 0x%x\n",
                   NtStatus));

    }

    RtlSecureZeroMemory(&Internal1Info, sizeof(Internal1Info));

    return NtStatus;

}

NTSTATUS
SampGetCurrentAdminPassword(
    USER_INTERNAL1_INFORMATION *Internal1InfoOut
    )
/*++

Routine Description:

    This routine retrieves the account admin's password in the form
    of a USER_INNTERNAL1_INFORMATION structure.

Parameters:

    Internal1InfoOut, a caller allocated piece of memory for the password
                      information

Return Values:

    STATUS_SUCCESS, or a resource error

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PPOLICY_ACCOUNT_DOMAIN_INFO  DomainInfo = NULL;
    USER_INTERNAL1_INFORMATION *pInternal1Info = NULL;
    SAMPR_HANDLE                 ServerHandle = NULL;
    SAMPR_HANDLE                 DomainHandle = NULL;
    SAMPR_HANDLE                 UserHandle = NULL;


    //
    // Open the server
    //
    NtStatus = SamIConnect(NULL,
                           &ServerHandle,
                           GENERIC_ALL,
                           TRUE);
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Get the account domain's sid
    //
    NtStatus = SampGetAccountDomainInfo(&DomainInfo);
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Open the account domain
    //
    NtStatus = SamrOpenDomain(ServerHandle,
                              GENERIC_ALL,
                              DomainInfo->DomainSid,
                              &DomainHandle);
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Open the administrator account
    //
    NtStatus = SamrOpenUser(DomainHandle,
                            GENERIC_ALL,
                            DOMAIN_USER_RID_ADMIN,
                            &UserHandle);
    if (!NT_SUCCESS(NtStatus)) {
        //
        // N.B This error handling assumes that the Administrator account
        // exists.  This is a valid assumption for non-tampered products.
        //
        goto Cleanup;
    }

    //
    // Get the password
    //
    NtStatus = SamrQueryInformationUser2(UserHandle,
                                         UserInternal1Information,
                                         (PSAMPR_USER_INFO_BUFFER*)&pInternal1Info);

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Copy the information to the out parameter
    //
    RtlCopyMemory(Internal1InfoOut, pInternal1Info, sizeof(*Internal1InfoOut));
    RtlSecureZeroMemory(pInternal1Info, sizeof(*pInternal1Info));


Cleanup:

    if (pInternal1Info) {
       SamIFree_SAMPR_USER_INFO_BUFFER((PSAMPR_USER_INFO_BUFFER)pInternal1Info,
                                       UserInternal1Information);
    }
    if (UserHandle) {
        SamrCloseHandle(&UserHandle);
    }
    if (DomainHandle) {
        SamrCloseHandle(&DomainHandle);
    }
    if (DomainInfo) {
        LsaIFree_LSAPR_POLICY_INFORMATION (PolicyAccountDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION)DomainInfo);
    }
    if (ServerHandle) {
        SamrCloseHandle(&ServerHandle);
    }

    return NtStatus;
}

NTSTATUS
SampSetAdminPasswordInRegistry(
    IN BOOLEAN         fUseCurrentAdmin,
    IN PUNICODE_STRING ClearTextPassword
    )
/*++

Routine Description:

    This routine owf's the ClearTextPassword and then store the whole
    set pasword structure in the registry to picked up next reboot.

Parameters:

    fUseCurrentAdmin, use the current admin's password

    ClearTextPassword, the password to encrypt and store

Return Values:

    A fatal system service error - STATUS_SUCCESS expected.

--*/
{

    NTSTATUS NtStatus, IgnoreStatus;
    USER_INTERNAL1_INFORMATION  Internal1Info;

    OBJECT_ATTRIBUTES SamKey;
    UNICODE_STRING    SamKeyName;
    HANDLE            SamKeyHandle;

    UNICODE_STRING    KeyName;

    ULONG             DesiredAccess = GENERIC_ALL;

    ASSERT(ClearTextPassword);

    RtlSecureZeroMemory(&Internal1Info, sizeof(USER_INTERNAL1_INFORMATION));

    if (fUseCurrentAdmin) {

        NtStatus = SampGetCurrentAdminPassword(&Internal1Info);

    } else {

        Internal1Info.PasswordExpired = FALSE;
        Internal1Info.NtPasswordPresent = TRUE;

        NtStatus = SampCalculateLmAndNtOwfPasswords(ClearTextPassword,
                                                    &Internal1Info.LmPasswordPresent,
                                                    &Internal1Info.LmOwfPassword,
                                                    &Internal1Info.NtOwfPassword);

    }

    if (NT_SUCCESS(NtStatus)) {

        //
        // Write it out to the registry
        //

        RtlInitUnicodeString(&SamKeyName, SAMP_REBOOT_INFO_KEY );
        InitializeObjectAttributes(&SamKey,
                                   &SamKeyName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        NtStatus = NtOpenKey(&SamKeyHandle,
                             DesiredAccess,
                             &SamKey);

        if (NT_SUCCESS(NtStatus)) {

            //
            // Create the value
            //

            RtlInitUnicodeString(&KeyName, SAMP_ADMIN_INFO_NAME);
            NtStatus = NtSetValueKey(SamKeyHandle,
                                     &KeyName,
                                     0,               // Title name, optional
                                     REG_BINARY,
                                     &Internal1Info,
                                     sizeof(USER_INTERNAL1_INFORMATION));

            if (NT_SUCCESS(NtStatus)) {

                IgnoreStatus = NtFlushKey(SamKeyHandle);
                if (!NT_SUCCESS(IgnoreStatus)) {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: NtFlushKey failed with 0x%x\n",
                               IgnoreStatus));
                }

            } else {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: NtSetValueKey failed with 0x%x\n",
                           NtStatus));
            }

            IgnoreStatus = NtClose(SamKeyHandle);
            if (!NT_SUCCESS(IgnoreStatus)) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: NtClose failed with 0x%x\n",
                           IgnoreStatus));
            }

        }
        else {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtOpenKey failed with 0x%x\n",
                       NtStatus));

        }

    } else {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampCalculateLmAndNtOwfPasswords failed with 0x%x\n",
                   NtStatus));
    }

    RtlSecureZeroMemory(&Internal1Info, sizeof(Internal1Info));

    return NtStatus;

}

NTSTATUS
SampGetAdminPasswordFromRegistry(
    OUT USER_INTERNAL1_INFORMATION *InternalInfo1 OPTIONAL
    )
/*++

Routine Description:

    This routine reads the set password structure stored in the registry
    from a promotion attempt.


Parameters:

    InternalInfo1, a pre-allocated structure into which the registry will be
                   copied in.

Return Values:

    A fatal system service error; STATUS_SUCCESS expected.
    STATUS_UNSUCCESSFUL, if the data is not the expected size.

--*/
{

    NTSTATUS          NtStatus, IgnoreStatus;

    OBJECT_ATTRIBUTES SamKey;
    UNICODE_STRING    SamKeyName;
    HANDLE            SamKeyHandle;

    UNICODE_STRING    KeyName;

    ULONG             DesiredAccess = GENERIC_ALL;

    PKEY_VALUE_PARTIAL_INFORMATION   KeyPartialInfo;
    ULONG                            KeyPartialInfoSize = 0;

    //
    // Open the parent key
    //
    RtlInitUnicodeString(&SamKeyName, SAMP_REBOOT_INFO_KEY );
    InitializeObjectAttributes(&SamKey,
                               &SamKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&SamKeyHandle,
                         DesiredAccess,
                         &SamKey);

    if (NT_SUCCESS(NtStatus)) {

        //
        // Query the value
        //
        KeyPartialInfo = NULL;
        KeyPartialInfoSize = 0;
        RtlInitUnicodeString(&KeyName, SAMP_ADMIN_INFO_NAME);
        NtStatus = NtQueryValueKey(SamKeyHandle,
                                   &KeyName,
                                   KeyValuePartialInformation,
                                   KeyPartialInfo,
                                   KeyPartialInfoSize,
                                   &KeyPartialInfoSize);

        if (STATUS_BUFFER_TOO_SMALL == NtStatus) {
            //
            //  Allocate some space and then read the buffer
            //
            KeyPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)
                             MIDL_user_allocate(KeyPartialInfoSize);

            if (KeyPartialInfo) {

                NtStatus = NtQueryValueKey(SamKeyHandle,
                                           &KeyName,
                                           KeyValuePartialInformation,
                                           KeyPartialInfo,
                                           KeyPartialInfoSize,
                                           &KeyPartialInfoSize);
            } else {

                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: Memory allocation failed\n"));

                NtStatus = STATUS_NO_MEMORY;
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            //
            // Analyse the value's data
            //
            if (KeyPartialInfo->DataLength == sizeof(USER_INTERNAL1_INFORMATION)) {

                //
                // This looks good
                //

                if ( ARGUMENT_PRESENT(InternalInfo1) ) {

                    RtlCopyMemory(InternalInfo1, KeyPartialInfo->Data, sizeof(USER_INTERNAL1_INFORMATION));

                }

            } else {

                SampDiagPrint( PROMOTE, ("SAMSS: AdminInfo key found with bogus value length\n"));
                NtStatus = STATUS_UNSUCCESSFUL;
            }

        } else if (NtStatus != STATUS_OBJECT_NAME_NOT_FOUND) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtQueryValueKey failed with 0x%x\n",
                       NtStatus));

        }


        IgnoreStatus = NtClose(SamKeyHandle);
        if (!NT_SUCCESS(IgnoreStatus)) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtClose failed with 0x%x\n",
                       IgnoreStatus));

        }

        if (KeyPartialInfo) {

            RtlSecureZeroMemory(KeyPartialInfo, sizeof(KeyPartialInfo));
            MIDL_user_free(KeyPartialInfo);

        }


    } else {


        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: NtOpenKey failed with 0x%x\n",
                   NtStatus));

    }

    return NtStatus;

}


NTSTATUS
SampRemoveAdminPasswordFromRegistry(
    VOID
    )
/*++

Routine Description:

    This routine removes the temporily stored admin password from the
    registry.

Parameters:

    None.

Return Values:

    NTSTATUS value

--*/
{

    NTSTATUS          NtStatus, IgnoreStatus;

    OBJECT_ATTRIBUTES SamKey;
    UNICODE_STRING    SamKeyName;
    HANDLE            SamKeyHandle;

    UNICODE_STRING    ValueName;

    ULONG             DesiredAccess = GENERIC_ALL;

    //
    // Open the parent key
    //
    RtlInitUnicodeString(&SamKeyName, SAMP_REBOOT_INFO_KEY );
    InitializeObjectAttributes(&SamKey,
                               &SamKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&SamKeyHandle,
                         DesiredAccess,
                         &SamKey);

    if ( NT_SUCCESS(NtStatus) )
    {
        RtlInitUnicodeString( &ValueName, SAMP_ADMIN_INFO_NAME );

        NtStatus = NtDeleteValueKey( SamKeyHandle, &ValueName );

        if ( !NT_SUCCESS( NtStatus ) )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtDeleteValueKey failed with 0x%x\n",
                       NtStatus));
        }

        NtClose( SamKeyHandle );

    }
    else
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: NtOpenKey failed with 0x%x\n",
                   NtStatus));
    }

    return NtStatus;
}


WCHAR*
SampGetBlankAdminPasswordWarning(
    VOID
    )
/*++

Routine Description:

    This routine queries the resource table in samsrv.dll to get the string
    for the warning the admin password set failed.  If an error occurs trying
    to get the message, a default english string is used.

Parameters:

    None.

Return Values:

    The message string allocated from LocalAlloc; NULL if memory allocation
    failed.

--*/
{
    HMODULE ResourceDll;
    WCHAR   *WarningString=NULL;
    ULONG   Length, Size;
    BOOL    Status;

    ResourceDll = (HMODULE) LoadLibrary( L"SAMSRV.DLL" );

    if (ResourceDll) {

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        ResourceDll,
                                        SAMMSG_BLANK_ADMIN_PASSWORD,
                                        0,       // Use caller's language
                                        (LPWSTR)&WarningString,
                                        0,       // routine should allocate
                                        NULL
                                        );
        if (WarningString) {
            // Messages from a message file have a cr and lf appended
            // to the end
            WarningString[Length-2] = L'\0';
            Length -= 2;
        }

        Status = FreeLibrary(ResourceDll);
        ASSERT(Status);

    }

    if (!WarningString) {

        ASSERT(!"SAMSS: Resource allocation failed - this can be safely ignored");

        Size = (wcslen(SampDefaultBlankAdminPasswordWarningString)+1)*sizeof(WCHAR);
        WarningString = (WCHAR*)LocalAlloc(0, Size);
        if (WarningString) {
            wcscpy(WarningString, SampDefaultBlankAdminPasswordWarningString);
        }
    }

    return WarningString;

}

NTSTATUS
SampPerformNewServerPhase2(
    SAMPR_HANDLE DomainHandle,
    BOOLEAN      fMemberServer
    )

/*++

Routine Description:

    This routine performs the actions necessary on a reboot to complete
    a demotion operation.

    Currently, all this means is to set the account domain's admin's password.

    As well, the ds files are cleaned up.

Parameters:

    DomainHandle: a valid handle to the account domain

    fMemberServer: TRUE if this is a member server

Return Values:

    an NT status; a failure is critical

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus;
    WCHAR    *PathArray = NULL;
    DWORD    Size = 0;

    if ( SampUseDsData )
    {
        //
        // Protect against wierd configurations
        //

        // remove the key to
        NtStatus = SampDeleteDsDirsToDeleteKey();

        return STATUS_SUCCESS;
    }

    NtStatus = SampSetAdminPassword( DomainHandle );
    if ( !NT_SUCCESS(NtStatus) )
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampSetAdminPassword failed with %x0x\n"));
    }

    NtStatus = SampRetrieveDsDirsToDeleteKey( &PathArray, &Size );
    if ( NT_SUCCESS( NtStatus ) )
    {
        ASSERT( PathArray );
        NtStatus = SampProcessDsDirsToDelete( PathArray, Size );
        if ( !NT_SUCCESS(NtStatus) )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampProcessDsDirsToDelete failed with %x0x\n",
                       NtStatus));
        }

        //
        // Delete the key
        //
        IgnoreStatus = SampDeleteDsDirsToDeleteKey();

        MIDL_user_free( PathArray );

    }


    return NtStatus;
}

NTSTATUS
SampPerformTempUpgradeWork(
    SAMPR_HANDLE DomainHandle
    )
/*++

Routine Description:

    This routine sets the admin password on the temporary accounts made
    for downlevel upgrades.

Parameters:

    DomainHandle: a valid handle to the account domain

Return Values:

    an NT status; a failure is critical

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    NtStatus = SampSetAdminPassword( DomainHandle );
    if ( !NT_SUCCESS(NtStatus) )
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampSetAdminPassword failed with 0x%x\n",
                   NtStatus));
    }

    return NtStatus;
}




NTSTATUS
SampApplyWellKnownMemberships(
    IN SAMPR_HANDLE AccountDomainHandle,
    IN SAMPR_HANDLE BuiltinDomainHandle,
    IN PSID         DomainSid,
    IN ULONG        Flags
    )
/*++

Routine Description:

    This routine applies the memberships indicated by
    DsWellKnownMemberships

Parameters:

    DomainHandle - a handle to the account domain

    BuiltinDomainHandle - a handle to the builtin domain

    DomainSid - the sid of the account domain


Return Values:

    an NT status; a failure is not critical

--*/
{

    NTSTATUS      NtStatus = STATUS_SUCCESS;
    ULONG         i;
    SAMPR_HANDLE  GroupDomainHandle = NULL;
    ULONG         DesiredAccess = MAXIMUM_ALLOWED;
    PSID          CurrentDomainSid = 0;

    //
    // These values were taken from bldsam3.c
    //
    ULONG         Attributes = SE_GROUP_MANDATORY |
                               SE_GROUP_ENABLED_BY_DEFAULT |
                               SE_GROUP_ENABLED;

    //
    // Parameter checking
    //
    ASSERT(AccountDomainHandle);
    ASSERT(BuiltinDomainHandle);
    ASSERT(DomainSid);

    for ( i=0; i < ARRAY_COUNT( DsWellKnownMemberships ); i++ )
    {
        SAMPR_HANDLE GroupHandle = NULL;
        PSID         AccountSid = NULL;
        BOOLEAN      fGroupOpened = FALSE;

        //
        // apply the old logic if the membership is only meant to DS case
        //
        if (DsWellKnownMemberships[i].fDSOnly)
        {
            if (!SampUseDsData)
            {
                //
                // we are in Registry mode, but the membership is for DS mode only
                //

                continue;
            }

            if (  DsWellKnownMemberships[i].fEnterpriseOnly
              &&  !FLAG_ON( Flags, SAMP_PROMOTE_ENTERPRISE ) )
            {
                //
                // Thanks, but no thanks
                //
                continue;
            }

            //
            // This is one of three cases: upgrade from nt4, win2k to ws03 
            // upgrade, or fresh install.  Filter the default memberships
            // appropriate to the scenario.  The rule is that the default
            // membership from a particular release shouldn't be applied
            // to an upgrade from that release (because the default were
            // already applied once).
            //
            if ( FLAG_ON(Flags, SAMP_PROMOTE_UPGRADE) ) {

                // NT4 upgrade
                if (DsWellKnownMemberships[i].ReleaseVersion < WIN2K_RELEASE) {
                    continue;
                }

            } else if ( FLAG_ON(Flags, SAMP_PROMOTE_INTERNAL_UPGRADE) ) {

                // win2k to ws03 upgrade or ws03 to ws03 PDC transfer
                if (DsWellKnownMemberships[i].ReleaseVersion < WS03_RELEASE) {
                    continue;
                }

            } else {

                ASSERT(FLAG_ON(Flags, SAMP_PROMOTE_MIGRATE));
                // This is the fresh install case -- apply all the domain
                // defaults
            }

            if ( 
                
                //
                // logic to be preformed on PRE WIN2K compat group.
                //
                 (DOMAIN_ALIAS_RID_PREW2KCOMPACCESS == DsWellKnownMemberships[i].GroupRid) 
                 
                 &&

                 (

                     //
                     // If Pre-W2K compat was not selected we only want to apply
                     // the Authenticated Users to the group
                     //
                     ( !FLAG_ON( Flags, SAMP_PROMOTE_ALLOW_ANON ) 
                       && !(SampAuthenticatedUsersSid == *DsWellKnownMemberships[i].WellKnownAccountSid) ) 
                     ||
                     //
                     // If Pre-W2K compat was selected then we only want to skip
                     // applying Authenticated Users to the group
                     //
                     ( FLAG_ON( Flags, SAMP_PROMOTE_ALLOW_ANON )
                       && (SampAuthenticatedUsersSid == *DsWellKnownMemberships[i].WellKnownAccountSid)  )
                 )

               ) 
            {
                //
                // Don't apply
                //
                continue;

            } 

        }

        //
        // Get the right domain handle for the group
        //
        if ( DsWellKnownMemberships[i].fBuiltinGroup )
        {
            GroupDomainHandle = BuiltinDomainHandle;
        }
        else
        {
            GroupDomainHandle = AccountDomainHandle;
        }

        switch ( DsWellKnownMemberships[i].GroupType )
        {
            case SampGroupObjectType:

                //
                // Get the group handle
                //
                NtStatus = SamrOpenGroup( GroupDomainHandle,
                                          DesiredAccess,
                                          DsWellKnownMemberships[i].GroupRid,
                                          &GroupHandle );


                if ( !NT_SUCCESS( NtStatus ) )
                {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: SamrOpenGroup failed with 0x%x\n",
                               NtStatus));

                    goto IterationCleanup;
                }
                fGroupOpened = TRUE;

                //
                // Add the member
                //
                NtStatus = SamrAddMemberToGroup( GroupHandle,
                                                 DsWellKnownMemberships[i].AccountRid,
                                                 Attributes );


                if ( (NtStatus == STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS)
                 ||  (NtStatus == STATUS_MEMBER_IN_GROUP) )
                {
                    NtStatus = STATUS_SUCCESS;
                }

                if ( !NT_SUCCESS( NtStatus ) )
                {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: SamrAddMemberToGroup failed with 0x%x\n",
                               NtStatus));

                    goto IterationCleanup;
                }

                break;

            case SampAliasObjectType:

                //
                // Get the alias handle
                //


                NtStatus = SamrOpenAlias( GroupDomainHandle,
                                          DesiredAccess,
                                          DsWellKnownMemberships[i].GroupRid,
                                          &GroupHandle );


                if ( !NT_SUCCESS( NtStatus ) )
                {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: SamrOpenAlias failed with 0x%x\n",
                               NtStatus));

                    goto IterationCleanup;
                }
                fGroupOpened = TRUE;

                //
                // Prepare the Account SID
                //
                if (DsWellKnownMemberships[i].fWellKnownSid)
                {
                    ULONG   Size;

                    ASSERT( NULL != *DsWellKnownMemberships[i].WellKnownAccountSid );


                    Size = RtlLengthSid(*DsWellKnownMemberships[i].WellKnownAccountSid);

                    AccountSid = midl_user_allocate( Size );
                    if ( !AccountSid ) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        goto IterationCleanup;
                    }
                    RtlCopyMemory( AccountSid,
                                   *DsWellKnownMemberships[i].WellKnownAccountSid,
                                   Size );
                }
                else
                {
                    if ( DsWellKnownMemberships[i].fBuiltinAccount )
                    {
                        CurrentDomainSid = SampBuiltinDomainSid;
                    }
                    else
                    {
                        CurrentDomainSid = DomainSid;
                    }


                    NtStatus = SampCreateFullSid( CurrentDomainSid,
                                                  DsWellKnownMemberships[i].AccountRid,
                                                  &AccountSid );

                    if ( !NT_SUCCESS( NtStatus ) )
                    {
                        KdPrintEx((DPFLTR_SAMSS_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "SAMSS: SampCreateFullSid failed with 0x%x\n",
                                   NtStatus));

                        goto IterationCleanup;
                    }

                }

                //
                // Add the member
                //
                NtStatus = SamrAddMemberToAlias( GroupHandle,
                                                 AccountSid );

                if ( (NtStatus == STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS)
                 ||  (NtStatus == STATUS_MEMBER_IN_ALIAS) )

                {
                    NtStatus = STATUS_SUCCESS;
                }

                if ( !NT_SUCCESS( NtStatus ) )
                {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: SamrAddMemberToAlias failed with 0x%x\n",
                               NtStatus));

                    goto IterationCleanup;
                }


                break;

            default:
                ASSERT( "Invalid switch statement" );

        }

IterationCleanup:

        if ( !NT_SUCCESS( NtStatus ) )
        {

            //
            // Log the error and then reset NtStatus to success
            //
            NTSTATUS IgnoreStatus = STATUS_SUCCESS;
            DWORD    WinError = ERROR_SUCCESS;
            DWORD    WinErrorToLog;
            UNICODE_STRING User, Group, Error;
            PUNICODE_STRING EventStrings[3] = { &User, &Group, &Error };
            ULONG    Length;
            HMODULE  AccountNamesResource = NULL;

            RtlSecureZeroMemory( &User, sizeof( UNICODE_STRING ) );
            RtlSecureZeroMemory( &Group, sizeof( UNICODE_STRING ) );
            RtlSecureZeroMemory( &Error, sizeof( UNICODE_STRING ) );

            AccountNamesResource = (HMODULE) LoadLibrary( L"SAMSRV.DLL" );
            if (AccountNamesResource) {
                IgnoreStatus = SampGetMessageStrings( AccountNamesResource,
                                                      DsWellKnownMemberships[i].AccountName,
                                                      &User,
                                                      DsWellKnownMemberships[i].GroupName,
                                                      &Group );

                FreeLibrary( AccountNamesResource );
            } else {
                IgnoreStatus = STATUS_RESOURCE_DATA_NOT_FOUND;
            }

            WinErrorToLog = RtlNtStatusToDosError( NtStatus );
            Length = FormatMessage( (FORMAT_MESSAGE_FROM_SYSTEM |
                                     FORMAT_MESSAGE_ALLOCATE_BUFFER),
                                     NULL, // no source
                                     WinErrorToLog,
                                     0, // let the system decide the language
                                     (LPWSTR)&Error.Buffer,
                                     0, // buffer is to be allocated
                                     NULL // no inserts
                                    );
            if ( Length > 0 ) {
                Error.Length = (USHORT)Length;
                Error.MaximumLength = (USHORT)Length;
                Error.Buffer[Length-2] = L'\0';
            } else {
                WinError = GetLastError();
            }

            if (  (ERROR_SUCCESS == WinError)
                && NT_SUCCESS( IgnoreStatus ) )
            {
                ULONG Msg = SAMMSG_MEMBERSHIP_SETUP_ERROR_NO_GROUP;
                if ( fGroupOpened )
                {
                    Msg = SAMMSG_MEMBERSHIP_SETUP_ERROR;
                }

                SampWriteEventLog( EVENTLOG_INFORMATION_TYPE,
                                   0,    // no category
                                   Msg,
                                   NULL, // no sid
                                   sizeof(EventStrings)/sizeof(EventStrings[0]), // number of strings
                                   sizeof(DWORD), // size of data
                                   EventStrings,
                                   &WinErrorToLog
                                    );

            }

            if ( User.Buffer )
            {
                LocalFree( User.Buffer );
            }
            if ( Group.Buffer )
            {
                LocalFree( Group.Buffer );
            }
            if ( Error.Buffer )
            {
                LocalFree( Error.Buffer );
            }

            // This error condition is handled
            NtStatus = STATUS_SUCCESS;

        }


        if (GroupHandle)
        {
            SamrCloseHandle(&GroupHandle);
            GroupHandle = NULL;
        }

       if ( AccountSid )
       {
           MIDL_user_free(  AccountSid );
           AccountSid = NULL;
       }

    }

    ASSERT( NT_SUCCESS( NtStatus ) );
    return NtStatus;
}


NTSTATUS
SampAddAnonymousOrAuthUsersToPreW2KCompAlias(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMPR_HANDLE BuiltinDomainHandle
    )
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    SAMPR_HANDLE        AliasHandle = NULL;
    SAMPR_PSID_ARRAY    MembersBuffer;
    BOOLEAN             IsMemberAlready = FALSE, AddToAlias = FALSE;
    ULONG               i;

    // init local variables

    RtlSecureZeroMemory(&MembersBuffer, sizeof(SAMPR_PSID_ARRAY));

    //
    // Get alias handle
    //
    NtStatus = SamrOpenAlias(BuiltinDomainHandle,   // Domain Handle
                             MAXIMUM_ALLOWED,       // Desired Access
                             DOMAIN_ALIAS_RID_PREW2KCOMPACCESS, // Alias Rid
                             &AliasHandle
                             );

    if (!NT_SUCCESS(NtStatus))
    {
        //
        // PRE_Windows 2000 Compatibility Group Should always be there
        //
        goto Cleanup;
    }

    //
    // Get Alias Members
    //
    NtStatus = SamrGetMembersInAlias(AliasHandle,
                                     ( PSAMPR_PSID_ARRAY_OUT ) &MembersBuffer
                                     );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // Check membership, whether Everyone is a member of W2KCompGroup
    //
    for (i = 0; i < MembersBuffer.Count; i++)
    {
        if (RtlEqualSid(SampWorldSid, MembersBuffer.Sids[i].SidPointer))
        {
            AddToAlias = TRUE;
        }
        if (RtlEqualSid(SampAnonymousSid, MembersBuffer.Sids[i].SidPointer))
        {
            IsMemberAlready = TRUE;
        }
    }

    //
    // Add the member
    //

    if (AddToAlias && !IsMemberAlready)
    {
        NtStatus = SamrAddMemberToAlias(AliasHandle,
                                        SampAnonymousSid
                                        );

        if ( (NtStatus == STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS)
         ||  (NtStatus == STATUS_MEMBER_IN_ALIAS) )
        {
            NtStatus = STATUS_SUCCESS;
        }
    } 

Cleanup:

    if (AliasHandle)
    {
        SamrCloseHandle(&AliasHandle);
    }

    if (MembersBuffer.Sids)
    {
        MIDL_user_free(MembersBuffer.Sids);
    }

    return( NtStatus );
}





NTSTATUS
SampStoreDsDirsToDelete(
    VOID
    )
/*++

Routine Description:

    This routine queries the ds config to determine what directories
    to delete.  It then saves them in the process heap so when the ds is
    finally shutdown, the directories can be cleared.

Parameters:

    None.

Return Values:

    an NT status; a failure is not critical

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DWORD    WinError = ERROR_SUCCESS;

    DWORD Size, Index, TotalSize, ArrayIndex;

    WCHAR **DsDirsArray = NULL;
    WCHAR *ContiguousArray = NULL;

    struct
    {
        WCHAR *RegKey;

    } SuffixArray[] =
    {
        TEXT(BACKUPPATH_KEY),
        TEXT(JETSYSTEMPATH_KEY),
        TEXT(LOGPATH_KEY)
    };

    ULONG NumberOfDirectories = ARRAY_COUNT(SuffixArray);

    //
    // Set up the directory array.
    //
    Size = (NumberOfDirectories) * sizeof(WCHAR*);
    DsDirsArray = (WCHAR**) MIDL_user_allocate( Size );
    if ( NULL == DsDirsArray )
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    RtlSecureZeroMemory( DsDirsArray, Size );

    //
    // Set up the individual directories
    //
    TotalSize = 0;
    Size = (MAX_PATH+1)*sizeof(WCHAR); // +1 for NULL
    for ( Index = 0; Index < NumberOfDirectories; Index++ )
    {
        DsDirsArray[Index] = (WCHAR*) MIDL_user_allocate( Size );
        if ( DsDirsArray[Index] )
        {
            RtlSecureZeroMemory( DsDirsArray[Index], Size );

            WinError = GetConfigParamW( SuffixArray[Index].RegKey,
                                        DsDirsArray[Index],
                                        Size );
            if ( ERROR_SUCCESS != WinError )
            {
                MIDL_user_free( DsDirsArray[Index] );
                DsDirsArray[Index] = 0;
            } 
            else
            {
                TotalSize += (wcslen( DsDirsArray[Index] ) + 1) * sizeof(WCHAR);
            }
        }
        else
        {
            // No memory - break
            NtStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }
    }

    //
    // Marshall the strings up into a contiguous piece of memory
    //
    ContiguousArray = (WCHAR*) MIDL_user_allocate( TotalSize );
    if ( !ContiguousArray )
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    RtlSecureZeroMemory( ContiguousArray, TotalSize );

    Index = 0;
    for (ArrayIndex = 0; ArrayIndex < NumberOfDirectories; ArrayIndex++)
    {
        if ( DsDirsArray[ArrayIndex] )
        {
            DWORD StringSize = (wcslen( DsDirsArray[ArrayIndex] ) + 1) * sizeof(WCHAR);
            RtlCopyMemory( &(ContiguousArray[Index]), DsDirsArray[ArrayIndex], StringSize );
            Index += (StringSize / sizeof(WCHAR));
        }
    }

    //
    // Set the value in the registry
    //
    NtStatus = SampCreateDsDirsToDeleteKey( ContiguousArray, TotalSize );
    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }


Cleanup:

    if ( ContiguousArray )
    {
        MIDL_user_free( ContiguousArray );
    }

    if ( DsDirsArray )
    {
        for (ArrayIndex = 0; ArrayIndex < NumberOfDirectories; ArrayIndex++)
        {
            if  ( DsDirsArray[ArrayIndex] )
            {
                MIDL_user_free( DsDirsArray[ArrayIndex] );
            }
        }

        MIDL_user_free( DsDirsArray );
    }

    return NtStatus;
}


NTSTATUS
SampProcessDsDirsToDelete(
    IN OUT WCHAR *PathArray,
    IN DWORD Size
    )
/*++

Routine Description:

Parameters:


Return Values:

    A system service error

--*/
{
    NTSTATUS NtStatus  = STATUS_SUCCESS;
    DWORD    WinError  = ERROR_SUCCESS;
    WCHAR    Delim = L'\t';
    WCHAR    *DelimString = L"\t";
    WCHAR    *Path;
    ULONG    CharCount = Size / sizeof(WCHAR);
    ULONG    Index;

    //
    // Convert NULL's to tabs so wcstok will work
    //
    for ( Index = 0; Index < CharCount; Index++ )
    {
        if ( Index == (CharCount-1))
        {
            // final character - should be NULL
            ASSERT( L'\0' == PathArray[Index] );
        }
        else if ( L'\0' == PathArray[Index] )
        {
            PathArray[Index] = Delim;
        }
    }

    if ( PathArray )
    {
        Path = wcstok( PathArray, DelimString );
        while ( Path )
        {
            WinError = SampClearDirectory( Path );

            if (  ERROR_SUCCESS != WinError
              && !(   WinError == ERROR_PATH_NOT_FOUND
                   || WinError == ERROR_FILE_NOT_FOUND ) )
            {
                //
                // Tell the user to clear this directory
                //
                PUNICODE_STRING EventString[1];
                UNICODE_STRING  UnicodeString;

                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: Failed to delete directory %ls; error %d\n",
                           Path,
                           WinError));

                RtlInitUnicodeString( &UnicodeString, Path );
                EventString[0] = &UnicodeString;


                SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                                  0,     // no category
                                  SAMMSG_DATABASE_DIR_NOT_DELETED,
                                  NULL,  // no sid
                                  1,
                                  sizeof(DWORD),
                                  EventString,
                                  (PVOID)(&WinError));
            }

            Path = wcstok( NULL, DelimString );
        }
    }

    return NtStatus;
}

NTSTATUS
SampCreateDsDirsToDeleteKey(
    IN WCHAR *PathArray,
    IN DWORD Size
    )
/*++

Routine Description:

Parameters:


Return Values:

    A system service error

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    NTSTATUS          IgnoreStatus;

    OBJECT_ATTRIBUTES SamKey;
    UNICODE_STRING    SamKeyName;
    HANDLE            SamKeyHandle;

    UNICODE_STRING    PromoteKeyName;

    ULONG             DesiredAccess = GENERIC_ALL;

    //
    // Open the parent key
    //
    RtlInitUnicodeString(&SamKeyName, SAMP_REBOOT_INFO_KEY );
    InitializeObjectAttributes(&SamKey,
                               &SamKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&SamKeyHandle,
                         DesiredAccess,
                         &SamKey);

    if (NT_SUCCESS(NtStatus)) {

        //
        // Create the value
        //
        RtlInitUnicodeString(&PromoteKeyName, SAMP_DS_DIRS_INFO_NAME );
        NtStatus = NtSetValueKey(SamKeyHandle,
                                 &PromoteKeyName,
                                 0,               // Title name, optional
                                 REG_MULTI_SZ,
                                 PathArray,
                                 Size);

        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtSetValueKey failed with 0x%x\n",
                       NtStatus));
        }

        IgnoreStatus = NtFlushKey(SamKeyHandle);
        if (!NT_SUCCESS(IgnoreStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtFlushKey failed with 0x%x\n",
                       IgnoreStatus));
        }

        IgnoreStatus = NtClose(SamKeyHandle);
        if (!NT_SUCCESS(IgnoreStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtClose failed with 0x%x\n",
                       IgnoreStatus));
        }

    }
    else {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: NtOpenKey failed with 0x%x\n",
                   NtStatus));

    }

    return NtStatus;
}

NTSTATUS
SampRetrieveDsDirsToDeleteKey(
    OUT WCHAR **pPathArray,
    OUT DWORD *Size
    )
/*++

Routine Description:

Parameters:


Return Values:

    A system service error

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus;

    OBJECT_ATTRIBUTES SamKey;
    UNICODE_STRING    SamKeyName;
    HANDLE            SamKeyHandle;

    UNICODE_STRING    PromoteKeyName;

    ULONG             DesiredAccess = GENERIC_ALL;

    PKEY_VALUE_PARTIAL_INFORMATION   KeyPartialInfo;
    ULONG                            KeyPartialInfoSize = 0;

    WCHAR *Paths = NULL;

    ASSERT(pPathArray);
    ASSERT(Size);

    //
    // Open the parent key
    //
    RtlInitUnicodeString(&SamKeyName, SAMP_REBOOT_INFO_KEY);
    InitializeObjectAttributes(&SamKey,
                               &SamKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&SamKeyHandle,
                         DesiredAccess,
                         &SamKey);

    if (NT_SUCCESS(NtStatus)) {

        //
        // Query the value
        //

        RtlInitUnicodeString( &PromoteKeyName, SAMP_DS_DIRS_INFO_NAME );
        NtStatus = NtQueryValueKey(SamKeyHandle,
                                   &PromoteKeyName,
                                   KeyValuePartialInformation,
                                   NULL,
                                   0,
                                   &KeyPartialInfoSize);

        if (STATUS_BUFFER_TOO_SMALL == NtStatus) {
            //
            //  Allocate some space and then read the buffer
            //
            KeyPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)
                             MIDL_user_allocate(KeyPartialInfoSize);

            if (KeyPartialInfo) {

                NtStatus = NtQueryValueKey(SamKeyHandle,
                                           &PromoteKeyName,
                                           KeyValuePartialInformation,
                                           KeyPartialInfo,
                                           KeyPartialInfoSize,
                                           &KeyPartialInfoSize);

                if (NT_SUCCESS(NtStatus)) {
                    //
                    // Analysis the value's data
                    //
                    *pPathArray = (WCHAR*) MIDL_user_allocate( KeyPartialInfo->DataLength );

                    if ( *pPathArray )
                    {
                        RtlCopyMemory( *pPathArray,
                                        KeyPartialInfo->Data,
                                        KeyPartialInfo->DataLength );
                        *Size = KeyPartialInfo->DataLength;
                    }
                    else
                    {
                        NtStatus = STATUS_NO_MEMORY;
                    }

                } else {

                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: NtQueryValueKey failed with 0x%x\n",
                               NtStatus));
                }

                MIDL_user_free( KeyPartialInfo );

            } else {

                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: Memory allocation failed\n"));

                NtStatus = STATUS_NO_MEMORY;

            }

        }
        else
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtQueryValueKey failed with 0x%x\n",
                       NtStatus));
        }


        IgnoreStatus = NtClose(SamKeyHandle);
        if (!NT_SUCCESS(IgnoreStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtClose failed with 0x%x\n",
                       IgnoreStatus));
        }

    }
    else {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: NtOpenKey failed with 0x%x\n",
                   NtStatus));

    }

    if ( NT_SUCCESS( NtStatus ) )
    {
        ASSERT( *pPathArray );
    }

    return NtStatus;
}

NTSTATUS
SampDeleteDsDirsToDeleteKey(
    VOID
    )
/*++

Routine Description:

Parameters:


Return Values:

    A system service error

--*/
{

    NTSTATUS          NtStatus = STATUS_SUCCESS;

    OBJECT_ATTRIBUTES SamKey;
    UNICODE_STRING    SamKeyName;
    HANDLE            SamKeyHandle;

    UNICODE_STRING    ValueName;

    ULONG             DesiredAccess = GENERIC_ALL;

    //
    // Open the parent key
    //
    RtlInitUnicodeString(&SamKeyName, SAMP_REBOOT_INFO_KEY );
    InitializeObjectAttributes(&SamKey,
                               &SamKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&SamKeyHandle,
                         DesiredAccess,
                         &SamKey);

    if ( NT_SUCCESS(NtStatus) )
    {
        RtlInitUnicodeString( &ValueName, SAMP_DS_DIRS_INFO_NAME );

        NtStatus = NtDeleteValueKey( SamKeyHandle, &ValueName );

        if ( !NT_SUCCESS( NtStatus )
          && STATUS_OBJECT_NAME_NOT_FOUND != NtStatus )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtDeleteValueKey failed with 0x%x\n",
                       NtStatus ));
        }

        NtClose( SamKeyHandle );

    }
    else
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: NtOpenKey failed with 0x%x\n",
                   NtStatus));
    }

    return NtStatus;
}

DWORD
SampClearDirectory(
    IN WCHAR *DirectoryName
    )
/*++

Routine Description:

    This routine deletes all the files in Directory and, then
    if the directory is empty, removes the directory.

Parameters:

    DirectoryName: a null terminated string

Return Values:

    A value from winerror.h

    ERROR_SUCCESS - The check was done successfully.

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    DWORD ExtendedWinError = ERROR_SUCCESS;
    HANDLE          FindHandle = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindData;
    WCHAR           Path[ MAX_PATH ];
    WCHAR           FilePath[ MAX_PATH ];
    BOOL            fStatus;

    if ( !DirectoryName )
    {
        return ERROR_SUCCESS;
    }

    if ( wcslen(DirectoryName) > MAX_PATH - 4 )
    {
        return ERROR_INVALID_PARAMETER;
    }

    RtlSecureZeroMemory( Path, sizeof(Path) );
    wcscpy( Path, DirectoryName );
    wcscat( Path, L"\\*.*" );

    RtlSecureZeroMemory( &FindData, sizeof( FindData ) );
    FindHandle = FindFirstFile( Path, &FindData );
    if ( INVALID_HANDLE_VALUE == FindHandle )
    {
        WinError = GetLastError();
        goto ClearDirectoryExit;
    }

    do
    {

        if (  !FLAG_ON( FindData.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY ) )
        {
            RtlSecureZeroMemory( FilePath, sizeof(FilePath) );
            wcscpy( FilePath, DirectoryName );
            wcscat( FilePath, L"\\" );
            wcscat( FilePath, FindData.cFileName );

            fStatus = DeleteFile( FilePath );
            if ( !fStatus )
            {
                ExtendedWinError = GetLastError();
            }

            //
            // Even if error, continue on
            //
        }

        RtlSecureZeroMemory( &FindData, sizeof( FindData ) );

    } while ( FindNextFile( FindHandle, &FindData ) );

    WinError = GetLastError();

    //
    // Fall through to the exit
    //

ClearDirectoryExit:

    // This is not an error
    if ( ERROR_NO_MORE_FILES == WinError )
    {
        WinError = ERROR_SUCCESS;
    }

    if ( INVALID_HANDLE_VALUE != FindHandle )
    {
        FindClose( FindHandle );
    }

    if ( ERROR_SUCCESS == WinError )
    {
        //
        // Try to remove the directory
        //
        fStatus = RemoveDirectory( DirectoryName );

        //
        // Ignore the error and continue on
        //
        if ( !fStatus )
        {
            ExtendedWinError = GetLastError();
        }

    }

    // Propogate error if any delete file failed
    if ( ERROR_SUCCESS == WinError )
    {
        WinError = ExtendedWinError;
    }


    return WinError;
}

NTSTATUS
SampAddEnterpriseAdminsToAdministrators(
    VOID
    )
/*++

Routine Description:

    This routine, called during SamIPromote add the enterprise wide account
    of "Enterprise Admins" to the alias Administrators.

Parameters:

    None.

Return Values:

    STATUS_SUCCESS

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;

    PPOLICY_DNS_DOMAIN_INFO  DnsDomainInfo = NULL;

    ULONG   Size = 0;
    DSNAME *RootDomain = 0;

    DSNAME *AdministratorsDsName = NULL;

    // alloc'ed by MIDL_user_allocate
    PSID    EAdminsSid = NULL;
    DSNAME **EAdminsDsName = NULL;

    ULONG Count;

    //
    // Get the current domain sid
    //
    NtStatus = LsaIQueryInformationPolicyTrusted(PolicyDnsDomainInformation,
                   (PLSAPR_POLICY_INFORMATION*) &DnsDomainInfo );
    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }

    //
    // Get the root domain sid via its dsname
    //
    Size = 0;
    RootDomain = NULL;
    NtStatus = GetConfigurationName( DSCONFIGNAME_ROOT_DOMAIN,
                                     &Size,
                                     RootDomain );
    if ( STATUS_BUFFER_TOO_SMALL == NtStatus )
    {
        SAMP_ALLOCA(RootDomain,Size );

        if (NULL==RootDomain)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        NtStatus = GetConfigurationName( DSCONFIGNAME_ROOT_DOMAIN,
                                         &Size,
                                         RootDomain );

    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }
    ASSERT( RtlValidSid( &RootDomain->Sid ) );

    //
    // Construct the enterprise admins' sid
    //
    NtStatus = SampCreateFullSid( &RootDomain->Sid,
                                  DOMAIN_GROUP_RID_ENTERPRISE_ADMINS,
                                  &EAdminsSid
                                  );
    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }

    //
    // Create the local administrators dsname
    //
    Size = DSNameSizeFromLen( 0 );
    SAMP_ALLOCA(AdministratorsDsName ,Size );
    if (NULL==AdministratorsDsName)
    {
       NtStatus = STATUS_INSUFFICIENT_RESOURCES;
       goto Cleanup;
    }
    RtlSecureZeroMemory( AdministratorsDsName, Size );
    AdministratorsDsName->structLen = Size;
    AdministratorsDsName->SidLen = RtlLengthSid( SampAdministratorsAliasSid );
    RtlCopySid( AdministratorsDsName->SidLen,
                &AdministratorsDsName->Sid,
                SampAdministratorsAliasSid );

    //
    // Create an FPO for the enterprise admins objects
    //
    Count = 0;
    do
    {
        //
        // Start a transaction
        //
        NTSTATUS st;

        NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );
        if ( !NT_SUCCESS( NtStatus ) )
        {
            break;
        }

        NtStatus = SampDsResolveSidsForDsUpgrade(
                        DnsDomainInfo->Sid,
                        &EAdminsSid,
                        1,
                        (RESOLVE_SIDS_FAIL_WELLKNOWN_SIDS
                        | RESOLVE_SIDS_ADD_FORIEGN_SECURITY_PRINCIPAL ),
                        &EAdminsDsName
                        );

        if ( NT_SUCCESS( NtStatus )
          && NULL != EAdminsDsName[0] )
        {
            //
            // Add the EA to administrators
            //
            NtStatus = SampDsAddMembershipAttribute( AdministratorsDsName,
                                                     SAM_ALLOW_INTRAFOREST_FPO,
                                                     SampAliasObjectType,
                                                     SAMP_ALIAS_MEMBERS,
                                                     EAdminsDsName[0] );

            if ( STATUS_MEMBER_IN_ALIAS == NtStatus )
            {
                // This is acceptable
                NtStatus = STATUS_SUCCESS;
            }
        }

        st = SampMaybeEndDsTransaction( NT_SUCCESS(NtStatus) ?
                                           TransactionCommit :
                                           TransactionAbort );

        // Propogate the error if necessary
        if ( NT_SUCCESS(NtStatus) )
        {
            NtStatus = st;
        }

    } while ( (STATUS_DS_BUSY == NtStatus) && Count < 5 );

    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }

    //
    // That's it -- fall through to cleanup
    //

Cleanup:


    // We should only fail on resource error, so let's assert

    ASSERT( NT_SUCCESS( NtStatus ) );
    if ( !NT_SUCCESS( NtStatus ) )
    {
        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                          0,     // no category
                          SAMMSG_EA_TO_ADMIN_FAILED,
                          NULL,  // no sid
                          0,
                          sizeof(DWORD),
                          NULL,  // no message insert
                          (PVOID)(&NtStatus));

        // This is error has been handled
        NtStatus = STATUS_SUCCESS;
    }

    if ( EAdminsSid )
    {
        MIDL_user_free( EAdminsSid );
    }

    if ( EAdminsDsName )
    {
        if ( EAdminsDsName[0] )
        {
            MIDL_user_free( EAdminsDsName[0] );
        }
        MIDL_user_free( EAdminsDsName );
    }

    if ( DnsDomainInfo )
    {
        LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION) DnsDomainInfo );
    }

    return NtStatus;

}


DWORD
SampSetMachineAccountSecret(
    LPWSTR SecretValue
    )
/*++

Routine Description:

    This routine sets the local copy of the machine account's password.

    We go through the lsa client library because there is no easy way to
    set a secret via the in-proc api.

Parameters:

    None.

Return Values:

    ERROR_SUCCESS; winerror otherwise

--*/
{
    OBJECT_ATTRIBUTES PolicyObject;
    HANDLE   PolicyHandle;
    NTSTATUS NtStatus;
    UNICODE_STRING SecretName, SecretString;

    RtlInitUnicodeString(&SecretName, SSI_SECRET_NAME);

    RtlInitUnicodeString(&SecretString, SecretValue);

    RtlSecureZeroMemory(&PolicyObject, sizeof(PolicyObject));

    NtStatus = LsaOpenPolicy(NULL,
                             &PolicyObject,
                             MAXIMUM_ALLOWED,
                             &PolicyHandle );

    if ( NT_SUCCESS(NtStatus) )
    {

        NtStatus = LsaStorePrivateData(PolicyHandle,
                                       &SecretName,
                                       &SecretString);

        LsaClose(PolicyHandle);
    }

    return NtStatus;

}



NTSTATUS
SampSetSafeModeAdminPassword(
    VOID
    )

/*++

Routine Description:

    This routine is called during the first boot of a domain controller to
    set the admin password of the safemode SAM registry hive.  The OWF
    password is stored in the registry; this routine must gaurentee to delete
    it whether or not the password set succeeded.

    This function is tricky because although we are running in DS mode
    we are setting a value in the registry SAM.

Parameters:

    None.

Return Values:

    A system service error

--*/
{
    NTSTATUS     NtStatus = STATUS_SUCCESS;
    PSAMP_OBJECT AccountContext = NULL;
    USER_INTERNAL1_INFORMATION   Internal1Info;
    BOOLEAN fLockHeld = FALSE;
    BOOLEAN fCommit = FALSE;

    RtlSecureZeroMemory( &Internal1Info, sizeof(Internal1Info) );

    NtStatus = SampGetAdminPasswordFromRegistry(&Internal1Info);
    if ( !NT_SUCCESS(NtStatus) ) {

        if (NtStatus != STATUS_OBJECT_NAME_NOT_FOUND) {
            //
            // This is worth noting
            //
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampGetAdminPasswordFromRegistry failed with 0x%x\n",
                       NtStatus));
        }

        //
        // Ok, nothing to set
        //
        return STATUS_SUCCESS;
    }


    NtStatus = SampAcquireWriteLock();
    if ( !NT_SUCCESS( NtStatus ) )
    {
        SampDiagPrint( DISPLAY_LOCKOUT,
                     ( "SAMSS: SampAcquireWriteLock returned 0x%x\n",
                      NtStatus ));

        goto Cleanup;
    }
    fLockHeld = TRUE;

    //
    // Set the transactional domain the account context will go to
    // the registry
    //
    SampSetTransactionDomain( SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX );

    //
    // Create a context
    //
    NtStatus = SampCreateAccountContext( SampUserObjectType,
                                         DOMAIN_USER_RID_ADMIN,
                                         TRUE,  // trusted client
                                         FALSE, // loopback
                                         TRUE,  // account exists
                                         &AccountContext );

    if ( !NT_SUCCESS( NtStatus ) )
    {
        SampDiagPrint( DISPLAY_LOCKOUT,
                ( "SAMSS: SampCreateAccountContext for rid 0x%x returned 0x%x\n",
                      DOMAIN_USER_RID_ADMIN, NtStatus ));

        goto Cleanup;
    }

    SampReferenceContext( AccountContext );

    //
    // Store the passwords
    //
    NtStatus = SampStoreUserPasswords( AccountContext,
                                       &Internal1Info.LmOwfPassword,
                                       Internal1Info.LmPasswordPresent,
                                       &Internal1Info.NtOwfPassword,
                                       Internal1Info.NtPasswordPresent,
                                       FALSE,  // don't check password restrictions
                                       PasswordSet,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL
                                       );

    if ( !NT_SUCCESS( NtStatus ) )
    {
        SampDiagPrint( DISPLAY_LOCKOUT,
                     ( "SAMSS: SampStoreUserPasswords returned 0x%x\n",
                      NtStatus ));

        goto Cleanup;
    }
    fCommit = TRUE;



Cleanup:

    if ( AccountContext )
    {
        //
        //  Dereference the context to make the changes
        //
        NtStatus = SampDeReferenceContext( AccountContext, fCommit );
        if ( !NT_SUCCESS( NtStatus ) )
        {
            SampDiagPrint( DISPLAY_LOCKOUT,
                         ( "SAMSS: SampDeReferenceContext returned 0x%x\n",
                          NtStatus ));

            fCommit = FALSE;
        }


    }

    if ( fLockHeld ) {

        FlushImmediately = TRUE;

        NtStatus = SampReleaseWriteLock( fCommit );

        FlushImmediately = FALSE;

    }

    //
    // Keep the key open
    //
    if ( AccountContext ) {

        SampDeleteContext( AccountContext );
        AccountContext = 0;

    }

    if ( NT_SUCCESS( NtStatus ) && fCommit ) {

        SampRemoveAdminPasswordFromRegistry();

    }

    return NtStatus;


}


NTSTATUS
SampGenerateRandomPassword(
    IN LPWSTR Password,
    IN ULONG  Length
    )

/*++

Routine Description:

    This routine fills in Password with random bits.

Parameters:

    Password -- a preallocated buffer of WCHAR's

    Length -- the number of characters (not bytes) in Password

Return Values:

    None.

--*/
{
    ULONG i;
    BOOLEAN fStatus;

    fStatus = CDGenerateRandomBits( (PUCHAR) Password,
                                    Length * sizeof(WCHAR) );
    if ( !fStatus ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Terminate the password
    Password[Length-1] = L'\0';
    // Make sure there aren't any NULL's in the password
    for (i = 0; i < (Length-1); i++)
    {
        if ( Password[i] == L'\0' )
        {
            // arbitrary letter
            Password[i] = L'c';
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
SampMakeNullTerminateString(
    IN  PUNICODE_STRING UnicodeString,
    OUT LPWSTR *ppStringWithNullTerminator
)
/*++
Routine Description:

    This routine copies the UnicodeString to a NULL terminated WCHAR string.

Parameters:

    UnicodeString - input string

    ppStringWithNullTerminator - returning string with NULL terminator

Return Value:

    STATUS_INSUFFICIENT_RESOURCES
    STATUS_SUCCESS

--*/
{

    *ppStringWithNullTerminator = RtlAllocateHeap(RtlProcessHeap(),
                                                  0,
                                                  (UnicodeString->Length + sizeof(WCHAR))
                                                  );

    if (NULL == *ppStringWithNullTerminator)
    {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }


    RtlSecureZeroMemory(*ppStringWithNullTerminator, (UnicodeString->Length + sizeof(WCHAR)) );

    RtlCopyMemory(*ppStringWithNullTerminator,
                  UnicodeString->Buffer,
                  UnicodeString->Length
                  );

    return( STATUS_SUCCESS );
}


NTSTATUS
SampAddAccountsAndApplyMemberships(
    IN SAMPR_HANDLE AccountDomainHandle,
    IN SAMPR_HANDLE BuiltinDomainHandle,
    IN PSID         DomainSid,
    IN ULONG        PromoteFlags
    )
/*++
Routine Description:

    This routine is the worker routine to add well known accounts and apply
    well known membership. This routine is currently called under 3 different
    scenarios, and the tasks which we are going to perform are listed under
    each scenario.

    Case 1. binary upgrade

         1.1 DS Mode: PDC only (BDC upgrade will not call this function)

            Task performed:
                add well known accounts
                apply well known memberships
                add anonymous logon to pre-windows2000 compatible alias
                do necessary DS updates

         1.2 Registry Mode

            Task performed:
                add well known accounts
                apply well known memberships


    Case 2. DCPROMO time (first DC in domain) - DS only

         Task performed:
            add well known accounts
            apply well known memberships

    Case 3. PDC role transfer - DS only

         Task performed:
            add well known accounts
            apply well known memberships
            add anonymous logon to pre-windows2000 compatible alias
            do necessary DS updates
            
    Since this is a distributed environment, this update should only happen
    once.  To ensure this an operational guid is created once this work
    is done.  This is necessary since everytime the PDC role is transfered
    this task is triggered.  Most operations are object additions so are
    ok to repeat, but group membership changes should only be applied once.            

Parameters:

    AccountDomainHandle, a valid SAM domain handle

    BuiltinDomainHandle, a valid SAM domain handle

    DomainSid - Account Domain SID

    PromoteFlags - Flags

Return Values:

    STATUS_SUCCESS; a status from a SAM api call

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       RetryCount = 0;

    //
    // Only do this once in a distributed environment
    //
    if (SampUseDsData
     && SampWS03DefaultsApplied ) {

        return STATUS_SUCCESS;

    }


    RetryCount = 0;
    do
    {
        //
        // Add Well Known Accounts
        //
        NtStatus = SampAddWellKnownAccountsAndSecurityPrincipals(
                                            AccountDomainHandle,
                                            BuiltinDomainHandle,
                                            PromoteFlags
                                            );

        if (NT_SUCCESS(NtStatus))
        {
            //
            // Apply Well Known Memberships
            //
            NtStatus = SampApplyWellKnownMemberships(AccountDomainHandle,
                                                     BuiltinDomainHandle,
                                                     DomainSid,
                                                     PromoteFlags
                                                     );
        }


        if (NT_SUCCESS(NtStatus) &&
            SampUseDsData &&
            !FLAG_ON( PromoteFlags, SAMP_PROMOTE_DOMAIN )
            )
        {
            //
            // Add AnonymousLogon or AuthUsers to PreW2KCompAlias
            // 1. DS mode only.
            // 2. not for DCPROMO (it is for upgrade and PDC transfer only)
            // 

            NtStatus = SampAddAnonymousOrAuthUsersToPreW2KCompAlias(AccountDomainHandle,
                                                                    BuiltinDomainHandle
                                                                    );

            //
            // Call DS to do necessary update
            //

            if (NT_SUCCESS(NtStatus)) {
                DsUpdateOnPDC(PromoteFlags&SAMP_PROMOTE_ENTERPRISE);
            }

        }

        if ( NtStatus == STATUS_DS_BUSY )
        {
            ASSERT( !"SAMSS: DS is busy during account creation" );

            if ( RetryCount > 30 )
            {
                break;
            }

            Sleep( 1000 );
            RetryCount++;
        }

    } while ( NtStatus == STATUS_DS_BUSY );

    if (NT_SUCCESS(NtStatus)
        && SampUseDsData) {

        //
        // Create the operation guid indicate that this run once code
        // has completed
        //
        NtStatus = SampMarkChangeApplied(SAMP_WIN2K_TO_WS03_UPGRADE);
    }


    return( NtStatus );

}





NTSTATUS
SampDoAccountsUpgradeDuringPDCTransfer(
    IN PVOID Parameter
    )
/*++

Routine Description:

    This routine calls into SAM accounts / memberships upgrade routine
    SampAddAccountsAndApplyMemberships() to

    add well known accounts AND
    apply well known memberships

    This routine is called in DS mode only.

Parameter:

    Parameter - no use

Return Value:

    NtStatus Code

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    SAMPR_HANDLE    ServerHandle = 0;
    SAMPR_HANDLE    DomainHandle = 0;
    SAMPR_HANDLE    BuiltinDomainHandle = 0;
    PPOLICY_ACCOUNT_DOMAIN_INFO  DomainInfo = NULL;
    ULONG           DsRevision = 0;
    ULONG           PromoteFlags = SAMP_PROMOTE_INTERNAL_UPGRADE;


    ASSERT( SampUseDsData );

    if ( !SampUseDsData )
    {
        return( STATUS_SUCCESS );
    }


    //
    // Open the server
    //
    NtStatus = SampConnect(NULL,            // server name
                           &ServerHandle,
                           SAM_CLIENT_LATEST,
                           GENERIC_ALL,    // all access
                           TRUE,           // trusted client
                           FALSE,
                           FALSE,          // NotSharedByMultiThreads
                           TRUE
                           );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Get the current domain's sid
    //
    NtStatus = SampGetAccountDomainInfo(&DomainInfo);
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }
    ASSERT(DomainInfo);
    ASSERT(DomainInfo->DomainSid);

    //
    // Open the current domain
    //
    NtStatus = SamrOpenDomain(ServerHandle,
                              GENERIC_ALL,
                              DomainInfo->DomainSid,
                              &DomainHandle);
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Open the builtin domain
    //
    NtStatus = SamrOpenDomain(ServerHandle,
                              GENERIC_ALL,
                              SampBuiltinDomainSid,
                              &BuiltinDomainHandle);
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Find out if this machine is a DC in a root domain, then
    // set the Flags
    //

    if (SampDefinedDomains[DOMAIN_START_DS+1].IsForestRootDomain)
    {
        // add the following flag if it is forest root domain
        PromoteFlags |= SAMP_PROMOTE_ENTERPRISE;
    }


    //
    // call the worker routine
    // Add Well Known Accounts and Security principals
    // This function is called when server role is changed from BDC to PDC
    //
    //

    NtStatus = SampAddAccountsAndApplyMemberships(
                                DomainHandle,
                                BuiltinDomainHandle,
                                DomainInfo->DomainSid,
                                PromoteFlags
                                );

Cleanup:

    //
    // if failed, schedule another run
    //

    if (!NT_SUCCESS(NtStatus))
    {
        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                          0, // no category
                          SAMMSG_PDC_TASK_FAILURE,
                          NULL,
                          0,
                          sizeof(DWORD),
                          NULL,
                          &NtStatus
                          );


        LsaIRegisterNotification(
            SampDoAccountsUpgradeDuringPDCTransfer,
            (PVOID) NULL,   // no parameter
            NOTIFIER_TYPE_INTERVAL,
            0,              // no class
            NOTIFIER_FLAG_ONE_SHOT,
            60,             // wait one minute
            NULL            // no handle
            );
    }

    if (ServerHandle) {
        SamrCloseHandle(&ServerHandle);
    }

    if (DomainHandle) {
        SamrCloseHandle(&DomainHandle);
    }

    if (BuiltinDomainHandle) {
        SamrCloseHandle(&BuiltinDomainHandle);
    }

    if (DomainInfo) {
        LsaIFree_LSAPR_POLICY_INFORMATION (PolicyAccountDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION)DomainInfo);
    }


    return( NtStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\rng.h ===
//
// placeholder, does nothing.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\ntdsguid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       ntdsguid.c
//
//--------------------------------------------------------------------------


/*++
 File:    NTDSGUID.C
 Purpose: Contains the Schema Guids for the Attributes and Class
          Schema Objects in NTDS.
 Creator: Automatically generated on
 Date:    Wed Jun 26 10:50:14 2002

 ** This is a Generated File From Schema.INI **

--*/

#include <ntdspch.h>
#include <ntdsguid.h>

// 
// The List of GUID Controls used in DS
// 

const GUID GUID_CONTROL_DomainListAccounts     = {0xab721a50,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   
const GUID GUID_CONTROL_DomainLookup           = {0xab721a51,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   
const GUID GUID_CONTROL_DomainAdministerServer = {0xab721a52,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   
const GUID GUID_CONTROL_UserChangePassword     = {0xab721a53,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   
const GUID GUID_CONTROL_UserForceChangePassword = {0x299570,0x246d, 0x11d0,0xa7,0x68,0x00,0xaa,0x00,0x6e,0x05,0x29} ;   
const GUID GUID_CONTROL_SendAs                 = {0xab721a54,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   
const GUID GUID_CONTROL_SendTo                 = {0xab721a55,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   
const GUID GUID_CONTROL_ReceiveAs              = {0xab721a56,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b} ;   
const GUID GUID_CONTROL_ListGroupMembership    = {0x65be5d30,0x20cf,0x11d0,0xa7,0x68,0x00,0xaa,0x00,0x6e,0x05,0x29} ;   
const GUID GUID_CONTROL_DsInstallReplica       = {0x9923a32a,0x3607,0x11d2,0xb9,0xbe,0x00,0x00,0xf8,0x7a,0x36,0xb2} ;   
const GUID GUID_CONTROL_DsSamEnumEntireDomain  = {0x91d67418,0x0135,0x4acc,0x8d,0x79,0xc0,0x8e,0x85,0x7c,0xfb,0xec} ;   
const GUID GUID_CONTROL_UpdatePasswordNotRequiredBit = {0x280f369c,0x67c7,0x438e,0xae,0x98,0x1d,0x46,0xf3,0xc6,0xf5,0x41} ;   
const GUID GUID_CONTROL_UnexpirePassword       = {0xccc2dc7d,0xa6ad,0x4a7a,0x88,0x46,0xc0,0x4e,0x3c,0xc5,0x35,0x01} ;   
const GUID GUID_CONTROL_EnablePerUserReversiblyEncryptedTextPassword = {0x05c74c5e,0x4deb,0x43b4,0xbd,0x9f,0x86,0x66,0x4c,0x2a,0x7f,0xd5} ;   


// 
// The List of Property Set GUIDS used by SAM
// 

const GUID GUID_PS_DOMAIN_PASSWORD              = {0xc7407360,0x20bf,0x11d0,0xa7,0x68,0x00,0xaa,0x00,0x6e,0x05,0x29} ;   
const GUID GUID_PS_GENERAL_INFO                 = {0x59ba2f42,0x79a2,0x11d0,0x90,0x20,0x00,0xc0,0x4f,0xc2,0xd3,0xcf} ;   
const GUID GUID_PS_USER_ACCOUNT_RESTRICTIONS    = {0x4c164200,0x20c0,0x11d0,0xa7,0x68,0x00,0xaa,0x00,0x6e,0x05,0x29} ;   
const GUID GUID_PS_USER_LOGON                   = {0x5f202010,0x79a5,0x11d0,0x90,0x20,0x00,0xc0,0x4f,0xc2,0xd4,0xcf} ;   
const GUID GUID_PS_MEMBERSHIP                   = {0xbc0ac240,0x79a9,0x11d0,0x90,0x20,0x00,0xc0,0x4f,0xc2,0xd4,0xcf} ;   
const GUID GUID_PS_DOMAIN_OTHER_PARAMETERS      = {0xb8119fd0,0x04f6,0x4762,0xab,0x7a,0x49,0x86,0xc7,0x6b,0x3f,0x9a} ;   


// 
// The list of Property Set GUIDS used by LSA
// 

const GUID GUID_PS_PASSWORD_POLICY              = {0xa29b89fb,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   
const GUID GUID_PS_LOCKOUT_POLICY               = {0xa29b89fc,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   
const GUID GUID_PS_DOMAIN_CONFIGURATION         = {0xa29b89fd,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   
const GUID GUID_PS_DOMAIN_POLICY                = {0xa29b89fe,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   
const GUID GUID_PS_PRIVILEGES                   = {0xa29b89ff,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   
const GUID GUID_PS_ADMINISTRATIVE_ACCESS        = {0xa29b8a00,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   
const GUID GUID_PS_LOCAL_POLICY                 = {0xa29b8a01,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   
const GUID GUID_PS_AUDIT                        = {0xa29b8a02,0xc7e8,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   
const GUID GUID_PS_BUILTIN_LOCAL_GROUPS         = {0xa29b8a03,0xc738,0x11d0,0x9b,0xae,0x00,0xc0,0x4f,0xd9,0x2e,0xf5} ;   



//--------------------------------------
// ATTRIBUTE SCHEMA GUIDS
//--------------------------------------
const GUID GUID_A_ACCOUNT_EXPIRES                = {0xbf967915,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ACCOUNT_NAME_HISTORY           = {0x031952ec,0x3b72,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_AGGREGATE_TOKEN_RATE_PER_USER = {0x7f56127d,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_ALLOCABLE_RSVP_BANDWIDTH   = {0x7f561283,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_CACHE_TIMEOUT              = {0x1cb355a1,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_DIRECTION                  = {0x7f56127a,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_DSBM_DEADTIME              = {0x1cb355a0,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_DSBM_PRIORITY              = {0x1cb3559e,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_DSBM_REFRESH               = {0x1cb3559f,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_ENABLE_ACS_SERVICE         = {0x7f561287,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_ENABLE_RSVP_ACCOUNTING     = {0xf072230e,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_ENABLE_RSVP_MESSAGE_LOGGING = {0x7f561285,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_EVENT_LOG_LEVEL            = {0x7f561286,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_IDENTITY_NAME              = {0xdab029b6,0xddf7,0x11d1,0x90,0xa5,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_MAX_AGGREGATE_PEAK_RATE_PER_USER = {0xf072230c,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_MAX_DURATION_PER_FLOW      = {0x7f56127e,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_MAX_NO_OF_ACCOUNT_FILES    = {0xf0722310,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_MAX_NO_OF_LOG_FILES        = {0x1cb3559c,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_MAX_PEAK_BANDWIDTH         = {0x7f561284,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_MAX_PEAK_BANDWIDTH_PER_FLOW = {0x7f56127c,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_MAX_SIZE_OF_RSVP_ACCOUNT_FILE = {0xf0722311,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_MAX_SIZE_OF_RSVP_LOG_FILE  = {0x1cb3559d,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_MAX_TOKEN_BUCKET_PER_FLOW  = {0x81f6e0df,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_MAX_TOKEN_RATE_PER_FLOW    = {0x7f56127b,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_MAXIMUM_SDU_SIZE           = {0x87a2d8f9,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_MINIMUM_DELAY_VARIATION    = {0x9c65329b,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_MINIMUM_LATENCY            = {0x9517fefb,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_MINIMUM_POLICED_SIZE       = {0x8d0e7195,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_NON_RESERVED_MAX_SDU_SIZE  = {0xaec2cfe3,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_NON_RESERVED_MIN_POLICED_SIZE = {0xb6873917,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_NON_RESERVED_PEAK_RATE     = {0xa331a73f,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_NON_RESERVED_TOKEN_SIZE    = {0xa916d7c9,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ACS_NON_RESERVED_TX_LIMIT      = {0x1cb355a2,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_NON_RESERVED_TX_SIZE       = {0xf072230d,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_PERMISSION_BITS            = {0x7f561282,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_POLICY_NAME                = {0x1cb3559a,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_PRIORITY                   = {0x7f561281,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_RSVP_ACCOUNT_FILES_LOCATION = {0xf072230f,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_RSVP_LOG_FILES_LOCATION    = {0x1cb3559b,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_SERVICE_TYPE               = {0x7f56127f,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_TIME_OF_DAY                = {0x7f561279,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_TOTAL_NO_OF_FLOWS          = {0x7f561280,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ACS_SERVER_LIST                = {0x7cbd59a5,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_ADDITIONAL_INFORMATION         = {0x6d05fb41,0x246b,0x11d0,0xa9,0xc8,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_ADDITIONAL_TRUSTED_SERVICE_NAMES = {0x032160be,0x9824,0x11d1,0xae,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ADDRESS                        = {0xf0f8ff84,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_ADDRESS_BOOK_ROOTS             = {0xf70b6e48,0x06f4,0x11d2,0xaa,0x53,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_ADDRESS_ENTRY_DISPLAY_TABLE    = {0x5fd42461,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS = {0x5fd42462,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_ADDRESS_HOME                   = {0x16775781,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ADDRESS_SYNTAX                 = {0x5fd42463,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_ADDRESS_TYPE                   = {0x5fd42464,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_ADMIN_CONTEXT_MENU             = {0x553fd038,0xf32e,0x11d0,0xb0,0xbc,0x00,0xc0,0x4f,0xd8,0xdc,0xa6} ;
const GUID GUID_A_ADMIN_COUNT                    = {0xbf967918,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ADMIN_DESCRIPTION              = {0xbf967919,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ADMIN_DISPLAY_NAME             = {0xbf96791a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ADMIN_MULTISELECT_PROPERTY_PAGES = {0x18f9b67d,0x5ac6,0x4b3b,0x97,0xdb,0xd0,0xa4,0x06,0xaf,0xb7,0xba} ;
const GUID GUID_A_ADMIN_PROPERTY_PAGES           = {0x52458038,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ALLOWED_ATTRIBUTES             = {0x9a7ad940,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_ALLOWED_ATTRIBUTES_EFFECTIVE   = {0x9a7ad941,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_ALLOWED_CHILD_CLASSES          = {0x9a7ad942,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_ALLOWED_CHILD_CLASSES_EFFECTIVE = {0x9a7ad943,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_ALT_SECURITY_IDENTITIES        = {0x00fbf30c,0x91fe,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ANR                            = {0x45b01500,0xc419,0x11d1,0xbb,0xc9,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_APP_SCHEMA_VERSION             = {0x96a7dd65,0x9118,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_APPLICATION_NAME               = {0xdd712226,0x10e4,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_APPLIES_TO                     = {0x8297931d,0x86d3,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_ASSET_NUMBER                   = {0xba305f75,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_ASSISTANT                      = {0x0296c11c,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ASSOC_NT_ACCOUNT               = {0x398f63c0,0xca60,0x11d1,0xbb,0xd1,0x00,0x00,0xf8,0x1f,0x10,0xc0} ;
const GUID GUID_A_ASSOCIATEDDOMAIN               = {0x3320FC38,0xC379,0x4c17,0xA5,0x10,0x1B,0xDF,0x61,0x33,0xC5,0xDA} ;
const GUID GUID_A_ASSOCIATEDNAME                 = {0xF7FBFC45,0x85AB,0x42a4,0xA4,0x35,0x78,0x0E,0x62,0xF7,0x85,0x8B} ;
const GUID GUID_A_ATTRIBUTECERTIFICATEATTRIBUTE  = {0xFA4693BB,0x7BC2,0x4cb9,0x81,0xA8,0xC9,0x9C,0x43,0xB7,0x90,0x5E} ;
const GUID GUID_A_ATTRIBUTE_DISPLAY_NAMES        = {0xcb843f80,0x48d9,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ATTRIBUTE_ID                   = {0xbf967922,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ATTRIBUTE_SECURITY_GUID        = {0xbf967924,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ATTRIBUTE_SYNTAX               = {0xbf967925,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ATTRIBUTE_TYPES                = {0x9a7ad944,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_AUDIO                          = {0xD0E1D224,0xE1A0,0x42ce,0xA2,0xDA,0x79,0x3B,0xA5,0x24,0x4F,0x35} ;
const GUID GUID_A_AUDITING_POLICY                = {0x6da8a4fe,0x0e52,0x11d0,0xa2,0x86,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_AUTHENTICATION_OPTIONS         = {0xbf967928,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_AUTHORITY_REVOCATION_LIST      = {0x1677578d,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_AUXILIARY_CLASS                = {0xbf96792c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_BAD_PASSWORD_TIME              = {0xbf96792d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_BAD_PWD_COUNT                  = {0xbf96792e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_BIRTH_LOCATION                 = {0x1f0075f9,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_BRIDGEHEAD_SERVER_LIST_BL      = {0xd50c2cdb,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_BRIDGEHEAD_TRANSPORT_LIST      = {0xd50c2cda,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_BUILDINGNAME                   = {0xF87FA54B,0xB2C5,0x4fd7,0x88,0xC0,0xDA,0xCC,0xB2,0x1D,0x93,0xC5} ;
const GUID GUID_A_BUILTIN_CREATION_TIME          = {0xbf96792f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_BUILTIN_MODIFIED_COUNT         = {0xbf967930,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_BUSINESS_CATEGORY              = {0xbf967931,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_BYTES_PER_MINUTE               = {0xba305f76,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_CA_CERTIFICATE                 = {0xbf967932,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_CA_CERTIFICATE_DN              = {0x963d2740,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CA_CONNECT                     = {0x963d2735,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CA_USAGES                      = {0x963d2738,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CA_WEB_URL                     = {0x963d2736,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CAN_UPGRADE_SCRIPT             = {0xd9e18314,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CANONICAL_NAME                 = {0x9a7ad945,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_CARLICENSE                     = {0xD4159C92,0x957D,0x4a87,0x8A,0x67,0x8D,0x29,0x34,0xE0,0x16,0x49} ;
const GUID GUID_A_CATALOGS                       = {0x7bfdcb81,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CATEGORIES                     = {0x7bfdcb7e,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CATEGORY_ID                    = {0x7d6c0e94,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_CERTIFICATE_AUTHORITY_OBJECT   = {0x963d2732,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CERTIFICATE_REVOCATION_LIST    = {0x1677579f,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CERTIFICATE_TEMPLATES          = {0x2a39c5b1,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CLASS_DISPLAY_NAME             = {0x548e1c22,0xdea6,0x11d0,0xb0,0x10,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CODE_PAGE                      = {0xbf967938,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COM_CLASSID                    = {0xbf96793b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COM_CLSID                      = {0x281416d9,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COM_INTERFACEID                = {0xbf96793c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COM_OTHER_PROG_ID              = {0x281416dd,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COM_PROGID                     = {0xbf96793d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COM_TREAT_AS_CLASS_ID          = {0x281416db,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COM_TYPELIB_ID                 = {0x281416de,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COM_UNIQUE_LIBID               = {0x281416da,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COMMENT                        = {0xbf96793e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COMMON_NAME                    = {0xbf96793f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COMPANY                        = {0xf0f8ff88,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_CONTENT_INDEXING_ALLOWED       = {0xbf967943,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_CONTEXT_MENU                   = {0x4d8601ee,0xac85,0x11d0,0xaf,0xe3,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_CONTROL_ACCESS_RIGHTS          = {0x6da8a4fc,0x0e52,0x11d0,0xa2,0x86,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COST                           = {0xbf967944,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_COUNTRY_CODE                   = {0x5fd42471,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_COUNTRY_NAME                   = {0xbf967945,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_CREATE_DIALOG                  = {0x2b09958a,0x8931,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CREATE_TIME_STAMP              = {0x2df90d73,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_CREATE_WIZARD_EXT              = {0x2b09958b,0x8931,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CREATION_TIME                  = {0xbf967946,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_CREATION_WIZARD                = {0x4d8601ed,0xac85,0x11d0,0xaf,0xe3,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_CREATOR                        = {0x7bfdcb85,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CRL_OBJECT                     = {0x963d2737,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CRL_PARTITIONED_REVOCATION_LIST = {0x963d2731,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CROSS_CERTIFICATE_PAIR         = {0x167757b2,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CURR_MACHINE_ID                = {0x1f0075fe,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_CURRENT_LOCATION               = {0x1f0075fc,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_CURRENT_PARENT_CA              = {0x963d273f,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_CURRENT_VALUE                  = {0xbf967947,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DBCS_PWD                       = {0xbf96799c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DEFAULT_CLASS_STORE            = {0xbf967948,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DEFAULT_GROUP                  = {0x720bc4e2,0xa54a,0x11d0,0xaf,0xdf,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DEFAULT_HIDING_VALUE           = {0xb7b13116,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DEFAULT_LOCAL_POLICY_OBJECT    = {0xbf96799f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DEFAULT_OBJECT_CATEGORY        = {0x26d97367,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DEFAULT_PRIORITY               = {0x281416c8,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DEFAULT_SECURITY_DESCRIPTOR    = {0x807a6d30,0x1669,0x11d0,0xa0,0x64,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_DELTA_REVOCATION_LIST          = {0x167757b5,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DEPARTMENT                     = {0xbf96794f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DEPARTMENTNUMBER               = {0xBE9EF6EE,0xCBC7,0x4f22,0xB2,0x7B,0x96,0x96,0x7E,0x7E,0xE5,0x85} ;
const GUID GUID_A_DESCRIPTION                    = {0xbf967950,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DESKTOP_PROFILE                = {0xeea65906,0x8ac6,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DESTINATION_INDICATOR          = {0xbf967951,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DHCP_CLASSES                   = {0x963d2750,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_FLAGS                     = {0x963d2741,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_IDENTIFICATION            = {0x963d2742,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_MASK                      = {0x963d2747,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_MAXKEY                    = {0x963d2754,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_OBJ_DESCRIPTION           = {0x963d2744,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_OBJ_NAME                  = {0x963d2743,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_OPTIONS                   = {0x963d274f,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_PROPERTIES                = {0x963d2753,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_RANGES                    = {0x963d2748,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_RESERVATIONS              = {0x963d274a,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_SERVERS                   = {0x963d2745,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_SITES                     = {0x963d2749,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_STATE                     = {0x963d2752,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_SUBNETS                   = {0x963d2746,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_TYPE                      = {0x963d273b,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_UNIQUE_KEY                = {0x963d273a,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DHCP_UPDATE_TIME               = {0x963d2755,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DISPLAY_NAME                   = {0xbf967953,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DISPLAY_NAME_PRINTABLE         = {0xbf967954,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DIT_CONTENT_RULES              = {0x9a7ad946,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_DIVISION                       = {0xfe6136a0,0x2073,0x11d0,0xa9,0xc2,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_DMD_LOCATION                   = {0xf0f8ff8b,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_DMD_NAME                       = {0x167757b9,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DN_REFERENCE_UPDATE            = {0x2df90d86,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_DNS_ALLOW_DYNAMIC              = {0xe0fa1e65,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DNS_ALLOW_XFR                  = {0xe0fa1e66,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DNS_HOST_NAME                  = {0x72e39547,0x7b18,0x11d1,0xad,0xef,0x00,0xc0,0x4f,0xd8,0xd5,0xcd} ;
const GUID GUID_A_DNS_NOTIFY_SECONDARIES         = {0xe0fa1e68,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DNS_PROPERTY                   = {0x675a15fe,0x3b70,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_DNS_RECORD                     = {0xe0fa1e69,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DNS_ROOT                       = {0xbf967959,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DNS_SECURE_SECONDARIES         = {0xe0fa1e67,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DNS_TOMBSTONED                 = {0xd5eb2eb7,0xbe4e,0x463b,0xa2,0x14,0x63,0x4a,0x44,0xd7,0x39,0x2e} ;
const GUID GUID_A_DOCUMENTAUTHOR                 = {0xF18A8E19,0xAF5F,0x4478,0xB0,0x96,0x6F,0x35,0xC2,0x7E,0xB8,0x3F} ;
const GUID GUID_A_DOCUMENTIDENTIFIER             = {0x0B21CE82,0xFF63,0x46d9,0x90,0xFB,0xC8,0xB9,0xF2,0x4E,0x97,0xB9} ;
const GUID GUID_A_DOCUMENTLOCATION               = {0xB958B14E,0xAC6D,0x4ec4,0x88,0x92,0xBE,0x70,0xB6,0x9F,0x72,0x81} ;
const GUID GUID_A_DOCUMENTPUBLISHER              = {0x170F09D7,0xEB69,0x448a,0x9A,0x30,0xF1,0xAF,0xEC,0xFD,0x32,0xD7} ;
const GUID GUID_A_DOCUMENTTITLE                  = {0xDE265A9C,0xFF2C,0x47b9,0x91,0xDC,0x6E,0x6F,0xE2,0xC4,0x30,0x62} ;
const GUID GUID_A_DOCUMENTVERSION                = {0x94B3A8A9,0xD613,0x4cec,0x9A,0xAD,0x5F,0xBC,0xC1,0x04,0x6B,0x43} ;
const GUID GUID_A_DOMAIN_CERTIFICATE_AUTHORITIES = {0x7bfdcb7a,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DOMAIN_COMPONENT               = {0x19195a55,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DOMAIN_CROSS_REF               = {0xb000ea7b,0xa086,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DOMAIN_ID                      = {0x963d2734,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DOMAIN_IDENTIFIER              = {0x7f561278,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DOMAIN_POLICY_OBJECT           = {0xbf96795d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DOMAIN_POLICY_REFERENCE        = {0x80a67e2a,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DOMAIN_REPLICA                 = {0xbf96795e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DOMAIN_WIDE_POLICY             = {0x80a67e29,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DRINK                          = {0x1A1AA5B5,0x262E,0x4df6,0xAF,0x04,0x2C,0xF6,0xB0,0xD8,0x00,0x48} ;
const GUID GUID_A_DRIVER_NAME                    = {0x281416c5,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_DRIVER_VERSION                 = {0xba305f6e,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_DS_CORE_PROPAGATION_DATA       = {0xd167aa4b,0x8b08,0x11d2,0x99,0x39,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_DS_HEURISTICS                  = {0xf0f8ff86,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_DS_UI_ADMIN_MAXIMUM            = {0xee8d0ae0,0x6f91,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_DS_UI_ADMIN_NOTIFICATION       = {0xf6ea0a94,0x6f91,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_DS_UI_SHELL_MAXIMUM            = {0xfcca766a,0x6f91,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_DSA_SIGNATURE                  = {0x167757bc,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_DYNAMIC_LDAP_SERVER            = {0x52458021,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_E_MAIL_ADDRESSES               = {0xbf967961,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_EFSPOLICY                      = {0x8e4eb2ec,0x4712,0x11d0,0xa1,0xa0,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_EMPLOYEE_ID                    = {0xbf967962,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_EMPLOYEE_NUMBER                = {0xa8df73ef,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_EMPLOYEE_TYPE                  = {0xa8df73f0,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_ENABLED                        = {0xa8df73f2,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_ENABLED_CONNECTION             = {0xbf967963,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ENROLLMENT_PROVIDERS           = {0x2a39c5b3,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ENTRY_TTL                      = {0xd213decc,0xd81a,0x4384,0xaa,0xc2,0xdc,0xfc,0xfd,0x63,0x1c,0xf8} ;
const GUID GUID_A_EXTENDED_ATTRIBUTE_INFO        = {0x9a7ad947,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_EXTENDED_CHARS_ALLOWED         = {0xbf967966,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_EXTENDED_CLASS_INFO            = {0x9a7ad948,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_EXTENSION_NAME                 = {0xbf967972,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_EXTRA_COLUMNS                  = {0xd24e2846,0x1dd9,0x4bcf,0x99,0xd7,0xa6,0x22,0x7c,0xc8,0x6d,0xa7} ;
const GUID GUID_A_FACSIMILE_TELEPHONE_NUMBER     = {0xbf967974,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_FILE_EXT_PRIORITY              = {0xd9e18315,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FLAGS                          = {0xbf967976,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_FLAT_NAME                      = {0xb7b13117,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FORCE_LOGOFF                   = {0xbf967977,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_FOREIGN_IDENTIFIER             = {0x3e97891e,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_FRIENDLY_NAMES                 = {0x7bfdcb88,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FROM_ENTRY                     = {0x9a7ad949,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_FROM_SERVER                    = {0xbf967979,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_FRS_COMPUTER_REFERENCE         = {0x2a132578,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_COMPUTER_REFERENCE_BL      = {0x2a132579,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_CONTROL_DATA_CREATION      = {0x2a13257a,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_CONTROL_INBOUND_BACKLOG    = {0x2a13257b,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_CONTROL_OUTBOUND_BACKLOG   = {0x2a13257c,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_DIRECTORY_FILTER           = {0x1be8f171,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_FRS_DS_POLL                    = {0x1be8f177,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_FRS_EXTENSIONS                 = {0x52458020,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_FAULT_CONDITION            = {0x1be8f178,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_FRS_FILE_FILTER                = {0x1be8f170,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_FRS_FLAGS                      = {0x2a13257d,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_LEVEL_LIMIT                = {0x5245801e,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_MEMBER_REFERENCE           = {0x2a13257e,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_MEMBER_REFERENCE_BL        = {0x2a13257f,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_PARTNER_AUTH_LEVEL         = {0x2a132580,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_PRIMARY_MEMBER             = {0x2a132581,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_REPLICA_SET_GUID           = {0x5245801a,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_REPLICA_SET_TYPE           = {0x26d9736b,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_ROOT_PATH                  = {0x1be8f174,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_FRS_ROOT_SECURITY              = {0x5245801f,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_SERVICE_COMMAND            = {0xddac0cee,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_FRS_SERVICE_COMMAND_STATUS     = {0x2a132582,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_STAGING_PATH               = {0x1be8f175,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_FRS_TIME_LAST_COMMAND          = {0x2a132583,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_TIME_LAST_CONFIG_CHANGE    = {0x2a132584,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_UPDATE_TIMEOUT             = {0x1be8f172,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_FRS_VERSION                    = {0x2a132585,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_VERSION_GUID               = {0x26d9736c,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_FRS_WORKING_PATH               = {0x1be8f173,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_FSMO_ROLE_OWNER                = {0x66171887,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_GARBAGE_COLL_PERIOD            = {0x5fd424a1,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_GENERATED_CONNECTION           = {0xbf96797a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_GENERATION_QUALIFIER           = {0x16775804,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_GIVEN_NAME                     = {0xf0f8ff8e,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_GLOBAL_ADDRESS_LIST            = {0xf754c748,0x06f4,0x11d2,0xaa,0x53,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_GOVERNS_ID                     = {0xbf96797d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_GP_LINK                        = {0xf30e3bbe,0x9ff0,0x11d1,0xb6,0x03,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_GP_OPTIONS                     = {0xf30e3bbf,0x9ff0,0x11d1,0xb6,0x03,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_GPC_FILE_SYS_PATH              = {0xf30e3bc1,0x9ff0,0x11d1,0xb6,0x03,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_GPC_FUNCTIONALITY_VERSION      = {0xf30e3bc0,0x9ff0,0x11d1,0xb6,0x03,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_GPC_MACHINE_EXTENSION_NAMES    = {0x32ff8ecc,0x783f,0x11d2,0x99,0x16,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_GPC_USER_EXTENSION_NAMES       = {0x42a75fc6,0x783f,0x11d2,0x99,0x16,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_GPC_WQL_FILTER                 = {0x7bd4c7a6,0x1add,0x4436,0x8c,0x04,0x39,0x99,0xa8,0x80,0x15,0x4c} ;
const GUID GUID_A_GROUP_ATTRIBUTES               = {0xbf96797e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_GROUP_MEMBERSHIP_SAM           = {0xbf967980,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_GROUP_PRIORITY                 = {0xeea65905,0x8ac6,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_GROUP_TYPE                     = {0x9a9a021e,0x4a5b,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_GROUPS_TO_IGNORE               = {0xeea65904,0x8ac6,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_HAS_MASTER_NCS                 = {0xbf967982,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_HAS_PARTIAL_REPLICA_NCS        = {0xbf967981,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_HELP_DATA16                    = {0x5fd424a7,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_HELP_DATA32                    = {0x5fd424a8,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_HELP_FILE_NAME                 = {0x5fd424a9,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_HIDE_FROM_AB                   = {0xEC05B750,0xA977,0x4efe,0x8E,0x8D,0xBA,0x6C,0x1A,0x6E,0x33,0xA8} ;
const GUID GUID_A_HOME_DIRECTORY                 = {0xbf967985,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_HOME_DRIVE                     = {0xbf967986,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_HOUSEIDENTIFIER                = {0xA45398B7,0xC44A,0x4eb6,0x82,0xD3,0x13,0xC1,0x09,0x46,0xDB,0xFE} ;
const GUID GUID_A_HOST                           = {0x6043DF71,0xFA48,0x46cf,0xAB,0x7C,0xCB,0xD5,0x46,0x44,0xB2,0x2D} ;
const GUID GUID_A_ICON_PATH                      = {0xf0f8ff83,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_IMPLEMENTED_CATEGORIES         = {0x7d6c0e92,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_INDEXEDSCOPES                  = {0x7bfdcb87,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_INITIAL_AUTH_INCOMING          = {0x52458023,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_INITIAL_AUTH_OUTGOING          = {0x52458024,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_INITIALS                       = {0xf0f8ff90,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_INSTALL_UI_LEVEL               = {0x96a7dd64,0x9118,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_INSTANCE_TYPE                  = {0xbf96798c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_INTER_SITE_TOPOLOGY_FAILOVER   = {0xb7c69e60,0x2cc7,0x11d2,0x85,0x4e,0x00,0xa0,0xc9,0x83,0xf6,0x08} ;
const GUID GUID_A_INTER_SITE_TOPOLOGY_GENERATOR  = {0xb7c69e5e,0x2cc7,0x11d2,0x85,0x4e,0x00,0xa0,0xc9,0x83,0xf6,0x08} ;
const GUID GUID_A_INTER_SITE_TOPOLOGY_RENEW      = {0xb7c69e5f,0x2cc7,0x11d2,0x85,0x4e,0x00,0xa0,0xc9,0x83,0xf6,0x08} ;
const GUID GUID_A_INTERNATIONAL_ISDN_NUMBER      = {0xbf96798d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_INVOCATION_ID                  = {0xbf96798e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_IPSEC_DATA                     = {0xb40ff81f,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_DATA_TYPE                = {0xb40ff81e,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_FILTER_REFERENCE         = {0xb40ff823,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_ID                       = {0xb40ff81d,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_ISAKMP_REFERENCE         = {0xb40ff820,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_NAME                     = {0xb40ff81c,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_NEGOTIATION_POLICY_ACTION = {0x07383075,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_NEGOTIATION_POLICY_REFERENCE = {0xb40ff822,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_NEGOTIATION_POLICY_TYPE  = {0x07383074,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_NFA_REFERENCE            = {0xb40ff821,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_OWNERS_REFERENCE         = {0xb40ff824,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IPSEC_POLICY_REFERENCE         = {0xb7b13118,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IS_CRITICAL_SYSTEM_OBJECT      = {0x00fbf30d,0x91fe,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IS_DEFUNCT                     = {0x28630ebe,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IS_DELETED                     = {0xbf96798f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_IS_EPHEMERAL                   = {0xf4c453f0,0xc5f1,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_IS_MEMBER_OF_DL                = {0xbf967991,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_IS_MEMBER_OF_PARTIAL_ATTRIBUTE_SET = {0x19405b9d,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IS_PRIVILEGE_HOLDER            = {0x19405b9c,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_IS_SINGLE_VALUED               = {0xbf967992,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_JPEGPHOTO                      = {0xBAC80572,0x09C4,0x4fa9,0x9A,0xE6,0x76,0x28,0xD7,0xAD,0xBE,0x0E} ;
const GUID GUID_A_KEYWORDS                       = {0xbf967993,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_KNOWLEDGE_INFORMATION          = {0x1677581f,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_LABELEDURI                     = {0xC569BB46,0xC680,0x44bc,0xA2,0x73,0xE6,0xC2,0x27,0xD7,0x1B,0x45} ;
const GUID GUID_A_LAST_BACKUP_RESTORATION_TIME   = {0x1fbb0be8,0xba63,0x11d0,0xaf,0xef,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_LAST_CONTENT_INDEXED           = {0xbf967995,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LAST_KNOWN_PARENT              = {0x52ab8670,0x5709,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_LAST_LOGOFF                    = {0xbf967996,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LAST_LOGON                     = {0xbf967997,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LAST_LOGON_TIMESTAMP           = {0xc0e20a04,0x0e5a,0x4ff3,0x94,0x82,0x5e,0xfe,0xae,0xcd,0x70,0x60} ;
const GUID GUID_A_LAST_SET_TIME                  = {0xbf967998,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LAST_UPDATE_SEQUENCE           = {0x7d6c0e9c,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_LDAP_ADMIN_LIMITS              = {0x7359a352,0x90f7,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_LDAP_DISPLAY_NAME              = {0xbf96799a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LDAP_IPDENY_LIST               = {0x7359a353,0x90f7,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_LEGACY_EXCHANGE_DN             = {0x28630ebc,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_LINK_ID                        = {0xbf96799b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LINK_TRACK_SECRET              = {0x2ae80fe2,0x47b4,0x11d0,0xa1,0xa4,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_LM_PWD_HISTORY                 = {0xbf96799d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LOCAL_POLICY_FLAGS             = {0xbf96799e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LOCAL_POLICY_REFERENCE         = {0x80a67e4d,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_LOCALE_ID                      = {0xbf9679a1,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LOCALITY_NAME                  = {0xbf9679a2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LOCALIZED_DESCRIPTION          = {0xd9e18316,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_LOCALIZATION_DISPLAY_ID        = {0xa746f0d1,0x78d0,0x11d2,0x99,0x16,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_LOCATION                       = {0x09dcb79f,0x165f,0x11d0,0xa0,0x64,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_LOCK_OUT_OBSERVATION_WINDOW    = {0xbf9679a4,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LOCKOUT_DURATION               = {0xbf9679a5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LOCKOUT_THRESHOLD              = {0xbf9679a6,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LOCKOUT_TIME                   = {0x28630ebf,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_LOGO                           = {0xbf9679a9,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LOGON_COUNT                    = {0xbf9679aa,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LOGON_HOURS                    = {0xbf9679ab,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LOGON_WORKSTATION              = {0xbf9679ac,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LSA_CREATION_TIME              = {0xbf9679ad,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_LSA_MODIFIED_COUNT             = {0xbf9679ae,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MACHINE_ARCHITECTURE           = {0xbf9679af,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MACHINE_PASSWORD_CHANGE_INTERVAL = {0xc9b6358e,0xbb38,0x11d0,0xaf,0xef,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MACHINE_ROLE                   = {0xbf9679b2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MACHINE_WIDE_POLICY            = {0x80a67e4f,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_MANAGED_BY                     = {0x0296c120,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MANAGED_OBJECTS                = {0x0296c124,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MANAGER                        = {0xbf9679b5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MAPI_ID                        = {0xbf9679b7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MARSHALLED_INTERFACE           = {0xbf9679b9,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MASTERED_BY                    = {0xe48e64e0,0x12c9,0x11d3,0x91,0x02,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MAX_PWD_AGE                    = {0xbf9679bb,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MAX_RENEW_AGE                  = {0xbf9679bc,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MAX_STORAGE                    = {0xbf9679bd,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MAX_TICKET_AGE                 = {0xbf9679be,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MAY_CONTAIN                    = {0xbf9679bf,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MEETINGADVERTISESCOPE          = {0x11b6cc8b,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGAPPLICATION             = {0x11b6cc83,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGBANDWIDTH               = {0x11b6cc92,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGBLOB                    = {0x11b6cc93,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGCONTACTINFO             = {0x11b6cc87,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGDESCRIPTION             = {0x11b6cc7e,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGENDTIME                 = {0x11b6cc91,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGID                      = {0x11b6cc7c,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGIP                      = {0x11b6cc89,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGISENCRYPTED             = {0x11b6cc8e,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGKEYWORD                 = {0x11b6cc7f,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGLANGUAGE                = {0x11b6cc84,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGLOCATION                = {0x11b6cc80,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGMAXPARTICIPANTS         = {0x11b6cc85,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGNAME                    = {0x11b6cc7d,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGORIGINATOR              = {0x11b6cc86,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGOWNER                   = {0x11b6cc88,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGPROTOCOL                = {0x11b6cc81,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGRATING                  = {0x11b6cc8d,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGRECURRENCE              = {0x11b6cc8f,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGSCOPE                   = {0x11b6cc8a,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGSTARTTIME               = {0x11b6cc90,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGTYPE                    = {0x11b6cc82,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEETINGURL                     = {0x11b6cc8c,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MEMBER                         = {0xbf9679c0,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MHS_OR_ADDRESS                 = {0x0296c122,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MIN_PWD_AGE                    = {0xbf9679c2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MIN_PWD_LENGTH                 = {0xbf9679c3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MIN_TICKET_AGE                 = {0xbf9679c4,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MODIFIED_COUNT                 = {0xbf9679c5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MODIFIED_COUNT_AT_LAST_PROM    = {0xbf9679c6,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MODIFY_TIME_STAMP              = {0x9a7ad94a,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MONIKER                        = {0xbf9679c7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MONIKER_DISPLAY_NAME           = {0xbf9679c8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MOVE_TREE_STATE                = {0x1f2ac2c8,0x3b71,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MS_COM_DEFAULTPARTITIONLINK    = {0x998b10f7,0xaa1a,0x4364,0xb8,0x67,0x75,0x3d,0x19,0x7f,0xe6,0x70} ;
const GUID GUID_A_MS_COM_OBJECTID                = {0x430f678b,0x889f,0x41f2,0x98,0x43,0x20,0x3b,0x5a,0x65,0x57,0x2f} ;
const GUID GUID_A_MS_COM_PARTITIONLINK           = {0x09abac62,0x043f,0x4702,0xac,0x2b,0x6c,0xa1,0x5e,0xee,0x57,0x54} ;
const GUID GUID_A_MS_COM_PARTITIONSETLINK        = {0x67f121dc,0x7d02,0x4c7d,0x82,0xf5,0x9a,0xd4,0xc9,0x50,0xac,0x34} ;
const GUID GUID_A_MS_COM_USERLINK                = {0x9e6f3a4d,0x242c,0x4f37,0xb0,0x68,0x36,0xb5,0x7f,0x9f,0xc8,0x52} ;
const GUID GUID_A_MS_COM_USERPARTITIONSETLINK    = {0x8e940c8a,0xe477,0x4367,0xb0,0x8d,0xff,0x2f,0xf9,0x42,0xdc,0xd7} ;
const GUID GUID_A_MS_DRM_IDENTITY_CERTIFICATE    = {0xE85E1204,0x3434,0x41ad,0x9B,0x56,0xE2,0x90,0x12,0x28,0xFF,0xF0} ;
const GUID GUID_A_MS_DS_ADDITIONAL_DNS_HOST_NAME = {0x80863791,0xDBE9,0x4eb8,0x83,0x7E,0x7F,0x0A,0xB5,0x5D,0x9A,0xC7} ;
const GUID GUID_A_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME = {0x975571DF,0xA4D5,0x429a,0x9F,0x59,0xCD,0xC6,0x58,0x1D,0x91,0xE6} ;
const GUID GUID_A_MS_DS_ALL_USERS_TRUST_QUOTA    = {0xD3AA4A5C,0x4E03,0x4810,0x97,0xAA,0x2B,0x33,0x9E,0x7A,0x43,0x4B} ;
const GUID GUID_A_MS_DS_ALLOWED_DNS_SUFFIXES     = {0x8469441b,0x9ac4,0x4e45,0x82,0x05,0xbd,0x21,0x9d,0xbf,0x67,0x2d} ;
const GUID GUID_A_MS_DS_ALLOWED_TO_DELEGATE_TO   = {0x800D94D7,0xB7A1,0x42a1,0xB1,0x4D,0x7C,0xAE,0x14,0x23,0xD0,0x7F} ;
const GUID GUID_A_MS_DS_AUXILIARY_CLASSES        = {0xc4af1073,0xee50,0x4be0,0xb8,0xc0,0x89,0xa4,0x1f,0xe9,0x9a,0xbe} ;
const GUID GUID_A_MS_DS_APPROX_IMMED_SUBORDINATES = {0xe185d243,0xf6ce,0x4adb,0xb4,0x96,0xb0,0xc0,0x05,0xd7,0x82,0x3c} ;
const GUID GUID_A_MS_DS_AZ_APPLICATION_DATA      = {0x503FC3E8,0x1CC6,0x461a,0x99,0xA3,0x9E,0xEE,0x04,0xF4,0x02,0xA7} ;
const GUID GUID_A_MS_DS_AZ_APPLICATION_NAME      = {0xDB5B0728,0x6208,0x4876,0x83,0xB7,0x95,0xD3,0xE5,0x69,0x52,0x75} ;
const GUID GUID_A_MS_DS_AZ_APPLICATION_VERSION   = {0x7184A120,0x3AC4,0x47ae,0x84,0x8F,0xFE,0x0A,0xB2,0x07,0x84,0xD4} ;
const GUID GUID_A_MS_DS_AZ_BIZ_RULE              = {0x33D41EA8,0xC0C9,0x4c92,0x94,0x94,0xF1,0x04,0x87,0x84,0x13,0xFD} ;
const GUID GUID_A_MS_DS_AZ_BIZ_RULE_LANGUAGE     = {0x52994B56,0x0E6C,0x4e07,0xAA,0x5C,0xEF,0x9D,0x7F,0x5A,0x0E,0x25} ;
const GUID GUID_A_MS_DS_AZ_CLASS_ID              = {0x013A7277,0x5C2D,0x49ef,0xA7,0xDE,0xB7,0x65,0xB3,0x6A,0x3F,0x6F} ;
const GUID GUID_A_MS_DS_AZ_DOMAIN_TIMEOUT        = {0x6448F56A,0xCA70,0x4e2e,0xB0,0xAF,0xD2,0x0E,0x4C,0xE6,0x53,0xD0} ;
const GUID GUID_A_MS_DS_AZ_GENERATE_AUDITS       = {0xF90ABAB0,0x186C,0x4418,0xBB,0x85,0x88,0x44,0x7C,0x87,0x22,0x2A} ;
const GUID GUID_A_MS_DS_AZ_LAST_IMPORTED_BIZ_RULE_PATH = {0x665ACB5C,0xBB92,0x4dbc,0x8C,0x59,0xB3,0x63,0x8E,0xAB,0x09,0xB3} ;
const GUID GUID_A_MS_DS_AZ_LDAP_QUERY            = {0x5E53368B,0xFC94,0x45c8,0x9D,0x7D,0xDA,0xF3,0x1E,0xE7,0x11,0x2D} ;
const GUID GUID_A_MS_DS_AZ_MAJOR_VERSION         = {0xCFB9ADB7,0xC4B7,0x4059,0x95,0x68,0x1E,0xD9,0xDB,0x6B,0x72,0x48} ;
const GUID GUID_A_MS_DS_AZ_MINOR_VERSION         = {0xEE85ED93,0xB209,0x4788,0x81,0x65,0xE7,0x02,0xF5,0x1B,0xFB,0xF3} ;
const GUID GUID_A_MS_DS_AZ_OPERATION_ID          = {0xA5F3B553,0x5D76,0x4cbe,0xBA,0x3F,0x43,0x12,0x15,0x2C,0xAB,0x18} ;
const GUID GUID_A_MS_DS_AZ_SCOPE_NAME            = {0x515A6B06,0x2617,0x4173,0x80,0x99,0xD5,0x60,0x5D,0xF0,0x43,0xC6} ;
const GUID GUID_A_MS_DS_AZ_SCRIPT_ENGINE_CACHE_MAX = {0x2629F66A,0x1F95,0x4bf3,0xA2,0x96,0x8E,0x9D,0x7B,0x9E,0x30,0xC8} ;
const GUID GUID_A_MS_DS_AZ_SCRIPT_TIMEOUT        = {0x87D0FB41,0x2C8B,0x41f6,0xB9,0x72,0x11,0xFD,0xFD,0x50,0xD6,0xB0} ;
const GUID GUID_A_MS_DS_AZ_TASK_IS_ROLE_DEFINITION = {0x7B078544,0x6C82,0x4fe9,0x87,0x2F,0xFF,0x48,0xAD,0x2B,0x2E,0x26} ;
const GUID GUID_A_MS_DS_BEHAVIOR_VERSION         = {0xd31a8757,0x2447,0x4545,0x80,0x81,0x3b,0xb6,0x10,0xca,0xcb,0xf2} ;
const GUID GUID_A_MS_DS_BYTE_ARRAY               = {0xF0D8972E,0xDD5B,0x40e5,0xA5,0x1D,0x04,0x4C,0x7C,0x17,0xEC,0xE7} ;
const GUID GUID_A_MS_DS_CACHED_MEMBERSHIP        = {0x69cab008,0xcdd4,0x4bc9,0xba,0xb8,0x0f,0xf3,0x7e,0xfe,0x1b,0x20} ;
const GUID GUID_A_MS_DS_CACHED_MEMBERSHIP_TIME_STAMP = {0x3566bf1f,0xbeee,0x4dcb,0x8a,0xbe,0xef,0x89,0xfc,0xfe,0xc6,0xc1} ;
const GUID GUID_A_MS_DS_CONSISTENCY_GUID         = {0x23773dc2,0xb63a,0x11d2,0x90,0xe1,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MS_DS_CONSISTENCY_CHILD_COUNT  = {0x178b7bc2,0xb63a,0x11d2,0x90,0xe1,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MS_DS_CREATOR_SID              = {0xc5e60132,0x1480,0x11d3,0x91,0xc1,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_DS_DATE_TIME                = {0x234FCBD8,0xFB52,0x4908,0xA3,0x28,0xFD,0x9F,0x6E,0x58,0xE4,0x03} ;
const GUID GUID_A_MS_DS_DEFAULT_QUOTA            = {0x6818f726,0x674b,0x441b,0x8a,0x3a,0xf4,0x05,0x96,0x37,0x4c,0xea} ;
const GUID GUID_A_MS_DS_DNSROOTALIAS             = {0x2143ACCA,0xEEAD,0x4d29,0xB5,0x91,0x85,0xFA,0x49,0xCE,0x91,0x73} ;
const GUID GUID_A_MS_DS_ENTRY_TIME_TO_DIE        = {0xe1e9bad7,0xc6dd,0x4101,0xa8,0x43,0x79,0x4c,0xec,0x85,0xb0,0x38} ;
const GUID GUID_A_MS_DS_EXECUTESCRIPTPASSWORD    = {0x9D054A5A,0xD187,0x46c1,0x9D,0x85,0x42,0xDF,0xC4,0x4A,0x56,0xDD} ;
const GUID GUID_A_MS_DS_EXTERNAL_KEY             = {0xB92FD528,0x38AC,0x40d4,0x81,0x8D,0x04,0x33,0x38,0x08,0x37,0xC1} ;
const GUID GUID_A_MS_DS_EXTERNAL_STORE           = {0x604877CD,0x9CDB,0x47c7,0xB0,0x3D,0x3D,0xAA,0xDB,0x04,0x49,0x10} ;
const GUID GUID_A_MS_DS_FILTER_CONTAINERS        = {0xfb00dcdf,0xac37,0x483a,0x9c,0x12,0xac,0x53,0xa6,0x60,0x30,0x33} ;
const GUID GUID_A_MS_DS_HAS_INSTANTIATED_NCS     = {0x11e9a5bc,0x4517,0x4049,0xaf,0x9c,0x51,0x55,0x4f,0xb0,0xfc,0x09} ;
const GUID GUID_A_MS_DS_HAS_DOMAIN_NCS           = {0x6F17E347,0xA842,0x4498,0xB8,0xB3,0x15,0xE0,0x07,0xDA,0x4F,0xED} ;
const GUID GUID_A_MS_DS_HAS_MASTER_NCS           = {0xAE2DE0E2,0x59D7,0x4d47,0x8D,0x47,0xED,0x4D,0xFE,0x43,0x57,0xAD} ;
const GUID GUID_A_MS_DS_INTEGER                  = {0x7BC64CEA,0xC04E,0x4318,0xB1,0x02,0x3E,0x07,0x29,0x37,0x1A,0x65} ;
const GUID GUID_A_MS_DS_INTID                    = {0xBC60096A,0x1B47,0x4b30,0x88,0x77,0x60,0x2C,0x93,0xF5,0x65,0x32} ;
const GUID GUID_A_MS_DS_KEYVERSIONNUMBER         = {0xC523E9C0,0x33B5,0x4ac8,0x89,0x23,0xB5,0x7B,0x92,0x7F,0x42,0xF6} ;
const GUID GUID_A_MS_DS_LOGON_TIME_SYNC_INTERVAL = {0xAD7940F8,0xE43A,0x4a42,0x83,0xBC,0xD6,0x88,0xE5,0x9E,0xA6,0x05} ;
const GUID GUID_A_MS_DS_MASTERED_BY              = {0x60234769,0x4819,0x4615,0xA1,0xB2,0x49,0xD2,0xF1,0x19,0xAC,0xB5} ;
const GUID GUID_A_MS_DS_MAX_VALUES               = {0xD1E169A4,0xEBE9,0x49bf,0x8F,0xCB,0x8A,0xEF,0x38,0x74,0x59,0x2D} ;
const GUID GUID_A_MS_DS_MEMBERS_FOR_AZ_ROLE      = {0xCBF7E6CD,0x85A4,0x4314,0x89,0x39,0x8B,0xFE,0x80,0x59,0x78,0x35} ;
const GUID GUID_A_MS_DS_MEMBERS_FOR_AZ_ROLE_BL   = {0xECECCD20,0xA7E0,0x4688,0x9C,0xCF,0x02,0xEC,0xE5,0xE2,0x87,0xF5} ;
const GUID GUID_A_MS_DS_NON_MEMBERS              = {0xCAFCB1DE,0xF23C,0x46b5,0xAD,0xF7,0x1E,0x64,0x95,0x7B,0xD5,0xDB} ;
const GUID GUID_A_MS_DS_NON_MEMBERS_BL           = {0x2A8C68FC,0x3A7A,0x4e87,0x87,0x20,0xFE,0x77,0xC5,0x1C,0xBE,0x74} ;
const GUID GUID_A_MS_DS_TRUST_FOREST_TRUST_INFO  = {0x29cc866e,0x49d3,0x4969,0x94,0x2e,0x1d,0xbc,0x09,0x25,0xd1,0x83} ;
const GUID GUID_A_MS_DS_TOMBSTONE_QUOTA_FACTOR   = {0x461744d7,0xf3b6,0x45ba,0x87,0x53,0xfb,0x95,0x52,0xa5,0xdf,0x32} ;
const GUID GUID_A_MS_DS_TOP_QUOTA_USAGE          = {0x7b7cce4f,0xf1f5,0x4bb6,0xb7,0xeb,0x23,0x50,0x4a,0xf1,0x9e,0x75} ;
const GUID GUID_A_MS_DS_MACHINE_ACCOUNT_QUOTA    = {0xd064fb68,0x1480,0x11d3,0x91,0xc1,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_DS_OBJECT_REFERENCE         = {0x638EC2E8,0x22E7,0x409c,0x85,0xD2,0x11,0xB2,0x1B,0xEE,0x72,0xDE} ;
const GUID GUID_A_MS_DS_OBJECT_REFERENCE_BL      = {0x2B702515,0xC1F7,0x4b3b,0xB1,0x48,0xC0,0xE4,0xC6,0xCE,0xEC,0xB4} ;
const GUID GUID_A_MS_DS_OPERATIONS_FOR_AZ_ROLE   = {0x93F701BE,0xFA4C,0x43b6,0xBC,0x2F,0x4D,0xBE,0xA7,0x18,0xFF,0xAB} ;
const GUID GUID_A_MS_DS_OPERATIONS_FOR_AZ_ROLE_BL = {0xF85B6228,0x3734,0x4525,0xB6,0xB7,0x3F,0x3B,0xB2,0x20,0x90,0x2C} ;
const GUID GUID_A_MS_DS_OPERATIONS_FOR_AZ_TASK   = {0x1AACB436,0x2E9D,0x44a9,0x92,0x98,0xCE,0x4D,0xEB,0xEB,0x6E,0xBF} ;
const GUID GUID_A_MS_DS_OPERATIONS_FOR_AZ_TASK_BL = {0xA637D211,0x5739,0x4ed1,0x89,0xB2,0x88,0x97,0x45,0x48,0xBC,0x59} ;
const GUID GUID_A_MS_DS_OTHER_SETTINGS           = {0x79d2f34c,0x9d7d,0x42bb,0x83,0x8f,0x86,0x6b,0x3e,0x44,0x00,0xe2} ;
const GUID GUID_A_MS_DS_QUOTA_AMOUNT             = {0xfbb9a00d,0x3a8c,0x4233,0x9c,0xf9,0x71,0x89,0x26,0x49,0x03,0xa1} ;
const GUID GUID_A_MS_DS_QUOTA_EFFECTIVE          = {0x6655b152,0x101c,0x48b4,0xb3,0x47,0xe1,0xfc,0xeb,0xc6,0x01,0x57} ;
const GUID GUID_A_MS_DS_QUOTA_TRUSTEE            = {0x16378906,0x4ea5,0x49be,0xa8,0xd1,0xbf,0xd4,0x1d,0xff,0x4f,0x65} ;
const GUID GUID_A_MS_DS_QUOTA_USED               = {0xb5a84308,0x615d,0x4bb7,0xb0,0x5f,0x2f,0x17,0x46,0xaa,0x43,0x9f} ;
const GUID GUID_A_MS_DS_NC_REPL_CURSORS          = {0x8a167ce4,0xf9e8,0x47eb,0x8d,0x78,0xf7,0xfe,0x80,0xab,0xb2,0xcc} ;
const GUID GUID_A_MS_DS_NC_REPL_INBOUND_NEIGHBORS = {0x9edba85a,0x3e9e,0x431b,0x9b,0x1a,0xa5,0xb6,0xe9,0xed,0xa7,0x96} ;
const GUID GUID_A_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS = {0x855f2ef5,0xa1c5,0x4cc4,0xba,0x6d,0x32,0x52,0x28,0x48,0xb6,0x1f} ;
const GUID GUID_A_MS_DS_NC_REPLICA_LOCATIONS     = {0x97de9615,0xb537,0x46bc,0xac,0x0f,0x10,0x72,0x0f,0x39,0x09,0xf3} ;
const GUID GUID_A_MS_DS_NON_SECURITY_GROUP_EXTRA_CLASSES = {0x2de144fc,0x1f52,0x486f,0xbd,0xf4,0x16,0xfc,0xc3,0x08,0x4e,0x54} ;
const GUID GUID_A_MS_DS_PER_USER_TRUST_QUOTA     = {0xD161ADF0,0xCA24,0x4993,0xA3,0xAA,0x8B,0x2C,0x98,0x13,0x02,0xE8} ;
const GUID GUID_A_MS_DS_PER_USER_TRUST_TOMBSTONES_QUOTA = {0x8B70A6C6,0x50F9,0x4fa3,0xA7,0x1E,0x1C,0xE0,0x30,0x40,0x44,0x9B} ;
const GUID GUID_A_MS_DS_PREFERRED_GC_SITE        = {0xd921b50a,0x0ab2,0x42cd,0x87,0xf6,0x09,0xcf,0x83,0xa9,0x18,0x54} ;
const GUID GUID_A_MS_DS_REPL_ATTRIBUTE_META_DATA = {0xd7c53242,0x724e,0x4c39,0x9d,0x4c,0x2d,0xf8,0xc9,0xd6,0x6c,0x7a} ;
const GUID GUID_A_MS_DS_REPL_VALUE_META_DATA     = {0x2f5c8145,0xe1bd,0x410b,0x89,0x57,0x8b,0xfa,0x81,0xd5,0xac,0xfd} ;
const GUID GUID_A_MS_DS_REPLICATES_NC_REASON     = {0x0ea12b84,0x08b3,0x11d3,0x91,0xbc,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_DS_REPLICATION_NOTIFY_FIRST_DSA_DELAY = {0x85abd4f4,0x0a89,0x4e49,0xbd,0xec,0x6f,0x35,0xbb,0x25,0x62,0xba} ;
const GUID GUID_A_MS_DS_REPLICATION_NOTIFY_SUBSEQUENT_DSA_DELAY = {0xd63db385,0xdd92,0x4b52,0xb1,0xd8,0x0d,0x3e,0xcc,0x0e,0x86,0xb6} ;
const GUID GUID_A_MS_DS_REPLICATIONEPOCH         = {0x08E3AA79,0xEB1C,0x45b5,0xAF,0x7B,0x8F,0x94,0x24,0x6C,0x8E,0x41} ;
const GUID GUID_A_MS_DS_RETIRED_REPL_NC_SIGNATURES = {0xD5B35506,0x19D6,0x4d26,0x9A,0xFB,0x11,0x35,0x7A,0xC9,0x9B,0x5E} ;
const GUID GUID_A_MS_DS_SCHEMA_EXTENSIONS        = {0xb39a61be,0xed07,0x4cab,0x9a,0x4a,0x49,0x63,0xed,0x01,0x41,0xe1} ;
const GUID GUID_A_MS_DS_SD_REFERENCE_DOMAIN      = {0x4c51e316,0xf628,0x43a5,0xb0,0x6b,0xff,0xb6,0x95,0xfc,0xb4,0xf3} ;
const GUID GUID_A_MS_DS_SECURITY_GROUP_EXTRA_CLASSES = {0x4f146ae8,0xa4fe,0x4801,0xa7,0x31,0xf5,0x18,0x48,0xa4,0xf4,0xe4} ;
const GUID GUID_A_MS_DS_SETTINGS                 = {0x0e1b47d7,0x40a3,0x4b48,0x8d,0x1b,0x4c,0xac,0x0c,0x1c,0xdf,0x21} ;
const GUID GUID_A_MS_DS_SITE_AFFINITY            = {0xc17c5602,0xbcb7,0x46f0,0x96,0x56,0x63,0x70,0xca,0x88,0x4b,0x72} ;
const GUID GUID_A_MS_DS_SPN_SUFFIXES             = {0x789EE1EB,0x8C8E,0x4e4c,0x8C,0xEC,0x79,0xB3,0x1B,0x76,0x17,0xB5} ;
const GUID GUID_A_MS_DS_TASKS_FOR_AZ_ROLE        = {0x35319082,0x8C4A,0x4646,0x93,0x86,0xC2,0x94,0x9D,0x49,0x89,0x4D} ;
const GUID GUID_A_MS_DS_TASKS_FOR_AZ_ROLE_BL     = {0xA0DCD536,0x5158,0x42fe,0x8C,0x40,0xC0,0x0A,0x7A,0xD3,0x79,0x59} ;
const GUID GUID_A_MS_DS_TASKS_FOR_AZ_TASK        = {0xB11C8EE2,0x5FCD,0x46a7,0x95,0xF0,0xF3,0x83,0x33,0xF0,0x96,0xCF} ;
const GUID GUID_A_MS_DS_TASKS_FOR_AZ_TASK_BL     = {0xDF446E52,0xB5FA,0x4ca2,0xA4,0x2F,0x13,0xF9,0x8A,0x52,0x6C,0x8F} ;
const GUID GUID_A_MS_DS_USER_ACCOUNT_CONTROL_COMPUTED = {0x2cc4b836,0xb63f,0x4940,0x8d,0x23,0xea,0x7a,0xcf,0x06,0xaf,0x56} ;
const GUID GUID_A_MS_DS_UPDATESCRIPT             = {0x146EB639,0xBB9F,0x4fc1,0xA8,0x25,0xE2,0x9E,0x00,0xC7,0x79,0x20} ;
const GUID GUID_A_MS_EXCH_ASSISTANT_NAME         = {0xa8df7394,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MS_EXCH_HOUSE_IDENTIFIER       = {0xa8df7407,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MS_EXCH_LABELEDURI             = {0x16775820,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MS_EXCH_OWNER_BL               = {0xbf9679f4,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MS_FRS_HUB_MEMBER              = {0x5643ff81,0x35b6,0x4ca9,0x95,0x12,0xba,0xf0,0xbd,0x0a,0x27,0x72} ;
const GUID GUID_A_MS_FRS_TOPOLOGY_PREF           = {0x92aa27e0,0x5c50,0x402d,0x9e,0xc1,0xee,0x84,0x7d,0xef,0x97,0x88} ;
const GUID GUID_A_MS_IEEE_80211_DATA             = {0x0E0D0938,0x2658,0x4580,0xA9,0xF6,0x7A,0x0A,0xC7,0xB5,0x66,0xCB} ;
const GUID GUID_A_MS_IEEE_80211_DATA_TYPE        = {0x6558B180,0x35DA,0x4efe,0xBE,0xED,0x52,0x1F,0x8F,0x48,0xCA,0xFB} ;
const GUID GUID_A_MS_IEEE_80211_ID               = {0x7F73EF75,0x14C9,0x4c23,0x81,0xDE,0xDD,0x07,0xA0,0x6F,0x9E,0x8B} ;
const GUID GUID_A_MS_IIS_FTP_DIR                 = {0x8A5C99E9,0x2230,0x46eb,0xB8,0xE8,0xE5,0x9D,0x71,0x2E,0xB9,0xEE} ;
const GUID GUID_A_MS_IIS_FTP_ROOT                = {0x2A7827A4,0x1483,0x49a5,0x9D,0x84,0x52,0xE3,0x81,0x21,0x56,0xB4} ;
const GUID GUID_A_MS_PKI_CERT_TEMPLATE_OID       = {0x3164c36a,0xba26,0x468c,0x8b,0xda,0xc1,0xe5,0xcc,0x25,0x67,0x28} ;
const GUID GUID_A_MS_PKI_CERTIFICATE_APPLICATION_POLICY = {0xdbd90548,0xaa37,0x4202,0x99,0x66,0x8c,0x53,0x7b,0xa5,0xce,0x32} ;
const GUID GUID_A_MS_PKI_CERTIFICATE_NAME_FLAG   = {0xea1dddc4,0x60ff,0x416e,0x8c,0xc0,0x17,0xce,0xe5,0x34,0xbc,0xe7} ;
const GUID GUID_A_MS_PKI_CERTIFICATE_POLICY      = {0x38942346,0xcc5b,0x424b,0xa7,0xd8,0x6f,0xfd,0x12,0x02,0x9c,0x5f} ;
const GUID GUID_A_MS_PKI_ENROLLMENT_FLAG         = {0xd15ef7d8,0xf226,0x46db,0xae,0x79,0xb3,0x4e,0x56,0x0b,0xd1,0x2c} ;
const GUID GUID_A_MS_PKI_MINIMAL_KEY_SIZE        = {0xe96a63f5,0x417f,0x46d3,0xbe,0x52,0xdb,0x77,0x03,0xc5,0x03,0xdf} ;
const GUID GUID_A_MS_PKI_OID_ATTRIBUTE           = {0x8c9e1288,0x5028,0x4f4f,0xa7,0x04,0x76,0xd0,0x26,0xf2,0x46,0xef} ;
const GUID GUID_A_MS_PKI_OID_CPS                 = {0x5f49940e,0xa79f,0x4a51,0xbb,0x6f,0x3d,0x44,0x6a,0x54,0xdc,0x6b} ;
const GUID GUID_A_MS_PKI_OID_LOCALIZEDNAME       = {0x7d59a816,0xbb05,0x4a72,0x97,0x1f,0x5c,0x13,0x31,0xf6,0x75,0x59} ;
const GUID GUID_A_MS_PKI_OID_USER_NOTICE         = {0x04c4da7a,0xe114,0x4e69,0x88,0xde,0xe2,0x93,0xf2,0xd3,0xb3,0x95} ;
const GUID GUID_A_MS_PKI_PRIVATE_KEY_FLAG        = {0xbab04ac2,0x0435,0x4709,0x93,0x07,0x28,0x38,0x0e,0x7c,0x70,0x01} ;
const GUID GUID_A_MS_PKI_SUPERSEDE_TEMPLATES     = {0x9de8ae7d,0x7a5b,0x421d,0xb5,0xe4,0x06,0x1f,0x79,0xdf,0xd5,0xd7} ;
const GUID GUID_A_MS_PKI_TEMPLATE_MINOR_REVISION = {0x13f5236c,0x1884,0x46b1,0xb5,0xd0,0x48,0x4e,0x38,0x99,0x0d,0x58} ;
const GUID GUID_A_MS_PKI_TEMPLATE_SCHEMA_VERSION = {0x0c15e9f5,0x491d,0x4594,0x91,0x8f,0x32,0x81,0x3a,0x09,0x1d,0xa9} ;
const GUID GUID_A_MS_PKI_RA_APPLICATION_POLICIES = {0x3c91fbbf,0x4773,0x4ccd,0xa8,0x7b,0x85,0xd5,0x3e,0x7b,0xcf,0x6a} ;
const GUID GUID_A_MS_PKI_RA_POLICIES             = {0xd546ae22,0x0951,0x4d47,0x81,0x7e,0x1c,0x9f,0x96,0xfa,0xad,0x46} ;
const GUID GUID_A_MS_PKI_RA_SIGNATURE            = {0xfe17e04b,0x937d,0x4f7e,0x8e,0x0e,0x92,0x92,0xc8,0xd5,0x68,0x3e} ;
const GUID GUID_A_MS_RRAS_ATTRIBUTE              = {0xf39b98ad,0x938d,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MS_RRAS_VENDOR_ATTRIBUTE_ENTRY = {0xf39b98ac,0x938d,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MS_SQL_NAME                    = {0x3532dfd8,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_REGISTEREDOWNER         = {0x48fd44ea,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_CONTACT                 = {0x4f6cbdd8,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_LOCATION                = {0x561c9644,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_MEMORY                  = {0x5b5d448c,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_BUILD                   = {0x603e94c4,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_SERVICEACCOUNT          = {0x64933a3e,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_CHARACTERSET            = {0x696177a6,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_SORTORDER               = {0x6ddc42c0,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_UNICODESORTORDER        = {0x72dc918a,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_CLUSTERED               = {0x7778bd90,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_NAMEDPIPE               = {0x7b91c840,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_MULTIPROTOCOL           = {0x8157fa38,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_SPX                     = {0x86b08004,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_TCPIP                   = {0x8ac263a6,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_APPLETALK               = {0x8fda89f4,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_VINES                   = {0x94c56394,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_STATUS                  = {0x9a7d4770,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_LASTUPDATEDDATE         = {0x9fcc43d4,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_INFORMATIONURL          = {0xa42cd510,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_CONNECTIONURL           = {0xa92d23da,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_PUBLICATIONURL          = {0xae0c11b8,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_GPSLATITUDE             = {0xb222ba0e,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_GPSLONGITUDE            = {0xb7577c94,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_GPSHEIGHT               = {0xbcdd4f0e,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_VERSION                 = {0xc07cc1d0,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_LANGUAGE                = {0xc57f72f4,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_DESCRIPTION             = {0x8386603c,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_TYPE                    = {0xca48eba8,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_INFORMATIONDIRECTORY    = {0xd0aedb2e,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_DATABASE                = {0xd5a0dbdc,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_ALLOWANONYMOUSSUBSCRIPTION = {0xdb77be4a,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_ALIAS                   = {0xe0c6baae,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_SIZE                    = {0xe9098084,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_CREATIONDATE            = {0xede14754,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_LASTBACKUPDATE          = {0xf2b6abca,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_LASTDIAGNOSTICDATE      = {0xf6d6dd88,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_APPLICATIONS            = {0xfbcda2ea,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_KEYWORDS                = {0x01e9a98a,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_PUBLISHER               = {0xc1676858,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_ALLOWKNOWNPULLSUBSCRIPTION = {0xc3bb7054,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_ALLOWIMMEDIATEUPDATINGSUBSCRIPTION = {0xc4186b6e,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_ALLOWQUEUEDUPDATINGSUBSCRIPTION = {0xc458ca80,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_ALLOWSNAPSHOTFILESFTPDOWNLOADING = {0xc49b8be8,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_SQL_THIRDPARTY              = {0xc4e311fc,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_MS_TAPI_CONFERENCE_BLOB        = {0x4cc4601e,0x7201,0x4141,0xab,0xc8,0x3e,0x52,0x9a,0xe8,0x88,0x63} ;
const GUID GUID_A_MS_TAPI_IP_ADDRESS             = {0xefd7d7f7,0x178e,0x4767,0x87,0xfa,0xf8,0xa1,0x6b,0x84,0x05,0x44} ;
const GUID GUID_A_MS_TAPI_PROTOCOL_ID            = {0x89c1ebcf,0x7a5f,0x41fd,0x99,0xca,0xc9,0x00,0xb3,0x22,0x99,0xab} ;
const GUID GUID_A_MS_TAPI_UNIQUE_IDENTIFIER      = {0x70a4e7ea,0xb3b9,0x4643,0x89,0x18,0xe6,0xdd,0x24,0x71,0xbf,0xd4} ;
const GUID GUID_A_MS_WMI_AUTHOR                  = {0x6366c0c1,0x6972,0x4e66,0xb3,0xa5,0x1d,0x52,0xad,0x0c,0x05,0x47} ;
const GUID GUID_A_MS_WMI_CHANGEDATE              = {0xf9cdf7a0,0xec44,0x4937,0xa7,0x9b,0xcd,0x91,0x52,0x2b,0x3a,0xa8} ;
const GUID GUID_A_MS_WMI_CLASS                   = {0x90c1925f,0x4a24,0x4b07,0xb2,0x02,0xbe,0x32,0xeb,0x3c,0x8b,0x74} ;
const GUID GUID_A_MS_WMI_CLASSDEFINITION         = {0x2b9c0ebc,0xc272,0x45cb,0x99,0xd2,0x4d,0x0e,0x69,0x16,0x32,0xe0} ;
const GUID GUID_A_MS_WMI_CREATIONDATE            = {0x748b0a2e,0x3351,0x4b3f,0xb1,0x71,0x2f,0x17,0x41,0x4e,0xa7,0x79} ;
const GUID GUID_A_MS_WMI_GENUS                   = {0x50c8673a,0x8f56,0x4614,0x93,0x08,0x9e,0x13,0x40,0xfb,0x9a,0xf3} ;
const GUID GUID_A_MS_WMI_ID                      = {0x9339a803,0x94b8,0x47f7,0x91,0x23,0xa8,0x53,0xb9,0xff,0x7e,0x45} ;
const GUID GUID_A_MS_WMI_INTDEFAULT              = {0x1b0c07f8,0x76dd,0x4060,0xa1,0xe1,0x70,0x08,0x46,0x19,0xdc,0x90} ;
const GUID GUID_A_MS_WMI_INTFLAGS1               = {0x18e006b9,0x6445,0x48e3,0x9d,0xcf,0xb5,0xec,0xfb,0xc4,0xdf,0x8e} ;
const GUID GUID_A_MS_WMI_INTFLAGS2               = {0x075a42c9,0xc55a,0x45b1,0xac,0x93,0xeb,0x08,0x6b,0x31,0xf6,0x10} ;
const GUID GUID_A_MS_WMI_INTFLAGS3               = {0xf29fa736,0xde09,0x4be4,0xb2,0x3a,0xe7,0x34,0xc1,0x24,0xba,0xcc} ;
const GUID GUID_A_MS_WMI_INTFLAGS4               = {0xbd74a7ac,0xc493,0x4c9c,0xbd,0xfa,0x5c,0x7b,0x11,0x9c,0xa6,0xb2} ;
const GUID GUID_A_MS_WMI_INTMAX                  = {0xfb920c2c,0xf294,0x4426,0x8a,0xc1,0xd2,0x4b,0x42,0xaa,0x2b,0xce} ;
const GUID GUID_A_MS_WMI_INTMIN                  = {0x68c2e3ba,0x9837,0x4c70,0x98,0xe0,0xf0,0xc3,0x36,0x95,0xd0,0x23} ;
const GUID GUID_A_MS_WMI_INTVALIDVALUES          = {0x6af565f6,0xa749,0x4b72,0x96,0x34,0x3c,0x5d,0x47,0xe6,0xb4,0xe0} ;
const GUID GUID_A_MS_WMI_INT8DEFAULT             = {0xf4d8085a,0x8c5b,0x4785,0x95,0x9b,0xdc,0x58,0x55,0x66,0xe4,0x45} ;
const GUID GUID_A_MS_WMI_INT8MAX                 = {0xe3d8b547,0x003d,0x4946,0xa3,0x2b,0xdc,0x7c,0xed,0xc9,0x6b,0x74} ;
const GUID GUID_A_MS_WMI_INT8MIN                 = {0xed1489d1,0x54cc,0x4066,0xb3,0x68,0xa0,0x0d,0xaa,0x26,0x64,0xf1} ;
const GUID GUID_A_MS_WMI_INT8VALIDVALUES         = {0x103519a9,0xc002,0x441b,0x98,0x1a,0xb0,0xb3,0xe0,0x12,0xc8,0x03} ;
const GUID GUID_A_MS_WMI_MOF                     = {0x6736809f,0x2064,0x443e,0xa1,0x45,0x81,0x26,0x2b,0x1f,0x13,0x66} ;
const GUID GUID_A_MS_WMI_NAME                    = {0xc6c8ace5,0x7e81,0x42af,0xad,0x72,0x77,0x41,0x2c,0x59,0x41,0xc4} ;
const GUID GUID_A_MS_WMI_NORMALIZEDCLASS         = {0xeaba628f,0xeb8e,0x4fe9,0x83,0xfc,0x69,0x3b,0xe6,0x95,0x55,0x9b} ;
const GUID GUID_A_MS_WMI_PARM1                   = {0x27e81485,0xb1b0,0x4a8b,0xbe,0xdd,0xce,0x19,0xa8,0x37,0xe2,0x6e} ;
const GUID GUID_A_MS_WMI_PARM2                   = {0x0003508e,0x9c42,0x4a76,0xa8,0xf4,0x38,0xbf,0x64,0xba,0xb0,0xde} ;
const GUID GUID_A_MS_WMI_PARM3                   = {0x45958fb6,0x52bd,0x48ce,0x9f,0x9f,0xc2,0x71,0x2d,0x9f,0x2b,0xfc} ;
const GUID GUID_A_MS_WMI_PARM4                   = {0x3800d5a3,0xf1ce,0x4b82,0xa5,0x9a,0x15,0x28,0xea,0x79,0x5f,0x59} ;
const GUID GUID_A_MS_WMI_PROPERTYNAME            = {0xab920883,0xe7f8,0x4d72,0xb4,0xa0,0xc0,0x44,0x98,0x97,0x50,0x9d} ;
const GUID GUID_A_MS_WMI_QUERY                   = {0x65fff93e,0x35e3,0x45a3,0x85,0xae,0x87,0x6c,0x67,0x18,0x29,0x7f} ;
const GUID GUID_A_MS_WMI_QUERYLANGUAGE           = {0x7d3cfa98,0xc17b,0x4254,0x8b,0xd7,0x4d,0xe9,0xb9,0x32,0xa3,0x45} ;
const GUID GUID_A_MS_WMI_SCOPEGUID               = {0x87b78d51,0x405f,0x4b7f,0x80,0xed,0x2b,0xd2,0x87,0x86,0xf4,0x8d} ;
const GUID GUID_A_MS_WMI_SOURCEORGANIZATION      = {0x34f7ed6c,0x615d,0x418d,0xaa,0x00,0x54,0x9a,0x7d,0x7b,0xe0,0x3e} ;
const GUID GUID_A_MS_WMI_STRINGDEFAULT           = {0x152e42b6,0x37c5,0x4f55,0xab,0x48,0x16,0x06,0x38,0x4a,0x9a,0xea} ;
const GUID GUID_A_MS_WMI_STRINGVALIDVALUES       = {0x37609d31,0xa2bf,0x4b58,0x8f,0x53,0x2b,0x64,0xe5,0x7a,0x07,0x6d} ;
const GUID GUID_A_MS_WMI_TARGETCLASS             = {0x95b6d8d6,0xc9e8,0x4661,0xa2,0xbc,0x6a,0x5c,0xab,0xc0,0x4c,0x62} ;
const GUID GUID_A_MS_WMI_TARGETNAMESPACE         = {0x1c4ab61f,0x3420,0x44e5,0x84,0x9d,0x8b,0x5d,0xbf,0x60,0xfe,0xb7} ;
const GUID GUID_A_MS_WMI_TARGETOBJECT            = {0xc44f67a5,0x7de5,0x4a1f,0x92,0xd9,0x66,0x2b,0x57,0x36,0x4b,0x77} ;
const GUID GUID_A_MS_WMI_TARGETPATH              = {0x5006a79a,0x6bfe,0x4561,0x9f,0x52,0x13,0xcf,0x4d,0xd3,0xe5,0x60} ;
const GUID GUID_A_MS_WMI_TARGETTYPE              = {0xca2a281e,0x262b,0x4ff7,0xb4,0x19,0xbc,0x12,0x33,0x52,0xa4,0xe9} ;
const GUID GUID_A_MSCOPE_ID                      = {0x963d2751,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MSI_FILE_LIST                  = {0x7bfdcb7d,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MSI_SCRIPT                     = {0xd9e18313,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MSI_SCRIPT_NAME                = {0x96a7dd62,0x9118,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MSI_SCRIPT_PATH                = {0xbf967937,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_MSI_SCRIPT_SIZE                = {0x96a7dd63,0x9118,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_MSMQ_AUTHENTICATE              = {0x9a0dc326,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_BASE_PRIORITY             = {0x9a0dc323,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_COMPUTER_TYPE             = {0x9a0dc32e,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_COMPUTER_TYPE_EX          = {0x18120de8,0xf4c4,0x4341,0xbd,0x95,0x32,0xeb,0x5b,0xcf,0x7c,0x80} ;
const GUID GUID_A_MSMQ_COST                      = {0x9a0dc33a,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_CSP_NAME                  = {0x9a0dc334,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_DEPENDENT_CLIENT_SERVICE  = {0x2df90d83,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_MSMQ_DEPENDENT_CLIENT_SERVICES = {0x2df90d76,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_MSMQ_DIGESTS                   = {0x9a0dc33c,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_DIGESTS_MIG               = {0x0f71d8e0,0xda3b,0x11d1,0x90,0xa5,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_DS_SERVICE                = {0x2df90d82,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_MSMQ_DS_SERVICES               = {0x2df90d78,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_MSMQ_ENCRYPT_KEY               = {0x9a0dc331,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_FOREIGN                   = {0x9a0dc32f,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_IN_ROUTING_SERVERS        = {0x9a0dc32c,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_INTERVAL1                 = {0x8ea825aa,0x3b7b,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_INTERVAL2                 = {0x99b88f52,0x3b7b,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_JOURNAL                   = {0x9a0dc321,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_JOURNAL_QUOTA             = {0x9a0dc324,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_LABEL                     = {0x9a0dc325,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_LABEL_EX                  = {0x4580ad25,0xd407,0x48d2,0xad,0x24,0x43,0xe6,0xe5,0x67,0x93,0xd7} ;
const GUID GUID_A_MSMQ_LONG_LIVED                = {0x9a0dc335,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_MIGRATED                  = {0x9a0dc33f,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_MULTICAST_ADDRESS         = {0x1d2f4412,0xf10d,0x4337,0x9b,0x48,0x6e,0x5b,0x12,0x5c,0xd2,0x65} ;
const GUID GUID_A_MSMQ_NAME_STYLE                = {0x9a0dc333,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_NT4_FLAGS                 = {0xeb38a158,0xd57f,0x11d1,0x90,0xa2,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_NT4_STUB                  = {0x6f914be6,0xd57e,0x11d1,0x90,0xa2,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_OS_TYPE                   = {0x9a0dc330,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_OUT_ROUTING_SERVERS       = {0x9a0dc32b,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_OWNER_ID                  = {0x9a0dc328,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_PREV_SITE_GATES           = {0x2df90d75,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_MSMQ_PRIVACY_LEVEL             = {0x9a0dc327,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_QM_ID                     = {0x9a0dc33e,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_QUEUE_JOURNAL_QUOTA       = {0x8e441266,0xd57f,0x11d1,0x90,0xa2,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_QUEUE_NAME_EXT            = {0x2df90d87,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_MSMQ_QUEUE_QUOTA               = {0x3f6b8e12,0xd57f,0x11d1,0x90,0xa2,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_QUEUE_TYPE                = {0x9a0dc320,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_QUOTA                     = {0x9a0dc322,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_RECIPIENT_FORMATNAME      = {0x3bfe6748,0xb544,0x485a,0xb0,0x67,0x1b,0x31,0x0c,0x43,0x34,0xbf} ;
const GUID GUID_A_MSMQ_ROUTING_SERVICE           = {0x2df90d81,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_MSMQ_ROUTING_SERVICES          = {0x2df90d77,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_MSMQ_SECURED_SOURCE            = {0x8bf0221b,0x7a06,0x4d63,0x91,0xf0,0x14,0x99,0x94,0x18,0x13,0xd3} ;
const GUID GUID_A_MSMQ_SERVICE_TYPE              = {0x9a0dc32d,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_SERVICES                  = {0x9a0dc33d,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_SIGN_CERTIFICATES         = {0x9a0dc33b,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_SIGN_CERTIFICATES_MIG     = {0x3881b8ea,0xda3b,0x11d1,0x90,0xa5,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_SIGN_KEY                  = {0x9a0dc332,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_SITE_1                    = {0x9a0dc337,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_SITE_2                    = {0x9a0dc338,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_SITE_FOREIGN              = {0xfd129d8a,0xd57e,0x11d1,0x90,0xa2,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_SITE_GATES                = {0x9a0dc339,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_SITE_GATES_MIG            = {0xe2704852,0x3b7b,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_SITE_ID                   = {0x9a0dc340,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_SITE_NAME                 = {0xffadb4b2,0xde39,0x11d1,0x90,0xa5,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_SITE_NAME_EX              = {0x422144fa,0xc17f,0x4649,0x94,0xd6,0x97,0x31,0xed,0x27,0x84,0xed} ;
const GUID GUID_A_MSMQ_SITES                     = {0x9a0dc32a,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_TRANSACTIONAL             = {0x9a0dc329,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSMQ_USER_SID                  = {0xc58aae32,0x56f9,0x11d2,0x90,0xd0,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_MSMQ_VERSION                   = {0x9a0dc336,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSNPALLOWDIALIN                = {0xdb0c9085,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSNPCALLEDSTATIONID            = {0xdb0c9089,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSNPCALLINGSTATIONID           = {0xdb0c908a,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSNPSAVEDCALLINGSTATIONID      = {0xdb0c908e,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSRADIUSCALLBACKNUMBER         = {0xdb0c909c,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSRADIUSFRAMEDIPADDRESS        = {0xdb0c90a4,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSRADIUSFRAMEDROUTE            = {0xdb0c90a9,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSRADIUSSERVICETYPE            = {0xdb0c90b6,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSRASSAVEDCALLBACKNUMBER       = {0xdb0c90c5,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSRASSAVEDFRAMEDIPADDRESS      = {0xdb0c90c6,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MSRASSAVEDFRAMEDROUTE          = {0xdb0c90c7,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_MUST_CONTAIN                   = {0xbf9679d3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_NAME_SERVICE_FLAGS             = {0x80212840,0x4bdc,0x11d1,0xa9,0xc4,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NC_NAME                        = {0xbf9679d6,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_NETBIOS_NAME                   = {0xbf9679d8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_NETBOOT_ALLOW_NEW_CLIENTS      = {0x07383076,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_ANSWER_ONLY_VALID_CLIENTS = {0x0738307b,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_ANSWER_REQUESTS        = {0x0738307a,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_CURRENT_CLIENT_COUNT   = {0x07383079,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_GUID                   = {0x3e978921,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_NETBOOT_INITIALIZATION         = {0x3e978920,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_NETBOOT_INTELLIMIRROR_OSES     = {0x0738307e,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_LIMIT_CLIENTS          = {0x07383077,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_LOCALLY_INSTALLED_OSES = {0x07383080,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_MACHINE_FILE_PATH      = {0x3e978923,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_NETBOOT_MAX_CLIENTS            = {0x07383078,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_MIRROR_DATA_FILE       = {0x2df90d85,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_NETBOOT_NEW_MACHINE_NAMING_POLICY = {0x0738307c,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_NEW_MACHINE_OU         = {0x0738307d,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_SCP_BL                 = {0x07383082,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_SERVER                 = {0x07383081,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETBOOT_SIF_FILE               = {0x2df90d84,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_NETBOOT_TOOLS                  = {0x0738307f,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NETWORK_ADDRESS                = {0xbf9679d9,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_NEXT_LEVEL_STORE               = {0xbf9679da,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_NEXT_RID                       = {0xbf9679db,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_NON_SECURITY_MEMBER            = {0x52458018,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NON_SECURITY_MEMBER_BL         = {0x52458019,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_NOTIFICATION_LIST              = {0x19195a56,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_NT_GROUP_MEMBERS               = {0xbf9679df,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_NT_MIXED_DOMAIN                = {0x3e97891f,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_NT_PWD_HISTORY                 = {0xbf9679e2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_NT_SECURITY_DESCRIPTOR         = {0xbf9679e3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OBJ_DIST_NAME                  = {0xbf9679e4,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OBJECT_CATEGORY                = {0x26d97369,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_OBJECT_CLASS                   = {0xbf9679e5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OBJECT_CLASS_CATEGORY          = {0xbf9679e6,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OBJECT_CLASSES                 = {0x9a7ad94b,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_OBJECT_COUNT                   = {0x34aaa216,0xb699,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_OBJECT_GUID                    = {0xbf9679e7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OBJECT_SID                     = {0xbf9679e8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OBJECT_VERSION                 = {0x16775848,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_OEM_INFORMATION                = {0xbf9679ea,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OM_OBJECT_CLASS                = {0xbf9679ec,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OM_SYNTAX                      = {0xbf9679ed,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OMT_GUID                       = {0xddac0cf3,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_OMT_INDX_GUID                  = {0x1f0075fa,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_OPERATING_SYSTEM               = {0x3e978925,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_OPERATING_SYSTEM_HOTFIX        = {0xbd951b3c,0x9c96,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_OPERATING_SYSTEM_SERVICE_PACK  = {0x3e978927,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_OPERATING_SYSTEM_VERSION       = {0x3e978926,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_OPERATOR_COUNT                 = {0xbf9679ee,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OPTION_DESCRIPTION             = {0x963d274d,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_OPTIONS                        = {0x19195a53,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_OPTIONS_LOCATION               = {0x963d274e,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_ORGANIZATION_NAME              = {0xbf9679ef,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ORGANIZATIONAL_UNIT_NAME       = {0xbf9679f0,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_ORGANIZATIONALSTATUS           = {0x28596019,0x7349,0x4d2f,0xAD,0xFF,0x5A,0x62,0x99,0x61,0xF9,0x42} ;
const GUID GUID_A_ORIGINAL_DISPLAY_TABLE         = {0x5fd424ce,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_ORIGINAL_DISPLAY_TABLE_MSDOS   = {0x5fd424cf,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_OTHER_LOGIN_WORKSTATIONS       = {0xbf9679f1,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OTHER_MAILBOX                  = {0x0296c123,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_OTHER_NAME                     = {0xbf9679f2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_OTHER_WELL_KNOWN_OBJECTS       = {0x1ea64e5d,0xac0f,0x11d2,0x90,0xdf,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_OWNER                          = {0xbf9679f3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PACKAGE_FLAGS                  = {0x7d6c0e99,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PACKAGE_NAME                   = {0x7d6c0e98,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PACKAGE_TYPE                   = {0x7d6c0e96,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PARENT_CA                      = {0x5245801b,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PARENT_CA_CERTIFICATE_CHAIN    = {0x963d2733,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PARENT_GUID                    = {0x2df90d74,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a} ;
const GUID GUID_A_PARTIAL_ATTRIBUTE_DELETION_LIST = {0x28630ec0,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PARTIAL_ATTRIBUTE_SET          = {0x19405b9e,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PEK_KEY_CHANGE_INTERVAL        = {0x07383084,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PEK_LIST                       = {0x07383083,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PENDING_CA_CERTIFICATES        = {0x963d273c,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PENDING_PARENT_CA              = {0x963d273e,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PER_MSG_DIALOG_DISPLAY_TABLE   = {0x5fd424d3,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PER_RECIP_DIALOG_DISPLAY_TABLE = {0x5fd424d4,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PERSONAL_TITLE                 = {0x16775858,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PHONE_FAX_OTHER                = {0x0296c11d,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PHONE_HOME_OTHER               = {0xf0f8ffa2,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PHONE_HOME_PRIMARY             = {0xf0f8ffa1,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PHONE_IP_OTHER                 = {0x4d146e4b,0x48d4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PHONE_IP_PRIMARY               = {0x4d146e4a,0x48d4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PHONE_ISDN_PRIMARY             = {0x0296c11f,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PHONE_MOBILE_OTHER             = {0x0296c11e,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PHONE_MOBILE_PRIMARY           = {0xf0f8ffa3,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PHONE_OFFICE_OTHER             = {0xf0f8ffa5,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PHONE_PAGER_OTHER              = {0xf0f8ffa4,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PHONE_PAGER_PRIMARY            = {0xf0f8ffa6,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PHOTO                          = {0x9C979768,0xBA1A,0x4c08,0x96,0x32,0xC6,0xA5,0xC1,0xED,0x64,0x9A} ;
const GUID GUID_A_PHYSICAL_DELIVERY_OFFICE_NAME  = {0xbf9679f7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PHYSICAL_LOCATION_OBJECT       = {0xb7b13119,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PICTURE                        = {0x8d3bca50,0x1d7e,0x11d0,0xa0,0x81,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PKI_CRITICAL_EXTENSIONS        = {0xfc5a9106,0x3b9d,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_PKI_DEFAULT_CSPS               = {0x1ef6336e,0x3b9e,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_PKI_DEFAULT_KEY_SPEC           = {0x426cae6e,0x3b9d,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_PKI_ENROLLMENT_ACCESS          = {0x926be278,0x56f9,0x11d2,0x90,0xd0,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_PKI_EXPIRATION_PERIOD          = {0x041570d2,0x3b9e,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_PKI_EXTENDED_KEY_USAGE         = {0x18976af6,0x3b9e,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_PKI_KEY_USAGE                  = {0xe9b0a87e,0x3b9d,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_PKI_MAX_ISSUING_DEPTH          = {0xf0bfdefa,0x3b9d,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_PKI_OVERLAP_PERIOD             = {0x1219a3ec,0x3b9e,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_PKT                            = {0x8447f9f1,0x1027,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PKT_GUID                       = {0x8447f9f0,0x1027,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_POLICY_REPLICATION_FLAGS       = {0x19405b96,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PORT_NAME                      = {0x281416c4,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_POSS_SUPERIORS                 = {0xbf9679fa,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_POSSIBLE_INFERIORS             = {0x9a7ad94c,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_POST_OFFICE_BOX                = {0xbf9679fb,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_POSTAL_ADDRESS                 = {0xbf9679fc,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_POSTAL_CODE                    = {0xbf9679fd,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PREFERRED_DELIVERY_METHOD      = {0xbf9679fe,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PREFERREDLANGUAGE              = {0x856BE0D0,0x18E7,0x46e1,0x8F,0x5F,0x7E,0xE4,0xD9,0x02,0x0E,0x0D} ;
const GUID GUID_A_PREFERRED_OU                   = {0xbf9679ff,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PREFIX_MAP                     = {0x52458022,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PRESENTATION_ADDRESS           = {0xa8df744b,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_PREVIOUS_CA_CERTIFICATES       = {0x963d2739,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PREVIOUS_PARENT_CA             = {0x963d273d,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PRIMARY_GROUP_ID               = {0xbf967a00,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRIMARY_GROUP_TOKEN            = {0xc0ed8738,0x7efd,0x4481,0x84,0xd9,0x66,0xd2,0xdb,0x8b,0xe3,0x69} ;
const GUID GUID_A_PRINT_ATTRIBUTES               = {0x281416d7,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_BIN_NAMES                = {0x281416cd,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_COLLATE                  = {0x281416d2,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_COLOR                    = {0x281416d3,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_DUPLEX_SUPPORTED         = {0x281416cc,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_END_TIME                 = {0x281416ca,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_FORM_NAME                = {0x281416cb,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_KEEP_PRINTED_JOBS        = {0xba305f6d,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_LANGUAGE                 = {0x281416d6,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_MAC_ADDRESS              = {0xba305f7a,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_MAX_COPIES               = {0x281416d1,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_MAX_RESOLUTION_SUPPORTED = {0x281416cf,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_MAX_X_EXTENT             = {0xba305f6f,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_MAX_Y_EXTENT             = {0xba305f70,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_MEDIA_READY              = {0x3bcbfcf5,0x4d3d,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_MEDIA_SUPPORTED          = {0x244b296f,0x5abd,0x11d0,0xaf,0xd2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_MEMORY                   = {0xba305f74,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_MIN_X_EXTENT             = {0xba305f71,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_MIN_Y_EXTENT             = {0xba305f72,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_NETWORK_ADDRESS          = {0xba305f79,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_NOTIFY                   = {0xba305f6a,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_NUMBER_UP                = {0x3bcbfcf4,0x4d3d,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_ORIENTATIONS_SUPPORTED   = {0x281416d0,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_OWNER                    = {0xba305f69,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_PAGES_PER_MINUTE         = {0x19405b97,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PRINT_RATE                     = {0xba305f77,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_RATE_UNIT                = {0xba305f78,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_SEPARATOR_FILE           = {0x281416c6,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_SHARE_NAME               = {0xba305f68,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_SPOOLING                 = {0xba305f6c,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_STAPLING_SUPPORTED       = {0xba305f73,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINT_START_TIME               = {0x281416c9,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRINT_STATUS                   = {0xba305f6b,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRINTER_NAME                   = {0x244b296e,0x5abd,0x11d0,0xaf,0xd2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PRIOR_SET_TIME                 = {0xbf967a01,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRIOR_VALUE                    = {0xbf967a02,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRIORITY                       = {0x281416c7,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRIVATE_KEY                    = {0xbf967a03,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PRIVILEGE_ATTRIBUTES           = {0x19405b9a,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PRIVILEGE_DISPLAY_NAME         = {0x19405b98,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PRIVILEGE_HOLDER               = {0x19405b9b,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PRIVILEGE_VALUE                = {0x19405b99,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PRODUCT_CODE                   = {0xd9e18317,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PROFILE_PATH                   = {0xbf967a05,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PROXIED_OBJECT_NAME            = {0xe1aea402,0xcd5b,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PROXY_ADDRESSES                = {0xbf967a06,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PROXY_GENERATION_ENABLED       = {0x5fd424d6,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_PROXY_LIFETIME                 = {0xbf967a07,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PUBLIC_KEY_POLICY              = {0x80a67e28,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_PURPORTED_SEARCH               = {0xb4b54e50,0x943a,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_PWD_HISTORY_LENGTH             = {0xbf967a09,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PWD_LAST_SET                   = {0xbf967a0a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_PWD_PROPERTIES                 = {0xbf967a0b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_QUALITY_OF_SERVICE             = {0x80a67e4e,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_QUERY_FILTER                   = {0xcbf70a26,0x7e78,0x11d2,0x99,0x21,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_QUERY_POLICY_BL                = {0xe1aea404,0xcd5b,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_QUERY_POLICY_OBJECT            = {0xe1aea403,0xcd5b,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_QUERYPOINT                     = {0x7bfdcb86,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_RANGE_LOWER                    = {0xbf967a0c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_RANGE_UPPER                    = {0xbf967a0d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_RDN                            = {0xbf967a0e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_RDN_ATT_ID                     = {0xbf967a0f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REGISTERED_ADDRESS             = {0xbf967a10,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REMOTE_SERVER_NAME             = {0xbf967a12,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REMOTE_SOURCE                  = {0xbf967a14,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REMOTE_SOURCE_TYPE             = {0xbf967a15,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REMOTE_STORAGE_GUID            = {0x2a39c5b0,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_REPL_PROPERTY_META_DATA        = {0x281416c0,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REPL_TOPOLOGY_STAY_OF_EXECUTION = {0x7bfdcb83,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_REPL_UPTODATE_VECTOR           = {0xbf967a16,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REPLICA_SOURCE                 = {0xbf967a18,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REPORTS                        = {0xbf967a1c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REPL_INTERVAL                  = {0x45ba9d1a,0x56fa,0x11d2,0x90,0xd0,0x00,0xc0,0x4f,0xd9,0x1a,0xb1} ;
const GUID GUID_A_REPS_FROM                      = {0xbf967a1d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REPS_TO                        = {0xbf967a1e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_REQUIRED_CATEGORIES            = {0x7d6c0e93,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_RETIRED_REPL_DSA_SIGNATURES    = {0x7bfdcb7f,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_TOKEN_GROUPS                   = {0xb7c69e6d,0x2cc7,0x11d2,0x85,0x4e,0x00,0xa0,0xc9,0x83,0xf6,0x08} ;
const GUID GUID_A_TOKEN_GROUPS_GLOBAL_AND_UNIVERSAL = {0x46a9b11d,0x60ae,0x405a,0xb7,0xe8,0xff,0x8a,0x58,0xd4,0x56,0xd2} ;
const GUID GUID_A_TOKEN_GROUPS_NO_GC_ACCEPTABLE  = {0x040fc392,0x33df,0x11d2,0x98,0xb2,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_REVISION                       = {0xbf967a21,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_RID                            = {0xbf967a22,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_RID_ALLOCATION_POOL            = {0x66171889,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_RID_AVAILABLE_POOL             = {0x66171888,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_RID_MANAGER_REFERENCE          = {0x66171886,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_RID_NEXT_RID                   = {0x6617188c,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_RID_PREVIOUS_ALLOCATION_POOL   = {0x6617188a,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_RID_SET_REFERENCES             = {0x7bfdcb7b,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_RID_USED_POOL                  = {0x6617188b,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_RIGHTS_GUID                    = {0x8297931c,0x86d3,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_ROLE_OCCUPANT                  = {0xa8df7465,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_ROOMNUMBER                     = {0x81D7F8C2,0xE327,0x4a0d,0x91,0xC6,0xB4,0x2D,0x40,0x09,0x11,0x5F} ;
const GUID GUID_A_ROOT_TRUST                     = {0x7bfdcb80,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_RPC_NS_ANNOTATION              = {0x88611bde,0x8cf4,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_RPC_NS_BINDINGS                = {0xbf967a23,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_RPC_NS_CODESET                 = {0x7a0ba0e0,0x8e98,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_RPC_NS_ENTRY_FLAGS             = {0x80212841,0x4bdc,0x11d1,0xa9,0xc4,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_RPC_NS_GROUP                   = {0xbf967a24,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_RPC_NS_INTERFACE_ID            = {0xbf967a25,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_RPC_NS_OBJECT_ID               = {0x29401c48,0x7a27,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_RPC_NS_PRIORITY                = {0xbf967a27,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_RPC_NS_PROFILE_ENTRY           = {0xbf967a28,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_RPC_NS_TRANSFER_SYNTAX         = {0x29401c4a,0x7a27,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_SAM_ACCOUNT_NAME               = {0x3e0abfd0,0x126a,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_SAM_ACCOUNT_TYPE               = {0x6e7b626c,0x64f2,0x11d0,0xaf,0xd2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_SCHEDULE                       = {0xdd712224,0x10e4,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_SCHEMA_FLAGS_EX                = {0xbf967a2b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SCHEMA_ID_GUID                 = {0xbf967923,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SCHEMA_INFO                    = {0xf9fb64ae,0x93b4,0x11d2,0x99,0x45,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_SCHEMA_UPDATE                  = {0x1e2d06b4,0xac8f,0x11d0,0xaf,0xe3,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_SCHEMA_VERSION                 = {0xbf967a2c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SCOPE_FLAGS                    = {0x16f3a4c2,0x7e79,0x11d2,0x99,0x21,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_SCRIPT_PATH                    = {0xbf9679a8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SD_RIGHTS_EFFECTIVE            = {0xc3dbafa6,0x33df,0x11d2,0x98,0xb2,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_SEARCH_FLAGS                   = {0xbf967a2d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SEARCH_GUIDE                   = {0xbf967a2e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SECRETARY                      = {0x01072D9A,0x98AD,0x4a53,0x97,0x44,0xE8,0x3E,0x28,0x72,0x78,0xFB} ;
const GUID GUID_A_SECURITY_IDENTIFIER            = {0xbf967a2f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SEE_ALSO                       = {0xbf967a31,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SEQ_NOTIFICATION               = {0xddac0cf2,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_SERIAL_NUMBER                  = {0xbf967a32,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SERVER_NAME                    = {0x09dcb7a0,0x165f,0x11d0,0xa0,0x64,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_SERVER_REFERENCE               = {0x26d9736d,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SERVER_REFERENCE_BL            = {0x26d9736e,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SERVER_ROLE                    = {0xbf967a33,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SERVER_STATE                   = {0xbf967a34,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SERVICE_BINDING_INFORMATION    = {0xb7b1311c,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SERVICE_CLASS_ID               = {0xbf967a35,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SERVICE_CLASS_INFO             = {0xbf967a36,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SERVICE_CLASS_NAME             = {0xb7b1311d,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SERVICE_DNS_NAME               = {0x28630eb8,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SERVICE_DNS_NAME_TYPE          = {0x28630eba,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SERVICE_INSTANCE_VERSION       = {0xbf967a37,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SERVICE_PRINCIPAL_NAME         = {0xf3a64788,0x5306,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SETUP_COMMAND                  = {0x7d6c0e97,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_SHELL_CONTEXT_MENU             = {0x553fd039,0xf32e,0x11d0,0xb0,0xbc,0x00,0xc0,0x4f,0xd8,0xdc,0xa6} ;
const GUID GUID_A_SHELL_PROPERTY_PAGES           = {0x52458039,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SHORT_SERVER_NAME              = {0x45b01501,0xc419,0x11d1,0xbb,0xc9,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_SHOW_IN_ADDRESS_BOOK           = {0x3e74f60e,0x3e73,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SHOW_IN_ADVANCED_VIEW_ONLY     = {0xbf967984,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SID_HISTORY                    = {0x17eb4278,0xd167,0x11d0,0xb0,0x02,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SIGNATURE_ALGORITHMS           = {0x2a39c5b2,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SITE_GUID                      = {0x3e978924,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_SITE_LINK_LIST                 = {0xd50c2cdd,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SITE_LIST                      = {0xd50c2cdc,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SITE_OBJECT                    = {0x3e10944c,0xc354,0x11d0,0xaf,0xf8,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SITE_OBJECT_BL                 = {0x3e10944d,0xc354,0x11d0,0xaf,0xf8,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SITE_SERVER                    = {0x1be8f17c,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_SMTP_MAIL_ADDRESS              = {0x26d9736f,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SPN_MAPPINGS                   = {0x2ab0e76c,0x7041,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_STATE_OR_PROVINCE_NAME         = {0xbf967a39,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_STREET_ADDRESS                 = {0xbf967a3a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_STRUCTURAL_OBJECT_CLASS        = {0x3860949f,0xf6a8,0x4b38,0x99,0x50,0x81,0xec,0xb6,0xbc,0x29,0x82} ;
const GUID GUID_A_SUB_CLASS_OF                   = {0xbf967a3b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SUB_REFS                       = {0xbf967a3c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SUBSCHEMASUBENTRY              = {0x9a7ad94d,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_SUPER_SCOPE_DESCRIPTION        = {0x963d274c,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SUPER_SCOPES                   = {0x963d274b,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SUPERIOR_DNS_ROOT              = {0x5245801d,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SUPPLEMENTAL_CREDENTIALS       = {0xbf967a3f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SUPPORTED_APPLICATION_CONTEXT  = {0x1677588f,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SURNAME                        = {0xbf967a41,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SYNC_ATTRIBUTES                = {0x037651e4,0x441d,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SYNC_MEMBERSHIP                = {0x037651e3,0x441d,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SYNC_WITH_OBJECT               = {0x037651e2,0x441d,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SYNC_WITH_SID                  = {0x037651e5,0x441d,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_SYSTEM_AUXILIARY_CLASS         = {0xbf967a43,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SYSTEM_FLAGS                   = {0xe0fa1e62,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_SYSTEM_MAY_CONTAIN             = {0xbf967a44,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SYSTEM_MUST_CONTAIN            = {0xbf967a45,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SYSTEM_ONLY                    = {0xbf967a46,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_SYSTEM_POSS_SUPERIORS          = {0xbf967a47,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_TELEPHONE_NUMBER               = {0xbf967a49,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_TELETEX_TERMINAL_IDENTIFIER    = {0xbf967a4a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_TELEX_NUMBER                   = {0xbf967a4b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_TELEX_PRIMARY                  = {0x0296c121,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_TEMPLATE_ROOTS                 = {0xed9de9a0,0x7041,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_TERMINAL_SERVER                = {0x6db69a1c,0x9422,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_TEXT_COUNTRY                   = {0xf0f8ffa7,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_TEXT_ENCODED_OR_ADDRESS        = {0xa8df7489,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_TIME_REFRESH                   = {0xddac0cf1,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_TIME_VOL_CHANGE                = {0xddac0cf0,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_TITLE                          = {0xbf967a55,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_TOMBSTONE_LIFETIME             = {0x16c3a860,0x1273,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed} ;
const GUID GUID_A_TRANSPORT_ADDRESS_ATTRIBUTE    = {0xc1dc867c,0xa261,0x11d1,0xb6,0x06,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_TRANSPORT_DLL_NAME             = {0x26d97372,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_TRANSPORT_TYPE                 = {0x26d97374,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_TREAT_AS_LEAF                  = {0x8fd044e3,0x771f,0x11d1,0xae,0xae,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_TREE_NAME                      = {0x28630ebd,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_TRUST_ATTRIBUTES               = {0x80a67e5a,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_TRUST_AUTH_INCOMING            = {0xbf967a59,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_TRUST_AUTH_OUTGOING            = {0xbf967a5f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_TRUST_DIRECTION                = {0xbf967a5c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_TRUST_PARENT                   = {0xb000ea7a,0xa086,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_TRUST_PARTNER                  = {0xbf967a5d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_TRUST_POSIX_OFFSET             = {0xbf967a5e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_TRUST_TYPE                     = {0xbf967a60,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_UAS_COMPAT                     = {0xbf967a61,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_UID                            = {0x0BB0FCA0,0x1E89,0x429f,0x90,0x1A,0x14,0x13,0x89,0x4D,0x9F,0x59} ;
const GUID GUID_A_UNC_NAME                       = {0xbf967a64,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_UNICODE_PWD                    = {0xbf9679e1,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_UNIQUEIDENTIFIER               = {0xBA0184C7,0x38C5,0x4bed,0xA5,0x26,0x75,0x42,0x14,0x70,0x58,0x0C} ;
const GUID GUID_A_UNIQUEMEMBER                   = {0x8F888726,0xF80A,0x44d7,0xB1,0xEE,0xCB,0x9D,0xF2,0x13,0x92,0xC8} ;
const GUID GUID_A_UNSTRUCTUREDADDRESS            = {0x50950839,0xCC4C,0x4491,0x86,0x3A,0xFC,0xF9,0x42,0xD6,0x84,0xB7} ;
const GUID GUID_A_UNSTRUCTUREDNAME               = {0x9C8EF177,0x41CF,0x45c9,0x96,0x73,0x77,0x16,0xC0,0xC8,0x90,0x1B} ;
const GUID GUID_A_UPGRADE_PRODUCT_CODE           = {0xd9e18312,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_UPN_SUFFIXES                   = {0x032160bf,0x9824,0x11d1,0xae,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_USER_ACCOUNT_CONTROL           = {0xbf967a68,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_USER_CERT                      = {0xbf967a69,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_USER_COMMENT                   = {0xbf967a6a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_USER_PARAMETERS                = {0xbf967a6d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_USER_PASSWORD                  = {0xbf967a6e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_USERCLASS                      = {0x11732A8A,0xE14D,0x4cc5,0xB9,0x2F,0xD9,0x3F,0x51,0xC6,0xD8,0xE4} ;
const GUID GUID_A_USERPKCS12                     = {0x23998AB5,0x70F8,0x4007,0xA4,0xC1,0xA8,0x4A,0x38,0x31,0x1F,0x9A} ;
const GUID GUID_A_USER_PRINCIPAL_NAME            = {0x28630ebb,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_USER_SHARED_FOLDER             = {0x9a9a021f,0x4a5b,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_USER_SHARED_FOLDER_OTHER       = {0x9a9a0220,0x4a5b,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_USER_SMIME_CERTIFICATE         = {0xe16a9db2,0x403c,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_USER_WORKSTATIONS              = {0xbf9679d7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_USN_CHANGED                    = {0xbf967a6f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_USN_CREATED                    = {0xbf967a70,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_USN_DSA_LAST_OBJ_REMOVED       = {0xbf967a71,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_USN_INTERSITE                  = {0xa8df7498,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0} ;
const GUID GUID_A_USN_LAST_OBJ_REM               = {0xbf967a73,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_USN_SOURCE                     = {0x167758ad,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_VALID_ACCESSES                 = {0x4d2fa380,0x7f54,0x11d2,0x99,0x2a,0x00,0x00,0xf8,0x7a,0x57,0xd4} ;
const GUID GUID_A_VENDOR                         = {0x281416df,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_VERSION_NUMBER                 = {0xbf967a76,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_VERSION_NUMBER_HI              = {0x7d6c0e9a,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_VERSION_NUMBER_LO              = {0x7d6c0e9b,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_VOL_TABLE_GUID                 = {0x1f0075fd,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_VOL_TABLE_IDX_GUID             = {0x1f0075fb,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_VOLUME_COUNT                   = {0x34aaa217,0xb699,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_WBEM_PATH                      = {0x244b2970,0x5abd,0x11d0,0xaf,0xd2,0x00,0xc0,0x4f,0xd9,0x30,0xc9} ;
const GUID GUID_A_WELL_KNOWN_OBJECTS             = {0x05308983,0x7688,0x11d1,0xad,0xed,0x00,0xc0,0x4f,0xd8,0xd5,0xcd} ;
const GUID GUID_A_WHEN_CHANGED                   = {0xbf967a77,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_WHEN_CREATED                   = {0xbf967a78,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_WINSOCK_ADDRESSES              = {0xbf967a79,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_WWW_HOME_PAGE                  = {0xbf967a7a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_WWW_PAGE_OTHER                 = {0x9a9a0221,0x4a5b,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1} ;
const GUID GUID_A_X121_ADDRESS                   = {0xbf967a7b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;
const GUID GUID_A_X500UNIQUEIDENTIFIER           = {0xD07DA11F,0x8A3D,0x42b6,0xB0,0xAA,0x76,0xC9,0x62,0xBE,0x71,0x9A} ;
const GUID GUID_A_X509_CERT                      = {0xbf967a7f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2} ;


//--------------------------------------
// CLASS SCHEMA GUIDS
//--------------------------------------
const GUID GUID_C_ACCOUNT                        = {0x2628A46A,0xA6AD,0x4ae0,0xB8,0x54,0x2B,0x12,0xD9,0xFE,0x6F,0x9E};
const GUID GUID_C_ACS_POLICY                     = {0x7f561288,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_ACS_RESOURCE_LIMITS            = {0x2e899b04,0x2834,0x11d3,0x91,0xd4,0x00,0x00,0xf8,0x7a,0x57,0xd4};
const GUID GUID_C_ACS_SUBNET                     = {0x7f561289,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_ADDRESS_BOOK_CONTAINER         = {0x3e74f60f,0x3e73,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_ADDRESS_TEMPLATE               = {0x5fd4250a,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed};
const GUID GUID_C_APPLICATION_ENTITY             = {0x3fdfee4f,0x47f4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_APPLICATION_PROCESS            = {0x5fd4250b,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed};
const GUID GUID_C_APPLICATION_SETTINGS           = {0xf780acc1,0x56f0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_APPLICATION_SITE_SETTINGS      = {0x19195a5c,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_APPLICATION_VERSION            = {0xddc790ac,0xaf4d,0x442a,0x8f,0x0f,0xa1,0xd4,0xca,0xa7,0xdd,0x92};
const GUID GUID_C_ATTRIBUTE_SCHEMA               = {0xbf967a80,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_BUILTIN_DOMAIN                 = {0xbf967a81,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_CATEGORY_REGISTRATION          = {0x7d6c0e9d,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_CERTIFICATION_AUTHORITY        = {0x3fdfee50,0x47f4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_CLASS_REGISTRATION             = {0xbf967a82,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_CLASS_SCHEMA                   = {0xbf967a83,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_CLASS_STORE                    = {0xbf967a84,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_COM_CONNECTION_POINT           = {0xbf967a85,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_COMPUTER                       = {0xbf967a86,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_CONFIGURATION                  = {0xbf967a87,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_CONNECTION_POINT               = {0x5cb41ecf,0x0e4c,0x11d0,0xa2,0x86,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_CONTACT                        = {0x5cb41ed0,0x0e4c,0x11d0,0xa2,0x86,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_CONTAINER                      = {0xbf967a8b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_CONTROL_ACCESS_RIGHT           = {0x8297931e,0x86d3,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_COUNTRY                        = {0xbf967a8c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_CRL_DISTRIBUTION_POINT         = {0x167758ca,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_CROSS_REF                      = {0xbf967a8d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_CROSS_REF_CONTAINER            = {0xef9e60e0,0x56f7,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_DEVICE                         = {0xbf967a8e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_DFS_CONFIGURATION              = {0x8447f9f2,0x1027,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed};
const GUID GUID_C_DHCP_CLASS                     = {0x963d2756,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_DISPLAY_SPECIFIER              = {0xe0fa1e8a,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_DISPLAY_TEMPLATE               = {0x5fd4250c,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed};
const GUID GUID_C_DMD                            = {0xbf967a8f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_DNS_NODE                       = {0xe0fa1e8c,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_DNS_ZONE                       = {0xe0fa1e8b,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_DOCUMENT                       = {0x39BAD96D,0xC2D6,0x4baf,0x88,0xAB,0x7E,0x42,0x07,0x60,0x01,0x17};
const GUID GUID_C_DOCUMENTSERIES                 = {0x7A2BE07C,0x302F,0x4b96,0xBC,0x90,0x07,0x95,0xD6,0x68,0x85,0xF8};
const GUID GUID_C_DOMAIN                         = {0x19195a5a,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_DOMAIN_DNS                     = {0x19195a5b,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_DOMAIN_POLICY                  = {0xbf967a99,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_DOMAINRELATEDOBJECT            = {0x8BFD2D3D,0xEFDA,0x4549,0x85,0x2C,0xF8,0x5E,0x13,0x7A,0xED,0xC6};
const GUID GUID_C_DS_UI_SETTINGS                 = {0x09b10f14,0x6f93,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4};
const GUID GUID_C_DSA                            = {0x3fdfee52,0x47f4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_DYNAMIC_OBJECT                 = {0x66d51249,0x3355,0x4c1f,0xb2,0x4e,0x81,0xf2,0x52,0xac,0xa2,0x3b};
const GUID GUID_C_FILE_LINK_TRACKING             = {0xdd712229,0x10e4,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed};
const GUID GUID_C_FILE_LINK_TRACKING_ENTRY       = {0x8e4eb2ed,0x4712,0x11d0,0xa1,0xa0,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_FOREIGN_SECURITY_PRINCIPAL     = {0x89e31c12,0x8530,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_FRIENDLYCOUNTRY                = {0xC498F152,0xDC6B,0x474a,0x9F,0x52,0x7C,0xDB,0xA3,0xD7,0xD3,0x51};
const GUID GUID_C_FT_DFS                         = {0x8447f9f3,0x1027,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed};
const GUID GUID_C_GROUP                          = {0xbf967a9c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_GROUP_OF_NAMES                 = {0xbf967a9d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_GROUPOFUNIQUENAMES             = {0x0310A911,0x93A3,0x4e21,0xA7,0xA3,0x55,0xD8,0x5A,0xB2,0xC4,0x8B};
const GUID GUID_C_GROUP_POLICY_CONTAINER         = {0xf30e3bc2,0x9ff0,0x11d1,0xb6,0x03,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_INDEX_SERVER_CATALOG           = {0x7bfdcb8a,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_INETORGPERSON                  = {0x4828CC14,0x1437,0x45bc,0x9B,0x07,0xAD,0x6F,0x01,0x5E,0x5F,0x28};
const GUID GUID_C_INFRASTRUCTURE_UPDATE          = {0x2df90d89,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a};
const GUID GUID_C_INTELLIMIRROR_GROUP            = {0x07383086,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_INTELLIMIRROR_SCP              = {0x07383085,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_INTER_SITE_TRANSPORT           = {0x26d97376,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_INTER_SITE_TRANSPORT_CONTAINER = {0x26d97375,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_IPSEC_BASE                     = {0xb40ff825,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_IPSEC_FILTER                   = {0xb40ff826,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_IPSEC_ISAKMP_POLICY            = {0xb40ff828,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_IPSEC_NEGOTIATION_POLICY       = {0xb40ff827,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_IPSEC_NFA                      = {0xb40ff829,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_IPSEC_POLICY                   = {0xb7b13121,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_LEAF                           = {0xbf967a9e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_LICENSING_SITE_SETTINGS        = {0x1be8f17d,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_LINK_TRACK_OBJECT_MOVE_TABLE   = {0xddac0cf5,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_LINK_TRACK_OMT_ENTRY           = {0xddac0cf7,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_LINK_TRACK_VOL_ENTRY           = {0xddac0cf6,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_LINK_TRACK_VOLUME_TABLE        = {0xddac0cf4,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_LOCALITY                       = {0xbf967aa0,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_LOST_AND_FOUND                 = {0x52ab8671,0x5709,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_MAIL_RECIPIENT                 = {0xbf967aa1,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_MEETING                        = {0x11b6cc94,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_MS_COM_PARTITION               = {0xc9010e74,0x4e58,0x49f7,0x8a,0x89,0x5e,0x3e,0x23,0x40,0xfc,0xf8};
const GUID GUID_C_MS_COM_PARTITIONSET            = {0x250464ab,0xc417,0x497a,0x97,0x5a,0x9e,0x0d,0x45,0x9a,0x7c,0xa1};
const GUID GUID_C_MS_DS_APP_CONFIGURATION        = {0x90df3c3e,0x1854,0x4455,0xa5,0xd7,0xca,0xd4,0x0d,0x56,0x65,0x7a};
const GUID GUID_C_MS_DS_APP_DATA                 = {0x9E67D761,0xE327,0x4d55,0xBC,0x95,0x68,0x2F,0x87,0x5E,0x2F,0x8E};
const GUID GUID_C_MS_DS_AZ_ADMIN_MANAGER         = {0xCFEE1051,0x5F28,0x4bae,0xA8,0x63,0x5D,0x0C,0xC1,0x8A,0x8E,0xD1};
const GUID GUID_C_MS_DS_AZ_APPLICATION           = {0xDDF8DE9B,0xCBA5,0x4e12,0x84,0x2E,0x28,0xD8,0xB6,0x6F,0x75,0xEC};
const GUID GUID_C_MS_DS_AZ_OPERATION             = {0x860ABE37,0x9A9B,0x4fa4,0xB3,0xD2,0xB8,0xAC,0xE5,0xDF,0x9E,0xC5};
const GUID GUID_C_MS_DS_AZ_ROLE                  = {0x8213EAC9,0x9D55,0x44dc,0x92,0x5C,0xE9,0xA5,0x2B,0x92,0x76,0x44};
const GUID GUID_C_MS_DS_AZ_SCOPE                 = {0x4FEAE054,0xCE55,0x47bb,0x86,0x0E,0x5B,0x12,0x06,0x3A,0x51,0xDE};
const GUID GUID_C_MS_DS_AZ_TASK                  = {0x1ED3A473,0x9B1B,0x418a,0xBF,0xA0,0x3A,0x37,0xB9,0x5A,0x53,0x06};
const GUID GUID_C_MS_DS_QUOTA_CONTAINER          = {0xda83fc4f,0x076f,0x4aea,0xb4,0xdc,0x8f,0x4d,0xab,0x9b,0x59,0x93};
const GUID GUID_C_MS_DS_QUOTA_CONTROL            = {0xde91fc26,0xbd02,0x4b52,0xae,0x26,0x79,0x59,0x99,0xe9,0x6f,0xc7};
const GUID GUID_C_MS_EXCH_CONFIGURATION_CONTAINER = {0xd03d6858,0x06f4,0x11d2,0xaa,0x53,0x00,0xc0,0x4f,0xd7,0xd8,0x3a};
const GUID GUID_C_MS_IEEE_80211_POLICY           = {0x7B9A2D92,0xB7EB,0x4382,0x97,0x72,0xC3,0xE0,0xF9,0xBA,0xAF,0x94};
const GUID GUID_C_MS_PKI_ENTERPRISE_OID          = {0x37cfd85c,0x6719,0x4ad8,0x8f,0x9e,0x86,0x78,0xba,0x62,0x75,0x63};
const GUID GUID_C_MS_PKI_KEY_RECOVERY_AGENT      = {0x26ccf238,0xa08e,0x4b86,0x9a,0x82,0xa8,0xc9,0xac,0x7e,0xe5,0xcb};
const GUID GUID_C_MS_SQL_SQLSERVER               = {0x05f6c878,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4};
const GUID GUID_C_MS_SQL_OLAPSERVER              = {0x0c7e18ea,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4};
const GUID GUID_C_MS_SQL_SQLREPOSITORY           = {0x11d43c5c,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4};
const GUID GUID_C_MS_SQL_SQLPUBLICATION          = {0x17c2f64e,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4};
const GUID GUID_C_MS_SQL_SQLDATABASE             = {0x1d08694a,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4};
const GUID GUID_C_MS_SQL_OLAPDATABASE            = {0x20af031a,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4};
const GUID GUID_C_MS_SQL_OLAPCUBE                = {0x09f0506a,0xcd28,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4};
const GUID GUID_C_MS_TAPI_RT_CONFERENCE          = {0xca7b9735,0x4b2a,0x4e49,0x89,0xc3,0x99,0x02,0x53,0x34,0xdc,0x94};
const GUID GUID_C_MS_TAPI_RT_PERSON              = {0x53ea1cb5,0xb704,0x4df9,0x81,0x8f,0x5c,0xb4,0xec,0x86,0xca,0xc1};
const GUID GUID_C_MS_WMI_INTRANGEPARAM           = {0x50ca5d7d,0x5c8b,0x4ef3,0xb9,0xdf,0x5b,0x66,0xd4,0x91,0xe5,0x26};
const GUID GUID_C_MS_WMI_INTSETPARAM             = {0x292f0d9a,0xcf76,0x42b0,0x84,0x1f,0xb6,0x50,0xf3,0x31,0xdf,0x62};
const GUID GUID_C_MS_WMI_MERGEABLEPOLICYTEMPLATE = {0x07502414,0xfdca,0x4851,0xb0,0x4a,0x13,0x64,0x5b,0x11,0xd2,0x26};
const GUID GUID_C_MS_WMI_OBJECTENCODING          = {0x55dd81c9,0xc312,0x41f9,0xa8,0x4d,0xc6,0xad,0xbd,0xf1,0xe8,0xe1};
const GUID GUID_C_MS_WMI_POLICYTEMPLATE          = {0xe2bc80f1,0x244a,0x4d59,0xac,0xc6,0xca,0x5c,0x4f,0x82,0xe6,0xe1};
const GUID GUID_C_MS_WMI_POLICYTYPE              = {0x595b2613,0x4109,0x4e77,0x90,0x13,0xa3,0xbb,0x4e,0xf2,0x77,0xc7};
const GUID GUID_C_MS_WMI_RANGEPARAM              = {0x45fb5a57,0x5018,0x4d0f,0x90,0x56,0x99,0x7c,0x8c,0x91,0x22,0xd9};
const GUID GUID_C_MS_WMI_REALRANGEPARAM          = {0x6afe8fe2,0x70bc,0x4cce,0xb1,0x66,0xa9,0x6f,0x73,0x59,0xc5,0x14};
const GUID GUID_C_MS_WMI_RULE                    = {0x3c7e6f83,0xdd0e,0x481b,0xa0,0xc2,0x74,0xcd,0x96,0xef,0x2a,0x66};
const GUID GUID_C_MS_WMI_SHADOWOBJECT            = {0xf1e44bdf,0x8dd3,0x4235,0x9c,0x86,0xf9,0x1f,0x31,0xf5,0xb5,0x69};
const GUID GUID_C_MS_WMI_SIMPLEPOLICYTEMPLATE    = {0x6cc8b2b5,0x12df,0x44f6,0x83,0x07,0xe7,0x4f,0x5c,0xde,0xe3,0x69};
const GUID GUID_C_MS_WMI_SOM                     = {0xab857078,0x0142,0x4406,0x94,0x5b,0x34,0xc9,0xb6,0xb1,0x33,0x72};
const GUID GUID_C_MS_WMI_STRINGSETPARAM          = {0x0bc579a2,0x1da7,0x4cea,0xb6,0x99,0x80,0x7f,0x3b,0x9d,0x63,0xa4};
const GUID GUID_C_MS_WMI_UINTRANGEPARAM          = {0xd9a799b2,0xcef3,0x48b3,0xb5,0xad,0xfb,0x85,0xf8,0xdd,0x32,0x14};
const GUID GUID_C_MS_WMI_UINTSETPARAM            = {0x8f4beb31,0x4e19,0x46f5,0x93,0x2e,0x5f,0xa0,0x3c,0x33,0x9b,0x1d};
const GUID GUID_C_MS_WMI_UNKNOWNRANGEPARAM       = {0xb82ac26b,0xc6db,0x4098,0x92,0xc6,0x49,0xc1,0x8a,0x33,0x36,0xe1};
const GUID GUID_C_MS_WMI_WMIGPO                  = {0x05630000,0x3927,0x4ede,0xbf,0x27,0xca,0x91,0xf2,0x75,0xc2,0x6f};
const GUID GUID_C_MSMQ_CONFIGURATION             = {0x9a0dc344,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0};
const GUID GUID_C_MSMQ_CUSTOM_RECIPIENT          = {0x876d6817,0x35cc,0x436c,0xac,0xea,0x5e,0xf7,0x17,0x4d,0xd9,0xbe};
const GUID GUID_C_MSMQ_ENTERPRISE_SETTINGS       = {0x9a0dc345,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0};
const GUID GUID_C_MSMQ_GROUP                     = {0x46b27aac,0xaafa,0x4ffb,0xb7,0x73,0xe5,0xbf,0x62,0x1e,0xe8,0x7b};
const GUID GUID_C_MSMQ_MIGRATED_USER             = {0x50776997,0x3c3d,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1};
const GUID GUID_C_MSMQ_QUEUE                     = {0x9a0dc343,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0};
const GUID GUID_C_MSMQ_SETTINGS                  = {0x9a0dc347,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0};
const GUID GUID_C_MSMQ_SITE_LINK                 = {0x9a0dc346,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0};
const GUID GUID_C_NTDS_CONNECTION                = {0x19195a60,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_NTDS_DSA                       = {0xf0f8ffab,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed};
const GUID GUID_C_NTDS_SERVICE                   = {0x19195a5f,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_NTDS_SITE_SETTINGS             = {0x19195a5d,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_NTFRS_MEMBER                   = {0x2a132586,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_NTFRS_REPLICA_SET              = {0x5245803a,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_NTFRS_SETTINGS                 = {0xf780acc2,0x56f0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_NTFRS_SUBSCRIBER               = {0x2a132588,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_NTFRS_SUBSCRIPTIONS            = {0x2a132587,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_ORGANIZATION                   = {0xbf967aa3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_ORGANIZATIONAL_PERSON          = {0xbf967aa4,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_ORGANIZATIONAL_ROLE            = {0xa8df74bf,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0};
const GUID GUID_C_ORGANIZATIONAL_UNIT            = {0xbf967aa5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_PACKAGE_REGISTRATION           = {0xbf967aa6,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_PERSON                         = {0xbf967aa7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_PHYSICAL_LOCATION              = {0xb7b13122,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_PKI_CERTIFICATE_TEMPLATE       = {0xe5209ca2,0x3bba,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1};
const GUID GUID_C_PKI_ENROLLMENT_SERVICE         = {0xee4aa692,0x3bba,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1};
const GUID GUID_C_MS_PKI_PRIVATE_KEY_RECOVERY_AGENT = {0x1562a632,0x44b9,0x4a7e,0xa2,0xd3,0xe4,0x26,0xc9,0x6a,0x3a,0xcc};
const GUID GUID_C_PRINT_QUEUE                    = {0xbf967aa8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_QUERY_POLICY                   = {0x83cc7075,0xcca7,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_REMOTE_MAIL_RECIPIENT          = {0xbf967aa9,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_REMOTE_STORAGE_SERVICE_POINT   = {0x2a39c5bd,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_RESIDENTIAL_PERSON             = {0xa8df74d6,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0};
const GUID GUID_C_RFC822LOCALPART                = {0xB93E3A78,0xCBAE,0x485e,0xA0,0x7B,0x5E,0xF4,0xAE,0x50,0x56,0x86};
const GUID GUID_C_RID_MANAGER                    = {0x6617188d,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_RID_SET                        = {0x7bfdcb89,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_ROOM                           = {0x7860E5D2,0xC8B0,0x4cbb,0xBD,0x45,0xD9,0x45,0x5B,0xEB,0x92,0x06};
const GUID GUID_C_RPC_CONTAINER                  = {0x80212842,0x4bdc,0x11d1,0xa9,0xc4,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_RPC_ENTRY                      = {0xbf967aac,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_RPC_GROUP                      = {0x88611bdf,0x8cf4,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_RPC_PROFILE                    = {0x88611be1,0x8cf4,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_RPC_PROFILE_ELEMENT            = {0xf29653cf,0x7ad0,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_RPC_SERVER                     = {0x88611be0,0x8cf4,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_RPC_SERVER_ELEMENT             = {0xf29653d0,0x7ad0,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9};
const GUID GUID_C_RRAS_ADMINISTRATION_CONNECTION_POINT = {0x2a39c5be,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_RRAS_ADMINISTRATION_DICTIONARY = {0xf39b98ae,0x938d,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_SAM_DOMAIN                     = {0xbf967a90,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SAM_DOMAIN_BASE                = {0xbf967a91,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SAM_SERVER                     = {0xbf967aad,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SECRET                         = {0xbf967aae,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SECURITY_OBJECT                = {0xbf967aaf,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SECURITY_PRINCIPAL             = {0xbf967ab0,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SERVER                         = {0xbf967a92,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SERVERS_CONTAINER              = {0xf780acc0,0x56f0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_SERVICE_ADMINISTRATION_POINT   = {0xb7b13123,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_SERVICE_CLASS                  = {0xbf967ab1,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SERVICE_CONNECTION_POINT       = {0x28630ec1,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_SERVICE_INSTANCE               = {0xbf967ab2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SIMPLESECURITYOBJECT           = {0x5FE69B0B,0xE146,0x4f15,0xB0,0xAB,0xC1,0xE5,0xD4,0x88,0xE0,0x94};
const GUID GUID_C_SITE                           = {0xbf967ab3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SITE_LINK                      = {0xd50c2cde,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_SITE_LINK_BRIDGE               = {0xd50c2cdf,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_SITES_CONTAINER                = {0x7a4117da,0xcd67,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_STORAGE                        = {0xbf967ab5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_SUBNET                         = {0xb7b13124,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_SUBNET_CONTAINER               = {0xb7b13125,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1};
const GUID GUID_C_SUBSCHEMA                      = {0x5a8b3261,0xc38d,0x11d1,0xbb,0xc9,0x00,0x80,0xc7,0x66,0x70,0xc0};
const GUID GUID_C_TOP                            = {0xbf967ab7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_TRUSTED_DOMAIN                 = {0xbf967ab8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_TYPE_LIBRARY                   = {0x281416e2,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_USER                           = {0xbf967aba,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
const GUID GUID_C_VOLUME                         = {0xbf967abb,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\pek.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        pek.cxx
//
// Contents:    Routines for Password encryption-decryption
//              and key management. Handles Password encryption and
//              decryption in registry mode. In DS mode does no
//              encryption/decryption --- encryption/decryption done by
//              DS.
//
//
// History:     5 December 1997        Created
//
//------------------------------------------------------------------------




#include <ntdspch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntsam.h>
#include <samrpc.h>
#include <ntsamp.h>
#include <samisrv.h>
#include <samsrvp.h>
#include <dslayer.h>
#include <cryptdll.h>
#include <wincrypt.h>
#include <crypt.h>
#include <wxlpc.h>
#include <rc4.h>
#include <md5.h>
#include <enckey.h>
#include <rng.h>
#include <attids.h>
#include <filtypes.h>
#include <lmaccess.h>

/////////////////////////////////////////////////////////////////////
//
//  Services Pertiaining to Encryption and Decryption of Secret
//  Data Attributes.
//
/////////////////////////////////////////////////////////////////////


USHORT
SampGetEncryptionKeyType()
/*++

    Obtains the Correct Key Id for use on Encryption, depending
    upon DS or Registry Mode

    Parameters:

        None

    Return Values

        Key Id for use on Encryption
--*/
{
    //
    // In registry mode encryption is performed by using the
    // 128 bit password encryption key stored in the domain 
    // object and salting the key with the RID of the account
    // and a constant that describes the attribute. In DS mode
    // No encryption is performed by SAM, the base DS handles the
    // encryption -- look at ds\ds\src\ntdsa\pek\pek.c 
    //

    if (SampSecretEncryptionEnabled)
    {
        if (SampUseDsData)
            //
            // In DS mode encryption is handled by DS.
            //
            return SAMP_NO_ENCRYPTION;
        else
            return SAMP_DEFAULT_SESSION_KEY_ID;
    }
    else
        return SAMP_NO_ENCRYPTION;
}

PUCHAR 
SampMagicConstantFromDataType(
       IN SAMP_ENCRYPTED_DATA_TYPE DataType,
       OUT PULONG ConstantLength
       )
{
    switch(DataType)
    {
       case LmPassword:
            *ConstantLength = sizeof("LMPASSWORD");
            return("LMPASSWORD");
       case NtPassword:
            *ConstantLength = sizeof("NTPASSWORD");
            return("NTPASSWORD");
       case NtPasswordHistory:
            *ConstantLength = sizeof("NTPASSWORDHISTORY");
            return("NTPASSWORDHISTORY");
       case LmPasswordHistory:
            *ConstantLength = sizeof("LMPASSWORDHISTORY");
            return("LMPASSWORDHISTORY");
       case MiscCredentialData:
            *ConstantLength = sizeof("MISCCREDDATA");
            return("MISCCREDDATA");
       default:
            break;
    }

    ASSERT(FALSE && "Should not happen");
    *ConstantLength = 0;
    return(NULL);
} 
  

NTSTATUS
SampEncryptSecretData(
    OUT PUNICODE_STRING EncryptedData,
    IN  USHORT          EncryptionType,
    IN  SAMP_ENCRYPTED_DATA_TYPE DataType,
    IN  PUNICODE_STRING ClearData,
    IN  ULONG Rid
    )
/*++

Routine Description:

    This routine encrypts sensitive data. The encrypted data is allocated and
    should be free with SampFreeUnicodeString.


Arguments:

    EncryptedData - Receives the encrypted data and may be freed with
        SampFreeUnicodeString. The

    EncryptionType  - Specifies the Type of Encryption to Use.

    ClearData - Contains the clear data to encrypt. The length may be
        zero.

Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_INSUFFICIENT_RESOURCES - not enough memory to allocate the
        output.

--*/
{
    PSAMP_SECRET_DATA SecretData;
    struct RC4_KEYSTRUCT Rc4Key;
    MD5_CTX Md5Context;
    UCHAR * KeyToUse;
    ULONG   KeyLength;
    PUCHAR  ConstantToUse=NULL;
    ULONG   ConstantLength = 0;

    ASSERT(ENCRYPTED_LM_OWF_PASSWORD_LENGTH == ENCRYPTED_NT_OWF_PASSWORD_LENGTH);

    ASSERT(!SampIsDataEncrypted(ClearData));

    //
    // If encryption is not enabled, or caller does not want encryption,
    // do nothing special.
    //

    if ((!SampSecretEncryptionEnabled) || (SAMP_NO_ENCRYPTION==EncryptionType)) {
        return(SampDuplicateUnicodeString(
                EncryptedData,
                ClearData
                ));
    }

    //
    // Compute the size of the output buffer and allocate it.
    //

    EncryptedData->Length = SampSecretDataSize(ClearData->Length);
    EncryptedData->MaximumLength = EncryptedData->Length;

    EncryptedData->Buffer = (LPWSTR) MIDL_user_allocate(EncryptedData->Length);
    if (EncryptedData->Buffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    SecretData = (PSAMP_SECRET_DATA) EncryptedData->Buffer;
    SecretData->Flags = SAMP_ENCRYPTION_FLAG_PER_TYPE_CONST;
    SecretData->KeyId = (USHORT) SampCurrentKeyId;
    ConstantToUse = SampMagicConstantFromDataType(DataType,&ConstantLength);

    switch(EncryptionType)
    {
    case SAMP_DEFAULT_SESSION_KEY_ID:
        ASSERT(FALSE==SampUseDsData);
        if (TRUE==SampUseDsData)
        {
            return STATUS_INTERNAL_ERROR;
        }

        KeyToUse = SampSecretSessionKey;
        KeyLength = SAMP_SESSION_KEY_LENGTH;
        break;

    default:
        ASSERT("Unknown Key Type Specified");
        return STATUS_INTERNAL_ERROR;
        break;

    }

    MD5Init(&Md5Context);

    MD5Update(
        &Md5Context,
        KeyToUse,
        KeyLength
        );

    MD5Update(
        &Md5Context,
        (PUCHAR) &Rid,
        sizeof(ULONG)
        );

    MD5Update(
        &Md5Context,
        ConstantToUse,
        ConstantLength 
        );

    MD5Final(
        &Md5Context
        );

    rc4_key(
        &Rc4Key,
        MD5DIGESTLEN,
        Md5Context.digest
        );

    //
    // Only encrypt if the length is greater than zero - RC4 can't handle
    // zero length buffers.
    //

    if (ClearData->Length > 0) {

        RtlCopyMemory(
            SecretData->Data,
            ClearData->Buffer,
            ClearData->Length
            );

        rc4(
            &Rc4Key,
            ClearData->Length,
            SecretData->Data
            );

    }


    return(STATUS_SUCCESS);

}


NTSTATUS
SampDecryptSecretData(
    OUT PUNICODE_STRING ClearData,
    IN SAMP_ENCRYPTED_DATA_TYPE DataType,
    IN PUNICODE_STRING EncryptedData,
    IN ULONG Rid
    )
/*++

Routine Description:

    This routine decrypts sensitive data encrypted by SampEncryptSecretData().
    The clear data is allocated and should be free with SampFreeUnicodeString.
    The default session key with the default algorithm is used.


Arguments:

    ClearData - Contains the decrypted data. The length may be
        zero. The string should be freed with SampFreeUnicodeString.

    EncryptedData - Receives the encrypted data and may be freed with
        SampFreeUnicodeString.

    Rid - Rid to salt the data.


Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_INSUFFICIENT_RESOURCES - not enough memory to allocate the
        output.

--*/
{
    PSAMP_SECRET_DATA SecretData;
    struct RC4_KEYSTRUCT Rc4Key;
    MD5_CTX Md5Context;
    UCHAR * KeyToUse;
    ULONG   KeyLength;
    ULONG   Key;

    //
    // If encryption is not enabled, do nothing special.
    //

    if (!SampSecretEncryptionEnabled ||
        !SampIsDataEncrypted(EncryptedData)) {

        //
        // If secret encryption is enabled, than it is possible that early
        // releases of NT4 SP3 didn't decrypt a password before sticking
        // it in the history. If this is the case then return a null
        // string as the history.
        //


        if ((SampSecretEncryptionEnabled) &&
            ((EncryptedData->Length % ENCRYPTED_NT_OWF_PASSWORD_LENGTH) != 0)) {
            return(SampDuplicateUnicodeString(
                    ClearData,
                    &SampNullString
                    ));
        }


        return(SampDuplicateUnicodeString(
                ClearData,
                EncryptedData
                ));
    }

    //
    // Make sure the data has actually been encrypted.
    //

    ASSERT(ENCRYPTED_LM_OWF_PASSWORD_LENGTH == ENCRYPTED_NT_OWF_PASSWORD_LENGTH);
    ASSERT(SampIsDataEncrypted(EncryptedData));

    SecretData = (PSAMP_SECRET_DATA) EncryptedData->Buffer;
    
    //
    // Make sure we still have the correct key
    //

    if ((SecretData->KeyId !=SampCurrentKeyId) &&
       (SecretData->KeyId !=SampPreviousKeyId))
    {
        return(STATUS_INTERNAL_ERROR);
    }

    //
    // Compute the size of the output buffer and allocate it.
    //

    ClearData->Length = SampClearDataSize(EncryptedData->Length);
    ClearData->MaximumLength = ClearData->Length;

    //
    // If there was no data we can return now.
    //

    if (ClearData->Length == 0)
    {
        ClearData->Buffer = NULL;
        return(STATUS_SUCCESS);
    }

    ClearData->Buffer = (LPWSTR) MIDL_user_allocate(ClearData->Length);
    if (ClearData->Buffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Find the Key to Use
    //

    if (SecretData->KeyId == SampCurrentKeyId)
    {
        KeyToUse = SampSecretSessionKey;
        KeyLength = SAMP_SESSION_KEY_LENGTH;
    } 
    else 
    {
        ASSERT(SecretData->KeyId==SampPreviousKeyId);

        KeyToUse = SampSecretSessionKeyPrevious;
        KeyLength = SAMP_SESSION_KEY_LENGTH;
    }

    MD5Init(&Md5Context);

    MD5Update(
        &Md5Context,
        KeyToUse,
        KeyLength
        );

    MD5Update(
        &Md5Context,
        (PUCHAR) &Rid,
        sizeof(ULONG)
        );

    if ((SecretData->Flags & SAMP_ENCRYPTION_FLAG_PER_TYPE_CONST)!=0)
    {
        ULONG  ConstantLength = 0;
        PUCHAR ConstantToUse = SampMagicConstantFromDataType(DataType,&ConstantLength);


        MD5Update(
            &Md5Context,
            ConstantToUse,
            ConstantLength
            );
    } 
     
    MD5Final(
        &Md5Context
        );

    rc4_key(
        &Rc4Key,
        MD5DIGESTLEN,
        Md5Context.digest
        );

    RtlCopyMemory(
        ClearData->Buffer,
        SecretData->Data,
        ClearData->Length
        );

    rc4(
        &Rc4Key,
        ClearData->Length,
        (PUCHAR) ClearData->Buffer
        );


    return(STATUS_SUCCESS);

}


        
        

        
NTSTATUS
SampEncryptDSRMPassword(
    OUT PUNICODE_STRING EncryptedData,
    IN  USHORT          EncryptionType,
    IN  SAMP_ENCRYPTED_DATA_TYPE DataType,
    IN  PUNICODE_STRING ClearData,
    IN  ULONG Rid
    )
/*++

Routine Description:

    This routine encrypts password using SAM password encryption key.

    The encrypted password is allocated and should be free with 
    SampFreeUnicodeString.

    This routine will be used by SamrSetDSRMPassword ONLY.

Arguments:

    EncryptedData - Receives the encrypted data and may be freed with
        SampFreeUnicodeString. The

    KeyId         - Specifies the Type of Encryption to Use.

    ClearData - Contains the clear data to encrypt. The length may be
        zero.

Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_INSUFFICIENT_RESOURCES - not enough memory to allocate the
        output.

--*/
{
    PSAMP_SECRET_DATA SecretData;
    struct RC4_KEYSTRUCT Rc4Key;
    MD5_CTX Md5Context;
    UCHAR * KeyToUse;
    ULONG   KeyLength;
    PUCHAR  ConstantToUse=NULL;
    ULONG   ConstantLength = 0;

    ASSERT(ENCRYPTED_LM_OWF_PASSWORD_LENGTH == ENCRYPTED_NT_OWF_PASSWORD_LENGTH);

    ASSERT(!SampIsDataEncrypted(ClearData));

    //
    // If encryption is not enabled, or caller does not want encryption,
    // do nothing special.
    //

    if ((!SampSecretEncryptionEnabled) || (SAMP_NO_ENCRYPTION==EncryptionType)) {
        return(SampDuplicateUnicodeString(
                EncryptedData,
                ClearData
                ));
    }

    //
    // Compute the size of the output buffer and allocate it.
    //

    EncryptedData->Length = SampSecretDataSize(ClearData->Length);
    EncryptedData->MaximumLength = EncryptedData->Length;

    EncryptedData->Buffer = (LPWSTR) MIDL_user_allocate(EncryptedData->Length);
    if (EncryptedData->Buffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    SecretData = (PSAMP_SECRET_DATA) EncryptedData->Buffer;
    SecretData->Flags = SAMP_ENCRYPTION_FLAG_PER_TYPE_CONST;
    SecretData->KeyId = (USHORT) SampCurrentKeyId;
    ConstantToUse = SampMagicConstantFromDataType(DataType,&ConstantLength);

    KeyToUse = SampSecretSessionKey;
    KeyLength = SAMP_SESSION_KEY_LENGTH;

    MD5Init(&Md5Context);

    MD5Update(
        &Md5Context,
        KeyToUse,
        KeyLength
        );

    MD5Update(
        &Md5Context,
        (PUCHAR) &Rid,
        sizeof(ULONG)
        );

    MD5Update(
        &Md5Context,
        ConstantToUse,
        ConstantLength 
        );

    MD5Final(
        &Md5Context
        );

    rc4_key(
        &Rc4Key,
        MD5DIGESTLEN,
        Md5Context.digest
        );

    //
    // Only encrypt if the length is greater than zero - RC4 can't handle
    // zero length buffers.
    //

    if (ClearData->Length > 0) {

        RtlCopyMemory(
            SecretData->Data,
            ClearData->Buffer,
            ClearData->Length
            );

        rc4(
            &Rc4Key,
            ClearData->Length,
            SecretData->Data
            );

    }


    return(STATUS_SUCCESS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\ridmgr.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ridmgr.h

Abstract:

    This file contains definitions, constants, etc. for the NT Security
    Accounts Manager (SAM) Relative Identifier (RID) manager.

Author:

    Chris Mayhall (ChrisMay) 05-Nov-1996

Environment:

    User Mode - Win32

Revision History:

    ChrisMay        05-Nov-1996
        Created.
    ChrisMay        05-Jan-1997
        Updated forward declarations, etc.

--*/

// Constants and Macros

// BUG: Temporary error codes, should be corrected and moved into ntstatus.h.

#define STATUS_NO_RIDS_ALLOCATED    STATUS_DS_NO_RIDS_ALLOCATED
#define STATUS_NO_MORE_RIDS         STATUS_DS_NO_MORE_RIDS
#define SAMP_INCORRECT_ROLE_OWNER   STATUS_DS_INCORRECT_ROLE_OWNER
#define SAMP_RID_MGR_INIT_ERROR     STATUS_DS_RIDMGR_INIT_ERROR

// 0xFFFFFF - SAMP_RESTRICTED_ACCOUNT_COUNT = 16,777,215 - 1000 =  16,776,215
// possible account RID's per domain. Note that the top byte is reserved for
// POSIX, Netware, and Macintosh compatibility. In NT4 (and prior releases)
// the first 1000 RID's were reserved (SAMP_RESTRICTED_ACCOUNT_COUNT) for the
// Builtin accounts.

// The minimum domain RID is incremented by 100,000 to handle NT4-to-NT5 up-
// grades. NT4 DC's are limited to approximately 30,000 accounts (and with
// some deletion) 100,000 should be well above any NT4 RID currently in use.
// Otherwise there will be a RID re-usage problem when the NT4 DC is upgraded
// to NT5.

// #define SAMP_MINIMUM_DOMAIN_RID     (SAMP_RESTRICTED_ACCOUNT_COUNT + 100000)
#define SAMP_MINIMUM_DOMAIN_RID     SAMP_RESTRICTED_ACCOUNT_COUNT
#define SAMP_MAXIMUM_DOMAIN_RID     0x3FFFFFFF
// Test Case Size: #define SAMP_MAXIMUM_DOMAIN_RID     (SAMP_MINIMUM_DOMAIN_RID + SAMP_RID_BLOCK_SIZE)

// RID block size is the increment amount for allocating new RID blocks. Note
// that 16,776,115 divided by SAMP_RID_BLOCK_SIZE yields the maximum number of
// DC's that can be present in a single domain.
// Note:- When a DC is restored, the DC will abandon the current rid-block and request
//        get a new rid-block allocated for future account creations. This is so that
//        we can avoid creating duplicate accounts with same RID. Keeping the RID block
//        size too low will result in frequent FSMO operations and too high will result
//        in potential wastage of RIDs during restore. Block size of 500 is a reasonable 
//        trade-off.

#define SAMP_RID_BLOCK_SIZE         500

//
// The default SampRidThreshold percentage.  Once this percentage of the current
// RID pool is exhausted, a request for a new RID pool is triggered.
// If the blocksize is 500, a threshold of 0.50 will result in a new pool 
// request once 250 RIDs have been consumed.

#define SAMP_RID_THRESHOLD   (0.50)

// This NT status code is returned from the creation routines in the event
// that the object already exists (hence, don't reset NextRid, etc. to the
// initialization values).

#define SAMP_OBJ_EXISTS             STATUS_USER_EXISTS

// Maximum number of attributes on any one class of RID-management object--
// used for contiguous DSATTR allocation blocks, faster allocation.

#define SAMP_RID_ATTR_MAX           8

// Opcodes for floating single master operation (FSMO) to either obtain a new
// RID pool or request to change the current RID manager to another DSA.

#define SAMP_REQUEST_RID_POOL       2
#define SAMP_CHANGE_RID_MANAGER     3

// retry interval if rid pool request failed ( 30 s )
#define SAMP_RID_DEFAULT_RETRY_INTERVAL 30000
// retry interval if local update of a rid pool request failed ( 30 min)
#define SAMP_RID_LOCAL_UPDATER_ERROR_RETRY_INTERVAL 1800000
// retry count when we start applying the above 30 min interval
#define SAMP_RID_LOCAL_UPDATE_RETRY_CUTOFF 3

// Private attribute flags used only in this module.

#define RID_REFERENCE               0x00000001
#define RID_ROLE_OWNER              0x00000010
#define RID_AVAILABLE_POOL          0x00000020
#define RID_DC_COUNT                0x00000040
#define RID_ALLOCATED_POOL          0x00001000
#define RID_PREV_ALLOC_POOL         0x00002000
#define RID_USED_POOL               0x00004000
#define RID_NEXT_RID                0x00008000

// Type Definitions and Enums

typedef ULONG RIDFLAG;
typedef ULONG *PRIDFLAG;

typedef struct _RIDINFO
{
    // Since DSNAME's are variable-length structs, maintain pointers to the
    // DSNAME's in this structure.

    // Note, the DSNAMEs currently only contain the distinguished name (DN)
    // of the object, but do NOT contain the GUID, SID, or length data--
    // this can be added later if necessary. The DN is copied into the
    // StringName member of the DSNAME.

    PDSNAME         RidManagerReference; // DSNAME of the RID Manager
    PDSNAME         RoleOwner;           // Current RID Manager
    ULARGE_INTEGER  RidPoolAvailable;    // Global RID pool for the domain
    ULONG           RidDcCount;          // Number of DC's in the domain
    ULARGE_INTEGER  RidPoolAllocated;    // Current RID pool in use by the DSA
    ULARGE_INTEGER  RidPoolPrevAlloc;    // Previous RID pool used by the DSA
    ULARGE_INTEGER  RidPoolUsed;         // RID high water mark
    ULONG           NextRid;             // The Next RID to use
    RIDFLAG         Flags;               // RID operation desired
} RIDINFO;

typedef struct _RIDINFO *PRIDINFO;

typedef enum _RID_OBJECT_TYPE
{
    RidManagerReferenceType = 1,
    RidManagerType,
    RidObjectType
} RID_OBJECT_TYPE;

// Global Data

extern CRITICAL_SECTION RidMgrCriticalSection;
extern PCRITICAL_SECTION RidMgrCritSect;

// extern BOOLEAN SampDcHasInitialRidPool;
extern BOOLEAN fRidFSMOOpInProgress;

// Forward declarations for RID management

NTSTATUS
SampInitDomainNextRid(
    IN OUT PULONG NextRid
    );

NTSTATUS
SampCreateRidManagerReference(
    IN PWCHAR NamePrefix,
    IN ULONG NamePrefixLength,
    IN PDSNAME RidMgr,
    OUT PDSNAME RidMgrRef
    );

NTSTATUS
SampCreateRidManager(
    IN PDSNAME RidMgr
    );

NTSTATUS
SampUpdateRidManagerReference(
    IN PDSNAME RidMgrRef,
    IN PDSNAME RidMgr
    );

VOID
SampSetRoleOwner(
    PRIDINFO RidInfo,
    PDSNAME RidObject
    );

VOID
SampSetRidPoolAvailable(
    PRIDINFO RidInfo,
    ULONG high,
    ULONG low
    );

VOID
SampSetRidFlags(
    PRIDINFO RidInfo,
    RIDFLAG Flags
    );

NTSTATUS
SampUpdateRidManager(
    IN PDSNAME RidMgr,
    IN PRIDINFO RidInfo
    );

VOID
SampSetRidPoolAllocated(
    PRIDINFO RidInfo,
    ULONG high,
    ULONG low
    );

VOID
SampSetRidPoolPrevAlloc(
    PRIDINFO RidInfo,
    ULONG high,
    ULONG low
    );

VOID
SampSetRidPoolUsed(
    PRIDINFO RidInfo,
    ULONG high,
    ULONG low
    );

VOID
SampSetRid(
    PRIDINFO RidInfo,
    ULONG NextRid
    );

NTSTATUS
SampUpdateRidObject(
    IN PDSNAME RidObj,
    IN PRIDINFO RidInfo,
    IN BOOLEAN fLazyCommit,
    IN BOOLEAN fAuthoritative
    );

NTSTATUS
SampReadRidManagerInfo(
    IN PDSNAME RidMgr,
    OUT PRIDINFO RidInfo
    );

VOID
SampDumpRidInfo(
    PRIDINFO RidInfo
    );

NTSTATUS
SampReadRidObjectInfo(
    IN PDSNAME RidObj,
    OUT PRIDINFO RidInfo
    );

NTSTATUS
SampReadRidManagerReferenceInfo(
    IN PDSNAME RidMgrRef,
    OUT PRIDINFO RidInfo
    );

NTSTATUS
SampGetNextRid(
    IN PSAMP_OBJECT DomainContext,
    PULONG Rid
    );

NTSTATUS
SampDomainRidInitialization(
    IN BOOLEAN fSynchronous
    );

NTSTATUS
SampDomainAsyncRidInitialization(
    PVOID p OPTIONAL
    );

NTSTATUS
SampDomainRidUninitialization(
    VOID
    );

NTSTATUS
SampGetNextRid(
    IN PSAMP_OBJECT DomainContext,
    OUT PULONG Rid
    );

NTSTATUS
SampAllowAccountCreation(
    IN PSAMP_OBJECT Context,
    IN NTSTATUS FailureStatus
    );

NTSTATUS
SampAllowAccountModification(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampAllowAccountDeletion(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SamIFloatingSingleMasterOp(
    IN PDSNAME RidManager,
    IN ULONG OpCode
    );

NTSTATUS
SamIFloatingSingleMasterOpEx(
    IN  PDSNAME  RidManager,
    IN  PDSNAME  TargetDsa,
    IN  ULONG    OpCode,
    IN  ULARGE_INTEGER *ClientAllocPool,
    OUT PDSNAME **ObjectArray OPTIONAL
    );

NTSTATUS
SamIDomainRidInitialization(
    VOID
    );

NTSTATUS
SamIGetNextRid(
    IN SAMPR_HANDLE DomainHandle,
    OUT PULONG Rid
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\rundown.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    rundown.c

Abstract:

    This file contains context handle rundown services
    related to the SAM server RPC interface package..


Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////






void
SAMPR_HANDLE_rundown(
    IN SAMPR_HANDLE SamHandle
    )

/*++

Routine Description:

    This service is called if a binding breaks when a context_handle is
    still active.

    Note that the RPC runtime will eliminate any race condition caused
    by an outstanding call to the server with this context handle that
    might cause the handle to become invalid before the rundown routine
    is called.

Arguments:

    SamHandle - The context handle value whose context must be rundown.
        Note that as far as RPC is concerned, this handle is no longer
        valid at the time the rundown call is made.

Return Value:


    None.


--*/
{

    NTSTATUS NtStatus;
    PSAMP_OBJECT Context;
    SAMP_OBJECT_TYPE FoundType;

    Context = (PSAMP_OBJECT)(SamHandle);



    SampAcquireReadLock();

    //
    // Lookup the context block
    //

    NtStatus = SampLookupContext(
                   Context,                           // Context
                   SAMP_CLOSE_OPERATION_ACCESS_MASK,  // DesiredAccess
                   SampUnknownObjectType,             // ExpectedType
                   &FoundType                         // FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

            // TEMPORARY
            //DbgPrint("Rundown of  ");
            //if (FoundType == SampServerObjectType) DbgPrint("Server ");
            //if (FoundType == SampDomainObjectType) DbgPrint("Domain ");
            //if (FoundType == SampGroupObjectType) DbgPrint("Group ");
            //if (FoundType == SampUserObjectType) DbgPrint("User ");
            //DbgPrint("context.\n");
            //DbgPrint("    Handle Value is:    0x%lx\n", Context );
            //if (Context->ReferenceCount != 2) {
            //DbgPrint("    REFERENCE COUNT is: 0x%lx\n", Context->ReferenceCount);
            //}
            // TEMPORARY

        //
        // Delete this context...
        //

        SampDeleteContext( Context );


        //
        // And drop our reference from the lookup operation
        //

        SampDeReferenceContext( Context, FALSE);


    }


    SampReleaseReadLock();


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\samaudit.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    SAMAUDIT.C
    
Abstract:

    SAM Auditing Theory of Operation
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    There exists no single unified auditing model in SAM.  The model used
    depends on the type of change being audited and the mode of operation 
    (DS vs Registry).
    
    
    General Audits
    ~~~~~~~~~~~~~~
    
    Each object type has a "general audit" defined in msaudite.mc for 
    creation, change, and deletion.  Creation and change operations that 
    involve an audited attribute will generate the associated audit.  If 
    the creation or change includes any security relevant attributes then 
    the new value for that attribute will be included in the audit.  Refer 
    to Mappings.c where each object's attribute mapping table includes flags 
    describing what types of auditing are performed for the attribute. 
        
    Registry Mode:
        
        In registry mode all updates come through SAM RPC.  Each object type
        has several routines that handle RPC creation, change, and deletion 
        audits.  Any pertinent information collected in the RPC call is passed
        to the auditing routine including the object context.  All necessary
        information to perform the audit is collected.  The appropriate audit
        ID is determined.  Depending on the information class associated with 
        the RPC call the relevant attribute value information is collected 
        in an object type specific structure the underlying auditing interface 
        can process (see lsaisrv.h).  All of this information is then passed 
        to the auditing interface. 
        
    DS Mode:
    
        In DS mode changes can include both attributes that go through 
        loopback for validation as well as NonSamWriteAllowed attributes
        which the DS core validates.  For this reason the auditing 
        infrastructure resides largely in the core (SampAuditAddNotifications
        in mappings.c).  As there may be multiple calls through the DS to 
        make the entire change associated with the transaction the information
        necessary to perform any audit(s) is collected when the changes are
        written but before they are commited.  New value information is 
        collected based on the flags in the attribute's mapping table entry 
        and stored in an object type specific data structure.  This 
        information is queued on the THSTATE in an audit notification.  
                
        When the transaction commits the queue is processed 
        (SampProcessAuditNotifications in mappings.c) and the appropriate 
        audit routine(s) from this file are invoked in samsrv.dll.  The 
        auditing routine in this file determines the audit ID and invokes
        the underlying audit interface passing all of the above information.
        
        This mechanism is the same for SAM RPC modifications as well as LDAP
        modifications.
        
          
    Dedicated audits
    ~~~~~~~~~~~~~~~~             
              
    Changes that are considered extremely interesting from a repudiation 
    standpoint can generate "dedicated audits" (ie. a password change or 
    enabling a user account). 
    
    Dedicated routines exist in this file to support each dedicated audit.
    These routines are invoked at the time the relevant change is made.
    
    Registry mode and DS mode are unified for these audits by SampAuditAnyEvent.
    The auditing routine performs any processing on its inputs and invokes 
    SampAuditAnyEvent.
    
            
    Registry Mode:
    
        SampAuditAnyEvent will issue the audit directly to the auditing 
        interface.
         
            
    DS Mode:         
         
        SampAuditAnyEvent will queue the audit information on the THSTATE
        as a loopback task.  The loopback task queue is distinct from the 
        audit notification queue discussed above for general audits. 
        Loopback tasks are processed when the transaction commits (see
        SampProcessLoopbackTasks in mappings.c).  This routine calls into
        samsrv.dll to collect any auditing information from the task entry
        and invokde the underlying auditing interface.
        
    
    Note: In all cases above, none of the auditing logic is executed unless 
          SAM auditing is enabled.
    
           
    Issues: It is important to note that audits can require information from 
            different points in time.  First, sometimes it is useful to
            capture information at the time the modification is about
            to occur (i.e. the previous value of an attribute for later
            comparison with the new value).  Secondly, often it is necessary
            to aquire information at the time change will commit (i.e. the
            new value of modified attributes).  Most audits do not require 
            information from the first time window.  
            
            A notable exception is the user account control.  This attribute 
            packs many logical attributes into one.  It would be useful to 
            know the old and new value at the time the audit is written to 
            easily determine the actual delta.  
            
            The dedicated audit model allows for collection of information 
            at the time the audited change is about to occur, while the
            general audit model allows for doing so when the audit is about
            to be written.  The ideal auditing mechanism would allow us to 
            update information at a location available throughout the 
            transaction lifetime on a per audit basis.
            
            One possible extension would be to export from ntdsa.dll a method
            for accessing such memory.  In this way information could be 
            collected throughout the transaction for processing and consumption
            upon commit. 
            
            Furthermore, implementing some simple infrastructure in registry 
            mode to mirror this functionality and wrapping the mode specific
            decision of which mechanism to use would enable a single unified
            model for all SAM auditing.  The scope of this change is beyond
            the requirements and schedule at this time.
    
Author:

    18-June-1999     ShaoYin
    
Revision History:

    27-Mar-2002      BillyJ - Support for NonSamWriteAllowed attributes as 
                              well as new value collection for auditing 
                              security sensitive changes.  See file header
                              comment for details including references to
                              supporting architecture in the core DS.
                              Documented auditing theory of operation.

--*/

//
//
//  Include header files
//
// 

#include <samsrvp.h>
#include <msaudite.h> // Audit schema definitions
#include <stdlib.h>
#include <attids.h>   // ATT_*
#include <dslayer.h>  // DSAlloc
#include <strsafe.h>  // Safe string routines

         

//
// Imported routine prototypes
//                  
NTSTATUS
SampRetrieveUserLogonHours(
    IN PSAMP_OBJECT Context,
    OUT PLOGON_HOURS LogonHours
    );          


//
// Localized string cache entry
//
typedef struct _SAMP_AUDIT_MESSAGE_TABLE {

    ULONG   MessageId;
    PWCHAR  MessageString;

}   SAMP_AUDIT_MESSAGE_TABLE;


//
// the following table is used to hold Message String for
// each every additional audit message text SAM wants to 
// put into the audit event.
//
// this table will be filled whenever needed. Once loaded
// SAM won't free them, instead, SAM will keep using the 
// Message String from the table. So that we can save 
// time of calling FormatMessage()
// 

SAMP_AUDIT_MESSAGE_TABLE    SampAuditMessageTable[] =
{
    {SAMMSG_AUDIT_ENABLED_LOCAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_ENABLED_LOCAL_GROUP_TO_DISABLED_LOCAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_ENABLED_LOCAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_ENABLED_GLOBAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_ENABLED_GLOBAL_GROUP_TO_DISABLED_GLOBAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_ENABLED_GLOBAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_ENABLED_LOCAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_ENABLED_GLOBAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_DISABLED_LOCAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_DISABLED_GLOBAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_LOCAL_GROUP_TO_ENABLED_LOCAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_LOCAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_LOCAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_GLOBAL_GROUP_TO_ENABLED_GLOBAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_GLOBAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_GLOBAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_ENABLED_LOCAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_ENABLED_GLOBAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_DISABLED_LOCAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_DISABLED_GLOBAL_GROUP, 
     NULL },

    {SAMMSG_AUDIT_MEMBER_ACCOUNT_NAME_NOT_AVAILABLE, 
     NULL },

    {SAMMSG_AUDIT_ACCOUNT_ENABLED, 
     NULL },

    {SAMMSG_AUDIT_ACCOUNT_DISABLED, 
     NULL },

    {SAMMSG_AUDIT_ACCOUNT_CONTROL_CHANGE, 
     NULL },

    {SAMMSG_AUDIT_ACCOUNT_NAME_CHANGE, 
     NULL },

    {SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_PWD,
     NULL },

    {SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_LOGOFF,
     NULL },

    {SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_OEM,
     NULL },

    {SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_REPLICATION,
     NULL },

    {SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_SERVERROLE,
     NULL },

    {SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_STATE,
     NULL },

    {SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_LOCKOUT,
     NULL }, 

    {SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_MODIFIED,
     NULL },

    {SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_DOMAINMODE,
     NULL },

    {SAMMSG_AUDIT_BASIC_TO_QUERY_GROUP,
     NULL },

    {SAMMSG_AUDIT_QUERY_TO_BASIC_GROUP,
     NULL }  
};


ULONG   cSampAuditMessageTable = sizeof(SampAuditMessageTable) /
                                    sizeof(SAMP_AUDIT_MESSAGE_TABLE);



PWCHAR
SampGetAuditMessageString(
    ULONG   MessageId
    )
/*++
Routine Description:

    This routine will get the message text for the passed in 
    message ID.
    
    It will only search in the SampAuditMessageTable. If the 
    message string for the message ID has been loaded, then 
    return the message string immediately. Otherwise, load the
    message string the SAMSRV.DLL, and save the message string
    in the table. 

    if can't find the message ID from the table, return NULL.
    
Parameters:

    MessageId -- MessageID for the message string interested.

Return Value:
    
    Pointer to the message string. 
    
    Caller SHOULD NOT free the message string. Because the 
    string is in the table. We want to keep it.    
        
--*/
{
    HMODULE ResourceDll;
    PWCHAR  MsgString = NULL;
    ULONG   Index;
    ULONG   Length = 0;
    BOOL    Status;


    for (Index = 0; Index < cSampAuditMessageTable; Index++)
    {
        if (MessageId == SampAuditMessageTable[Index].MessageId)
        {
            if (NULL != SampAuditMessageTable[Index].MessageString)
            {
                MsgString = SampAuditMessageTable[Index].MessageString;
            }
            else
            {
                //
                // not finding the message string from the table.
                // try to load it
                // 
                ResourceDll = (HMODULE) LoadLibrary(L"SAMSRV.DLL");

                if (NULL == ResourceDll)
                {
                    return NULL;
                }

                Length = (USHORT) FormatMessage(
                                        FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        ResourceDll,
                                        MessageId,
                                        0,          // Use caller's language
                                        (LPWSTR)&MsgString,
                                        0,          // routine should allocate
                                        NULL        // Insertion string 
                                        );

                if (Length > 1 && MsgString)
                {
                    // message text has "cr" and "lf" in the end
                    MsgString[Length - 2] = L'\0';
                    SampAuditMessageTable[Index].MessageString = MsgString;
                }
                else
                {
                    // Force NULL on error just in case FormatMessage touches it.
                    MsgString = NULL;
                }   

                Status = FreeLibrary(ResourceDll);
                ASSERT(Status);
            }
            return (MsgString);
        }
    }

    return (NULL);
}


NTSTATUS
SampAuditAnyEvent(
    IN PSAMP_OBJECT         AccountContext,
    IN NTSTATUS             Status,
    IN ULONG                AuditId,
    IN PSID                 DomainSid,
    IN PUNICODE_STRING      AdditionalInfo    OPTIONAL,
    IN PULONG               MemberRid         OPTIONAL,
    IN PSID                 MemberSid         OPTIONAL,
    IN PUNICODE_STRING      AccountName       OPTIONAL,
    IN PUNICODE_STRING      DomainName,
    IN PULONG               AccountRid        OPTIONAL,
    IN PPRIVILEGE_SET       Privileges        OPTIONAL,
    IN PVOID                NewValueInfo      OPTIONAL
    )
/*++

Routine Description:

    This routine is a wrapper of auditing routines, it calls different
    worker routines based on the client type. For loopback client and 
    the status is success so far, insert this auditing task into 
    Loopback Task Queue in thread state, which will be either
    performed or aborted when the transaction done.  That is because 
    
    For SAM Client, since the transaction has been committed already, 
    go ahead let LSA generate the audit event. 

    If the status is not success, and caller still wants to audit this 
    event, perform the auditing immediately.  
    
Paramenters:

    Same as the worker routine
    
Return Values:

    NtStatus         

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    if (NT_SUCCESS(Status) && AccountContext->LoopbackClient)
    {
        NtStatus = SampAddLoopbackTaskForAuditing(
                        Status,         // Status
                        AuditId,        // Audit Id
                        DomainSid,      // Domain SID
                        AdditionalInfo, // Additional Info
                        MemberRid,      // Member Rid
                        MemberSid,      // Member Sid
                        AccountName,    // Account Name
                        DomainName,     // Domain Name
                        AccountRid,     // Account Rid
                        Privileges,     // Privileges used
                        NewValueInfo    // New value information
                        );
    }
    else
    {
        NtStatus = LsaIAuditSamEvent(
                        Status,         // Status
                        AuditId,        // Audit Id
                        DomainSid,      // Domain SID
                        AdditionalInfo, // Additional Info
                        MemberRid,      // Member Rid
                        MemberSid,      // Member Sid
                        AccountName,    // Account Name
                        DomainName,     // Domain Name
                        AccountRid,     // Account Rid
                        Privileges,     // Privileges used
                        NewValueInfo    // New value information
                        );
    }

    return(NtStatus);
}   


NTSTATUS
SampMaybeLookupContextForAudit(
    IN PSAMP_OBJECT Context,
    OUT BOOL *MustDeReference
    )
/*++
Routine Description:

    This routine references a context if it is not already referenced and
    valid.  It is designed to be used when the state of the context is unknown
    but the caller wants to perform a read operation.
    
    This routine should be called to ensure a context is properly referenced
    and valid prior to performing a read on any variable or fixed attributes
    in the OnDisk.  If the context is not valid it is referenced and an out
    parameter is set indicating the caller must dereference the context.  The
    dereference should not set the Commit argument as this routine is only
    intended for use in reading from contexts that are not owned by the caller.
    
    The reason for this is that performing a lookup on a context that is 
    already referenced and dirty will cause corruption if the most nested
    reference does not set the commit flag upon dereferencing. 
    
    If the context is referenced the desired access requested is 0.  This 
    routine is only called by trusted callers and doing so skips access checks.
    
    The following is a requirement of SampLookupContext which may be invoked.

    THIS ROUTINE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.
    (For Loopback Client, the SAM Lock is not a requirement)      
    
Parameters:

    Context -- Object context
    
    MustDeReference -- A boolean set indicating if the context must be
                       dereferenced.
    
Return Values:

    STATUS_SUCCESS -- The context is valid and may be used.  MustDeReference
                      is set to TRUE if the context should be dereferenced
                      using SampDeReferenceContext, otherwise it is set to 
                      FALSE.
                      
    Errors returned from SampLookupContext.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    SAMP_OBJECT_TYPE FoundType = SampUnknownObjectType;
    
    ASSERT(Context->LoopbackClient || SampCurrentThreadOwnsLock());
    
    //
    // Initialize out parameter indicating no dereference necessary
    //
    *MustDeReference = FALSE;

    //
    // Have any changes been made using this context
    //
    if (Context->FixedDirty || Context->VariableDirty) {
        //
        // A dirty context must have a valid OnDisk and must have a 
        // reference count of either
        //     1   - The creation case
        //     >1  - Initial SAM reference plus any others
        //
        // Only the portion of the OnDisk that is dirty must be valid.
        // The fact the context is referenced will ensure that a read
        // of either fixed or variable attributes that aren't valid will
        // cause a load of those attributes.
        //
        if (Context->FixedDirty) {
            ASSERT(Context->FixedValid || 
                (Context->VariableValid && Context->VariableDirty)); 
        }
        
        if (Context->VariableDirty) {
            ASSERT(Context->VariableValid);
        }
        
        ASSERT(Context->ReferenceCount >= 1);
        
    } else {
        //
        // No changes have been made using this context.  We only need to
        // reference the context if the OnDisk is not valid. 
        //
        if (Context->FixedValid && Context->VariableValid) {
            //
            // Any context that is not dirty and has a valid OnDisk must 
            // either have a reference count >1 or has PersistAcrossCalls set
            // and a reference count >= 1.
            //
            ASSERT(Context->ReferenceCount > 0);
            
        } else {
            //
            // The OnDisk is not valid, reference the context and set out parm
            //
            NtStatus = SampLookupContext(
                       Context,
                       0L,
                       SampUnknownObjectType,           
                       &FoundType
                       );
        
            if (NT_SUCCESS(NtStatus)) {
                *MustDeReference = TRUE;
            } 
        }
    }
    
    return NtStatus;
    
}


VOID
SampAuditGroupTypeChange(
    PSAMP_OBJECT GroupContext, 
    BOOLEAN OldSecurityEnabled, 
    BOOLEAN NewSecurityEnabled, 
    NT5_GROUP_TYPE OldNT5GroupType, 
    NT5_GROUP_TYPE NewNT5GroupType
    )
/*++
Routine Description:

    This routine audits SAM group type change.

Parameters:

    GroupContext -- Group (univeral, globa or local) Context
    
    OldSecurityEnabled -- Indicate the group is security enabled or 
                          not prior to the change 
    
    NewSecurityEnabled -- Indicate the group is security enabled or 
                          not after the change

    OldNT5GroupType -- Group Type before the change
                              
    NewNT5GroupType -- Group Type after the change                          

Return Value:

    None.    
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSAMP_DEFINED_DOMAINS Domain = NULL;
    SAMP_OBJECT_TYPE    ObjectType;
    UNICODE_STRING      GroupTypeChange, GroupName;
    PWCHAR      GroupTypeChangeString = NULL;
    ULONG       MsgId = SAMMSG_AUDIT_ENABLED_LOCAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP;
    ULONG       GroupRid;
    NTSTATUS IgnoreStatus;
    BOOL fDereferenceContext = FALSE;

    //
    // Determine the nature of the group type change
    // 
    if (OldSecurityEnabled)
    {
        switch (OldNT5GroupType) {
        case NT5ResourceGroup: 
            if (NewSecurityEnabled)
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    ASSERT(FALSE && "No Change\n");
                    return;
                case NT5AccountGroup:
                    ASSERT(FALSE && "Local ==> Global\n");
                    return;
                case NT5UniversalGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_LOCAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP;
                    break;
                default:
                    ASSERT(FALSE && "Invalid Group Type\n");
                    return;
                }
            }
            else
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_LOCAL_GROUP_TO_DISABLED_LOCAL_GROUP;
                    break;
                case NT5AccountGroup:
                    ASSERT(FALSE && "Local ==> Global\n");
                    return;
                case NT5UniversalGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_LOCAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP;
                    break;
                default:
                    ASSERT(FALSE && "Invalid Group Type\n");
                    return;
                }
            }
            break;
        case NT5AccountGroup:
            if (NewSecurityEnabled)
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    ASSERT(FALSE && "Global ==> Local\n");
                    return;
                case NT5AccountGroup:
                    ASSERT(FALSE && "No Change\n");
                    return;
                case NT5UniversalGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_GLOBAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP;
                    break;
                default:
                    ASSERT(FALSE && "Invalid Group Type\n");
                    return;
                }
            }
            else
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    ASSERT(FALSE && "Global ==> Local\n");
                    return;
                case NT5AccountGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_GLOBAL_GROUP_TO_DISABLED_GLOBAL_GROUP;
                    break;
                case NT5UniversalGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_GLOBAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP;
                    break;
                default:
                    ASSERT(FALSE && "Invalid Group Type\n");
                    return;
                }
            }
            break;
        case NT5UniversalGroup:
            if (NewSecurityEnabled)
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_ENABLED_LOCAL_GROUP; 
                    break;
                case NT5AccountGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_ENABLED_GLOBAL_GROUP; 
                    break;
                case NT5UniversalGroup:
                    ASSERT(FALSE && "No Change\n");
                    return;
                default:
                    ASSERT(FALSE && "Invalid Group Type\n");
                    return;
                }
            }
            else
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_DISABLED_LOCAL_GROUP;
                    break;
                case NT5AccountGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_DISABLED_GLOBAL_GROUP;
                    break;
                case NT5UniversalGroup:
                    MsgId = SAMMSG_AUDIT_ENABLED_UNIVERSAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP;
                    break;
                default:
                    ASSERT(FALSE && "Invalid Group Type\n");
                    return;
                }
            }
            break;
        default:
            ASSERT(FALSE && "Invalid Group Type\n");
            return;
        }
    }
    else
    {
        switch (OldNT5GroupType) {
        case NT5ResourceGroup: 
            if (NewSecurityEnabled)
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_LOCAL_GROUP_TO_ENABLED_LOCAL_GROUP;
                    break;
                case NT5AccountGroup:
                    ASSERT(FALSE && "Local ==> Global\n");
                    return;
                case NT5UniversalGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_LOCAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP;
                    break;
                default:
                    ASSERT(FALSE && "Invalid Group Type\n");
                    return;
                }
            }
            else
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    ASSERT(FALSE && "No Change\n");
                    return;
                case NT5AccountGroup:
                    ASSERT(FALSE && "Local ==> Global\n");
                    return;
                case NT5UniversalGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_LOCAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP;
                    break;
                default:
                    ASSERT(FALSE && "Invalid Group Type\n");
                    return;
                }
            }
            break;
        case NT5AccountGroup:
            if (NewSecurityEnabled)
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    ASSERT(FALSE && "Global ==> Local\n");
                    return;
                case NT5AccountGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_GLOBAL_GROUP_TO_ENABLED_GLOBAL_GROUP;
                    break;
                case NT5UniversalGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_GLOBAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP;
                    break;
                default:
                    ASSERT(FALSE && "Invalid Group Type\n");
                    return;
                }
            }
            else
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    ASSERT(FALSE && "Global ==> Local\n");
                    return;
                case NT5AccountGroup:
                    ASSERT(FALSE && "No Change\n");
                    return;
                case NT5UniversalGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_GLOBAL_GROUP_TO_DISABLED_UNIVERSAL_GROUP;
                    break;
                default:
                    ASSERT(FALSE && "Invalid Group Type\n");
                    return;
                }
            }
            break;
        case NT5UniversalGroup:
            if (NewSecurityEnabled)
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_ENABLED_LOCAL_GROUP; 
                    break;
                case NT5AccountGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_ENABLED_GLOBAL_GROUP; 
                    break;
                case NT5UniversalGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_ENABLED_UNIVERSAL_GROUP;
                    break;
                default:
                    ASSERT(FALSE && "Invalid Group Type\n");
                    return;
                }
            }
            else
            {
                switch (NewNT5GroupType) {
                case NT5ResourceGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_DISABLED_LOCAL_GROUP;
                    break;
                case NT5AccountGroup:
                    MsgId = SAMMSG_AUDIT_DISABLED_UNIVERSAL_GROUP_TO_DISABLED_GLOBAL_GROUP;
                    break;
                case NT5UniversalGroup:
                    ASSERT(FALSE && "No Change\n");
                    return;
                default:
                    ASSERT(FALSE && "Invalid Group Type\n");
                    return;
                }
            }
            break;

        case NT5AppBasicGroup:

            if (NewNT5GroupType == NT5AppQueryGroup) {
                MsgId = SAMMSG_AUDIT_BASIC_TO_QUERY_GROUP;
            } else {
                ASSERT(FALSE && "Invalid Group Type\n");
                return;
            }
            break;

        case NT5AppQueryGroup:

            if (NewNT5GroupType == NT5AppBasicGroup) {
                MsgId = SAMMSG_AUDIT_QUERY_TO_BASIC_GROUP;
            } else {
                ASSERT(FALSE && "Invalid Group Type\n");
                return;
            }
            break;

        default:
            ASSERT(FALSE && "Invalid Group Type\n");
            return;
        }
    }

    //
    // Get the group type change message from resource table 
    // 

    GroupTypeChangeString = SampGetAuditMessageString(MsgId);

    if (GroupTypeChangeString)
    {
        RtlInitUnicodeString(&GroupTypeChange, GroupTypeChangeString);
    }
    else
    {
        RtlInitUnicodeString(&GroupTypeChange, L"-");
    }
    
    //
    // Reference the context if needed
    //  
    NtStatus = SampMaybeLookupContextForAudit(
                   GroupContext,
                   &fDereferenceContext
                   );
    
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    } 
    
    //
    // Get Group Account Rid
    // 
    if (SampGroupObjectType == GroupContext->ObjectType)
    {
        GroupRid = GroupContext->TypeBody.Group.Rid;
    }
    else
    {
        GroupRid = GroupContext->TypeBody.Alias.Rid;
    }
    
    //
    // Get Group Account Name
    // 
    Domain = &SampDefinedDomains[ GroupContext->DomainIndex ];

    memset(&GroupName, 0, sizeof(GroupName));
    NtStatus = SampGetUnicodeStringAttribute(
                        GroupContext,
                        (SampGroupObjectType == GroupContext->ObjectType) ? 
                            SAMP_GROUP_NAME : SAMP_ALIAS_NAME,
                        FALSE,
                        &GroupName
                        );

    if (!NT_SUCCESS(NtStatus) ||
        (NULL == GroupName.Buffer)) {
        RtlInitUnicodeString(&GroupName, L"-");
    }

    SampAuditAnyEvent(
        GroupContext,
        STATUS_SUCCESS,
        SE_AUDITID_GROUP_TYPE_CHANGE,   // Audit Id
        Domain->Sid,                    // Domain SID
        &GroupTypeChange,
        NULL,                           // Member Rid (not used)
        NULL,                           // Member Sid (not used)
        &GroupName,                     // Account Name
        &Domain->ExternalName,          // Domain
        &GroupRid,                      // Account Rid
        NULL,                           // Privileges used
        NULL                            // New Value Information
        );
    
Cleanup:

    if (fDereferenceContext) {
        IgnoreStatus = SampDeReferenceContext(GroupContext, FALSE);
        ASSERT(NT_SUCCESS(IgnoreStatus));    
    } 

    return;
}
    

VOID
SampAuditGroupMemberChange(
    IN PSAMP_OBJECT GroupContext, 
    IN BOOLEAN AddMember, 
    IN PWCHAR  MemberStringName OPTIONAL,
    IN PULONG  MemberRid  OPTIONAL,
    IN PSID    MemberSid  OPTIONAL
    )
/*++
Routine Description:

    This routine takes care of all kinds of Group Member update.

Arguments:

    GroupContext -- Pointer to Group Object Context

    AddMember -- TRUE: Add a Member 
                 FALSE: Remove a Member

    MemberStringName -- If present, it's the member account's 
                        string name                 

    MemberRid -- Pointer to the member account's RID if present.                        

    MemberSid -- Pointer to the member account's SID if present  
    
Return Value:

    None.
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSAMP_DEFINED_DOMAINS   Domain = NULL;     
    SAMP_OBJECT_TYPE        ObjectType; 
    UNICODE_STRING          GroupName;
    UNICODE_STRING          MemberName;
    NT5_GROUP_TYPE          NT5GroupType; 
    BOOLEAN     SecurityEnabled;
    ULONG       GroupRid;
    ULONG       AuditId;
    NTSTATUS IgnoreStatus;
    BOOL fDereferenceContext = FALSE;
    
    //
    // Reference the context if needed
    //  
    NtStatus = SampMaybeLookupContextForAudit(
                   GroupContext,
                   &fDereferenceContext
                   );
    
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    } 
    
    Domain = &SampDefinedDomains[GroupContext->DomainIndex];


    if (SampGroupObjectType == GroupContext->ObjectType)
    {
        ASSERT(ARGUMENT_PRESENT(MemberRid));

        GroupRid = GroupContext->TypeBody.Group.Rid;
        SecurityEnabled = GroupContext->TypeBody.Group.SecurityEnabled;
        NT5GroupType = GroupContext->TypeBody.Group.NT5GroupType;

    }
    else
    {
        ASSERT(SampAliasObjectType == GroupContext->ObjectType);
        ASSERT(ARGUMENT_PRESENT(MemberSid));

        GroupRid = GroupContext->TypeBody.Alias.Rid;
        SecurityEnabled = GroupContext->TypeBody.Alias.SecurityEnabled;
        NT5GroupType = GroupContext->TypeBody.Alias.NT5GroupType;
    }


    if (AddMember)
    {
        if (SecurityEnabled)
        {
            switch (NT5GroupType) {
            case NT5ResourceGroup:
                AuditId = SE_AUDITID_LOCAL_GROUP_ADD;
                break;
            case NT5AccountGroup:
                AuditId = SE_AUDITID_GLOBAL_GROUP_ADD;
                break;
            case NT5UniversalGroup:
                AuditId = SE_AUDITID_SECURITY_ENABLED_UNIVERSAL_GROUP_ADD;
                break;
            default:
                ASSERT(FALSE && "Invalid Group Type\n");
                return;
            }
        }
        else
        {
            switch (NT5GroupType) {
            case NT5ResourceGroup:
                AuditId = SE_AUDITID_SECURITY_DISABLED_LOCAL_GROUP_ADD;
                break;
            case NT5AccountGroup:
                AuditId = SE_AUDITID_SECURITY_DISABLED_GLOBAL_GROUP_ADD;
                break;
            case NT5UniversalGroup:
                AuditId = SE_AUDITID_SECURITY_DISABLED_UNIVERSAL_GROUP_ADD;
                break;
            case NT5AppBasicGroup:
                AuditId = SE_AUDITID_APP_BASIC_GROUP_ADD;
                break;
            default:
                ASSERT(FALSE && "Invalid Group Type\n");
                return;
            }
        }
    }
    else
    {
        if (SecurityEnabled)
        {
            switch (NT5GroupType) {
            case NT5ResourceGroup:
                AuditId = SE_AUDITID_LOCAL_GROUP_REM;
                break;
            case NT5AccountGroup:
                AuditId = SE_AUDITID_GLOBAL_GROUP_REM;
                break;
            case NT5UniversalGroup:
                AuditId = SE_AUDITID_SECURITY_ENABLED_UNIVERSAL_GROUP_REM;
                break;
            default:
                ASSERT(FALSE && "Invalid Group Type\n");
                return;
            }
        }
        else
        {
            switch (NT5GroupType) {
            case NT5ResourceGroup:
                AuditId = SE_AUDITID_SECURITY_DISABLED_LOCAL_GROUP_REM;
                break;
            case NT5AccountGroup:
                AuditId = SE_AUDITID_SECURITY_DISABLED_GLOBAL_GROUP_REM;
                break;
            case NT5UniversalGroup:
                AuditId = SE_AUDITID_SECURITY_DISABLED_UNIVERSAL_GROUP_REM;
                break;
            case NT5AppBasicGroup:
                AuditId = SE_AUDITID_APP_BASIC_GROUP_REM;
                break;
            default:
                ASSERT(FALSE && "Invalid Group Type\n");
                return;
            }
        }
    }

    //
    // member name 
    // 
    if (ARGUMENT_PRESENT(MemberStringName))
    {
        RtlInitUnicodeString(&MemberName, MemberStringName);
    }
    else
    {
        RtlInitUnicodeString(&MemberName, L"-");
    }


    //
    // Group name
    // 
    memset(&GroupName, 0, sizeof(GroupName));
    NtStatus = SampGetUnicodeStringAttribute(
                        GroupContext,
                        (SampGroupObjectType == GroupContext->ObjectType) ? 
                            SAMP_GROUP_NAME : SAMP_ALIAS_NAME,
                        FALSE,
                        &GroupName
                        );

    if (!NT_SUCCESS(NtStatus) ||
        (NULL == GroupName.Buffer)) {
        RtlInitUnicodeString(&GroupName, L"-");
    }

    SampAuditAnyEvent(
        GroupContext,
        STATUS_SUCCESS,
        AuditId,              // Audit Event Id
        Domain->Sid,          // Domain SID
        &MemberName,          // Additional Info -- Member Name
        MemberRid,            // Member Rid is present 
        MemberSid,            // Member Sid is present
        &GroupName,           // Group Account Name
        &Domain->ExternalName,// Domain Name 
        &GroupRid,            // Group Rid
        NULL,                 // Privileges
        NULL                  // New value information
        );
    
Cleanup:

    if (fDereferenceContext) {
        IgnoreStatus = SampDeReferenceContext(GroupContext, FALSE);
        ASSERT(NT_SUCCESS(IgnoreStatus));    
    } 

    return;
}
      

VOID
SampAuditAccountEnableDisableChange(
    PSAMP_OBJECT AccountContext, 
    ULONG NewUserAccountControl, 
    ULONG OldUserAccountControl,
    PUNICODE_STRING AccountName
    )
/*++
Routine Description:

    This routine generates an audit dedicated to a user/computer account being
    enabled or disabled.  The general purpose routine SampAuditUserChange[Ds]
    will include the new value of all the user account control bits in the
    general change audit.
    
Arguments:

    AccountContext -- Pointer to User/Computer Account Context
    
    OldUserAccountControl -- UserAccountControl before the change
    
    NewUserAccountControl -- UserAccountControl after the change
    
    AccountName -- Pass in account name

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus;
    PSAMP_DEFINED_DOMAINS Domain = NULL;
    ULONG   AuditId = 0;    

    //
    // If the account's disabled or enabled state has not changed do not
    // generate an audit.
    // 
    if ((OldUserAccountControl & (ULONG) USER_ACCOUNT_DISABLED) == 
        (NewUserAccountControl & (ULONG) USER_ACCOUNT_DISABLED) )
    {
        return;
    }   

    Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];

    // 
    // Determine the dedicated audit Id based on Enbaled/Disabled change.
    // 
    if ( (OldUserAccountControl & USER_ACCOUNT_DISABLED) &&
        !(NewUserAccountControl & USER_ACCOUNT_DISABLED) )
    {
        AuditId = SE_AUDITID_USER_ENABLED; 
    }
    else if ( !(OldUserAccountControl & USER_ACCOUNT_DISABLED) &&
               (NewUserAccountControl & USER_ACCOUNT_DISABLED) )
    {
        AuditId = SE_AUDITID_USER_DISABLED; 
    }

    SampAuditAnyEvent(AccountContext,
                      STATUS_SUCCESS,
                      AuditId,
                      Domain->Sid,
                      NULL,
                      NULL,
                      NULL,
                      AccountName,
                      &Domain->ExternalName,
                      &AccountContext->TypeBody.User.Rid,
                      NULL,
                      NULL
                      );

    return;
}
    

VOID
SampAuditDomainChange(
    IN NTSTATUS StatusCode,
    IN PSID DomainSid, 
    IN PUNICODE_STRING DomainName,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    IN PSAMP_OBJECT DomainContext
    )
/*++
Routine Description:

    This routine audits Domain Policy changes made via SamrSetInformationDomain
    when in registry mode. 
    
Arguments:

    StatusCode - Status Code to log     

    DomainSid - Domain Object SID
    
    DomainName - Domain Name
    
    DomainInformationClass - indicate what policy property
    
    DomainContext - Context for this domain  

Return Value:

    None.

--*/
{
    ULONG       MsgId;
    PWCHAR      DomainPolicyChangeString = NULL;
    PWCHAR      Info = NULL;
    ULONG       Length;
    UNICODE_STRING  DomainPolicyChange;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN V1aFixed = NULL;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PWCHAR      Temp = NULL;
    ULONG       TempLength = 0;
    LPWSTR      AlteredStateString = NULL;
    UNICODE_STRING OemInformation;
    LSAP_AUDIT_DOMAIN_ATTR_VALUES AttrVals;
    NTSTATUS IgnoreStatus;
    BOOL fDereferenceContext = FALSE;
    
    //
    // This routine only manages the auditing in registry mode RPC calls.
    //
    if (SampUseDsData) {
        return;
    }
    
    //
    // Reference the context if needed
    //  
    NtStatus = SampMaybeLookupContextForAudit(
                   DomainContext,
                   &fDereferenceContext
                   );
    
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    } 
            
    //
    // Get the current fixed attributes 
    //       
    V1aFixed = &(SampDefinedDomains[ DomainContext->DomainIndex ].CurrentFixed);
    
    //
    // Determine the domain policy that was changed
    //
    switch (DomainInformationClass) {       
    case DomainPasswordInformation:
        MsgId = SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_PWD;
        break;
    case DomainLogoffInformation:
        MsgId = SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_LOGOFF;
        break;
    case DomainOemInformation:
        MsgId = SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_OEM;
        break;                        
    case DomainReplicationInformation:
        MsgId = SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_REPLICATION;
        break;
    case DomainServerRoleInformation:
        MsgId = SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_SERVERROLE;
        break;
    case DomainStateInformation:
        MsgId = SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_STATE;
        break;
    case DomainLockoutInformation:
        MsgId = SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_LOCKOUT;
        break;
    case DomainModifiedInformation2:
        MsgId = SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_MODIFIED;
        break;
    case DomainGeneralInformation:
    case DomainGeneralInformation2:
    case DomainNameInformation:
    case DomainModifiedInformation:
    case DomainUasInformation:
    default:
        return;
    }
    
    //
    // Get audit information string
    //
    DomainPolicyChangeString = SampGetAuditMessageString(MsgId);
        
    RtlZeroMemory(&AttrVals, sizeof(LSAP_AUDIT_DOMAIN_ATTR_VALUES));
   
    //
    // Collect attribute values based on the information class
    //     
    switch(DomainInformationClass) {

    case DomainPasswordInformation:
        
        AttrVals.MinPasswordLength = &V1aFixed->MinPasswordLength;
        AttrVals.PasswordHistoryLength = &V1aFixed->PasswordHistoryLength;
        AttrVals.PasswordProperties = &V1aFixed->PasswordProperties;
        AttrVals.MinPasswordAge = &V1aFixed->MinPasswordAge;
        AttrVals.MaxPasswordAge = &V1aFixed->MaxPasswordAge;
        
        AttrVals.AttrDeltaType[
            LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, MinPasswordLength)] =
            LsapAuditSamAttrNewValue;
        
        AttrVals.AttrDeltaType[
            LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, PasswordHistoryLength)] =
            LsapAuditSamAttrNewValue;
        
        AttrVals.AttrDeltaType[
            LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, PasswordProperties)] =
            LsapAuditSamAttrNewValue;
        
        AttrVals.AttrDeltaType[
            LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, MinPasswordAge)] =
            LsapAuditSamAttrNewValue;
        
        AttrVals.AttrDeltaType[
            LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, MaxPasswordAge)] =
            LsapAuditSamAttrNewValue;
                    
        break;
        
    case DomainLogoffInformation:
        
        AttrVals.ForceLogoff = &V1aFixed->ForceLogoff; 
        
        AttrVals.AttrDeltaType[
            LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, ForceLogoff)] =
            LsapAuditSamAttrNewValue;
        
        break;
        
    case DomainOemInformation:
        //
        // OemInformation attribute.
        //
        NtStatus = SampGetUnicodeStringAttribute(
                   DomainContext,
                   SAMP_DOMAIN_OEM_INFORMATION,
                   FALSE, // Do not make copy
                   &OemInformation
                   );
        
        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }
        
        //
        // Add the SAMP_USER_FULL_NAME attribute
        //
        AttrVals.OemInformation = &OemInformation;
        
        if (AttrVals.OemInformation->Length > 0) {
              
            AttrVals.AttrDeltaType[
                LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, OemInformation)] =
                    LsapAuditSamAttrNewValue; 
            
        } else {
            
            AttrVals.AttrDeltaType[
                LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, OemInformation)] =
                    LsapAuditSamAttrNoValue; 
        }    

        break;
        
    case DomainReplicationInformation:
        //
        // No audit requirement, or only an object access failure audit
        // is required.  We just maintain old behavior of generating a generic 
        // SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_REPLICATION audit without any 
        // attribute value information.
        //        
        break;
        
    case DomainServerRoleInformation:
        //
        // No audit requirement, or only an object access failure audit
        // is required.  We just maintain old behavior of generating a generic 
        // SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_SERVERROLE audit without any 
        // attribute value information.
        //
        break;
        
    case DomainStateInformation:
        //
        // No audit requirement, or only an object access failure audit
        // is required.  We just maintain old behavior of generating a generic 
        // SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_STATE audit without any 
        // attribute value information.
        //  
        break;
        
    case DomainLockoutInformation:
        
        AttrVals.LockoutDuration = &V1aFixed->LockoutDuration;
        AttrVals.LockoutObservationWindow = &V1aFixed->LockoutObservationWindow;
        AttrVals.LockoutThreshold = &V1aFixed->LockoutThreshold;
        
        AttrVals.AttrDeltaType[
            LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, LockoutDuration)] =
            LsapAuditSamAttrNewValue;
        
        AttrVals.AttrDeltaType[
            LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, LockoutObservationWindow)] =
            LsapAuditSamAttrNewValue;
        
        AttrVals.AttrDeltaType[
            LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, LockoutThreshold)] =
            LsapAuditSamAttrNewValue;
        
        break;
        
    case DomainModifiedInformation2:
        //
        // No audit requirement, or only an object access failure audit
        // is required.  We just maintain old behavior of generating a generic 
        // SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_MODIFIED audit without any 
        // attribute value information.
        //
        break;
        
        //
        // These information classes include no audited attributes, but are
        // included for completeness i.e. should the specification change.
        //
    case DomainGeneralInformation:
    case DomainGeneralInformation2:
    case DomainNameInformation:
    case DomainModifiedInformation:
    case DomainUasInformation:
        default:        
            //
            // Assert if there is an unhandled information level, it may
            // require auditing support.
            //
            ASSERT(FALSE &&
                   "Addition of new information class may require auditing");
            
        goto Cleanup;
    }         
        
    //
    // Initialize the additional information argument to the auditing API
    //
    if (DomainPolicyChangeString)
    {
        RtlInitUnicodeString(&DomainPolicyChange, DomainPolicyChangeString);
    }
    else
    {
        RtlInitUnicodeString(&DomainPolicyChange, L"-");
    }
    
    //
    // Loopback client will not call into this routine
    //  
    LsaIAuditSamEvent(
        StatusCode,
        SE_AUDITID_DOMAIN_POLICY_CHANGE,// Audit ID
        DomainSid,                      // Domain Sid
        &DomainPolicyChange,            // Indicate what policy property was changed
        NULL,                           // Member Rid (not used)
        NULL,                           // Member Sid (not used)
        NULL,                           // Account Name (not used)
        DomainName,                     // Domain
        NULL,                           // Account Rid (not used)
        NULL,                           // Privileges used (not used)
        (PVOID)&AttrVals                // New Value Information
        );
    
Cleanup:

    if (fDereferenceContext) {
        IgnoreStatus = SampDeReferenceContext(DomainContext, FALSE);
        ASSERT(NT_SUCCESS(IgnoreStatus));    
    } 
    
    return;
}     


VOID
SampAuditDomainChangeDs(
    IN ULONG DomainIndex,
    IN PVOID NewValueInfo
    )
/*++
Routine Description:

    This routine audits Domain attribute changes originated from 
    loopback client

Parameters:

    DomainContext - SampDefinedDomains index.

    NewValueInfo - Domain audit attribute value information.  This value is
                   NULL unless attributes were changed that have the audit
                   type bit SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES.

Return Values:

    Nothing.

--*/
{
    NTSTATUS IgnoreStatus;
    HRESULT hr = NO_ERROR;
    size_t StrLen;
    UNICODE_STRING AdditionalInfo;
    PWSTR AdditionalInfoString = NULL;
    PSAMP_DEFINED_DOMAINS Domain = NULL; 
    ULONG BufLength = 0;
    BOOL fAdditionalInfoSet = FALSE;
    BOOL fAuditWithoutAdditionalInfo = FALSE;
    PWCHAR Temp = NULL,
           OemInfo = NULL, 
           PwdInfo = NULL, 
           LogoffInfo = NULL, 
           LockoutInfo = NULL, 
           DomainModeInfo = NULL;
    LSAP_SAM_AUDIT_ATTR_DELTA_TYPE *AttrDeltas = NULL;
    
    //
    // Get a pointer to the domain this object is in.
    //                                        
    Domain = &SampDefinedDomains[DomainIndex];
    
    //
    // No attributes that require value information?  Skip to the audit.
    //
    if (NULL == NewValueInfo) {
        goto NoNewValues;
    }
    
    AttrDeltas = ((PLSAP_AUDIT_DOMAIN_ATTR_VALUES)NewValueInfo)->AttrDeltaType; 
    
    //
    // The audit includes an informational string that consists of a comma
    // delimited list of localized string descriptors indicating which 
    // policies were effected by the change.  Each policy maps to one or more
    // audited attributes.  If any one attribute associated with a policy has
    // changed then we'll include that policy's descriptor.
    //
    
    //
    // Check for Password policy changes
    //
    if (AttrDeltas[LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, 
                   MinPasswordAge)] != LsapAuditSamAttrUnchanged 
        ||
        AttrDeltas[LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, 
                   MaxPasswordAge)] != LsapAuditSamAttrUnchanged 
        ||
        AttrDeltas[LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, 
                   PasswordProperties)] != LsapAuditSamAttrUnchanged 
        ||
        AttrDeltas[LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, 
                   MinPasswordLength)] != LsapAuditSamAttrUnchanged
        ||
        AttrDeltas[LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, 
                   PasswordHistoryLength)] != LsapAuditSamAttrUnchanged) { 
        //
        // Get the localized password policy string descriptor
        //
        PwdInfo = SampGetAuditMessageString(
                      SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_PWD);
                       
        StrLen = 0;
    
        hr = StringCchLength(
                 PwdInfo,
                 MAXUSHORT,  // The strings are NULL terminated.
                 &StrLen
                 );
        
        if (SUCCEEDED(hr)) {
            // Account for storage and a possible seperator ', '
            BufLength += StrLen +2;
        }
    }
    
    //
    // Check for Logoff policy changes
    //                                
    if (AttrDeltas[LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, 
                   ForceLogoff)] != LsapAuditSamAttrUnchanged) { 
        //
        // Get the localized logoff policy string descriptor
        //
        LogoffInfo = SampGetAuditMessageString(
                         SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_LOGOFF);
            
        StrLen = 0;
                
        hr = StringCchLength(
                 LogoffInfo,
                 MAXUSHORT,  // The strings are NULL terminated.
                 &StrLen
                 );
        
        if (SUCCEEDED(hr)) {
            // Account for storage and a possible seperator ', '
            BufLength += StrLen +2;
        }   
    }
    
    //
    // Check for Lockout policy changes
    //
    if (AttrDeltas[LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, 
                   LockoutThreshold)] != LsapAuditSamAttrUnchanged 
        ||
        AttrDeltas[LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, 
                   LockoutObservationWindow)] != LsapAuditSamAttrUnchanged 
        ||
        AttrDeltas[LSAP_FIELD_PTR(LSAP_AUDIT_DOMAIN_ATTR_VALUES, 
                   LockoutDuration)] != LsapAuditSamAttrUnchanged) { 
        //
        // Get the localized lockout policy string descriptor
        //
        LockoutInfo = SampGetAuditMessageString(
                          SAMMSG_AUDIT_DOMAIN_POLICY_CHANGE_LOCKOUT);
                       
        StrLen = 0;
            
        hr = StringCchLength(
                 LockoutInfo,
                 MAXUSHORT,  // The strings are NULL terminated.
                 &StrLen
                 );
        
        if (SUCCEEDED(hr)) {
            // Account for storage and a possible seperator ', '
            BufLength += StrLen +2;
        }
    }        
    
    //
    // Build the final string policy change descriptor
    //
    if (BufLength)
    {
        // Account for a NULL terminator
        BufLength++;
        
        AdditionalInfoString = MIDL_user_allocate( BufLength * sizeof(WCHAR) );
        if (NULL == AdditionalInfoString)
        {         
            hr = E_FAIL;
            
        } else {
            
            RtlZeroMemory(AdditionalInfoString, BufLength * sizeof(WCHAR));    
        }
        
        if (PwdInfo && SUCCEEDED(hr))
        {       
            hr = StringCchCatW(AdditionalInfoString, BufLength, PwdInfo);

            if (SUCCEEDED(hr)) {
                                    
                fAdditionalInfoSet = TRUE;    
            }   
        }
        
        if (LogoffInfo && SUCCEEDED(hr))
        {
            if (fAdditionalInfoSet)
            {
                hr = StringCchCatW(AdditionalInfoString, BufLength, L", ");
            }
                
            if (SUCCEEDED(hr)) {
                
                hr = StringCchCatW(AdditionalInfoString, BufLength, LogoffInfo);

                if (SUCCEEDED(hr)) {
                                        
                    fAdditionalInfoSet = TRUE;    
                }     
            }    
        }
        
        if (LockoutInfo)
        {
            if (fAdditionalInfoSet)
            {
                hr = StringCchCatW(AdditionalInfoString, BufLength, L", ");
            }
            
            if (SUCCEEDED(hr)) {
                
                hr = StringCchCatW(AdditionalInfoString, BufLength, LockoutInfo);

                if (SUCCEEDED(hr)) {
                                        
                    fAdditionalInfoSet = TRUE;    
                }     
            } 
        }
    }
    
NoNewValues:    
    
    if (SUCCEEDED(hr) && AdditionalInfoString) {
        
        RtlInitUnicodeString(&AdditionalInfo, AdditionalInfoString);
        
    } else {
        
        RtlInitUnicodeString(&AdditionalInfo, L"-");
    }   
    
    // Ignore status
    LsaIAuditSamEvent(
        STATUS_SUCCESS,
        SE_AUDITID_DOMAIN_POLICY_CHANGE,
        Domain->Sid,
        &AdditionalInfo,
        NULL,
        NULL,
        NULL,
        &Domain->ExternalName,
        NULL,
        NULL,
        NewValueInfo
        );  

    if (AdditionalInfoString)
    {
        MIDL_user_free( AdditionalInfoString );
    }
    
    return;
    
}



VOID
SampAuditAccountNameChange(
    IN PSAMP_OBJECT     AccountContext,
    IN PUNICODE_STRING  NewAccountName,
    IN PUNICODE_STRING  OldAccountName
    )
/*++
Routine Description:

    This routine generates an Account Name Change audit. 
    it calls SampAuditAnyEvent().

Parameters:

    AccountContext - object context
    
    NewAccountName - pointer to new account name
    
    OldAccountName - pointer to old account name

Return Value:

    None
    
--*/
{
    PSAMP_DEFINED_DOMAINS   Domain = NULL;
    ULONG                   AccountRid;

    //
    // Get a pointer to the domain this object is in.
    // 

    Domain = &SampDefinedDomains[AccountContext->DomainIndex];

    //
    // Get AccountRid
    // 

    switch (AccountContext->ObjectType)
    {
    case SampUserObjectType:
        AccountRid = AccountContext->TypeBody.User.Rid;
        break;

    case SampGroupObjectType:
        AccountRid = AccountContext->TypeBody.Group.Rid;
        break;
        
    case SampAliasObjectType:
        AccountRid = AccountContext->TypeBody.Alias.Rid;
        break;

    default:
        ASSERT(FALSE && "Invalid object type\n");
        return;
    }


    SampAuditAnyEvent(AccountContext,   // AccountContext,
                      STATUS_SUCCESS,   // NtStatus
                      SE_AUDITID_ACCOUNT_NAME_CHANGE,  // AuditId,
                      Domain->Sid,      // DomainSid
                      OldAccountName,   // Additional Info
                      NULL,             // Member Rid
                      NULL,             // Member Sid
                      NewAccountName,   // AccountName
                      &Domain->ExternalName,    // Domain Name
                      &AccountRid,      // AccountRid
                      NULL,             // Privileges used
                      NULL              // New State Data
                      );

}


NTSTATUS
SampAuditGetGroupChangeAuditId( 
    ULONG GroupType,
    PULONG AuditId,
    IN BOOL Add
    )
/*++
Routine Description:

    This routine maps a SAM grouptype to an audit Id.  

Parameters:

    GroupType - The SAM group type being audited
    
    AuditId - Points to a ULONG that is set to the correct Audit Id.
              This value will be zero if the Audit Id could not be found.
              
    Add - Indicates whether this was a group creation or modification.              

Return Value:

    STATUS_SUCCESS on success.
    
    STATUS_UNSUCCESSFUL on failure.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    *AuditId = 0;
    
    if (GROUP_TYPE_SECURITY_ENABLED & GroupType)
    {
        if (GROUP_TYPE_RESOURCE_GROUP & GroupType)
        {   
            *AuditId = Add ? SE_AUDITID_LOCAL_GROUP_CREATED 
                : SE_AUDITID_LOCAL_GROUP_CHANGE;
        }
        else if (GROUP_TYPE_ACCOUNT_GROUP & GroupType)
        {
            *AuditId = Add ? SE_AUDITID_GLOBAL_GROUP_CREATED 
                : SE_AUDITID_GLOBAL_GROUP_CHANGE;
        }
        else if (GROUP_TYPE_UNIVERSAL_GROUP & GroupType)
        {
            *AuditId = Add ? SE_AUDITID_SECURITY_ENABLED_UNIVERSAL_GROUP_CREATED 
                : SE_AUDITID_SECURITY_ENABLED_UNIVERSAL_GROUP_CHANGE;
        }
        else
        {
            ASSERT(FALSE && "Invalid GroupType\n");
            NtStatus = STATUS_UNSUCCESSFUL;
        }
    }
    else
    {
        if (GROUP_TYPE_RESOURCE_GROUP & GroupType)
        {
            *AuditId = Add ? SE_AUDITID_SECURITY_DISABLED_LOCAL_GROUP_CREATED 
                : SE_AUDITID_SECURITY_DISABLED_LOCAL_GROUP_CHANGE; 
        }
        else if (GROUP_TYPE_ACCOUNT_GROUP & GroupType)
        {
            *AuditId = Add ? SE_AUDITID_SECURITY_DISABLED_GLOBAL_GROUP_CREATED
                : SE_AUDITID_SECURITY_DISABLED_GLOBAL_GROUP_CHANGE;
        }
        else if (GROUP_TYPE_UNIVERSAL_GROUP & GroupType)
        {
            *AuditId = Add ? SE_AUDITID_SECURITY_DISABLED_UNIVERSAL_GROUP_CREATED
                : SE_AUDITID_SECURITY_DISABLED_UNIVERSAL_GROUP_CHANGE;
        }
        else if (GROUP_TYPE_APP_BASIC_GROUP & GroupType)
        {
            *AuditId = Add ? SE_AUDITID_APP_BASIC_GROUP_CREATED 
                : SE_AUDITID_APP_BASIC_GROUP_CHANGE;
        }
        else if (GROUP_TYPE_APP_QUERY_GROUP & GroupType)
        {
            *AuditId = Add ? SE_AUDITID_APP_QUERY_GROUP_CREATED
                : SE_AUDITID_APP_QUERY_GROUP_CHANGE;
        }
        else
        {
            ASSERT(FALSE && "Invalid GroupType\n");
            NtStatus = STATUS_UNSUCCESSFUL;
        }
    }
     
    return NtStatus;
    
}


VOID
SampAuditGroupChange(
    IN ULONG DomainIndex, 
    IN PSAMP_OBJECT GroupContext, 
    IN PVOID InformationClass,
    IN BOOL IsAliasInformationClass,
    IN PUNICODE_STRING AccountName,
    IN PULONG AccountRid, 
    IN ULONG GroupType,
    IN PPRIVILEGE_SET Privileges OPTIONAL,
    IN BOOL Add
    )
/*++
Routine Description:

    This routine generates a alias or group change audit. 
    It is called only by RPC clients.

    RPC client - calls it from SamrSetInformationGroup / SamrSetInformationAlias
    
Parameter:

    DomainIndex -- indicates which domain the object belongs to

    InformationClass -- points to either an alias or group information class.
    
    IsAliasInformationClass -- indicates the type of InformationClass.
    
    AccountName -- pointer to account name.
    
    AcountRid -- pointer to account rid 

    GroupType -- indicates the group type, used to pick up audit ID
    
    Privileges -- Non-NULL value points to privileges used for the change.
    
    Add -- Indicates if this is a create or modify operation.
    
Return Value:
                             `
    None

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_DEFINED_DOMAINS Domain = NULL;
    ULONG AuditId = 0;
    LSAP_AUDIT_GROUP_ATTR_VALUES AttrVals;
    ALIAS_INFORMATION_CLASS AliasInformationClass;
    GROUP_INFORMATION_CLASS GroupInformationClass;
    NTSTATUS IgnoreStatus;
    BOOL fDereferenceContext = FALSE;

    //
    // This routine only manages the auditing in registry mode RPC calls.
    //
    if (SampUseDsData) {
        return;
    }
    
    //
    // Get a pointer to the domain this object is in.
    //         
    Domain = &SampDefinedDomains[DomainIndex];
    
    //
    // This routine should not be called by the loopback client
    //
    ASSERT(!Domain->Context->LoopbackClient);

    //
    // Reference the context if needed
    //  
    NtStatus = SampMaybeLookupContextForAudit(
                   GroupContext,
                   &fDereferenceContext
                   );
    
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }      
        
    //
    // Initialize the appropriate information class type
    //
    if (IsAliasInformationClass) {
        
        AliasInformationClass = *(ALIAS_INFORMATION_CLASS*)InformationClass;
    
    } else {
        
        GroupInformationClass = *(GROUP_INFORMATION_CLASS*)InformationClass;  
    } 
    
    //
    // Choose an Auditing ID to audit
    //         
    NtStatus = SampAuditGetGroupChangeAuditId(GroupType, &AuditId, Add);
    
    if (!NT_SUCCESS(NtStatus)) {
        ASSERT(FALSE && "Group change audit Id determination should not fail");
        return;
    }   
     
    RtlZeroMemory(&AttrVals, sizeof(LSAP_AUDIT_GROUP_ATTR_VALUES));
      
    //
    // Collect value information
    //
    if (IsAliasInformationClass) {
        //
        // Collect information class specific value information for Alias
        //
        switch (AliasInformationClass) {
            
            case AliasGeneralInformation:
            case AliasNameInformation:
                //
                // SamAccountName
                //
                AttrVals.SamAccountName = AccountName;
    
                AttrVals.AttrDeltaType[
                    LSAP_FIELD_PTR(LSAP_AUDIT_GROUP_ATTR_VALUES, SamAccountName)] =
                    LsapAuditSamAttrNewValue; 

                break;
                
            case AliasAdminCommentInformation:
            case AliasReplicationInformation:
                //
                // These information classes contain no attributes that
                // require new value information.
                //
                break;
                
            default:        
                //
                // Assert if there is an unhandled information level, it may
                // require auditing support.
                //
                ASSERT(FALSE &&
                       "Addition of new information class?");
        }
        
    } else {
        //
        // Collect information class specific value information for Group
        //
        switch (GroupInformationClass) {
            
            case GroupGeneralInformation:
            case GroupNameInformation:
                //
                // SamAccountName
                //
                AttrVals.SamAccountName = AccountName;
    
                AttrVals.AttrDeltaType[
                    LSAP_FIELD_PTR(LSAP_AUDIT_GROUP_ATTR_VALUES, SamAccountName)] =
                    LsapAuditSamAttrNewValue;
                
                break;
                
            case GroupAttributeInformation:
            case GroupAdminCommentInformation:
            case GroupReplicationInformation:
                //
                // These information classes contain no attributes that
                // require new value information.
                //
                break;
                
            default:        
                //
                // Assert if there is an unhandled information level, it may
                // require auditing support.
                //
                ASSERT(FALSE &&
                       "Addition of new information class?");
        }
        
    }
    
    // IgnoreStatus
    LsaIAuditSamEvent(STATUS_SUCCESS,
                      AuditId,                  // Audit Id              
                      Domain->Sid,              // Domain SID            
                      NULL,                     // Account Name          
                      NULL,                     // Source Rid            
                      NULL,                     // Member Sid            
                      AccountName,              // Account Name          
                      &(Domain->ExternalName),  // Domain's SAM Name     
                      AccountRid,               // Source Account's Rid  
                      Privileges,               // Privileges used       
                      (PVOID)&AttrVals          // New Value Information
                      );
    
Cleanup:

    if (fDereferenceContext) {
        IgnoreStatus = SampDeReferenceContext(GroupContext, FALSE);
        ASSERT(NT_SUCCESS(IgnoreStatus));    
    } 
           
    return;

}


VOID
SampAuditGroupChangeDs(
    IN ULONG DomainIndex,
    IN PUNICODE_STRING AccountName,
    IN PULONG Rid,
    IN ULONG GroupType,
    IN PPRIVILEGE_SET Privileges OPTIONAL,
    IN PVOID NewValueInfo,
    IN BOOL Add
    )
/*++
Routine Description:

    This routine generates a group change audit. 
    It is called by both RPC clients and LDAP clients.

    LDAP client - calls it from SampNotifyReplicatedInChange. 

Parameter:

    DomainIndex  -- indicates which domain the object belongs to
    
    AccountName  -- pointer to account name.
    
    Rid          -- pointer to account rid 

    GroupType    -- indicates the group type, used to pick up audit ID
    
    Privileges   -- The set of privileges used, or NULL if none.
    
    NewValueInfo -- Object specific attribute value structure Lsa understands.
    
    Add          -- Indicates if this is an add or change operation.
    
Return Value:

    None

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_DEFINED_DOMAINS Domain = NULL;
    ULONG AuditId;
    
    //
    // Get a pointer to the domain this object is in.
    //    
    Domain = &SampDefinedDomains[DomainIndex];

    //
    // Choose an Auditing ID to audit
    //    
    NtStatus = SampAuditGetGroupChangeAuditId(GroupType, &AuditId, Add);
    
    if (!NT_SUCCESS(NtStatus)) {
        ASSERT(FALSE && "Group change audit Id determination should not fail");
        return;
    }    
    
    // IgnoreStatus
    LsaIAuditSamEvent(STATUS_SUCCESS,
                      AuditId,                   // Audit Id               
                      Domain->Sid,               // Domain SID             
                      NULL,                      // Account Name           
                      NULL,                      // Source Rid             
                      NULL,                      // Member Sid             
                      AccountName,               // Account Name           
                      &(Domain->ExternalName),   // Domain's SAM Name      
                      Rid,                       // Source Account's Rid   
                      Privileges,                // Privileges used        
                      NewValueInfo               // New value information         
                      );

    return;
    
}


NTSTATUS
SampAuditSidHistory(
    IN PSAMP_OBJECT Context,
    IN DSNAME *pObject
    )
/*++
Routine Description:

    This routine audits Sid History attribute changes originating from 
    the loopback client. 
    
    It is worth noting that this is a legacy audit that does not use
    either the loopback task queue or audit notification mechanisms. 

Parameters:

    Context - Object context pointer

    pObject - DSNAME of the object with the Sid history
    
Return Values:

    None.

--*/
{
    NTSTATUS  NtStatus = STATUS_SUCCESS;
    READARG   ReadArg;
    READRES  *ReadResult = NULL;
    ENTINFSEL EntInfSel; 
    ATTR      Attr;
    ULONG     RetValue = 0;
    ULONG     AccountRid = 0;
    ULONG     NameType = 0;
    ULONG     i = 0;
    PSAMP_DEFINED_DOMAINS Domain = NULL; 
    UNICODE_STRING AccountName; 
    PLSA_ADT_SID_LIST SidList = NULL;
    
    ASSERT(Context->LoopbackClient && SampUseDsData);
    
    //
    // This routine should only be called by the loopback client in DS mode.
    //
    if (!SampUseDsData || !Context->LoopbackClient) {
        return STATUS_NOT_IMPLEMENTED;
    }
    
    //
    // Get a pointer to the domain this object is in
    //            
    Domain = &SampDefinedDomains[Context->DomainIndex];

    //
    // Determine the account Rid
    //
    switch( Context->ObjectType )
    {
        case SampGroupObjectType:
            NameType = SAMP_GROUP_NAME;
            AccountRid = Context->TypeBody.Group.Rid;
            break;

        case SampAliasObjectType:
            NameType = SAMP_ALIAS_NAME;
            AccountRid = Context->TypeBody.Alias.Rid;
            break;

        case SampUserObjectType:
            NameType = SAMP_USER_ACCOUNT_NAME;
            AccountRid = Context->TypeBody.User.Rid;
            break;
        
        default:
            ASSERT( "Object type does not have Sid History attribute!" );
            goto Cleanup;
    }

    //
    // Lookup the account name, the context is already referenced.
    //
    RtlInitUnicodeString(&AccountName, L"-");   
    
    switch( Context->ObjectType ) {

        case SampGroupObjectType:
        case SampAliasObjectType:
        case SampUserObjectType:

            //
            // If we failed to get the account name continue without it.  
            //
            NtStatus = SampGetUnicodeStringAttribute(
                        Context,
                        NameType,
                        FALSE,  // Don't make a copy
                        &AccountName
                    );
            
            break;
            
        default:
            ASSERT( "Object type does not have Sid History attribute!" );
            goto Cleanup;

    }
    
    //
    // Read the Sid history attribute for inclusion in the audit
    //     
    RtlZeroMemory(&Attr, sizeof(Attr));
    Attr.attrTyp = ATT_SID_HISTORY;

    RtlZeroMemory(&EntInfSel, sizeof(EntInfSel));
    EntInfSel.AttrTypBlock.attrCount = 1;
    EntInfSel.AttrTypBlock.pAttr = &Attr;
    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

    RtlZeroMemory(&ReadArg, sizeof(READARG));
    ReadArg.pObject = pObject;
    ReadArg.pSel = &EntInfSel;
    InitCommarg(&ReadArg.CommArg);

    //
    // Issue the read, we won't free the read result in this routine.  The
    // return values must remain until the transaction completes where
    // they will be used for auditing.  The values are allocated on the 
    // thread's heap and will be cleaned up when it terminates.  
    //
    RetValue = DirRead(&ReadArg, &ReadResult);
    
    //
    // We wrote this attribute within the same transaction, our view
    // should not have changed, therefore the read should always succeed.
    //
    ASSERT(0 == RetValue || 
           (attributeError == ReadResult->CommRes.errCode &&
            PR_PROBLEM_NO_ATTRIBUTE_OR_VAL == 
               ReadResult->CommRes.pErrInfo->AtrErr.FirstProblem.intprob.problem)); 
    
    if (NULL == ReadResult)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetValue, &ReadResult->CommRes);
    }
    THClearErrors();
   
    //
    // STATUS_DS_NO_ATTRIBUTE_OR_VALUE indicates the Sid history is empty.
    //
    if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE == NtStatus) {
        
        NtStatus = STATUS_SUCCESS;
        
    } else if (!NT_SUCCESS(NtStatus)) {
        //
        // Fatal resource error
        //
        goto Cleanup;
    }
    
    //
    // Build the Sid History information structure
    //
    if ((ReadResult->entry.AttrBlock.attrCount == 1)
     && (ReadResult->entry.AttrBlock.pAttr[0].attrTyp == ATT_SID_HISTORY))
    {
        ATTRVALBLOCK *pAVBlock = &ReadResult->entry.AttrBlock.pAttr[0].AttrVal;
        
        ASSERT(ReadResult->entry.AttrBlock.attrCount >= 1);
                                  
        SidList = (PLSA_ADT_SID_LIST)DSAlloc(sizeof(LSA_ADT_SID_LIST));
        
        if (NULL == SidList) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        
        SidList->cSids = pAVBlock->valCount;
        
        //
        // Allocate enough memory to store each PLSA_ADT_SID_LIST_ENTRY
        //                      
        SidList->Sids = (PLSA_ADT_SID_LIST_ENTRY)DSAlloc(SidList->cSids * sizeof(LSA_ADT_SID_LIST_ENTRY));
        
        if (NULL == SidList->Sids) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Initialize every PLSA_ADT_SID_LIST_ENTRY
        //
        for (i = 0; i < SidList->cSids; i++) {
            
            SidList->Sids[i].Flags = 0;
            SidList->Sids[i].Sid = (PSID)pAVBlock->pAVal[i].pVal;
        }   
    }
    
    //
    // We need to propagate any error back to the caller and ultimately
    // roll back the transaction.  No audit, no commit.
    // 
    NtStatus = SampAuditAnyEvent(
                   Context,
                   STATUS_SUCCESS,
                   SE_AUDITID_ADD_SID_HISTORY,     // Audit Id
                   Domain->Sid,                    // Domain SID
                   NULL,                           // Account Name
                   &AccountRid,                    // Source Rid 
                   NULL,                           // Member Sid      
                   &AccountName,                   // Account Name
                   &Domain->ExternalName,          // Domain's SAM Name
                   &AccountRid,                    // Source Account's Rid
                   NULL,                           // Privileges used
                   (PVOID)SidList                  // New Value Information
                   );
    
Cleanup:
    
    return NtStatus;   
    
}


VOID
SampAuditUserChange(
    IN PSAMP_OBJECT AccountContext,
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN PUNICODE_STRING AccountName,
    IN PULONG Rid, 
    IN ULONG PrevAccountControl,
    IN ULONG AccountControl,
    IN PPRIVILEGE_SET Privileges OPTIONAL,
    IN BOOL Add
    )
/*++
Routine Description:

    This routine audits user object changes for the RPC client when in
    registry mode.  DS mode audits for both RPC and LDAP are audited
    via SampNotifyReplicatedinChange().
    
Parameters:

    Context - Object context pointer.

    UserInformationClass - Defines the set of attributes to include in the 
                           audit new value information.
                           
    AccountName - SAM account name of the user.
    
    Rid - Rid of the user.
    
    AccountControl - User account control of the user.                           
    
    Privileges - Optional privilege set used for operation.
    
    Add - Indicates if this is an add or change operation.
       
Return Values:

    None.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_DEFINED_DOMAINS Domain = NULL;
    ULONG AuditId; 
    PSAMP_V1_0A_FIXED_LENGTH_USER V1aFixed = NULL;
    UNICODE_STRING AdditionalInfo;
    UNICODE_STRING FullName;
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING HomeDrive;
    UNICODE_STRING ScriptPath;
    UNICODE_STRING ProfilePath;
    UNICODE_STRING Workstations;
    UNICODE_STRING UserParameters;
    LSAP_AUDIT_USER_ATTR_VALUES AttrVals;
    LOGON_HOURS LogonHours;
    NTSTATUS IgnoreStatus;
    BOOL fDereferenceContext = FALSE;
    
    //
    // This routine only manages the auditing in registry mode RPC calls.
    //
    if (SampUseDsData) {
        return;
    }
    
    //
    // Assert if there is an unhandled information level, it may
    // require auditing support.
    //
    ASSERT(UserInformationClass <= UserInternal6Information &&
           "Addition of new information class may require auditing");    
    
    //
    // Initialize auditing value structures
    //
    RtlZeroMemory(&AttrVals, sizeof(LSAP_AUDIT_USER_ATTR_VALUES));
    RtlZeroMemory(&LogonHours, sizeof(LOGON_HOURS));
    
    //
    //   These information classes are read only and thus ignored.
    //
    if (UserInformationClass == UserLogonInformation     ||
        UserInformationClass == UserAccountInformation   ||
        UserInformationClass == UserInternal6Information) {
        
        goto Cleanup;
    }
    
    //
    // Reference the context if needed
    //  
    NtStatus = SampMaybeLookupContextForAudit(
                   AccountContext,
                   &fDereferenceContext
                   );
    
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }
        
    Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];
    
    //
    // Get the current fixed attributes 
    //
    NtStatus = SampGetFixedAttributes(AccountContext,
                                      FALSE,     //  Don't make a copy
                                      (PVOID *)&V1aFixed
                                     );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }   
    
    //
    // Add attribute value information based on the information class
    //
        
    //
    // All information classes that include:
    //      SAMP_USER_ACCOUNT_NAME       
    //
    if (NT_SUCCESS(NtStatus) &&
        (UserInformationClass == UserGeneralInformation      ||
         UserInformationClass == UserAllInformation          ||
         UserInformationClass == UserAccountNameInformation  ||
         UserInformationClass == UserNameInformation         ||
         UserInformationClass == UserInternal3Information    ||
         UserInformationClass == UserInternal4Information    ||
         UserInformationClass == UserInternal4InformationNew)) {
        
        ASSERT(AccountName && AccountName->Length > 0);
        
        //
        // Add SAMP_USER_ACCOUNT_NAME information
        //
        AttrVals.SamAccountName = AccountName;
        
        AttrVals.AttrDeltaType[
           LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, SamAccountName)] =
           LsapAuditSamAttrNewValue;
        
        //
        // This attribute can not be set to no value
        //
    }
    
    //
    // All information classes that include:       
    //      SAMP_USER_FULL_NAME
    //      SAMP_FIXED_USER_PRIMARY_GROUP_ID
    //
    if (NT_SUCCESS(NtStatus) &&
        (UserInformationClass == UserGeneralInformation      ||
         UserInformationClass == UserAllInformation          ||
         UserInformationClass == UserFullNameInformation     ||
         UserInformationClass == UserNameInformation         ||
         UserInformationClass == UserInternal3Information    ||
         UserInformationClass == UserInternal4Information    ||
         UserInformationClass == UserInternal4InformationNew)) {

        NtStatus = SampGetUnicodeStringAttribute(
                   AccountContext,
                   SAMP_USER_FULL_NAME,
                   FALSE, // Do not make copy
                   &FullName
                   );
        
        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }
        
        //
        // Add the SAMP_USER_FULL_NAME attribute
        //
        AttrVals.DisplayName = &FullName;
        
        if (AttrVals.DisplayName->Length > 0) {
              
            AttrVals.AttrDeltaType[
                LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, DisplayName)] =
                    LsapAuditSamAttrNewValue; 
            
        } else {
            
            AttrVals.AttrDeltaType[
                LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, DisplayName)] =
                    LsapAuditSamAttrNoValue; 
        }    
    }
    
    //
    // All information classes that include:
    //      SAMP_USER_HOME_DIRECTORY
    //      SAMP_USER_HOME_DIRECTORY_DRIVE
    //
    if (NT_SUCCESS(NtStatus) &&
        (UserInformationClass == UserAllInformation          ||
         UserInformationClass == UserHomeInformation         ||
         UserInformationClass == UserInternal3Information    ||
         UserInformationClass == UserInternal4Information    ||
         UserInformationClass == UserInternal4InformationNew)) {

        NtStatus = SampGetUnicodeStringAttribute(
                       AccountContext,
                       SAMP_USER_HOME_DIRECTORY,
                       FALSE, // Do not make copy
                       &HomeDirectory
                       );
        
        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }
        
        //
        // Add SAMP_USER_HOME_DIRECTORY information
        //
        AttrVals.HomeDirectory = &HomeDirectory;
        
        if (AttrVals.HomeDirectory->Length > 0) {
              
            AttrVals.AttrDeltaType[
                LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, HomeDirectory)] =
                    LsapAuditSamAttrNewValue; 
            
        } else {
            
            AttrVals.AttrDeltaType[
                LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, HomeDirectory)] =
                    LsapAuditSamAttrNoValue; 
        } 
        
        NtStatus = SampGetUnicodeStringAttribute(
                       AccountContext,
                       SAMP_USER_HOME_DIRECTORY_DRIVE,
                       FALSE, // Do not make copy
                       &HomeDrive
                       );
        
        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }

        //
        // Add SAMP_USER_HOME_DIRECTORY_DRIVE information
        //
        AttrVals.HomeDrive = &HomeDrive;
        
        if (AttrVals.HomeDrive->Length > 0) {
              
            AttrVals.AttrDeltaType[
                LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, HomeDrive)] =
                    LsapAuditSamAttrNewValue; 
            
        } else {
            
            AttrVals.AttrDeltaType[
                LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, HomeDrive)] =
                    LsapAuditSamAttrNoValue; 
        }         
    }
    
    //
    // All information classes that include:
    //      SAMP_USER_SCRIPT_PATH
    //
    if (NT_SUCCESS(NtStatus) &&
        (UserInformationClass == UserAllInformation          ||
         UserInformationClass == UserScriptInformation       ||
         UserInformationClass == UserInternal3Information    ||
         UserInformationClass == UserInternal4Information    ||
         UserInformationClass == UserInternal4InformationNew)) {

        NtStatus = SampGetUnicodeStringAttribute(
                       AccountContext,
                       SAMP_USER_SCRIPT_PATH,
                       FALSE, // Do not make copy
                       &ScriptPath
                       );
        
        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }
        
        //
        // Add SAMP_USER_SCRIPT_PATH information
        //
        AttrVals.ScriptPath = &ScriptPath;
        
        if (AttrVals.ScriptPath->Length > 0) {
              
            AttrVals.AttrDeltaType[
                LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, ScriptPath)] =
                    LsapAuditSamAttrNewValue; 
            
        } else {
            
            AttrVals.AttrDeltaType[
                LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, ScriptPath)] =
                    LsapAuditSamAttrNoValue; 
        } 
    }
    
    //
    // All information classes that include:
    //      SAMP_USER_PROFILE_PATH
    //
    if (NT_SUCCESS(NtStatus) &&
        (UserInformationClass == UserAllInformation          ||
         UserInformationClass == UserProfileInformation      ||
         UserInformationClass == UserInternal3Information    ||
         UserInformationClass == UserInternal4Information    ||
         UserInformationClass == UserInternal4InformationNew)) {

        NtStatus = SampGetUnicodeStringAttribute(
                       AccountContext,
                       SAMP_USER_PROFILE_PATH,
                       FALSE, // Do not make copy
                       &ProfilePath
                       );
        
        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }
        
        //
        // Add SAMP_USER_PROFILE_PATH information
        //
        AttrVals.ProfilePath = &ProfilePath;
        
        if (AttrVals.ProfilePath->Length > 0) {
              
            AttrVals.AttrDeltaType[
                LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, ProfilePath)] =
                    LsapAuditSamAttrNewValue; 
            
        } else {
            
            AttrVals.AttrDeltaType[
                LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, ProfilePath)] =
                    LsapAuditSamAttrNoValue; 
        } 
    }
    
    //
    // All information classes that include:
    //      SAMP_USER_WORKSTATIONS
    //
    if (NT_SUCCESS(NtStatus) &&
        (UserInformationClass == UserAllInformation          ||
         UserInformationClass == UserWorkStationsInformation ||
         UserInformationClass == UserInternal3Information    ||
         UserInformationClass == UserInternal4Information    ||
         UserInformationClass == UserInternal4InformationNew)) {

        NtStatus = SampGetUnicodeStringAttribute(
                       AccountContext,
                       SAMP_USER_WORKSTATIONS,
                       FALSE, // Do not make copy
                       &Workstations
                       );
        
        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }
        
        //
        // Add SAMP_USER_WORKSTATIONS information
        //
        AttrVals.UserWorkStations = &Workstations;
        
        if (AttrVals.UserWorkStations->Length > 0) {
              
            AttrVals.AttrDeltaType[
                LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, UserWorkStations)] =
                    LsapAuditSamAttrNewValue; 
            
        } else {
            
            AttrVals.AttrDeltaType[
                LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, UserWorkStations)] =
                    LsapAuditSamAttrNoValue; 
        }
    }   
    
    //
    // All information classes that include:
    //      
    //      SAMP_FIXED_USER_PWD_LAST_SET
    //             
    if (NT_SUCCESS(NtStatus) &&
        (UserInformationClass == UserAllInformation          ||
         UserInformationClass == UserInternal3Information    ||
         UserInformationClass == UserInternal4Information    ||
         UserInformationClass == UserInternal4InformationNew)) {
        
        //
        // Add SAMP_FIXED_USER_PWD_LAST_SET information
        //
        AttrVals.PasswordLastSet = (PFILETIME)&V1aFixed->PasswordLastSet;
        
        AttrVals.AttrDeltaType[
           LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, PasswordLastSet)] =
           LsapAuditSamAttrNewValue;
        
        //
        // This attribute can not be set to no value
        //
    }
    
    //
    // All information classes that include:
    //      
    //      SAMP_FIXED_USER_ACCOUNT_CONTROL
    //             
    if (NT_SUCCESS(NtStatus) &&
        (UserInformationClass == UserAllInformation          ||
         UserInformationClass == UserControlInformation      ||
         UserInformationClass == UserInternal3Information    ||
         UserInformationClass == UserInternal4Information    ||
         UserInformationClass == UserInternal4InformationNew)) {
        
        //
        // Mask out any computed bits as we don't audit them.
        //
        ULONG OldMaskedAccountControl = 
            PrevAccountControl & ~((ULONG)USER_COMPUTED_ACCOUNT_CONTROL_BITS);
        
        ULONG NewMaskedAccountControl =
            AccountControl & ~((ULONG)USER_COMPUTED_ACCOUNT_CONTROL_BITS);
        
        //
        // Add SAMP_FIXED_USER_ACCOUNT_CONTROL information
        //
        AttrVals.PrevUserAccountControl = &OldMaskedAccountControl;
        AttrVals.UserAccountControl = &NewMaskedAccountControl;
        
        AttrVals.AttrDeltaType[
           LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, UserAccountControl)] =
           LsapAuditSamAttrNewValue;
        
        //
        // This attribute can not be set to no value
        //
    }         
    
    //
    // All information classes that include:
    //      
    //      SAMP_FIXED_USER_ACCOUNT_EXPIRES
    //             
    if (NT_SUCCESS(NtStatus) &&
        (UserInformationClass == UserAllInformation          ||
         UserInformationClass == UserExpiresInformation      ||
         UserInformationClass == UserInternal3Information    ||
         UserInformationClass == UserInternal4Information    ||
         UserInformationClass == UserInternal4InformationNew)) {
        
        //
        // Add SAMP_FIXED_USER_ACCOUNT_EXPIRES information
        //
        AttrVals.AccountExpires = (PFILETIME)&V1aFixed->AccountExpires; 
        
        AttrVals.AttrDeltaType[
           LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, AccountExpires)] =
           LsapAuditSamAttrNewValue;
        
        //
        // This attribute can not be set to no value
        //
    } 
    
    //
    // All information classes that include:
    //      
    //      SAMP_FIXED_USER_PRIMARY_GROUP_ID
    //             
    if (NT_SUCCESS(NtStatus) &&
        (UserInformationClass == UserAllInformation          ||
         UserInformationClass == UserPrimaryGroupInformation ||
         UserInformationClass == UserInternal3Information    ||
         UserInformationClass == UserInternal4Information    ||
         UserInformationClass == UserInternal4InformationNew)) {
        
        //
        // Add SAMP_FIXED_USER_PRIMARY_GROUP_ID information
        //
        AttrVals.PrimaryGroupId = &V1aFixed->PrimaryGroupId;
        
        AttrVals.AttrDeltaType[
           LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, PrimaryGroupId)] =
           LsapAuditSamAttrNewValue; 
        
        //
        // This attribute can not be set to no value
        //
    } 
        
    //
    // All information classes that include:
    //
    //      SAMP_USER_PARAMETERS
    //
    if (NT_SUCCESS(NtStatus) &&
        (UserInformationClass == UserAllInformation) ||
        (UserInformationClass == UserParametersInformation)) {
     
        NtStatus = SampGetUnicodeStringAttribute(
                       AccountContext,
                       SAMP_USER_PARAMETERS,
                       FALSE, // Do not make copy
                       &UserParameters
                       );
        
        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }

        //
        // Do not supply a value as it is secret.  Indicate a change by 
        // tagging the attribute as secret so it be displayed.
        //
        AttrVals.UserParameters = NULL;
        
        if (UserParameters.Length > 0) {
            
            AttrVals.AttrDeltaType[
                LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, UserParameters)] =
                    LsapAuditSamAttrSecret;
            
        } else {
            
            AttrVals.AttrDeltaType[
                LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, UserParameters)] =
                    LsapAuditSamAttrNoValue;
        }
    }
    
    //
    // All information classes that include:
    //      
    //      SAMP_USER_LOGON_HOURS
    //      
    if (NT_SUCCESS(NtStatus) &&
        (UserInformationClass == UserAllInformation          ||
         UserInformationClass == UserLogonHoursInformation   ||
         UserInformationClass == UserInternal3Information    ||
         UserInformationClass == UserInternal4Information    ||
         UserInformationClass == UserInternal4InformationNew)) {
        
        //
        // Add SAMP_USER_LOGON_HOURS information
        //                         
        NtStatus = SampRetrieveUserLogonHours(AccountContext, &LogonHours);
        
        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }
        
        AttrVals.LogonHours = &LogonHours; 
        
        if (0 == AttrVals.LogonHours->UnitsPerWeek &&
            NULL == AttrVals.LogonHours->LogonHours) {
            
            AttrVals.AttrDeltaType[
                LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, LogonHours)] =
                    LsapAuditSamAttrNoValue;  
        
        } else {
            
            AttrVals.AttrDeltaType[
                LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, LogonHours)] =
                    LsapAuditSamAttrNewValue;
        }           
    }      
    
    //
    // All information classes that include:
    //      SAMP_FIXED_USER_UPN
    //      SAMP_USER_SPN
    //      SAMP_USER_A2D2LIST
    //
    // These information classes are read only and therefore can not 
    // be used to change attribute values.
    //
    
    //
    // Initialize the additional information argument to the auditing API
    //
    RtlInitUnicodeString(&AdditionalInfo, L"-");
    
    //
    // Determine audit Id
    //
    if (AccountControl & USER_MACHINE_ACCOUNT_MASK)
    {
        AuditId = Add ? SE_AUDITID_COMPUTER_CREATED : SE_AUDITID_COMPUTER_CHANGE;  
        
    } else {
        
        AuditId = Add ? SE_AUDITID_USER_CREATED : SE_AUDITID_USER_CHANGE;
    }
    
    // Ignore status
    LsaIAuditSamEvent(
        STATUS_SUCCESS,
        AuditId,                        // Audit ID
        Domain->Sid,                    // Domain Sid
        Add ? NULL : &AdditionalInfo,   // Additional Info
        NULL,                           // Member Rid (not used)
        NULL,                           // Member Sid (not used)
        AccountName,                    // Account Name
        &(Domain->ExternalName),        // Domain Name
        Rid,                            // Account Rid
        Privileges,                     // Privileges used (not used)
        (PVOID)&AttrVals                // New value information
        );       
    
Cleanup:

    if (fDereferenceContext) {
        IgnoreStatus = SampDeReferenceContext(AccountContext, FALSE);
        ASSERT(NT_SUCCESS(IgnoreStatus));    
    }                                

    if (LogonHours.LogonHours) {
        MIDL_user_free((PVOID)LogonHours.LogonHours);
    }      
    
    return;
    
}


VOID
SampAuditUserDelete(
    ULONG           DomainIndex, 
    PUNICODE_STRING AccountName,
    PULONG          AccountRid, 
    ULONG           AccountControl
    )
/*++

Routine Description:

    This routine generates a group change audit. 
    
    It is called in both registry and DS cases

    Registry - calls it from SamrDeleteUser

    DS - calls it from SampNotifyReplicatedinChange. 

Parameter:

    DomainIndex -- indicates which domain the object belongs to

    AccountName -- pointer to account name.
    
    AcountRid -- pointer to account rid 

    AccountControl -- the type of user account 

Return Value:

    None

--*/
{
    PSAMP_DEFINED_DOMAINS   Domain = NULL;
    ULONG                   AuditId;

    //
    // Get a pointer to the domain this object is in.
    //

    Domain = &SampDefinedDomains[DomainIndex];

    if (AccountControl & USER_MACHINE_ACCOUNT_MASK )
    {
        AuditId = SE_AUDITID_COMPUTER_DELETED;
    }
    else
    {
        AuditId = SE_AUDITID_USER_DELETED;
    }

    LsaIAuditSamEvent(STATUS_SUCCESS,
                      AuditId,
                      Domain->Sid,
                      NULL,
                      NULL,
                      NULL,
                      AccountName,
                      &(Domain->ExternalName),
                      AccountRid,
                      NULL,
                      NULL
                      );


    return;
}


VOID
SampAuditGroupDelete(
    ULONG           DomainIndex, 
    PUNICODE_STRING GroupName,
    PULONG          AccountRid, 
    ULONG           GroupType
    )
/*++

Routine Description:

    This routine generates a group change audit. 
    
    It is called in both registry and DS cases

    Registry  - calls it from SamrDeleteGroup / SamrDeleteAlias

    DS  - calls it from SampNotifyReplicatedinChange. 

Parameter:

    DomainIndex -- indicates which domain the object belongs to

    GroupName -- pointer to group name.
    
    AcountRid -- pointer to account rid 

    GroupType -- indicates the group type, used to pick up audit ID

Return Value:

    None

--*/
{
    PSAMP_DEFINED_DOMAINS   Domain = NULL;
    ULONG                   AuditId;

    //
    // Get a pointer to the domain this object is in.
    //

    Domain = &SampDefinedDomains[DomainIndex];

    //
    // Choose an Auditing ID to audit
    //
    if (GROUP_TYPE_SECURITY_ENABLED & GroupType)
    {
        if (GROUP_TYPE_ACCOUNT_GROUP & GroupType)
        {
            AuditId = SE_AUDITID_GLOBAL_GROUP_DELETED;
        }
        else if (GROUP_TYPE_UNIVERSAL_GROUP & GroupType)
        {
            AuditId = SE_AUDITID_SECURITY_ENABLED_UNIVERSAL_GROUP_DELETED;
        }
        else 
        {
            ASSERT(GROUP_TYPE_RESOURCE_GROUP & GroupType);
            AuditId = SE_AUDITID_LOCAL_GROUP_DELETED;
        }
    }
    else
    {
        if (GROUP_TYPE_ACCOUNT_GROUP & GroupType)
        {
            AuditId = SE_AUDITID_SECURITY_DISABLED_GLOBAL_GROUP_DELETED;
        }
        else if (GROUP_TYPE_UNIVERSAL_GROUP & GroupType)
        {
            AuditId = SE_AUDITID_SECURITY_DISABLED_UNIVERSAL_GROUP_DELETED;
        }
        else if (GROUP_TYPE_APP_BASIC_GROUP & GroupType)
        {
            AuditId = SE_AUDITID_APP_BASIC_GROUP_DELETED;
        }
        else if (GROUP_TYPE_APP_QUERY_GROUP & GroupType)
        {
            AuditId = SE_AUDITID_APP_QUERY_GROUP_DELETED;
        }
        else
        {
            ASSERT(GROUP_TYPE_RESOURCE_GROUP & GroupType);
            AuditId = SE_AUDITID_SECURITY_DISABLED_LOCAL_GROUP_DELETED;
        }
    }

    LsaIAuditSamEvent(STATUS_SUCCESS,
                      AuditId,
                      Domain->Sid,
                      NULL,
                      NULL,
                      NULL,
                      GroupName,
                      &(Domain->ExternalName),
                      AccountRid,
                      NULL,
                      NULL
                      );

    return;
}


VOID
SampDeleteObjectAuditAlarm(
    IN PSAMP_OBJECT Context    
    )
/*++

Routine Description:

    This routine is an impersonation wrapper for NtDeleteObjectAuditAlarm

Parameter:

    Context -- the SAM context that is being deleted                            

Return Value:

    None

--*/
{
    BOOLEAN ImpersonatingAnonymous = FALSE;
    BOOLEAN Impersonating = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;

    if (!Context->TrustedClient) {

        Status = SampImpersonateClient(&ImpersonatingAnonymous);
        if (NT_SUCCESS(Status)) {
            Impersonating = TRUE;
        }
    }
        
    (VOID) NtDeleteObjectAuditAlarm(&SampSamSubsystem,
                                    Context,
                                    Context->AuditOnClose);
        
    if (Impersonating) {
        SampRevertToSelf(ImpersonatingAnonymous);
    }
}


VOID
SampAuditUserChangeDs(
    IN ULONG DomainIndex,
    IN PUNICODE_STRING AccountName,
    IN ULONG AccountControl,
    IN PULONG Rid,
    IN PPRIVILEGE_SET Privileges OPTIONAL,
    IN PVOID NewValueInfo OPTIONAL,
    IN BOOL Add
    )
/*++
Routine Description:

    This routine audits User and Computer attribute changes originating from 
    the DS/LDAP.

Parameters:

    DomainIndex  - SampDefinedDomains index for the user object
    
    ObjectType   - The Sam object type, ie. to differentiate between user 
                   and computer
    
    AccountName  - SAM account name of the modified user
    
    Rid          - SAM account Rid
    
    Privileges   - The set of priviledges used, or NULL if none.
    
    NewValueInfo - Object specific attribute value structure Lsa understands.
    
    Add          - Indicates if this is an add or change operation.

Return Values:

    None.

--*/
{
    NTSTATUS       IgnoreStatus;
    PSID           DomainSid = NULL;
    ULONG          AuditId = 0;
    UNICODE_STRING AdditionalInfo;
    PSAMP_DEFINED_DOMAINS Domain = NULL;  
    
    //
    // Perform some validations on the new value information.  We check 
    // elements that are populated using the Ds Control mechanism in case
    // any places we change these attributes don't set the value properly.
    //
    if (NewValueInfo) {
        
        PLSAP_AUDIT_USER_ATTR_VALUES Values = 
            (PLSAP_AUDIT_USER_ATTR_VALUES)NewValueInfo;
        
        //
        // If the UAC changed both the new and old value must be present.
        //
        if (LsapAuditSamAttrNewValue == Values->AttrDeltaType[
            LSAP_FIELD_PTR(LSAP_AUDIT_USER_ATTR_VALUES, UserAccountControl)]) {
            
            ASSERT(Values->UserAccountControl && Values->PrevUserAccountControl);
            
            if (NULL == Values->UserAccountControl ||
                NULL == Values->PrevUserAccountControl) {
                //
                // In W2K and prior to Win2K3 Beta 3 computed bits were 
                // erroneously persisted.  This is no longer the case. 
                // We need to handle the case where a write occurs to the UAC 
                // that results in no delta to persisted bits of a pre-Beta 3 
                // object.  Because SAM will mask all computed bits, the value
                // will be indirectly changed but not "noticed" by SAM. 
                // Therefore, no previous UAC value will be added to the 
                // notification.  The resulting write to the DS will trigger 
                // inclusion of UAC data in the audit.  In this case, we'll 
                // clear the UAC information from the audit notification
                // because this is a system driven change and as such does 
                // not need to be audited.
                //                                        
                Values->AttrDeltaType[LSAP_FIELD_PTR(
                    LSAP_AUDIT_USER_ATTR_VALUES, UserAccountControl)] = 
                    LsapAuditSamAttrUnchanged;
                
                Values->PrevUserAccountControl = NULL;
                Values->UserAccountControl = NULL;
            }
        }  
    }

    //
    // Get a pointer to the domain this object is in.
    //                                        
    Domain = &SampDefinedDomains[DomainIndex];
    
    RtlInitUnicodeString(&AdditionalInfo, L"-");
    
    //
    // Determine audit Id
    //
    if (AccountControl & USER_MACHINE_ACCOUNT_MASK)
    {
        AuditId = Add ? SE_AUDITID_COMPUTER_CREATED : SE_AUDITID_COMPUTER_CHANGE;  
        
    } else {
        
        AuditId = Add ? SE_AUDITID_USER_CREATED : SE_AUDITID_USER_CHANGE;
    }
   
    // Ignore status
    IgnoreStatus = LsaIAuditSamEvent(STATUS_SUCCESS,
                                     AuditId,
                                     Domain->Sid,
                                     Add ? NULL : &AdditionalInfo,
                                     NULL,
                                     NULL,
                                     AccountName,
                                     &(Domain->ExternalName),
                                     Rid,
                                     Privileges,
                                     NewValueInfo
                                     );
    
    return;
    
}

    
NTSTATUS
SampAuditUpdateAuditNotificationDs(
    IN SAMP_AUDIT_NOTIFICATION_UPDATE_TYPE Type,
    IN PSID Sid,
    IN PVOID Value
    )
/*++
Routine Description:

    This routine invokes the appropriate Ds control operation to store
    state on an audit notification.  
    
Parameters:

    Type  - The type of audit notification update.  This value indicates
            the datatype of Value and hence the falvor of Ds control op.
            
    Sid   - Object Sid associated with the audit.            
    
    Value - A generic pointer to the state to be stored.

Return Values:

    STATUS_SUCCESS - Value was successfully stored on an audit notification.
    
    Error status returned from SampDsControl.

--*/
{
    SAMP_DS_CTRL_OP DsControlOp;
    PVOID DummyResult = NULL;   
    NTSTATUS NtStatus = STATUS_SUCCESS;
            
    //
    // This routine only stores state for auditing when in DS mode.  Registry 
    // mode auditing has dedicated routines.
    //
    if (!SampUseDsData) {
        goto Cleanup;
    }
    
    //
    // Be sure we've got a transaction open to invoke SampDsControl.
    //  
    NtStatus = SampDoImplicitTransactionStart(TransactionRead);
          
    if ( !NT_SUCCESS(NtStatus) ) {
        goto Cleanup;
    }
    
    RtlZeroMemory(&DsControlOp, sizeof(SAMP_DS_CTRL_OP));
    DsControlOp.OpType = SampDsCtrlOpTypeUpdateAuditNotification;
    DsControlOp.OpBody.UpdateAuditNotification.UpdateType = Type;
    DsControlOp.OpBody.UpdateAuditNotification.Sid = Sid;
    
    //
    // Initialize the Ds control op based on update type
    //
    switch (Type) {
        
        case SampAuditUpdateTypePrivileges:
            DsControlOp.OpBody.UpdateAuditNotification.UpdateData.Privileges =
                (PPRIVILEGE_SET)Value;
            break;
            
        case SampAuditUpdateTypeUserAccountControl:
            DsControlOp.OpBody.UpdateAuditNotification.UpdateData.IntegerData =
                (*(PULONG)Value);
            break;
            
        default:
            
            ASSERT(FALSE && "Invalid audit notification update type");
            break;
    }    
    
    NtStatus = SampDsControl(&DsControlOp, &DummyResult);
    
Cleanup:    
    
    return NtStatus;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\samrpc_s_stub.c ===
#include "samrpc_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\samifree.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    samifree.c

Abstract:

    This file contains routines to free structure allocated by the Samr
    routines.  These routines are used by SAM clients which live in the
    same process as the SAM server and call the Samr routines directly.


Author:

    Cliff Van Dyke (CliffV) 26-Feb-1992

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>





VOID
SamIFree_SAMPR_SR_SECURITY_DESCRIPTOR (
    PSAMPR_SR_SECURITY_DESCRIPTOR Source
    )

/*++

Routine Description:

    This routine free a SAMPR_SR_SECURITY_DESCRIPTOR and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgs__SAMPR_SR_SECURITY_DESCRIPTOR ( Source );
        MIDL_user_free (Source);
    }
}



VOID
SamIFree_SAMPR_DOMAIN_INFO_BUFFER (
    PSAMPR_DOMAIN_INFO_BUFFER Source,
    DOMAIN_INFORMATION_CLASS Branch
    )

/*++

Routine Description:

    This routine free a SAMPR_DOMAIN_INFO_BUFFER and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

    Branch - Specifies which branch of the union to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgu__SAMPR_DOMAIN_INFO_BUFFER ( Source, Branch );
        MIDL_user_free (Source);
    }
}


VOID
SamIFree_SAMPR_ENUMERATION_BUFFER (
    PSAMPR_ENUMERATION_BUFFER Source
    )

/*++

Routine Description:

    This routine free a SAMPR_ENUMERATION_BUFFER and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgs__SAMPR_ENUMERATION_BUFFER ( Source );
        MIDL_user_free (Source);
    }
}


VOID
SamIFree_SAMPR_PSID_ARRAY (
    PSAMPR_PSID_ARRAY Source
    )

/*++

Routine Description:

    This routine free a the graph of allocated nodes pointed to
    by a PSAMPR_PSID_ARRAY

Parameters:

    Source - A pointer to the node to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgs__SAMPR_PSID_ARRAY ( Source );
    }
}


VOID
SamIFree_SAMPR_ULONG_ARRAY (
    PSAMPR_ULONG_ARRAY Source
    )

/*++

Routine Description:

    This routine free a SAMPR_ULONG_ARRAY and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgs__SAMPR_ULONG_ARRAY ( Source );
        // SAM never allocates this.
        // MIDL_user_free (Source);
    }
}


VOID
SamIFree_SAMPR_RETURNED_USTRING_ARRAY (
    PSAMPR_RETURNED_USTRING_ARRAY Source
    )

/*++

Routine Description:

    This routine free a SAMPR_RETURNED_USTRING_ARRAY and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgs__SAMPR_RETURNED_USTRING_ARRAY ( Source );
        // SAM never allocates this.
        // MIDL_user_free (Source);
    }
}


VOID
SamIFree_SAMPR_GROUP_INFO_BUFFER (
    PSAMPR_GROUP_INFO_BUFFER Source,
    GROUP_INFORMATION_CLASS Branch
    )

/*++

Routine Description:

    This routine free a SAMPR_GROUP_INFO_BUFFER and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

    Branch - Specifies which branch of the union to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgu__SAMPR_GROUP_INFO_BUFFER ( Source, Branch );
        MIDL_user_free (Source);
    }
}


VOID
SamIFree_SAMPR_ALIAS_INFO_BUFFER (
    PSAMPR_ALIAS_INFO_BUFFER Source,
    ALIAS_INFORMATION_CLASS Branch
    )

/*++

Routine Description:

    This routine free a SAMPR_ALIAS_INFO_BUFFER and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

    Branch - Specifies which branch of the union to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgu__SAMPR_ALIAS_INFO_BUFFER ( Source, Branch );
        MIDL_user_free (Source);
    }
}


VOID
SamIFree_SAMPR_GET_MEMBERS_BUFFER (
    PSAMPR_GET_MEMBERS_BUFFER Source
    )

/*++

Routine Description:

    This routine free a SAMPR_GET_MEMBERS_BUFFER and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgs__SAMPR_GET_MEMBERS_BUFFER ( Source );
        MIDL_user_free (Source);
    }
}


VOID
SamIFree_SAMPR_USER_INFO_BUFFER (
    PSAMPR_USER_INFO_BUFFER Source,
    USER_INFORMATION_CLASS Branch
    )

/*++

Routine Description:

    This routine free a SAMPR_USER_INFO_BUFFER and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

    Branch - Specifies which branch of the union to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {

        _fgu__SAMPR_USER_INFO_BUFFER ( Source, Branch );
        MIDL_user_free (Source);
    }
}

VOID
SamIFree_UserInternal6Information (
   PUSER_INTERNAL6_INFORMATION  Source
   )
{  

    if (NULL!=Source)
    {
        _fgu__SAMPR_USER_INFO_BUFFER( (PSAMPR_USER_INFO_BUFFER) &Source->I1,UserAllInformation);
        MIDL_user_free(Source->A2D2List);
        MIDL_user_free(Source->UPN.Buffer);
        MIDL_user_free(Source->RegisteredSPNs);
        MIDL_user_free(Source);
    }
}


VOID
SamIFree_SAMPR_GET_GROUPS_BUFFER (
    PSAMPR_GET_GROUPS_BUFFER Source
    )

/*++

Routine Description:

    This routine free a SAMPR_GET_GROUPS_BUFFER and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgs__SAMPR_GET_GROUPS_BUFFER ( Source );
        MIDL_user_free (Source);
    }
}



VOID
SamIFree_SAMPR_DISPLAY_INFO_BUFFER (
    PSAMPR_DISPLAY_INFO_BUFFER Source,
    DOMAIN_DISPLAY_INFORMATION Branch
    )

/*++

Routine Description:

    This routine free a SAMPR_DISPLAY_INFO_BUFFER and the graph of
    allocated nodes it points to.

Parameters:

    Source - A pointer to the node to free.

    Branch - Specifies which branch of the union to free.

Return Values:

    None.

--*/
{
    if ( Source != NULL ) {
        _fgu__SAMPR_DISPLAY_INFO_BUFFER ( Source, Branch );
        // SAM never allocates this.
        // MIDL_user_free (Source);
    }
}

VOID
SamIFreeSidAndAttributesList(
    IN  PSID_AND_ATTRIBUTES_LIST List
    )
/*

  Routine Description:

        Frees the Sid And Attributes Array returned by a get Reverse membership list


  Arguments:

        cSids  - Count of Sid/Attribute Pairs
        rpSids - Array of Sids

  Return Values
       None

  */
{
    ULONG   Index;

    if (NULL!=List->SidAndAttributes)
    {
        for (Index=0;Index<List->Count;Index++)
        {
            if (List->SidAndAttributes[Index].Sid)
                MIDL_user_free(List->SidAndAttributes[Index].Sid);
        }

        MIDL_user_free(List->SidAndAttributes);
        List->SidAndAttributes = NULL;
    }
}

VOID
SamIFreeSidArray(
    IN  PSAMPR_PSID_ARRAY List
    )
/*

  Routine Description:

  Frees the Sid Array returned by a get Reverse membership list


  Arguments:

  Return Values
       None

  */
{
    ULONG   Index;

    if (NULL != List)
    {
        if (List->Sids != NULL)
        {
            for (Index = 0; Index < List->Count ; Index++ )
            {
                if (List->Sids[Index].SidPointer != NULL)
                {
                    MIDL_user_free(List->Sids[Index].SidPointer);
                }
            }
            MIDL_user_free(List->Sids);
        }
        MIDL_user_free(List);
    }
}

VOID
SamIFreeVoid(
    IN  PVOID ptr
    )
/*

  Routine Description:

  Frees memory pointed to by ptr. Useful for cases where non-Sam functions
  need to free memory allocated off the process heap of Sam. For ex., 
  dbGetReverseMemberships in dbconstr.c in ntdsa.dll calls this to free
  Sid array returned by Sam in SampDsGetReverseMembership call


  Arguments:

  Return Values
       None

  */
{
    MIDL_user_free(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\samss.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    samss.c

Abstract:

    This is the main routine for the Security Account Manager Server process.

Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:

    JimK        04-Jul-91
        Created initial file.
    ChrisMay    13-Aug-96
        Added branch at the end of SampInitialize to initialize domain con-
        trollers from the DS backing store instead of the registry.
    ChrisMay    07-Oct-96
        Added routine to support crash-recovery by booting from the registry
        as a fall back to booting from the DS.
    ChrisMay    02-Jan-97
        Moved call to SampDsBuildRootObjectName inside the test to determine
        whether or not the machine is a DC.
    ColinBr     23-Jan-97
        Added thread creation for delayed directory service initialization
    ColinBr     12-Jun-97
        Changed the crash-recovery hives to be stand alone server hives which
        exist under HKLM\SAM\SAFEMODE. Also layed foundation for supporting
        LsaISafeMode(), and eliminating the possibility of running a DC using
        registry hives.


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dslayer.h>
#include <dsdomain.h>
#include <sdconvrt.h>
#include <nlrepl.h>
#include <dsconfig.h>
#include <ridmgr.h>
#include <samtrace.h>
#include <dnsapi.h>
#include <dsmember.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Module Private defines                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


#define SAM_AUTO_BUILD

//
// Enable this define to compile in code to SAM that allows for the
// simulation of SAM initialization/installation failures.  See
// SampInitializeForceError() below for details.
//

// #define SAMP_SETUP_FAILURE_TEST 1

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
SampRegistryDelnode(
    IN WCHAR* KeyPath
    );

NTSTATUS
SampInitialize(
    OUT PULONG Revision
    );

VOID
SampLoadPasswordFilterDll( VOID );

NTSTATUS
SampEnableAuditPrivilege( VOID );

NTSTATUS
SampFixGroupCount( VOID );

VOID
SampPerformInitializeFailurePopup( NTSTATUS ErrorStatus );


#ifdef SAMP_SETUP_FAILURE_TEST

NTSTATUS
SampInitializeForceError(
    OUT PNTSTATUS ForcedStatus
    );

#endif //SAMP_SETUP_FAILURE_TEST



#if SAMP_DIAGNOSTICS
VOID
SampActivateDebugProcess( VOID );

NTSTATUS
SampActivateDebugProcessWrkr(
    IN PVOID ThreadParameter
    );
#endif //SAMP_DIAGNOSTICS

NTSTATUS
SampCacheComputerObject();

NTSTATUS
SampQueryNetLogonChangeNumbers( VOID );

NTSTATUS
SampSetSafeModeAdminPassword(
    VOID
    );

NTSTATUS
SampApplyDefaultSyskey();

NTSTATUS
SampReadRegistryParameters(
    IN PVOID p
    );

NTSTATUS
SampEventLogSafeModeBoot(
    IN PVOID p
    );


VOID
SampMachineNameChangeCallBack(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    );



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL
DllMain(
        HINSTANCE hinstDll,
        DWORD dwReason,
        LPVOID pvReserved
        )
/*++

Routine Description:

    This routine is invoked when interesting things happen to the dll.
    Why is it here? To make sure that no thread exits with SampLock
    held.

Arguments:

        hinstDll - an instance handle for the DLL.
        dwReason - The reason the routine was called.
        pvReserved - Unused, unless dwReason is DLL_PROCESS_DETACH.

Return Value:

   TRUE

--*/
{
    BOOL fReturn;

    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_DETACH:

        ASSERT(!SampCurrentThreadOwnsLock());

        if (SampCurrentThreadOwnsLock())
        {
            (VOID)RtlReleaseResource( &SampLock );
        }

        break;

    default:
        break;
    }
    return(TRUE);
}

BOOLEAN
SampIsDownlevelDcUpgrade(
    VOID
    )
/*++

Routine Description:

    This is a downlevel dc upgrade if

    1) the product type is LanmanNT
    2) we are running during an upgrade
    3) there are no ntds parameter keys in the registry

Arguments:

Return Value:

    TRUE if the above conditions are satisfied; FALSE otherwise

--*/
{
    NTSTATUS          NtStatus;

    OBJECT_ATTRIBUTES KeyObject;
    HANDLE            KeyHandle;
    UNICODE_STRING    KeyName;


    if (SampProductType == NtProductLanManNt
     && SampIsSetupInProgress(NULL)) {

        //
        // Does the key exist ?
        //

        RtlInitUnicodeString(&KeyName, TEXT("\\Registry\\Machine\\") TEXT(DSA_CONFIG_ROOT));
        RtlZeroMemory(&KeyObject, sizeof(KeyObject));
        InitializeObjectAttributes(&KeyObject,
                                   &KeyName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        NtStatus = NtOpenKey(&KeyHandle,
                             KEY_READ,
                             &KeyObject);


        if (!NT_SUCCESS(NtStatus)) {
            //
            // The key not does or is not accessible so the ds has not
            // been installed, making this a downlevel upgrade
            //
            return TRUE;
        }

        CloseHandle(KeyHandle);

    }

    return FALSE;

}

NTSTATUS
SampChangeConfigurationKeyToValue(
    IN PUNICODE_STRING Name
    )
/*++

Routine Description:

    This routine checks for the existence of a key with the name "Name" under
    \\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa.  If it
    exists, then a value of "Name" is placed under 
    \\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa.

Arguments:

    Name -- the name of the key

Return Value:

    resource error only

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS StatusCheck;

    OBJECT_ATTRIBUTES KeyObject;
    HANDLE            KeyHandle;
    UNICODE_STRING    KeyName;

    WCHAR Path[256];
    WCHAR *RootPath = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa";
    HANDLE OldKey;

    //
    // Set up the path to the old key
    //
    RtlZeroMemory(Path, sizeof(Path));
    wcscpy(Path, RootPath);
    wcscat(Path, L"\\");
    wcsncat(Path, Name->Buffer, Name->Length);
    ASSERT(wcslen(Path) < sizeof(Path)/sizeof(Path[0]));

    RtlInitUnicodeString(&KeyName, Path);
    RtlZeroMemory(&KeyObject, sizeof(KeyObject));
    InitializeObjectAttributes(&KeyObject,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&OldKey,
                         DELETE,
                         &KeyObject);

    if (NT_SUCCESS(NtStatus)) {

        //
        // The key exists; add the value and then remove the key
        //
        RtlInitUnicodeString(&KeyName, RootPath);
        RtlZeroMemory(&KeyObject, sizeof(KeyObject));
        InitializeObjectAttributes(&KeyObject,
                                   &KeyName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);
    
        NtStatus = NtOpenKey(&KeyHandle,
                             KEY_READ | KEY_WRITE,
                             &KeyObject);

        if (NT_SUCCESS(NtStatus)) {

            //
            // Add the value
            //
            ULONG             Value = 1;
            NtStatus =  NtSetValueKey(KeyHandle,
                                      Name,
                                      0,
                                      REG_DWORD,
                                      &Value,
                                      sizeof(Value));

            if (NT_SUCCESS(NtStatus)) {

                //
                // Remove the key
                //
                StatusCheck = NtDeleteKey(OldKey);
                ASSERT(NT_SUCCESS(StatusCheck));

            }

            StatusCheck = NtClose(KeyHandle);
            ASSERT(NT_SUCCESS(StatusCheck));

        }

        StatusCheck = NtClose(OldKey);
        ASSERT(NT_SUCCESS(StatusCheck));

    } else {

        //
        // Key doesn't exist -- that's fine, nothing to do
        //
        NtStatus = STATUS_SUCCESS;

    }

    return NtStatus;
}

VOID
SampChangeConfigurationKeys(
    VOID
    )
/*++

Routine Description:

    This routine changes configuration keys to values
    
    N.B. This code currently supports settings made in the Windows 2000
    release.  Once upgrade from this release is not supported, this
    code can be removed.

Arguments:

    None.

Return Value:

    None.         

--*/
{
    ULONG i;
    LPWSTR Values[] = 
    {
        L"IgnoreGCFailures",
        L"NoLmHash"
    };
    #define NELEMENTS(x) (sizeof(x)/sizeof((x)[0]))

    for (i = 0; i < NELEMENTS(Values) ; i++) {

        UNICODE_STRING NameU;
        NTSTATUS CheckStatus;

        RtlInitUnicodeString(&NameU, Values[i]);

        CheckStatus = SampChangeConfigurationKeyToValue(&NameU);
        ASSERT(NT_SUCCESS(CheckStatus));
    }

    return;

}

static CHAR BootMsg[100];




VOID
SampMachineNameChangeCallBack(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    )
/*++
Routine Description:

    Call back whenever machine name is change, so that SAM can update cached
    Account Domain Name

Parameter:

    ChangedInfoClass

Reture Value: 

    None

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PLSAPR_POLICY_INFORMATION   PolicyInfo = NULL;
    PSAMP_DEFINED_DOMAINS       Domain = NULL;
    ULONG       Index = 0; 

    ULONG       DnsNameLen = DNS_MAX_NAME_BUFFER_LENGTH+1;
    WCHAR       DnsNameBuffer[DNS_MAX_NAME_BUFFER_LENGTH+1];
    BOOLEAN     fCompareDnsDomainName = FALSE;



    //
    // only Account Domain info change is interested
    // 

    if ( SampUseDsData ||
         (PolicyNotifyAccountDomainInformation != ChangedInfoClass)
         )
    {
        return;
    }

    //
    // Query LSA Policy to get account domain name
    // 

    NtStatus = LsaIQueryInformationPolicyTrusted(
                    PolicyAccountDomainInformation,
                    &PolicyInfo
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        return;
    }

    //
    // get machine DNS name
    // 
    RtlZeroMemory(DnsNameBuffer, sizeof(WCHAR) * DnsNameLen);
    if ( GetComputerNameExW(ComputerNameDnsFullyQualified,
                            DnsNameBuffer,
                            &DnsNameLen) )
    {
        fCompareDnsDomainName = TRUE;
    }

    //
    // Acquire SAM Lock
    // 

    SampAcquireSamLockExclusive();


    //
    // scan SAM defined domain array (Account Domain Only)
    // and update cached Account Domain Name (machine name)
    // 
    for ( Index = 0; Index < SampDefinedDomainsCount; Index++ )
    {
        PWCHAR      pTmp = NULL;
        ULONG       BufLength = 0;

        Domain = &(SampDefinedDomains[Index]); 

        // not builtin domain
        if (!Domain->IsBuiltinDomain)
        {
            // Account Domain Name should be changed
            if (!RtlEqualUnicodeString(&(Domain->ExternalName),
                                       (UNICODE_STRING *)&(PolicyInfo->PolicyAccountDomainInfo.DomainName), 
                                       TRUE)  // case insensitive
                )
            {

                // allocate memory
                BufLength = PolicyInfo->PolicyAccountDomainInfo.DomainName.MaximumLength;  
                pTmp = RtlAllocateHeap( RtlProcessHeap(), 0, BufLength);
                if (NULL != pTmp)
                {
                    RtlZeroMemory(pTmp, BufLength);
                    RtlCopyMemory(pTmp, PolicyInfo->PolicyAccountDomainInfo.DomainName.Buffer, BufLength);
                    Domain->ExternalName.Length = PolicyInfo->PolicyAccountDomainInfo.DomainName.Length;
                    Domain->ExternalName.MaximumLength = PolicyInfo->PolicyAccountDomainInfo.DomainName.MaximumLength;

                    //
                    // release the old name
                    // 
                    RtlFreeHeap(RtlProcessHeap(), 0, Domain->ExternalName.Buffer);
                    Domain->ExternalName.Buffer = pTmp;
                    pTmp = NULL;
                }
            }

            // update DnsDomainName if necessary
            if (fCompareDnsDomainName)
            {
                // previous DnsDomainName is NULL or changed
                if ((NULL == Domain->DnsDomainName.Buffer) ||
                    (!DnsNameCompare_W(Domain->DnsDomainName.Buffer, DnsNameBuffer))
                    )
                {
                    BufLength = DnsNameLen * sizeof(WCHAR);

                    pTmp = RtlAllocateHeap( RtlProcessHeap(), 0, BufLength );
                    if (NULL != pTmp)
                    {
                        RtlZeroMemory(pTmp, BufLength);
                        RtlCopyMemory(pTmp, DnsNameBuffer, BufLength);
                        Domain->DnsDomainName.Length = (USHORT)BufLength;
                        Domain->DnsDomainName.MaximumLength = (USHORT)BufLength;

                        //
                        // release old value
                        // 
                        if (Domain->DnsDomainName.Buffer)
                        {
                            RtlFreeHeap(RtlProcessHeap(), 0, Domain->DnsDomainName.Buffer);
                        }
                        Domain->DnsDomainName.Buffer = pTmp;
                        pTmp = NULL;
                    }
                }
            }
        }
    }


    //
    // Release SAM Lock
    // 

    SampReleaseSamLockExclusive();

    if ( NULL != PolicyInfo )
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(PolicyAccountDomainInformation,
                                          PolicyInfo);
    }
}




NTSTATUS
SamIInitialize (
    VOID
    )

/*++

Routine Description:

    This is the initialization control routine for the Security Account
    Manager Server.  A mechanism is provided for simulating initialization
    errors.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully

        Simulated errors

        Errors from called routines.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus;
    HANDLE EventHandle = NULL;
    ULONG Revision = 0;
    ULONG PromoteData;
    BOOLEAN fUpgrade = FALSE;


    SAMTRACE("SamIInitialize");

//
// The following conditional code is used to generate artifical errors
// during SAM installation for the purpose of testing setup.exe error
// handling.  This code should remain permanently, since it provides a
// way of testing against regressions in the setup error handling code.
//

#ifdef SAMP_SETUP_FAILURE_TEST
    NTSTATUS ForcedStatus;

    //
    // Read an error code from the Registry.
    //

    NtStatus = SampInitializeForceError( &ForcedStatus);

    if (!NT_SUCCESS(NtStatus)) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: Attempt to force error failed 0x%lx\n",
                   NtStatus));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM will try to initialize normally\n"));

        NtStatus = STATUS_SUCCESS;

    } else {

        //
        // Use the status returned
        //

        NtStatus = ForcedStatus;
    }

#endif // SAMP_SETUP_FAILURE_TEST

    //
    // Initialize SAM if no error was forced.
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampInitialize( &Revision );
    }

    //
    // Register our shutdown routine
    //

    if (!SetConsoleCtrlHandler(SampShutdownNotification, TRUE)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM Server: SetConsoleCtrlHandler call failed %d\n",
                   GetLastError()));
    }

    if (!SetProcessShutdownParameters(SAMP_SHUTDOWN_LEVEL,SHUTDOWN_NORETRY)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM Server: SetProcessShutdownParameters call failed %d\n",
                   GetLastError()));
    }


    //
    // Register Domain Name Change Notification Call Back (Registry Mode Only)
    // 
    if (!SampUseDsData && NT_SUCCESS(NtStatus))
    {
        NtStatus = LsaIRegisterPolicyChangeNotificationCallback(
                        SampMachineNameChangeCallBack,
                        PolicyNotifyAccountDomainInformation
                        );
    }

    //
    // Try to load the cached Alias Membership information and turn on caching.
    // In Registry Case, if unsuccessful, caching remains disabled forever.
    //

    //
    // For DS Case, enable Builtin Domain's Alias Membership information.
    // in Registry Case, enable both Builtin Domain and Account Domain Alias Caching.
    //

    if (NT_SUCCESS(NtStatus))
    {
        if (TRUE==SampUseDsData)
        {
            LsaIRegisterNotification(
                        SampAlDelayedBuildAliasInformation,
                        NULL,
                        NOTIFIER_TYPE_INTERVAL,
                        0,
                        NOTIFIER_FLAG_ONE_SHOT,
                        150,        // wait for 5 minutes: 300 secound
                        0
                        );

            //
            // Create the builtin account name cache
            //
            NtStatus = SampInitAliasNameCache();
            if (!NT_SUCCESS(NtStatus))
            {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "[SAMSS]: SampInitAliasNameCache failed (0x%x)", NtStatus));
            }

        }
        else
        {
            IgnoreStatus = SampAlBuildAliasInformation();

            if ( !NT_SUCCESS(IgnoreStatus))
            {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAM Server: Build Alias Cache access violation handled"));

                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAM Server: Alias Caching turned off\n"));
            }
        }
    }

    //
    // Perform any necessary upgrades.
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampUpgradeSamDatabase(
                        Revision
                        );
        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAM Server: Failed to upgrade SAM database: 0x%x\n",
                       NtStatus));
        }
    }


    //
    // (Almost) Everyone is initialized, start processing calls.
    //

    SampServiceState = SampServiceEnabled;
    
    //
    // Do phase 2 of promotion, if necessary.  This must be
    // called after the ServiceState is set to enabled.
    //

    if (NT_SUCCESS(NtStatus) && !LsaISafeMode() )
    {
        if (SampIsRebootAfterPromotion(&PromoteData)) {

            SampDiagPrint( PROMOTE, ("SAMSS: Performing phase 2 of SAM promotion\n"));

            NtStatus = SampPerformPromotePhase2(PromoteData);

            if (!NT_SUCCESS(NtStatus)) {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: SampCreateNewDsDomainAccounts returned: 0x%x\n",
                           NtStatus));
            }

        }
    }

    if ( (NT_SUCCESS(NtStatus))
     &&  SampIsSetupInProgress( &fUpgrade )
     &&  fUpgrade 
     &&  SampUseDsData ) {


        //
        // This is GUI mode setup then upgrade all the group information
        // This is now being run for the benefit of DS data
        //

        ULONG   PromoteFlags = SAMP_PROMOTE_INTERNAL_UPGRADE;

        if (SampDefinedDomains[DOMAIN_START_DS+1].IsForestRootDomain)
        {
            // add the following flag if it is forest root domain
            PromoteFlags |= SAMP_PROMOTE_ENTERPRISE; 
        }

        NtStatus = SampPerformPromotePhase2( PromoteFlags );

        if (!NT_SUCCESS(NtStatus)) {

            ASSERT( NT_SUCCESS(NtStatus) );
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: New account creation failed with: 0x%x\n",
                       NtStatus));

            //
            // Don't fail the install because of this
            //
            NtStatus = STATUS_SUCCESS;
        }
    }

    
    //
    // In DS Mode cache the DS name of the computer object
    //

    if ((SampUseDsData) && (NT_SUCCESS(NtStatus)))
    {
       SampCacheComputerObject();
    }


    if (NT_SUCCESS(NtStatus) && SampUseDsData)
    {
        // Tell the Core DS that SAM is running, it can now start tasks that
        // would have conflicted with SAM startup.
        SampSignalStart();
    }

    //
    // Startup the thread that initializes the backup restore interface
    //

    if (SampUseDsData || LsaISafeMode())
    {
        HANDLE ThreadHandle;
        ULONG  ThreadId;

        // This is either a DC in normal or repair mode
        // Create a thread to host Directory Service Backup/Restore

        ThreadHandle = CreateThread(
                            NULL,
                            0,
                            (LPTHREAD_START_ROUTINE) SampDSBackupRestoreInit,
                            NULL,
                            0,
                            &ThreadId
                            );


        if (ThreadHandle == NULL)
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS:  Unable to create SampDSBackupRestoreInit thread: %d\n",
                       GetLastError()));

            // If unable to create the DS Backup Restore thread, we should still be
            // able to boot. Should not return error at this point.
        }
        else
        {
            CloseHandle(ThreadHandle);
        }
    }

    //
    // In Ds Mode perform RID manager initialization synchronously
    // NT5 Relative ID (RID) management is distributed because accounts
    // can be created on any DC in the domain, and not just the primary
    // domain controller. Initialization of the RID Manager sets initial
    // RID values and reads the DS to restore previous RID pools.
    //


    if ((SampUseDsData) && (NT_SUCCESS(NtStatus)))
    {

        //
        // Try initializing the RID manager
        //

        NtStatus = SampDomainRidInitialization(TRUE);
        if (!NT_SUCCESS(NtStatus))
        {
            // RID initialization failure will prohibit the DC from creating
            // new accounts, groups, or aliases.

            //
            // SampDomainRidInitialization reschedules itself so this 
            // error has been handled
            //
            NtStatus = STATUS_SUCCESS;
        }
        else
        {
            //
            // Rids are initialized. Turn on the Writable Bit
            //
            I_NetLogonSetServiceBits(DS_WRITABLE_FLAG,DS_WRITABLE_FLAG);
        }


    }

    //
    // In DS Mode, protect SAM Server Object from being renamed or deleted
    // 

    if ((SampUseDsData) && NT_SUCCESS(NtStatus))
    {
        DSNAME *Target;

        Target = midl_user_allocate(SampServerObjectDsName->structLen);
        if (Target) {
            RtlCopyMemory(Target, SampServerObjectDsName, SampServerObjectDsName->structLen);

            LsaIRegisterNotification(
                        SampDsProtectSamObject,
                        Target,
                        NOTIFIER_TYPE_INTERVAL,
                        0,
                        NOTIFIER_FLAG_ONE_SHOT,
                        300,        // wait for 5 minutes: 300 secound
                        NULL
                        );
        } else {

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

    }

    //
    // In DS mode, Register WMI trace
    //

    if (SampUseDsData && NT_SUCCESS(NtStatus))
    {
        HANDLE   ThreadHandle;
        ULONG    ThreadId = 0;

        ThreadHandle = CreateThread(NULL,
                                    0,
                                    SampInitializeTrace,
                                    NULL,
                                    0,
                                    &ThreadId
                                    );

        if (NULL == ThreadHandle)
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Failed to Create SampInitailizeTrace thread. Error ==> %d \n",
                       GetLastError()));
        }
        else
        {
            CloseHandle(ThreadHandle);
        }
    }


    //
    // If we are booting to repair mode then log an event
    //

    if ((NT_SUCCESS(NtStatus))
        && (LsaISafeMode()))
    {
        //
        // Queue up the event log , at this time in the boot
        // process the event log is also just starting and hence
        // may not be available; so delay this somewhat.
        // Note this eventing is best effort; the event is
        // informational
        //
        LsaIRegisterNotification(
                        SampEventLogSafeModeBoot,
                        NULL,
                        NOTIFIER_TYPE_INTERVAL,
                        0,
                        NOTIFIER_FLAG_ONE_SHOT,
                        120,        // wait for 2 minutes: 120 secound
                        NULL
                        );    

    }

    //
    // If requested, activate a diagnostic process.
    // This is a debug aid expected to be used for SETUP testing.
    //

#if SAMP_DIAGNOSTICS
    IF_SAMP_GLOBAL( ACTIVATE_DEBUG_PROC ) {

        SampActivateDebugProcess();
    }
#endif //SAMP_DIAGNOSTICS



    if (!NT_SUCCESS(NtStatus))
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SAM server failed to initialize (%08lx)\n",
                   NtStatus));

        //
        // If SAM server failed initialization due to DS failure.
        // give the user shutdown option, and instruct him to boot
        // to safe boot.

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM Server: SamIInitialize failed with status code:0x%x, about to call into SampPerformInitializeFailurePopup.\n",
                   NtStatus));

        SampPerformInitializeFailurePopup(NtStatus);

    }

    return(NtStatus);
}


BOOLEAN
SampUsingDsData()

/*++

    Itty bitty export so in-process clients know which mode we're in.

--*/

{
    return(SampUseDsData);
}

BOOLEAN
SamIAmIGC()
{
    if (SampUseDsData) {
        return((BOOLEAN)SampAmIGC());
    } else {
        return FALSE;
    }
}









NTSTATUS
SampInitContextList(
    VOID
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    NTSTATUS    IgnoreStatus = STATUS_SUCCESS;

    __try
    {
        NtStatus = RtlInitializeCriticalSectionAndSpinCount(
                        &SampContextListCritSect,
                        4000
                        );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        return( NtStatus );
    }

    IgnoreStatus = RtlEnterCriticalSection( &SampContextListCritSect );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    InitializeListHead(&SampContextListHead);

    IgnoreStatus = RtlLeaveCriticalSection( &SampContextListCritSect );
    ASSERT(NT_SUCCESS(IgnoreStatus));


    return( NtStatus );
}
    


NTSTATUS
SampInitialize(
    OUT PULONG Revision
    )

/*++

Routine Description:

    This routine does the actual initialization of the SAM server.  This includes:

        - Initializing well known global variable values

        - Creating the registry exclusive access lock,

        - Opening the registry and making sure it includes a SAM database
          with a known revision level,

        - Starting the RPC server,

        - Add the SAM services to the list of exported RPC interfaces



Arguments:

    Revision - receives the revision of the database.

Return Value:

    STATUS_SUCCESS - Initialization has successfully completed.

    STATUS_UNKNOWN_REVISION - The SAM database has an unknown revision.



--*/
{
    NTSTATUS            NtStatus;
    NTSTATUS            IgnoreStatus;
    LPWSTR              ServiceName;

    PSAMP_OBJECT ServerContext;
    OBJECT_ATTRIBUTES SamAttributes;
    UNICODE_STRING SamNameU;
    UNICODE_STRING SamParentNameU;
    PULONG RevisionLevel;
    BOOLEAN ProductExplicitlySpecified;
    PPOLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo = NULL;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    CHAR    NullLmPassword = 0;
    RPC_STATUS  RpcStatus;
    HANDLE      ThreadHandle, ThreadHandleTmp;
    ULONG       ThreadId;
    BOOLEAN     CrashRecoveryMode = FALSE;
    BOOLEAN     RegistryMode = FALSE;
    BOOLEAN     DownlevelDcUpgrade = FALSE;
    BOOLEAN     RecreateHives = FALSE;
    PNT_PRODUCT_TYPE  DatabaseProductType = NULL;
    NT_PRODUCT_TYPE   TempDatabaseProductType;
    DWORD             PromoteData;
    BOOLEAN     fUpgrade;
    BOOLEAN     fSetup;

    SAMTRACE("SampInitialize");

    //
    // Set the state of our service to "initializing" until everything
    // is initialized.
    //

    SampServiceState = SampServiceInitializing;


    //
    // Initialize the Shutdown Handler, we get shut down notifications
    // regardless
    //

    NtStatus = SampInitializeShutdownEvent();
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Check the environment
    //
    fSetup = SampIsSetupInProgress(&fUpgrade);

    //
    // Initialize the logging resources
    //
    NtStatus = SampInitLogging();
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Change any configuration keys
    //
    if (fUpgrade) {

        SampChangeConfigurationKeys();
    }

    //
    // Read configuration data and register for updates
    //
    LsaIRegisterNotification( SampReadRegistryParameters,
                              0,
                              NOTIFIER_TYPE_NOTIFY_EVENT,
                              NOTIFY_CLASS_REGISTRY_CHANGE,
                              0,
                              0,
                              0 );
    (VOID) SampReadRegistryParameters(NULL);

    //
    // Set up some useful well-known sids
    //

    NtStatus = SampInitializeWellKnownSids();
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Get the product type
    //

    ProductExplicitlySpecified = RtlGetNtProductType(&SampProductType);

    //
    // Are we in safe mode?
    //
    CrashRecoveryMode = LsaISafeMode();

    //
    // Is this a downlevel dc upgrade ?
    //
    DownlevelDcUpgrade = SampIsDownlevelDcUpgrade();


    //
    // initialize Active Context Table
    // 

    NtStatus = SampInitializeActiveContextTable();
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Initialize the server/domain context list
    //

    NtStatus = SampInitContextList();
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Initialize the attribute field information of the object
    // information structures.
    //

    SampInitObjectInfoAttributes();

    //
    // Initialize the single replication critical section
    //
    NtStatus = RtlInitializeCriticalSection(&SampReplicateQueueLock);
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Set up the generic mappings for the SAM object types
    //

    SampObjectInformation[ SampServerObjectType ].GenericMapping.GenericRead
        = SAM_SERVER_READ;
    SampObjectInformation[ SampServerObjectType ].GenericMapping.GenericWrite
        = SAM_SERVER_WRITE;
    SampObjectInformation[ SampServerObjectType ].GenericMapping.GenericExecute
        = SAM_SERVER_EXECUTE;
    SampObjectInformation[ SampServerObjectType ].GenericMapping.GenericAll
        = SAM_SERVER_ALL_ACCESS;

    SampObjectInformation[ SampDomainObjectType ].GenericMapping.GenericRead
        = DOMAIN_READ;
    SampObjectInformation[ SampDomainObjectType ].GenericMapping.GenericWrite
        = DOMAIN_WRITE;
    SampObjectInformation[ SampDomainObjectType ].GenericMapping.GenericExecute
        = DOMAIN_EXECUTE;
    SampObjectInformation[ SampDomainObjectType ].GenericMapping.GenericAll
        = DOMAIN_ALL_ACCESS;

    SampObjectInformation[ SampGroupObjectType ].GenericMapping.GenericRead
        = GROUP_READ;
    SampObjectInformation[ SampGroupObjectType ].GenericMapping.GenericWrite
        = GROUP_WRITE;
    SampObjectInformation[ SampGroupObjectType ].GenericMapping.GenericExecute
        = GROUP_EXECUTE;
    SampObjectInformation[ SampGroupObjectType ].GenericMapping.GenericAll
        = GROUP_ALL_ACCESS;

    SampObjectInformation[ SampAliasObjectType ].GenericMapping.GenericRead
        = ALIAS_READ;
    SampObjectInformation[ SampAliasObjectType ].GenericMapping.GenericWrite
        = ALIAS_WRITE;
    SampObjectInformation[ SampAliasObjectType ].GenericMapping.GenericExecute
        = ALIAS_EXECUTE;
    SampObjectInformation[ SampAliasObjectType ].GenericMapping.GenericAll
        = ALIAS_ALL_ACCESS;

    SampObjectInformation[ SampUserObjectType ].GenericMapping.GenericRead
        = USER_READ;
    SampObjectInformation[ SampUserObjectType ].GenericMapping.GenericWrite
        = USER_WRITE;
    SampObjectInformation[ SampUserObjectType ].GenericMapping.GenericExecute
        = USER_EXECUTE;
    SampObjectInformation[ SampUserObjectType ].GenericMapping.GenericAll
        = USER_ALL_ACCESS;

    //
    // Set mask of INVALID accesses for an access mask that is already mapped.
    //

    SampObjectInformation[ SampServerObjectType ].InvalidMappedAccess
        = (ULONG)(~(SAM_SERVER_ALL_ACCESS | ACCESS_SYSTEM_SECURITY | MAXIMUM_ALLOWED));
    SampObjectInformation[ SampDomainObjectType ].InvalidMappedAccess
        = (ULONG)(~(DOMAIN_ALL_ACCESS | ACCESS_SYSTEM_SECURITY | MAXIMUM_ALLOWED));
    SampObjectInformation[ SampGroupObjectType ].InvalidMappedAccess
        = (ULONG)(~(GROUP_ALL_ACCESS | ACCESS_SYSTEM_SECURITY | MAXIMUM_ALLOWED));
    SampObjectInformation[ SampAliasObjectType ].InvalidMappedAccess
        = (ULONG)(~(ALIAS_ALL_ACCESS | ACCESS_SYSTEM_SECURITY | MAXIMUM_ALLOWED));
    SampObjectInformation[ SampUserObjectType ].InvalidMappedAccess
        = (ULONG)(~(USER_ALL_ACCESS | ACCESS_SYSTEM_SECURITY | MAXIMUM_ALLOWED));

    //
    // Set a mask of write operations for the object types.  Strip
    // out READ_CONTROL, which doesn't allow writing but is defined
    // in all of the standard write accesses.
    // This is used to enforce correct role semantics (e.g., only
    // trusted clients can perform write operations when a domain
    // role isn't Primary).
    //
    // Note that USER_WRITE isn't good enough for user objects.  That's
    // because USER_WRITE allows users to modify portions of their
    // account information, but other portions can only be modified by
    // an administrator.
    //

    SampObjectInformation[ SampServerObjectType ].WriteOperations
        = (SAM_SERVER_WRITE & ~READ_CONTROL) | DELETE;
    SampObjectInformation[ SampDomainObjectType ].WriteOperations
        = (DOMAIN_WRITE & ~READ_CONTROL) | DELETE;
    SampObjectInformation[ SampGroupObjectType ].WriteOperations
        = (GROUP_WRITE & ~READ_CONTROL) | DELETE;
    SampObjectInformation[ SampAliasObjectType ].WriteOperations
        = (ALIAS_WRITE & ~READ_CONTROL) | DELETE;
    SampObjectInformation[ SampUserObjectType ].WriteOperations
        = ( USER_WRITE & ~READ_CONTROL ) | USER_WRITE_ACCOUNT |
          USER_FORCE_PASSWORD_CHANGE | USER_WRITE_GROUP_INFORMATION | DELETE;

    // Set up the names of the SAM defined object types.
    // These names are used for auditing purposes.

    RtlInitUnicodeString( &SamNameU, L"SAM_SERVER" );
    SampObjectInformation[ SampServerObjectType ].ObjectTypeName = SamNameU;
    RtlInitUnicodeString( &SamNameU, L"SAM_DOMAIN" );
    SampObjectInformation[ SampDomainObjectType ].ObjectTypeName = SamNameU;
    RtlInitUnicodeString( &SamNameU, L"SAM_GROUP" );
    SampObjectInformation[ SampGroupObjectType ].ObjectTypeName  = SamNameU;
    RtlInitUnicodeString( &SamNameU, L"SAM_ALIAS" );
    SampObjectInformation[ SampAliasObjectType ].ObjectTypeName  = SamNameU;
    RtlInitUnicodeString( &SamNameU, L"SAM_USER" );
    SampObjectInformation[ SampUserObjectType ].ObjectTypeName   = SamNameU;

    //
    // Set up the name of the SAM server object itself (rather than its type)
    //

    RtlInitUnicodeString( &SampServerObjectName, L"SAM" );

    //
    // Set up the name of the SAM server for auditing purposes
    //

    RtlInitUnicodeString( &SampSamSubsystem, SAMP_SAM_COMPONENT_NAME );

    //
    // Set up the names of well known registry keys
    //

    RtlInitUnicodeString( &SampFixedAttributeName,    L"F" );
    RtlInitUnicodeString( &SampVariableAttributeName, L"V" );
    RtlInitUnicodeString( &SampCombinedAttributeName, L"C" );

    RtlInitUnicodeString(&SampNameDomains, L"DOMAINS" );
    RtlInitUnicodeString(&SampNameDomainGroups, L"Groups" );
    RtlInitUnicodeString(&SampNameDomainAliases, L"Aliases" );
    RtlInitUnicodeString(&SampNameDomainAliasesMembers, L"Members" );
    RtlInitUnicodeString(&SampNameDomainUsers, L"Users" );
    RtlInitUnicodeString(&SampNameDomainAliasesNames, L"Names" );
    RtlInitUnicodeString(&SampNameDomainGroupsNames, L"Names" );
    RtlInitUnicodeString(&SampNameDomainUsersNames, L"Names" );



    //
    // Initialize other useful characters and strings
    //

    RtlInitUnicodeString(&SampBackSlash, L"\\");
    RtlInitUnicodeString(&SampNullString, L"");


    //
    // Initialize some useful time values
    //

    SampImmediatelyDeltaTime.LowPart = 0;
    SampImmediatelyDeltaTime.HighPart = 0;

    SampNeverDeltaTime.LowPart = 0;
    SampNeverDeltaTime.HighPart = MINLONG;

    SampHasNeverTime.LowPart = 0;
    SampHasNeverTime.HighPart = 0;

    SampWillNeverTime.LowPart = MAXULONG;
    SampWillNeverTime.HighPart = MAXLONG;


    //
    // Initialize useful encryption constants
    //

    NtStatus = RtlCalculateLmOwfPassword(&NullLmPassword, &SampNullLmOwfPassword);
    ASSERT( NT_SUCCESS(NtStatus) );

    RtlInitUnicodeString(&SamNameU, NULL);
    NtStatus = RtlCalculateNtOwfPassword(&SamNameU, &SampNullNtOwfPassword);
    ASSERT( NT_SUCCESS(NtStatus) );


    //
    // Initialize variables for the hive flushing thread
    //

    LastUnflushedChange.LowPart = 0;
    LastUnflushedChange.HighPart = 0;

    FlushThreadCreated  = FALSE;
    FlushImmediately    = FALSE;

    SampFlushThreadMinWaitSeconds   = 30;
    SampFlushThreadMaxWaitSeconds   = 600;
    SampFlushThreadExitDelaySeconds = 120;


    //
    // Enable the audit privilege (needed to use NtAccessCheckAndAuditAlarm)
    //

    NtStatus = SampEnableAuditPrivilege();

    if (!NT_SUCCESS(NtStatus)) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   " SAM SERVER:  The SAM Server could not enable the audit Privilege.\n"
                   "              Failing to initialize SAM.\n"));

        return( NtStatus );
    }

    //
    // Get Auditing Information from the LSA and save information
    // relevant to SAM.
    //

    NtStatus = LsaIQueryInformationPolicyTrusted(
                   PolicyAuditEventsInformation,
                   (PLSAPR_POLICY_INFORMATION *) &PolicyAuditEventsInfo
                   );

    if (NT_SUCCESS(NtStatus)) {

        SampSetAuditingInformation( PolicyAuditEventsInfo );

    } else {

        //
        // Failed to query Audit Information from LSA.  Allow SAM to
        // continue initializing wuth SAM Account auditing turned off.
        //

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   " SAM SERVER:  Query Audit Info from LSA returned 0x%lX\n",
                   NtStatus));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   " SAM SERVER:  Sam Account Auditing is not enabled"));

        SampSuccessAccountAuditingEnabled = FALSE;
        SampFailureAccountAuditingEnabled = FALSE;
        NtStatus = STATUS_SUCCESS;
    }

    //
    // We no longer need the Lsa Audit Events Info data.
    //

    if (PolicyAuditEventsInfo != NULL) {

        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyAuditEventsInformation,
            (PLSAPR_POLICY_INFORMATION) PolicyAuditEventsInfo
            );
    }

    //
    // Create the internal data structure and backstore lock ...
    //

    __try
    {
        RtlInitializeResource(&SampLock);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
          KdPrintEx((DPFLTR_SAMSS_ID,
                     DPFLTR_INFO_LEVEL,
                     "SAM failed to initialize SamLock under low memory condition. Exceptin thrown: 0x%x (%d)\n",
                     GetExceptionCode(),
                     GetExceptionCode()));

          NtStatus = STATUS_INSUFFICIENT_RESOURCES;
          return (NtStatus);
    }

    //
    // Initialize the group cache
    //

    NtStatus = SampInitializeGroupCache();
    if (!NT_SUCCESS(NtStatus))
    {
        return(NtStatus);
    }

    //
    // Initialize the latency counter information
    //
    NtStatus = SampInitLatencyCounter(&SampAccountGroupsLatencyInfo,
                                      DSSTAT_ACCTGROUPLATENCY,
                                      100);
    if (!NT_SUCCESS(NtStatus))
    {
        return(NtStatus);
    }

    NtStatus = SampInitLatencyCounter(&SampResourceGroupsLatencyInfo,
                                      DSSTAT_RESGROUPLATENCY,
                                      100);
    if (!NT_SUCCESS(NtStatus))
    {
        return(NtStatus);
    }

    //
    // Open the registry and make sure it includes a SAM database.
    // Also make sure this SAM database has been initialized and is
    // at a revision level we understand.
    //



    RtlInitUnicodeString( &SamParentNameU, L"\\Registry\\Machine\\Security" );
    RtlInitUnicodeString( &SamNameU, L"\\Registry\\Machine\\Security\\SAM" );



    //
    // Check if this is the Reboot after a DC promotion/demotion.
    // In this case we will have delete old sam hives and recreate new
    // hives depending upon the type of promotion operation. We create
    // new hives on all cases of role changes. The only exception to
    // the rule is the reboot after the GUI setup phase of the NT4/NT5.1 backup,
    // in which case we create the hives before the reboot in order to
    // preserve the syskey settings. The flag SAMP_TEMP_UPGRADE in promote
    // data indicates that it is the case of a reboot after a GUI mode setup
    // phase of an NT4 / NT3.51 backup domain controller.
    //

    //
    // Note the check for the admin password.  The logic here is that 
    // anytime a SAM database is recreated due to a role change there
    // should be an administrative password to set.  Also, this handles
    // the case where after a promotion, the server is immediately
    // started in ds repair mode: in this case we want to recreate
    // the database and set the password; however when starting in the
    // DS mode afterwards, we don't want to recreate the repair 
    // database again.  The act of setting the password removes
    // the registry that makes SampGetAdminPasswordFromRegistry return
    // STATUS_SUCCESS.
    //
    if (  (SampIsRebootAfterPromotion(&PromoteData)) 
       &&  NT_SUCCESS(SampGetAdminPasswordFromRegistry(NULL))
       && (!FLAG_ON( (PromoteData), SAMP_TEMP_UPGRADE ) ) )
    {
        //
        // Get rid of the old database
        //
        NtStatus = SampRegistryDelnode( SamNameU.Buffer );
        if ( !NT_SUCCESS( NtStatus ) )
        {
            //
            // This is itself is no reason to bail on initialization
            //
            NtStatus = STATUS_SUCCESS;
        }

        RecreateHives = TRUE;
    }

    if ( SampProductType == NtProductLanManNt )
    {
        //
        // The registry domain is really an account type domain
        //
        TempDatabaseProductType = NtProductServer;
        DatabaseProductType = &TempDatabaseProductType;
    }

    ASSERT( NT_SUCCESS(NtStatus) );

    InitializeObjectAttributes(
        &SamAttributes,
        &SamNameU,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    SampDumpNtOpenKey((KEY_READ | KEY_WRITE), &SamAttributes, 0);

    NtStatus = RtlpNtOpenKey(
                   &SampKey,
                   (KEY_READ | KEY_WRITE),
                   &SamAttributes,
                   0
                   );

    if ( NtStatus == STATUS_OBJECT_NAME_NOT_FOUND ) {


        if (!SampIsSetupInProgress(NULL) && !RecreateHives)
        {
            //
            // This is not a boot after dcpromo, and
            // this is not a GUI setup either, fail
            // OS startup. This prevents easy offline
            // attacks against other components in the system
            // by recreating the SAM hives
            //

            return(STATUS_UNSUCCESSFUL);
        }


#ifndef SAM_AUTO_BUILD

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL, " NEWSAM\\SERVER: Sam database not found in registry.\n"
                   "                Failing to initialize\n"));

        return(NtStatus);

#endif //SAM_AUTO_BUILD

#if DBG
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   " NEWSAM\\SERVER: Initializing SAM registry database for\n"));

        if (DatabaseProductType) {
            if (*DatabaseProductType == NtProductWinNt) {
                DbgPrint("                WinNt product.\n");
            } else if ( *DatabaseProductType == NtProductLanManNt ) {
                DbgPrint("                LanManNt product.\n");
            } else {
                DbgPrint("                Dedicated Server product.\n");
            }
        } else{
            if (SampProductType == NtProductWinNt) {
                DbgPrint("                WinNt product.\n");
            } else if ( SampProductType == NtProductLanManNt ) {
                DbgPrint("                LanManNt product.\n");
            } else {
                DbgPrint("                Dedicated Server product.\n");
            }
        }
#endif //DBG

        //
        // Change the flush thread timeouts.  This is necessary because
        // the reboot following an installation does not call
        // ExitWindowsEx() and so our shutdown notification routine does
        // not get called.  Consequently, it does not have a chance to
        // flush any changes that were obtained by syncing with a PDC.
        // If there are a large number of accounts, it could be
        // extremely expensive to do another full re-sync.  So, close
        // the flush thread wait times so that it is pretty sure to
        // have time to flush.
        //

        SampFlushThreadMinWaitSeconds   = 5;

        NtStatus = SampInitializeRegistry(SamParentNameU.Buffer,
                                          DatabaseProductType,
                                          NULL,     // Server Role - NULL implies
                                                    // call into LSA
                                          NULL,     // AccountDomainInfo - NULL implies call into
                                                    // LSA
                                          NULL,      // PrimaryDomainInfo - NULL implies call into
                                                    // LSA
                                          FALSE
                                          );


        if (!NT_SUCCESS(NtStatus)) {

            return(NtStatus);
        }

        SampDumpNtOpenKey((KEY_READ | KEY_WRITE), &SamAttributes, 0);

        NtStatus = RtlpNtOpenKey(
                       &SampKey,
                       (KEY_READ | KEY_WRITE),
                       &SamAttributes,
                       0
                       );
    }

    if (!NT_SUCCESS(NtStatus)) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL, "SAM Server: Could not access the SAM database.\n"
                   "            Status is 0x%lx \n",
                   NtStatus));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "            Failing to initialize SAM.\n"));

        return(NtStatus);
    }

    //
    // The following subroutine may be removed from the code
    // following the Daytona release.  By then it will have fixed
    // the group count.
    //

    NtStatus = SampFixGroupCount();


    //
    // We need to read the fixed attributes of the server objects.
    // Create a context to do that.
    //
    // Server Object doesn't care about DomainIndex, use 0 is fine. (10/12/2000 ShaoYin)
    // Note: we are creating a registry mode object here (DS does not start yet)
    // 

    ServerContext = SampCreateContextEx(SampServerObjectType,   // Object Type
                                        TRUE,   // trusted client
                                        FALSE,  // Registry Object, not DS object
                                        TRUE,   // Not Shared By multi Threads
                                        FALSE,  // loopback client
                                        FALSE,  // lazy commit
                                        FALSE,  // persis across calls
                                        FALSE,  // Buffer Writes
                                        FALSE,  // Opened By DCPromo
                                        0       // Domain Index
                                        );


    if ( ServerContext == NULL ) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL, "SAM Server: Could not create server context.\n"
                   "            Failing to initialize SAM.\n"));

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // The RootKey for a SERVER object is the root of the SAM database.
    // This key should not be closed when the context is deleted.
    //

    ServerContext->RootKey = SampKey;

    //
    // Get the FIXED attributes, which just consists of the revision level.
    //


    NtStatus = SampGetFixedAttributes(
                   ServerContext,
                   FALSE,
                   (PVOID *)&RevisionLevel
                   );

    if (NtStatus != STATUS_SUCCESS) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM Server: Could not access the SAM database revision level.\n"));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "            Status is 0x%lx \n",
                   NtStatus));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "            Failing to initialize SAM.\n"));

        return(NtStatus);
    }

    *Revision = *RevisionLevel;

    if ( SAMP_UNKNOWN_REVISION( *Revision ) ) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM Server: The SAM database revision level is not one supported\n"));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "            by this version of the SAM server code.  The highest revision\n"));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "            level supported is 0x%lx.  The SAM Database revision is 0x%lx \n",
                   (ULONG)SAMP_SERVER_REVISION,
                   *Revision));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "            Failing to initialize SAM.\n"));

        return(STATUS_UNKNOWN_REVISION);
    }

    SampDeleteContext( ServerContext );

    //
    // If necessary, commit a partially commited transaction.
    //

    NtStatus = RtlInitializeRXact( SampKey, TRUE, &SampRXactContext );

    if ( NtStatus == STATUS_RXACT_STATE_CREATED ) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   " SAM SERVER:  RXACT state of the SAM database didn't yet exist.\n"
                   "              Failing to initialize SAM.\n"));

        return(NtStatus);
    } else if (!NT_SUCCESS(NtStatus)) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   " SAM SERVER:  RXACT state of the SAM database didn't initialize properly.\n"));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "              Status is 0x%lx \n",
                   NtStatus));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "              Failing to initialize SAM.\n"));

        return(NtStatus);
    }

    if ( NtStatus == STATUS_RXACT_COMMITTED ) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   " SAM SERVER:  Previously aborted backstore commit was completed\n"
                   "              during SAM initialization.  This is not a cause\n"
                   "              for alarm.\n"
                   "              Continuing with SAM initialization.\n"));
    }


    //
    // Allow each sub-component of SAM a chance to initialize
    //

    // Initialize the domain objects of this DC. Each hosted domain
    // is composed of two domains: Builtin and Account. The first hosted
    // domain fills the first two elements of the SampDefinedDomains array,
    // the next hosted domain fills the next two elements, and so on.
    //
    // The first hosted domain is always setup. On a workstation or server,
    // the hosted domain contains the account information for normal opera-
    // tion. On a domain controller, this same domain contains the crash-
    // recovery accounts, used in the event that the DS is unable to start
    // or run correctly. Subsequent hosted domains (on a DC) contain the
    // account information for a normally running DC, and this account data
    // is persistently stored in the DS.

    SampDiagPrint(INFORM,
                  ("SAMSS: Initializing domain-controller domain objects\n"));

    if (!SampInitializeDomainObject())
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS:  Domain Object Intialization Failed.\n"
                   "        Failing to initialize SAM Server.\n"));

        return(STATUS_INVALID_DOMAIN_STATE);
    }

    //
    // Intialize the session key for password encryption. Note this step
    // is done before the repair boot password is set below, so that
    // syskey based encryption is achieved for the repair boot password.
    //

    NtStatus = SampInitializeSessionKey();
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Set the ds registry password if necessary
    //
    if (  SampIsRebootAfterPromotion(&PromoteData)
        && (  FLAG_ON( PromoteData, SAMP_PROMOTE_REPLICA )
           || FLAG_ON( PromoteData, SAMP_PROMOTE_DOMAIN ) ) 
        && (   ((NtProductLanManNt == SampProductType)
              && !DownlevelDcUpgrade) 
           || ((NtProductServer == SampProductType)
              && LsaISafeMode() ) )
        ) {

        (VOID) SampSetSafeModeAdminPassword();

    }

    //
    // Determine that the product is a domain controller and that it is
    // not in gui mode setup, hence, should reference the
    // DS for account data.
    //

    if (NtProductLanManNt == SampProductType
        && !DownlevelDcUpgrade)
    {
        // If the product type is a domain controller and it is not recover-
        // ing from a previous crash, reference the DS for account data.

        SampUseDsData = TRUE;
        SampDiagPrint(INFORM,
                      ("SAMSS: Domain controller is using DS data.\n"));
    }
    else
    {
        SampUseDsData = FALSE;
        SampDiagPrint(INFORM,
                      ("SAMSS: Domain controller is using registry data.\n"));
    }

    if (TRUE == SampUseDsData)
    {
        UNICODE_STRING ServerObjectRDN;
        UNICODE_STRING SystemContainerRDN;
        DSNAME         *SampSystemContainerDsName;


        //
        // Now, initialize the domain objects from the DS
        //

        NtStatus = SampDsInitializeDomainObjects();

        SampDiagPrint(INFORM,
                      ("SAMSS: SampDsInitializeDomainObjects status = 0x%lx\n",
                       NtStatus));

        if (!NT_SUCCESS(NtStatus))
        {
            // If SampDsInitializeDomainObjects failed, it is likely that the
            // DS failed to start. It is likely that the DS was unable to
            // start, be accessed, or there may be a data corruption.

            return(NtStatus);

        }

        NtStatus = SampInitializeAccountNameTable();

        if (!NT_SUCCESS(NtStatus))
        {
            //
            // If we failed to init SampAccountNameTable. We can not
            // function well
            // 

            return(NtStatus);
        }

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampInitializeAccountNameTable SUCCEED ==> %d\n",
                   NtStatus));


        //
        // Create the DS Name of the Sam server Object. The current logic assumes a hard
        // coded path for the system container / Server object. This will be changed, once
        // the new method of querying for the system container, in a rename safe way, comes
        // online
        //

        RtlInitUnicodeString(&SystemContainerRDN,L"System");

        NtStatus = SampDsCreateDsName(
                        SampDefinedDomains[DOMAIN_START_DS+1].Context->ObjectNameInDs,
                        &SystemContainerRDN,
                        &SampSystemContainerDsName
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Cannot Create the SAM server Object's Name, boot to safe mode\n"));

            return(STATUS_INVALID_DOMAIN_STATE);
        }

        RtlInitUnicodeString(&ServerObjectRDN,L"Server");

        NtStatus = SampDsCreateDsName(
                        SampSystemContainerDsName,
                        &ServerObjectRDN,
                        &SampServerObjectDsName
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Cannot Create the SAM server Object's Name, boot to safe mode \n"));

            return(STATUS_INVALID_DOMAIN_STATE);
        }

        MIDL_user_free(SampSystemContainerDsName);

        //
        // Setup notifications on object in the DS that we cache information
        // about
        // 

        NtStatus = SampSetupDsObjectNotifications();

        if (!NT_SUCCESS(NtStatus))
        {
            KdPrintEx((DPFLTR_SAMSS_ID, 
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Cannot Cache SAM server/domain Object's Security Descriptor\n"));

            return( NtStatus );
        }

        

        //
        // Initialize the well known (server / domain objects) Security 
        // Descriptor Table.
        // 

        NtStatus = SampInitWellKnownSDTable();

        if (!NT_SUCCESS(NtStatus))
        {
            KdPrintEx((DPFLTR_SAMSS_ID, 
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Cannot Cache SAM server/domain Object's Security Descriptor\n"));

            return( NtStatus );
        }


        //
        // Some win2k installations may not have the FPO container properly
        // configured
        //
        (VOID) SampDsProtectFPOContainer(NULL);

        //
        // Initialize the access Rights for NT5 Security descriptors
        //

        NtStatus = SampInitializeAccessRightsTable();

        if (!NT_SUCCESS(NtStatus))
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Cannot Initialize the access rights table, set \"samusereg\" switch in system starttup\n"));

            return(STATUS_INVALID_DOMAIN_STATE);
        }

        //
        // Initialize the site information
        //

        NtStatus = SampInitSiteInformation();

        if (!NT_SUCCESS(NtStatus))
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Cannot Initialize site information\n"));

            NtStatus = STATUS_SUCCESS;
        }

        //
        // Check for configuration information in the DomainUpdates container
        // in the DS.  This routine also registers for notification should
        // any configuration changes occurs.
        //
        NtStatus = SampCheckDomainUpdates(NULL);
        if (!NT_SUCCESS(NtStatus))
        {
            return NtStatus;
        }


        SampIsMachineJoinedToDomain = TRUE;
    }
    else
    {
        // 
        // This machine is not a DC
        // check whether it is running Personal SKU
        // if not, if it joins to a domain
        // 
        OSVERSIONINFOEXW osvi;

        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
        if(GetVersionExW((OSVERSIONINFOW*)&osvi))
        {
            if ( osvi.wProductType == VER_NT_WORKSTATION && (osvi.wSuiteMask & VER_SUITE_PERSONAL))
            {
                SampPersonalSKU = TRUE;
            }
        } 

        if (!SampPersonalSKU)
        {
            NTSTATUS                    NtStatus2 = STATUS_SUCCESS;
            PLSAPR_POLICY_INFORMATION   pPolicyInfo = NULL;

            // 
            // Determine if this machine joins to a domain. 
            // 
            NtStatus2 = LsaIQueryInformationPolicyTrusted(
                                    PolicyPrimaryDomainInformation,
                                    &pPolicyInfo
                                    );

            if (NT_SUCCESS(NtStatus2))
            {
                PSID    AccountDomainSid = NULL;

                AccountDomainSid = SampDefinedDomains[ DOMAIN_START_REGISTRY + 1 ].Sid;

                // primary domain sid is not NULL and is not equal to local 
                // account domain sid. This machine must be joined to a domain
                if (pPolicyInfo->PolicyPrimaryDomainInfo.Sid &&
                    (!RtlEqualSid(AccountDomainSid, 
                                  pPolicyInfo->PolicyPrimaryDomainInfo.Sid)) )
                {
                    SampIsMachineJoinedToDomain = TRUE;
                }

                LsaIFree_LSAPR_POLICY_INFORMATION(PolicyPrimaryDomainInformation, 
                                                  pPolicyInfo);
            }
        }
    }
    

    //
    // Check if the machine is syskey'd and if not then syskey the machine
    //

    NtStatus = SampApplyDefaultSyskey();
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Notify netlogon of our role if this is gui mode setup for
    // a DC upgrade
    //
    if (  DownlevelDcUpgrade
      && (SampProductType == NtProductLanManNt)  )
    {
        POLICY_LSA_SERVER_ROLE LsaServerRole;

        // The DS should not be running
        ASSERT( !SampUseDsData );

        switch ( SampDefinedDomains[SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX].ServerRole )
        {
            case DomainServerRolePrimary:
                LsaServerRole= PolicyServerRolePrimary;
                break;

            case DomainServerRoleBackup:
                LsaServerRole = PolicyServerRoleBackup;
                break;

            default:
                ASSERT(FALSE && "InvalidServerRole");
                LsaServerRole = PolicyServerRoleBackup;
        }

        (VOID) I_NetNotifyRole( LsaServerRole );
    }

    //
    //  Initialize and Check Net Logon Change Numbers
    //  to support any Down Level Replication
    //

    NtStatus = SampQueryNetLogonChangeNumbers();
    if (!NT_SUCCESS(NtStatus))
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: Failed to query netlogon change Numbers 0x%x\n",
                   NtStatus));

        //
        // Reset the status code to success. Do not let boot fail
        //

        NtStatus = STATUS_SUCCESS;
    }

    //
    // Build null session token handle. Also initializes token source info
    //

    NtStatus = SampCreateNullToken();
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS:  Unable to create NULL token: 0x%x\n",
                   NtStatus));

        return(NtStatus);
    }

    //
    // Tell the LSA that we have started. Ignore the
    // error code.
    //

    if (SampUseDsData)
    {
        NtStatus = LsaISamIndicatedDsStarted( TRUE );

        if ( !NT_SUCCESS( NtStatus )) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS:  Failed to notify LSA of DS startup: 0x%x.\n"
                       "        Failing to initialize SAM Server.\n",
                       NtStatus));

            return(NtStatus);
        }
    }

    //
    // Load the password-change notification packages.
    //

    NtStatus = SampLoadNotificationPackages( );

    if (!NT_SUCCESS(NtStatus)) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS:  Failed to load notification packagees: 0x%x.\n"
                   "        Failing to initialize SAM Server.\n",
                   NtStatus));

        return(NtStatus);
    }

    //
    //
    // Load the password filter DLL if there is one
    //

    SampLoadPasswordFilterDll();



    //
    // Start the RPC server...
    //

    //
    // Publish the sam server interface package...
    //
    // NOTE:  Now all RPC servers in lsass.exe (now winlogon) share the same
    // pipe name.  However, in order to support communication with
    // version 1.0 of WinNt,  it is necessary for the Client Pipe name
    // to remain the same as it was in version 1.0.  Mapping to the new
    // name is performed in the Named Pipe File System code.
    //



     ServiceName = L"lsass";
     NtStatus = RpcpAddInterface( ServiceName, samr_ServerIfHandle);




    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS:  Could Not Start RPC Server.\n"
                   "        Failing to initialize SAM Server.\n"
                   "        Status is: 0x%lx\n",
                   NtStatus));

        return(NtStatus);
    }

    //
    // If we are running as a netware server, for Small World or FPNW,
    // register an SPX endpoint and some authentication info.
    //

    SampStartNonNamedPipeTransports();


    //
    // Create a thread to start authenticated RPC.
    //

    ThreadHandle = CreateThread(
                        NULL,
                        0,
                        (LPTHREAD_START_ROUTINE) SampSecureRpcInit,
                        NULL,
                        0,
                        &ThreadId
                        );


    if (ThreadHandle == NULL) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS:  Unable to create thread: %d\n",
                   GetLastError()));

        return(STATUS_INVALID_HANDLE);

    }
    else {
        CloseHandle(ThreadHandle);
    }

    return(NtStatus);
}


NTSTATUS
SampInitializeWellKnownSids( VOID )

/*++

Routine Description:

    This routine initializes some global well-known sids.



Arguments:

    None.

Return Value:

    STATUS_SUCCESS - Initialization has successfully completed.

    STATUS_NO_MEMORY - Couldn't allocate memory for the sids.

--*/
{
    NTSTATUS
        NtStatus;

    PPOLICY_ACCOUNT_DOMAIN_INFO
        DomainInfo;

    //
    //      WORLD is s-1-1-0
    //  ANONYMOUS is s-1-5-7
    //

    SID_IDENTIFIER_AUTHORITY
            WorldSidAuthority       =   SECURITY_WORLD_SID_AUTHORITY,
            NtAuthority             =   SECURITY_NT_AUTHORITY;

    SAMTRACE("SampInitializeWellKnownSids");


    NtStatus = RtlAllocateAndInitializeSid(
                   &NtAuthority,
                   1,
                   SECURITY_ANONYMOUS_LOGON_RID,
                   0, 0, 0, 0, 0, 0, 0,
                   &SampAnonymousSid
                   );
    if (NT_SUCCESS(NtStatus)) {
        NtStatus = RtlAllocateAndInitializeSid(
                       &WorldSidAuthority,
                       1,                      //Sub authority count
                       SECURITY_WORLD_RID,     //Sub authorities (up to 8)
                       0, 0, 0, 0, 0, 0, 0,
                       &SampWorldSid
                       );
        if (NT_SUCCESS(NtStatus)) {
            NtStatus = RtlAllocateAndInitializeSid(
                            &NtAuthority,
                            2,
                            SECURITY_BUILTIN_DOMAIN_RID,
                            DOMAIN_ALIAS_RID_ADMINS,
                            0, 0, 0, 0, 0, 0,
                            &SampAdministratorsAliasSid
                            );
            if (NT_SUCCESS(NtStatus)) {
                NtStatus = RtlAllocateAndInitializeSid(
                                &NtAuthority,
                                2,
                                SECURITY_BUILTIN_DOMAIN_RID,
                                DOMAIN_ALIAS_RID_ACCOUNT_OPS,
                                0, 0, 0, 0, 0, 0,
                                &SampAccountOperatorsAliasSid
                                );
                if (NT_SUCCESS(NtStatus)) {
                    NtStatus = RtlAllocateAndInitializeSid(
                                    &NtAuthority,
                                    1,
                                    SECURITY_AUTHENTICATED_USER_RID,
                                    0, 0, 0, 0, 0, 0, 0,
                                    &SampAuthenticatedUsersSid
                                    );
                    if (NT_SUCCESS(NtStatus)) {
                        NtStatus = RtlAllocateAndInitializeSid(
                                        &NtAuthority,
                                        1,
                                        SECURITY_PRINCIPAL_SELF_RID,
                                        0,0, 0, 0, 0, 0, 0,
                                        &SampPrincipalSelfSid
                                        );
                        if (NT_SUCCESS(NtStatus)) {
                            NtStatus = RtlAllocateAndInitializeSid(
                                            &NtAuthority,
                                            1,
                                            SECURITY_BUILTIN_DOMAIN_RID,
                                            0,0, 0, 0, 0, 0, 0,
                                            &SampBuiltinDomainSid
                                            );
                            if (NT_SUCCESS(NtStatus)) {
                                NtStatus = SampGetAccountDomainInfo( &DomainInfo );
                                if (NT_SUCCESS(NtStatus)) {
                                    NtStatus = SampCreateFullSid( DomainInfo->DomainSid,
                                                                  DOMAIN_USER_RID_ADMIN,
                                                                  &SampAdministratorUserSid
                                                                  );
                                    
                                    if (NT_SUCCESS(NtStatus)) {
                                        NtStatus = SampCreateFullSid( 
                                                       DomainInfo->DomainSid,
                                                       DOMAIN_GROUP_RID_ADMINS,
                                                       &SampDomainAdminsGroupSid
                                                       );
                                    }
                                    
                                    MIDL_user_free( DomainInfo );

                                    if (NT_SUCCESS(NtStatus)) {
                                        NtStatus = RtlAllocateAndInitializeSid(
                                                       &NtAuthority, 
                                                       1, 
                                                       SECURITY_LOCAL_SYSTEM_RID, 
                                                       0, 0, 0, 0, 0, 0, 0, 
                                                       &SampLocalSystemSid
                                                       );
                                    if (NT_SUCCESS(NtStatus)) {
                                         NtStatus = RtlAllocateAndInitializeSid(
                                                       &NtAuthority,
                                                       1,
                                                       SECURITY_NETWORK_RID,
                                                       0, 0, 0, 0, 0, 0, 0,
                                                       &SampNetworkSid
                                                       );
                                         if (NT_SUCCESS(NtStatus)) {
                                             NtStatus = RtlAllocateAndInitializeSid(
                                                            &NtAuthority,
                                                            1,
                                                            SECURITY_ENTERPRISE_CONTROLLERS_RID,
                                                            0, 0, 0, 0, 0, 0, 0,
                                                            &SampEnterpriseDomainControllersSid
                                                            );
                                             if (NT_SUCCESS(NtStatus)) {
                                                 NtStatus = RtlAllocateAndInitializeSid(
                                                               &NtAuthority,
                                                               1,
                                                               SECURITY_NETWORK_SERVICE_RID,
                                                               0, 0, 0, 0, 0, 0, 0,
                                                               &SampNetworkServiceSid
                                                               );
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

        }
    }

    return(NtStatus);
}



VOID
SampLoadPasswordFilterDll(
    VOID
    )

/*++

Routine Description:

    This function loads a DLL to do password filtering.  This DLL is
    optional and is expected to be used by ISVs or customers to do
    things like dictionary lookups and other simple algorithms to
    reject any password deemed too risky to allow a user to use.

    For example, user initials or easily guessed password might be
    rejected.

Arguments:

    None.

Return Value:

    None.


--*/

{


#if NOT_YET_SUPPORTED
    NTSTATUS Status, IgnoreStatus, MsProcStatus;
    PVOID ModuleHandle;
    STRING ProcedureName;

    UNICODE_STRING FileName;

    PSAM_PF_INITIALIZE  InitializeRoutine;



    //
    // Indicate the dll has not yet been loaded.
    //

    SampPasswordFilterDllRoutine = NULL;



    RtlInitUnicodeString( &FileName, L"PwdFiltr" );
    Status = LdrLoadDll( NULL, NULL, &FileName, &ModuleHandle );


    if (!NT_SUCCESS(Status)) {
        return;
    }

    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "Samss: Loading Password Filter DLL - %Z\n",
               &FileName));

    //
    // Now get the address of the password filter DLL routines
    //

    RtlInitString( &ProcedureName, SAM_PF_NAME_INITIALIZE );
    Status = LdrGetProcedureAddress(
                 ModuleHandle,
                 &ProcedureName,
                 0,
                 (PVOID *)&InitializeRoutine
                 );

    if (!NT_SUCCESS(Status)) {

        //
        // We found the DLL, but couldn't get its initialization routine
        // address
        //

        // FIX, FIX - Log an error

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "Samss: Couldn't get password filter DLL init routine address.\n"
                   "       Status is:  0x%lx\n",
                   Status));

        IgnoreStatus = LdrUnloadDll( ModuleHandle );
        return;
    }


    RtlInitString( &ProcedureName, SAM_PF_NAME_PASSWORD_FILTER );
    Status = LdrGetProcedureAddress(
                 ModuleHandle,
                 &ProcedureName,
                 0,
                 (PVOID *)&SampPasswordFilterDllRoutine
                 );

    if (!NT_SUCCESS(Status)) {

        //
        // We found the DLL, but couldn't get its password filter routine
        // address
        //

        // FIX, FIX - Log an error

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "Samss: Couldn't get password filter routine address from loaded DLL.\n"
                   "       Status is:  0x%lx\n",
                   Status));

        IgnoreStatus = LdrUnloadDll( ModuleHandle );
        return;
    }




    //
    // Now initialize the DLL
    //

    Status = (InitializeRoutine)();

    if (!NT_SUCCESS(Status)) {

        //
        // We found the DLL and loaded its routine addresses, but it returned
        // and error from its initialize routine.
        //

        // FIX, FIX - Log an error

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "Samss: Password filter DLL returned error from initialization routine.\n");
                   "       Status is:  0x%lx\n",
                   Status));

        SampPasswordFilterDllRoutine = NULL;
        IgnoreStatus = LdrUnloadDll( ModuleHandle );
        return;
    }

#endif // NOT_YET_SUPPORTED
    return;


}


NTSTATUS
SampEnableAuditPrivilege( VOID )

/*++

Routine Description:

    This routine enables the SAM process's AUDIT privilege.
    This privilege is necessary to use the NtAccessCheckAndAuditAlarm()
    service.



Arguments:

    None.

Return Value:




--*/

{
    NTSTATUS NtStatus, IgnoreStatus;
    HANDLE Token;
    LUID AuditPrivilege;
    PTOKEN_PRIVILEGES NewState;
    ULONG ReturnLength;

    SAMTRACE("SampEnableAuditPrivilege");

    //
    // Open our own token
    //

    NtStatus = NtOpenProcessToken(
                 NtCurrentProcess(),
                 TOKEN_ADJUST_PRIVILEGES,
                 &Token
                 );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Initialize the adjustment structure
    //

    AuditPrivilege =
        RtlConvertLongToLuid(SE_AUDIT_PRIVILEGE);

    ASSERT( (sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)) < 100);
    NewState = RtlAllocateHeap(RtlProcessHeap(), 0, 100 );
    if (NULL==NewState)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    NewState->PrivilegeCount = 1;
    NewState->Privileges[0].Luid = AuditPrivilege;
    NewState->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    //
    // Set the state of the privilege to ENABLED.
    //

    NtStatus = NtAdjustPrivilegesToken(
                 Token,                            // TokenHandle
                 FALSE,                            // DisableAllPrivileges
                 NewState,                         // NewState
                 0,                                // BufferLength
                 NULL,                             // PreviousState (OPTIONAL)
                 &ReturnLength                     // ReturnLength
                 );

    //
    // Clean up some stuff before returning
    //

    RtlFreeHeap( RtlProcessHeap(), 0, NewState );
    IgnoreStatus = NtClose( Token );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    return NtStatus;
}


VOID
SampPerformInitializeFailurePopup( NTSTATUS ErrorStatus )
/*++

Routine Description:

    This routine will give the user the shutdown option and
    instruct him to boot to safe mode if we are running in Registry Case.
    If this is a Domain Controller, then direct user to boot into DS
    Repair Mode.

Arguments:

    Error Status Code which causes the failure.

Return Value:

    None

--*/
{
    UINT     PreviousMode;
    ULONG    Response;
    ULONG    Win32Error = 0;
    HMODULE  ResourceDll;
    BOOLEAN  WasEnabled;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    UINT_PTR ErrorParameters[2];
    WCHAR    * ErrorMessage = NULL;
    WCHAR    * ArgArray[4];
    UNICODE_STRING  ErrorString;

    //
    // First, construct the Message String for the Error which caused SAM failure.
    //

    //
    // FormatMessage() Can NOT construct correct message string with additional
    // arguments for NTSTATUS code. FormatMessage() can ONLY format message with
    // additional parameters for Win32/DOS error code.
    // So we need to map NTSTATUS code to Win32 error code.
    //
    // If fail to map the NTSTATUS code to Win32 Code,
    // then try to get message string from without insert.
    //
    //
    ArgArray[0] = NULL;
    ArgArray[1] = NULL;
    ArgArray[2] = NULL;
    ArgArray[3] = NULL;

    Win32Error = RtlNtStatusToDosError(ErrorStatus);

    if (ERROR_MR_MID_NOT_FOUND == Win32Error)
    {
        //
        // Get Message String from NTSTATUS code
        //
        ResourceDll = (HMODULE) GetModuleHandle( L"ntdll.dll" );

        if (NULL != ResourceDll)
        {
            FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE |    // find message from ntdll.dll
                           FORMAT_MESSAGE_IGNORE_INSERTS |  // do not insert
                           FORMAT_MESSAGE_ALLOCATE_BUFFER,  // please allocate buffer for me
                           ResourceDll,                     // source dll
                           ErrorStatus,                     // message ID
                           0,                               // language ID 
                           (LPWSTR)&ErrorMessage,           // address of return Message String
                           0,                               // maximum buffer size if not 0
                           NULL                             // can not insert arguments, so set to NULL
                           );

            FreeLibrary(ResourceDll);
        }
    }
    else
    {
        //
        // Get Message String from Win32 Code (mapped from ntstatus)
        //
        FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |     // find message from system resource table
                       FORMAT_MESSAGE_ARGUMENT_ARRAY |  // insert arguments which are all NULL
                       FORMAT_MESSAGE_ALLOCATE_BUFFER,  // please allocate buffer for me
                       NULL,                            // from system, so NULL here
                       Win32Error,                      // use the Win32Error
                       0,                               // language ID
                       (LPWSTR)&ErrorMessage,           // address of return message string
                       0,                               // maximum buffer size if not 0
                       (va_list *) &(ArgArray)          // arguments for inserting, all NULL
                       );

    }

    if (ErrorMessage) {
        RtlInitUnicodeString(&ErrorString,
                             ErrorMessage
                             );
    }
    else {
        RtlInitUnicodeString(&ErrorString,
                             L"Unmapped Error"
                             );
    }

    ErrorParameters[0] = (UINT_PTR)&ErrorString;
    ErrorParameters[1] = (UINT_PTR)ErrorStatus;

    //
    // Adjust Error Mode, so that we can get the popup Message Box
    //
    PreviousMode = SetErrorMode(0);

    //
    // Display different error message in different situation.
    //
    if (SampDsInitializationFailed && (STATUS_DS_CANT_START != ErrorStatus))
    {
        //
        // SampDsInitializationFailed will be set to TRUE
        // when DS fails to start
        //
        // Error code will be set to STATUS_DS_CANT_START if DS failed to
        // start and returned meaningless STATUS_UNSUCCESSFUL.
        //
        if (SampIsSetupInProgress(NULL))
        {
            Status = STATUS_DS_INIT_FAILURE_CONSOLE; 
        }
        else
        {
            Status = STATUS_DS_INIT_FAILURE;
        }
    }
    else
    {
        if (TRUE == SampUseDsData)
        {

            if (SampIsSetupInProgress(NULL))
            {
                // We are in DS mode and during GUI mode setup, 
                // should instruct user to boot into Recovery Console.
                Status = STATUS_DS_SAM_INIT_FAILURE_CONSOLE; 
            }
            else
            {
                //
                // We are in DS mode, should tell user to boot into DS Repair Mode
                //
                Status = STATUS_DS_SAM_INIT_FAILURE;
            }
        }
        else
        {
            //
            // We are in Registry mode, should boot into Safe Mode
            //
            Status = STATUS_SAM_INIT_FAILURE;
        }
    }

    NtStatus = NtRaiseHardError(
                            Status, // Status Code
                            2,  // number of parameters
                            1,  // Unicode String Mask
                            ErrorParameters,
                            OptionOk,
                            &Response
                            );

    SetErrorMode(PreviousMode);

    if (NT_SUCCESS(NtStatus) && Response==ResponseOk) {

        //
        // If the user is ok with shutdown, adjust privilege level,
        // issue shutdown request.
        //
        RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                            TRUE,       // enable shutdown privilege.
                            FALSE,
                            &WasEnabled
                           );

        //
        // Shutdown and Reboot now.
        // Note: use NtRaiseHardError to shutdown the machine will result Bug Check
        //

        NtShutdownSystem(ShutdownReboot);

        //
        // if Shutdown request failed, (returned from above API)
        // reset shutdown privilege to previous value.
        //
        RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                            WasEnabled,   // reset to previous state.
                            FALSE,
                            &WasEnabled
                           );

    }

    if (ErrorMessage != NULL) {
        LocalFree(ErrorMessage);
    }

    return;

}




NTSTATUS
SampFixGroupCount( VOID )

/*++

Routine Description:

    This routine fixes the group count of the account domain.
    A bug in early Daytona beta systems left the group count
    too low (by one).  This routine fixes that problem by
    setting the value according to however many groups are found
    in the registry.


Arguments:

    None - uses the gobal variable "SampKey".


Return Value:

    The status value of the registry services needed to query
    and set the group count.


--*/

{
    NTSTATUS
        NtStatus,
        IgnoreStatus;

    OBJECT_ATTRIBUTES
        ObjectAttributes;

    UNICODE_STRING
        KeyName,
        NullName;

    HANDLE
        AccountHandle;

    ULONG
        ResultLength,
        GroupCount = 0;

    PKEY_FULL_INFORMATION
        KeyInfo;

    SAMTRACE("SampFixGroupCount");


    RtlInitUnicodeString( &KeyName,
                          L"DOMAINS\\Account\\Groups"
                          );


    //
    // Open this key.
    // Query the number of sub-keys in the key.
    // The number of groups is one less than the number
    // of values (because there is one key called "Names").
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                SampKey,
                                NULL
                                );

    SampDumpNtOpenKey((KEY_READ | KEY_WRITE), &ObjectAttributes, 0);

    NtStatus = RtlpNtOpenKey(
                   &AccountHandle,
                   (KEY_READ | KEY_WRITE),
                   &ObjectAttributes,
                   0
                   );

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = NtQueryKey(
                     AccountHandle,
                     KeyFullInformation,
                     NULL,                  // Buffer
                     0,                     // Length
                     &ResultLength
                     );

        SampDumpNtQueryKey(KeyFullInformation,
                           NULL,
                           0,
                           &ResultLength);

        if (NtStatus == STATUS_BUFFER_OVERFLOW  ||
            NtStatus == STATUS_BUFFER_TOO_SMALL) {

            KeyInfo = RtlAllocateHeap( RtlProcessHeap(), 0, ResultLength);
            if (KeyInfo == NULL) {

                NtStatus = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                NtStatus = NtQueryKey(
                             AccountHandle,
                             KeyFullInformation,
                             KeyInfo,               // Buffer
                             ResultLength,          // Length
                             &ResultLength
                             );

                SampDumpNtQueryKey(KeyFullInformation,
                                   KeyInfo,
                                   ResultLength,
                                   &ResultLength);

                if (NT_SUCCESS(NtStatus)) {
                    GroupCount = (KeyInfo->SubKeys - 1);
                }

                RtlFreeHeap( RtlProcessHeap(), 0, KeyInfo );
            }
        }


        if (NT_SUCCESS(NtStatus)) {

            RtlInitUnicodeString( &NullName, NULL );
            NtStatus = NtSetValueKey(
                         AccountHandle,
                         &NullName,                 // Null value name
                         0,                         // Title Index
                         GroupCount,                // Count goes in Type field
                         NULL,                      // No data
                         0
                         );
        }


        IgnoreStatus = NtClose( AccountHandle );
        ASSERT( NT_SUCCESS(IgnoreStatus) );
    }

    return(NtStatus);


}


#ifdef SAMP_SETUP_FAILURE_TEST

NTSTATUS
SampInitializeForceError(
    OUT PNTSTATUS ForcedStatus
    )

/*++

Routine Description:

    This function forces an error to occur in the SAM initialization/installation.
    The error to be simulated is specified by storing the desired Nt Status
    value to be simulated in the REG_DWORD registry key valie PhonyLsaError
    in HKEY_LOCAL_MACHINE\System\Setup.

Arguments:

    ForcedStatus - Receives the Nt status code to be simulated.  If set to a
        non-success status, SAM initialization is bypassed and the specified
        status code is set instead.  If STATUS_SUCCESS is returned, no
        simulation takes place and SAM initializes as it would normally.

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS OutputForcedStatus = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle = NULL;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation = NULL;
    ULONG KeyValueInfoLength;
    ULONG ResultLength;
    UNICODE_STRING KeyPath;
    UNICODE_STRING ValueName;

    SAMTRACE("SampInitializeForceError");


    RtlInitUnicodeString( &KeyPath, L"\\Registry\\Machine\\System\\Setup" );
    RtlInitUnicodeString( &ValueName, L"PhonyLsaError" );

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    SampDumpNtOpenKey((MAXIMUM_ALLOWED), &ObjectAttributes, 0);

    NtStatus = NtOpenKey( &KeyHandle, MAXIMUM_ALLOWED, &ObjectAttributes);

    if (!NT_SUCCESS( NtStatus )) {

        //
        // If the error is simply that the registry key does not exist,
        // do not simulate an error and allow SAM initialization to
        // proceed.
        //

        if (NtStatus != STATUS_OBJECT_NAME_NOT_FOUND) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtOpenKey for Phony Lsa Error failed 0x%lx\n",
                       NtStatus));

            goto InitializeForceErrorError;
        }

        NtStatus = STATUS_SUCCESS;

        goto InitializeForceErrorFinish;
    }

    KeyValueInfoLength = 256;

    NtStatus = STATUS_NO_MEMORY;

    KeyValueInformation = RtlAllocateHeap(
                              RtlProcessHeap(),
                              0,
                              KeyValueInfoLength
                              );

    if (KeyValueInformation == NULL) {

        goto InitializeForceErrorError;
    }

    NtStatus = NtQueryValueKey(
                   KeyHandle,
                   &ValueName,
                   KeyValueFullInformation,
                   KeyValueInformation,
                   KeyValueInfoLength,
                   &ResultLength
                   );

    SampDumpNtQueryValueKey(&ValueName,
                            KeyValueFullInformation,
                            KeyValueInformation,
                            KeyValueInfoLength,
                            &ResultLength);

    if (!NT_SUCCESS(NtStatus)) {

        //
        // If the error is simply that that the PhonyLsaError value has not
        // been set, do not simulate an error and instead allow SAM initialization
        // to proceed.
        //

        if (NtStatus != STATUS_OBJECT_NAME_NOT_FOUND) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: NtQueryValueKey for Phony Lsa Error failed 0x%lx\n",
                       NtStatus));

            goto InitializeForceErrorError;
        }

        NtStatus = STATUS_SUCCESS;
        goto InitializeForceErrorFinish;
    }

    NtStatus = STATUS_INVALID_PARAMETER;

    if (KeyValueInformation->Type != REG_DWORD) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: Key for Phony Lsa Error is not REG_DWORD type"));

        goto InitializeForceErrorError;
    }

    NtStatus = STATUS_SUCCESS;

    //
    // Obtain the error code stored as the registry key value
    //

    OutputForcedStatus = *((NTSTATUS *)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset));

InitializeForceErrorFinish:

    //
    // Clean up our resources.
    //

    if (KeyValueInformation != NULL) {

        RtlFreeHeap( RtlProcessHeap(), 0, KeyValueInformation );
    }

    if (KeyHandle != NULL) {

        NtClose( KeyHandle );
    }

    *ForcedStatus = OutputForcedStatus;
    return(NtStatus);

InitializeForceErrorError:

    goto InitializeForceErrorFinish;
}

#endif // SAMP_SETUP_FAILURE_TEST



#if SAMP_DIAGNOSTICS

VOID
SampActivateDebugProcess( VOID )

/*++

Routine Description:

    This function activates a process with a time delay.
    The point of this action is to provide some diagnostic capabilities
    during SETUP.  This originated out of the need to run dh.exe (to get
    a heap dump of LSASS.exe) during setup.



Arguments:

    Arguments are provided via global variables.  The debug user is
    given an opportunity to change these string values before the
    process is activated.

Return Values:

    None.

--*/

{
    NTSTATUS
        NtStatus;

    HANDLE
        Thread;

    DWORD
        ThreadId;

    IF_NOT_SAMP_GLOBAL( ACTIVATE_DEBUG_PROC ) {
        return;
    }

    //
    // Do all the work in another thread so that it can wait before
    // activating the debug process.
    //

    Thread = CreateThread(
                 NULL,
                 0L,
                 (LPTHREAD_START_ROUTINE)SampActivateDebugProcessWrkr,
                 0L,
                 0L,
                 &ThreadId
                 );
    if (Thread != NULL) {
        (VOID) CloseHandle( Thread );
    }


    return;
}


NTSTATUS
SampActivateDebugProcessWrkr(
    IN PVOID ThreadParameter
    )

/*++

Routine Description:

    This function activates a process with a time delay.
    The point of this action is to provide some diagnostic capabilities
    during SETUP.  This originated out of the need to run dh.exe (to get
    a heap dump of LSASS.exe) during setup.

    The user is given the opportunity to change any or all of the
    following values before the process is activated (and before
    we wait):

                Seconds until activation
                Image to activate
                Command line to image


Arguments:

    ThreadParameter - Not used.

Return Values:

    STATUS_SUCCESS

--*/

{
    NTSTATUS
        NtStatus;

    UNICODE_STRING
        CommandLine;

    ULONG
        Delay = 30;          // Number of seconds

    SECURITY_ATTRIBUTES
        ProcessSecurityAttributes;

    STARTUPINFO
        StartupInfo;

    PROCESS_INFORMATION
        ProcessInformation;

    SECURITY_DESCRIPTOR
        SD;

    BOOL
        Result;


    RtlInitUnicodeString( &CommandLine,
                          TEXT("dh.exe -p 33") );


    //
    // Give the user an opportunity to change parameter strings...
    //

    SampDiagPrint( ACTIVATE_DEBUG_PROC,
                   ("SAM: Diagnostic flags are set to activate a debug process...\n"
                    " The following parameters are being used:\n\n"
                    "   Command Line [0x%lx]:   *%wZ*\n"
                    "   Seconds to activation [address: 0x%lx]:   %d\n\n"
                    " Change parameters if necessary and then proceed.\n"
                    " Use |# command at the ntsd prompt to see the process ID\n"
                    " of lsass.exe\n",
                    &CommandLine, &CommandLine,
                    &Delay, Delay) );

    DbgBreakPoint();

    //
    // Wait for Delay seconds ...
    //

    Sleep( Delay*1000 );

    SampDiagPrint( ACTIVATE_DEBUG_PROC,
                   ("SAM: Activating debug process %wZ\n",
                    &CommandLine) );
    //
    // Initialize process security info
    //

    InitializeSecurityDescriptor( &SD ,SECURITY_DESCRIPTOR_REVISION1 );
    ProcessSecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
    ProcessSecurityAttributes.lpSecurityDescriptor = &SD;
    ProcessSecurityAttributes.bInheritHandle = FALSE;

    //
    // Initialize process startup info
    //

    RtlZeroMemory( &StartupInfo, sizeof(StartupInfo) );
    StartupInfo.cb = sizeof(STARTUPINFO);
    StartupInfo.lpReserved = CommandLine.Buffer;
    StartupInfo.lpTitle = CommandLine.Buffer;
    StartupInfo.dwX =
        StartupInfo.dwY =
        StartupInfo.dwXSize =
        StartupInfo.dwYSize = 0L;
    StartupInfo.dwFlags = STARTF_FORCEOFFFEEDBACK;
    StartupInfo.wShowWindow = SW_SHOW;   // let it be seen if possible
    StartupInfo.lpReserved2 = NULL;
    StartupInfo.cbReserved2 = 0;


    //
    // Now create the diagnostic process...
    //

    Result = CreateProcess(
                      NULL,             // Image name
                      CommandLine.Buffer,
                      &ProcessSecurityAttributes,
                      NULL,         // ThreadSecurityAttributes
                      FALSE,        // InheritHandles
                      CREATE_UNICODE_ENVIRONMENT,   //Flags
                      NULL,  //Environment,
                      NULL,  //CurrentDirectory,
                      &StartupInfo,
                      &ProcessInformation);

    if (!Result) {
        SampDiagPrint( ACTIVATE_DEBUG_PROC,
                       ("SAM: Couldn't activate diagnostic process.\n"
                        "     Error: 0x%lx (%d)\n\n",
                        GetLastError(), GetLastError()) );
    }

    return(STATUS_SUCCESS);         // Exit this thread
}
#endif // SAMP_DIAGNOSTICS


NTSTATUS
SampQueryNetLogonChangeNumbers()
/*++

    Routine Description

        Queries Netlogon for the change Log Serial Number

    Parameters

          None:

    Return Values

       STATUS_SUCCESS;
       Other Values from Netlogon API
--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    ULONG           i;
    LARGE_INTEGER   NetLogonChangeLogSerialNumber;

    //
    // On a Per domain basis query netlogon for the change log serial Number
    //

    for (i=0;i<SampDefinedDomainsCount;i++)
    {

        if ((IsDsObject(SampDefinedDomains[i].Context))
            && (DomainServerRolePrimary==SampDefinedDomains[i].ServerRole))
        {
            BOOLEAN         FlushRequired = FALSE;

            NtStatus =   I_NetLogonGetSerialNumber(
                                SecurityDbSam,
                                SampDefinedDomains[i].Sid,
                                &(NetLogonChangeLogSerialNumber)
                                );

            if (STATUS_INVALID_DOMAIN_ROLE == NtStatus)
            {

                //
                // Not PDC then just set to 1, netlogon will ignore notifications anyway
                //

               SampDiagPrint(INFORM,("I_NetLogonGetSerialNumber Returned %x for Domain %d\n",
                                            NtStatus,i));

               SampDefinedDomains[i].NetLogonChangeLogSerialNumber.QuadPart = 1;
               NtStatus = STATUS_SUCCESS;
            }
            else if (!NT_SUCCESS(NtStatus))
            {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS:  Could not Query Serial Number From Netlogon, Error = %x\n",
                           NtStatus));

                return(NtStatus);
            }


            //
            // Acquire Write Lock
            //

            NtStatus = SampAcquireWriteLock();
            if (!NT_SUCCESS(NtStatus))
            {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: Unable to Acquire Write Lock to flush Serial Number, Error = %x\n",
                           NtStatus));

                return (NtStatus);
            }

            //
            // Validate the Domain Cache if necessary, as release write lock without
            // flushing invalidates it
            //

            NtStatus = SampValidateDomainCache();
            if (!NT_SUCCESS(NtStatus))
            {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: Unable to Validate Domain Cache while initializing %x\n",
                           NtStatus));

                SampReleaseWriteLock(FALSE);
                return (NtStatus);
            }

            //
            // Make the present domain the transaction domain. This will make the commit code, run part of
            // release write lock commit the correct domain.
            //

            SampSetTransactionDomain(i);

            //
            // There are now 3 Cases.
            //
            // Case 1 -- The Netlogon Change Log Serial Number is Equal to the domain
            //           Modified Count. This is the clean flush case. In this case
            //           the domain modified Count is the serial number
            // Case 2 -- The Netlogon Change Log Serial Number is > the domain modified count
            //           This corresponds to an unclean shut down, or failed Ds Commit. The Change
            //           Serial number is then the one queried from the log.
            // Case 3 -- The Netlogon Change Serial Number is less than the change serial number in
            //           the modified count property of the domain object and the domain is not a builtin
            //           domain. This corresponds to some sort of error with the log.
            //           The only recourse in this case is a full sync.
            // Case 4 -- Same as Case 3, but builtin domain. In this case the number on the modified count
            //           property on the domain object prevails. We make the assumption that the modified count
            //           propety on the builtin domain object is always an accurate value. This is true as
            //           long as there are no failed commits. However in case of failed commits we expect to
            //           hit 2. To hit 4 means that the commit on the builtin domain failed plus a huge
            //           number of commits succeeded after that on the account domain, such as to wrap the log,
            //           plus the machine crashed such that we could not flush the latest modified count. The
            //           end result of this is that backup domain controllers will skip a change for which a
            //           commit never took place.
            //

            if (NetLogonChangeLogSerialNumber.QuadPart ==
                    SampDefinedDomains[i].CurrentFixed.ModifiedCount.QuadPart)
            {
                SampDiagPrint(INFORM,("Number Queried From Log Same as Modified Count on Domain %d\n",i));
                SampDefinedDomains[i].NetLogonChangeLogSerialNumber.QuadPart = NetLogonChangeLogSerialNumber.QuadPart;
            }
            else if (NetLogonChangeLogSerialNumber.QuadPart >
                    SampDefinedDomains[i].CurrentFixed.ModifiedCount.QuadPart)
            {
                SampDiagPrint(INFORM,("Number Queried From Log Greater Than Modified Count on Domain %d\n",i));

                //
                // Set the serial number to the one queried from the change log.
                //

                SampDefinedDomains[i].NetLogonChangeLogSerialNumber.QuadPart =
                                            NetLogonChangeLogSerialNumber.QuadPart;
                SampDefinedDomains[i].CurrentFixed.ModifiedCount.QuadPart = NetLogonChangeLogSerialNumber.QuadPart;

                ASSERT(( RtlCompareMemory(
                                &SampDefinedDomains[i].CurrentFixed,
                                &SampDefinedDomains[i].UnmodifiedFixed,
                                sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN) ) !=
                                sizeof( SAMP_V1_0A_FIXED_LENGTH_DOMAIN) ));

                FlushRequired = TRUE;
            }
            else
            {
                SampDiagPrint(INFORM,("Number Queried From Log Less Than Modified Count on Domain %d\n",i));
                if (SampDefinedDomains[i].IsBuiltinDomain)
                {
                    SampDefinedDomains[i].NetLogonChangeLogSerialNumber.QuadPart =
                            SampDefinedDomains[i].CurrentFixed.ModifiedCount.QuadPart;
                }
                else
                {
                    //
                    // Force a Full Sync. Set Serial Number to 1 and restamp the creation time.
                    //

                    SampDefinedDomains[i].NetLogonChangeLogSerialNumber.QuadPart = 1;
                    SampDefinedDomains[i].CurrentFixed.ModifiedCount.QuadPart = 1;
                    NtQuerySystemTime(
                        &(SampDefinedDomains[i].CurrentFixed.CreationTime));

                    FlushRequired = TRUE;
                }

            }

            NtStatus = SampReleaseWriteLock(FlushRequired);

            if (!NT_SUCCESS(NtStatus))
            {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: Commit Failed While Setting Serial Number, Error = %x\n",
                           NtStatus));

                return (NtStatus);
            }


        }
        else
        {

            //
            // Registry or BDC Case
            //

            SampDefinedDomains[i].NetLogonChangeLogSerialNumber =
                SampDefinedDomains[i].CurrentFixed.ModifiedCount;
            NtStatus = STATUS_SUCCESS;
        }

    }

    return (NtStatus);
}

NTSTATUS
SampCacheComputerObject()
{
   NTSTATUS NtStatus = STATUS_SUCCESS;
   DSNAME   *TempDN=NULL;

   NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
   if (NT_SUCCESS(NtStatus))
   {
        NtStatus = SampFindComputerObject(NULL,&TempDN);
        if (NT_SUCCESS(NtStatus))
        {
             SampComputerObjectDsName = MIDL_user_allocate(TempDN->structLen);
             if (NULL!=SampComputerObjectDsName)
             {
                 RtlCopyMemory(SampComputerObjectDsName,TempDN,TempDN->structLen);
             }
        }
   }

   SampMaybeEndDsTransaction(TransactionCommit);

   return(NtStatus);
}

//
// SAM Configuration Keys that are either disabled or enabled
//
struct {
    
    LPSTR   ValueName;
    BOOLEAN *pfEnabled;

} SampConfigurationKeys[] = 
{
    {"IgnoreGCFailures",                    &SampIgnoreGCFailures},
    {"NoLmHash",                            &SampNoLmHash},
    {"SamNoGcLogonEnforceKerberosIpCheck",  &SampNoGcLogonEnforceKerberosIpCheck},
    {"SamNoGcLogonEnforceNTLMCheck",        &SampNoGcLogonEnforceNTLMCheck},
    {"SamReplicatePasswordsUrgently",       &SampReplicatePasswordsUrgently},
    {"ForceGuest",                          &SampForceGuest},
    {"LimitBlankPasswordUse",               &SampLimitBlankPasswordUse },
    {"SamAccountLockoutTestMode",           &SampAccountLockoutTestMode },
    {"SamDisableSingleObjectRepl",          &SampDisableSingleObjectRepl },
};

NTSTATUS
SampEventLogSafeModeBoot(
    PVOID p
    )
{
    SampWriteEventLog(
              EVENTLOG_INFORMATION_TYPE,
              0,
              SAMMSG_BOOT_TO_RESTORE_MODE,
              NULL,
              0,
              0,
              NULL,
              NULL
              );

    return(STATUS_SUCCESS);

}
NTSTATUS
SampReadRegistryParameters(
    PVOID p
    )
/*++

Routine Description:

   This routine reads in the configuration parameters for SAM.  This routine
   is called once during startup and then whenever the CONTROL\LSA
   registry key changes.

Arguments:

    p - Not used.

Return Values:

    STATUS_SUCCESS

--*/
{
    DWORD WinError;
    HKEY LsaKey;
    DWORD dwSize, dwValue, dwType;
    ULONG i;

    WinError = RegOpenKey(HKEY_LOCAL_MACHINE,
                          L"System\\CurrentControlSet\\Control\\Lsa",
                          &LsaKey );
    if (ERROR_SUCCESS != WinError) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Read the simple ones in first
    //
    for (i = 0; i < ARRAY_COUNT(SampConfigurationKeys); i++) {

        dwSize = sizeof(dwValue);
        WinError = RegQueryValueExA(LsaKey,
                                    SampConfigurationKeys[i].ValueName,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwValue,
                                    &dwSize);
    
        if ((ERROR_SUCCESS == WinError) && 
            (REG_DWORD == dwType) &&
            (1 == dwValue)) {
            *SampConfigurationKeys[i].pfEnabled = TRUE;
        } else {
            *SampConfigurationKeys[i].pfEnabled = FALSE;
        }
    }

    //
    // Hack!
    // 
    // To be removed once setup guys fix GUI mode to set, not change,
    // the admin password.
    //
    {
        BOOLEAN fUpgrade;
        if (SampIsSetupInProgress( &fUpgrade )) {

            SampLimitBlankPasswordUse = FALSE;
        }
    }

    //
    // End of Hack!
    //

    //
    // Call out to the more complicated routines
    //

    //
    // NULL session access
    //
    SampCheckNullSessionAccess(LsaKey);

    //
    // Large SID Emulation modes
    //
    SampInitEmulationSettings(LsaKey);

    //
    // Logging levels
    //
    SampLogLevelChange(LsaKey);

    //
    // load restriction for OWF password change API
    // 
    SampInitOwfPasswordChangeRestriction(LsaKey);


    RegCloseKey(LsaKey);

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(p);
}


VOID
SampInitOwfPasswordChangeRestriction(
    IN HKEY LsaKey 
    )
/*++

Routine Description:

    This routine loads the value in the registry under 
    system\currentcontrolset\Control\Lsa\SamRestrictOwfPassworChange

    the default value for .NET Server is 1.

Arguments:

    LsaKey -- an open key to Control\LSA
    
Return Value:

    None - this routines sets the SampRestictOwfPasswordChange global.

--*/
{
    DWORD WinError;
    DWORD dwSize, dwValue = 1, dwType;

    dwSize = sizeof(dwValue);
    WinError = RegQueryValueExA(LsaKey,
                                "SamRestrictOwfPasswordChange",
                                NULL,
                                &dwType,
                                (LPBYTE)&dwValue,
                                &dwSize);
    
    if ((ERROR_SUCCESS == WinError) && 
        (REG_DWORD == dwType))
    {
        if ( dwValue <= 2 )
        {
            // value is in our expected range
            SampRestrictOwfPasswordChange = dwValue;
        }
        else
        {
            // value of this regkey is out of range. 
            // set to default value
            SampRestrictOwfPasswordChange = 1;
        }
    }
    else
    {
        // error in querying this regkey
        // set to default value
        SampRestrictOwfPasswordChange = 1;
    }

}



BOOLEAN
SampIsAuditingEnabled(
    IN ULONG DomainIndex,
    IN NTSTATUS Status
    )
/*++

Routine Description:

   This routine exports SAM auditing configuration for consumption by ntdsa.dll.

Arguments:

    DomainIndex - Domain index to check auditing state for.
    
    Status - The status code for the potentially auditable operation.
    
Return Values:

    TRUE - Auditing is enabled for DomainIndex and Status
    
    FALSE - Auditing is not enabled for DomainIndex and Status

--*/
{
    return SampDoSuccessOrFailureAccountAuditing(DomainIndex, Status);   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\samtrace.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    SAMTRACE.C
    
Abstract:

    Implement SAM Server event tracing by using WMI trace infrastructure. 
    
Author:

    01-Dec-1998     ShaoYin
    
Revision History:


--*/

//
//
//  Include header files
//
// 

#include <samsrvp.h>
#include <wmistr.h>                 // WMI
#define INITGUID
#include <sdconvrt.h>
#include <sddl.h>
#include <samtrace.h>




#define RESOURCE_NAME __TEXT("MofResource")
#define IMAGE_PATH    __TEXT("samsrv.dll")
#define LSA_KEY_STRING  __TEXT("System\\CurrentControlSet\\Control\\Lsa")
#define TRACE_SAM_EVENT_IN_DETAIL_VALUE_STRING    __TEXT("TraceSamEventInDetail")

#define SAM_EVENT_TRACE_VERSION     0x00000001 
#define SAM_EVENT_TRACE_SIGNATURE   __TEXT("SAM")

unsigned long   SampEventTraceFlag = FALSE;
TRACEHANDLE     SampTraceRegistrationHandle = (TRACEHANDLE) 0;
TRACEHANDLE     SampTraceLoggerHandle = (TRACEHANDLE) 0;
BOOLEAN         SampTraceLogEventInDetail = FALSE;



//
// Forward declaration
// 

ULONG
SampTraceControlCallBack(
    IN WMIDPREQUESTCODE RequestCode, 
    IN PVOID RequestContext, 
    IN OUT ULONG *InOutBufferSize, 
    IN OUT PVOID Buffer
    );
    
//
// The following table contains the address of event trace GUID.
// We should always update SAMPTRACE_GUID (enum type defined in samtrace.h)
// whenever we add new event trace GUID for SAM
// 
    
TRACE_GUID_REGISTRATION SampTraceGuids[] =
{
    {&SampConnectGuid,                          NULL},
    {&SampCloseHandleGuid,                      NULL},
    {&SampSetSecurityObjectGuid,                NULL},
    {&SampQuerySecurityObjectGuid,              NULL},
    {&SampShutdownSamServerGuid,                NULL},
    {&SampLookupDomainInSamServerGuid,          NULL},
    {&SampEnumerateDomainsInSamServerGuid,      NULL},
    {&SampOpenDomainGuid,                       NULL},
    {&SampQueryInformationDomainGuid,           NULL},
    {&SampSetInformationDomainGuid,             NULL},
    {&SampCreateGroupInDomainGuid,              NULL},
    {&SampEnumerateGroupsInDomainGuid,          NULL},
    {&SampCreateUserInDomainGuid,               NULL},
    {&SampCreateComputerInDomainGuid,           NULL},
    {&SampEnumerateUsersInDomainGuid,           NULL},
    {&SampCreateAliasInDomainGuid,              NULL},
    {&SampEnumerateAliasesInDomainGuid,         NULL},
    {&SampGetAliasMembershipGuid,               NULL},
    {&SampLookupNamesInDomainGuid,              NULL},
    {&SampLookupIdsInDomainGuid,                NULL},
    {&SampOpenGroupGuid,                        NULL},
    {&SampQueryInformationGroupGuid,            NULL},
    {&SampSetInformationGroupGuid,              NULL},
    {&SampAddMemberToGroupGuid,                 NULL},
    {&SampDeleteGroupGuid,                      NULL},
    {&SampRemoveMemberFromGroupGuid,            NULL},
    {&SampGetMembersInGroupGuid,                NULL},
    {&SampSetMemberAttributesOfGroupGuid,       NULL},
    {&SampOpenAliasGuid,                        NULL},
    {&SampQueryInformationAliasGuid,            NULL},
    {&SampSetInformationAliasGuid,              NULL},
    {&SampDeleteAliasGuid,                      NULL},
    {&SampAddMemberToAliasGuid,                 NULL},
    {&SampRemoveMemberFromAliasGuid,            NULL},
    {&SampGetMembersInAliasGuid,                NULL},
    {&SampOpenUserGuid,                         NULL},
    {&SampDeleteUserGuid,                       NULL},
    {&SampQueryInformationUserGuid,             NULL},
    {&SampSetInformationUserGuid,               NULL},
    {&SampChangePasswordUserGuid,               NULL},
    {&SampChangePasswordComputerGuid,           NULL},
    {&SampSetPasswordUserGuid,                  NULL},
    {&SampSetPasswordComputerGuid,              NULL},
    {&SampPasswordPushPdcGuid,                  NULL},
    {&SampGetGroupsForUserGuid,                 NULL},
    {&SampQueryDisplayInformationGuid,          NULL},
    {&SampGetDisplayEnumerationIndexGuid,       NULL},
    {&SampGetUserDomainPasswordInformationGuid, NULL},
    {&SampRemoveMemberFromForeignDomainGuid,    NULL},
    {&SampGetDomainPasswordInformationGuid,     NULL},
    {&SampSetBootKeyInformationGuid,            NULL},
    {&SampGetBootKeyInformationGuid,            NULL},

};


#define SampGuidCount (sizeof(SampTraceGuids) / sizeof(TRACE_GUID_REGISTRATION))

    

ULONG
_stdcall
SampInitializeTrace(
    PVOID Param
    )
/*++    
Routine Description:

    Register WMI Trace Guids. The caller should only call this 
    api in DS mode.
    
Parameters:

    None.
    
Reture Values:
    
    None. 
    
--*/
{
    ULONG   Status = ERROR_SUCCESS;
    HMODULE hModule;
    TCHAR FileName[MAX_PATH+1];
    DWORD nLen = 0;

    hModule = GetModuleHandle(IMAGE_PATH);
    if (hModule != NULL) {
        nLen = GetModuleFileName(hModule, FileName, MAX_PATH);
    }
    if (nLen == 0) {
        lstrcpy(FileName, IMAGE_PATH);
    }
    
    //
    // Register Trace GUIDs
    // 
    
    Status = RegisterTraceGuids(
                    SampTraceControlCallBack, 
                    NULL, 
                    &SampControlGuid, 
                    SampGuidCount, 
                    SampTraceGuids, 
                    FileName, 
                    RESOURCE_NAME, 
                    &SampTraceRegistrationHandle);
                    
#if DBG
    if (Status != ERROR_SUCCESS)
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampInitializeTrace Failed ==> %d\n",
                   Status));

    }
    else
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampInitializeTrace SUCCEED ==> %d\n",
                   Status));
    }
#endif // DBG
    
    return Status;
}


BOOLEAN
SampCheckLogEventInDetailFlag(
    TRACEHANDLE TraceLoggerHandle
    )
/*++

Routine Description:

    This routine checks whether data logging is enabled or not. 
    if detail event trace is enabled, then log event in detail.
    Otherwise, just log the event without detail info.

Parameters:

    None

Return Value:

    TRUE - data logging is enabled
    
    FALSE - data logging is disabled

--*/
{
    ULONG           WinError = ERROR_SUCCESS;
    HKEY            LsaKey;
    DWORD           dwType = REG_DWORD, dwSize = sizeof(DWORD), dwValue = 0;
    BOOLEAN         ReturnResult = FALSE;
    ULONG           EnableLevel = 1;


    WinError = RegOpenKey(HKEY_LOCAL_MACHINE,
                          LSA_KEY_STRING,
                          &LsaKey
                          );

    if (ERROR_SUCCESS == WinError)
    {
        WinError = RegQueryValueEx(LsaKey,
                                   TRACE_SAM_EVENT_IN_DETAIL_VALUE_STRING,
                                   NULL,
                                   &dwType,
                                   (LPBYTE)&dwValue,
                                   &dwSize
                                   );

        if ((ERROR_SUCCESS == WinError) && 
            (REG_DWORD == dwType) &&
            (1 == dwValue))
        {
            ReturnResult = TRUE;
        }

        RegCloseKey(LsaKey);
    }


    if (!ReturnResult)
    {
        //
        // Reg key is not set ... just get the level
        // from the trace logger handle
        //

        EnableLevel = GetTraceEnableLevel(TraceLoggerHandle);
        if ( EnableLevel > 1)
        {
            ReturnResult = TRUE;
        }
    }



    return(ReturnResult);
}


ULONG
SampTraceControlCallBack(
    IN WMIDPREQUESTCODE RequestCode, 
    IN PVOID RequestContext, 
    IN OUT ULONG *InOutBufferSize, 
    IN OUT PVOID Buffer
    )
/*++

Routine Description:

Parameters:

Return Values:

--*/
{

    PWNODE_HEADER   Wnode = (PWNODE_HEADER) Buffer;
    TRACEHANDLE     LocalTraceHandle;
    ULONG   Status = ERROR_SUCCESS;
    ULONG   RetSize;
    ULONG   EnableLevel;
    
    switch (RequestCode) 
    {
        case WMI_ENABLE_EVENTS:
        {
            SampTraceLoggerHandle = LocalTraceHandle = GetTraceLoggerHandle(Buffer);
            SampEventTraceFlag = 1;     // enable flag
            SampTraceLogEventInDetail = SampCheckLogEventInDetailFlag(LocalTraceHandle);
            RetSize = 0;  
            break; 
        }
    
        case WMI_DISABLE_EVENTS:
        {
            SampTraceLoggerHandle = (TRACEHANDLE) 0;
            SampEventTraceFlag = 0;     // disable flag
            SampTraceLogEventInDetail= FALSE;   // disable detail data logging
            RetSize = 0;
            break;
        }
        default:
        {
            RetSize = 0;
            Status = ERROR_INVALID_PARAMETER;
            break;
        }
    } 
    
    *InOutBufferSize = RetSize;
    return Status;
} 


    
VOID
SampTraceEvent(
    IN ULONG WmiEventType, 
    IN ULONG TraceGuid 
    )
/*++

Routine Description:

    This routine will do a WMI event trace. 
    
    In Registry Mode, it is NO-OP.
    
    Only has effect in DS mode.

Parameters:

    WmiEventType - Event Type, valid values are:
                   EVENT_TRACE_TYPE_START
                   EVENT_TRACE_TYPE_END
                   
    TraceGuid - Index in SampTraceGuids[]                   

Return Values:

    None.

--*/

{
    ULONG       WinError = ERROR_SUCCESS;
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    RPC_STATUS  RpcStatus = RPC_S_OK;
    RPC_BINDING_HANDLE  ServerBinding;
    PTOKEN_OWNER    Owner = NULL;
    PTOKEN_PRIMARY_GROUP    PrimaryGroup = NULL;
    PWSTR       StringSid = NULL;       
    PWSTR       StringBinding = NULL;
    PWSTR       NetworkAddr = NULL;
    PWSTR       StringNotAvailable = L"Not Available";
    ULONG       Version = SAM_EVENT_TRACE_VERSION;
    SAMP_EVENT_TRACE_INFO   Event;

    
    
    //
    // Theoretically, only test SampEventTraceFlag would be enough, since
    // SampEventTraceFlag will remain FALSE in Registry Mode, because 
    // SampInitializeTrace() will never been called in Registry Mode.
    // Thus nobody will change the value of SampEventTraceFlag 
    // 
    if (!SampEventTraceFlag)
    {
        return;
    }

    //
    // Assert we do a WMI trace only in DS mode.
    // 
    ASSERT(SampUseDsData);


    // 
    // Fill the event information. 
    // 
    memset(&Event, 0, sizeof(SAMP_EVENT_TRACE_INFO));
      
    //
    // TraceGuid should be a valid one
    //
    ASSERT(TraceGuid <= SampGuidCount);
    Event.EventTrace.GuidPtr = (ULONGLONG) SampTraceGuids[TraceGuid].Guid; 
      
    Event.EventTrace.Class.Type = (UCHAR) WmiEventType;
    Event.EventTrace.Class.Version =  SAM_EVENT_TRACE_VERSION;   
    Event.EventTrace.Flags |= (WNODE_FLAG_USE_GUID_PTR |  // GUID is actually a pointer 
                               WNODE_FLAG_USE_MOF_PTR  |  // Data is not contiguous to header
                               WNODE_FLAG_TRACED_GUID);   // denotes a trace 
                             
    Event.EventTrace.Size = sizeof(EVENT_TRACE_HEADER);   // no other parameters/information

    //
    // log detailed info if required
    // 

    if (SampTraceLogEventInDetail && 
        (EVENT_TRACE_TYPE_START == WmiEventType)
        )
    {

        //
        // Get Client SID
        // 
        NtStatus = SampGetCurrentOwnerAndPrimaryGroup(
                            &Owner,
                            &PrimaryGroup
                            );

        if (!NT_SUCCESS(NtStatus))
        {
            StringSid = StringNotAvailable;
        }
        else 
        {
            if (0 == ConvertSidToStringSidW(Owner->Owner, &StringSid))
            {
                StringSid = StringNotAvailable;
            }
        }

        //
        // Get Clinet Network Address 
        // 

        RpcStatus = RpcBindingServerFromClient(NULL, &ServerBinding); 

        if (RPC_S_OK == RpcStatus)
        {
            RpcStatus = RpcBindingToStringBindingW(ServerBinding, &StringBinding);
            
            if (RPC_S_OK == RpcStatus)
            {
                RpcStatus = RpcStringBindingParseW(StringBinding, 
                                               NULL,
                                               NULL,
                                               &NetworkAddr,
                                               NULL,
                                               NULL
                                               );
            }

            RpcBindingFree( &ServerBinding );

        }

        if (RPC_S_OK != RpcStatus)
        {
            NetworkAddr = StringNotAvailable;
        }

        //
        // O.K. Now we have both Client SID and NetworkAddr, 
        // prepare the event info
        // 

        Event.EventInfo[0].Length = (wcslen(SAM_EVENT_TRACE_SIGNATURE) + 1) * sizeof(WCHAR);
        Event.EventInfo[0].DataPtr = (ULONGLONG) SAM_EVENT_TRACE_SIGNATURE;

        Event.EventInfo[1].Length = sizeof(ULONG);
        Event.EventInfo[1].DataPtr = (ULONGLONG) &Version;

        Event.EventInfo[2].Length = (wcslen(StringSid) + 1) * sizeof(WCHAR);
        Event.EventInfo[2].DataPtr = (ULONGLONG) StringSid;

        Event.EventInfo[3].Length = (wcslen(NetworkAddr) + 1) * sizeof(WCHAR);
        Event.EventInfo[3].DataPtr = (ULONGLONG) NetworkAddr;

        Event.EventTrace.Size += sizeof(Event.EventInfo);
       
    }

    //
    // Log the Event
    // 
    WinError = TraceEvent(SampTraceLoggerHandle, 
                          (PEVENT_TRACE_HEADER)&Event
                          ); 

    if (WinError != ERROR_SUCCESS)
    {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampTraceEvent Error: 0x%x\n",
                       WinError));
    }


    //
    // Cleanup
    //

    if (Owner)
        MIDL_user_free(Owner);

    if (PrimaryGroup)
        MIDL_user_free(PrimaryGroup);

    if (StringSid && (StringNotAvailable != StringSid))
        LocalFree(StringSid);

    if (NetworkAddr && (StringNotAvailable != NetworkAddr))
        RpcStringFreeW(&NetworkAddr);

    if (StringBinding)
        RpcStringFreeW(&StringBinding);


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\ridmgr.c ===
/*++

Copyright (c) 1990 - 1997  Microsoft Corporation

Module Name:

    ridmgr.c

Abstract:

    This file contains services for the multi-master Relative Identifier (RID)
    allocator, a.k.a. the distributed RID Manager in NT5.

    The RID Manager allows accounts to be created on any domain controller
    (DC) in the domain, rather than just at the PDC as in previous versions
    of NT. After an account has been successfully created, its data is rep-
    licated to other DC's in the domain.

    The distributed RID Manager model is as follows. When a DC is joined to
    a domain, it updates several objects in the DS for RID management. An
    initial pool of RID's is requested from the RID Manager. This request
    is made via the Floating Single Master Operation (FSMO), which allows
    one and only one DC at a time to change the size of the available RID
    pool. The FSMO operation is assumed to be asynchronous, so will return
    before the RID pool has actually been allocated in most cases.

    Subsequently, the requesting DC reads its allocated-RID attribute, from
    which it can determine that it has a valid RID pool. Once the RID pool
    has been allocated, the DC can begin assigning RID's to new accounts.

    When a pool is nearing exhaustion, i.e. a threshold is reached, the DC
    makes a request for another RID pool.

    The FSMO is set up to handle both inter- and intra-site requests for
    new RID pools, provided that the sites are RPC'able from one another.

    The DC/DSA that is the current FSMO owner is named by a distinguished
    name (DN), which is stored in the RoleOwner property of the RID Manager
    object itself. On exactly one DC, the RoleOwner will be the same name
    as that DC's (DSA) DN. Other replicas of the RoleOwner attribute will
    also contain this information via replicated data.

    It is possible that the name will differ on other DCs in the event that
    some other DC has requested ownership. That is, suppose that there are 3
    DC's in a domain and DC1 is the current RoleOwner, and hence, is the RID
    Manager.

    Next, DC2 requests ownership from DC1. Simultaneously, DC3 requests a
    new RID pool from the RID Manager (named in the RoleOwner). Because of
    replication latency, DC3 is unaware that DC2 is now the RoleOwner, and
    not DC1. Upon reaching DC1, inspecting the RoleOwner attribute, DC3's
    FSMO operation will discover that DC2 is the current RID Manager, and
    hence will return this information to DC3 so that it can retry the op-
    eration.

    =======================================================================

    RID management is defined by three objects and their attributes:

    (1) Sam-Domain Object (an auxillary class of the domain class)

        RID Manager Reference DN attribute

    (2) RID-Manager Object (lives in the System container)

        Role Owner attribute (the DN of the DC/DSA machine)
        RID Pool Available attribute

    (3) RID-Set Object (lives under the Computer object)

        RID Pool Allocated attribute
        RID Pool Previously Allocated attribute
        RID Pool Used attribute
        RID Next Rid attribute

    The DN of the RID Manager is stored in an attribute on the domain object
    for easy access. From this information, the location of the RID Manager
    object is known via a single read operation.

    The FSMO Role Owner is an attribute stored on the RID Manager object. So,
    reading the domain object to get the RID Manager DN, allows a second read
    to access the FSMO DN.

    The total pool of available RIDs, at any time, is stored in the RID
    Pool Availalble attribute of the RID Manager.

    The RID-Set object, one per DC/DSA machine in the domain, contains
    the RID data specific to that DC/DSA, such as the next RID.


    Locking Model - Theory of Operation
    -----------------------------------

    There are three mechanisms used for achieving serialization:

    1) The SAM Lock:  (an nt resource) used to serialize access to global data
                      for all SAM calls

    Specifically for the rid manager, the SAM lock is used to serialize writes
    to the rid set object to avoid jet write conflicts (since a regular SAM
    CreateUser could cause a write [using a rid] and the rid request
    thread could try to be updating the rid set with more rids)

    The SAM lock is acquired in two places:

        i) when the local DC is the rid manager, the lock is acquired before
           starting the transaction that will eventually write to the rid
           set object.  See ridmgr.c::SamIFloatingSingleMasterOpEx().
       ii) when local DC is NOT the rid manager, the lock is acquired just
           after the RPC call to acquire the rids has returned but just before
           the transaction is started to apply the results of the RPC call (ie
           write to the rid set object). See dsamain\dra\drancrep.c::ReqFsmoOpAux()

    N.B.  The SAM lock must be grabbed before starting a DS transaction.

    2) RidMgrCriticalSection: (critical section) used to serialize rid requests
       (used only in the server portion of rid management).

       Specifically, it guards writes to the domain-wide rid manager object that
       keeps the global rid pool.  Hence it is only used in one place:
       ridmgr.c::SamIFloatingSingleMasterOpEx().

    N.B.  The RidMgrCriticalSection must be grabbed before starting a DS transaction.

    3) SampDcRidRequestPending: (boolean) used to prevent multiple requests for
       rids  (used only in the client portion of rid management)

       SampDcRidRequestPending is typically set to TRUE in
       SampRequestRidPoolAsynchronously, which then creates a thread that executes
       SampRequestRidPool.

       SampRequestRidPool sets SampDcRidRequestPending to FALSE when it is
       finished, whether in success or failure.

       As a special case, SampDomainRidInitialization sets SampDcRidRequestPending
       to TRUE as it directly calls SampRequestRidPool.

    N.B.  To prevent race conditions, SampDcRidRequestPending must be set to TRUE
    only when the SAM lock is held, which it is when SampGetNextRid (which
    calls SampRequestRidPoolAsynchronously) is called.

Author:

    Chris Mayhall (ChrisMay) 11-Jul-1996

Environment:

    User Mode - Win32

Revision History:

    11-Jul-1996 ChrisMay
        Created initial file.
    25-Jul-1996 ChrisMay
        Added domain initialization and corresponding changes in ntds.exe.
    23-Aug-1996 ChrisMay
        Made domain initialization work for multiple hosted domains and for
        domain information stored in the DS.
    08-Oct-1996 ChrisMay
        Miscellaneous cleanup.
    09-Dec-1996 ChrisMay
        Remove dead/obsolete code, further clean up needed to support mult-
        iple hosted domains.
    31-Jan-1997 ChrisMay
        Miscellaneous bug fixes and more scaffold routines.
    18-Feb-1997 ChrisMay
        Added code to resume with the NextRid of the NT4 Account domain after
        upgrading the NT4 DC to an NT5 DC.
    05-Mar-1997 ChrisMay
        Updated the RID Manager to use the new schema, maintaining routines
        that use the old schema for DC upgrades.
    14-Mar-1997 ChrisMay
        Change RID Manager creation so that it does not specify a temporary
        RoleOwner name, but instead, creates the object with the RoleOwner
        name.
    21-Apr-1997 ChrisMay
        Create the RID Manager object with the SD specified in the schema.
    09-May-1997 ChrisMay
        If-def'd away references to old RID schema--remove the code altogether
        after a successful testing for a few days.
    02-Jun-1997 ChrisMay
        Added an in-memory RID cache to reduce the number of RID updates to
        the NTDS-DSA object. Converted remaining SamKdPrint's to SampDiagPrint
        to reduce debug output. Added a check to SampAllowAccountCreation
        that verifies the DC is not being restored from backup and that it
        has an initial RID pool (before attempting to assign a RID). Added
        routines to read/write the RID cache HWM to the registry for crash
        recovery. Re-enabled dynamic RID pool requests based on a RID thresh-
        old. Added registry keys for testing hooks (so that testers can set
        RID ranges appropriately).
    15-Oct-1997 ChrisMay
        Added routine to read the RID Manager during startup, then create the
        object only if it does not exist, rather then attempt creation each
        boot.
    22-Oct-1997 ChrisMay
        Added code to convert from old schema to new schema, such that the
        RID Manager object now lives in the System container, while the RID
        attributes now live on the RID-Set object, in under a give Computer
        object. New schema.
    28-Oct-1997 ChrisMay
        Replaced calls to GetConfigParam with GetConfigurationName, replaced
        SampInitializeDsName with AppendRDN for better consistency. Cleaned
        up name-buffer allocation.

--*/


// Manifest Constants (used in this file)

#define MAX_RID_OBJ_UPDATE  10
#define MAX_FSMO_RETRY      100000
#define MAX_EVENT_STRINGS   8

#define RID_SET             "RID Set"
#define RID_SET_W           L"RID Set"
#define RID_SET_W_CN        L"CN=RID Set"

#define RID_MGR             "RID Manager$"
#define RID_MGR_W           L"RID Manager$"
#define RID_MGR_W_CN        L"CN=RID Manager$"

#define SYSTEM_W            L"System"
#define SYSTEM_CN           "CN=System"
#define SYSTEM_W_CN         L"CN=System"

#define COMPUTERS_W         L"Computers"
#define COMPUTERS_CN        "CN=Computers"
#define COMPUTERS_W_CN      L"CN=Computers"

#define DOMAIN_RIDS_W       L"Domain RIDs"
#define DOMAIN_RIDS_CN      "CN=Domain RIDs"

#define SAMP_RID_FAILURE_NOTIFY_FREQ 100
#define SAMP_TIME_TO_LOG_RID_FAILURE(x)  \
                                 ( ((x) % SAMP_RID_FAILURE_NOTIFY_FREQ) == 0 )


// Includes

#include <samsrvp.h>
#include "ntlsa.h"
#include "lmcons.h"         // LM20_PWLEN
#include "msaudite.h"
#include <ntlsa.h>
#include <nlrepl.h>         // I_NetNotifyMachineAccount prototype
#include <dslayer.h>
#include <dsutilp.h>
#include <dsdomain.h>
#include <objids.h>
#include <dsconfig.h>       // GetConfigurationName
#include <stdlib.h>
#include <ridmgr.h>
#include <sdconvrt.h>       // SampGetDefaultSecurityDescriptorForClass
#include <ntdsa.h>          // Floating Single Master Operations (FSMO)
#include <malloc.h>
#include <filtypes.h>


//============================================================================
//
//                           RID Manager Global Data
//
//============================================================================

// Global variables are maintained for certain RID values, such as the domain
// minimum and maximum RIDs, and not just manifest constants. This is done so
// that these values can be set from the debugger (or test application) in
// order to test boundary conditions without having to create 16 million ac-
// counts. Note that these variables should always be referenced in the code
// and not the constants explicitly.

ULONG  SampMinimumDomainRid;
ULONG  SampMaximumDomainRid;
DOUBLE SampRidThreshold;
ULONG  SampRidBlockSize;

//
// This critical section guards writes to the rid manager object to avoid
// write conflicts.
//
CRITICAL_SECTION RidMgrCriticalSection;
PCRITICAL_SECTION RidMgrCritSect;

//
// This boolean guards against the local rid manager code making multiple
// rid requests at once.  There is exactly 1 or 0 rid requests at any time
//
BOOLEAN SampDcRidRequestPending = FALSE;

//
// The DS object representing the RID manager is cached in here
//

DSNAME CachedRidManagerObject;


//
// The DS object representing the RID set object is returned in here
//

DSNAME CachedRidSetObject;


//============================================================================
//
//                           RID Manager Forward Decls
//
//============================================================================

NTSTATUS
SampFindRidManager(
    OUT PDSNAME *RidManager
    );

NTSTATUS
SampRequestRidPool(
    IN PDSNAME RidManager,
    IN BOOLEAN VerboseLogging
    );

NTSTATUS
SampRequestRidPoolAsynchronously(
    IN DSNAME * RidManager
    );

DWORD
SampSetupRidRegistryKey(
    IN HKEY KeyHandle,
    IN PCHAR ValueName,
    IN OUT PULONG Rid
    );

NTSTATUS
SampFindComputerObject(
    IN  PDSNAME DsaObject,
    OUT PDSNAME *ComputerObject
    );

NTSTATUS
SampFindRidObjectEx(
    IN  PDSNAME ComputerObject,
    OUT PDSNAME *RidObject
    );

SampObtainRidInfo(
    IN  PDSNAME  DsaObject, OPTIONAL
    OUT PDSNAME  *RidObject,
    OUT PRIDINFO RidInfo
    );

NTSTATUS
SampInitNextRid(
    PDSNAME  RidObject,
    PRIDINFO RidInfo
    );

NTSTATUS
SampSetupRidPoolNotification(
    PDSNAME RidManagerObject
    );


//============================================================================
//
//                         RID Manager Helper Routines
//
//============================================================================

VOID
SampSetRidManagerReference(PRIDINFO RidInfo, PDSNAME RidObject)
{
    RidInfo->RidManagerReference = RidObject;
}

VOID
SampGetRidManagerReference(PRIDINFO RidInfo, PDSNAME *RidObject)
{
    *RidObject = RidInfo->RidManagerReference;
}

VOID
SampSetRoleOwner(PRIDINFO RidInfo, PDSNAME RidObject)
{
    RidInfo->RoleOwner = RidObject;
}

VOID
SampGetRoleOwner(PRIDINFO RidInfo, PDSNAME *RidObject)
{
    *RidObject = RidInfo->RoleOwner;
}

VOID
SampSetRidPoolAvailable(PRIDINFO RidInfo, ULONG high, ULONG low)
{
    RidInfo->RidPoolAvailable.HighPart = (high);
    RidInfo->RidPoolAvailable.LowPart = (low);
}

VOID
SampGetRidPoolAvailable(PRIDINFO RidInfo, PULONG high, PULONG low)
{
    *(high) = RidInfo->RidPoolAvailable.HighPart;
    *(low) = RidInfo->RidPoolAvailable.LowPart;
}

VOID
SampSetDcCount(PRIDINFO RidInfo, ULONG Count)
{
    RidInfo->RidDcCount = (Count);
}

VOID
SampGetDcCount(PRIDINFO RidInfo, PULONG Count)
{
    *(Count) = RidInfo->RidDcCount;
}

VOID
SampSetRidPoolAllocated(PRIDINFO RidInfo, ULONG high, ULONG low)
{
    RidInfo->RidPoolAllocated.HighPart = (high);
    RidInfo->RidPoolAllocated.LowPart = (low);
}

VOID
SampGetRidPoolAllocated(PRIDINFO RidInfo, PULONG high, PULONG low)
{
    *(high) = RidInfo->RidPoolAllocated.HighPart;
    *(low) = RidInfo->RidPoolAllocated.LowPart;
}

VOID
SampSetRidPoolPrevAlloc(PRIDINFO RidInfo, ULONG high, ULONG low)
{
    RidInfo->RidPoolPrevAlloc.HighPart = (high);
    RidInfo->RidPoolPrevAlloc.LowPart = (low);
}

VOID
SampGetRidPoolPrevAlloc(PRIDINFO RidInfo, PULONG high, PULONG low)
{
    *(high) = RidInfo->RidPoolPrevAlloc.HighPart;
    *(low) = RidInfo->RidPoolPrevAlloc.LowPart;
}

VOID
SampSetRidPoolUsed(PRIDINFO RidInfo, ULONG high, ULONG low)
{
    RidInfo->RidPoolUsed.HighPart = (high);
    RidInfo->RidPoolUsed.LowPart = (low);
}

VOID
SampGetRidPoolUsed(PRIDINFO RidInfo, PULONG high, PULONG low)
{
    *(high) = RidInfo->RidPoolUsed.HighPart;
    *(low) = RidInfo->RidPoolUsed.LowPart;
}

VOID
SampSetRid(PRIDINFO RidInfo, ULONG NextRid)
{
    RidInfo->NextRid = (NextRid);
}

VOID
SampGetRid(PRIDINFO RidInfo, PULONG NextRid)
{
    *(NextRid) = RidInfo->NextRid;
}

VOID
SampSetRidFlags(PRIDINFO RidInfo, RIDFLAG Flags)
{
    RidInfo->Flags = (Flags);
}

VOID
SampGetRidFlags(PRIDINFO RidInfo, PRIDFLAG Flags)
{
    *(Flags) = RidInfo->Flags;
}

BOOLEAN
CheckOpResult(OPRES *OpResult)
{
    if (NULL != OpResult)
    {
        // There is a valid operation-result structure, so check it for the
        // extended error.

        if (EXOP_ERR_SUCCESS == OpResult->ulExtendedRet)
        {
            return(TRUE);
        }
        else
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: FSMO extended error code = %lu\n",
                           OpResult->ulExtendedRet));

            return(FALSE);
        }
    }
    else
    {
        // A NULL OpResult means that DirOperationControl was unable to
        // allocate memory for the operation-result structure. In this
        // case, it is unlikely that the rest of the operation could have
        // worked.

        return(FALSE);
    }
}

VOID
SampWriteEventLogWithError(
    IN USHORT EventType,
    IN ULONG MessageId,
    IN ULONG WinError
    )
{
   

    DWORD           WinError2 = ERROR_SUCCESS;
    UNICODE_STRING  Error = {0, 0, NULL};
    PUNICODE_STRING StringPointers = &Error;
    ULONG           Length;

    Length = FormatMessage( (FORMAT_MESSAGE_FROM_SYSTEM |
                             FORMAT_MESSAGE_ALLOCATE_BUFFER),
                             NULL, // no source
                             WinError,
                             0, // let the system decide the language
                             (LPWSTR)&Error.Buffer,
                             0, // buffer is to be allocated
                             NULL // no inserts
                             );
    if ( Length > 0 ) {
        Error.MaximumLength = (USHORT) Length * sizeof(WCHAR);
        Error.Length = (USHORT) Length * sizeof(WCHAR);
    } else {
        WinError2 = GetLastError();
    }

    if ( ERROR_SUCCESS == WinError2 )
    {
        SampWriteEventLog( EventType,
                           0,    // no category
                           MessageId,
                           NULL, // no sid
                           1, // number of strings
                           0, // size of data
                           &StringPointers,
                           NULL
                            );

    }

    if ( Error.Buffer )
    {
        LocalFree( Error.Buffer );
    }
}

NTSTATUS
SampFindComputerObject(
    IN  PDSNAME DsaObject,
    OUT PDSNAME *ComputerObject
    )
/*++

Routine Description:

    This routine returns the computer object for the specified dsa object.

Parameters:

    DsaObject - Pointer, the dsname of a dsa

    ComputerObject - Pointer, allocated from the thread heap

Return Values:

    STATUS_SUCCESS - The DSA's computer object was found and accessed.

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    DirError = 0;

    READARG   ReadArg;
    READRES  *ReadResult;
    ENTINFSEL EISelection; // Entry Information Selection
    ATTRBLOCK ReadAttrBlock;
    COMMARG  *CommArg;
    ATTR      Attr;
    PDSNAME   ServerDsName = NULL;
    PDSNAME   BaseDsName = DsaObject;

    //
    // Some initial assumptions
    //
    ASSERT( SampExistsDsTransaction() );
    ASSERT( ComputerObject );

    // Initialize the outbound parameters.
    *ComputerObject = NULL;

    if ( NULL == BaseDsName )
    {
        ULONG NameSize = 0;

        NtStatus = GetConfigurationName(DSCONFIGNAME_DSA,
                                        &NameSize,
                                        NULL );

        if ( STATUS_BUFFER_TOO_SMALL == NtStatus )
        {
            SAMP_ALLOCA(BaseDsName,NameSize );
            if (NULL!=BaseDsName)
            {

                NtStatus = GetConfigurationName( 
                                DSCONFIGNAME_DSA,
                                &NameSize,
                                BaseDsName 
                                );
            }
            else
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if ( !NT_SUCCESS(NtStatus) )
        {
            return NtStatus;
        }

    }

    //
    // Depending on the build installed, the server reference attribute
    // maybe on the server object, ntdsa object, or not exist.  Handle
    // all three cases, doing the common case, the server object, first.
    //

    SAMP_ALLOCA(ServerDsName,BaseDsName->structLen );
    if (NULL==ServerDsName)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    TrimDSNameBy( BaseDsName, 1, ServerDsName );

    //
    // Read the rid set reference property
    //

    RtlZeroMemory(&Attr, sizeof(ATTR));
    RtlZeroMemory(&ReadArg, sizeof(READARG));
    RtlZeroMemory(&EISelection, sizeof(ENTINFSEL));
    RtlZeroMemory(&ReadAttrBlock, sizeof(ATTRBLOCK));

    Attr.attrTyp = ATT_SERVER_REFERENCE;

    ReadAttrBlock.attrCount = 1;
    ReadAttrBlock.pAttr = &Attr;

    EISelection.AttrTypBlock = ReadAttrBlock;
    EISelection.attSel = EN_ATTSET_LIST;
    EISelection.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EISelection;
    ReadArg.pObject = ServerDsName;

    CommArg = &(ReadArg.CommArg);
    BuildStdCommArg(CommArg);

    DirError = DirRead(&ReadArg, &ReadResult);

    if (NULL==ReadResult)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(DirError, &ReadResult->CommRes);
    }

    SampClearErrors();

    if ( STATUS_DS_NO_ATTRIBUTE_OR_VALUE == NtStatus )
    {
        //
        // Maybe the attribute is on the ntdsa  object
        //
        ReadArg.pObject = BaseDsName;
        THFree( ReadResult );
        ReadResult = 0;

        DirError = DirRead(&ReadArg, &ReadResult);

        if (NULL==ReadResult)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            NtStatus = SampMapDsErrorToNTStatus(DirError, &ReadResult->CommRes);
        }

        SampClearErrors();

    }

    if ( NT_SUCCESS(NtStatus) )
    {
        //
        // Extract the value
        //
        ATTRBLOCK AttrBlock;
        PDSNAME   pVal = NULL;
        ATTRVAL *AttrVal = NULL;
        ULONG ValCount = 0;
        ULONG ValLength = 0;
        ULONG Index = 0;

        ASSERT(NULL != ReadResult);

        AttrBlock = ReadResult->entry.AttrBlock;
        AttrVal = AttrBlock.pAttr[0].AttrVal.pAVal;
        ValCount = AttrBlock.pAttr[0].AttrVal.valCount;

        for (Index = 0; Index < ValCount; Index++)
        {
            pVal = (PDSNAME)(AttrVal[Index].pVal);
            ValLength = AttrVal[Index].valLen;
            ASSERT(1 == ValCount);
        }
        ASSERT(NULL != pVal);
        *ComputerObject = pVal;

    }
    else if ( (STATUS_DS_NO_ATTRIBUTE_OR_VALUE == NtStatus)
           && (NULL == DsaObject ) )
    {
        //
        // There is no server reference, do a full search if the
        // search is for the local computer
        //
        PDSNAME DomainDn = NULL;
        ULONG   Length = 0;
        WCHAR   ComputerName[MAX_COMPUTERNAME_LENGTH+2];


        ASSERT( FALSE && "Can't find computer object!" );

        // This code should eventually be removed

        //
        // Get the root domain
        //

        NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                        &Length,
                                        DomainDn);

        SAMP_ALLOCA(DomainDn ,Length );
        if (NULL==DomainDn)
        {
           return(STATUS_INSUFFICIENT_RESOURCES);
        }

        NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                        &Length,
                                        DomainDn);

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = STATUS_NO_TRUST_SAM_ACCOUNT;

            Length = sizeof( ComputerName );
            RtlZeroMemory(ComputerName, Length);
            Length /= sizeof(WCHAR);

            if (GetComputerName(ComputerName, &Length))
            {
                ATTR ComputerNameAttr;
                ATTRVAL ComputerNameAttrVal;
                PDSNAME  Object = NULL;

                ComputerNameAttr.AttrVal.pAVal = &ComputerNameAttrVal;

                ComputerNameAttr.attrTyp = ATT_SAM_ACCOUNT_NAME;
                ComputerNameAttr.AttrVal.valCount = 1;

                wcscat(ComputerName, L"$");
                Length++;

                ComputerNameAttr.AttrVal.pAVal->valLen = Length * sizeof(WCHAR);
                ComputerNameAttr.AttrVal.pAVal->pVal = (PUCHAR)ComputerName;

                NtStatus = SampDsDoUniqueSearch(0, DomainDn, &ComputerNameAttr, &Object);

                if ( NT_SUCCESS( NtStatus ) )
                {
                    Length = Object->structLen;
                    (*ComputerObject) = (PDSNAME) THAlloc( Length );
                    if ( (*ComputerObject) )
                    {
                        RtlCopyMemory( (*ComputerObject), Object, Length );
                        MIDL_user_free( Object );
                    }
                    else
                    {
                        NtStatus = STATUS_NO_MEMORY;
                    }
                }
            }

            if ( STATUS_OBJECT_NAME_NOT_FOUND == NtStatus )
            {
                NtStatus = STATUS_NO_TRUST_SAM_ACCOUNT;
            }
        }
    }


    ASSERT( SampExistsDsTransaction() );
    SampClearErrors();

    return( NtStatus );

}


NTSTATUS
SampFindRidObjectEx(
    IN  PDSNAME ComputerObject,
    OUT PDSNAME *RidObject
    )
/*++

Routine Description:

    This routine returns the rid object for the specified computer object,
    if it exists.

Parameters:

    ComputerObject - Pointer, the dsname of a dsa

    RidObject      - Pointer, allocated from the thread heap

Return Values:

    STATUS_SUCCESS - The DSA's computer object was found and accessed.

    STATUS_DS_NO_ATTRIBUTE_OR_VALUE - the object does not exist

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    DirError = 0;

    READARG   ReadArg;
    READRES  *ReadResult;
    ENTINFSEL EISelection; // Entry Information Selection
    ATTRBLOCK ReadAttrBlock;
    COMMARG  *CommArg;
    ATTR      Attr;

    //
    // Some initial assumptions
    //
    ASSERT( SampExistsDsTransaction() );
    ASSERT( ComputerObject );
    ASSERT( RidObject );

    // Initialize the outbound parameters.
    *RidObject = NULL;

    //
    // Read the rid set reference property
    //
    RtlZeroMemory(&Attr, sizeof(ATTR));
    RtlZeroMemory(&ReadArg, sizeof(READARG));
    RtlZeroMemory(&EISelection, sizeof(ENTINFSEL));
    RtlZeroMemory(&ReadAttrBlock, sizeof(ATTRBLOCK));

    Attr.attrTyp = ATT_RID_SET_REFERENCES;

    ReadAttrBlock.attrCount = 1;
    ReadAttrBlock.pAttr = &Attr;

    EISelection.AttrTypBlock = ReadAttrBlock;
    EISelection.attSel = EN_ATTSET_LIST;
    EISelection.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EISelection;
    ReadArg.pObject = ComputerObject;

    CommArg = &(ReadArg.CommArg);
    BuildStdCommArg(CommArg);

    DirError = DirRead(&ReadArg, &ReadResult);

    if (NULL==ReadResult)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(DirError, &ReadResult->CommRes);
    }

    if ( NT_SUCCESS(NtStatus) )
    {
        // Once the RID Set Reference object has been found and read, extract
        // the RID Set DN of interest (currently only one domain is handled)
        // and return that DN for subsequent usage.

        ATTRBLOCK AttrBlock;
        PDSNAME   pVal = NULL;
        ATTRVAL *AttrVal = NULL;
        ULONG ValCount = 0;
        ULONG ValLength = 0;
        ULONG Index = 0;

        ASSERT(NULL != ReadResult);

        AttrBlock = ReadResult->entry.AttrBlock;
        AttrVal = AttrBlock.pAttr[0].AttrVal.pAVal;
        ValCount = AttrBlock.pAttr[0].AttrVal.valCount;

        for (Index = 0; Index < ValCount; Index++)
        {
            pVal = (PDSNAME)(AttrVal[Index].pVal);
            ValLength = AttrVal[Index].valLen;
            ASSERT(1 == ValCount);
        }
        ASSERT(NULL != pVal);
        *RidObject = pVal;

    }

    ASSERT( SampExistsDsTransaction() );
    SampClearErrors();


    return( NtStatus );
}



SampObtainRidInfo(
    IN  PDSNAME  DsaObject, OPTIONAL
    OUT PDSNAME  *RidObject, OPTIONAL
    OUT PRIDINFO RidInfo
    )
/*++

Routine Description:

    This function returns the rid information for a given dsa.

Parameters:

    DsaObject - the dsa object

    RidObject - pointer to the dn of the ridobject

    RidInfo - the structure to be filled in

Return Values:

    STATUS_SUCCESS - The rid information was retrieved

    STATUS_OBJECT_NOT_FOUND - the rid object was not found

    STATUS_NO_SAM_TRUST_ACCOUNT - the computer object could be found

    STATUS_DS_NO_ATTRIBUTE_OR_VALUE - the reference does not exist


    Resource errors from the ds

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDSNAME  ComputerObject = NULL;
    PDSNAME  LocalRidObject = NULL;

    ASSERT( SampExistsDsTransaction() );

    if ( RidObject )
    {
        *RidObject = NULL;
    }

    if ((fNullUuid(&CachedRidSetObject.Guid)) || (NULL!=DsaObject))
    {
        //
        // We have not yet visited the RID set object. Try to find it
        //

        NtStatus = SampFindComputerObject( DsaObject, &ComputerObject );
        if ( NT_SUCCESS( NtStatus ) )
        {
            //
            // Ok, now try and find the rid object
            //
            NtStatus = SampFindRidObjectEx( ComputerObject, &LocalRidObject);
            THFree( ComputerObject );
        }
    }
    else
    {
        LocalRidObject = &CachedRidSetObject;
    }


    if ( NT_SUCCESS( NtStatus ) )
    {

        //
        // Ok, now try to read it
        //
        NtStatus = SampReadRidObjectInfo( LocalRidObject, RidInfo );

        if ( NT_SUCCESS( NtStatus ) )
        {
            if ( RidObject )
            {
                *RidObject = LocalRidObject;
            }

        }
    }


    ASSERT( SampExistsDsTransaction() );

    return NtStatus;
}


NTSTATUS
SampGetMachineDnName(
    OUT PWCHAR *MachineDnName,
    OUT PULONG NameLength
    )

/*++

Routine Description:

    This routine queries the system registry for the DN (distinguished name)
    of this DSA and passes it back. If not found, the output buffer is left
    unaltered.

Parameters:

    MachineDnName - Pointer, return buffer containing the DN of this DSA.

    NameLength - Pointer, returned length of the Machine DN name.

Return Values:

    STATUS_SUCCESS - The DSA's DN was found and accessed.

    Other status codes as per the registry API.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE RegistryKey = 0;
    HANDLE Handle = 0;
    ACCESS_MASK DesiredAccess = KEY_READ;
    KEY_VALUE_INFORMATION_CLASS KeyInformationClass = KeyValueFullInformation;
    PBYTE Buffer = NULL;
    ULONG Length = 0;
    ULONG ResultLength = 0;
    PKEY_VALUE_FULL_INFORMATION KeyInformation = NULL;

    SAMTRACE("SampGetMachineDnName");

    RtlZeroMemory(&KeyName, sizeof(UNICODE_STRING));
    RtlZeroMemory(&ValueName, sizeof(UNICODE_STRING));

    RtlInitUnicodeString(&KeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\NTDS\\Parameters");
    RtlInitUnicodeString(&ValueName, L"Machine DN Name");

    ASSERT((0 < KeyName.Length) && (0 < ValueName.Length));

    InitializeObjectAttributes(&ObjectAttributes,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE,
                               RegistryKey,
                               NULL);

    NtStatus = NtOpenKey(&Handle, DesiredAccess, &ObjectAttributes);

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = NtQueryValueKey(Handle, 
                                   &ValueName, 
                                   KeyInformationClass,
                                   NULL,
                                   0,
                                   &ResultLength
                                   );

        if (STATUS_BUFFER_TOO_SMALL == NtStatus)
        {
            Length = ResultLength;

            SAMP_ALLOCA(Buffer,Length ); 
            if (NULL!=Buffer)
            {

                RtlZeroMemory(Buffer, sizeof(Buffer));

                NtStatus = NtQueryValueKey(Handle,
                                       &ValueName,
                                       KeyInformationClass,
                                       (PVOID)Buffer,
                                       Length,
                                       &ResultLength);
            }
            else
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }

            if (NT_SUCCESS(NtStatus))
            {
                PBYTE KeyValue = NULL;
                ULONG KeyValueLength = 0;

                ASSERT(NULL != Buffer);

                KeyInformation = (PKEY_VALUE_FULL_INFORMATION)Buffer;

                ASSERT(KeyValueFullInformation == KeyInformation->Type);
                ASSERT((0 < ResultLength) && (ResultLength <= Length));

                // The DSA's DN was found and read successfully from the registry
                // so copy it to the output buffer and return. Use byte offset,
                // not KeyInformation offset, to access the data.

                KeyValue = &(Buffer[KeyInformation->DataOffset]);
                KeyValueLength = KeyInformation->DataLength;

                // SampDiagPrint(RID_MANAGER,
                //               ("SAMSS: Key Value = %ws; Value Length = %lu\n",
                //                KeyValue,
                //                KeyValueLength));

                *MachineDnName = RtlAllocateHeap(RtlProcessHeap(), 0, KeyValueLength);

                if (NULL == *MachineDnName)
                {
                    *NameLength = 0;
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
                else
                {
                    RtlZeroMemory(*MachineDnName, KeyValueLength);

                    RtlCopyMemory(*MachineDnName,
                                  KeyValue,
                                  KeyValueLength);

                    *NameLength = KeyValueLength;


                    // SampDiagPrint(RID_MANAGER,
                    //               ("SAMSS: MachineDnName = %ws; Name Length = %lu\n",
                    //                MachineDnName,
                    //                *NameLength));

                    NtStatus = STATUS_SUCCESS;
                }
            }
            else
            {
                SampDiagPrint(RID_MANAGER,
                              ("SAMSS: NtQueryValueKey status = 0x%lx\n",
                               NtStatus));
            }
        }

        CloseHandle(Handle);
    }
    else
    {
        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: NtOpenKey status = 0x%lx\n", NtStatus));
    }

    return(NtStatus);
}


NTSTATUS
SampExtractReadResults(
    IN RID_OBJECT_TYPE ObjectType,
    IN READRES *ReadResult,
    OUT PRIDINFO RidInfo
    )

/*++

Routine Description:

    This routine reads the data from a DS data structure and tansforms it into
    the RIDINFO stucture so that it can be manipulated by the RID management
    code with less runtime overhead.

Arguments:

    ObjectType - Enum, RidManagerReference, RidManager, or RidObject.

    ReadResult - Pointer, input DS data.

    RidInfo - Pointer, returned RID information.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ATTRBLOCK AttrBlock;
    ATTRTYP AttrType = 0;
    ATTRVAL *AttrVal = NULL;
    ULONG Index = 0;
    ULONG Length = 0;
    ULONG StringLength = 0;

    SAMTRACE("SampExtractReadResults");

    if ((NULL == ReadResult) || (NULL == RidInfo))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    ASSERT((ObjectType == RidManagerReferenceType) ||
           (ObjectType == RidManagerType) ||
           (ObjectType == RidObjectType));

    RtlZeroMemory(&AttrBlock, sizeof(ATTRBLOCK));

    AttrBlock = ReadResult->entry.AttrBlock;

    // Determine whether the object is the RID Manager Reference, the RID
    // Manager, or the RID Object. Once this is determined, check the flag
    // in the RIDINFO structure to determine which attributes are being
    // asked for and extract them accordingly from the DS attribute block.
    // This is done by iterating through the returned (from a DS read op-
    // eration) ATTRBLOCK, copying the data into the RIDINFO stucture. Note
    // that space is allocated by this routine for the variable-length data
    // so needs to be released by the calling routine.

    if (RidManagerReferenceType == ObjectType)
    {
        for (Index = 0; Index < AttrBlock.attrCount; Index++)
        {
            AttrType = AttrBlock.pAttr[Index].attrTyp;
            AttrVal = AttrBlock.pAttr[Index].AttrVal.pAVal;
            Length = AttrVal->valLen;

            switch (AttrType)
            {

            case ATT_RID_MANAGER_REFERENCE:
                RidInfo->RidManagerReference = (PDSNAME) AttrVal->pVal;

                break;

            default:
                NtStatus = STATUS_INTERNAL_ERROR;
                SampDiagPrint(RID_MANAGER,
                              ("SAMSS: ExtractReadResults, undefined attribute error\n"));
                break;

            }
        }
    }
    else if (RidManagerType == ObjectType)
    {
        for (Index = 0; Index < AttrBlock.attrCount; Index++)
        {
            AttrType = AttrBlock.pAttr[Index].attrTyp;
            AttrVal = AttrBlock.pAttr[Index].AttrVal.pAVal;
            Length = AttrVal->valLen;

            switch (AttrType)
            {

            case ATT_FSMO_ROLE_OWNER:
                RidInfo->RoleOwner = (PDSNAME) AttrVal->pVal;

                break;

            case ATT_RID_AVAILABLE_POOL:
                RidInfo->RidPoolAvailable = *(ULARGE_INTEGER *)(AttrVal->pVal);
                break;

            default:
                NtStatus = STATUS_INTERNAL_ERROR;
                SampDiagPrint(RID_MANAGER,
                              ("SAMSS: ExtractReadResults, undefined attribute error\n"));
                break;

            }
        }
    }
    else if (RidObjectType == ObjectType)
    {
        for (Index = 0; Index < AttrBlock.attrCount; Index++)
        {
            AttrType = AttrBlock.pAttr[Index].attrTyp;
            AttrVal = AttrBlock.pAttr[Index].AttrVal.pAVal;

            switch (AttrType)
            {

            case ATT_RID_ALLOCATION_POOL:
                RidInfo->RidPoolAllocated = *(ULARGE_INTEGER *)(AttrVal->pVal);
                break;

            case ATT_RID_PREVIOUS_ALLOCATION_POOL:
                RidInfo->RidPoolPrevAlloc = *(ULARGE_INTEGER *)(AttrVal->pVal);
                break;

            case ATT_RID_USED_POOL:
                RidInfo->RidPoolUsed = *(ULARGE_INTEGER *)(AttrVal->pVal);
                break;

            case ATT_RID_NEXT_RID:
                RidInfo->NextRid = *(ULONG *)(AttrVal->pVal);
                break;

            default:
                NtStatus = STATUS_INTERNAL_ERROR;
                SampDiagPrint(RID_MANAGER,
                              ("SAMSS: ExtractReadResults, undefined attribute error\n"));
                break;

            }
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return(NtStatus);
}


//============================================================================
//
//                         Rid Manager Logging/Dumping Routines
//
//============================================================================

VOID
SampDumpRidInfo(
    PRIDINFO RidInfo
    )
{
    SAMTRACE("SampDumpRidInfo");

    if (NULL == RidInfo)
    {
        SampDiagPrint(RID_MANAGER, ("SAMSS: Dump RidInfo pointer = 0x%lx\n", RidInfo));
        return;
    }

    if (NULL != RidInfo->RidManagerReference)
    {
        SampDiagPrint(RID_MANAGER,
            ("SAMSS: Reference       = %ws\n",
             RidInfo->RidManagerReference->StringName));
    }

    if (NULL != RidInfo->RoleOwner)
    {
        SampDiagPrint(RID_MANAGER,
            ("SAMSS: Role Owner      = %ws\n",
             RidInfo->RoleOwner->StringName));
    }

    SampDiagPrint(RID_MANAGER,
        ("SAMSS: Pool Available  = %lu - %lu\n",
         RidInfo->RidPoolAvailable.LowPart, RidInfo->RidPoolAvailable.HighPart));
    SampDiagPrint(RID_MANAGER,
        ("SAMSS: DC Count        = %lu\n",
         RidInfo->RidDcCount));
    SampDiagPrint(RID_MANAGER,
        ("SAMSS: Pool Allocated  = %lu - %lu\n",
         RidInfo->RidPoolAllocated.LowPart, RidInfo->RidPoolAllocated.HighPart));
    SampDiagPrint(RID_MANAGER,
        ("SAMSS: Prev Pool Alloc = %lu - %lu\n",
         RidInfo->RidPoolPrevAlloc.LowPart, RidInfo->RidPoolPrevAlloc.HighPart));
    SampDiagPrint(RID_MANAGER,
        ("SAMSS: Used Pool       = %lu - %lu\n",
         RidInfo->RidPoolUsed.LowPart, RidInfo->RidPoolUsed.HighPart));
    SampDiagPrint(RID_MANAGER,
        ("SAMSS: Next RID        = %lu\n",
         RidInfo->NextRid));
    SampDiagPrint(RID_MANAGER,
        ("SAMSS: Flags           = 0x%lx\n",
         RidInfo->Flags));

    return;
}



VOID
SampLogRidValues(
    IN ULONG MinDomRid,
    IN ULONG MaxDomRid,
    IN ULONG BlockSize,
    IN ULONG MinAvailRid,
    IN ULONG MaxAvailRid,
    IN ULONG MinAllocRid,
    IN ULONG MaxAllocRid,
    IN ULONG NextRid,
    IN USHORT EventType,
    IN NTSTATUS NtStatus
    )
{
    ULONG i = 0;
    WCHAR String[MAX_EVENT_STRINGS][64];
    UNICODE_STRING UnicodeString[MAX_EVENT_STRINGS];
    PUNICODE_STRING EventString[MAX_EVENT_STRINGS];

    wsprintf(String[0], L"Minimum Domain RID = %lu", MinDomRid);
    RtlInitUnicodeString(&UnicodeString[0], String[0]);

    wsprintf(String[1], L"Maximum Domain RID = %lu", MaxDomRid);
    RtlInitUnicodeString(&UnicodeString[1], String[1]);

    wsprintf(String[2], L"RID Pool Size = %lu", BlockSize);
    RtlInitUnicodeString(&UnicodeString[2], String[2]);

    wsprintf(String[3], L"Minimum Available RID = %lu", MinAvailRid);
    RtlInitUnicodeString(&UnicodeString[3], String[3]);

    wsprintf(String[4], L"Maximum Available RID = %lu", MaxAvailRid);
    RtlInitUnicodeString(&UnicodeString[4], String[4]);

    wsprintf(String[5], L"Minimum Allocated RID = %lu", MinAllocRid);
    RtlInitUnicodeString(&UnicodeString[5], String[5]);

    wsprintf(String[6], L"Maximum Allocated RID = %lu", MaxAllocRid);
    RtlInitUnicodeString(&UnicodeString[6], String[6]);

    wsprintf(String[7], L"Current RID Value = %lu", NextRid);
    RtlInitUnicodeString(&UnicodeString[7], String[7]);

    for (i = 0; i < MAX_EVENT_STRINGS; i++)
    {
        EventString[i] = &UnicodeString[i];
    }

    // During system startup, record the RID values in the event log. The
    // NT status code of the RID-Manager initialization is also recorded.
    SampWriteEventLog(EventType,
                      0,
                      SAMMSG_RID_MANAGER_INITIALIZATION,
                      NULL,
                      MAX_EVENT_STRINGS,
                      sizeof(NTSTATUS),
                      EventString,
                      (PVOID)(&NtStatus));

    return;
}


//============================================================================
//
//                         Rid Manager Memory Routines
//
//============================================================================

VOID
SampFreeModArgAttrs(
    ATTRMODLIST *AttrMod
    )
{
    SAMTRACE("SampFreeModArgAttrs");

    if (NULL != AttrMod)
    {
        ATTRMODLIST *AttrModTmp = AttrMod;
        ATTR Attr;
        ATTRVAL *AttrVal;

        // Note that the "Attr" member is an embedded struct that was copied
        // into the AttrMod at creation time, so is not released here.

        while (NULL != AttrMod)
        {
            AttrModTmp = AttrMod->pNextMod;
            Attr = AttrMod->AttrInf;
            AttrVal = Attr.AttrVal.pAVal;
            THFree(AttrVal);
            THFree(AttrMod);
            AttrMod = AttrModTmp;
        }
    }

    return;
}


VOID
SampFreeReadResultAttrs(
    READRES *ReadResult
    )
{
    SAMTRACE("SampFreeReadResultAttrs");

    if (NULL != ReadResult)
    {
        ATTRBLOCK *AttrBlock = &(ReadResult->entry.AttrBlock);

        if (NULL != AttrBlock)
        {
            if (NULL != AttrBlock->pAttr)
            {
                ULONG i, j;

                for(i = 0; i < AttrBlock->attrCount; i++)
                {
                    if (NULL != AttrBlock->pAttr[i].AttrVal.pAVal)
                    {
                        for(j = 0; j < AttrBlock->pAttr[i].AttrVal.valCount; j++)
                        {
                            if (NULL != AttrBlock->pAttr[i].AttrVal.pAVal[j].pVal)
                            {
                                THFree(AttrBlock->pAttr[i].AttrVal.pAVal[j].pVal);
                            }
                        }

                        THFree(AttrBlock->pAttr[i].AttrVal.pAVal);
                    }
                }

                THFree(AttrBlock->pAttr);
            }

            // Don't THFree(AttrBlock) cause it was structure copied into the
            // ENTINF! Who knows if the source AttrBlock was ever released by
            // the originating routine!
        }

        THFree(ReadResult->entry.pName);
    }

    return;
}


//============================================================================
//
//                        Rid Manager Reference Routines
//
//============================================================================


NTSTATUS
SampUpdateRidManagerReference(
    IN PDSNAME RidMgrRef,
    IN PDSNAME RidMgr
    )
{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampUpdateRidManagerReference");

    ASSERT( SampExistsDsTransaction() );

    if ((NULL != RidMgrRef) && (NULL != RidMgr))
    {
        NTSTATUS NtStatusTemp = STATUS_SUCCESS;
        MODIFYARG ModArg;
        MODIFYRES *pModRes;
        COMMARG *CommArg;
        ULONG RetCode;
        ATTR Attr;
        ATTRVALBLOCK AttrValBlock;
        ATTRVAL AttrVal;

        ASSERT((NULL != RidMgr) && (NULL != RidMgrRef->StringName));

        memset( &ModArg, 0, sizeof( ModArg ) );
        ModArg.pObject = RidMgrRef;

        ModArg.FirstMod.pNextMod = NULL;
        ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;

        AttrVal.valLen = RidMgr->structLen;
        AttrVal.pVal = (PUCHAR)RidMgr;

        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: RID Manager = %ws\n",
                       RidMgr->StringName));

        AttrValBlock.valCount = 1;
        AttrValBlock.pAVal = &AttrVal;

        Attr.attrTyp = ATT_RID_MANAGER_REFERENCE;
        Attr.AttrVal = AttrValBlock;

        ModArg.FirstMod.AttrInf = Attr;
        ModArg.count = 1;

        CommArg = &(ModArg.CommArg);

        BuildStdCommArg(CommArg);

        RetCode = DirModifyEntry(&ModArg, &pModRes);

        if (NULL==pModRes)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            NtStatus = SampMapDsErrorToNTStatus(RetCode,&pModRes->CommRes);
        }

        if (!NT_SUCCESS(NtStatus))
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirModifyEntry status = %d\n",
                           RetCode));
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirModifyEntry NT status = %d\n",
                           NtStatus));
        }

    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    ASSERT( SampExistsDsTransaction() );
    SampClearErrors();

    return(NtStatus);
}


NTSTATUS
SampReadRidManagerReferenceInfo(
    IN PDSNAME RidMgrRef,
    OUT PRIDINFO RidInfo
    )

/*++

Routine Description:

    This routine reads the RID Manager Reference data from the DS backing
    store, returning it in the format of the RIDINFO structure. This routine
    obtains the the DN of the RID Manager.

Arguments:

    RidMgrRef - Pointer, RDN DS name of the RID Manager Reference object.

    RidInfo - Pointer, returned data containing the DN of the RID Manager.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

    STATUS_NO_MEMORY if the returned buffers could not be allocated.

    Other DS error codes that have been mapped to an NTSTATUS can be returned
    from this routine.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampReadRidManagerReferenceInfo");

    ASSERT( SampExistsDsTransaction() );

    if ((NULL != RidMgrRef) && (NULL != RidInfo))
    {
        NTSTATUS NtStatusTemp = STATUS_SUCCESS;
        READARG ReadArg;
        READRES *ReadResult = NULL;
        ENTINFSEL EISelection; // Entry Information Selection
        ATTRBLOCK ReadAttrBlock;
        COMMARG *CommArg;
        ULONG RetCode = 0;
        ULONG Index = 0;
        ATTR *Attr = NULL;

        ASSERT(NULL != RidMgrRef->StringName);

        RtlZeroMemory(&ReadArg, sizeof(READARG));
        RtlZeroMemory(&EISelection, sizeof(ENTINFSEL));
        RtlZeroMemory(&ReadAttrBlock, sizeof(ATTRBLOCK));

        Attr = (ATTR *)DSAlloc(sizeof(ATTR) * SAMP_RID_ATTR_MAX);

        if (NULL == Attr)
        {
            return(STATUS_NO_MEMORY);
        }

        RtlZeroMemory(Attr, sizeof(ATTR) * SAMP_RID_ATTR_MAX);

        if (RID_REFERENCE & RidInfo->Flags)
        {
            Attr[Index].attrTyp = ATT_RID_MANAGER_REFERENCE;
            Index++;
        }

        ReadAttrBlock.attrCount = Index;
        ReadAttrBlock.pAttr = Attr;

        EISelection.AttrTypBlock = ReadAttrBlock;
        EISelection.attSel = EN_ATTSET_LIST;
        EISelection.infoTypes = EN_INFOTYPES_TYPES_VALS;

        ReadArg.pSel = &EISelection;
        ReadArg.pObject = RidMgrRef;
        CommArg = &(ReadArg.CommArg);
        BuildStdCommArg(CommArg);

        RetCode = DirRead(&ReadArg, &ReadResult);

        if (NULL==ReadResult)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            NtStatus = SampMapDsErrorToNTStatus(RetCode,&ReadResult->CommRes);
        }

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampExtractReadResults(RidManagerReferenceType,
                                              ReadResult,
                                              RidInfo);

        }
        else
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirRead (RidManagerRef) status = 0x%lx\n",
                           NtStatus));
        }

        THFree(Attr);

        if (!NT_SUCCESS(NtStatus))
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: SampExtractReadResults status = 0x%lx\n",
                           NtStatus));
        }

    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    ASSERT( SampExistsDsTransaction() );
    SampClearErrors();

    return(NtStatus);
}


//============================================================================
//
//                              Validation Routines
//
//============================================================================

NTSTATUS
SampVerifyStartupEnv(
    IN PDSNAME RidMgr
    )

/*++

Routine Description:

    The purpose of this routine is to determine whether or not the initial
    startup environment for the RID Manager is valid on a replica (B)DC.

    After replicating the domain information to the replica DC and for
    some reason the RID Manager object is NOT replicated (perhaps due to
    network problems), subsequent reboot of the replica DC could cause the
    RID Manager object to be re-created on that DC. This routine detects
    such a situation and returns an error code, as well as preventing the
    creation of the RID Manager object on the BDC (it is only created on
    the PDC).

    If the RID Manager object does not exist, on the replica DC, then the
    replica DC will not be able to allocate an initial RID pool and should
    prevent account creation until the object exists.

Arguments:

    RidMgr - Pointer, RDN DS name of the RID Manager object.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampVerifyStartupEnv");

    if (NULL != RidMgr)
    {
        NT_PRODUCT_TYPE NtProductType;
        DOMAIN_SERVER_ROLE ServerRole;

        // Get the server role from the SAM global domain information array,
        // using the DS Account domain, i.e. DOMAIN_START_DS + 1. Note that
        // the DS Builtin domain is at index DOMAIN_START_DS.

        RtlGetNtProductType(&NtProductType);
        ServerRole = SampDefinedDomains[DOMAIN_START_DS + 1].ServerRole;

        // SampDiagPrint(RID_MANAGER,
        //               ("SAMSS: NtProductType = %d ServerRole = %d\n",
        //                NtProductType,
        //                ServerRole));

        if ((NtProductLanManNt == NtProductType) &&
            (DomainServerRoleBackup == ServerRole))
        {
            // The server is a BDC, so make sure that the RID Manager object
            // already exists on this machine (via replication). If it does
            // not exist, this is an error, and no RID pool can be allocated
            // to this DSA at this time. Retry later. Attempt to read the RID
            // available pool as the basic existence test.

            RIDINFO RidInfo;
            RIDFLAG Flag = RID_AVAILABLE_POOL;

            RtlZeroMemory(&RidInfo, sizeof(RIDINFO));
            SampSetRidFlags(&RidInfo, Flag);

            NtStatus = SampReadRidManagerInfo(RidMgr, &RidInfo);
        }
        else
        {
            // The server is a PDC, so continue on as usual, no further
            // checking necessary.

            NtStatus = STATUS_SUCCESS;
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return(NtStatus);
}


NTSTATUS
SampVerifyRidManagerExists(
    IN PDSNAME RidMgr
    )

/*++

Routine Description:

    The purpose of this routine is to find out whether the RID Manager$
    object exists on the given DSA.

Arguments:

    RidMgr - Pointer, RDN DS name of the RID Manager object.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampRidManagerExists");

    if (NULL != RidMgr)
    {
        RIDINFO RidInfo;
        RIDFLAG Flag = RID_AVAILABLE_POOL;

        RtlZeroMemory(&RidInfo, sizeof(RIDINFO));
        SampSetRidFlags(&RidInfo, Flag);

        // Attempt to read a must-have attribute on the RID Manager to verify
        // that the object exists.

        NtStatus = SampReadRidManagerInfo(RidMgr, &RidInfo);
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return(NtStatus);
}




//============================================================================
//
//                              Rid Manager Routines
//
//============================================================================


NTSTATUS
SampCreateRidManager(
    IN PDSNAME RidMgr
    )

/*++

Routine Description:

    This routine creates the RID Manager object in the DS tree, if it does
    not already exist. The RID Manager contains the Role Owner and domain-
    wide RID pool that is available.

    The Role Owner is the current DC (a.k.a. DSA) that has the rights to
    modify either the Role Owner value or the available RID pool. As each DC
    requests a RID allocation from the pool, the RID Manager subtracts this
    allocation from the bottom of the available pool.

Arguments:

    RidMgr - Pointer, RDN DS name of the RID Manager object.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    USHORT EventType = 0;

    SAMTRACE("SampCreateRidManager");

    ASSERT( SampExistsDsTransaction() );

    if (NULL != RidMgr)
    {
        PWCHAR MachineDnName = NULL;
        ULONG Length = 0;
        PDSNAME RoleOwnerDsName = NULL;
        ULONG RoleOwnerDsNameLength = 0;
        BOOLEAN TrustedClient = TRUE;
        PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
        ULONG SecurityDescriptorLength = 0;

        ASSERT((NULL != RidMgr) && (NULL != RidMgr->StringName));

        // The DS disallows setting the DN attribute to a temporary
        // object that does not yet exist in the DS so, determine the
        // RoleOwner's DN and set it during object creation.

        NtStatus = SampGetMachineDnName(&MachineDnName, &Length);

        if (NT_SUCCESS(NtStatus))
        {
            ASSERT(NULL != MachineDnName);
            ASSERT(0 < Length);
            SAMP_ALLOCA(RoleOwnerDsName,DSNameSizeFromLen(Length));
            if (NULL==RoleOwnerDsName)
            {
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
            SampInitializeDsName(RoleOwnerDsName,
                                 NULL,
                                 0,
                                 MachineDnName,
                                 Length);

            RoleOwnerDsNameLength = RoleOwnerDsName->structLen;
            RtlFreeHeap(RtlProcessHeap(), 0, MachineDnName);
        }

        NtStatus = SampGetDefaultSecurityDescriptorForClass(
                                            CLASS_RID_MANAGER,
                                            &SecurityDescriptorLength,
                                            TrustedClient,
                                            &SecurityDescriptor);

        if (NT_SUCCESS(NtStatus))
        {
            NTSTATUS NtStatusTemp = STATUS_SUCCESS;
            ULONG ObjectClass = CLASS_RID_MANAGER;
            WCHAR RidMgrRDN[] = RID_MGR_W;
            ULONG RidMgrRDNLength = (sizeof(RidMgrRDN) - 2);
            LARGE_INTEGER RidPoolAvailable = {0, 0};
            ULONG RidPoolAvailableLength = sizeof(ULARGE_INTEGER);
            ULONG IsCritical = 1;
            ULONG SystemFlags = FLAG_DOMAIN_DISALLOW_RENAME |
                                FLAG_DOMAIN_DISALLOW_MOVE |
                                FLAG_DISALLOW_DELETE ;
            ADDARG AddArg;
            ADDRES *pAddRes;
            COMMARG *CommArg;
            ULONG RetCode;

            ATTRTYP Type[] =
            {
                ATT_NT_SECURITY_DESCRIPTOR,
                ATT_OBJECT_CLASS,
                ATT_COMMON_NAME,
                ATT_FSMO_ROLE_OWNER,
                ATT_RID_AVAILABLE_POOL,
                ATT_SYSTEM_FLAGS,
                ATT_IS_CRITICAL_SYSTEM_OBJECT
            };

            ATTRVAL Value[] =
            {
                {SecurityDescriptorLength,    (PUCHAR)SecurityDescriptor},
                {sizeof(ULONG),               (PUCHAR)&ObjectClass},
                {RidMgrRDNLength,             (PUCHAR)RidMgrRDN},
                {RoleOwnerDsNameLength,       (PUCHAR)RoleOwnerDsName},
                {RidPoolAvailableLength,      (PUCHAR)&RidPoolAvailable},
                {sizeof(ULONG),               (PUCHAR)&SystemFlags},
                {sizeof(ULONG),               (PUCHAR)&IsCritical}

            };

            DEFINE_ATTRBLOCK7(AttrBlock, Type, Value);

            ASSERT(NULL != SecurityDescriptor);
            ASSERT(0 < SecurityDescriptorLength);

            memset( &AddArg, 0, sizeof( AddArg ) );
            AddArg.pObject = RidMgr;
            AddArg.AttrBlock = AttrBlock;
            CommArg = &(AddArg.CommArg);

            BuildStdCommArg(CommArg);

            RetCode = DirAddEntry(&AddArg, &pAddRes);

            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirAddEntry status (RID Mgr) = %d\n", RetCode));

            if (NULL==pAddRes)
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                NtStatus = SampMapDsErrorToNTStatus(RetCode,&pAddRes->CommRes);
            }

            // Must end the DS transaction regardless of error status,
            // otherwise a SAM write lock is held.

            if (!NT_SUCCESS(NtStatus))
            {
                // Catch any change to the error-mapping layer. The ex-
                // pected failure is that the RID Manager object already
                // exists, which is an update error (updError) and this
                // should map to SAMP_OBJ_EXISTS.

                ASSERT(updError == RetCode);
                #if (DBG == 1)
                if (updError == RetCode)
                {
                    ASSERT(SAMP_OBJ_EXISTS == NtStatus);
                }
                #endif
            }

            if (NULL != SecurityDescriptor)
            {
                MIDL_user_free(SecurityDescriptor);
            }
        }
        else
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: SampGetDefaultSecurityDescriptorForClass status = 0x%lx\n",
                           NtStatus));
        }

    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    (NT_SUCCESS(NtStatus)) ?
        (EventType = EVENTLOG_INFORMATION_TYPE) :
        (EventType = EVENTLOG_ERROR_TYPE);


    //
    // This is only interesting if it fails
    //
    if ( !NT_SUCCESS( NtStatus ) )
    {
        SampWriteEventLog(EventType,
                          0,
                          SAMMSG_RID_MANAGER_CREATION,
                          NULL,
                          0,
                          sizeof(NtStatus),
                          NULL,
                          &NtStatus);
    }


    ASSERT( SampExistsDsTransaction() );
    SampClearErrors();

    return(NtStatus);
}


NTSTATUS
SampUpdateRidManager(
    IN PDSNAME RidMgr,
    IN PRIDINFO RidInfo
    )
{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampUpdateRidManager");

    ASSERT( SampExistsDsTransaction() );

    if ((NULL != RidMgr) && (NULL != RidInfo))
    {
        NTSTATUS NtStatusTemp = STATUS_SUCCESS;
        MODIFYARG ModArg;
        MODIFYRES *pModRes;
        COMMARG *CommArg;
        ATTRMODLIST *AttrMod;
        ATTRMODLIST *AttrModTmp = NULL; // Fix build w/ new x86 compiler
        ULONG RetCode = 0;
        ULONG Index = 0;
        ATTRVAL *AttrVal;
        ATTRVALBLOCK AttrValBlock;
        ATTR *Attr;

        ASSERT(NULL != RidMgr->StringName);

        //
        // One of the 2 flags must be passed in by the caller
        //

        ASSERT((RidInfo->Flags & RID_ROLE_OWNER) ||
                   (RidInfo->Flags & RID_AVAILABLE_POOL));

        if (RID_ROLE_OWNER & RidInfo->Flags)
        {
            AttrVal = (ATTRVAL *)DSAlloc(sizeof(ATTRVAL));
            Attr = (ATTR *)DSAlloc(sizeof(ATTR));

            if ((NULL == AttrVal) || (NULL == Attr))
            {
                return(STATUS_NO_MEMORY);
            }

            AttrVal->valLen = RidInfo->RoleOwner->structLen;
            AttrVal->pVal = (PUCHAR)RidInfo->RoleOwner;
            AttrValBlock.pAVal = AttrVal;
            AttrValBlock.valCount = 1;
            Attr->AttrVal = AttrValBlock;
            Attr->attrTyp = ATT_FSMO_ROLE_OWNER;

            AttrMod = (ATTRMODLIST *)DSAlloc(sizeof(ATTRMODLIST));

            if (NULL == AttrMod)
            {
                return(STATUS_NO_MEMORY);
            }

            AttrMod->AttrInf = *Attr;
            AttrMod->choice = AT_CHOICE_REPLACE_ATT;
            THFree(Attr);

            if (0 < Index)
            {
                AttrMod->pNextMod = AttrModTmp;
            }
            else
            {
                AttrMod->pNextMod = NULL;
            }

            AttrModTmp = AttrMod;

            Index++;

            SampDiagPrint(RID_MANAGER,
                ("SAMSS: RoleOwner StringName = %ws\n",
                RidInfo->RoleOwner->StringName));
        }

        if (RID_AVAILABLE_POOL & RidInfo->Flags)
        {
            AttrVal = (ATTRVAL *)DSAlloc(sizeof(ATTRVAL));
            Attr = (ATTR *)DSAlloc(sizeof(ATTR));

            if ((NULL == AttrVal) || (NULL == Attr))
            {
                return(STATUS_NO_MEMORY);
            }

            AttrVal->valLen = sizeof(ULARGE_INTEGER);
            AttrVal->pVal = (PUCHAR)&(RidInfo->RidPoolAvailable);
            AttrValBlock.pAVal = AttrVal;
            AttrValBlock.valCount = 1;
            Attr->AttrVal = AttrValBlock;
            Attr->attrTyp = ATT_RID_AVAILABLE_POOL;

            AttrMod = (ATTRMODLIST *)DSAlloc(sizeof(ATTRMODLIST));

            if (NULL == AttrMod)
            {
                return(STATUS_NO_MEMORY);
            }

            AttrMod->AttrInf = *Attr;
            AttrMod->choice = AT_CHOICE_REPLACE_ATT;
            THFree(Attr);

            if (0 < Index)
            {
                AttrMod->pNextMod = AttrModTmp;
            }
            else
            {
                AttrMod->pNextMod = NULL;
            }

            AttrModTmp = AttrMod;

            Index++;

            SampDiagPrint(RID_MANAGER,
                ("SAMSS: Rid Pool Available = %lu - %lu\n",
                RidInfo->RidPoolAvailable.LowPart,
                RidInfo->RidPoolAvailable.HighPart));
        }

        memset( &ModArg, 0, sizeof( ModArg ) );
        ModArg.FirstMod = *AttrModTmp;
        ModArg.count = (USHORT)Index;
        ModArg.pObject = RidMgr;

        ASSERT(0 < Index);

        CommArg = &(ModArg.CommArg);

        BuildStdCommArg(CommArg);


        //
        // Turn on Urgent Replication for Updates to the RID manager
        // object
        //

        CommArg->Svccntl.fUrgentReplication = TRUE;

        RetCode = DirModifyEntry(&ModArg, &pModRes);

        if (NULL==pModRes)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            NtStatus = SampMapDsErrorToNTStatus(RetCode,&pModRes->CommRes);
        }

        SampFreeModArgAttrs(AttrModTmp);

        if (!NT_SUCCESS(NtStatus))
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirModifyEntry status = %d\n",
                           RetCode));
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirModifyEntry NT status = %d\n",
                           NtStatus));
        }

    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    ASSERT( SampExistsDsTransaction() );
    SampClearErrors();

    return(NtStatus);
}




NTSTATUS
SampReadRidManagerInfoEx(
    IN PDSNAME RidMgr,
    OUT PRIDINFO RidInfo
    )

/*++

Routine Description:

    This routine reads the RID Manager data from the DS backing store, re-
    turning it in the format of the RIDINFO structure. This routine obtains
    the DN of the current Role Owner (a.k.a. the RID Manager) and the pool
    of RIDs available to any DC in the domain.

Arguments:

    RidMgrRef - Pointer, RDN DS name of the RID Manager Reference object.

    fCloseTransactions - Indicates that we should close the transaction ( ie
                         not running in caller's transaction )

    RidInfo - Pointer, returned data containing the DN of the RID Manager.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

    STATUS_NO_MEMORY if the returned buffers could not be allocated.

    Other DS error codes that have been mapped to an NTSTATUS can be returned
    from this routine.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampReadRidManagerInfo");

    ASSERT( SampExistsDsTransaction() );

    if ((NULL != RidMgr) && (NULL != RidInfo))
    {
        NTSTATUS NtStatusTemp = STATUS_SUCCESS;
        READARG ReadArg;
        READRES *ReadResult = NULL;
        ENTINFSEL EISelection; // Entry Information Selection
        ATTRBLOCK ReadAttrBlock;
        COMMARG *CommArg;
        ULONG RetCode = 0;
        ULONG Index = 0;
        ATTR *Attr = NULL;

        ASSERT(NULL != RidMgr->StringName);

        RtlZeroMemory(&ReadArg, sizeof(READARG));
        RtlZeroMemory(&EISelection, sizeof(ENTINFSEL));
        RtlZeroMemory(&ReadAttrBlock, sizeof(ATTRBLOCK));

        Attr = (ATTR *)DSAlloc(sizeof(ATTR) * SAMP_RID_ATTR_MAX);

        if (NULL == Attr)
        {
            return(STATUS_NO_MEMORY);
        }

        RtlZeroMemory(Attr, sizeof(ATTR) * SAMP_RID_ATTR_MAX);

        if (RID_ROLE_OWNER & RidInfo->Flags)
        {
            Attr[Index].attrTyp = ATT_FSMO_ROLE_OWNER;
            Index++;
        }

        if (RID_AVAILABLE_POOL & RidInfo->Flags)
        {
            Attr[Index].attrTyp = ATT_RID_AVAILABLE_POOL;
            Index++;
        }

        ReadAttrBlock.attrCount = Index;
        ReadAttrBlock.pAttr = Attr;

        EISelection.AttrTypBlock = ReadAttrBlock;
        EISelection.attSel = EN_ATTSET_LIST;
        EISelection.infoTypes = EN_INFOTYPES_TYPES_VALS;

        ReadArg.pSel = &EISelection;
        ReadArg.pObject = RidMgr;
        CommArg = &(ReadArg.CommArg);
        BuildStdCommArg(CommArg);

        RetCode = DirRead(&ReadArg, &ReadResult);

        if (NULL==ReadResult)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            NtStatus = SampMapDsErrorToNTStatus(RetCode,&ReadResult->CommRes);
        }

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampExtractReadResults(RidManagerType,
                                              ReadResult,
                                              RidInfo);

        }
        else
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirRead (RidManager) status = 0x%lx\n",
                           NtStatus));
        }

        THFree(Attr);

        if (!NT_SUCCESS(NtStatus))
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: SampExtractReadResults status = 0x%lx\n",
                           NtStatus));
        }

    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    ASSERT( SampExistsDsTransaction() );
    SampClearErrors();

    return(NtStatus);
}


NTSTATUS
SampReadRidManagerInfo(
    IN PDSNAME RidMgr,
    OUT PRIDINFO RidInfo
    )
{
    return (SampReadRidManagerInfoEx(
                RidMgr,
                RidInfo
                ));
}

//============================================================================
//
//                              Rid Object Routines
//
//============================================================================


NTSTATUS
SampUpdateRidSetReferences(
    IN PDSNAME ComputerObject,
    IN PDSNAME RidObject
    )
{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    MODIFYARG ModArg;
    MODIFYRES *pModRes;
    COMMARG *CommArg;
    ULONG RetCode;
    ATTR Attr;
    ATTRVALBLOCK AttrValBlock;
    ATTRVAL AttrVal;

    RtlZeroMemory(&ModArg, sizeof(ModArg));
    ModArg.pObject = ComputerObject;

    ModArg.FirstMod.pNextMod = NULL;
    ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;

    AttrVal.valLen = RidObject->structLen;
    AttrVal.pVal = (PUCHAR)RidObject;

    AttrValBlock.valCount = 1;
    AttrValBlock.pAVal = &AttrVal;

    Attr.attrTyp = ATT_RID_SET_REFERENCES;
    Attr.AttrVal = AttrValBlock;

    ModArg.FirstMod.AttrInf = Attr;
    ModArg.count = 1;

    CommArg = &(ModArg.CommArg);

    BuildStdCommArg(CommArg);

    // Whenever a new RID Set object is created, its DN is stored as a RID
    // Set Reference on the Computer object (for this DSA).

    RetCode = DirModifyEntry(&ModArg, &pModRes);

    if (NULL==pModRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetCode,&pModRes->CommRes);
    }

    return(NtStatus);
}


NTSTATUS
SampCreateRidObject(
    IN PDSNAME ComputerObject,
    IN PDSNAME RidObject
    )
{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG Length = 0;
    ULONG Status = 0;
    ADDARG AddArg;
    ADDRES *pAddRes;
    COMMARG *CommArg;

    BOOLEAN TrustedClient = TRUE;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    ULONG SecurityDescriptorLength = 0;

    ASSERT( SampExistsDsTransaction() );

    if ((NULL == ComputerObject) || (NULL == RidObject))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    // Allocate space for the RID Set object DN plus some padding overhead
    // for extra characters (e.g. "cn=") added by AppendRDN.

    // Create and set default attributes needed to create the RID
    // Set object. All RID ranges are initialized to zero for now
    // and are updated later.


    NtStatus = SampGetDefaultSecurityDescriptorForClass(
                                        CLASS_RID_SET,
                                        &SecurityDescriptorLength,
                                        TrustedClient,
                                        &SecurityDescriptor);

    if (NT_SUCCESS(NtStatus))
    {
        NTSTATUS NtStatusTemp = STATUS_SUCCESS;
        ULONG ObjectClass = CLASS_RID_SET;
        WCHAR RidObjRDN[] = RID_SET_W;
        ULONG RidObjRDNLength = (sizeof(RidObjRDN) - 2);
        LARGE_INTEGER RidAllocPool = {0, 0};
        LARGE_INTEGER RidPrevPool = {0, 0};
        LARGE_INTEGER RidUsedPool = {0, 0};
        ULONG RidNextRid = 0;

        ATTRTYP Type[] =
        {
            ATT_NT_SECURITY_DESCRIPTOR,
            ATT_OBJECT_CLASS,
            ATT_COMMON_NAME,
            ATT_RID_ALLOCATION_POOL,
            ATT_RID_PREVIOUS_ALLOCATION_POOL,
            ATT_RID_NEXT_RID,
            ATT_RID_USED_POOL
        };

        ATTRVAL Value[] =
        {
            {SecurityDescriptorLength,    (PUCHAR)SecurityDescriptor},
            {sizeof(ULONG),               (PUCHAR)&ObjectClass},
            {RidObjRDNLength,             (PUCHAR)RidObjRDN},
            {sizeof(ULARGE_INTEGER),      (PUCHAR)&RidAllocPool},
            {sizeof(ULARGE_INTEGER),      (PUCHAR)&RidPrevPool},
            {sizeof(ULONG),               (PUCHAR)&RidNextRid},
            {sizeof(ULARGE_INTEGER),      (PUCHAR)&RidUsedPool}
        };

        DEFINE_ATTRBLOCK7(AttrBlock, Type, Value);

        ASSERT(NULL != SecurityDescriptor);
        ASSERT(0 < SecurityDescriptorLength);

        memset( &AddArg, 0, sizeof( AddArg ) );
        AddArg.pObject = RidObject;
        AddArg.AttrBlock = AttrBlock;
        CommArg = &(AddArg.CommArg);

        BuildStdCommArg(CommArg);

        // Add the RID Set Object to the DS, and if successful,
        // update the RID Set References DN on the Computer object
        // with the DN of this new object.

        Status = DirAddEntry(&AddArg, &pAddRes);

        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: DirAddEntry status (RID Object) = %d\n", Status));

        if (NULL==pAddRes)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            NtStatus = SampMapDsErrorToNTStatus(Status,&pAddRes->CommRes);
        }

        if ( NT_SUCCESS(NtStatus)
          || NtStatus == STATUS_USER_EXISTS )
        {
            NtStatus = SampUpdateRidSetReferences(ComputerObject,
                                                  RidObject);

            if ( !NT_SUCCESS(NtStatus) )
            {
                SampDiagPrint(RID_MANAGER,
                              ("SAMSS: SampUpdateRidSetReferences status = 0x%lx\n",
                               NtStatus));
            }

        }
        else
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirAddEntry for RidSetObject status = 0x%lx\n",
                           NtStatus));
        }

        if (NULL != SecurityDescriptor)
        {
            MIDL_user_free(SecurityDescriptor);
        }
    }
    else
    {
        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: SampGetDefaultSecurityDescriptorForClass status = 0x%lx\n",
                       NtStatus));
    }

    ASSERT( SampExistsDsTransaction() );
    SampClearErrors();

    return(NtStatus);
}


NTSTATUS
SampUpdateRidObject(
    IN PDSNAME RidObj,
    IN PRIDINFO RidInfo,
    IN BOOLEAN fLazyCommit,     // if set to TRUE, let JET commit lazily  
    IN BOOLEAN fAuthoritative   // If set to TRUE, force it to win against any existing
                                // version anywhere in the enterprise
    )
{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    NTSTATUS NtStatusTemp = STATUS_SUCCESS;
    MODIFYARG ModArg;
    MODIFYRES *pModRes;
    COMMARG *CommArg;
    ATTRMODLIST *AttrMod;
    ATTRMODLIST *AttrModTmp = NULL; // Fix build w/ new x86 compiler
    ULONG RetCode;
    ULONG Index = 0;
    ATTRVAL *AttrVal;
    ATTRVALBLOCK AttrValBlock;
    ATTR *Attr;

    SAMTRACE("SampUpdateRidObject");

    ASSERT( SampExistsDsTransaction() );

    if ((NULL != RidObj) && (NULL != RidInfo))
    {
        if (RID_ALLOCATED_POOL & RidInfo->Flags)
        {
            AttrVal = (ATTRVAL *)DSAlloc(sizeof(ATTRVAL));
            Attr = (ATTR *)DSAlloc(sizeof(ATTR));

            if ((NULL == AttrVal) || (NULL == Attr))
            {
                return(STATUS_NO_MEMORY);
            }

            AttrVal->valLen = sizeof(ULARGE_INTEGER);
            AttrVal->pVal = (PUCHAR)&(RidInfo->RidPoolAllocated);
            AttrValBlock.pAVal = AttrVal;
            AttrValBlock.valCount = 1;
            Attr->AttrVal = AttrValBlock;
            Attr->attrTyp = ATT_RID_ALLOCATION_POOL;

            AttrMod = (ATTRMODLIST *)DSAlloc(sizeof(ATTRMODLIST));

            if (NULL == AttrMod)
            {
                return(STATUS_NO_MEMORY);
            }

            AttrMod->AttrInf = *Attr;
            AttrMod->choice = AT_CHOICE_REPLACE_ATT;
            THFree(Attr);

            if (0 < Index)
            {
                AttrMod->pNextMod = AttrModTmp;
            }
            else
            {
                AttrMod->pNextMod = NULL;
            }

            AttrModTmp = AttrMod;

            Index++;

            SampDiagPrint(RID_MANAGER,
                ("SAMSS: Rid Pool Allocated = %lu - %lu\n",
                RidInfo->RidPoolAllocated.LowPart,
                RidInfo->RidPoolAllocated.HighPart));
        }

        if (RID_PREV_ALLOC_POOL & RidInfo->Flags)
        {
            AttrVal = (ATTRVAL *)DSAlloc(sizeof(ATTRVAL));
            Attr = (ATTR *)DSAlloc(sizeof(ATTR));

            if ((NULL == AttrVal) || (NULL == Attr))
            {
                return(STATUS_NO_MEMORY);
            }

            AttrVal->valLen = sizeof(ULARGE_INTEGER);
            AttrVal->pVal = (PUCHAR)&(RidInfo->RidPoolPrevAlloc);
            AttrValBlock.pAVal = AttrVal;
            AttrValBlock.valCount = 1;
            Attr->AttrVal = AttrValBlock;
            Attr->attrTyp = ATT_RID_PREVIOUS_ALLOCATION_POOL;

            AttrMod = (ATTRMODLIST *)DSAlloc(sizeof(ATTRMODLIST));

            if (NULL == AttrMod)
            {
                return(STATUS_NO_MEMORY);
            }

            AttrMod->AttrInf = *Attr;
            AttrMod->choice = AT_CHOICE_REPLACE_ATT;
            THFree(Attr);

            if (0 < Index)
            {
                AttrMod->pNextMod = AttrModTmp;
            }
            else
            {
                AttrMod->pNextMod = NULL;
            }

            AttrModTmp = AttrMod;

            Index++;

            SampDiagPrint(RID_MANAGER,
                ("SAMSS: Rid Pool Prev Alloc = %lu - %lu\n",
                RidInfo->RidPoolPrevAlloc.LowPart,
                RidInfo->RidPoolPrevAlloc.HighPart));
        }

        if (RID_USED_POOL & RidInfo->Flags)
        {
            AttrVal = (ATTRVAL *)DSAlloc(sizeof(ATTRVAL));
            Attr = (ATTR *)DSAlloc(sizeof(ATTR));

            if ((NULL == AttrVal) || (NULL == Attr))
            {
                return(STATUS_NO_MEMORY);
            }

            AttrVal->valLen = sizeof(ULARGE_INTEGER);
            AttrVal->pVal = (PUCHAR)&(RidInfo->RidPoolUsed);
            AttrValBlock.pAVal = AttrVal;
            AttrValBlock.valCount = 1;
            Attr->AttrVal = AttrValBlock;
            Attr->attrTyp = ATT_RID_USED_POOL;

            AttrMod = (ATTRMODLIST *)DSAlloc(sizeof(ATTRMODLIST));

            if (NULL == AttrMod)
            {
                return(STATUS_NO_MEMORY);
            }

            AttrMod->AttrInf = *Attr;
            AttrMod->choice = AT_CHOICE_REPLACE_ATT;
            THFree(Attr);

            if (0 < Index)
            {
                AttrMod->pNextMod = AttrModTmp;
            }
            else
            {
                AttrMod->pNextMod = NULL;
            }

            AttrModTmp = AttrMod;

            Index++;

            SampDiagPrint(RID_MANAGER,
                ("SAMSS: Rid Pool Used = %lu - %lu\n",
                RidInfo->RidPoolUsed.LowPart,
                RidInfo->RidPoolUsed.HighPart));
        }

        if (RID_NEXT_RID & RidInfo->Flags)
        {
            AttrVal = (ATTRVAL *)DSAlloc(sizeof(ATTRVAL));
            Attr = (ATTR *)DSAlloc(sizeof(ATTR));

            if ((NULL == AttrVal) || (NULL == Attr))
            {
                return(STATUS_NO_MEMORY);
            }

            AttrVal->valLen = sizeof(ULONG);
            AttrVal->pVal = (PUCHAR)&(RidInfo->NextRid);
            AttrValBlock.pAVal = AttrVal;
            AttrValBlock.valCount = 1;
            Attr->AttrVal = AttrValBlock;
            Attr->attrTyp = ATT_RID_NEXT_RID;

            AttrMod = (ATTRMODLIST *)DSAlloc(sizeof(ATTRMODLIST));

            if (NULL == AttrMod)
            {
                return(STATUS_NO_MEMORY);
            }

            AttrMod->AttrInf = *Attr;
            AttrMod->choice = AT_CHOICE_REPLACE_ATT;
            THFree(Attr);

            if (0 < Index)
            {
                AttrMod->pNextMod = AttrModTmp;
            }
            else
            {
                AttrMod->pNextMod = NULL;
            }

            AttrModTmp = AttrMod;

            Index++;

            SampDiagPrint(RID_MANAGER,
                ("SAMSS: Next Rid = %lu\n", RidInfo->NextRid));
        }

        memset( &ModArg, 0, sizeof( ModArg ) );
        ModArg.FirstMod = *AttrModTmp;
        ModArg.count = (USHORT)Index;
        ModArg.pObject = RidObj;

        ASSERT(0 < Index);

        CommArg = &(ModArg.CommArg);

        BuildStdCommArg(CommArg);

        if (fAuthoritative)
        {
            // We are asked to force this change to win everywhere
            // set the appropriate SVCCNTL bit to 1
            CommArg->Svccntl.fAuthoritativeModify = TRUE;
        }

        RetCode = DirModifyEntry(&ModArg, &pModRes);

        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: DirModifyEntry (RidObject) RetCode = 0x%lx\n",
                       RetCode));

        if (NULL==pModRes)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            NtStatus = SampMapDsErrorToNTStatus(RetCode,&pModRes->CommRes);
        }

        SampFreeModArgAttrs(AttrModTmp);

        if (!NT_SUCCESS(NtStatus))
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirModifyEntry status = %d\n",
                           RetCode));
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirModifyEntry NT status = %d\n",
                           NtStatus));
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    ASSERT( SampExistsDsTransaction() );
    SampClearErrors();

    return(NtStatus);
}


NTSTATUS
SampInitNextRid(
    PDSNAME  RidObject,
    PRIDINFO RidInfo
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;

    ASSERT( SampExistsDsTransaction() );

    if ( 0 == RidInfo->NextRid )
    {
        //
        // This function is only useful when an initial
        // rid pool has been allocated
        //

        ASSERT( RidInfo->NextRid == 0 );
        ASSERT( RidInfo->RidPoolPrevAlloc.LowPart == 0 );
        ASSERT( RidInfo->RidPoolPrevAlloc.HighPart == 0 );
        ASSERT( RidInfo->RidPoolAllocated.LowPart != 0 );
        ASSERT( RidInfo->RidPoolAllocated.HighPart != 0 );

        //
        // Move the allocated pool in to our local pool
        //
        RidInfo->RidPoolPrevAlloc = RidInfo->RidPoolAllocated;

        //
        // Start the first rid from the bottom
        //
        RidInfo->NextRid = RidInfo->RidPoolPrevAlloc.LowPart;

        SampSetRidFlags( RidInfo, RID_PREV_ALLOC_POOL | RID_NEXT_RID );

        NtStatus = SampUpdateRidObject(RidObject,
                                       RidInfo,
                                       FALSE,       // commit immediately
                                       FALSE );

        if ( !NT_SUCCESS( NtStatus ) )
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: SampUpdateRidObject status 0x%x\n",
                           NtStatus) );
        }

    }

    ASSERT( SampExistsDsTransaction() );

    SampClearErrors();

    return  NtStatus;
}

NTSTATUS
SampReadRidObjectInfo(
    IN PDSNAME RidObj,
    OUT PRIDINFO RidInfo
    )

/*++

Routine Description:

    This routine reads the RID Object data from the DS backing store, re-
    turning it in the format of the RIDINFO structure. This routine obtains
    the allocated RID pool, the previously allocated RID pool, the used RID
    pool, and the next RID that can be assigned to an account. Each DC (DSA)
    has a distinct RID Object, which stores this information about the RIDs
    owned by the DC.

Arguments:

    RidMgrRef - Pointer, RDN DS name of the RID Manager Reference object.

    RidInfo - Pointer, returned data containing the DN of the RID Manager.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

    STATUS_NO_MEMORY if the returned buffers could not be allocated.

    Other DS error codes that have been mapped to an NTSTATUS can be returned
    from this routine.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampReadRidObjectInfo");

    ASSERT( SampExistsDsTransaction() );

    if ((NULL != RidObj) && (NULL != RidInfo))
    {
        NTSTATUS NtStatusTemp = STATUS_SUCCESS;
        READARG ReadArg;
        READRES *ReadResult = NULL;
        ENTINFSEL EISelection; // Entry Information Selection
        ATTRBLOCK ReadAttrBlock;
        COMMARG *CommArg;
        ULONG RetCode = 0;
        ULONG Index = 0;
        ATTR *Attr = NULL;

        RtlZeroMemory(&ReadArg, sizeof(READARG));
        RtlZeroMemory(&EISelection, sizeof(ENTINFSEL));
        RtlZeroMemory(&ReadAttrBlock, sizeof(ATTRBLOCK));

        Attr = (ATTR *)DSAlloc(sizeof(ATTR) * SAMP_RID_ATTR_MAX);

        if (NULL == Attr)
        {
            return(STATUS_NO_MEMORY);
        }

        RtlZeroMemory(Attr, sizeof(ATTR) * SAMP_RID_ATTR_MAX);

        if (RID_ALLOCATED_POOL & RidInfo->Flags)
        {
            Attr[Index].attrTyp = ATT_RID_ALLOCATION_POOL;
            Index++;
        }

        if (RID_PREV_ALLOC_POOL & RidInfo->Flags)
        {
            Attr[Index].attrTyp = ATT_RID_PREVIOUS_ALLOCATION_POOL;
            Index++;
        }

        if (RID_USED_POOL & RidInfo->Flags)
        {
            Attr[Index].attrTyp = ATT_RID_USED_POOL;
            Index++;
        }

        if (RID_NEXT_RID & RidInfo->Flags)
        {
            Attr[Index].attrTyp = ATT_RID_NEXT_RID;
            Index++;
        }

        ReadAttrBlock.attrCount = Index;
        ReadAttrBlock.pAttr = Attr;

        EISelection.AttrTypBlock = ReadAttrBlock;
        EISelection.attSel = EN_ATTSET_LIST;
        EISelection.infoTypes = EN_INFOTYPES_TYPES_VALS;

        ReadArg.pSel = &EISelection;
        ReadArg.pObject = RidObj;
        CommArg = &(ReadArg.CommArg);
        BuildStdCommArg(CommArg);

        RetCode = DirRead(&ReadArg, &ReadResult);

        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: DirRead (RidObject) retcode = 0x%lx\n",
                       RetCode));

        if (NULL==ReadResult)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            NtStatus = SampMapDsErrorToNTStatus(RetCode,&ReadResult->CommRes);
        }


        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampExtractReadResults(RidObjectType,
                                              ReadResult,
                                              RidInfo);

            // BUG: Need a routine to free the memory inside RidInfo.
        }
        else
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: DirRead (RidObject) status = 0x%lx\n",
                           NtStatus));

        }

        THFree(Attr);

        if (!NT_SUCCESS(NtStatus))
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: SampExtractReadResults status = 0x%lx\n",
                           NtStatus));
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    ASSERT( SampExistsDsTransaction() );
    SampClearErrors();

    return(NtStatus);
}


//============================================================================
//
//          Invalidating an existing RID pool to throw away the current
//          RID range allocated
//              - can be called only at startup before
//                  SampDomainRidInitialization()
//              - this invalidation is authoritative i.e. we will force it to
//                  win against any other version in the enterprise
//
//============================================================================

NTSTATUS
SampInvalidateRidRange(BOOLEAN fAuthoritative)
{
    NTSTATUS NtStatus, TempNtStatus;


    PDSNAME pDSNameRidObject = NULL;
    RIDINFO RidObjectInfo;
    RIDFLAG Flags;
    PVOID   pTHSSave = NULL;


    SAMTRACE("SampInvalidateRidRange");

    __try
    {
        // save the thread state
        pTHSSave = THSave();

        //
        // This assert is really just a place holder to understand who
        // is calling us.  This routine closes the transaction, so
        // caller's so not be expecting to get have a transaction
        // when leaving this function.
        //
        ASSERT( !SampExistsDsTransaction() );

        NtStatus = SampMaybeBeginDsTransaction(TransactionWrite);
        if (!NT_SUCCESS(NtStatus))
        {
            __leave;
        }

        RtlZeroMemory(&RidObjectInfo, sizeof(RIDINFO));
        Flags = (   RID_ALLOCATED_POOL
                    | RID_PREV_ALLOC_POOL
                    | RID_USED_POOL
                    | RID_NEXT_RID);

        SampSetRidFlags(&RidObjectInfo, Flags);

        // First try to read all the RID info to sanity check that all required
        // fields of the RID range info exist
        // Note: This read doesn't serve any useful purpose except to make sure that
        // all fields expected on the RID object really exist.
        NtStatus = SampObtainRidInfo(NULL,&pDSNameRidObject, &RidObjectInfo);
        if (!NT_SUCCESS(NtStatus))
        {
            // Failed to read the RID object
            SampDiagPrint(RID_MANAGER,
                ("SAMSS: SampReadRidObjectInfo status = 0x%lx\n",
                NtStatus));

            __leave;
        }

        // Invalidate the RID range by resetting the ranges and next rid values to 0
        //SampSetRidPoolAllocated(&RidObjectInfo, 0, 0);
        SampSetRidPoolPrevAlloc(&RidObjectInfo, 0, 0);
        SampSetRidPoolUsed(&RidObjectInfo, 0, 0);
        SampSetRid(&RidObjectInfo, 0);
        SampSetRidFlags(&RidObjectInfo, Flags);

        NtStatus = SampUpdateRidObject(pDSNameRidObject, &RidObjectInfo, FALSE, fAuthoritative);
        if (!NT_SUCCESS(NtStatus))
        {
            SampDiagPrint(RID_MANAGER,
                ("SAMSS: SampUpdateRidObject status = 0x%lx\n",
                NtStatus));

            __leave;
        }
    }
    __finally
    {


        TempNtStatus = SampMaybeEndDsTransaction( NT_SUCCESS(NtStatus) ?
                                     TransactionCommit : TransactionAbort );

        if ( !NT_SUCCESS( TempNtStatus ) )
        {
            SampDiagPrint(RID_MANAGER,
                ("SAMSS: SampMaybeEndDsTransaction status = 0x%lx\n",
                TempNtStatus));
        }


        // restore the original thread state if appropriate
        if (pTHSSave)
        {
            THRestore(pTHSSave);
        }



    }

    return (NtStatus);
}


//============================================================================
//
//                           Rid Request/Allocation
//
//============================================================================


VOID
SampComputeRidThreshold(
    IN ULONG MinimumAllocatedRid,
    IN ULONG MaximumAllocatedRid,
    OUT PULONG RidThreshold
    )

/*++

Routine Description:

    This routine calculates the RID threshold value, which is used to deter-
    mine whether or not to request another RID pool. If the value of NextRid
    is greater than RidThreshold, then typically, a new pool is allocated.

    Whenever a DC (DSA) creates a new account, a RID is assigned to that ac-
    count. Each DC has a finite pool of RIDs allocated to it at any point in
    time.

    As RIDs are assigned, the allocation pool shrinks and eventually reaches
    a threshold. Upon reaching the threshold, the DC submits a request to the
    RID Manager for another RID pool.

    If the allocation is made, the current RID pool is saved in the previous
    RID pool attribute and the new RID pool is saved in the current pool. This
    way, the remaining RIDs (between the threshold and the end of the pool)
    can still be used for assignment, rather than throwing them away. When
    the previous RID pool is completely exhausted, the next RID comes from the
    current RID pool.

    // BUG: Change RID threshold calculation to a "RID consumption rate".

Arguments:

    MinimumAllocatedRid - The minimum RID that this DC has allocated to it.                                                                            
                                                                           
    MaximumAllocatedRid - The maximum RID that this DC has allocated to it.

    RidThreshold - Pointer, returned RID value that is the threshold RID.

Return Value:

    None.

--*/

{
    SAMTRACE("SampComputeRidThreshold");

    ASSERT(NULL != RidThreshold);

    // The MaximumAllocatedRid is the largest RID currently allocated to
    // the DC. This value should always be greater than the starting RID
    // in a domain, and no greater than the domain's maximum RID. It also
    // must be greater than the threshold factor, otherwise an internal
    // error has occurred. The value of SampRidThreshold is defined in
    // ridmgr.h as a static percentage of the overall size of the allocated
    // RID pool. In the future, it may be more accurate to define the
    // threshold in terms of a "RID consumption rate" instead of a static
    // value.

    ASSERT(MaximumAllocatedRid > SampMinimumDomainRid);
    ASSERT(MaximumAllocatedRid <= SampMaximumDomainRid);
    ASSERT(MaximumAllocatedRid > MinimumAllocatedRid);
    
    SampDiagPrint(RID_MANAGER,
                  ("SAMSS: MinimumAllocatedRid = %lu MaximumAllocatedRid = %lu Threshold = %2.2f\n",
                   MinimumAllocatedRid,
                   MaximumAllocatedRid,
                   SampRidThreshold));

    //
    // The threshold at which we will request a new pool is when 
    // SampRidThreshold % of the current allocation pool is exhausted.
    //                
    
    *RidThreshold = (ULONG)(MinimumAllocatedRid + 
                     ((DOUBLE)(MaximumAllocatedRid - MinimumAllocatedRid) *
                     SampRidThreshold));
        
    SampDiagPrint(RID_MANAGER,
                  ("SAMSS: RidThreshold = %2.2f\n", *RidThreshold));

    // The computed RID threshold should always be less than the maximum
    // RID in the DC's current RID pool and larger than the domain's small-
    // est RID.

    ASSERT(*RidThreshold > SampMinimumDomainRid);
    ASSERT(*RidThreshold >= MinimumAllocatedRid);
    ASSERT(*RidThreshold <= MaximumAllocatedRid);

    return;
}



NTSTATUS
SampFindRidManager(
    OUT PDSNAME *RidManager
    )

/*++

Routine Description:

    This routine returns the DSNAME of the RID Manager object, as set in
    the RID Manager Reference attribute of the DS Domain object.

Arguments:

    RidManager - Pointer to the DN of the returned RID Manager.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    RIDFLAG Flags = RID_REFERENCE;
    PDSNAME Parent = NULL;
    ULONG DsNameLength = 0;
    RIDINFO RidInfo;

    SAMTRACE("SampFindRidManager");

    if ((NULL != RidManager) && (fNullUuid(&CachedRidManagerObject.Guid)))
    {

        DsNameLength = 0;
        NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                        &DsNameLength,
                                        Parent);

        ASSERT(STATUS_BUFFER_TOO_SMALL == NtStatus);
        if (STATUS_BUFFER_TOO_SMALL == NtStatus)
        {
            SAMP_ALLOCA(Parent,DsNameLength );
            if (NULL==Parent)
            {
                return(STATUS_INSUFFICIENT_RESOURCES);
            }

            NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                            &DsNameLength,
                                            Parent);
        }

        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: RID Manager Reference = %ws\n",
                       Parent->StringName));


        RtlZeroMemory(&RidInfo, sizeof(RIDINFO));
        SampSetRidFlags(&RidInfo, Flags);

        NtStatus = SampReadRidManagerReferenceInfo(Parent, &RidInfo);

        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: RID Manager = %ws\n",
                       RidInfo.RidManagerReference->StringName));

        if (NT_SUCCESS(NtStatus))
        {
            // Just set the outbound name pointer to the returned buffer,
            // which was allocated by SampReadRidManagerReferenceInfo. The
            // caller must release the buffer.

            *RidManager = RidInfo.RidManagerReference;

        }
        else
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: SampReadRidManagerReferenceInfo status = 0x%lx\n",
                           NtStatus));
        }

    }
    else if (NULL!=RidManager)
    {

        //
        // Give back the cached Rid manager object, so that time is saved
        //

        *RidManager = &CachedRidManagerObject;
    }
    else
    {
        return(STATUS_INVALID_PARAMETER);
    }

    return(NtStatus);
}





NTSTATUS
SamIFloatingSingleMasterOpEx(
    IN  PDSNAME  RidManager,
    IN  PDSNAME  TargetDsa,
    IN  ULONG    OpCode,
    IN  ULARGE_INTEGER *ClientAllocPool,
    OUT PDSNAME **ObjectArray OPTIONAL
    )

/*++

Routine Description:

    This routine is the worker routine for RID-pool allocations. This function
    assumes the DC that is running this function is the RID FSMO owner.

    This entire routine is done in one ds transaction.

    Steps are as follows:

    Find the computer object for the target dsa
    If no rid object exists for it, create one
    Get a pool of rid's from the rid manager object
    Assign that pool of rids to the rid object
    Return the rid object

Arguments:

    TargetDsa - Pointer to the DN of the RID Manager.

    OpCode - FSMO operation requested.

    ClientAllocVersion - the version of the client's AllocPool attribute

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus = STATUS_SUCCESS;

    RIDFLAG Flags = 0;
    RIDINFO RidInfo;

    PDSNAME ComputerObject = NULL;
    PDSNAME RidObject      = NULL;
    PDSNAME LocalDsaObject = NULL;

    ULONG MaxRidAvail = 0;
    ULONG MinRidAvail = 0;

    ULONG MaxRidAlloc = 0;
    ULONG MinRidAlloc = 0;
    ULONG MaxRidPrev = 0;
    ULONG MinRidPrev = 0;
    ULONG NextRid = 0;

    ULONG MinRidTemp = 0;

    BOOLEAN fCreateRidObject = FALSE;
    BOOLEAN fLockHeld = FALSE;
    BOOLEAN fKeepThreadState = FALSE;

    SAMP_DS_TRANSACTION_CONTROL CommitType = TransactionCommit;
    SAMP_DS_TRANSACTION_CONTROL AbortType = TransactionAbort;

    ULONG Length = 0;

    SAMTRACE("SamIFloatingSingleMasterOpEx");


    SampDiagPrint(RID_MANAGER,
                  ("SAMSS: Servicing Rid Request from %ls\n",
                   TargetDsa->StringName));

    //
    // Parameter check
    //
    ASSERT( RidManager );
    ASSERT( TargetDsa );

    //
    // Retrieve a local variable
    //
    Length = 0;
    LocalDsaObject = NULL;
    NtStatus = GetConfigurationName(DSCONFIGNAME_DSA,
                                    &Length,
                                    LocalDsaObject);
    if ( NtStatus == STATUS_BUFFER_TOO_SMALL )
    {
        SAMP_ALLOCA(LocalDsaObject,Length);
        if (NULL==LocalDsaObject)
        {
           return(STATUS_INSUFFICIENT_RESOURCES);
        }

        NtStatus = GetConfigurationName(DSCONFIGNAME_DSA,
                                        &Length,
                                        LocalDsaObject);
    }
    if ( !NT_SUCCESS( NtStatus ) )
    {
        return NtStatus;
    }

    //
    // Determine if we need to keep our thread state
    //
    if ( THQuery() )
    {
        fKeepThreadState = TRUE;
        CommitType = TransactionCommitAndKeepThreadState;
        AbortType = TransactionAbortAndKeepThreadState;
    }

    //
    // We should not be called in a transaction, nor should the ds
    // have a write lock on SAM
    //
    ASSERT( !SampExistsDsTransaction() );
    ASSERT( !SampIsWriteLockHeldByDs() );


    //
    // If this is the local dsa calling wait for write access to the
    // rid object, so write conflicts can be avioded.
    //
    if ( NameMatched( LocalDsaObject, TargetDsa ) )
    {
        SampAcquireSamLockExclusive();
        fLockHeld = TRUE;
    }

    //
    // Many servers maybe calling in to get rid pools.  To avoid write
    // conflicts on the rid manager object, guard writes with a critical section
    //
    RtlEnterCriticalSection( RidMgrCritSect );

    //
    // Start a write transaction
    //
    NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );
    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }

    //
    // Read first object we'll need:
    // the target's computer object
    //
    Flags = RID_ALLOCATED_POOL | RID_PREV_ALLOC_POOL | RID_NEXT_RID ;
    RtlZeroMemory(&RidInfo, sizeof(RIDINFO));
    SampSetRidFlags(&RidInfo, Flags);

    NtStatus = SampFindComputerObject( TargetDsa, &ComputerObject );
    if ( NT_SUCCESS( NtStatus ) )
    {
        //
        // Ok, now try and find the rid object
        //
        NtStatus = SampFindRidObjectEx( ComputerObject, &RidObject);
        if ( NT_SUCCESS( NtStatus ) )
        {
            //
            // Ok, now try to read it
            //
            NtStatus = SampReadRidObjectInfo( RidObject, &RidInfo );
            if ( NtStatus == STATUS_OBJECT_NAME_NOT_FOUND )
            {
                //
                // This is acceptable when then rid set object has
                // been deleted since the reference will still point
                // to the deleted object. The RID on the deleted RID
                // Set are lost, RID reclamation is a very difficult 
                // problem to solve in view of security considerations
                // that a SID can never be reused
                //

                fCreateRidObject = TRUE;
                NtStatus = STATUS_SUCCESS;
            }

        }
        else if ( NtStatus == STATUS_DS_NO_ATTRIBUTE_OR_VALUE )
        {
            fCreateRidObject = TRUE;
            NtStatus = STATUS_SUCCESS;
        }
    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }

    if ( fCreateRidObject )
    {
        ULONG   DsNameSize = 0;

        DsNameSize = (ULONG)DSNameSizeFromLen( ComputerObject->NameLen +  
                                               wcslen(RID_SET_W) + 
                                               4 ); 

        RidObject = THAlloc( DsNameSize );

        if ( !RidObject )
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RtlZeroMemory( RidObject, DsNameSize );

        AppendRDN(ComputerObject,
                  RidObject,
                  DsNameSize,
                  RID_SET_W,
                  0,
                  ATT_COMMON_NAME);

        // Create the RID object with DN NewRidObject and update the
        // associated attributes on ComputerObject.

        NtStatus = SampCreateRidObject( ComputerObject, RidObject );

        if ( NT_SUCCESS( NtStatus )
          || (NtStatus == STATUS_USER_EXISTS)
          || (NtStatus == STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS) )
        {
            NtStatus = SampReadRidObjectInfo( RidObject, &RidInfo );
        }
    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }

    ASSERT( ComputerObject );
    ASSERT( RidObject );

    //
    // Put the values in convienent variables
    //

    SampGetRidPoolAllocated(&RidInfo, &MaxRidAlloc, &MinRidAlloc);
    SampGetRidPoolPrevAlloc(&RidInfo, &MaxRidPrev, &MinRidPrev);
    SampGetRid(&RidInfo, &NextRid);

    ASSERT( NextRid <= MaxRidPrev );
    ASSERT( NextRid >= MinRidPrev );

    //
    // First determine if we need to really to allocate a pool or not
    //
    if (  ClientAllocPool != 0
       && ClientAllocPool->HighPart != 0
       && ClientAllocPool->HighPart < MaxRidAlloc ) {

        //
        // The client has allocated rid pool that is less the version
        // that we, the rid master, already has.  So to satisfy this client,
        // all we need to do is return the version we have locally on this
        // DS
        //
        NtStatus = STATUS_SUCCESS;
        goto Cleanup;

    }

    //
    // Now we have the information about the target's dsa's current rid pool
    // "carve of a rid pool"
    //
    Flags = RID_AVAILABLE_POOL|RID_ROLE_OWNER;
    RtlZeroMemory(&RidInfo, sizeof(RIDINFO));
    SampSetRidFlags(&RidInfo, Flags);

    NtStatus = SampReadRidManagerInfoEx(RidManager, &RidInfo);

    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }

    //
    // Make sure we are the role owner
    //
    if ( !NameMatched( RidInfo.RoleOwner, LocalDsaObject ) )
    {
        NtStatus = STATUS_INVALID_OWNER;
        goto Cleanup;
    }

    SampGetRidPoolAvailable(&RidInfo, &MaxRidAvail, &MinRidAvail);

    SampDiagPrint(RID_MANAGER,
                  ("SAMSS: Available RID Range = %lu - %lu\n",
                   MinRidAvail,
                   MaxRidAvail));

    // Save the minimum available RID in a temporary and increment
    // the minimum available RID by the block size. Increasing the
    // minimum available RID is how the pool of available RIDs is
    // reduced during allocation.

    MinRidTemp = MinRidAvail;
    MinRidAvail += SampRidBlockSize;

    if (MinRidAvail > MaxRidAvail)
    {
        // If the (new) minimum is greater than the maximum RID, set
        // the minimum available RID to the maximum available RID,
        // indicating that the domain's RID pool has been consumed.
        // Use the last (partial) RID pool available to the DC rather
        // than throwing it away.

        MinRidAvail = MaxRidAvail;
    }

    SampDiagPrint(RID_MANAGER,
                  ("SAMSS: Available RID Range = %lu - %lu\n",
                   MinRidAvail,
                   MaxRidAvail));

    ASSERT(MinRidAvail <= MaxRidAvail);

    if (MinRidAvail <= MaxRidAvail)
    {
        Flags = RID_AVAILABLE_POOL;

        SampSetRidFlags( &RidInfo, Flags );
        SampSetRidPoolAvailable(&RidInfo, MaxRidAvail, MinRidAvail);

        // Update the RID Manager with the new range of available
        // RIDs, reflecting the allocation. The available RID pool
        // has now been reduced in size. The next step is to give
        // this pool to the requesting DC (below).

        NtStatus = SampUpdateRidManager(RidManager, &RidInfo);

        if (!NT_SUCCESS(NtStatus))
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: SampUpdateRidManager status = 0x%lx\n",
                           NtStatus));
        }
    }
    else
    {
        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: All RIDs have been used for this domain\n"));

        NtStatus = STATUS_NO_MORE_RIDS;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    // The RID Manager's available RID pool has been reduced, make the
    // allocation to the requesting DC.

    MinRidAlloc = MinRidTemp;

    // If the minimum available RID equals the maximum available
    // RID, there is one remaining RID available in the domain,
    // namely the domain's maximum RID. If this is the case, then
    // set the maximum allocated RID to the minimum available
    // RID; otherwise set it to one less than the minimum avail-
    // able RID (the non-boundary case) to avoid overlapping RID
    // ranges across allocations.

    (MinRidAvail == MaxRidAvail) ?
        (MaxRidAlloc = MinRidAvail) :
        (MaxRidAlloc = (MinRidAvail - 1));

    SampDiagPrint(RID_MANAGER,
                  ("SAMSS: MinRidPrev = %lu MaxRidPrev = %lu\n",
                   MinRidPrev,
                   MaxRidPrev));

    SampDiagPrint(RID_MANAGER,
                  ("SAMSS: MinRidAlloc = %lu MaxRidAlloc = %lu\n",
                   MinRidAlloc,
                   MaxRidAlloc));

    ASSERT((MinRidPrev <= MaxRidPrev) &&
       (MaxRidPrev <= MinRidAlloc) &&
       (MinRidAlloc <= MaxRidAlloc));

    Flags = RID_ALLOCATED_POOL;
    SampSetRidFlags( &RidInfo, Flags );
    SampSetRidPoolAllocated(&RidInfo, MaxRidAlloc, MinRidAlloc);

    NtStatus = SampUpdateRidObject(RidObject, &RidInfo, FALSE, FALSE);

    if (!NT_SUCCESS(NtStatus))
    {
        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: SampUpdateRidObject status = 0x%lx\n",
                       NtStatus));
        goto Cleanup;
    }

    //
    // That's it - fall through to cleanup
    //

Cleanup:

    ASSERT( SampExistsDsTransaction() );

    if ( NT_SUCCESS( NtStatus ) )
    {
        NtStatus = SampMaybeEndDsTransaction( CommitType );
    }
    else
    {
        // We need to keep our thread state
        IgnoreStatus = SampMaybeEndDsTransaction( AbortType );
    }

    if ( fKeepThreadState )
    {
        ASSERT( THQuery() );

        //
        // Lose our SAM status
        //
        SampSetSam( FALSE );
    }

    //
    // We have commited our changes, so we can release our critical sections
    //
    RtlLeaveCriticalSection( RidMgrCritSect );

    if ( fLockHeld )
    {
        SampReleaseSamLockExclusive();
    }


    //
    // Set the out parameter
    //
    if ( NT_SUCCESS( NtStatus ) )
    {
        if ( ObjectArray )
        {
            // We pass back the value using heap memory so there should
            // be a thread state
            ASSERT( THQuery() );

            //
            // The rid manager object gets automatically returned -
            // we need to return the rid object and computer object
            // since the computer object's reference to the rid object
            // may have been updated.
            //
            *ObjectArray = (PDSNAME*) THAlloc( 3 * sizeof(PDSNAME) );
            if ( *ObjectArray )
            {
                RtlZeroMemory( *ObjectArray, 3 * sizeof(PDSNAME) );
                (*ObjectArray)[0] = RidObject;
                (*ObjectArray)[1] = ComputerObject;
            }
            else
            {
                NtStatus = STATUS_NO_MEMORY;
            }
        }
    }

    SampDiagPrint(RID_MANAGER,
                  ("SAMSS: Servicing Rid Request from %ls finished with 0x%x\n",
                   TargetDsa->StringName, NtStatus));

    return( NtStatus );
}


NTSTATUS
SampRequestRidPool(
    IN PDSNAME RidManager,
    IN BOOLEAN VerboseLogging
    )

/*++

Routine Description:

    This routine calls the Floating Single Master Operation (a.k.a FSMO) to
    request a new RID pool from the role owner (the current RID Manager). It
    is assumed that this routine is asynchronous, hence, can return before
    the new RID pool has actually been allocated to the requesting DC.

    The requesting DC finds out that it has been granted a new RID pool by
    reading the allocated RID pool attribute. This is typically done in the
    normal course of RID allocation or assignment. There is no notification
    event generated to alert the requesting DC that the RID pool has been
    allocated.

Arguments:

    RidManager - Pointer to the DN of the current RID Manager.

    VerboseLogging - if TRUE, log all events

    RetryMaximum - Maximum number of times the RID request will be attempted.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

--*/

{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG  OpCode = SAMP_REQUEST_RID_POOL;
    OPARG  OpArg;
    OPRES  *OpResult = NULL;
    OpType Operation;
    USHORT RetryCount = 0;
    USHORT EventType = 0;
    RIDINFO RidInfo;
    DWORD WinError = ERROR_SUCCESS;
    ULONG  WaitTime = SAMP_RID_DEFAULT_RETRY_INTERVAL; // Our default is 30 seconds before we try a new request
    ULONG Status = 0;
    RIDFLAG Flags = (RID_ALLOCATED_POOL |
                         RID_PREV_ALLOC_POOL |
                         RID_NEXT_RID);
    PDSNAME RidObject;

   

    SAMTRACE("SampRequestRidPool");

    //
    // Parameter check
    //
    ASSERT( RidManager );

    //
    // This function has been written to control its own transactioning
    //
    ASSERT( !SampExistsDsTransaction() );

    //
    // We are going of the machine! By no means should the write lock be held
    //
    ASSERT( !SampIsWriteLockHeldByDs() );

    //
    // The thread that started this request should have already set the
    // guard to TRUE.
    //
    ASSERT( SampDcRidRequestPending == TRUE );


    RtlZeroMemory(&RidInfo, sizeof(RIDINFO));
    SampSetRidFlags(&RidInfo, Flags);



    do
    {
        // This is the retry loop for acquiring the RID FSMO owner
        // role. This loop will repeat for RetryMaximum times. Note
        // that while waiting (sleep) between retries, the thread
        // state is destroyed so as to reduce resource consumption
        // while blocked.

        //
        // Reset the error code displayed to the user
        //

        WinError = ERROR_SUCCESS;

        //
        // If verbose logging is enabled then log an event saying that we are about
        // to acquire a RID pool.
        //

        if ( VerboseLogging ) {

            SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                              0,
                              SAMMSG_REQUESTING_NEW_RID_POOL,
                              NULL,
                              0,
                              0,
                              NULL,
                              NULL);
        }


        //
        // Create a thread state, if thread state creation fails,
        // set the error code to not enough memory and break out
        // of the loop
        //
        
        Status = THCreate( CALLERTYPE_SAM );

        
        if (Status)
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        SampSetDsa(TRUE);

        //
        // Request a RID pool from the FSMO role owner
        //
        
        RtlZeroMemory(&OpArg, sizeof(OPARG));
        OpArg.eOp = OP_CTRL_RID_ALLOC;

        Status = DirOperationControl(&OpArg, &OpResult);

        // If either the status or the extended-error indicates a
        // failure of any kind, continue retrying the operation until
        // the maximum retry limit is reached.

        if ( NULL == OpResult ) {

            // Indicate what the problem was
            WinError = ERROR_NOT_ENOUGH_MEMORY;

            // get out of this loop
            break;

        }
        else if (Status)
        {

            //
            // Dir Operation control failed due to one reason or other
            //

            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: FSMO DirOperationControl status = %lu\n",
                           Status));


            //
            // Some error was hit -- try to get the most accurate win32 error
            // to describe the failure
            //
            switch ( OpResult->ulExtendedRet ) {
                case EXOP_ERR_SUCCESS:

                    //
                    // Actually EXOP_ERR_SUCCESS can come back if the operation
                    // failed locally as part of a commit etc but not in the remote
                    // DC. In that case if we have retried more than SAMP_RID_LOCAL_UPDATE_RETRY_CUTOFF
                    // times then backoff to 30 min RID pool request intervals
                    //

                    if (RetryCount>SAMP_RID_LOCAL_UPDATE_RETRY_CUTOFF)
                    {
                        // WaitTime is in milliseconds

                        WaitTime = SAMP_RID_LOCAL_UPDATER_ERROR_RETRY_INTERVAL;
                    }

                    //
                    // Fall through the Default path, which translates to DirError returned
                    //

                case EXOP_ERR_COULDNT_CONTACT:
                    WinError = ERROR_DS_COULDNT_CONTACT_FSMO;
                    break;
                case EXOP_ERR_UPDATE_ERR:
                    WinError  = ERROR_DS_BUSY;
                    break;
                case EXOP_ERR_FSMO_OWNER_DELETED:
                    WinError = ERROR_DS_MISSING_FSMO_SETTINGS;
                    break;
                case EXOP_ERR_FSMO_REFUSING_ROLES:
                    WinError = ERROR_DS_REFUSING_FSMO_ROLES;
                    break;
                case EXOP_ERR_FSMO_MISSING_SETTINGS:
                    WinError = ERROR_DS_MISSING_FSMO_SETTINGS;
                    break;
                case EXOP_ERR_DIR_ERROR:
                    WinError = ERROR_DS_DATABASE_ERROR;
                    break;
                case EXOP_ERR_ACCESS_DENIED:
                    WinError = ERROR_DS_DRA_ACCESS_DENIED;
                    break;
                default:
                    //
                    // This covers
                    //
                    //  EXOP_ERR_UNKNOWN_OP
                    //  EXOP_ERR_FSMO_NOT_OWNER
                    //  EXOP_ERR_EXCEPTION
                    //  EXOP_ERR_UNKNOWN_CALLER
                    //  EXOP_ERR_RID_ALLOC
                    //  EXOP_ERR_FSMO_PENDING_OP
                    //  EXOP_ERR_MISMATCH
                    //
                    WinError = DirErrorToWinError( Status, &OpResult->CommRes);
                    break;
            }

            //
            // An error of some kind has occurred which is either a 
            // connectivity failure of some sort, or a failure to update
            // the pool locally. Wait for specified wait time and then
            // retry the operation
            //

            //
            // If this is the first time this error has occured then write
            // out an event log indicating the error
            //

            if (0==RetryCount)
            {
                SampWriteEventLogWithError(
                              EVENTLOG_ERROR_TYPE,
                              SAMMSG_RID_REQUEST_STATUS_FAILURE,
                              WinError);
            }

            //
            // Release resources before waiting.

            THDestroy();

            //
            // Wait for either shut down to occur or for the system to
            // for time out period, which is 30 seconds.
            //

            WaitForSingleObject(SampAboutToShutdownEventHandle,WaitTime);

            //
            // Reset the wait time back to  the default of 30 seconds.
            // if we waited because of a database error for 30 minutes
            // and subsequently failed due to a network error, then we should
            // retry again in 30 seconds and not after 30 mins.
            //

            WaitTime = SAMP_RID_DEFAULT_RETRY_INTERVAL;
        }

        RetryCount++;

        //
        // Log a successful RID pool acquire message
        // if either verbose logging is enabled, or 
        // if we previously failed to acquire a RID pool
        //

        if (( ERROR_SUCCESS == WinError ) &&
           ( (VerboseLogging ) || (RetryCount>1)))
        {

            SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                              0,
                              SAMMSG_RID_REQUEST_STATUS_SUCCESS,
                              NULL,
                              0,
                              sizeof(WinError),
                              NULL,
                              &WinError);

     
        }

    } while ((ERROR_SUCCESS!=WinError) && 
             (SampServiceState==SampServiceEnabled));

    //
    // Check if we successfully allocated a RID pool
    //

    if (WinError!=ERROR_SUCCESS)
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

   //
   // the AllocatedPool has already been
   // updated with a new pool.  All we need to do, is catch
   // the boundary case where next rid is 0 and update ourselves
   // This case can happen when the initial rid pool is acquired
   // and when the rid pool is invalidated
   //
           

    NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );
    if ( NT_SUCCESS( NtStatus ) )
    {
        NtStatus = SampObtainRidInfo( NULL,
                                      &RidObject,
                                      &RidInfo );
    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }

    SampDumpRidInfo(&RidInfo);

    NtStatus = SampInitNextRid( RidObject,
                                &RidInfo );

        

Cleanup:

    if ( SampExistsDsTransaction() )
    {
        SampMaybeEndDsTransaction( NT_SUCCESS( NtStatus ) ? TransactionCommit :
                                   TransactionAbort );

    }

   
    //
    // If we succeeded in getting a Rid Pool then turn back on our
    // writable flag
    //


    if (NT_SUCCESS(NtStatus))
    {

        I_NetLogonSetServiceBits(DS_DS_FLAG,DS_DS_FLAG);

    }

    //
    // Whether in success or failure, the rid request is over
    //

    SampDcRidRequestPending = FALSE;

    //
    // Make sure we left our state as we came in
    //
    ASSERT( !SampExistsDsTransaction() );
    ASSERT( !SampIsWriteLockHeldByDs() );

    return(NtStatus);
}


NTSTATUS
SampAsynchronousRidPoolRequest(
    LPVOID Parameter
    )

/*++

Routine Description:

    This routine is called whenever a RID pool is needed "out of band",
    meaning that the request for a RID pool is done in a new thread so
    that the primary thread of the caller can continue on.

Arguments:

    Parameter - Pointer, request information, contains the DS name of the
        RID Manager object, flag indicating whether or not FSMO role owner-
        ship is being requested, and the maximum number of retries to con-
        tact the current FSMO role owner.

Return Value:

    STATUS_SUCCESS if the RID pool was acquired, otherwise an error code.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDSNAME RidManager = (PDSNAME)Parameter;


    //
    // Increment the Active Thread Count, so that shutdown will
    // wait for this thread
    //

    SampIncrementActiveThreads();

    NtStatus = SampRequestRidPool(
                    RidManager,
                     FALSE
                     );

    if (NT_SUCCESS(NtStatus))
    {
        // Since this routine is called during first-time DC boot, be sure
        // to set SampRidManagerInitialized after successfull acquisition of
        // a RID pool. Note that this flag is set whenever this routine re-
        // turns successfully, and is benign to do so if the flag was set
        // previously.

        SampRidManagerInitialized = TRUE;
    }

    RtlFreeHeap(RtlProcessHeap(), 0, Parameter);

    SampDecrementActiveThreads();

    return(NtStatus);
}


NTSTATUS
SampRequestRidPoolAsynchronously(
    IN DSNAME * RidManager
    )
/*++

    This routine does the work of requesting a Rid pool in a
    background thread. That is it creates the thread that would
    go and request a RID pool


    Parameters

        RidManager -- The RId manager object, needed for passing into the
        Rid pool request routine

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    ThreadID;
    PVOID    Parameter;
    HANDLE   ThreadHandle;


    Parameter = RtlAllocateHeap(RtlProcessHeap(),
                                        0,
                                        RidManager->structLen);

    if (NULL == Parameter)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto ErrorCase;
    }

    RtlCopyMemory(Parameter, RidManager, RidManager->structLen);

    SampDcRidRequestPending = TRUE;

    ThreadHandle = CreateThread(NULL,//Attributes,
                                0,//StackSize,
                                SampAsynchronousRidPoolRequest,
                                Parameter,
                                0,//CreateFlags,
                                &ThreadID);

    if (NULL == ThreadHandle)
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: CreateThread returned NULL handle\n"));

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        SampDcRidRequestPending = FALSE;
        RtlFreeHeap(RtlProcessHeap(),0,Parameter);
        goto ErrorCase;
    }
    else
    {
        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: RID request thread ID = 0x%lx\n",
                       ThreadID));


        CloseHandle(ThreadHandle);
    }

ErrorCase:

    return NtStatus;
}


NTSTATUS
SampGetNextRid(
    IN PSAMP_OBJECT DomainContext,
    OUT PULONG Rid
    )

/*++

Routine Description:

    This routine returns the next available RID from the current allocation
    pool (for this DC). If the RID value is greater than the threshold of the
    current allocation pool (i.e. there are only a limited number of RIDs
    left in the current pool), then a request for more RIDs is generated.
    Requests for new RID pools is accomplished via the FSMO (Floating Single
    Master Operation) mechanism in the DS.

    Because allocated RID pools are disjoint from one another, there will be
    effective "gaps" in the RID space for any single DC. This routine will
    "step over" gaps in the RID space, always returning the next RID that
    can be assigned to a new account.

    The RID value is incremented with each account creation. This value is
    cached in memory, but also written to the registry for persistence a-
    cross reboots. Writing to the registry is much cheaper than writing to
    the DS each time the RID is incremented. The RID cache is a finite size
    and is decremented with each increment to the RID value. When the cache
    size reaches zero, the value of the current RID is written to the DS.
    The registry is not the primary backing store for the RID value, but is
    just used as a cheaper way to maintain the RID value as it changes, and
    across reboots.

    Multiple threads can call this routine concurrently, as it is protected
    by the SAM Lock

    Note that this routine has been written to avoid assigning RIDs from
    pools that it does not own--seems natural enough, but sometimes diffi-
    cult in real practice due to threading, overlapping transactions, and
    DC crashes. Therefore, after the RID value is incremented, several
    "sanity" checks are performed to catch a bogus RID. In certain cases,
    an error is returned, which will prevent account creation with a bad
    RID. In other cases, this may lead to another attempt to acquire FSMO
    ownership in order to get a new RID pool.

    The routine has also been written so that rebooting a DC which is in
    "RID trouble" will clear the internal state and allow account creation
    to continue.

    This routine is ONLY used in DS case. However there are 2 flavors in DS 
    case. 
    
    1. SAM API (downlevel). The Caller should hold SAM lock already, 
       so within this routine, we will open a new DS transaction (if no
       DS transaction opened yet) and acquire a new RID from DS. 
       
       Note: in this case, we will not commit the DS transaction within
             this routine. Indeed, SAM will either commit or abort the 
             whole account creation operation as a one transaction. So
             that we won't lost a unused RID due to failed operation.  
             We can do it only in downlevel SAM creation case, that is 
             because the SAM / DS database is guarded by SAM lock to 
             serialize all write/read operations. 
             
    2. Loopback case. If it is a loopback client, the caller will not 
       hold SAM lock before calling into this routine. So this routine
       will need to acquire SAM lock, save existing DS transaction,
       then start a new DS transaction. Once retrieving the next RID, 
       we will commit the new DS transaction and restore the old 
       transaction, also release SAM lock. 
       
       This scheme will guanrantee the SAM account RID uniqueness, because
       we always acquire the SAM lock before update the next RID value
       in DS. 
       
       However the side effect of doing that is losing a unused RID if
       the whole account creation failed.             


Arguments:

    Rid - Pointer to the returned Relative ID (RID).

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

    Other DS error codes that have been mapped to an NTSTATUS can be returned
    from this routine.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus = STATUS_SUCCESS;
    RIDINFO  RidInfo;
    RIDFLAG  Flags;
    PDSNAME  RidManager = NULL;
    ULONG    Length = 0;
    BOOLEAN  fRequestNewRidPool = FALSE;
    BOOLEAN  fUpdatePrevPool = FALSE;

    PDSNAME  ComputerObject = NULL;
    PDSNAME  NewRidObject = NULL;

    ULONG    AllocHigh = 0;
    ULONG    AllocLow = 0;
    ULONG    PrevAllocHigh = 0;
    ULONG    PrevAllocLow = 0;
    ULONG    RidThreshold = 0;
    ULONG    NextRidOnDatabase=0;

    BOOLEAN  AlreadyNotifiedUserOfError = FALSE;

    PVOID   *pTHState = NULL;

    SAMTRACE("SampGetNextRid");

    ASSERT( Rid );

    RtlZeroMemory(&RidInfo, sizeof(RIDINFO));

    if (!SampRidManagerInitialized)
    {
        return STATUS_NO_RIDS_ALLOCATED;
    }

    if (DomainContext->LoopbackClient) 
    {
        ASSERT(SampUseDsData && THQuery());
        pTHState = THSave();
        ASSERT( pTHState );

        ASSERT( !SampCurrentThreadOwnsLock() && "Should NOT have SAM lock\n");
        SampAcquireSamLockExclusive();

        if (!NT_SUCCESS(NtStatus)) {
            goto ErrorCase;
        }
    }
    else
    {
        ASSERT( SampCurrentThreadOwnsLock() );
    }


    // Read the RID Object's data to determine the value of the next RID
    // that can be assigned, as well as the allocation pool.

    NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );

    if ( NT_SUCCESS( NtStatus ) )
    {

        Flags = RID_NEXT_RID | RID_ALLOCATED_POOL | RID_PREV_ALLOC_POOL;
        SampSetRidFlags(&RidInfo, Flags);

        NtStatus = SampObtainRidInfo( NULL,
                                      &NewRidObject,
                                      &RidInfo );

    }

    if ( !NT_SUCCESS(NtStatus) )
    {
        goto ErrorCase;
    }

    SampDumpRidInfo(&RidInfo);


    //
    // Put the current values of the various RID pools into local
    // variables for easier access.
    //

    SampGetRidPoolAllocated(&RidInfo, &AllocHigh, &AllocLow);
    SampGetRidPoolPrevAlloc(&RidInfo, &PrevAllocHigh, &PrevAllocLow);
    SampGetRid(&RidInfo, Rid);

    //
    // Increment the RID value by one to dole out the next Rid
    //

    if ((*Rid <= PrevAllocHigh) && (*Rid <= SampMaximumDomainRid))
    {
        (*Rid) += 1;
        NextRidOnDatabase = (*Rid);
    }

    // After incrementing the RID to its next value, perform various
    // checks. If a RID threshold has been reached at least one time,
    // the previous-RID pool may still contain unused RIDs (because
    // the RID threshold is reached before actual exhaustion). So, if
    // there are still some RIDs in the previous pool, continue to
    // use them before starting to use RIDs from the current pool.

    if (*Rid < SampMinimumDomainRid)
    {
        // The RID is less than the legal minimum RID value, which
        // will occur if the very first request for a RID pool has
        // not yet been fulfilled. The RID value has only been init-
        // ialized to zero (as part of first-time initialization),
        // and no RID pools have been allocated to this DC--the DC
        // is not yet ready to create accounts, so return an error
        // code, allowing the caller to retry the operation later if
        // desired.

        ASSERT((*Rid == 1) || (*Rid == 0));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: No RIDs have been assigned\n"));

        NtStatus = STATUS_NO_RIDS_ALLOCATED;

        SampWriteEventLog(EVENTLOG_ERROR_TYPE,
                          0,
                          SAMMSG_NO_RIDS_ASSIGNED,
                          NULL,
                          0,
                          sizeof(NTSTATUS),
                          NULL,
                          (PVOID)(&NtStatus));

        AlreadyNotifiedUserOfError = TRUE;

        //
        // This is the case of having no RID pool
        //

        fRequestNewRidPool = TRUE;
 

        goto RequestNewRidPool;
    }

    if (*Rid > SampMaximumDomainRid)
    {
        // The maximum domain RID was surpassed, so no further
        // accounts can be created in the domain, bail out, and
        // exit from the critical section properly.

        
        NtStatus = STATUS_NO_MORE_RIDS;

        SampWriteEventLog(EVENTLOG_ERROR_TYPE,
                          0,
                          SAMMSG_MAX_DOMAIN_RID,
                          NULL,
                          0,
                          sizeof(NTSTATUS),
                          NULL,
                          (PVOID)(&NtStatus));

        AlreadyNotifiedUserOfError = TRUE;

        goto ErrorCase;
    }

    if ( *Rid > PrevAllocHigh )
    {

        //
        // The maximum RID of the previous pool was surpassed, so
        // continue with the minimum RID of the new pool, hopping
        // over the gap in the RID space.  This is accomplished by
        // copying in the (next) Allocated Rid Pool
        //

        // We should not skip any rids
        ASSERT( *Rid == PrevAllocHigh + 1 );

        if ( PrevAllocHigh != AllocHigh )
        {
            ASSERT( PrevAllocLow != AllocLow );

            // The next pool should be greater than our last pool
            ASSERT( PrevAllocHigh > PrevAllocLow );
            ASSERT( AllocLow > PrevAllocHigh );
            ASSERT( AllocHigh > AllocLow );

            //
            // Start using the new rid pool
            //
            PrevAllocHigh = AllocHigh;
            PrevAllocLow = AllocLow;
            fUpdatePrevPool = TRUE;

            //
            // Go to the bottom of the previous pool again.
            //

            *Rid = PrevAllocLow;
            NextRidOnDatabase = *Rid;

        }
        else
        {
            //
            // We have exhausted this rid pool and a new rid pool
            // does not yet exist
            //
            NtStatus = STATUS_NO_MORE_RIDS;

            SampWriteEventLog(EVENTLOG_ERROR_TYPE,
                              0,
                              SAMMSG_MAX_DC_RID,
                              NULL,
                              0,
                              sizeof(NTSTATUS),
                              NULL,
                              (PVOID)(&NtStatus));

            AlreadyNotifiedUserOfError = TRUE;

            fRequestNewRidPool = TRUE;

            //
            // Tell netlogon to stop advertising this DC as writable
            //

            I_NetLogonSetServiceBits(DS_DS_FLAG,0);


            goto RequestNewRidPool;

        }
    }

    // As a final test, make sure the RID is within a legal range,
    // i.e. either within the previous pool or the current pool. Do
    // this test before computing the RID threshold so as to avoid
    // erroneous calls to acquire a new RID pool.
    //
    // The assert is used to catch a RID that is not within either
    // the previous pool or the current pool. The permanent test,
    // however, excludes a RID that is larger than the currently
    // allocated maximum from the test. Why? This is so that the
    // boundary case of (*Rid == AllocHigh + 1) will fall through
    // allowing retries for RID-pool acquisition below. Without this
    // exception to the rule, a given DC that has exhausted its RID
    // pool AND has not been able to successfully acquire a new RID
    // pool, will get "stuck" at the value AllocHigh + 1, possibly
    // forcing major Administrator intervention.

    ASSERT( (*Rid >= PrevAllocLow) && (*Rid <= PrevAllocHigh) );

    if ( !(*Rid >= PrevAllocLow) && (*Rid <= PrevAllocHigh) )
    {
        WCHAR String[64];
        UNICODE_STRING UnicodeString;
        PUNICODE_STRING EventString[1];

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: RID [%lu] out of valid range\n",
                   *Rid));

        NtStatus = STATUS_INTERNAL_ERROR;

        wsprintf(String, L"%lu", *Rid);
        RtlInitUnicodeString(&UnicodeString, String);
        EventString[0] = &UnicodeString;

        AlreadyNotifiedUserOfError = TRUE;

        SampWriteEventLog(EVENTLOG_ERROR_TYPE,
                          0,
                          SAMMSG_INVALID_RID,
                          NULL,
                          1,
                          sizeof(NTSTATUS),
                          EventString,
                          (PVOID)(&NtStatus));


        goto ErrorCase;
    }



    // Determine if the RID threshold of the allocation pool
    // has been reached. If the threshold has been reached, submit a
    // request for another RID allocation pool.
    SampComputeRidThreshold( AllocLow, AllocHigh, &RidThreshold );
    if ( *Rid > RidThreshold )
    {
        //
        // Request a new pool if the current pool is previous pool.
        // That is, if we don't have a new rid pool.
        //
        ASSERT( PrevAllocHigh == AllocHigh );
        ASSERT( PrevAllocLow == AllocLow );
        if ( PrevAllocHigh == AllocHigh ) {

            fRequestNewRidPool = TRUE;

        }
    }

    // Note that the test needs to be "*Rid > RidThreshold" and not
    // just equality. This way, if the DC has been unsuccessful at
    // acquiring a new RID pool for any reason, retry attempts can
    // occur with subsequent account creation. This holds true across
    // reboot scenarios as well. The flag SampDcRidRequestPending is
    // used to guard against overlapping requests for a new RID pool.

RequestNewRidPool:

    if ( ( TRUE == fRequestNewRidPool )
      && ( FALSE == SampDcRidRequestPending) )
    {
        NTSTATUS TempNtStatus = STATUS_SUCCESS;

        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: RID = %lu, requesting a new RID pool\n",
                      *Rid));

        TempNtStatus = SampFindRidManager(&RidManager);

        if (NT_SUCCESS(TempNtStatus))
        {
            HANDLE ThreadHandle = NULL;
            LPSECURITY_ATTRIBUTES Attributes = NULL;
            DWORD StackSize = 0;
            LPVOID Parameter = NULL;
            DWORD CreateFlags = 0;
            DWORD ThreadID = 0;

            // Submit the request for a new RID pool. The next time
            // the RID pool is read, the values will be updated or
            // not depending on whether or not this request has been
            // processed. Consequently, the RID threshold must be
            // chosen with this asynchonicity in mind. That is, the
            // RID threshold must be large enough to support ongoing
            // account creation during possibly lengthy delays in
            // RID allocation, particularly in the inter-site cases.

            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: Requesting RID pool.\n"));

            // SampRequestRidPool may go off-machine to acquire FSMO
            // role ownership, and this is happening inside a SAM
            // transaction. Consequently, a new thread is spun off to
            // do the work of acquiring the FSMO role ownership so
            // that the calling routine will not be blocked with an
            // open transaction. An error code is returned, however,
            // allowing the caller to handle the account-creation
            // failure appropriately, such as retrying the operation
            // or notifying the administrator.

            ASSERT(NULL != RidManager);

            //
            // Ignore the status returned. Do not assign anything to
            // NtStatus at this point
            //

            TempNtStatus = SampRequestRidPoolAsynchronously(RidManager);

        }
    }

    // Errors that could have occurred at this point are failure
    // while attempting to find the current Role Owner or failure
    // attempting to request a new RID pool. Although these oper-
    // ations are distributed and potentially asynchronous, the
    // error returned from these routines will more likely indicate
    // a local failure (such as out of memory, etc.), in which
    // case, do not update the RID Object.

    if ( NT_SUCCESS(NtStatus)  )
    {
        // Update the next-RID and RID-pool-used attributes. The back-
        // ing store is only updated when the in-memory cache has been
        // exhausted. This is done to reduce the number of updates to
        // the store, so that subsequent replication activity is also
        // reduced.


        Flags = RID_NEXT_RID;

        if ( fUpdatePrevPool )
        {
            Flags |= RID_PREV_ALLOC_POOL;
            SampSetRidPoolPrevAlloc(&RidInfo, PrevAllocHigh, PrevAllocLow);
        }


        SampSetRidFlags(&RidInfo, Flags);

        ASSERT(0!=NextRidOnDatabase);

        SampSetRid(&RidInfo, NextRidOnDatabase);

        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: Updating the RID object:\n"));
        SampDumpRidInfo(&RidInfo);

        // 
        // Let JET commit lazily
        // 
        NtStatus = SampUpdateRidObject(NewRidObject, &RidInfo, TRUE, FALSE);

        if (!NT_SUCCESS(NtStatus))
        {
            SampDiagPrint(RID_MANAGER,
                          ("SAMSS: SampUpdateRidObject status = 0x%lx\n",
                           NtStatus));
        }

    }

    //
    // That's it - fall through
    //

ErrorCase:

    if (DomainContext->LoopbackClient)
    {
        SampMaybeEndDsTransaction(NT_SUCCESS(NtStatus) ? 
                                  TransactionCommit : TransactionAbort);

        SampReleaseSamLockExclusive();

        if (pTHState)
        {
            THRestore( pTHState );
        }

    }
    else
    {
        ASSERT( SampCurrentThreadOwnsLock() );
    }

    //
    // Keep the Transaction Open for further processing by SAM
    //

    if (!NT_SUCCESS(NtStatus) && !AlreadyNotifiedUserOfError )
    {
        SampWriteEventLog(EVENTLOG_ERROR_TYPE,
                          0,
                          SAMMSG_GET_NEXT_RID_ERROR,
                          NULL,
                          0,
                          sizeof(NTSTATUS),
                          NULL,
                          (PVOID)(&NtStatus));
    }



    return(NtStatus);
}


//============================================================================
//
//                 Domain RID Initialization/Uninitialization
//
//============================================================================

// The SAM RID initialization and uninitialzation routines are never called
// concurrently on any given DC, so do not need to be protected by the RID
// critical section. These routines are only called in the context of SAM/LSA
// initialization within a single thread.




DWORD
SampSetupRidRegistryKey(
    IN HKEY KeyHandle,
    IN PCHAR ValueName,
    IN OUT PULONG Rid
    )

/*++

Routine Description:

    This routine creates the initial RID-management values in the registry.
    If the values already exist, they are read and returned.

Arguments:

    KeyHandle - Handle, registry RID key.

    ValueName - Pointer, registry value name.

    Rid - Pointer, returned RID value.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

    Other registry error codes.

--*/

{
    DWORD Status = ERROR_SUCCESS;
    ULONG ReservedParameter = 0;
    PULONG pReservedParameter = NULL;
    DWORD Type = REG_DWORD;
    ULONG Data = 0;
    ULONG Length = sizeof(DWORD);

    Data = 0;
    Length = sizeof(DWORD);

    // Read the RID value from the registry. If it does not exist, go ahead
    // and slam in a zero value. If it does exist, just return the current
    // value and let the caller figure out whether or not it is valid.

    Status = RegQueryValueExA(KeyHandle,
                              ValueName,
                              pReservedParameter,
                              &Type,
                              (PBYTE)&Data,
                              &Length);

    if (ERROR_SUCCESS != Status)
    {
        Data = 0;
        Length = sizeof(DWORD);

        Status = RegSetValueExA(KeyHandle,
                                ValueName,
                                ReservedParameter,
                                REG_DWORD,
                                (PVOID)&Data,
                                Length);
    }

    *Rid = Data;

    return(Status);
}


VOID
SampInitializeRidRanges(
    OUT PULONG  SampMinimumDomainRid,
    OUT PULONG  SampMaximumDomainRid,
    OUT DOUBLE *SampRidThreshold,
    OUT PULONG  SampRidBlockSize
    )

/*++

Routine Description:


    This routine sets up the RID Manager registry keys that contain things
    such as the min/max domain RID values, threshold value, etc. In general,
    this registry key (and its values) are not used by the RID manager--the
    RID manager uses the DS RID objects to read/write these values.

    The purpose of this key and its values are:

    -A hook for administrators so that they can override the DS RID values
     in case of an emergency repair.

    -A hook for testers so that they can set RID ranges and thresholds to
     small values in order to exercise the entire RID management code base.

Arguments:

    SampMinimunDomainRid - Pointer, smallest allowed RID in the domain.

    SampMaximunDomainRid - Pointer, largest allowed RID in the domain.

    SampRidThreshold - Pointer.  Once this percentage of the current RID pool 
        is exhausted, a request for a new RID pool is triggered.  If the 
        blocksize is 500, a threshold of 0.50 will result in a new pool request 
        once 250 RIDs have been consumed.

        If registry settings are present and valid this will be calculated as 
        RID Threshold / RID Block Size.  If not, the default value of 
        SAMP_RID_THRESHOLD will be used.     
    
    SampRidBlockSize - Pointer, the number of RIDs in the requested alloc-
        ation block.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

    Other registry error codes.

--*/

{
    DWORD Status = ERROR_SUCCESS;
    HKEY KeyHandle = INVALID_HANDLE_VALUE;
    CHAR RidConfigSection[256];

    // Initialize RID Manager global data. Globals are used for various RID
    // values so that they can be reset in the debugger or from test apps,
    // registry keys are read/set so that administrators can change the RID
    // values from the registry in a repair or testing situation.
    //
    // First, set the variables to the well-defined values of a healthy DC.
    //
    // Next, create or open the RID registry key (under the NTDS key) and
    // read each of the settings. If the values do not exist (first time set-
    // up), then default zero values are written to the registry. If non-
    // zero values do exist in the registry, then use these values to over-
    // ride the the well-defined values. Reset the variables iff all of the
    // registry key values are there and are valid. Allowing only a subset
    // of the variables to be set from the registry will likely lead to a
    // bogus set of RID values and a messed-up domain controller.
    //
    // Note: If the registry RID values are reset (say for testing purposes)
    // the DC must be rebooted in order for SAM and the RID manager to read
    // and use these new values.
    //
    // Note: If you must mess with the RID values from the registry, here
    // are the guidelines:
    //
    // 1. The minimum RID is the smallest allowed domain RID, and must be
    // greater than or equal to SAMP_MINIMUM_DOMAIN_RID.
    //
    // 2. The maximum RID is the largest allowed domain RID, and must be
    // less than or equal to SAMP_MAXIMUM_DOMAIN_RID. Naturally, it should
    // also be greater than the minimum RID.
    //
    // 3. The RID threshold triggers the action of allocating a new RID pool.
    // This value must be less than the RID block size (see next) and is
    // typically set to be 20% of the block size (i.e. when only 20% of the
    // pool remains, request another).
    //
    // 4. The RID block size is the chunk of RIDs that get allocated when
    // a RID request is made. This value is typically set in the tens of
    // thousands range, and must be larger than the threshold size. Its nicer
    // if the two values are not relatively prime (i.e. have a common divisor
    // greater than one).
    //
    // 5. The RID cache size probably shouldn't (at this time) be changed, so
    // if you want it to work, set it to the same value as SAMP_RID_CACHE_SIZE.

    *SampMinimumDomainRid = SAMP_MINIMUM_DOMAIN_RID;
    *SampMaximumDomainRid = SAMP_MAXIMUM_DOMAIN_RID;
    *SampRidThreshold = SAMP_RID_THRESHOLD;
    *SampRidBlockSize = SAMP_RID_BLOCK_SIZE;
    
    sprintf(RidConfigSection, "%s\\RID Values", DSA_CONFIG_ROOT);
    Status = RegCreateKeyA(HKEY_LOCAL_MACHINE, RidConfigSection, &KeyHandle);

    if (ERROR_SUCCESS == Status)
    {
        CHAR BlockSize[] = "RID Block Size";
                                         
        ULONG SampRidBlockSizeTemp = 0;
        
        Status = SampSetupRidRegistryKey(KeyHandle,
                                          BlockSize,
                                          &SampRidBlockSizeTemp);

        if (ERROR_SUCCESS != Status)
        {
            goto IgnoreRegistryCase;
        }
        
        // Verify the values that were returned from the registry, before
        // overriding the well-defined values. The above calls to SampSet-
        // upRidRegistryKeys will set default values to zero when they are
        // created for the first time. If these values are not changed,
        // they will be ignored because the following set of validations
        // will fail until valid values are placed in the registry.
        
        if (0 == SampRidBlockSizeTemp ||
            //
            // Debug builds can set small block sizes for testing.
            //
            #if (DBG == 1)
            FALSE
            #else
            SampRidBlockSizeTemp < SAMP_RID_BLOCK_SIZE      
            #endif
            )
        {
            SampDiagPrint(RID_MANAGER,
                      ("SAMSS: Invalid RID block size value [%lu] in registry\n",
                       SampRidBlockSizeTemp));

            goto IgnoreRegistryCase;
        }
        
        // Override the well-defined RID values iff all registry values are
        // present and valid.

        SampDiagPrint(RID_MANAGER,
            ("SAMSS: Overriding default RID values with registry settings\n"));
        
        *SampRidBlockSize = SampRidBlockSizeTemp;
    }
    else
    {
        // If the key cannot be created or opened, blow off the registry
        // values and just continue on with the well-defined RID values,
        // as would happen in a normally running system.

        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: RegCreate/OpenKey status = %lu\n",
                       Status));

        SampDiagPrint(RID_MANAGER,
                      ("SAMSS: Cannot access registry key %s\n",
                       RidConfigSection));
    }

IgnoreRegistryCase:

    if ( INVALID_HANDLE_VALUE != KeyHandle )
        RegCloseKey(KeyHandle);

    return;
}

NTSTATUS
SampInitializeRidManager(
    IN PDSNAME RidMgrObject,
    IN PDSNAME DsaObject,
    IN PDSNAME DomainObject,
    OUT BOOLEAN *NewRidManager
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    RIDINFO RidMgrInfo;

    RtlZeroMemory(&RidMgrInfo, sizeof(RIDINFO));


    //======================Create the RID Manager Object=====================

    // Find out if the RID Manager exists, create the (new schema) RID
    // Manager object in the System container if it does not exist.

    NtStatus = SampVerifyRidManagerExists(RidMgrObject);

    if ( !NT_SUCCESS(NtStatus) )
    {
        // Create the RID Manager for this DSA (a.k.a. DC). Assume
        // that any unsuccessful error code returned from the read
        // implies that the RID Manager does not exist and needs to
        // be created.

        NtStatus = SampCreateRidManager(RidMgrObject);

        if (!NT_SUCCESS(NtStatus))
        {
            goto Cleanup;
        }

        *NewRidManager = TRUE;

    }

    //======================Initialize RID Manager Object=====================

    // The boot-up sequence initializes the RID Reference, RID Manager, and
    // RID Object with initial, default values. Upon successful completion
    // of this phase, an initial RID pool is obtained from the current RID
    // Manager in the domain. Note that if the objects exist, from a prev-
    // ious session, they are not re-initialized because they must retain
    // previous values.

 
    // Set initial values for the RID Manager. The first NT DC that is
    // upgraded to an NT5 DC will create the RID Manager. In doing so,
    // the RID Manager will start its available RID pool at the current
    // value of the domain's NextRid value. This way, RIDs corresponding
    // to previously created accounts (prior to the upgrade) are preserv-
    // ed.

    if ( *NewRidManager )
    {
        PSAMP_OBJECT DomainContext = NULL;
        ULONG MinimumStartingRid = 0;
        ULONG Length = 0;
        ULONG DomainIndex = 0;


        // Make sure that the "next RID" that the RID manager starts with
        // is the one in the DS Account domain and not the Builtin domain
        // or some other random domain.

        DomainIndex = DOMAIN_START_DS + 1;

        

        MinimumStartingRid = SampDefinedDomains[DomainIndex].UnmodifiedFixed.NextRid;

       


        // Add a "delta" of 100 to the value of NextRid before setting
        // the minimum RID for the domain. Since the upgrade scenarios
        // include NT4 BDC to NT5 DC upgrades, there may be a few ac-
        // counts not yet replicated to this DC at the time of the up-
        // grade. In practice, this should only be a few accounts, so
        // incrementing by the minimum starting RID by 100 should cov-
        // er any latency problems. The Domain Administrator should
        // synchronize the domain controller to the rest of the domain
        // before performing an upgrade to reduce this problem.
        
        MinimumStartingRid += 100;
        ASSERT(SAMP_RESTRICTED_ACCOUNT_COUNT < MinimumStartingRid);

        RtlZeroMemory(&RidMgrInfo, sizeof(RIDINFO));

        // Store the location of the Role Owner in the RID Manager
        // object. This is a one-time initialization, indicating
        // that this is the the first DC in the domain, hence, the
        // first RID Manager of the domain. By default, then, the
        // first DC/DSA in the domain takes the role of the RID
        // Manager (and the DC/DSA is the RoleOwner). Indicate in the
        // flags that the role owner and available pool are being
        // updated.
       

        SampSetRoleOwner(&RidMgrInfo, DsaObject);
        SampSetRidPoolAvailable(&RidMgrInfo,
                                SampMaximumDomainRid,
                                MinimumStartingRid);
        SampSetRidFlags(&RidMgrInfo, RID_ROLE_OWNER | RID_AVAILABLE_POOL);

        NtStatus = SampUpdateRidManager(RidMgrObject,
                                        &RidMgrInfo);

        if ( !NT_SUCCESS( NtStatus ) )
        {
            goto Cleanup;
        }

        //
        // Update the reference to the rid manager
        //
        NtStatus = SampUpdateRidManagerReference(DomainObject,
                                                 RidMgrObject);

        if (!NT_SUCCESS(NtStatus))
        {
            goto Cleanup;
        }
    }

Cleanup:

        return(NtStatus);
}


NTSTATUS
SampDomainAsyncRidInitialization(
    PVOID p OPTIONAL
    )
//
// A wrapper for SampDomainRidInitialization, this routine
// is a callback routine for LsaIRegsiterNotification.
//
{
    return(SampDomainRidInitialization(FALSE));

    UNREFERENCED_PARAMETER( p );
}

NTSTATUS
SampDomainRidInitialization(
    IN BOOLEAN fSynchronous
    )

/*++

Routine Description:

    This routine is the initialization procedure for the RID Manager code
    and objects. It is executed whenever a domain controller is booted. In
    order to keep system boot time to a reasonable duration, any lengthy
    operations required during initialization should be started in a new
    thread.

    This routine creates the initial RID-management objects in the DS when
    installing a new domain controller (DC), or reinitializes them if they
    already exist from a prior installation. Because RID management is a
    critical part of a normally functioning DC, failure to initialize RID
    pools correctly will cause SAM, and hence, LSA to return an error code
    from their initialization sequences. Logon will be limited to a local
    Administrator account (presumably enough to repair the DC).

    Note that the terms "DSA" and "DC" are used interchangeably. A DC
    contains one instance of a DSA per hosted domain on that DC--in the
    first product, there is one DSA per DC. In the future, there can be
    several DSA's per DC, each acting as a domain controller for each
    different hosted domain.

    In particular, each DC is represented by one RID Object in the DS. The
    RID Object's distinguished name (DN) is constructed by appending the
    machine DN onto the "RID Set" string.

    When multiple domains are hosted on a single DC, there will be several
    DSA's per DC, hence, the need for several RID Objects per DC--one for
    each DSA's hosted domain.

    Overview of the RID Manager initialization steps:

    1)
    Initialize Globals
    Wait For RPCSS To Start

    2)
    Start a write transaction
    Verify RID Manager Is Not Created On A BDC
    Create the RID Manager Object
    Initialize RID Manager Object
    Initialize RID Manager Reference Object
    Read RID Manager Reference Object
    End transaction

    3)
    Start a write transaction
    Read RID Objects if possible and upgrade if necessary
    End transaction

    4)
    If necessary, request a rid pool ( this may go off the machine )

    5)
    Start a write transaction
    If necessary update local rid object with new rid pool
    End transaction

    6)
    Start read transaction
    Validate RID Objects
    End transaction

    7)
    Log RID Manager Initialization Status

Arguments:

    fSynchronous -- Tells us that the RID manager has been started synchronously
                    at initialization time. Synchronous initialization can successfully
                    complete if no off machine operations are required

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

    STATUS_INVALID_PARAMETER if the root name of the domain could not be
        located in the registry.

    Other DS error codes that have been mapped to an NTSTATUS can be returned
    from this routine.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    RIDINFO RidInfo;
   
    RIDINFO RidMgrInfoOld;
    RIDINFO RidObjectInfo;

    PDSNAME RidMgrObject = NULL;
    PDSNAME RidObject = NULL;
    PDSNAME Parent = NULL;

    PDSNAME DomainObject = NULL;
    PDSNAME DsaObject    = NULL;

    USHORT VerifyCount = 1;

    BOOLEAN   fRequestNewRidPool = FALSE;
    BOOLEAN   fInitRidManager = FALSE;
    BOOLEAN   fInitRidObject  = FALSE;
    BOOLEAN   fInitialized = FALSE;
    ULONG     Length = 0;
    ULONG     Status = 0;
    DWORD     IgnoreError = 0;

    RIDFLAG   Flags = 0;
    ULONG     DsaLength = 0;
    NTSTATUS  TempNtStatus;

    BOOLEAN   fActiveThread = FALSE;
    BOOLEAN   fTransactionOpen = FALSE;

    SAMTRACE("SampDomainRidInitialization");

    //
    // If we are no longer enabled, return without rescheduling
    //
    if (SampServiceState != SampServiceEnabled) {
        // This shouldn't happen the first time through!
        ASSERT( !fSynchronous );
        return(STATUS_INVALID_SERVER_STATE);
    }

    //
    // Init stack space
    //
    RtlZeroMemory(&RidInfo, sizeof(RIDINFO));
    RtlZeroMemory(&RidMgrInfoOld, sizeof(RIDINFO));
    RtlZeroMemory(&RidObjectInfo, sizeof(RIDINFO));

    if (fSynchronous)
    {
        //
        // The first Time Around initialize the Globals and the critical Section
        //

        //===========================Initialize Globals===========================

        RtlZeroMemory(&CachedRidManagerObject, sizeof(DSNAME));
        CachedRidManagerObject.structLen = DSNameSizeFromLen(0);
        RtlZeroMemory(&CachedRidSetObject, sizeof(DSNAME));
        CachedRidSetObject.structLen = DSNameSizeFromLen(0);

        
        // This call provides a registry-based override to the default RID para-
        // meter sizes. The registry values can be "tuned" for testing, admini-
        // strator configuration, etc. If the registry keys are not present or
        // their values are zero, they are not used, and the default constant
        // values are used instead (see ridmgr.h)

        SampInitializeRidRanges(&SampMinimumDomainRid,
                                &SampMaximumDomainRid,
                                &SampRidThreshold,
                                &SampRidBlockSize
                                );

        SampRidManagerInitialized = FALSE;
        SampDcRidRequestPending = FALSE;

        // Define a critical section to synchronize access to RID Manager global
        // data.

        RidMgrCritSect = &RidMgrCriticalSection;

        __try
        {
            InitializeCriticalSection(RidMgrCritSect);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        // If critical section initialization failed then return error.
        if (!NT_SUCCESS(NtStatus))
        {
            return (NtStatus);
        }
    }

    //
    // Increment the active thread count if we are being called in the 
    // background
    //
    if (!fSynchronous)
    {
        SampIncrementActiveThreads();
        fActiveThread = TRUE;
    }
  
    //
    // Prepare the dsname for the well known location of the rid manager
    // object
    //
  
    Length = 0;
    DomainObject = NULL;
    NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                    &Length,
                                    DomainObject);

    if ( NtStatus == STATUS_BUFFER_TOO_SMALL)
    {
        SAMP_ALLOCA(DomainObject,Length);
        if (NULL==DomainObject)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                        &Length,
                                        DomainObject);

    }

    if ( !NT_SUCCESS(NtStatus) )
    {
        goto Cleanup;
    }


    Length = (ULONG)DSNameSizeFromLen( DomainObject->NameLen + 
                                       wcslen(SYSTEM_W) + 
                                       4 );

    SAMP_ALLOCA(Parent,Length );
    if (NULL==Parent)
    {
       NtStatus = STATUS_INSUFFICIENT_RESOURCES;
       goto Cleanup;
    }
      
    RtlZeroMemory(Parent, Length);

    Status = AppendRDN(DomainObject,
                       Parent,
                       Length,
                       SYSTEM_W,
                       0,
                       ATT_COMMON_NAME);


    Length = (ULONG)DSNameSizeFromLen( Parent->NameLen + 
                                       wcslen(RID_MGR_W) +
                                       4);

    SAMP_ALLOCA(RidMgrObject,Length );
    if (NULL==RidMgrObject)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory(RidMgrObject, Length);

    Status = AppendRDN(Parent,
                       RidMgrObject,
                       Length, 
                       RID_MGR_W,
                       0,
                       ATT_COMMON_NAME);


    //
    // The attempt to create rid objects and their associated references is
    // retried until success. All the object creations are performed in a 
    // single transaction.
    //

    //============== Get NTDS Setting DN  ==========================
    //    Need to read NTDS Setting DN each every time in the loop
    //    otherwise, if the server moved sites before rid manager
    //    has been initialized, we will loop forever
    //==============================================================

    DsaLength = 0;
    DsaObject = NULL;
    NtStatus = GetConfigurationName(DSCONFIGNAME_DSA,
                                    &DsaLength,
                                    DsaObject);

    if ( NtStatus == STATUS_BUFFER_TOO_SMALL)
    {
        //
        // Allocate Memory from Heap instead of stack.
        //
        DsaObject = (PDSNAME) RtlAllocateHeap(RtlProcessHeap(), 0, DsaLength);

        if (NULL == DsaObject)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            RtlZeroMemory(DsaObject, DsaLength);

            NtStatus = GetConfigurationName(DSCONFIGNAME_DSA,
                                            &DsaLength,
                                            DsaObject);
        }
    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }

    //============== Create a transaction for the rid mgr initialization ==

    NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );
    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }
    fTransactionOpen = TRUE;


    //
    // Initialize the RID manager object , the object is created if it does
    // not exist and the initial available RID pool is set on it.
    //

    NtStatus = SampInitializeRidManager(
                        RidMgrObject,
                        DsaObject,
                        DomainObject,
                        &fInitRidManager
                        );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //===================Create New and Read Old RID Objects==================
    // Read the RID Object if it exists. The RID
    // object contains the RID pools for this DC (one pool for each hosted
    // domain.

    //
    // If the RID object does not exist, then it will be created when
    // we request an initial rid pool.
    //
    Flags = (RID_ALLOCATED_POOL |
             RID_PREV_ALLOC_POOL |
             RID_USED_POOL |
             RID_NEXT_RID);
    SampSetRidFlags(&RidObjectInfo, Flags);

    NtStatus = SampObtainRidInfo( DsaObject,
                                 &RidObject,
                                 &RidObjectInfo  );
    if ( NT_SUCCESS( NtStatus ) )
    {
        //
        // The RID set object exists
        // Let's see what shape our rid pool is in and
        // determine what sort of initialiazation needs
        // to be done
        //
        if ( RidObjectInfo.NextRid == 0 )
        {
            //
            // This should be a completely fresh rid object.
            // This can happend when the rid pool has been
            // invalidated, or when we obtained a rid pool,
            // but failed to update our local information
            //

           fRequestNewRidPool = TRUE;
        }
    }
        
    else if ( (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND)
           || (NtStatus == STATUS_DS_NO_ATTRIBUTE_OR_VALUE) )
    {
        //
        // The rid object could not be found, the process of
        // acquiring a new RID pool will result in us obtaining
        // a new RID set object.
        //
        fInitRidObject = TRUE;
        NtStatus = STATUS_SUCCESS;
    }

    //
    // Clean up transactions
    //

    TempNtStatus = SampMaybeEndDsTransaction( NT_SUCCESS(NtStatus) ?
                                              TransactionCommit :
                                              TransactionAbort );

    fTransactionOpen = FALSE;

    if ( NT_SUCCESS( NtStatus ) && !NT_SUCCESS( TempNtStatus ) )
    {
        NtStatus = TempNtStatus;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

   
    //=======================Request An Initial RID Pool======================

    
    //
    // Request a RID pool if we either created a rid manager, or needed to
    // create a RID set , or if we found that our current pool was empty
    // In the last 2 cases do not go off machine to obtain a rid pool if 
    // this is the main initialization thread ( fSynchronous set to true )
    //

    if ((fInitRidManager) || 
        (!fSynchronous && fInitRidObject ) || 
        (!fSynchronous && fRequestNewRidPool))
    {
        //
        // If we need a rid pool and this is not the case of the first
        // DC in the domain starting up, then we most probably need to
        // go off machine for the rid pool. Return a failure if this is
        // the mainline init thread, so that this task is spawned again
        // in the background.
        //

     
        
        SampDcRidRequestPending = TRUE;

        NtStatus = SampRequestRidPool(
                        RidMgrObject,
                        FALSE
                        );
        if (!NT_SUCCESS(NtStatus))
        {
           goto Cleanup;
        }
    }
    else if ((fInitRidObject || fRequestNewRidPool) && fSynchronous)
    {
        //
        // Needing to get a RID pool and go off machine for that , 
        // but mainline initialization thread. Return a failure , and
        // the initialization will be retried in the background
        //

        NtStatus = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }


    //
    // If we are here, the RID set object has been created, we have
    // a RID pool etc
    //


    //
    // Begin a transaction
    //

    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }
    fTransactionOpen = TRUE;

    //
    // Read the Rid Set object
    //

    NtStatus = SampObtainRidInfo( DsaObject,
                                 &RidObject,
                                 &RidObjectInfo  
                                 );

    if (!NT_SUCCESS(NtStatus))
    {
       goto Cleanup;
    }
    

    //
    // Register the object with base DS to ensure that it is
    // not deleted
    //

    IgnoreError = DirProtectEntry(RidObject);
    
    //
    // Maintain the GUID of the cached RID manager object in memory
    // This speeds up further references to the RID manager object
    //

    RtlCopyMemory(&CachedRidManagerObject.Guid,
                  &RidMgrObject->Guid,
                  sizeof(GUID)
                 );
    //
    // Maintain the GUID of the RID set object in memory
    // This speeds up further references to the RID set object
    //

    RtlCopyMemory(&CachedRidSetObject.Guid,
                  &RidObject->Guid,
                  sizeof(GUID));

    //
    // Tell the DS to callback when the global rid pool changes
    // so that we can make sure our rid pool is always a subset
    // of the global rid pool.
    //

    NtStatus = SampSetupRidPoolNotification( RidMgrObject );
    if ( !NT_SUCCESS( NtStatus ) )
    {
        goto Cleanup;
    }

    //
    // We have a valid rid pool
    //
    SampRidManagerInitialized = TRUE;

Cleanup:

    if (DsaObject)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, DsaObject);
        DsaObject = NULL;
    }

    //
    // Close all open transactions.
    //
    if (fTransactionOpen) {

        SampMaybeEndDsTransaction(NT_SUCCESS(NtStatus) ?
                                  TransactionCommit :
                                  TransactionAbort);
    }

    if (fActiveThread) {

        SampDecrementActiveThreads();
    }

    // 
    // Reschedule as necessary
    //
    if ( !NT_SUCCESS(NtStatus) ) {

        PVOID fRet = NULL;

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampDomainRidInitialization status = 0x%lx; rescheduling\n",
                   NtStatus));

        do {

            //
            // LsaIRegisterNotification can fail on resource errors
            // keep retrying until it succeeds
            //
            fRet = LsaIRegisterNotification(
                    SampDomainAsyncRidInitialization,
                    NULL,
                    NOTIFIER_TYPE_INTERVAL,
                    0,           // no class
                    NOTIFIER_FLAG_ONE_SHOT,
                    30,          // wait for 30 seconds
                    NULL         // no handle
                    );

            if ( !fRet ) {
                // Wait one minute before retry
                WaitForSingleObject(SampAboutToShutdownEventHandle,60000);
            }

        } while ( !fRet && (SampServiceState == SampServiceEnabled));

    } else {

        // We should be fully initialized
        ASSERT( TRUE ==  SampRidManagerInitialized );


    }


    return( NtStatus );

}



NTSTATUS
SampDomainRidUninitialization(
    VOID
    )

/*++

Routine Description:

    This routine un-initializes various RID Manager data and releases re-
    sources, such as critical sections, back to the OS.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    SAMTRACE("SampDomainRidUninitialization");

    DeleteCriticalSection(RidMgrCritSect);

    return(NtStatus);
}

BOOL
SampNotifyPrepareToImpersonate(
    ULONG Client,
    ULONG Server,
    VOID **ImpersonateData
    )
//
// This function is called by the core DS as preparation for a call to
// SampNotifyProcessRidManagerDelta.  Since SAM does not have a
// client context, we set the thread state fDSA to TRUE.
//
{
    SampSetDsa( TRUE );

    return TRUE;
}

VOID
SampNotifyStopImpersonation(
    ULONG Client,
    ULONG Server,
    VOID *ImpersonateData
    )
//
// Called after SampNotifyProcessRidManagerDelta, this function
// undoes the effect of SampNotifyPrepareToImpersonate
//
{

    SampSetDsa( FALSE );

    return;
}

VOID
SampNotifyProcessRidManagerDelta(
    ULONG hClient,
    ULONG hServer,
    ENTINF *EntInf
    )
/*++

Routine Description:

    This callback is used when the global rid manager object is changed.
    This function compares our local rid pool with the current rid pool
    to make sure the former is a subset of the latter; if not, the current
    rid pool is invalidated.

Arguments:

    hClient - ignored
    hServer - ignored
    EntInf  - the pointer to the rid manager data

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PDSNAME  RidObject = NULL;
    ULONG    Flags = 0;

    RIDINFO  RidInfo;
    ULARGE_INTEGER  RidPoolAvailable;

    BOOL     fFoundRidPool = FALSE;
    BOOL     fLockAcquired = FALSE;
    BOOL     fTransaction  = FALSE;
    BOOL     fUpdateRidObject = FALSE;

    THSTATE  *pTHSSave = NULL;

    ULONG    i;

    // Parameter check
    ASSERT( EntInf );

    RtlZeroMemory( &RidInfo, sizeof(RidInfo) );
    RtlZeroMemory( &RidPoolAvailable, sizeof(RidPoolAvailable) );

    //
    // N.B. This function is called with a read transaction
    //
    pTHSSave = THSave();

    // Grab the SAM lock in case we have to update the rid pool information
    // so to avoid a write conflict
    SampAcquireReadLock();
    fLockAcquired = TRUE;

    // Start a transaction
    NtStatus = SampMaybeBeginDsTransaction(TransactionWrite);
    if ( !NT_SUCCESS( NtStatus ) )
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampMaybeBeginTransaction failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }
    fTransaction = TRUE;

    //
    // Get the local rid pool
    //
    Flags = ( RID_ALLOCATED_POOL | RID_PREV_ALLOC_POOL );
    SampSetRidFlags(&RidInfo, Flags);

    NtStatus = SampObtainRidInfo( NULL,
                                 &RidObject,
                                 &RidInfo );
    if ( !NT_SUCCESS( NtStatus ) )
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampObtainRidInfo failed with 0x%x\n",
                   NtStatus));

        goto Cleanup;
    }

    //
    // Extract the available (global) rid pool
    //
    for ( i = 0; i < EntInf->AttrBlock.attrCount; i++)
    {
        ATTR *Attr = &EntInf->AttrBlock.pAttr[i];

        if ( Attr->attrTyp == ATT_RID_AVAILABLE_POOL )
        {
            ASSERT( Attr->AttrVal.valCount == 1 );
            RidPoolAvailable = *(ULARGE_INTEGER *)(Attr->AttrVal.pAVal[0].pVal);
            fFoundRidPool = TRUE;
        }
    }

    if ( !fFoundRidPool )
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: RidPool not returned with notification.\n"));

        goto Cleanup;
    }

    //
    // Now for some logic
    //
    if (  (RidInfo.RidPoolPrevAlloc.LowPart > RidPoolAvailable.HighPart)
       || (RidInfo.RidPoolPrevAlloc.HighPart > RidPoolAvailable.HighPart) )
    {
        SampSetRidPoolPrevAlloc( &RidInfo, 0, 0 );
        fUpdateRidObject = TRUE;
    }

    if (  (RidInfo.RidPoolAllocated.LowPart > RidPoolAvailable.HighPart)
       || (RidInfo.RidPoolAllocated.HighPart > RidPoolAvailable.HighPart) )
    {

        SampSetRidPoolAllocated( &RidInfo, 0, 0 );
        fUpdateRidObject = TRUE;
    }

    if ( fUpdateRidObject )
    {
        //
        // This assert is here to trap cases where we have to invalidate
        // the rid pool.  This should _only_ be in extreme backup and restore.
        // scenarios.  It is harmless to ignore since we recover. However, we
        // obviously lose some RID's forever.
        //
        ASSERT( FALSE && "Invalidating rid pool" );

        NtStatus = SampUpdateRidObject( RidObject,
                                        &RidInfo,
                                        FALSE, // commit immediately
                                        FALSE  // not authoritative
                                       );

        if ( !NT_SUCCESS( NtStatus ) )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Update to invalidate rid pool failed\n"));

            goto Cleanup;
        }
    }

    //
    // That's it - fall through to cleanup;
    //

Cleanup:

    if ( fTransaction )
    {
        NtStatus = SampMaybeEndDsTransaction( NT_SUCCESS(NtStatus) ? TransactionCommit : TransactionAbort );
        if ( !NT_SUCCESS( NtStatus ) )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: Commit to invalidate rid pool failed 0x%x\n",
                       NtStatus));

            // Ignore error;
        }
    }

    if ( fLockAcquired )
    {
        SampReleaseReadLock();
    }

    if ( pTHSSave )
    {
        THRestore( pTHSSave );
    }

    return;
}


NTSTATUS
SampSetupRidPoolNotification(
    PDSNAME RidManagerObject
    )
/*++

Routine Description:

    This routine tells the DS to notify us when the rid manager object
    changes so we can verify that our local rid pool is a subset of the global
    rid pool.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS if the objects were created, otherwise an error code.

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       DirError = 0;

    SEARCHARG   searchArg;
    NOTIFYARG   notifyArg;
    NOTIFYRES*  notifyRes = NULL;
    ENTINFSEL   entInfSel;
    ATTR        attr;
    FILTER      filter;

    // Parameter check
    ASSERT( RidManagerObject );

    //
    // init notify arg
    //
    notifyArg.pfPrepareForImpersonate = SampNotifyPrepareToImpersonate;
    notifyArg.pfTransmitData = SampNotifyProcessRidManagerDelta;
    notifyArg.pfStopImpersonating = SampNotifyStopImpersonation;
    notifyArg.hClient = 0;

    //
    // init search arg
    //
    ZeroMemory(&searchArg, sizeof(SEARCHARG));
    ZeroMemory(&entInfSel, sizeof(ENTINFSEL));
    ZeroMemory(&filter, sizeof(FILTER));
    ZeroMemory(&attr, sizeof(ATTR));

    searchArg.pObject = RidManagerObject;

    InitCommarg(&searchArg.CommArg);
    searchArg.choice = SE_CHOICE_BASE_ONLY;
    searchArg.bOneNC = TRUE;

    searchArg.pSelection = &entInfSel;
    entInfSel.attSel = EN_ATTSET_LIST;
    entInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    entInfSel.AttrTypBlock.attrCount = 1;
    entInfSel.AttrTypBlock.pAttr = &attr;
    attr.attrTyp = ATT_RID_AVAILABLE_POOL;

    searchArg.pFilter = &filter;
    filter.choice = FILTER_CHOICE_ITEM;
    filter.FilterTypes.Item.choice = FI_CHOICE_TRUE;

    DirError = DirNotifyRegister(&searchArg, &notifyArg, &notifyRes);

    if ( DirError != 0 ) {

        NtStatus = SampMapDsErrorToNTStatus(DirError, &notifyRes->CommRes);
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: DirNotifyRegister init failed with 0x%x\n",
                    NtStatus ));
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\samsrvp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    samsrvp.h

Abstract:

    This file contains definitions private to the SAM server program.

Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:

    JimK        04-Jul-1991
        Created initial file.
    ChrisMay    10-Jun-1996
        Added macros and flags/defines for IsDsObject tests.
    Murlis      27-Jun-1996
        Moved SAMP_OBJECT_TYPE and mapping table structure defines
        to mappings.h in dsamain\src\include
    ColinBr     08-Aug-1996
        Added new ASSERT definitions
    ChrisMay    05-Dec-1996
        Moved SampDiagPrint to dbgutilp.h with the rest of the debugging
        routines and definitions.

--*/

#ifndef _NTSAMP_
#define _NTSAMP_


#ifndef UNICODE
#define UNICODE
#endif // UNICODE

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                                                                    //
//      Diagnostics                                                   //
//                                                                    //
////////////////////////////////////////////////////////////////////////

// Macro to align buffer data on DWORD boundary.

#define SampDwordAlignUlong( v )  (((v)+3) & 0xfffffffc)

//
// Maximum number of digits that may be specified to
// SampRtlConvertRidToUnicodeString
//

#define SAMP_MAXIMUM_ACCOUNT_RID_DIGITS    ((ULONG) 8)

//
// Account never expires timestamp (in ULONG form )
//

#define SAMP_ACCOUNT_NEVER_EXPIRES         ((ULONG) 0)



//
// SAM's shutdown order level (index).
// Shutdown notifications are made in the order of highest level
// to lowest level value.
//

#define SAMP_SHUTDOWN_LEVEL                 ((DWORD) 481)



// Define a Macro to set and unset the state of the DS object in the Context
// blob.

#define SAMP_REG_OBJECT                     ((ULONG) 0x00000001)
#define SAMP_DS_OBJECT                      ((ULONG) 0x00000002)


// Define a Macro to set and Unset the state of the DS object
// in the Context blob

#define SetDsObject(c)    ((c->ObjectFlags) |= SAMP_DS_OBJECT);\
                          ((c->ObjectFlags) &= ~(SAMP_REG_OBJECT));


#define SetRegistryObject(c)  ((c->ObjectFlags) |= SAMP_REG_OBJECT);\
                              ((c->ObjectFlags) &= ~(SAMP_DS_OBJECT));


//Define a Macro to check if the object is in the DS
#define IsDsObject(c)       (((c->ObjectFlags)& SAMP_DS_OBJECT)==SAMP_DS_OBJECT)


// Define a Macro to obtain the domain object given an account Object
#define DomainObjectFromAccountContext(C)\
            SampDefinedDomains[C->DomainIndex].Context->ObjectNameInDs

// Define a Macro to obtain the domain Sid given the account object
#define DomainSidFromAccountContext(C)\
            SampDefinedDomains[C->DomainIndex].Sid


// Define a Macro to access the Root Domain Object

#define ROOT_OBJECT     ((DSNAME *) RootObjectName)

// Macro to test wether DownLevelDomainControllers are present in the system
#define DownLevelDomainControllersPresent(DomainIndex)  (SampDefinedDomains[DomainIndex].IsMixedDomain)

// Define a Macro for ARRAY Counts
#define ARRAY_COUNT(x)  (sizeof(x)/sizeof(x[0]))

// Define a Macro for Absolute Value
#define ABSOLUTE_VALUE(x) ((x<0)?(-x):x)

// Define a Macro for one second in file time units
#define SAMP_ONE_SECOND_IN_FILETIME (10 * (1000*1000))

//
// Macro to help with RTL_BITMAP.
//
// b is the number of bits desired in the bitmap
//
#define SAMP_BITMAP_ULONGS_FROM_BITS(b) ((b + 31) / 32)

#define DOMAIN_START_DS 2
#define DOMAIN_START_REGISTRY 0

// Defines the maximum number of Sids that we will return in a reverse membership call.
// LSAI_CONTEXT_SID_LIMIT is the maximum number of SID in a Token, also we know
// SAM will stop group expansion at 2 * LSAI_CONTEXT_SID_LIMIT, add 10 more as overhead/buffer.
#define MAX_SECURITY_IDS    (2 * LSAI_CONTEXT_SID_LIMIT + 10)

// Define a macro to find out wether the domain is a builtin domain
#define IsBuiltinDomain(x) (SampDefinedDomains[x].IsBuiltinDomain)

#define FLAG_ON(x, y)  ((y)==((x)&(y)))


#define SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX 1

#define SAMP_DEFAULT_ACCOUNT_DOMAIN_INDEX \
    ( SampUseDsData ? \
        ( DOMAIN_START_DS + 1 ) :\
        SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX \
    )

#define DECLARE_CLIENT_REVISION(handle)\
    ULONG ClientRevision  = SampClientRevisionFromHandle(handle);




#define SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus)\
    SampMapNtStatusToClientRevision(ClientRevision,&NtStatus);\


// Defines the maximum number of members that can be added or removed from group/alias.
#if DBG

#define INIT_MEMBERSHIP_OPERATION_NUMBER   4
#define MAX_MEMBERSHIP_OPERATION_NUMBER    8

#else

#define INIT_MEMBERSHIP_OPERATION_NUMBER   16
#define MAX_MEMBERSHIP_OPERATION_NUMBER    5000

#endif


//
// Defines the value for incrementally read Group/Alias Membership
//

#if DBG

#define SAMP_READ_GROUP_MEMBERS_INCREMENT   10
#define SAMP_READ_ALIAS_MEMBERS_INCREMENT   10

#else

#define SAMP_READ_GROUP_MEMBERS_INCREMENT   500
#define SAMP_READ_ALIAS_MEMBERS_INCREMENT   500

#endif

//
// defines values for CONTROL used in SampMaybeAcquireReadLock
// 

#define DEFAULT_LOCKING_RULES                               0x0
#define DOMAIN_OBJECT_DONT_ACQUIRELOCK_EVEN_IF_SHARED       0x1

//
// define a macro for alloca that traps any exceptions
//

#define SAMP_ALLOCA(y,x) \
   __try {\
     y = alloca(x);\
   } __except ( GetExceptionCode() == STATUS_STACK_OVERFLOW) {\
     /*_resetstkoflw();*/\
     y=NULL;\
   }


#define SAMP_CONTEXT_SIGNATURE          0xEE77FF88
 

#define SAMP_CLOSE_OPERATION_ACCESS_MASK    0xFFFFFFFF


#define SAMP_DEFAULT_LASTLOGON_TIMESTAMP_SYNC_INTERVAL          14 
#define SAMP_LASTLOGON_TIMESTAMP_SYNC_SWING_WINDOW               5


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>      // DbgPrint prototype
#include <nturtl.h>     // needed for winbase.h
#include <rpc.h>        // DataTypes and runtime APIs
#include <string.h>     // strlen
#include <stdio.h>      // sprintf

#define UnicodeTerminate(p) ((PUNICODE_STRING)(p))->Buffer[(((PUNICODE_STRING)(p))->Length + 1)/sizeof(WCHAR)] = UNICODE_NULL

#include <ntrpcp.h>     // prototypes for MIDL user functions
#include <samrpc.h>     // midl generated SAM RPC definitions
#include <ntlsa.h>
#define SECURITY_WIN32
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>
#include <samisrv.h>    // SamIConnect()
#include <lsarpc.h>
#include <lsaisrv.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <samsrv.h>     // prototypes available to security process
#include "sampmsgs.h"
#include "lsathunk.h"
#include "dbgutilp.h"   // supplimental debugging routines
#include <mappings.h>
#include "ntdsguid.h"   // DS Control Access Right GUID


VOID
UnexpectedProblem( VOID );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// ASSERT is a macro defined in ntrtl.h that calls RtlAssert which is a      //
// in ntdll.dll that is only defined when DBG == 1, hece requiring a checked //
// ntdll.dll, hence a checked system.                                        //
//                                                                           //
// To allow ASSERT to break into a debugger when SAM is built with DBG == 1  //
// and still test it on a free system, ASSERT is redefined here to call a    //
// a private version of RtlAssert, namely SampAssert, when                    //
// SAMP_PRIVATE_ASSERT == 1.                                                 //
//                                                                           //
// Checked in versions of the file should have SAMP_PRIVATE_ASSERT == 0      //
// so for people outside the SAM world, ASSERT will have the action defined  //
// in ntrtl.h                                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#ifdef USER_MODE_SAM
    #define SAMP_PRIVATE_ASSERT 1
#else
    #define SAMP_PRIVATE_ASSERT 1
#endif

#if DBG

#define SUCCESS_ASSERT(Status, Msg)                                     \
{                                                                       \
    if ( !NT_SUCCESS(Status) ) {                                        \
        UnexpectedProblem();                                            \
        BldPrint(Msg);                                                  \
        BldPrint("Status is: 0x%lx \n", Status);                        \
        return(Status);                                                 \
                                                                        \
    }                                                                   \
}

#else

#define SUCCESS_ASSERT(Status, Msg)                                     \
{                                                                       \
    if ( !NT_SUCCESS(Status) ) {                                        \
        return(Status);                                                 \
    }                                                                   \
}

#endif // DBG


#if (DBG == 1) && (SAMP_PRIVATE_ASSERT == 1)

VOID
SampAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#undef ASSERT
#define ASSERT( exp ) \
    if (!(exp)) \
        SampAssert( #exp, __FILE__, __LINE__, NULL )

#undef ASSERTMSG
#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        SampAssert( #exp, __FILE__, __LINE__, msg )

#else

// Follow the convention of the ASSERT definition in ntrtl.h

#endif // DBG

ULONG
SampTransactionDomainIndexFn();

#define SampTransactionDomainIndex SampTransactionDomainIndexFn()


BOOLEAN
SampTransactionWithinDomainFn();

#define SampTransactionWithinDomain SampTransactionWithinDomainFn()


VOID
SampSetTransactionWithinDomain(
    IN BOOLEAN  WithinDomain
    );

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Caller Types when calling  SampStoreUserPasswords                   //
//      PasswordChange  -- the caller trying to change password        //
//      PasswordSet     -- the caller trying to set password           //
//      PasswordPushPdc -- the caller trying to Push Password changes  //
//                         on PDC                                      //
//                                                                     //
// These caller types are used by WMI event trace                      //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


typedef enum _SAMP_STORE_PASSWORD_CALLER_TYPE {
    PasswordChange = 1,
    PasswordSet,
    PasswordPushPdc
} SAMP_STORE_PASSWORD_CALLER_TYPE;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Structure for optimized(speed up) group/alias membership add/remove //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY {
    ULONG   OpType;         // ADD_VALUE or REMOVE_VALUE
    PDSNAME MemberDsName;       // Pointer to DSNAME
} SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY, *PSAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Structure for User Parameter Migration                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_SUPPLEMENTAL_CRED {
    struct _SAMP_SUPPLEMENTAL_CRED * Next;
    SECPKG_SUPPLEMENTAL_CRED SupplementalCred;
    BOOLEAN     Remove;
} SAMP_SUPPLEMENTAL_CRED, *PSAMP_SUPPLEMENTAL_CRED;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Structure for User Site Affinity                                    //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_SITE_AFFINITY {

    GUID SiteGuid;
    LARGE_INTEGER TimeStamp;

} SAMP_SITE_AFFINITY, *PSAMP_SITE_AFFINITY;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macro to define SAM Attribute access bitmap                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SAMP_DEFINE_SAM_ATTRIBUTE_BITMASK(x)                           \
    ULONG x##Buffer[SAMP_BITMAP_ULONGS_FROM_BITS(MAX_SAM_ATTRS)];      \
    RTL_BITMAP x;

#define SAMP_INIT_SAM_ATTRIBUTE_BITMASK(x)                             \
    RtlInitializeBitMap(&x,                                            \
                        (x##Buffer),                                   \
                        MAX_SAM_ATTRS );                               \
    RtlClearAllBits(&x);


#define SAMP_COPY_SAM_ATTRIBUTE_BITMASK(x,y)                           \
    (x).SizeOfBitMap = (y).SizeOfBitMap;                               \
    RtlCopyMemory((x).Buffer,(y).Buffer,(SAMP_BITMAP_ULONGS_FROM_BITS(MAX_SAM_ATTRS) * sizeof(ULONG)));
    

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// TEMPORARY GenTab2 definitions                                             //
// These structures should be considered opaque.                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// Each element in the tree is pointed to from a leaf structure.
// The leafs are linked together to arrange the elements in
// ascending sorted order.
//

typedef struct _GTB_TWO_THREE_LEAF {

    //
    // Sort order list links
    //

    LIST_ENTRY SortOrderEntry;

    //
    // Pointer to element
    //

    PVOID   Element;

} GTB_TWO_THREE_LEAF, *PGTB_TWO_THREE_LEAF;



typedef struct _GTB_TWO_THREE_NODE {

    //
    // Pointer to parent node.  If this is the root node,
    // then this pointer is null.
    //

    struct _GTB_TWO_THREE_NODE *ParentNode;


    //
    //  Pointers to child nodes.
    //
    //    1) If a pointer is null, then this node does not have
    //       that child.  In this case, the control value MUST
    //       indicate that the children are leaves.
    //
    //    2) If the children are leaves, then each child pointer
    //       is either NULL (indicating this node doesn't have
    //       that child) or points to a GTB_TWO_THREE_LEAF.
    //       If ThirdChild is Non-Null, then so is SecondChild.
    //       If SecondChild is Non-Null, then so is FirstChild.
    //       (that is, you can't have a third child without a
    //       second child, or a second child without a first
    //       child).
    //

    struct _GTB_TWO_THREE_NODE *FirstChild;
    struct _GTB_TWO_THREE_NODE *SecondChild;
    struct _GTB_TWO_THREE_NODE *ThirdChild;

    //
    // Flags provding control information about this node
    //

    ULONG   Control;


    //
    // These fields point to the element that has the lowest
    // value of all elements in the second and third subtrees
    // (respectively).  These fields are only valid if the
    // corresponding child subtree pointer is non-null.
    //

    PGTB_TWO_THREE_LEAF LowOfSecond;
    PGTB_TWO_THREE_LEAF LowOfThird;

} GTB_TWO_THREE_NODE, *PGTB_TWO_THREE_NODE;


//
//  The comparison function takes as input pointers to elements containing
//  user defined structures and returns the results of comparing the two
//  elements.  The result must indicate whether the FirstElement
//  is GreaterThan, LessThan, or EqualTo the SecondElement.
//

typedef
RTL_GENERIC_COMPARE_RESULTS
(NTAPI *PRTL_GENERIC_2_COMPARE_ROUTINE) (
    PVOID FirstElement,
    PVOID SecondElement
    );

//
//  The allocation function is called by the generic table package whenever
//  it needs to allocate memory for the table.
//

typedef
PVOID
(NTAPI *PRTL_GENERIC_2_ALLOCATE_ROUTINE) (
    CLONG ByteSize
    );

//
//  The deallocation function is called by the generic table package whenever
//  it needs to deallocate memory from the table that was allocated by calling
//  the user supplied allocation function.
//

typedef
VOID
(NTAPI *PRTL_GENERIC_2_FREE_ROUTINE) (
    PVOID Buffer
    );


typedef struct _RTL_GENERIC_TABLE2 {

    //
    // Pointer to root node.
    //

    PGTB_TWO_THREE_NODE Root;

    //
    // Number of elements in table
    //

    ULONG ElementCount;

    //
    // Link list of leafs (and thus elements) in sort order
    //

    LIST_ENTRY SortOrderHead;


    //
    // Caller supplied routines
    //

    PRTL_GENERIC_2_COMPARE_ROUTINE  Compare;
    PRTL_GENERIC_2_ALLOCATE_ROUTINE Allocate;
    PRTL_GENERIC_2_FREE_ROUTINE     Free;


} RTL_GENERIC_TABLE2, *PRTL_GENERIC_TABLE2;



//////////////////////////////////////////////////////////////////////////
//                                                                      //
//  Generic Table2 Routine Definitions...                               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


typedef struct 
{
    UNICODE_STRING  AccountName;
    SAMP_OBJECT_TYPE    ObjectType;

} SAMP_ACCOUNT_NAME_TABLE_ELEMENT, *PSAMP_ACCOUNT_NAME_TABLE_ELEMENT;


typedef struct
{
    PSID    ClientSid;
    ULONG   ActiveContextCount;
} SAMP_ACTIVE_CONTEXT_TABLE_ELEMENT, *PSAMP_ACTIVE_CONTEXT_TABLE_ELEMENT;



//NTSYSAPI
VOID
//NTAPI
RtlInitializeGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PRTL_GENERIC_2_COMPARE_ROUTINE  CompareRoutine,
    PRTL_GENERIC_2_ALLOCATE_ROUTINE AllocateRoutine,
    PRTL_GENERIC_2_FREE_ROUTINE     FreeRoutine
    );


//NTSYSAPI
PVOID
//NTAPI
RtlInsertElementGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element,
    PBOOLEAN NewElement
    );


//NTSYSAPI
BOOLEAN
//NTAPI
RtlDeleteElementGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element
    );


//NTSYSAPI
PVOID
//NTAPI
RtlLookupElementGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element
    );


//NTSYSAPI
PVOID
//NTAPI
RtlEnumerateGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID *RestartKey
    );


//NTSYSAPI
PVOID
//NTAPI
RtlRestartKeyByIndexGenericTable2(
    PRTL_GENERIC_TABLE2 Table,
    ULONG I,
    PVOID *RestartKey
    );

//NTSYSAPI
PVOID
//NTAPI
RtlRestartKeyByValueGenericTable2(
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element,
    PVOID *RestartKey
    );

//NTSYSAPI
ULONG
//NTAPI
RtlNumberElementsGenericTable2(
    PRTL_GENERIC_TABLE2 Table
    );

//
//  The function IsGenericTableEmpty will return to the caller TRUE if
//  the generic table is empty (i.e., does not contain any elements)
//  and FALSE otherwise.
//

//NTSYSAPI
BOOLEAN
//NTAPI
RtlIsGenericTable2Empty (
    PRTL_GENERIC_TABLE2 Table
    );





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macros                                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
// This macro generates TRUE if account auditing is enabled and this
// server is a PDC.  Otherwise, this macro generates FALSE.
//
// SampDoAccountAuditing(
//      IN ULONG i
//      )
//
// Where:
//
//      i - is the index of the domain whose state is to be checked.
//

#define SampDoAccountAuditing( i )                       \
    (SampSuccessAccountAuditingEnabled == TRUE)

#define SampDoSuccessOrFailureAccountAuditing( i, Status )        \
    (((SampFailureAccountAuditingEnabled == TRUE) && (!NT_SUCCESS(Status)))\
      ||((SampSuccessAccountAuditingEnabled==TRUE) && (NT_SUCCESS(Status))))

//
// VOID
// SampSetAuditingInformation(
// IN PPOLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo
// )
//
// Routine Description:
//
// This macro function sets the Audit Event Information relevant to SAM
// given LSA Audit Events Information.
//
// Arguments:
//
//     PolicyAuditEventsInfo - Pointer to Audit Events Information
//         structure.
//
// Return Values:
//
//     None.
//

#define SampSetAuditingInformation( PolicyAuditEventsInfo ) {       \
                                                                    \
    if (PolicyAuditEventsInfo->AuditingMode &&                      \
           (PolicyAuditEventsInfo->EventAuditingOptions[ AuditCategoryAccountManagement ] & \
                POLICY_AUDIT_EVENT_SUCCESS)                         \
       ) {                                                          \
                                                                    \
        SampSuccessAccountAuditingEnabled = TRUE;                   \
                                                                    \
    } else {                                                        \
                                                                    \
        SampSuccessAccountAuditingEnabled = FALSE;                  \
    }                                                               \
  if (PolicyAuditEventsInfo->AuditingMode &&                      \
           (PolicyAuditEventsInfo->EventAuditingOptions[ AuditCategoryAccountManagement ] & \
                POLICY_AUDIT_EVENT_FAILURE)                         \
       ) {                                                          \
                                                                    \
        SampFailureAccountAuditingEnabled = TRUE;                   \
                                                                    \
    } else {                                                        \
                                                                    \
        SampFailureAccountAuditingEnabled = FALSE;                  \
    }                                                               \
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Defines                                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
// Major and minor revision are stored as a single 32-bit
// value with the major revision in the upper 16-bits and
// the minor revision in the lower 16-bits.
//
//      Major Revision:         1  - NT Version 1.0
//          Minor Revisions:        1 - NT Revision 1.0
//                                  2 - NT Revision 1.0A
//

#define SAMP_MAJOR_REVISION            (0x00010000)
#define SAMP_MINOR_REVISION_V1_0       (0x00000001)
#define SAMP_MINOR_REVISION_V1_0A      (0x00000002)
#define SAMP_MINOR_REVISION            (0x00000002)

//
// SAMP_REVISION is the revision at which the database is created. This is several
// revisions below than the current revision as the database creation code has been
// kept unchanged from years of yore
//

#define SAMP_REVISION                  (SAMP_MAJOR_REVISION + SAMP_MINOR_REVISION)
#define SAMP_NT4_SERVER_REVISION       (SAMP_REVISION + 1)
#define SAMP_NT4SYSKEY_SERVER_REVISION (SAMP_REVISION + 2)
#define SAMP_NT4SP7_SERVER_REVISION    (SAMP_REVISION + 3)
#define SAMP_WIN2K_REVISION            (SAMP_REVISION + 4)

// 
// The below is the current revision; it corresponds to the fix for sysprep for
// re-encrypting keys.
//

#define SAMP_WHISTLER_OR_W2K_SYSPREP_FIX_REVISION  (SAMP_REVISION + 5)

//
// SAMP_SERVER_REVISION is the current revision for registry mode SAM.
//

#define SAMP_SERVER_REVISION           (SAMP_WHISTLER_OR_W2K_SYSPREP_FIX_REVISION)

//
// SAMP_DS_REVISION is the revision level maintained on the sam server object in the DS 
//

#define SAMP_WIN2K_DS_REVISION          1
#define SAMP_WHISTLER_DS_REVISION       2
#define SAMP_DS_REVISION                (SAMP_WHISTLER_DS_REVISION)

#define SAMP_UNKNOWN_REVISION( Revision )                  \
    ( ((Revision & 0xFFFF0000) > SAMP_MAJOR_REVISION)  ||  \
        (Revision > SAMP_SERVER_REVISION) )                \


//
// Maximum supported name length (in bytes) for this revision...
//

#define SAMP_MAXIMUM_NAME_LENGTH       (1024)

//
// Maximum length of a downlevel user name
//

#define SAMP_MAX_DOWN_LEVEL_NAME_LENGTH (20)


//
// Maximum amount of memory anyone can ask us to spend on a single
// request
//

#define SAMP_MAXIMUM_MEMORY_TO_USE     (4096*4096)


//
// Maximum allowable number of object opens.
// After this, opens will be rejected with INSUFFICIENT_RESOURCES
//

#define SAMP_PER_CLIENT_MAXIMUM_ACTIVE_CONTEXTS (2048)

//
// Maximum number of clients can open objects at the same time
// After this, opens will be rejected with INSUFFICIENT_RESOURCES
//  
#define SAMP_MAXIMUM_CLIENTS_COUNT      (1024)


//
// The number of SAM Local Domains
//

#define SAMP_DEFINED_DOMAINS_COUNT  ((ULONG)  2)


//
// Defines the maximum number of well-known (restricted) accounts
// in the SAM database. Restricted accounts have rids less than this
// value. User-defined accounts have rids >= this value.
//

#define SAMP_RESTRICTED_ACCOUNT_COUNT   SAMI_RESTRICTED_ACCOUNT_COUNT


//
// Maximum password history length.  We store OWFs (16 bytes) in
// a string (up to 64k), so we could have up to 4k.  However, that's
// much larger than necessary, and we'd like to leave room in case
// OWFs grow or somesuch.  So we'll limit it to 1k.
//

#define SAMP_MAXIMUM_PASSWORD_HISTORY_LENGTH    1024

//
// The default group attributes to return when anybody asks for them.
// This saves the expense of looking at the user object every time.
//


#define SAMP_DEFAULT_GROUP_ATTRIBUTES ( SE_GROUP_MANDATORY | \
                                        SE_GROUP_ENABLED | \
                                        SE_GROUP_ENABLED_BY_DEFAULT )

//
// This is the length in bytes of the session key used to encrypt secret
// (sensitive) information.
//

#define SAMP_SESSION_KEY_LENGTH 16

//
// Constants for encryption type. These constants control the behaviour
// SampEncryptSecretData and SampDecryptSecretData.
//
//   SAMP_NO_ENCRYPTION does no encryption. This is used in DS mode as
//   core DS is responsible for the encryption.
//
//   SAMP_DEFAULT_SESSION_KEY_ID indicates to SampEncryptSecretData 
//   that the encryption needs to be performed with using the Password
//   encryption key of registry mode SAM
//

#define SAMP_NO_ENCRYPTION              ((USHORT)0x0)
#define SAMP_DEFAULT_SESSION_KEY_ID     ((USHORT)0x01)

//
// This is the number of retries for entering the session key decryption key
//

#define SAMP_BOOT_KEY_RETRY_COUNT       3


//
// Flags for data stored in the encrypted form. The flags in the secret data
// structure are used to denote the various types of encryption algorithms/
// variations that have been implemented. A flags value of 0 corresponds to an
// RC4 encryption using an MD5 of the key and the RID. This type of encryption
// was introduced in NT 4.0 SP3.
//

//
// This flag specifies that the data encrypted did use different magic constants
// that correspond to the various encryption types below. This type of encryption
// does an MD5 with the key and the magic constant before doing an RC4 using the key
// and the data. This encryption was introduced in win2k and then backported to 
// NT 4.0 SP6a.
//
#define SAMP_ENCRYPTION_FLAG_PER_TYPE_CONST ((USHORT)0x1)

//
// This specifies the encrypted data type for various types of data that we
// expect to retrieve 
//

typedef enum _SAMP_ENCRYPTED_DATA_TYPE {
      LmPassword=1,
      NtPassword,
      LmPasswordHistory,
      NtPasswordHistory,
      MiscCredentialData
} SAMP_ENCRYPTED_DATA_TYPE;


//
// This is the mimumim number of history entries to store for the krbtgt
// account.
//

#define SAMP_KRBTGT_PASSWORD_HISTORY_LENGTH 3
#define SAMP_RANDOM_GENERATED_PASSWORD_LENGTH         16


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Each object has an associated set of attributes on disk.            //
// These attributes are divided into fixed-length and variable-length. //
// Each object type defines whether its fixed and variable length      //
// attributes are stored together or separately.                       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


#define SAMP_SERVER_STORED_SEPARATELY  (FALSE)

#define SAMP_DOMAIN_STORED_SEPARATELY  (TRUE)

#define SAMP_USER_STORED_SEPARATELY    (TRUE)

#define SAMP_GROUP_STORED_SEPARATELY   (FALSE)

#define SAMP_ALIAS_STORED_SEPARATELY   (FALSE)




///////////////////////////////////////////////////////////////////////////////
//
// Data structures used for tracking allocated memory
//
///////////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_MEMORY {
    struct _SAMP_MEMORY *Next;
    PVOID               Memory;
} SAMP_MEMORY, *PSAMP_MEMORY;



///////////////////////////////////////////////////////////////////////////////
//
// Data structures used for enumeration
//
///////////////////////////////////////////////////////////////////////////////


typedef struct _SAMP_ENUMERATION_ELEMENT {
    struct _SAMP_ENUMERATION_ELEMENT *Next;
    SAMPR_RID_ENUMERATION Entry;
} SAMP_ENUMERATION_ELEMENT, *PSAMP_ENUMERATION_ELEMENT;


///////////////////////////////////////////////////////////////////////////////
//
// Data structures related to service administration
//
///////////////////////////////////////////////////////////////////////////////

//
// SAM Service operation states.
// Valid state transition diagram is:
//
//    Initializing ----> Enabled <====> Disabled ---> Shutdown -->Terminating
//                               <====> Demoted  ---> Shutdown -->Terminating
//

typedef enum _SAMP_SERVICE_STATE {
    SampServiceInitializing = 1,
    SampServiceEnabled,
    SampServiceDisabled,
    SampServiceDemoted,
    SampServiceShutdown,
    SampServiceTerminating
} SAMP_SERVICE_STATE, *PSAMP_SERVICE_STATE;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//     Enumeration context associated with Enumerating Accounts in the       //
//     DS. This maintains the State Information regarding Paged Results      //
//     type of search in the DS, on a per domain context basis.              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


typedef struct _SAMP_DS_ENUMERATION_CONTEXT {

    // Used to Link to other Objects of this Type
    LIST_ENTRY              ContextListEntry;
    // Pointer to a DS Restart Structure
    PRESTART                Restart;
    // The Enumeration Handle associated with this structure.
    SAM_ENUMERATE_HANDLE    EnumerateHandle;
} SAMP_DS_ENUMERATION_CONTEXT, *PSAMP_DS_ENUMERATION_CONTEXT;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//   Display State Information used to speed up query of display information //
//   when clients want to download the entire display information            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_DS_DISPLAY_STATE {
    PRESTART        Restart;
    DOMAIN_DISPLAY_INFORMATION DisplayInformation;
    ULONG           TotalAvailable;
    ULONG           TotalEntriesReturned;
    ULONG           NextStartingOffset;
} SAMP_DS_DISPLAY_STATE;



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//   Structure used to communicate password information to the DS and back   //
//   into SAM so additional credentials can generated and applied            //
//   Note this structure must be contiguous in memory so that it can be      //
//   easily copied.                                                          //                                                                  //
///////////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_PASSWORD_UPDATE_INFO {

    // Is the clear text password present?
    BOOLEAN ClearPresent;

    // Password Data
    ULONG DataLength;        // length of password
    ULONG DataMaximumLength; // length of data
    DWORD Data[1];

}SAMP_PASSWORD_UPDATE_INFO, *PSAMP_PASSWORD_UPDATE_INFO;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Data structures associated with object types                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



//
// Object type-dependent information
//

typedef struct _SAMP_OBJECT_INFORMATION {

    //
    // Generic mapping for this object type
    //

    GENERIC_MAPPING GenericMapping;


    //
    // Mask of access types that are not valid for
    // this object type when the access mask has been
    // mapped from generic to specific access types.
    //

    ACCESS_MASK InvalidMappedAccess;


    //
    // Mask of accesses representing write operations.  These are
    // used on a BDC to determine if an operation should be allowed
    // or not.
    //

    ACCESS_MASK WriteOperations;

    //
    // Name of the object type - used for auditing.
    //

    UNICODE_STRING  ObjectTypeName;


    //
    // The following fields provide information about the attributes
    // of this object and how they are stored on disk.  These values
    // are set at SAM initialization time and are not changed
    // thereafter.  NOTE: changing these values in the build will
    // result in an on-disk format change - so don't change them 
    //
    //
    //      FixedStoredSeparately - When TRUE indicates the fixed and
    //          variable-length attributes of the object are stored
    //          separately (in two registry-key-attributes).  When FALSE,
    //          indicates they are stored together (in a single
    //          registry-key-attribute).
    //
    //
    //      FixedAttributesOffset - Offset from the beginning of the
    //          on-disk buffer to the beginning of the fixed-length
    //          attributes structure.
    //
    //      VariableBufferOffset - Offset from the beginning of the
    //          on-disk buffer to the beginning of the Variable-length
    //          data buffer.  If fixed and variable-length data are
    //          stored together, this will be zero.
    //
    //      VariableArrayOffset - Offset from the beginning of the
    //          on-disk buffer to the beginning of the array of
    //          variable-length attributes descriptors.
    //
    //      VariableDataOffset - Offset from the beginning of the
    //          on-disk buffer to the beginning of the variable-length
    //          attribute data.
    //

    BOOLEAN FixedStoredSeparately;
    ULONG FixedAttributesOffset,
          VariableBufferOffset,
          VariableArrayOffset,
          VariableDataOffset;

    //
    // Indicates the length of the fixed length information
    // for this object type.
    //

    ULONG FixedLengthSize;

    //
    // The following fields provide information about the attributes of this
    // object. Modifying SAM to utilize the DS as the backing store for domain
    // account information, while still using the registry backing store for
    // workstation account information, means that there are two similar, but
    // slightly different data representations for SAM account information.
    //
    // All account information is represented in memory in terms of the fixed
    // and variable-length data buffers (as defined in earlier versions of the
    // SAM library). The source of the information, however, has changed in
    // that domain-account information (i.e. Domain Controller accounts) comes
    // from the DS backing store.
    //
    // Consequently, there is no need to store KEY_VALUE_PARTIAL_INFORMATION
    // within the SAM buffer (because that is registry specific).
    //
    // Additionally, because some of the DS data types are different from the
    // types used in previous SAM implementations, buffer offsets and lengths
    // have changed from those stored in the registry, and mapped into memory
    // by SAM code.
    //
    // The upshot of this is that whenever SAM buffers, constructed from the
    // registry information are referenced, the above offsets (e.g. Fixed-
    // AttributesOffset) are used. Alternatively, whenever SAM buffers, con-
    // structed from DS information are referenced, the below offsets (e.g
    // FixedDsAttributesOffset) are used.
    //

    ULONG FixedDsAttributesOffset,
          FixedDsLengthSize,
          VariableDsBufferOffset,
          VariableDsArrayOffset,
          VariableDsDataOffset;

    //
    // Indicates the number of variable length attributes
    // for this object type.
    //

    ULONG VariableAttributeCount;


} SAMP_OBJECT_INFORMATION, *PSAMP_OBJECT_INFORMATION;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// The  following structures represent the in-memory body of each      //
// object type.  This is typically used to link instances of object    //
// types together, and track dynamic state information related to      //
// the object type.                                                    //
//                                                                     //
// This information does not include the on-disk representation of     //
// the object data.  That information is kept in a separate structure  //
// both on-disk and when in-memory.                                    //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// SERVER object in-memory body                                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_SERVER_OBJECT {
    ULONG Reserved1;
} SAMP_SERVER_OBJECT, *PSAMP_SERVER_OBJECT;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// DOMAIN object in-memory body                                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_DOMAIN_OBJECT {
    ULONG Reserved1;

    //
    // State information regarding the last display information reqest is
    // maintained in here. This is to allow fast restarts for clients that
    // want to download all the display information in one stroke
    //
    SAMP_DS_DISPLAY_STATE DsDisplayState;

} SAMP_DOMAIN_OBJECT, *PSAMP_DOMAIN_OBJECT;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// USER object in-memory body                                          //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_USER_OBJECT {
    ULONG   Rid;

    //
    // LockoutTime is set to the current time when an account becomes
    // locked out due to too many invalid password attempts. Lockout-
    // Time is set to zero when the account is unlocked.
    //

    LARGE_INTEGER   LockoutTime;

    //
    // LastLogonTimeStamp is set to the value of LastLogon if the
    // difference is greater than 7 days (or by any registry setting)
    // 

    LARGE_INTEGER   LastLogonTimeStamp;

    //
    // Supplemental credentials of a user object can be
    // cached in the context. The following 3 fields are
    // used to hold it
    //

    PVOID   CachedSupplementalCredentials;
    ULONG   CachedSupplementalCredentialLength;
    BOOLEAN CachedSupplementalCredentialsValid;

    //
    // Writes of supplemental credentials are held as a linked list
    // in this field and then combined with other writes when the
    // context is flushed to disk.
    //

    PSAMP_SUPPLEMENTAL_CRED SupplementalCredentialsToWrite;

    //
    // Old UserParameters Attribute, when doing UserParms Migration,
    // we are required to provide the old UserParms Value, so we cache
    // the old UserParms value and length at here.
    //

    PVOID   CachedOrigUserParms;
    ULONG   CachedOrigUserParmsLength;
    BOOLEAN CachedOrigUserParmsIsValid;

    //
    // Bit to keep an access check result, wether the
    // user has access to domain password information
    //
    BOOLEAN DomainPasswordInformationAccessible;

    //
    // Indicates that the context was returned as part of a machine,
    // account creation as a privilege. Such a context is only allowed
    // access to set only the password of the user described by the
    // context, as that is the only other operation in a machine join.
    //

    BOOLEAN PrivilegedMachineAccountCreate;

    //
    // Used to hold if user parms information is accessible ( bit to
    // to keep an access check result
    //

    BOOLEAN UparmsInformationAccessible;

    //
    // Pointer to the Domain SId, used by NT4 Security Descriptor to
    // NT5 SD Conversion Routine. In normal running, it should always be NULL.
    // Only set to point to the Domain SID during dcpromo time.
    //

    PSID    DomainSidForNt4SdConversion;

    //
    // Holds the UPN of the user
    //

    UNICODE_STRING  UPN;

    BOOLEAN UpnDefaulted;

    //
    // Information pertaining to the site affinity of a user.  Only used
    // in branch office scenarios
    //
    SAMP_SITE_AFFINITY SiteAffinity;

    //
    // Used to indicate whether a user handle should be checked for
    // site affinity.
    //
    BOOLEAN fCheckForSiteAffinityUpdate;

    //
    // This flag indicates that non-universal groups were not obtained
    // due to lack of a GC
    //
    BOOLEAN fNoGcAvailable;

    //
    // Information about the client location
    //
    SAM_CLIENT_INFO ClientInfo;

    //
    // A2D2 attribute ( A2D2 stands for authenticated to delegation to )
    // and this attribute is really an array  of SPN's.
    //

    PUSER_ALLOWED_TO_DELEGATE_TO_LIST A2D2List;
    BOOLEAN A2D2Present;

    //
    // SPN List -- Users and computers have SPN's and authentication
    // providers check those in here
    //

    PUSER_SPN_LIST SPNList;
    BOOLEAN  SPNPresent;

    //
    // Key version #
    //

    ULONG KVNO;
    BOOLEAN  KVNOPresent;

    //
    // Password infomation, if any
    //
    UNICODE_STRING PasswordInfo;

} SAMP_USER_OBJECT, *PSAMP_USER_OBJECT;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// GROUP object in-memory body                                         //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_GROUP_OBJECT {
    ULONG Rid;
    NT4_GROUP_TYPE NT4GroupType;
    NT5_GROUP_TYPE NT5GroupType;
    BOOLEAN        SecurityEnabled;
    ULONG          CachedMembershipOperationsListMaxLength;
    ULONG          CachedMembershipOperationsListLength;
    SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY   * CachedMembershipOperationsList;
} SAMP_GROUP_OBJECT, *PSAMP_GROUP_OBJECT;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// ALIAS object in-memory body                                         //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_ALIAS_OBJECT {
    ULONG Rid;
    NT4_GROUP_TYPE NT4GroupType;
    NT5_GROUP_TYPE NT5GroupType;
    BOOLEAN        SecurityEnabled;
    ULONG          CachedMembershipOperationsListMaxLength;
    ULONG          CachedMembershipOperationsListLength;
    SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY   * CachedMembershipOperationsList;

    ULONG          CachedNonMembershipOperationsListMaxLength;
    ULONG          CachedNonMembershipOperationsListLength;
    SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY   * CachedNonMembershipOperationsList;
} SAMP_ALIAS_OBJECT, *PSAMP_ALIAS_OBJECT;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
//                                                                     //
// The following data structure is the in-memory context associated    //
// with an open object.                                                //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _SAMP_OBJECT {


    //
    // Structure used to link this structure into lists
    //

    LIST_ENTRY ContextListEntry;

    //
    // Indicates the type of object stored.
    // This is used to access an array of object type descriptors.
    //

    SAMP_OBJECT_TYPE ObjectType;

    //
    // The FixedValid and VariableValid indicate whether the data in
    // the fixed and variable-length on-disk image buffers are valid
    // (i.e., were read from disk) or invalid (uninitialized).
    // TRUE indicates the attribute is valid, FALSE indicates it is not.
    //

    BOOLEAN FixedValid:1;
    BOOLEAN VariableValid:1;


    //
    // The following flags indicate whether the fixed and/or variable
    // length attributes portion of this object are dirty (i.e., have
    // been changed since read from disk).  If TRUE, then the data is
    // dirty and will have to be flushed upon commit.  These flags are
    // only meaningful if the corresponding FixedValid or VariableValid
    // flag is TRUE.
    //
    // When attributes are read from disk, the data is said to be
    // "clean".  If any changes are made to that data, then it is
    // said to be "dirty".  Dirty object attributes will be flushed
    // to disk when the object is de-referenced at the end of a
    // client call.
    //

    BOOLEAN FixedDirty:1;
    BOOLEAN VariableDirty:1;


    //
    // This field indicates a context block is to be deleted.
    // Actual deallocation of the memory for the context block
    // will not occur until the reference count drops to zero.
    //

    BOOLEAN MarkedForDelete:1;

    //
    // This field is used to indicate that the client associated with
    // this context block is to be fully trusted.  When TRUE, no access
    // checks are performed against the client.  This allows a single
    // interface to be used by both RPC clients and internal procedures.
    //

    BOOLEAN TrustedClient:1;

    //
    // This field indicates that the context handle was created to service
    // a SAM loopback request from the DS. This is similar to the trusted
    // bit in that no access checks are performed. However trusted by passes
    // many other consistency checks while loopback will not bypass them
    //

    BOOLEAN LoopbackClient:1;


    //
    // This flag is TRUE when this context is valid.  It may be necessary
    // to invalidate before we can eliminate all references to it due to
    // the way RPC works.  RPC will only allow you to invalidate a context
    // handle when called by the client using an API that has the context
    // handle as an OUT parameter.
    //
    // Since someone may delete a user or group object (which invalidates
    // all handles to that object), we must have a way of tracking handle
    // validity independent of RPC's method.
    //

    BOOLEAN Valid:1;

    ULONG   Signature;

    //
    // This flag, tells the SAM routines wether it is safe to avoid locking
    // the database before queries. This allows to multi-thread calls.
    // When a context is declared as thread safe it is not added to the list
    // of context's kept in memory ( the reason for the exclusion ).
    //

    BOOLEAN NotSharedByMultiThreads:1;

    //
    // This flag is used during new SAM Account Creation and 
    // existing Account Rename. It indicates whether the caller should 
    // remove the accoount name from the in memory SAM Account Name Table 
    // or not. 
    //

    BOOLEAN RemoveAccountNameFromTable:1;


    //
    // This Flag Tells the Commit code that a lazy flush is O.K
    //

    BOOLEAN LazyCommit:1;

    //
    // This flag indicates that it is ok to persist OnDiskData across
    // multiple SAM calls. Helps logon as logon providers like to open
    // a user handle and then query the handle multiple times.
    //

    BOOLEAN PersistAcrossCalls:1;


    //
    // This flag indicates that it is ok to buffer writes to the on disk
    // structure in the context. The actual write is then performed at close
    // handle time
    //

    BOOLEAN BufferWrites:1;

    //
    // This flag indicates to urgent replicate any change made in the context
    // when flushing its contents to the ds
    //
    BOOLEAN ReplicateUrgently:1;

    //
    // This flag indicates that the context is being opened by server side 
    // code internally in the LSA.
    //
    BOOLEAN OpenedBySystem:1;


    //
    // Indicates this context was opened as part of migrating a user from
    // registry SAM to DS as part of Dcpromo.
    //

    BOOLEAN OpenedByDCPromo:1;

    //
    // This flag indicates that only some of the attributes in the PVOID structure
    // in the context are valid.
    //

    BOOLEAN AttributesPartiallyValid:1;


    //
    // This is the set of per attribute valid bits. This is a 64 Bit integer
    // and can handle upto 64 attributes
    //

    RTL_BITMAP  PerAttributeInvalidBits;

    //
    // The Buffer where the per attribute dirty bits are stored
    //

    ULONG       PerAttributeInvalidBitsBuffer[MAX_SAM_ATTRS/sizeof(ULONG)];


    //
    // This is the set of per attribute dirty bits. This is a 64 Bit integer
    // and can handle upto 64 attributes
    //

    RTL_BITMAP  PerAttributeDirtyBits;

    //
    // The Buffer where the per attribute dirty bits are stored
    //

    ULONG       PerAttributeDirtyBitsBuffer[MAX_SAM_ATTRS/sizeof(ULONG)];

    //
    // This field points to the on-disk attributes of the object.  This
    // is one of:
    //               SAMP_ON_DISK_SERVER_OBJECT
    //               SAMP_ON_DISK_DOMAIN_OBJECT
    //               SAMP_ON_DISK_USER_OBJECT
    //               SAMP_ON_DISK_GROUP_OBJECT
    //               SAMP_ON_DISK_ALIAS_OBJECT
    //
    // The memory pointed to by this field is one allocation unit, even
    // if fixed and variable length attributes are stored as seperate
    // registry key attributes.  This means that any time additions to
    // the variable length attributes causes a new buffer to be allocated,
    // both the fixed and variable length portions of the structure must
    // be copied to the newly allocated memory.
    //

    PVOID OnDisk;


    //
    // The OnDiskAllocated, OnDiskUsed, and OnDiskFree fields describe the
    // memory pointed to by the OnDisk field.  The OnDiskAllocated field
    // indicates how many bytes long the block of memory is.  The OnDiskUsed
    // field indicates how much of the allocated memory is already in use.
    // The variable length attributes are all packed upon any modification
    // so that all free space is at the end of the block.  The OnDiskFree
    // field indicates how many bytes of the allocated block are available
    // for use (note that this should be Allocated minus Used ).
    //
    // NOTE: The allocated and used values will ALWAYS be rounded up to ensure
    //       they are integral multiples of 4 bytes in length.  This ensures
    //       any use of these fields directly will be dword aligned.
    //
    //       Also note that when the VariableValid flag is FALSE,
    //       then the then OnDiskUsed OnDiskFree do NOT contain valid
    //       values.
    //

    ULONG  OnDiskAllocated;
    ULONG  OnDiskUsed;
    ULONG  OnDiskFree;

    //
    // In DS mode it is possible to prefetch information such that the on disk is
    // only partially populated. If that happens and if a later an attribute is requested
    // that has not been populated in the OnDisk structure, we fetch the on disk structure
    // again from disk. However we do not want the free the existing OnDisk till the context
    // has been dereferenced as there is a lot of code that simply references data from the
    // on disk structure. We save the current value of on disk in this variable so that we
    // can free it later.
    //
    PVOID  PreviousOnDisk;



    //
    // Before a context handle may be used, it must be referenced.
    // This prevents the data from being deallocated from underneath it.
    //
    // Note, this count reflects one reference for the open itself, and
    // then another reference for each time the object is looked up or
    // subsequently referenced.  Therefore, a handle close should
    // dereference the object twice - once to counter the Lookup operation
    // and once to represent elimination of the handle itself.
    //

    ULONG ReferenceCount;



    //
    // This field indicates the accesses that the client has been granted
    // via this context.
    //

    ACCESS_MASK GrantedAccess;



    //
    // This handle is to the root registry key of the corresponding
    // object.  If this value is NULL, then the corresponding
    // object was created in a previous call, but has not yet been
    // opened.  This will only occur for USERS, GROUPS, and ALIASES
    // (and DOMAINS when we support DOMAIN creation).
    //

    HANDLE RootKey;

    //
    // This is the registry name of the corresponding object.  It is
    // set when the object is created, when RootKey is null.  It is
    // used to add the attributes changes out to the RXACT in the absence
    // of the RootKey.  After being used once, it is deleted - because
    // the next time the object is used, the LookupContext() will fill
    // in the RootKey.
    //

    UNICODE_STRING RootName;



    // The Following field indicates the name of the Object in the DS,
    // if the Object resides in the DS.

    DSNAME *ObjectNameInDs;

    //
    // The following field points to the ActiveContextCount element 
    // in SAM in-memory table. ActiveContextCount element contains
    // Client Sid and number of Contexts opened so far. 
    // By caching the pointer to the element
    // 
    // 1. we'll not need to lookup SID during de-reference. Instead, 
    //    we can decrement ref count directly.
    // 
    // 2. Don't need to impersonate client to get user SID even in 
    //    the case of client dies suddently.
    // 

    PVOID   ElementInActiveContextTable;


    // Defined Flags area as follows
    // SAMP_OBJ_FLAG_DS -- Determines whether the object is present in the DS
    // or in the Registry. If present in the Registry then the RootKey and Root
    // Name fields indicate the registry fields the object is associated
    // with. Else the ObjectNameInDs field indicates the object in the DS

    ULONG ObjectFlags;


    //
    // if the object is a DS object then this field contains the actual
    // object class of the object in the DS.
    //
    ULONG DsClassId;

    //
    // If the object is other than a Server object, then this field
    // contains the index of the domain the object is in.  This provides
    // access to thing