        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        SAFEIRELEASE( pRsopLinkObj );
        SAFEIRELEASE( pRsopLinkClass );
        SAFEIRELEASE( pRsopObj );

        // destroy the dynamic arrays
        DESTROY_ARRAY( arrAppliedData );
        DESTROY_ARRAY( arrFilteredData );

        return FALSE;
    }   

    SAFEIRELEASE( pRsopLinkObj );
    SAFEIRELEASE( pRsopLinkClass );
    SAFEIRELEASE( pRsopObj );
    
    return TRUE;
}

/*********************************************************************************************
Routine Description:
     This function Will delete the Rsop namespace created by method RsopCreateSession.

Arguments:
    [in] pClass         :   pointer to IWbemServices.   
    [in] CHString       :   string containing the RsopNamespace.  
    [in] pObject        :   pointer to IWbemClassObject.

Return Value:
  TRUE  - if SUCCESS
  FALSE - if ERROR
*********************************************************************************************/
BOOL RsopDeleteMethod( IWbemClassObject *pClass, CHString strNameSpace, 
                        IWbemServices *pNamespace )
{
    HRESULT                     hResult = S_OK;
    
    BOOL                        bResult  = FALSE; 
     
    IWbemClassObject            *pInClass = NULL;
    IWbemClassObject            *pInInst  = NULL;
    IWbemClassObject            *pOutInst = NULL;

    CHString                    strTemp;
    DWORD                        ulReturn=0;

    try
    {   
        // Check the input Parameters
        if( pClass == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        //Delete the resultant RSOP namespace as the snap shot
        //of RSOP has been obtained
        hResult = pClass->GetMethod( _bstr_t( FN_DELETE_RSOP ), 0, &pInClass, NULL );
        CHECK_HRESULT( hResult );

        hResult = pInClass->SpawnInstance( 0, &pInInst );
        CHECK_HRESULT( hResult );
        
        //Put the input parameter 
        hResult = PropertyPut( pInInst, FPR_RSOP_NAMESPACE, strNameSpace );
        CHECK_HRESULT( hResult );

        // All The required properties are set so, execute method RsopDeleteSession
        hResult = pNamespace->ExecMethod( _bstr_t( CLS_DIAGNOSTIC_PROVIDER ), 
                                            _bstr_t( FN_DELETE_RSOP ), 
                                            0, NULL, pInInst, &pOutInst, NULL );
        if(pOutInst == NULL)
        {
            hResult = E_FAIL;
        }
        if( FAILED( hResult ) )
        {
            // display the error msg
            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );

            // release the interface pointers and exit
            SAFEIRELEASE(pInClass);
            SAFEIRELEASE(pInInst);
            SAFEIRELEASE(pOutInst);

            return FALSE;
        } 
        //Get returned paramter to check whether the method was successfull
        bResult = PropertyGet( pOutInst, FPR_RETURN_VALUE, ulReturn, 0);
        CHECK_BRESULT( bResult );

        // Returns some ERROR code.
        if( ulReturn != 0 )
        {
            // Show Error Message
            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );
            bResult = FALSE;
        }
        bResult = TRUE;
    }
    catch( _com_error & error ) 
    {
        // display the error message and set the return value to FALSE
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
        bResult = FALSE;
    }

    // release the interface pointers and exit 
    SAFEIRELEASE(pInClass);
    SAFEIRELEASE(pInInst);
    SAFEIRELEASE(pOutInst);

    return bResult;
}

/*********************************************************************************************
Routine Description:

    This function gets the OS information and fills the array with the same
     
Arguments:
 
    [in] PUSERINFO      pUserInfo       :   Structure containing the user information.

Return Value:
 
    TRUE  on SUCCESS
    FALSE on FAILURE
*********************************************************************************************/
BOOL CGpResult::GetOsInfo( PUSERINFO pUserInfo )
{
    // Local variables
    HRESULT                         hResult = S_OK;

    BOOL                            bResult = FALSE;
    BOOL                            bDone = FALSE;

    IEnumWbemClassObject            *pEnumClass = NULL;
    IWbemClassObject                *pClass = NULL;

    ULONG                           ulReturn = 0;
    DWORD                           dwDomainRole = 0;

    CHString                        strTemp;

    try
    {
        // print the progress message
        PrintProgressMsg( m_hOutput, GetResString( IDS_GET_OSINFO ), m_csbi );

        // Enumerate the instances to get the domain and site names of the Win32 NT domain
        hResult = m_pWbemServices->CreateInstanceEnum( _bstr_t( CLS_WIN32_OS ),
                                                        WBEM_FLAG_FORWARD_ONLY | 
                                                        WBEM_FLAG_RETURN_IMMEDIATELY,
                                                        NULL, &pEnumClass );
        CHECK_HRESULT( hResult );
        
        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, m_pAuthIdentity );
        CHECK_HRESULT( hResult );

        // get the data
        hResult = pEnumClass->Next( WBEM_INFINITE, 1, &pClass, &ulReturn );
        CHECK_HRESULT( hResult );

        // get the OS version
        bResult = PropertyGet( pClass, CPV_OS_VERSION, pUserInfo->strOsVersion, 
                                V_NOT_AVAILABLE );
        CHECK_BRESULT( bResult );

        // get the OS type
        bResult = PropertyGet( pClass, CPV_OS_CAPTION, pUserInfo->strOsType, 
                                V_NOT_AVAILABLE );
        CHECK_BRESULT( bResult );

        // enumerate the instances of Win32_ComputerSystem class 
        hResult = m_pWbemServices->CreateInstanceEnum( _bstr_t( CLS_WIN32_CS ),
                                                        WBEM_FLAG_RETURN_IMMEDIATELY | 
                                                        WBEM_FLAG_FORWARD_ONLY, 
                                                        NULL, &pEnumClass );
        
        // check the result of enumeration
        CHECK_HRESULT( hResult );
    
        // set the security on the obtained interface
        hResult = SetInterfaceSecurity( pEnumClass, m_pAuthIdentity );
        CHECK_HRESULT( hResult );

        // get the enumerated objects information
        // NOTE: This needs to be traversed only one time. 
        hResult = pEnumClass->Next( WBEM_INFINITE, 1, &pClass, &ulReturn );
        CHECK_HRESULT( hResult );

        // get the OS config
        bResult = PropertyGet( pClass, CPV_DOMAIN_ROLE, dwDomainRole );
        CHECK_BRESULT( bResult );

        // get the domain name information for later use
        hResult = PropertyGet( pClass, CPV_DOMAIN, m_strADSIDomain );
        CHECK_BRESULT( bResult );

        // get the server name for future use by LDAP
        hResult = PropertyGet( pClass, CPV_NAME, m_strADSIServer );
        CHECK_BRESULT( bResult );

        // 
        // Mapping information of Win32_ComputerSystem's DomainRole property
        // NOTE: Refer to the _DSROLE_MACHINE_ROLE enumeration values in DsRole.h header file
        switch( dwDomainRole )
        {
        case DsRole_RoleStandaloneWorkstation:
            pUserInfo->strOsConfig = VALUE_STANDALONEWORKSTATION;
            break;
        case DsRole_RoleMemberWorkstation:
            pUserInfo->strOsConfig = VALUE_MEMBERWORKSTATION;
            break;
            
        case DsRole_RoleStandaloneServer:
            pUserInfo->strOsConfig = VALUE_STANDALONESERVER;
            break;
            
        case DsRole_RoleMemberServer:
            pUserInfo->strOsConfig = VALUE_MEMBERSERVER;
            break;
            
        case DsRole_RoleBackupDomainController:
            pUserInfo->strOsConfig = VALUE_BACKUPDOMAINCONTROLLER;
            break;
            
        case DsRole_RolePrimaryDomainController:
            pUserInfo->strOsConfig = VALUE_PRIMARYDOMAINCONTROLLER;
            break;

        default:
            break;
        }
    }
    catch(  _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        // release the allocated variables
        SAFEIRELEASE( pEnumClass );
        SAFEIRELEASE( pClass );
        
        return FALSE;
    }
    catch( CHeap_Exception )
    {
        // display the error message
        SetLastError( E_OUTOFMEMORY );
        SaveLastError();
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }


    // release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );
        
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    This function displays the security groups for system and user
     
Arguments:
 
    IWbemServices       :   pointer to the name space 
    BOOL                :   set to TRUE if the system o/p is to be displayed

Return Value:
 
    None   
*********************************************************************************************/
VOID CGpResult::DisplaySecurityGroups( IWbemServices *pNameSpace, BOOL bComputer )
{
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;

    ULONG                       ulReturned = 0;
    LONG                        lLBound = 0;
    LONG                        lUBound = 0;

    DWORD                       dwLength = 0;
    
    IWbemClassObject            *pClass = NULL;
    IWbemClassObject            *pName = NULL;
    IWbemClassObject            *pDomain = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;
    IEnumWbemClassObject        *pEnumDomain = NULL;
        
    VARIANT                     vVarVerbose;
    VARTYPE                     vartype;
    
    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    TCHAR                       szQueryString[ MAX_STRING_LENGTH ];
    CHString                    strTemp;
    CHString                    strDomain;
    
    SAFEARRAY                   *safeArray = NULL;
    
    try
    {
        ZeroMemory( szTemp, sizeof( szTemp ) );
        ZeroMemory( szQueryString, sizeof( szQueryString ) );

        // Enumerate the classes for the user privelege rights
        hResult = pNameSpace->CreateInstanceEnum( _bstr_t( CLS_RSOP_SESSION ),
                                                    WBEM_FLAG_FORWARD_ONLY |
                                                    WBEM_FLAG_RETURN_IMMEDIATELY, 
                                                    NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, m_pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }
                
                break;
            }
            bGotClass = TRUE;

            // Get the security groups
            if( bComputer == TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_SYS_SG ) );
                ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );
                for( dwLength = lstrlen( GetResString( IDS_SYS_SG ) ); dwLength > 4; dwLength-- )
                {
                    ShowMessage( stdout, GetResString( IDS_DASH ) );
                }
                ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_USER_SG ) );
                ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );
                for( dwLength = lstrlen( GetResString( IDS_USER_SG ) ); dwLength > 4; dwLength-- )
                {
                    ShowMessage( stdout, GetResString( IDS_DASH ) );
                }
                ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
            }
            
            VariantInit( &vVarVerbose );

            hResult = pClass->Get( _bstr_t(CPV_SEC_GRPS), 0, &vVarVerbose, 0, 0 );
            CHECK_HRESULT_VAR( hResult, vVarVerbose );

            if( vVarVerbose.vt != VT_NULL && vVarVerbose.vt != VT_EMPTY )
            {
                // get the type of the elements in the safe array
                vartype = V_VT( &vVarVerbose ) & ~VT_ARRAY;

                //get the array of strings in to the safe array from the variant
                safeArray = (SAFEARRAY *)vVarVerbose.parray;

                //get the number of elements (subkeys)
                if( safeArray != NULL )
                {
                    hResult = SafeArrayGetLBound( safeArray, 1, &lLBound );
                    CHECK_HRESULT( hResult );

                    hResult = SafeArrayGetUBound( safeArray, 1, &lUBound );
                    CHECK_HRESULT( hResult );
                }
                for( ; lLBound <= lUBound; lLBound++ )
                {
                    bResult = GetPropertyFromSafeArray( safeArray, lLBound, strTemp, vartype );
                    CHECK_BRESULT( bResult );
                    
                    // Got a sid, now get it's coressponding name
                    // form the object path using the SID
                    wsprintf( szTemp, OBJECT_PATH, strTemp );

                    // Get the object
                    hResult = m_pWbemServices->GetObject( _bstr_t( szTemp ), 0, NULL, &pName, NULL );
                    CHECK_HRESULT( hResult );

                    // Get the Account name
                    bResult = PropertyGet( pName, CPV_ACCOUNT_NAME, strTemp, V_NOT_AVAILABLE );

                    // Append the appropriate prefix
                    if( strTemp.Compare( _T( "ANONYMOUS LOGON" ) ) == 0 
                                || strTemp.Compare( _T( "BATCH" ) ) == 0
                                || strTemp.Compare( _T( "DIALUP" ) ) == 0
                                || strTemp.Compare( _T( "INTERACTIVE" ) ) == 0
                                || strTemp.Compare( _T( "SERVICE" ) ) == 0
                                || strTemp.Compare( _T( "SYSTEM" ) ) == 0
                                || strTemp.Compare( _T( "TERMINAL SERVICE USER" ) ) == 0
                                || strTemp.Compare( _T( "PROXY" ) ) == 0
                                || strTemp.Compare( _T( "NETWORK" ) ) == 0
                                || strTemp.Compare( _T( "ENTERPRISE DOMAIN CONTROLLERS" ) ) == 0
                                || strTemp.Compare( _T( "Authenticated Users" ) ) == 0
                                || strTemp.Compare( _T( "RESTRICTED" ) ) == 0
                                || strTemp.Compare( _T( "SELF" ) ) == 0 )
                    {
                        ShowMessage( stdout, _T( "NT AUTHORITY\\" ) );
                    }
                    else if( strTemp.Compare( _T( "Administrators" ) ) == 0 
                                || strTemp.Compare( _T( "Backup Operators" ) ) == 0
                                || strTemp.Compare( _T( "Guests" ) ) == 0
                                || strTemp.Compare( _T( "Power Users" ) ) == 0
                                || strTemp.Compare( _T( "Replicator" ) ) == 0
                                || strTemp.Compare( _T( "Pre-Windows 2000 Compatible Access" ) ) == 0
                                || strTemp.Compare( _T( "Users" ) ) == 0 )
                    {
                        ShowMessage( stdout, _T( "BUILTIN\\" ) );
                    }
                                        
                    ShowMessage( stdout, strTemp );
                    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
                }
            }
            else
            {
                ShowMessage( stdout, V_NOT_AVAILABLE );
                ShowMessage( stdout, NEW_LINE );
            }

            VariantClear(&vVarVerbose);
        }
    }
    
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        VariantClear(&vVarVerbose);
    }

    // release the interface pointers
    SAFEIRELEASE(pEnumClass);
    SAFEIRELEASE(pEnumDomain);
    SAFEIRELEASE(pClass);
    SAFEIRELEASE(pName);
    SAFEIRELEASE(pDomain);

    return;
}

/*********************************************************************************************
Routine Description:

    This function gets the link speed information
     
Arguments:
 
    IWbemServices       :   pointer to the name space. 
    COAUTHIDENTITY      :   pointer to the AuthIdentity structure.

Return Value:
 
    None   
*********************************************************************************************/
VOID DisplayLinkSpeed( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity )
{
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    BOOL                        bTemp = FALSE;

    ULONG                       ulReturned = 0;
    
    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;
    
    CHString                    strTemp;

    VARIANT                     vVarTemp;
    
    try
    {
        // Get the pointer to ennumerate with
        hResult = pNameSpace->CreateInstanceEnum( _bstr_t( CLS_RSOP_SESSION ),
                                                    WBEM_FLAG_FORWARD_ONLY |
                                                    WBEM_FLAG_RETURN_IMMEDIATELY,
                                                    NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );
        
        // Enumerate the classes one by one and get the data
        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            bGotClass = TRUE;

            VariantInit( &vVarTemp );
            hResult = pClass->Get( _bstr_t( CPV_SLOW_LINK ), 0, &vVarTemp, 0, 0 );
            CHECK_HRESULT_VAR( hResult, vVarTemp );

            ShowMessage( stdout, GetResString( IDS_LINK_SPEED ) );
            if( vVarTemp.vt != VT_NULL )
            {
                bTemp = vVarTemp.boolVal;
                if( bTemp == VAR_TRUE )
                {
                    ShowMessage( stdout, GetResString( IDS_YES ) );
                }
                else
                {
                    ShowMessage( stdout, GetResString( IDS_NO ) );
                }   
            }
            else
            {
                ShowMessage( stdout, V_NOT_AVAILABLE );
            }

            ShowMessage( stdout, NEW_LINE );
            VariantClear( &vVarTemp );
        }// while
    }
    catch(_com_error & error)
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        VariantClear( &vVarTemp );
    }

    // release the interface pointers
    SAFEIRELEASE(pEnumClass);
    SAFEIRELEASE(pClass);
    
    return;
}

/*********************************************************************************************
Routine Description:

     This function gets the User name and the domain name from WMI..
     
Arguments:
 
    [in]    szSid           :   string containing the SID
    [out]   szName          :   string to hold the user name
    [out]   szDomain        :   string to hold the domain name

Return Value:
 
    TRUE  on SUCCESS
    FALSE on FAILURE
*********************************************************************************************/
BOOL CGpResult::GetUserNameFromWMI( TCHAR szSid[], TCHAR szName[], TCHAR szDomain[] )
{
    // Local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    BOOL                        bGotDomainInfo = FALSE;
    BOOL                        bUserSpecified = FALSE;

    TCHAR                       szQueryString[ MAX_QUERY_STRING ];
    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    CHString                    strTemp = NULL_STRING;
    
    IEnumWbemClassObject        *pEnumClass = NULL;
    IWbemClassObject            *pClass =  NULL;

    ULONG                       ulReturn = 0;

    try
    {
        // set the strings to NULL
        ZeroMemory( szQueryString, MAX_QUERY_STRING * sizeof( TCHAR ));
        ZeroMemory( szTemp, MAX_STRING_LENGTH * sizeof( TCHAR ) );

        // Form the query string
        lstrcpy( szTemp, QUERY_USER_NAME );
        FORMAT_STRING( szQueryString, szTemp, szSid );
        
        // execute the respective query
        hResult = m_pWbemServices->ExecQuery( _bstr_t( QUERY_LANGUAGE ), 
                                                _bstr_t( szQueryString ), 
                                                WBEM_FLAG_FORWARD_ONLY | 
                                                WBEM_FLAG_RETURN_IMMEDIATELY,
                                                NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // set the security parameters
        hResult = SetInterfaceSecurity( pEnumClass, m_pAuthIdentity );
        CHECK_HRESULT( hResult );
        
        // Get the user name
        hResult = pEnumClass->Next( TIME_OUT_NEXT, 1, &pClass, &ulReturn );
        CHECK_HRESULT( hResult );
            
        // if there are no classes to enumerate break out of the loop
        if( ulReturn == 0 )
        {
            // No classes were retrieved....display msg
            // release the interface pointers and exit
            SAFEIRELEASE( pClass );
            SAFEIRELEASE( pEnumClass );

            return FALSE;

        }
            
        // Get the class property(Name)
        bResult = PropertyGet( pClass, CPV_NAME, strTemp, V_NOT_AVAILABLE );
        CHECK_BRESULT( bResult );

        // Got the name...Store it.
        lstrcpy( szName, strTemp );
            
        // Get and add the domain name if it exists
        bResult = PropertyGet( pClass, CPV_DOMAIN, strTemp, V_NOT_AVAILABLE );
        CHECK_BRESULT( bResult );

        if( strTemp.Compare( V_NOT_AVAILABLE ) != 0 )
        {
            // Got the domain name...Store it.
            lstrcpy( szDomain, strTemp );
        }
    }
    catch(  _com_error & error )
    {
        // erase the last status message
        PrintProgressMsg( m_hOutput, NULL, m_csbi );

        // display the error msg
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        // release the interface pointers and exit
        SAFEIRELEASE( pClass );
        SAFEIRELEASE( pEnumClass );

        return FALSE;
    }

    // release the interface pointers and exit
    SAFEIRELEASE( pClass );
    SAFEIRELEASE( pEnumClass );

    return TRUE;
}

/*********************************************************************************************
Routine Description:

    This function gets the threshold link speed information.
     
Arguments:
 
    [in] BOOL   :   set to TRUE if the information is to be retrieved for the computer.

Return Value:
 
    TRUE  on SUCCESS
    FALSE on FAILURE
*********************************************************************************************/
BOOL CGpResult::DisplayThresholdSpeedAndLastTimeInfo( BOOL bComputer )
{
    // Local variables
    HRESULT                 hResult = S_OK;

    HKEY                    hKey = NULL;
    HKEY                    hRemoteKey = NULL;

    IWbemServices           *pDefaultNameSpace = NULL;

    TCHAR                   szTemp[ MAX_STRING_LENGTH ];
    TCHAR                   szServer[ MAX_STRING_LENGTH ];
    TCHAR                   szName[ MAX_STRING_LENGTH ];
    TCHAR                   szTime[ MAX_STRING_LENGTH ];
    TCHAR                   szDate[ MAX_STRING_LENGTH ];

    BOOL                    bResult = FALSE;
    BOOL                    bLocaleChanged = FALSE;
    BOOL                    bConnFlag = TRUE;

    CHString                strTemp;

    DWORD                   dwHkey = 0;
    DWORD                   dwValue;
    DWORD                   dwResult = 0;

    FILETIME                ftWrite;
    FILETIME                ftLocal;

    SYSTEMTIME              systime;

    LCID                    lcid;

    try
    {
        // If we have to get the information from a remote machine then...
        // connect to the remote machine for the last time execution information.
        if ( m_bLocalSystem == FALSE )
        {
            lstrcpy( szServer, m_strServerName );
            lstrcpy( szName, m_strUserName );
            
            bResult = EstablishConnection( szServer, szName, MAX_STRING_LENGTH, 
                                            m_pwszPassword, MAX_STRING_LENGTH, FALSE );
            if( bResult != TRUE )
            {
                strTemp = V_NOT_AVAILABLE;
            }
            else
            {
                switch( GetLastError() )
                {
                    case I_NO_CLOSE_CONNECTION:
                        bConnFlag = FALSE;
                        break;
 
                    case E_LOCAL_CREDENTIALS:
                    case ERROR_SESSION_CREDENTIAL_CONFLICT:
                        bConnFlag = FALSE;
                        break;

                    default:
                        break;
                }
            }
        
            // Connect to the remote registry
            lstrcpy( szServer , _T( "\\\\" ) );
            lstrcat( szServer, m_strServerName );
            dwResult = RegConnectRegistry( szServer, bComputer ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER,
                                            &hRemoteKey );
            if( dwResult != ERROR_SUCCESS )
            {
                strTemp = V_NOT_AVAILABLE;
            }
        }

        // Open the last time execution information key
        dwResult = RegOpenKeyEx (bComputer ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER, 
                                    GROUPPOLICY_PATH, 0, KEY_READ, &hKey);


        if( dwResult != ERROR_SUCCESS )
        {
            strTemp = V_NOT_AVAILABLE;
        }

        // Get the last time execution information
        dwResult = RegQueryInfoKey( hKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 
                                    NULL, &ftWrite );

        if( dwResult == ERROR_SUCCESS )
        {
            FileTimeToLocalFileTime( &ftWrite, &ftLocal );
            FileTimeToSystemTime( &ftLocal, &systime );


            // verify whether console supports the current locale 100% or not
            lcid = GetSupportedUserLocale( bLocaleChanged );

            // get the formatted date
            GetDateFormat( lcid, 0, &systime, ((bLocaleChanged == TRUE) ? L"MM/dd/yyyy" : NULL), 
                            szDate, SIZE_OF_ARRAY( szDate ) );
            
            // now format the date
            GetTimeFormat( LOCALE_USER_DEFAULT, 0, &systime, ((bLocaleChanged == TRUE) ? L"HH:mm:ss" : NULL), 
                            szTime, SIZE_OF_ARRAY( szTime ) );

            wsprintf( szTemp, LAST_TIME_OP, szDate, szTime );
            strTemp = szTemp;
        }
        else
        {
            strTemp = V_NOT_AVAILABLE;
        }

        // Display the retrieved data
        ShowMessage( stdout, GetResString( IDS_LAST_TIME ) );
        ShowMessage( stdout, strTemp );
        ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );

        // if we have opened a connection then close the same.
        if( m_bLocalSystem == FALSE && bConnFlag == TRUE )
        {
            lstrcpy( szServer, m_strServerName );
            CloseConnection( szServer );
        }

        // Close the registry keys
        if( hKey != NULL )
        {
            RegCloseKey( hKey );
        }
        if( hRemoteKey != NULL )
        {
            RegCloseKey( hRemoteKey );
        }

        // connect to the default namespace
        ConnectWmi( m_pWbemLocator, &pDefaultNameSpace, m_strServerName, 
                    m_strUserName, m_pwszPassword, &m_pAuthIdentity,
                    FALSE, _bstr_t( ROOT_DEFAULT ), &hResult );
        CHECK_HRESULT( hResult );

        // form the key
        if( bComputer == TRUE )
        {           
            dwHkey = HKEY_DEF;
        }
        else
        {
            dwHkey = HKEY_CURRENT_USER_DEF;
        }

        // Get the DC name from where the policy was applied last
        RegQueryValueWMI( pDefaultNameSpace, dwHkey, APPLIED_PATH, FPR_APPLIED_FROM, 
                            strTemp, V_NOT_AVAILABLE );
        
        // remove the forward slashes (UNC) if exist in the begining of the server name
        if ( IsUNCFormat( strTemp ) == TRUE )
        {
            strTemp = strTemp.Mid( 2 );
        }

        // Display the retrieved data
        ShowMessage( stdout, GetResString( IDS_APPLIED_FROM ) );
        ShowMessage( stdout, strTemp );
        ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );

        // Get the threshold link speed information
        RegQueryValueWMI( pDefaultNameSpace, dwHkey, GPRESULT_PATH, FPR_LINK_SPEED_VALUE, dwValue, -1 );
        if( dwValue == -1 )
        {
            strTemp = DEFAULT_LINK_SPEED;
        }
        else
        {
            FORMAT_STRING( szTemp, _T( "%d kbps" ), dwValue );
            strTemp = szTemp;
        }

        // Display the retrieved data
        ShowMessage( stdout, GetResString( IDS_THRESHOLD_LINK_SPEED ) );
        ShowMessage( stdout, strTemp );
        ShowMessage( stdout, NEW_LINE );
    }
    catch(  _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        // release the allocated variables
        SAFEIRELEASE( pDefaultNameSpace );
    
        return FALSE;
    }
    catch( CHeap_Exception )
    {
        // display the error message
        SetLastError( E_OUTOFMEMORY );
        SaveLastError();
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }

    // release the interface pointer
    SAFEIRELEASE( pDefaultNameSpace );

    return TRUE;
}

/*********************************************************************************************
Routine Description: 

    This function checks if the current locale is supported or not.

Arguments: 

    [in] bLocaleChanged

Return Value: 

    LCID of the current locale.
*********************************************************************************************/
LCID GetSupportedUserLocale( BOOL& bLocaleChanged )
{
    // local variables
    LCID lcid;

    // get the current locale
    lcid = GetUserDefaultLCID();

    // check whether the current locale is supported by our tool or not
    // if not change the locale to the english which is our default locale
    bLocaleChanged = FALSE;
    if ( PRIMARYLANGID( lcid ) == LANG_ARABIC || PRIMARYLANGID( lcid ) == LANG_HEBREW ||
         PRIMARYLANGID( lcid ) == LANG_THAI   || PRIMARYLANGID( lcid ) == LANG_HINDI  ||
         PRIMARYLANGID( lcid ) == LANG_TAMIL  || PRIMARYLANGID( lcid ) == LANG_FARSI )
    {
        bLocaleChanged = TRUE;
        lcid = MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_DEFAULT ), SORT_DEFAULT ); // 0x409;
    }

    // return the locale
    return lcid;
}

/*********************************************************************************************
Routine Description: 

    This function sorts the applied Gpo data in the order applied.

Arguments: 

    [in/out] TARRAY     :   Array to be sorted

Return Value: 

    None
*********************************************************************************************/
VOID SortAppliedData( TARRAY arrAppliedData )
{
    // Local variables
    TARRAY          arrSortedData = NULL;

    DWORD           dwMax = 0;
    DWORD           dwCount = 0;
    DWORD           dwi = 0;
    DWORD           dwOrder = 0;
    DWORD           dwIndex = 0;

    // Create the dynamic array to hold the sorted data temporarily
    arrSortedData = CreateDynamicArray( );

    dwCount = DynArrayGetCount( arrAppliedData );

    // Get the max applied order in the array
    for( dwi = 0; dwi < dwCount; dwi++ )
    {
        dwOrder = DynArrayItemAsDWORD2( arrAppliedData, dwi, COL_ORDER );
        if( dwOrder > dwMax )
        {
            dwMax = dwOrder;
        }
    }

    // Create the sorted array in the descending order of the applied order
    for( dwi = 0; dwi < dwCount; dwi++ )
    {
        // re-set the index variable
        dwIndex = 0;

        // Get the index of the row whose order = dwMax
        while( TRUE )
        {
            dwOrder = DynArrayItemAsDWORD2( arrAppliedData, dwIndex, COL_ORDER );
            if( dwOrder == dwMax )
            {
                break;
            }

            // increment the index
            dwIndex++;

            // Additional check...just in case the order does not exist
            // avoid an AV
            if( dwIndex == dwCount )
            {
                break;
            }
        }

        // Additional check...just in case the order does not exist
        // avoid an AV
        if( dwIndex == dwCount )
        {
            // could not find the index
            // decrement the max order
            dwMax--;

            continue;
        }

        // Store the contents of the row
        DynArrayAppendRow( arrSortedData, COL_MAX );
        DynArraySetString2( arrSortedData, dwi, COL_DATA, 
                            DynArrayItemAsString2( arrAppliedData, dwIndex, COL_DATA ), 0 );
        DynArraySetDWORD2( arrSortedData, dwi, COL_ORDER, dwOrder );

        // decrement the max order
        dwMax--;
    }

    // copy the sorted data onto the applied data array
    for( dwi = 0; dwi < dwCount; dwi++ )
    {
        DynArraySetString2( arrAppliedData, dwi, COL_DATA, 
                            DynArrayItemAsString2( arrSortedData, dwi, COL_DATA ), 0 );
        DynArraySetDWORD2( arrAppliedData, dwi, COL_ORDER, 
                            DynArrayItemAsDWORD2( arrSortedData, dwi, COL_ORDER ) );
    }

    // destroy the temporarily created dynamic array
    DESTROY_ARRAY( arrSortedData );

    return;
}

/*********************************************************************************************
Routine Description: 

    This function retrieves the FQDN from ADSI

Arguments: 

    [out] TCHAR []      :   Array to hold the FQDN
    [in]  BOOL          :   flag to specify wether the FQDN is to be retrieved for
                            the computer or the user
    [in] LPCTSTR        :   The name for whom the FQDN is to be retrieved

Return Value: 

    None
*********************************************************************************************/
VOID CGpResult::GetFQDNFromADSI( TCHAR szFQDN[], BOOL bComputer, LPCTSTR pszName )
{
    // Local variables
    HRESULT                 hResult = S_OK;
    
    HANDLE                  hDS = NULL;

    DWORD                   dwReturn = 0;

    DS_NAME_RESULT          *pNameResult = NULL;
    
    ZeroMemory( szFQDN, MAX_STRING_LENGTH * sizeof( TCHAR ) );



    // Bind to the ADSI directory service
    dwReturn = DsBindWithCred( NULL, m_strADSIDomain, m_pAuthIdentity, &hDS );
    if( dwReturn != NO_ERROR )
    {
        return;
    }

    // Get the FQDN information
    dwReturn = DsCrackNames( hDS, DS_NAME_NO_FLAGS, 
                             bComputer ? DS_DISPLAY_NAME : DS_NT4_ACCOUNT_NAME, DS_FQDN_1779_NAME,
                             1, &pszName, &pNameResult );
    if( dwReturn != NO_ERROR )
    {
        return;
    }

    // store the retrieved FQDN
    lstrcpy( szFQDN, pNameResult->rItems->pName );

    // Free the handle to the ADSI directory services
    DsUnBind( &hDS );

    // Free the allocated memory
    DsFreeNameResult( pNameResult );
    return;
}

BOOL CGpResult::CreateRsopMutex( LPWSTR szMutexName )
{
    BOOL bResult = FALSE;
    SECURITY_ATTRIBUTES sa;
    PSECURITY_DESCRIPTOR psd = NULL;

    //
    // first try to open the mutex object by its name
    // if that fails it means the mutex is not yet created and 
    // so create it now
    //
    m_hMutex = OpenMutex( SYNCHRONIZE, FALSE, szMutexName );
    if ( m_hMutex == NULL )
    {
        // check the error code why it failed to open
        if ( GetLastError() == ERROR_FILE_NOT_FOUND )
        {
            // create the security descriptor -- just set the 
            // Dicretionary Access Control List (DACL)
            // in order to provide security, we will deny WRITE_OWNER and WRITE_DAC
            // permission to Everyone except to the owner 
             bResult = ConvertStringSecurityDescriptorToSecurityDescriptor( 
                 L"D:(D;;WOWD;;;WD)(A;;GA;;;WD)", SDDL_REVISION_1, &psd, NULL );
            if ( bResult == FALSE )
            {
                // we encountered error while creating a security descriptor
                SaveLastError();
                ShowMessage( stderr, GetResString(IDS_ERROR) );
                ShowMessage( stderr, GetReason() );
                return FALSE;
            }

            // initialize the SECURITY_ATTRIBUTES structure
            SecureZeroMemory( &sa, sizeof( SECURITY_ATTRIBUTES ) );
            sa.nLength = sizeof( SECURITY_ATTRIBUTES );
            sa.lpSecurityDescriptor = psd;
            sa.bInheritHandle = FALSE;

            // mutex doesn't exist -- so we need to create it now
            m_hMutex = CreateMutex( &sa, FALSE, szMutexName );
            if (m_hMutex == NULL )
            {
                // we are not able to create the mutex
                // cannot proceed furthur
                SaveLastError();
                ShowMessage( stderr, GetResString(IDS_ERROR) );
                ShowMessage( stderr, GetReason() );
                return FALSE;
            }
            LocalFree(psd);
        }
        else
        {
            // we encounter some error 
            // cannot proceed furthur
            SaveLastError();
            ShowMessage( stderr, GetResString(IDS_ERROR) );
            ShowMessage( stderr, GetReason() );
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\gpresult\pch.h ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
// 
//      pch.h 
//  
//  Abstract:
//  
//      pre-compiled header declaration
//      files that has to be pre-compiled into .pch file
//  
//  Author:
//  
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000
//  
//  Revision History:
//  
//    Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000 : Created It.
//  
// *********************************************************************************

#ifndef __PCH_H
#define __PCH_H

#pragma once        // include header file only once

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

//
// Private nt headers.
//
extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <ntexapi.h>
    #include <Security.h>
    #include <SecExt.h>
}

//
// public Windows header files
//
#include <windows.h>
#include <winperf.h>
#include <wbemidl.h>
#include <chstring.h>
#include <comdef.h>
#include <wbemtime.h>
#include <tchar.h>
#include <wbemidl.h>
#include <wbemprov.h>
#include <winerror.h>
#include <dsgetdc.h>
#include <lm.h>
#include <dsrole.h>                 // domain role information
#include <Sddl.h>                   // Sid conversion functions
#include <activeds.h>
#include <Ntdsapi.h>
#include <userenv.h>

//
// public C header files
//
#include <stdio.h>
#include <string.h>
#include <crtdbg.h>

//
// private Common header files
//
#include "cmdlineres.h"
#include "cmdline.h"

#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\gpresult\verboseloggingdata.cpp ===
/*********************************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

    VerboseLoggingData.cpp

Abstract: 
    
    The verbose data is displayed in this module.
 
Author:

    Wipro Technologies

Revision History:

    22-Feb-2001 : Created It.

*********************************************************************************************/ 

#include "pch.h"
#include "GpResult.h"
#include "WMI.h"
#include "VerboseLoggingData.h"

/*********************************************************************************************
Routine Description:

     This function displays the verbose data for the  scope - computer
     
Arguments:

    [in]    IWbemServices   *pRsopNameSpace     :   interface pointer

Return Value:
 
    TRUE  on SUCCESS
    FALSE on FAILURE
   
*********************************************************************************************/
BOOL CGpResult::DisplayVerboseComputerData( IWbemServices *pNameSpace )
{
    DWORD           dwLength = 0;

    //
    // Display the verbose information for the scope - computer 

    // Display the header
    ShowMessage( stdout, GetResString( IDS_COMPUTER_RESULT ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );
    for( dwLength = lstrlen( GetResString( IDS_COMPUTER_RESULT ) ); dwLength > 4; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    ShowMessage( stdout, NEW_LINE );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );

    // Display the software installations
    ShowMessage( stdout, GetResString( IDS_SW_SETTINGS ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_SW_SETTINGS ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplaySoftwareInstallations( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );
    
    // Display the start-up data    
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SSU ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_WS_SSU ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplayScripts( pNameSpace, TRUE, m_pAuthIdentity, m_bSuperVerbose );
    
    // Display the shut-down data  
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SSD ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_WS_SSD ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplayScripts( pNameSpace, FALSE, m_pAuthIdentity, m_bSuperVerbose );
    
    // Display the password policy
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_AP_PP ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_WS_SS_AP_PP ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplayPasswordPolicy( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );
    
    // Display the Audit Policy
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_LP_AP ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_WS_SS_LP_AP ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplayAuditPolicy( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );
    
    // Display the user rights
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_LP_URA ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_WS_SS_LP_URA ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplayUserRights( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );
    
    // Display the security options
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_LP_SO ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_WS_SS_LP_SO ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplaySecurityandEvents( pNameSpace, CLS_SECURITY_BOOLEAN, m_pAuthIdentity, m_bSuperVerbose );
    DisplaySecurityandEvents( pNameSpace, CLS_SECURITY_STRING, m_pAuthIdentity, m_bSuperVerbose );
    
    // Display the event log information
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_EL ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_WS_SS_EL ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplaySecurityandEvents( pNameSpace, CLS_EVENTLOG_NUMERIC, m_pAuthIdentity, m_bSuperVerbose );
    DisplaySecurityandEvents( pNameSpace, CLS_EVENTLOG_BOOLEAN, m_pAuthIdentity, m_bSuperVerbose );

    // Display the restricted groups information
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_RG ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_WS_SS_RG ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplayRestrictedGroups( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );

    // Display the system services information
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_SS ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_WS_SS_SS ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplaySystemServices( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );
    
    // Display the registry information
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_REG ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_WS_SS_REG ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplayRegistryandFileInfo( pNameSpace, CLS_REGISTRY, m_pAuthIdentity, m_bSuperVerbose );
    
    // Display the file information
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_FS ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_WS_SS_FS ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplayRegistryandFileInfo( pNameSpace, CLS_FILE, m_pAuthIdentity, m_bSuperVerbose );
    
    // Display the public key policies
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_PKP ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_WS_SS_PKP ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
    ShowMessage( stdout, V_NOT_AVAILABLE );
    ShowMessage( stdout, NEW_LINE );

    // Display the administrative templates
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_ADTS_ERS ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_ADTS_ERS ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplayTemplates( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );

    return TRUE;
}

/*********************************************************************************************
Routine Description

    This function displays the software installations for the system or user
    
Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.  
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure.
    [in] BOOL               bSuperVerbose   :   is set to TRUE if the super verbose
                                                information is to be displayed.

Return Value:

    None
*********************************************************************************************/
VOID DisplaySoftwareInstallations( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                                    BOOL bSuperVerbose )
{
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bFlag = FALSE;
    BOOL                        bGotClass = FALSE;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;
    
    CHString                    strTemp;

    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    TCHAR                       szQueryString [ MAX_STRING_LENGTH ];

    ULONG                       ulReturned  = 0;
    DWORD                       dwTemp = 0;
    
    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        ZeroMemory( szTemp, sizeof( szTemp ) );
        ZeroMemory( szQueryString, sizeof( szQueryString ) );

        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            lstrcpy( szTemp, QUERY_SUPER_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_SOFTWARE );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            lstrcpy( szTemp, QUERY_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_SOFTWARE );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ), 
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );
        
        // Enumerate the classes one by one and get the data
        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );
            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            bGotClass = TRUE;

            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            lstrcpy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ) );

            // Display the GPO name
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );       

            // Got the class.....get the name of the installable
            bResult = PropertyGet( pClass, CPV_APP_NAME, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_APP_NAME ) );
            ShowMessage( stdout, strTemp );

            // Get the version number
            bResult = PropertyGet( pClass, CPV_VER_HI, dwTemp, 0 );
            CHECK_BRESULT( bResult );
            
            wsprintf( szTemp, _T( "%u" ), dwTemp );
            lstrcat( szTemp, _T( "." ) );
            ShowMessage( stdout, GetResString( IDS_APP_VERSION ) );
            ShowMessage( stdout, szTemp );
               
            bResult = PropertyGet( pClass, CPV_VER_LO, dwTemp, 0 );
            CHECK_BRESULT( bResult );
            
            wsprintf( szTemp, _T( "%u" ), dwTemp );
            ShowMessage( stdout, szTemp );

            // Get the Deployment state
            bResult = PropertyGet( pClass, CPV_DEPLOY_STATE, dwTemp, 0 );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_DEPLOY_STATE ) );
            switch( dwTemp )
            {
                case 1:      ShowMessage( stdout, GetResString( IDS_ASSIGNED ) );
                                break;
                case 2:     ShowMessage( stdout, GetResString( IDS_PUBLISHED ) );
                                break;
                default:    ShowMessage( stdout, V_NOT_AVAILABLE );
                                break;
            }

            // Get the Deployment state
            bResult = PropertyGet( pClass, CPV_APP_SRC, strTemp, 0 );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_APP_SRC ) );
            ShowMessage( stdout, strTemp );

            // Get the auto-install information
            bResult = PropertyGet( pClass, CPV_AUTO_INSTALL, dwTemp, 2 );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_AUTOINSTALL ) );
            if( dwTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_TRUE ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_FALSE ) );
            }
                        
            // Get the origin information
            ShowMessage( stdout, GetResString( IDS_ORIGIN ) );
            bResult = PropertyGet( pClass, CPV_ORIGIN, dwTemp, 0 );
            CHECK_BRESULT( bResult );

            switch( dwTemp )
            {
                case 1:     ShowMessage( stdout, GetResString( IDS_APPLICATION ) );
                                break;
                case 2:     ShowMessage( stdout, GetResString( IDS_REMOVED ) );
                                break;
                case 3:     ShowMessage( stdout, GetResString( IDS_ARP ) );
                                break;
                default:    ShowMessage( stdout, V_NOT_AVAILABLE );
                                break;
            }

            ShowMessage( stdout, NEW_LINE );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }

    // release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );
    
    return;
}

/*********************************************************************************************
Routine Description

    This function displays the scripts policy setting for both start-up and 
    shut-down.
 
Arguments:

    [in] IWbemServices      *pNamespace     :  pointer to IWbemServices.  
    [in] BOOL               bScriptFlag     :   script type.
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose 
                                                info is to be displayed..

Return Value:

    None
*********************************************************************************************/
VOID DisplayScripts( IWbemServices *pNameSpace, BOOL bStartUp, 
                      COAUTHIDENTITY *pAuthIdentity, BOOL bSuperVerbose )
{
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    BOOL                        bLocaleChanged = FALSE;
    
    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;
    IWbemClassObject            *pScriptObject = NULL;
    
    VARIANT                     vVarScript;
    VARTYPE                     vartype;

    SAFEARRAY                   *safeArray = NULL;

    CHString                    strTemp;

    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    TCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    
    ULONG                       ulReturned  = 0;
    LONG                        lLBound = 0;
    LONG                        lUBound = 0;
    
    SYSTEMTIME                  SysTime;

    LCID                        lcid;

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        ZeroMemory( szTemp, sizeof( szTemp ) );
        ZeroMemory( szQueryString, sizeof( szQueryString ) );

        if( bStartUp == TRUE )
        {
            lstrcpy( szTemp, QUERY_START_UP );
        }
        else
        {
            lstrcpy( szTemp, QUERY_SHUT_DOWN );
        }

        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            FORMAT_STRING( szQueryString, szTemp, CLS_SCRIPTS );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            FORMAT_STRING( szQueryString, szTemp, CLS_SCRIPTS );
            lstrcat( szQueryString, QUERY_ADD_VERBOSE );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ), 
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult ); 

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );
        
        // Enumerate the classes one by one and get the data
        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            bGotClass = TRUE;
            
            // Get the GPO id...
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            // Display the GPO name
            lstrcpy( szTemp, strTemp );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp,  pAuthIdentity );

            // Get the script list
            VariantInit( &vVarScript );
            hResult = pClass->Get( _bstr_t( CPV_SCRIPTLIST ), 0, &vVarScript, 0, 0 );
            CHECK_HRESULT_VAR( hResult, vVarScript );
            
            if( vVarScript.vt != VT_NULL && vVarScript.vt != VT_EMPTY )
            {
                // get the type of the elements in the safe array
                vartype = V_VT( &vVarScript ) & ~VT_ARRAY;

                // Get the array of script objects into a safe array
                safeArray = ( SAFEARRAY * )vVarScript.parray;
                
                //get the number of subkeys
                if( safeArray != NULL )
                {
                    hResult = SafeArrayGetLBound( safeArray, 1, &lLBound );
                    CHECK_HRESULT( hResult ); 
                    
                    hResult = SafeArrayGetUBound( safeArray, 1, &lUBound );
                    CHECK_HRESULT( hResult );
                }

                // Get the identifier values for each sub-key
                for( ; lLBound <= lUBound; lLBound++ )
                {
                    // Get the script object interface pointer...
                    bResult = GetPropertyFromSafeArray( safeArray, lLBound, &pScriptObject, vartype );
                    CHECK_BRESULT( bResult );
                    
                    // Get the script...
                    bResult = PropertyGet( pScriptObject, CPV_SCRIPT, strTemp, V_NOT_AVAILABLE );
                    CHECK_BRESULT( bResult );

                    ShowMessage( stdout, GetResString( IDS_NAME ) );
                    ShowMessage( stdout, strTemp );
                    
                    // Get the arguments...
                    bResult = PropertyGet( pScriptObject, CPV_ARGUMENTS, strTemp, 
                                            V_NOT_AVAILABLE );
                    CHECK_BRESULT( bResult );

                    ShowMessage( stdout, GetResString( IDS_PARAMETERS ) );
                    ShowMessage( stdout, strTemp );
                    
                    // Get the execution time...
                    bResult = PropertyGet( pScriptObject, CPV_EXECTIME, strTemp, 
                                                        V_NOT_AVAILABLE );
                    CHECK_BRESULT( bResult );
                    
                    ShowMessage( stdout, GetResString( IDS_LASTEXECUTED ) );
                    // Check if the str is zero 
                    if( strTemp.Compare( ZERO ) == 0 )
                    {
                        ShowMessage( stdout, GetResString( IDS_NOT_EXECUTED ) );
                    }
                    else
                    {
                        bResult = PropertyGet( pScriptObject, CPV_EXECTIME, SysTime );
                        CHECK_BRESULT( bResult );

                        // verify whether console supports the current locale 100% or not
                        lcid = GetSupportedUserLocale( bLocaleChanged );

                        // now format the date
                        GetTimeFormat( LOCALE_USER_DEFAULT, 0, 
                                        &SysTime, ((bLocaleChanged == TRUE) ? L"HH:mm:ss" : NULL), 
                                        szTemp, SIZE_OF_ARRAY( szTemp ) );

                        ShowMessage( stdout, szTemp );
                    }
                    ShowMessage( stdout, NEW_LINE );
               }//end for safearray 
            }
            else
            {
                ShowMessage( stdout, V_NOT_AVAILABLE );
                ShowMessage( stdout, NEW_LINE );

                V_VT( &vVarScript ) = VT_EMPTY;
            }
                            
            VariantClear(&vVarScript);
        }// while
    }
    catch(_com_error & error)
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        VariantClear( &vVarScript );
    }

    // release the interface pointers
    SAFEIRELEASE(pEnumClass);
    SAFEIRELEASE(pClass);
    SAFEIRELEASE(pScriptObject);
    
    return;
}

/*********************************************************************************************
Routine Description
 This function displays the password policy for the computer configuration
 
Arguments:
    
    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.  
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose 
                                                info is to be displayed..

Return Value:
  
    None
*********************************************************************************************/
VOID DisplayPasswordPolicy( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                            BOOL bSuperVerbose )
{
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
        
    ULONG                       ulReturned = 0;
    
    CHString                    strTemp;
    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    TCHAR                       szQueryString [ MAX_STRING_LENGTH ];

    IWbemClassObject            *pClass         = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;
    
    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        ZeroMemory( szTemp, sizeof( szTemp ) );
        ZeroMemory( szQueryString, sizeof( szQueryString ) );
        
        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            lstrcpy( szTemp, QUERY_SUPER_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_PASSWD_POLICY );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            lstrcpy( szTemp, QUERY_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_PASSWD_POLICY );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ), 
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        if(FAILED( hResult ) ) 
        {
            _com_issue_error( hResult );
        }

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }
    
                break;
            }
            bGotClass = TRUE;

            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );
        
            // Display the GPO name
            lstrcpy( szTemp, strTemp );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );

            // get the key name
            bResult = PropertyGet( pClass, CPV_KEYNAME1, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );
        
            ShowMessage(stdout, GetResString( IDS_POLICY ) );
            ShowMessage(stdout, strTemp);
    
            // get the setting
            bResult = PropertyGet( pClass, CPV_SETTING1, ulReturned, 0 );
            CHECK_BRESULT( bResult );

            ShowMessage(stdout, GetResString( IDS_COMPUTER_SETTING ) );
            if( ulReturned == 0)
            {
                ShowMessage( stdout, V_NOT_AVAILABLE );
            }
            else
            {
                DISPLAY_MESSAGE1( stdout, szTemp, _T( "%u" ), ulReturned );
            }

            ShowMessage( stdout, NEW_LINE );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }    

    // release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );
   
    return;
}

/*********************************************************************************************
Routine Description

    This function displays the Audit policy for the computer configuration.

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.  
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose 
                                                info is to be displayed..

Return Value:
    
    None
*********************************************************************************************/
VOID DisplayAuditPolicy( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                            BOOL bSuperVerbose )
{
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    BOOL                        bTemp = FALSE;

    DWORD                       dwNoAuditing = 0;
    DWORD                       dwTemp = 0;

    ULONG                       ulReturned = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;
    
    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    TCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        ZeroMemory( szTemp, sizeof( szTemp ) );
        ZeroMemory( szQueryString, sizeof( szQueryString ) );
        
        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            lstrcpy( szTemp, QUERY_SUPER_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_AUDIT_POLICY );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            lstrcpy( szTemp, QUERY_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_AUDIT_POLICY );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ), 
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }
                
                break;
            }
            bGotClass = TRUE;
            
            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );
            
            // Get the GPO output
            lstrcpy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ) );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );

            // Get the category...
            bResult = PropertyGet( pClass, CPV_CATEGORY, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_POLICY ) );
            ShowMessage( stdout, strTemp );
            ShowMessage( stdout, GetResString( IDS_COMPUTER_SETTING ) );

            // Get the success property
            bResult = PropertyGet( pClass, CPV_SUCCESS, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            if( bTemp == VAR_TRUE )
            {
                ShowMessage( stdout, CPV_SUCCESS );
            }
            else
            {
                dwNoAuditing++;
            }
            
            // Get the failure property
            bResult = PropertyGet( pClass, CPV_FAILURE, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            if( bTemp == VAR_TRUE )
            {
                // Check if the success property is also set
                if ( dwNoAuditing == 0 )
                {
                    ShowMessage( stdout, _T( ", " ) );
                }
                ShowMessage( stdout, CPV_FAILURE );
            }
            else
            {
                dwNoAuditing++;
            }
            
            if( dwNoAuditing == 2 )
            {
                ShowMessage( stdout, GetResString( IDS_NO_AUDITING ) );
            }
            
            dwNoAuditing = 0;
            ShowMessage( stdout, NEW_LINE );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }
    catch( CHeap_Exception )
    {
        SetLastError( E_OUTOFMEMORY );
        SaveLastError();
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }

    // release the interface pointers
    SAFEIRELEASE(pEnumClass);
    SAFEIRELEASE(pClass);

    return;
}

/*********************************************************************************************
Routine Description

    To get the User Rights Assignment policy for the output display-
    [Computer Configuration\Security Setting\Local Policies\User Rights Assignment]

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.  
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose 
                                                info is to be displayed..

Return Value:
  
    None
*********************************************************************************************/
VOID DisplayUserRights( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                        BOOL bSuperVerbose )
{
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;

    ULONG                       ulReturned = 0;
    LONG                        lLBound = 0;
    LONG                        lUBound = 0;
    
    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    VARIANT                     vVarVerbose;
    VARTYPE                     vartype;
    
    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    TCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;
    
    SAFEARRAY                   *safeArray = NULL;
    
    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        ZeroMemory( szTemp, sizeof( szTemp ) );
        ZeroMemory( szQueryString, sizeof( szQueryString ) );
        
        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            lstrcpy( szTemp, QUERY_SUPER_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_USER_RIGHTS );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            lstrcpy( szTemp, QUERY_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_USER_RIGHTS );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ), 
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }
                
                break;
            }
            bGotClass = TRUE;

            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            lstrcpy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ) );

            // Display the GPO name
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );

            // Get the user rights
            VariantInit( &vVarVerbose );
            bResult = PropertyGet( pClass, CPV_USERRIGHT, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            strTemp = strTemp.Mid( ( strTemp.Find( EXTRA ) + 1 ), strTemp.GetLength() );    
            ShowMessage( stdout, GetResString( IDS_POLICY ) );
            ShowMessage( stdout, strTemp );

            // Get the computer setting
            ShowMessage( stdout, GetResString( IDS_COMPUTER_SETTING ) );
            hResult = pClass->Get( _bstr_t( CPV_ACCOUNTLIST ), 0, &vVarVerbose, 0, 0 );
            CHECK_HRESULT_VAR( hResult, vVarVerbose );

            if( vVarVerbose.vt != VT_NULL && vVarVerbose.vt != VT_EMPTY )
            {
                // get the type of the elements in the safe array
                vartype = V_VT( &vVarVerbose ) & ~VT_ARRAY;

                //get the array of strings in to the safe array from the variant
                safeArray = (SAFEARRAY *)vVarVerbose.parray;

                //get the number of elements (subkeys)
                if( safeArray != NULL )
                {
                    hResult = SafeArrayGetLBound( safeArray, 1, &lLBound );
                    CHECK_HRESULT( hResult );

                    hResult = SafeArrayGetUBound( safeArray, 1, &lUBound );
                    CHECK_HRESULT( hResult );  
                }
                for( ; lLBound <= lUBound; lLBound++ )
                {
                    // Get the element from the safe array
                    bResult = GetPropertyFromSafeArray( safeArray, lLBound, strTemp, vartype );
                    CHECK_BRESULT( bResult );
                    
                    if( strTemp.GetLength() == 0 )
                    {
                        ShowMessage( stdout, V_NOT_AVAILABLE );      
                    }
                    else
                    {
                        ShowMessage( stdout, strTemp );
                    }
                    ShowMessage( stdout, GetResString( IDS_NEWLINE1 ) );
                }
            }
            else
            {
                ShowMessage( stdout, V_NOT_AVAILABLE );
                ShowMessage( stdout, NEW_LINE );
            }

            VariantClear(&vVarVerbose);
        }
    }
    
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        VariantClear(&vVarVerbose);
    }
    catch( CHeap_Exception )
    {
        SetLastError( E_OUTOFMEMORY );
        SaveLastError();
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        VariantClear(&vVarVerbose);
    }

    // release the interface pointers
    SAFEIRELEASE(pEnumClass);
    SAFEIRELEASE(pClass);

    return;
}

/*********************************************************************************************
Routine Description

    To get the GPO name from the GPOID in the instance of any RSOP class

Arguments:

    [in] IWbemServices          *pNamespace     :   pointer to IWbemServices.  
    [in] LPTSTR                     lpszGpoid               :   GPO id. 
    [in] COAUTHIDENTITY *pAuthIdentity      :   pointer to the authorization structure
    
Return Value:
  
    None
*********************************************************************************************/
VOID GpoName(IWbemServices *pNameSpace, LPTSTR lpszGpoId, 
                          COAUTHIDENTITY *pAuthIdentity)
{
    HRESULT                                    hResult = S_OK; 

    BOOL                                           bResult = FALSE;
    
    IWbemClassObject                      *pClass = NULL;
    IEnumWbemClassObject               *pEnumClass = NULL;
    
    ULONG                                        ulReturned = 0;
    
    TCHAR                                         szQuery[ MAX_STRING_LENGTH ];
    CHString                                      strTemp;

    try
    {
        ZeroMemory( szQuery, sizeof( szQuery ) );

        // Form the query string
        wsprintf( szQuery, QUERY_GPO_NAME, lpszGpoId );

        // Eexecute the query to get the corressponding Gpo Name.
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ), 
                                                                _bstr_t( szQuery ), 
                                                                WBEM_FLAG_FORWARD_ONLY |
                                                                WBEM_FLAG_RETURN_IMMEDIATELY,
                                                                NULL, &pEnumClass);
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
        CHECK_HRESULT( hResult );

        if( ulReturned == 0 )
        {
            // Did not get the data we were looking for...
            // Display N/A if there were no classes
            ShowMessage( stdout, V_NOT_AVAILABLE );
            
            // Release the interface pointers
            SAFEIRELEASE(pEnumClass);
            SAFEIRELEASE(pClass);
            
            return;
        }
        
       // Found the GPO.....get the name
       bResult = PropertyGet( pClass, CPV_GPO_NAME, strTemp, V_NOT_AVAILABLE );
       CHECK_BRESULT( bResult );
                
       ShowMessage( stdout, strTemp );
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

    }

    // Release the interface pointers
    SAFEIRELEASE(pEnumClass);
    SAFEIRELEASE(pClass);

    return;
}

/*********************************************************************************************
Routine Description

    This function displays the Security Options or Eventlog instances for the 
    computer configuration.
    
Arguments:

    [in] pNamespace         :   pointer to IWbemServices.  
    [in] pszClassName       :   classname to retrieve data from.
    [in] pAuthIdentity      :   pointer to the Authorization structure
    [in] BOOL               :   set to TRUE if the super verbose info is to be displayed
        
Return Value:

    None
*********************************************************************************************/
VOID DisplaySecurityandEvents( IWbemServices *pNameSpace, BSTR pszClassName, 
                                COAUTHIDENTITY *pAuthIdentity, BOOL bSuperVerbose )
{
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;

    ULONG                       ulReturned = 0;
    DWORD                       dwTemp = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;
      
    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    TCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        ZeroMemory( szTemp, sizeof( szTemp ) );
        ZeroMemory( szQueryString, sizeof( szQueryString ) );
        
        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            lstrcpy( szTemp, QUERY_SUPER_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, pszClassName );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            lstrcpy( szTemp, QUERY_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, pszClassName );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ), 
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    // Check if this is the Security string class or the eventlog boolean class
                    // so that we can avoid multiple N/A's.
                    if( ( lstrcmp( pszClassName, CLS_EVENTLOG_BOOLEAN ) != 0 ) 
                            && ( lstrcmp( pszClassName, CLS_SECURITY_STRING ) != 0 ) )
                    {
                        ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                        ShowMessage( stdout, V_NOT_AVAILABLE );
                        ShowMessage( stdout, NEW_LINE );
                    }
                }

                break;
            }
            bGotClass = TRUE;

            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            lstrcpy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ) );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );

            // Get the key name
            bResult = PropertyGet( pClass, CPV_KEYNAME1, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );
            
            ShowMessage(stdout, GetResString( IDS_POLICY ) );
            ShowMessage( stdout, strTemp );
            
            // Get the setting
            if( lstrcmp( pszClassName, CLS_SECURITY_STRING ) == 0 )
            {
                bResult = PropertyGet( pClass, CPV_SETTING1, strTemp, V_NOT_AVAILABLE );
            }
            else
            {
                bResult = PropertyGet( pClass, CPV_SETTING1, dwTemp, 0 );
            }
            CHECK_BRESULT( bResult );
            
            ShowMessage( stdout, GetResString( IDS_COMPUTER_SETTING ) );
            if( lstrcmp( pszClassName, CLS_EVENTLOG_NUMERIC ) == 0 )
            {
                wsprintf( szTemp, _T( "%u" ), dwTemp );
                ShowMessage( stdout, szTemp );
            }
            else if( lstrcmp( pszClassName, CLS_SECURITY_STRING ) == 0 )
            {
                if( strTemp.Compare( V_NOT_AVAILABLE ) != 0 )
                {
                    ShowMessage( stdout, GetResString( IDS_ENABLED ) );
                }
                else 
                {
                    ShowMessage( stdout, GetResString( IDS_NOT_ENABLED ) );
                }
            }
            else
            {
                if( dwTemp == VAR_TRUE )
                {
                    ShowMessage( stdout, GetResString( IDS_ENABLED ) );
                }
                else 
                {
                    ShowMessage( stdout, GetResString( IDS_NOT_ENABLED ) );
                }
            }
            
            // Get the log name
            if( ( lstrcmp( pszClassName, CLS_SECURITY_BOOLEAN ) != 0 ) 
                    && ( lstrcmp( pszClassName, CLS_SECURITY_STRING ) != 0 ) )
            {
                bResult = PropertyGet( pClass, CPV_TYPE, dwTemp, 5 );
                CHECK_BRESULT( bResult );
                
                ShowMessage( stdout, GetResString( IDS_LOG_NAME ) );
                switch( dwTemp )
                {
                    case 0:      ShowMessage( stdout, GetResString( IDS_SYSTEM ) );
                                     break;
                    case 1:      ShowMessage( stdout, GetResString( IDS_SECURITY ) );
                                     break;
                    case 2:      ShowMessage( stdout, GetResString( IDS_APP_LOG ) );
                                     break;
                    default:    ShowMessage( stdout, V_NOT_AVAILABLE );
                                     break;
               }
            }

            ShowMessage( stdout, NEW_LINE );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );
    
    return;
}

/*********************************************************************************************
Routine Description
 
    Function to display the Restricted Groups policy for computer configuration

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.  
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure.
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose 
                                                info is to be displayed.
    
Return Value:
  
    None
*********************************************************************************************/
VOID DisplayRestrictedGroups( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                                BOOL bSuperVerbose )
{
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    
    ULONG                       ulTemp = 0;
    DWORD                       dwTemp = 0;
    ULONG                       ulReturned = 0;
    LONG                        lLBound = 0;
    LONG                        lUBound = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    VARIANT                     vVarVerbose;
    VARTYPE                     vartype;

    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    TCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;
    
    SAFEARRAY                   *safeArray      = NULL;
    
    
    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }
        
        ZeroMemory( szTemp, sizeof( szTemp ) );
        ZeroMemory( szQueryString, sizeof( szQueryString ) );
        
        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            lstrcpy( szTemp, QUERY_SUPER_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_RESTRICTED_GROUPS );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            lstrcpy( szTemp, QUERY_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_RESTRICTED_GROUPS );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ), 
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next instance
            hResult = pEnumClass->Next( WBEM_INFINITE, 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more instances to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }
                
                break;
            }
            bGotClass = TRUE;
            
            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            lstrcpy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ) );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );       

            // Get the group name
            bResult = PropertyGet( pClass, CPV_GROUP, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );
            
            ShowMessage( stdout, GetResString( IDS_GROUPNAME ) );
            ShowMessage( stdout, strTemp );
            
            // Get the members of the group
            VariantInit( &vVarVerbose );
            ShowMessage( stdout, GetResString( IDS_MEMBERS ) );
            hResult = pClass->Get( _bstr_t( CPV_MEMBERS ), 0, &vVarVerbose, 0, 0 );
            CHECK_HRESULT_VAR( hResult, vVarVerbose );

            if( vVarVerbose.vt != VT_NULL && vVarVerbose.vt != VT_EMPTY )
            {
                // get the type of the elements in the safe array
                vartype = V_VT( &vVarVerbose ) & ~VT_ARRAY;

                //get the array of strings in to the safe array from the variant
                safeArray = ( SAFEARRAY * )vVarVerbose.parray;
                
                //get the number of elements (subkeys)
                if( safeArray != NULL )
                {
                    hResult = SafeArrayGetLBound( safeArray, 1, &lLBound );
                    CHECK_HRESULT( hResult );
                    
                    hResult = SafeArrayGetUBound( safeArray, 1, &lUBound );
                    CHECK_HRESULT( hResult );  
                }
                
                for( ; lLBound <= lUBound; lLBound++ )
                {
                    // Get the element from the safe array
                    bResult = GetPropertyFromSafeArray( safeArray, lLBound, strTemp, vartype );
                    CHECK_BRESULT( bResult );
                    
                    if( strTemp.GetLength() == 0 )
                    {
                        ShowMessage( stdout, V_NOT_AVAILABLE );
                    }
                    else
                    {
                        ShowMessage( stdout, strTemp );
                    }
                    ShowMessage( stdout, GetResString( IDS_NEWLINE2 ) );
                }
            }
            else
            {
                ShowMessage( stdout, V_NOT_AVAILABLE );
            }

            VariantClear( &vVarVerbose );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        VariantClear( &vVarVerbose );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );
    
    return;
}

/*********************************************************************************************
Routine Description
 
    This function displays the System Services policy for the computer configuration

Arguments:
    
    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.  
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure.
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose 
                                                info is to be displayed.
    
Return Value:
 
    None
*********************************************************************************************/
VOID DisplaySystemServices( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                            BOOL bSuperVerbose )
{
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;

    DWORD                       dwTemp = 0;
    ULONG                       ulReturned = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    TCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;
      
    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        ZeroMemory( szTemp, sizeof( szTemp ) );
        ZeroMemory( szQueryString, sizeof( szQueryString ) );
        
        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            lstrcpy( szTemp, QUERY_SUPER_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_SYSTEM_SERVICES );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            lstrcpy( szTemp, QUERY_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_SYSTEM_SERVICES );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ), 
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next instance
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }
                
                break;
            }
            bGotClass = TRUE;
            
            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            lstrcpy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ) );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );       

            // Get the service information
            bResult = PropertyGet( pClass, CPV_SERVICE, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage(stdout, GetResString( IDS_SERVICENAME ) );
            ShowMessage( stdout, strTemp );
            
            ShowMessage(stdout, GetResString( IDS_STARTUP ) );
            bResult = PropertyGet( pClass, CPV_STARTUP, dwTemp, 0 );
            CHECK_BRESULT( bResult );

            switch( dwTemp )
            {
                case 2:     ShowMessage( stdout, GetResString( IDS_AUTOMATIC ) );
                                break;
                case 3:     ShowMessage( stdout, GetResString( IDS_MANUAL ) );
                                break;
                case 4:     ShowMessage( stdout, GetResString( IDS_DISABLED ) );
                                break;
                default:    ShowMessage( stdout, V_NOT_AVAILABLE );
                                break;
            }
            
            ShowMessage( stdout, NEW_LINE );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );
    
    return;
}

/*********************************************************************************************
Routine Description
 
    This function displays the Registry policy or File System policy for the
    computer configuration.

Arguments:

    [in] pNamespace         :   pointer to IWbemServices.  
    [in] pszClassName       :   classname to retrieve data from.
    [in] pAuthIdentity      :   pointer to the Authorization structure
    [in] BOOL               :   set to TRUE if the super verbose info is to be displayed
    
Return Value:
 
    None
*********************************************************************************************/
VOID DisplayRegistryandFileInfo( IWbemServices *pNameSpace, BSTR pszClassName, 
                                    COAUTHIDENTITY *pAuthIdentity, BOOL bSuperVerbose )
{
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    
    DWORD                       dwTemp = 0;
    ULONG                       ulReturned = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    TCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;
    
    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        ZeroMemory( szTemp, sizeof( szTemp ) );
        ZeroMemory( szQueryString, sizeof( szQueryString ) );
        
        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            lstrcpy( szTemp, QUERY_SUPER_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, pszClassName );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            lstrcpy( szTemp, QUERY_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, pszClassName );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ), 
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next instance               
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if(ulReturned == 0)
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }
                
                break;
            }
            bGotClass = TRUE;
            
            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            lstrcpy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ) );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );       

            // Get the name 
            bResult = PropertyGet( pClass, CPV_REG_FS, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_OBJECTNAME ) );
            ShowMessage( stdout, strTemp );
            ShowMessage( stdout, NEW_LINE );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }
    catch( CHeap_Exception )
    {
        SetLastError( E_OUTOFMEMORY );
        SaveLastError();
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );
    
    return;
}

/*********************************************************************************************
Routine Description

    This function displays the Administrative Templates policy for the user and 
    computer configurations.
    
Arguments:
    
    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.  
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure.
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose 
                                                info is to be displayed.
    

Return Value:

    None
*********************************************************************************************/
VOID DisplayTemplates( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                        BOOL bSuperVerbose )
{
    HRESULT                     hResult = S_OK;
    
    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    BOOL                        bTemp = FALSE;
    
    ULONG                       ulReturned = 0;
    DWORD                       dwTemp    = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    TCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        ZeroMemory( szTemp, sizeof( szTemp ) );
        ZeroMemory( szQueryString, sizeof( szQueryString ) );
        
        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            lstrcpy( szTemp, QUERY_ADMIN_TEMP );
            FORMAT_STRING( szQueryString, szTemp, CLS_ADMIN );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            lstrcpy( szTemp, QUERY_ADMIN_TEMP );
            FORMAT_STRING( szQueryString, szTemp, CLS_ADMIN );
            lstrcat( szQueryString, QUERY_ADD_VERBOSE );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ), 
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while(WBEM_S_NO_ERROR == hResult)
        {
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if(ulReturned == 0)
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }
                
                break;
            }
            bGotClass = TRUE;
            
            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            lstrcpy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ) );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );       
            
            // Get the registry value (string)
            bResult = PropertyGet( pClass, CPV_REGISTRY, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );
            
            ShowMessage( stdout, GetResString( IDS_FR_SETTING ) );
            ShowMessage( stdout, strTemp );

            // Get the state (Enabled/Disabled)
            ShowMessage( stdout, GetResString( IDS_STATE ) );
            bResult = PropertyGet( pClass, CPV_DELETED, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            if( bTemp == VAR_TRUE )
            {
                // The deleted flag is set to TRUE for all the disabled templates
                ShowMessage( stdout, GetResString( IDS_DISABLED ) );
                ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_ENABLED ) );
                ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
            }
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );
    
    return;
}

/*********************************************************************************************
Routine Description

    This function displays the Folder Redirection settings for the user configuration.

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.  
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose 
                                                info is to be displayed.
    
Return Value:

    None
*********************************************************************************************/
VOID DisplayFolderRedirection( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                                BOOL bSuperVerbose )
{
    HRESULT                     hResult = S_OK;
    
    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    BOOL                        bTemp = FALSE;

    DWORD                       dwTemp = 0;
    ULONG                       ulReturned = 0;
    LONG                        lLBound = 0;
    LONG                        lUBound = 0;
    
    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    VARIANT                     vVarVerbose;
    VARTYPE                     vartype;
    
    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    TCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;
    
    SAFEARRAY                   *safeArray = NULL;
    
    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        ZeroMemory( szTemp, sizeof( szTemp ) );
        ZeroMemory( szQueryString, sizeof( szQueryString ) );
        
        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            lstrcpy( szTemp, QUERY_SUPER_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_FOLDER_REDIRECTION );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            lstrcpy( szTemp, QUERY_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_FOLDER_REDIRECTION );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ), 
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if(ulReturned == 0)
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }
                
                break;
            }
            bGotClass = TRUE;

            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            lstrcpy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ) );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );       

            // Get the folder re-direction information
            ShowMessage( stdout, GetResString( IDS_FR_SETTING ) );

            // Get the installation type
            ShowMessage( stdout, GetResString( IDS_INSTALLATIONTYPE ) );
            bResult = PropertyGet( pClass, CPV_FRINSTYPE, dwTemp, 0 );
            CHECK_BRESULT( bResult );
            
            switch( dwTemp )
            {
                case 1:     ShowMessage( stdout, GetResString( IDS_BASIC ) );
                                break;
                case 2:     ShowMessage( stdout, GetResString( IDS_MAXIMUM ) );
                                break;
                default:    ShowMessage( stdout, V_NOT_AVAILABLE );
                                break;
            }
            
            // Get the Grant Type
            ShowMessage( stdout, GetResString( IDS_GRANTTYPE ) );
            bResult = PropertyGet( pClass, CPV_FRGRANT, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            if( bTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_EXCLUSIVE ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NOTEXCLUSIVE ) );
            }

            // Get the Move type
            ShowMessage( stdout, GetResString( IDS_MOVETYPE ) );
            bResult = PropertyGet( pClass, CPV_FRMOVE, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            if( bTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_MOVED ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NOTMOVED ) );
            }
            
            // Get the removal policy
            ShowMessage( stdout, GetResString( IDS_POLICYREMOVAL ) );
            bResult = PropertyGet( pClass,  CPV_FRREMOVAL, dwTemp, 0 );
            CHECK_BRESULT( bResult );

            switch( dwTemp )
            {
                case 1:     ShowMessage( stdout, GetResString( IDS_LEAVEFOLDER ) );
                                break;
                case 2:     ShowMessage( stdout, GetResString( IDS_REDIRECT ) );
                                break;
                default:    ShowMessage( stdout, V_NOT_AVAILABLE );
                                break;
            }

            // Get the Redirecting group
            bResult = PropertyGet( pClass, CPV_FRSECGROUP, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_REDIRECTINGGROUP ) );
            // Compare the value got with the set of values and display the appropriate output
            if( strTemp.Compare( SID_EVERYONE ) == 0 )
            {
                ShowMessage( stdout, GetResString( IDS_EVERYONE ) );
            }
            else if( strTemp.Compare( SID_NULL_SID ) == 0 )
            {
                ShowMessage( stdout, GetResString( IDS_NULL_SID ) );
            }
            else if( strTemp.Compare( SID_LOCAL ) == 0 )
            {
                ShowMessage( stdout, GetResString( IDS_LOCAL ) );
            }
            else if( strTemp.Compare( SID_CREATOR_OWNER ) == 0 )
            {
                ShowMessage( stdout, GetResString( IDS_CREATOR_OWNER ) );
            }
            else if( strTemp.Compare( SID_CREATOR_GROUP ) == 0 )
            {
                ShowMessage( stdout, GetResString( IDS_CREATOR_GROUP ) );
            }
            else
            {
                ShowMessage( stdout, V_NOT_AVAILABLE );
            }
            
            // Get the re-directed path
            VariantInit( &vVarVerbose );
            hResult = pClass->Get( _bstr_t( CPV_FRPATH ), 0, &vVarVerbose, 0, 0 );
            CHECK_HRESULT_VAR( hResult, vVarVerbose );
            
            ShowMessage( stdout, GetResString( IDS_REDIRECTEDPATH ) );
            if( vVarVerbose.vt != VT_NULL && vVarVerbose.vt != VT_EMPTY )
            {
                // get the type of the elements in the safe array
                vartype = V_VT( &vVarVerbose ) & ~VT_ARRAY;

                //get the array of strings in to the safe array from the variant
                safeArray = ( SAFEARRAY * )vVarVerbose.parray;

                //get the number of elements (subkeys)
                if( safeArray != NULL )
                {
                    hResult = SafeArrayGetLBound( safeArray, 1, &lLBound );
                    CHECK_HRESULT( hResult );

                    hResult = SafeArrayGetUBound( safeArray, 1, &lUBound );
                    CHECK_HRESULT( hResult );  
                }
                for( ; lLBound <= lUBound; lLBound++ )
                {
                    // Get the element from the Safe Array
                    bResult = GetPropertyFromSafeArray( safeArray, lLBound, strTemp, vartype );
                    CHECK_BRESULT( bResult );
                    
                    if( strTemp.GetLength() == 0)
                    {
                        ShowMessage( stdout, V_NOT_AVAILABLE );
                    }
                    else
                    {
                        ShowMessage( stdout, strTemp );
                    }
                    ShowMessage( stdout, GetResString( IDS_NEWLINE1 ) );
                }
            }
            else
            {
                ShowMessage( stdout, V_NOT_AVAILABLE );
            }
            
            VariantClear( &vVarVerbose );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        VariantClear( &vVarVerbose );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );
    
    return;
}

/*********************************************************************************************
Routine Description:

     This function displays the verbose data for the  scope - user
     
Arguments:

    [in]    IWbemServices   *pRsopNameSpace     :   interface pointer

Return Value:
 
  TRUE  on SUCCESS
  FALSE on FAILURE
   
*********************************************************************************************/
BOOL CGpResult::DisplayVerboseUserData( IWbemServices *pNameSpace )
{
    DWORD           dwLength = 0;
    
    //
    // Display the verbose information for the scope - user
    
    // Display the header
    ShowMessage( stdout, GetResString( IDS_USER_RESULT ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );
    for( dwLength = lstrlen( GetResString( IDS_USER_RESULT ) ); dwLength > 4; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    ShowMessage( stdout, NEW_LINE );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );

    // Display the software installation data
    ShowMessage( stdout, GetResString( IDS_SW_SETTINGS ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_SW_SETTINGS ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplaySoftwareInstallations( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );
    
    // Display the public key policies
    // Displaying N/A for time being
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_WS_SS_PKP ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_WS_SS_PKP ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
    ShowMessage( stdout, V_NOT_AVAILABLE );
    ShowMessage( stdout, NEW_LINE );
    
    // Display the administrative template information
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_ADTS_ERS ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_ADTS_ERS ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplayTemplates( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );
    
    // Display the File Re-direction information
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_USERFR ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_USERFR ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplayFolderRedirection( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );
    
    // Display the group policy for IE
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_IEPOLICY ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_IEPOLICY ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplayIEPolicy( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );
    
    // Display the connection information
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_PROXY ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_PROXY ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplayIEProxySetting( pNameSpace, m_pAuthIdentity );

    // Display the IE Favorite Links or Items
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_FAVLINKORITEM ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_FAVLINKORITEM ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplayIEImpURLS( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );
    DisplayIEFavorites( pNameSpace, m_pAuthIdentity );

    // Display the security content ratings
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_IE_SECURITY ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_IE_SECURITY ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplayIESecurityContent( pNameSpace, m_pAuthIdentity );
    DisplayIESecurity( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );

    // Display the secutrity zone settings
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    ShowMessage( stdout, GetResString( IDS_IE_PROGRAMS ) );
    ShowMessage( stdout, GetResString( IDS_NEWLINETAB ) );
    for( dwLength = lstrlen( GetResString( IDS_IE_PROGRAMS ) ); dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    DisplayIEPrograms( pNameSpace, m_pAuthIdentity, m_bSuperVerbose );

    return TRUE;
}

/*********************************************************************************************
Routine Description
    
    This function displays the IE policy settings for the user configuration.

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.  
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose 
                                                info is to be displayed.
    
Return Value:

    None
*********************************************************************************************/
VOID DisplayIEPolicy( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity, 
                        BOOL bSuperVerbose )
{
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    BOOL                        bTemp = FALSE;

    ULONG                       ulReturned = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    TCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        ZeroMemory( szTemp, sizeof( szTemp ) );
        ZeroMemory( szQueryString, sizeof( szQueryString ) );
        
        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            lstrcpy( szTemp, QUERY_SUPER_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_IE_POLICY );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            lstrcpy( szTemp, QUERY_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_IE_POLICY );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ), 
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );
        
        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }
                
                break;
            }
            bGotClass = TRUE;
      
            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            lstrcpy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ) );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );       

            // Get the bit-map name
            bResult = PropertyGet( pClass, CPV_BITMAPNAME, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );
            
            ShowMessage( stdout, GetResString( IDS_BITMAPNAME ) );
            ShowMessage( stdout, strTemp );
            
            // Get the Logo bitmap name
            bResult = PropertyGet( pClass, CPV_LOGOBITMAPNAME, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_LOGOBITMAPNAME ) );
            ShowMessage( stdout, strTemp );
            
            // Get the title bar text
            bResult = PropertyGet( pClass, CPV_TITLEBARTEXT, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_TITLEBARTEXT ) );
            ShowMessage( stdout, strTemp );
            
            // Get the user agent text
            bResult = PropertyGet( pClass, CPV_USERAGENTTEXT, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_USERAGENTTEXT ) );
            ShowMessage( stdout, strTemp );
                
            // Get the info., wether to delete the existing toolbar buttons
            bResult = PropertyGet( pClass, CPV_TOOL_BUTTONS, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_TOOL_BUTTONS ) );
            if( bTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_YES ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NO ) );
            }

            ShowMessage( stdout, NEW_LINE );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }
    catch( CHeap_Exception )
    {
        SetLastError( E_OUTOFMEMORY );
        SaveLastError();
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );
    
    return;
}

/*********************************************************************************************
Routine Description
    
    This function displays the IE favorites information.

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.  
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure
        
Return Value:

    None
*********************************************************************************************/
VOID DisplayIEFavorites( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity )
{
    HRESULT                     hResult = S_OK;
    
    BOOL                        bResult = FALSE;
    
    ULONG                       ulReturned = 0;
    DWORD                       dwTemp = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    CHString                    strTemp;
    
    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        ZeroMemory( szTemp, sizeof( szTemp ) );

        // Enumerate the classes
        hResult = pNameSpace->CreateInstanceEnum( _bstr_t( CLS_IE_FAVLINKORITEM ),
                                                    WBEM_FLAG_FORWARD_ONLY | 
                                                    WBEM_FLAG_RETURN_IMMEDIATELY, 
                                                    NULL, &pEnumClass);
        CHECK_HRESULT( hResult );

        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                break;
            }
            
            // Get the URL information
            bResult = PropertyGet( pClass, CPV_URL, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_URL ) );
            ShowMessage( stdout, strTemp );
            
            // Get the information on wether the site is available off line
            bResult = PropertyGet( pClass, CPV_AVAILOFFLINE, dwTemp, 2 );
            CHECK_BRESULT( bResult );
            
            ShowMessage( stdout, GetResString( IDS_AVAILABLE ) );
            if( dwTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_YES ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NO ) );
            }

            ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );
    
    return;
}

/*********************************************************************************************
Routine Description
    
    This function displays the IE security contents information.

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.  
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure

Return Value:

    None
*********************************************************************************************/
VOID DisplayIESecurityContent( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity )
{
    HRESULT                     hResult = S_OK;
    
    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    BOOL                        bTemp = FALSE;

    DWORD                       dwTemp = 0;
    ULONG                       ulReturned = 0;
    LONG                        lLBound = 0;
    LONG                        lUBound = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    VARIANT                     vVarVerbose;
    VARTYPE                     vartype;

    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    CHString                    strTemp;    

    SAFEARRAY                   *safeArray = NULL;
    
    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        ZeroMemory( szTemp, sizeof( szTemp ) );

        // enumerate the classes
        hResult = pNameSpace->CreateInstanceEnum( _bstr_t( CLS_IE_SECURITY_CONTENT ),
                                                    WBEM_FLAG_FORWARD_ONLY |
                                                    WBEM_FLAG_RETURN_IMMEDIATELY, 
                                                    NULL, &pEnumClass);
        CHECK_HRESULT( hResult );
        
        // set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no instances in both the security classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }

                break;
            }
            
            // Got a class...set the flag
            bGotClass = TRUE;
                    
            // Get the viewable sites information
            VariantInit( &vVarVerbose );
            ShowMessage( stdout, GetResString( IDS_VIEWABLESITES ) );
            hResult = pClass->Get( _bstr_t( CPV_ALWAYSVIEW ), 0, &vVarVerbose, 0, 0 );
            CHECK_HRESULT_VAR( hResult, vVarVerbose );

            if( vVarVerbose.vt != VT_NULL && vVarVerbose.vt != VT_EMPTY )
            {
                // get the type of the elements in the safe array
                vartype = V_VT( &vVarVerbose ) & ~VT_ARRAY;

                //get the array of strings in to the safe array from the variant
                safeArray = ( SAFEARRAY * )vVarVerbose.parray;
                
                //get the number of elements (subkeys)
                if( safeArray != NULL )
                {
                    hResult = SafeArrayGetLBound( safeArray, 1, &lLBound );
                    CHECK_HRESULT( hResult );

                    hResult = SafeArrayGetUBound( safeArray, 1, &lUBound );
                    CHECK_HRESULT( hResult );  
                }
                for( ; lLBound <= lUBound; lLBound++ )
                {
                    // Get the element from the safe array
                    bResult = GetPropertyFromSafeArray( safeArray, lLBound, strTemp, vartype );
                    CHECK_BRESULT( bResult );
                    
                    if( strTemp.GetLength() == 0 )
                    {
                        ShowMessage( stdout, V_NOT_AVAILABLE );
                    }
                    else
                    {
                        ShowMessage( stdout, strTemp );
                    }
                    ShowMessage( stdout, GetResString( IDS_NEWLINE1 ) );
                }
            }
            else
            {
                ShowMessage( stdout, V_NOT_AVAILABLE );
            }
            
            // Get the password over-ride information
            ShowMessage( stdout, GetResString( IDS_PASSWORDOVERRIDE ) );
            bResult = PropertyGet( pClass, CPV_ENABLEPASSWORD, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            if( bTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_TRUE ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_FALSE ) );
            }

            ShowMessage( stdout, GetResString( IDS_NEWLINE ) );

            VariantClear(&vVarVerbose);
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        VariantClear(&vVarVerbose);
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );
    
    return;
}

/*********************************************************************************************
Routine Description
    
    This function displays the IE security information.

Arguments:

    [in] IWbemServices      *pNamespace         :   pointer to IWbemServices.  
    [in] COAUTHIDENTITY     *pAuthIdentity      :   pointer to the authorization structure
    

Return Value:

    None
*********************************************************************************************/
VOID DisplayIESecurity( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                        BOOL bSuperVerbose )
{
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    BOOL                        bTemp = FALSE;

    ULONG                       ulReturned = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    TCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;
    
    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        ZeroMemory( szTemp, sizeof( szTemp ) );
        ZeroMemory( szQueryString, sizeof( szQueryString ) );
        
        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            lstrcpy( szTemp, QUERY_SUPER_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_IE_POLICY );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            lstrcpy( szTemp, QUERY_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_IE_POLICY );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ), 
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );
        
        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                break;
            }
            
            // Got a class...set the flag
            bGotClass = TRUE;

            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            lstrcpy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ) );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );       

            // Get the Security content information
            bResult = PropertyGet( pClass, CPV_SEC_CONTENT, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_CONTENT_SETTING ) );
            if( bTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_YES ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NO ) );
            }
            
            // Get the Security zone information
            bResult = PropertyGet( pClass, CPV_SEC_ZONE, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_ZONE_SETTING ) );
            if( bTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_YES ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NO ) );
            }

            // Get the Authenticode information
            bResult = PropertyGet( pClass, CPV_AUTH_CODE, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_AUTH_SETTING ) );
            if( bTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_YES ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NO ) );
            }

            // Get the trusted publisher lock down information
            bResult = PropertyGet( pClass, CPV_TRUST_PUB, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_TRUST_PUB ) );
            if( bTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_YES ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NO ) );
            }

            ShowMessage( stdout, NEW_LINE );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }
    catch( CHeap_Exception )
    {
        SetLastError( E_OUTOFMEMORY );
        SaveLastError();
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );
    
    return;
}

/*********************************************************************************************
Routine Description
    
    This function displays the IE proxy information.

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.  
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure
    

Return Value:

    None
*********************************************************************************************/
VOID DisplayIEProxySetting( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity )
{
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;

    ULONG                       ulReturned = 0;
    DWORD                       dwTemp = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    CHString                    strTemp;
    
    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        ZeroMemory( szTemp, sizeof( szTemp ) );

        // Enumerate the classes
        hResult = pNameSpace->CreateInstanceEnum( _bstr_t( CLS_IE_CONNECTION ),
                                                    WBEM_FLAG_FORWARD_ONLY |
                                                    WBEM_FLAG_RETURN_IMMEDIATELY, 
                                                    NULL, &pEnumClass);
        CHECK_HRESULT( hResult );
        
        // set the security interface
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // Get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }
                
                break;
            }
            bGotClass = TRUE;

            // Get the http proxy information
            bResult = PropertyGet( pClass, CPV_HTTP_PROXY, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_HTTP_PROXY ) );
            ShowMessage( stdout, strTemp );
            
            // Get the Secure proxy information
            bResult = PropertyGet( pClass, CPV_SECURE_PROXY, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_SECURE_PROXY ) );
            ShowMessage( stdout, strTemp );

            // Get the ftp proxy information
            bResult = PropertyGet( pClass, CPV_FTP_PROXY, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_FTP_PROXY ) );
            ShowMessage( stdout, strTemp );

            // Get the Gopher proxy information
            bResult = PropertyGet( pClass, CPV_GOPHER_PROXY, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_GOPHER_PROXY ) );
            ShowMessage( stdout, strTemp );

            // Get the socks proxy information
            bResult = PropertyGet( pClass, CPV_SOCKS_PROXY, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_SOCKS_PROXY ) );
            ShowMessage( stdout, strTemp );

            // Get the Auto config enable information
            ShowMessage( stdout, GetResString( IDS_AUTO_CONFIG_ENABLE ) );
            bResult = PropertyGet( pClass, CPV_AUTO_CONFIG_ENABLE, dwTemp, 2 );
            CHECK_BRESULT( bResult );

            if( dwTemp == -1 )
            {
                ShowMessage( stdout, GetResString( IDS_YES ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NO ) );
            }

            // Get the info on wether or not the proxy is enabled
            ShowMessage( stdout, GetResString( IDS_ENABLE_PROXY ) );
            bResult = PropertyGet( pClass, CPV_ENABLE_PROXY, dwTemp, 2 );
            CHECK_BRESULT( bResult );

            if( dwTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_YES ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NO ) );
            }
            
            // Get the info on wether or not to use the same proxy
            ShowMessage( stdout, GetResString( IDS_USE_SAME_PROXY ) );
            bResult = PropertyGet( pClass, CPV_USE_SAME_PROXY, dwTemp, 2 );
            CHECK_BRESULT( bResult );

            if( dwTemp == -1 )
            {
                ShowMessage( stdout, GetResString( IDS_YES ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NO ) );
            }
            
            ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );
    
    return;
}

/*********************************************************************************************
Routine Description
    
    This function displays the IE program settings for the user configuration.

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.  
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose 
                                                info is to be displayed.
    
Return Value:

    None
*********************************************************************************************/
VOID DisplayIEPrograms( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity, 
                        BOOL bSuperVerbose )
{
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    BOOL                        bTemp = FALSE;

    ULONG                       ulReturned = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    TCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;
    
    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        ZeroMemory( szTemp, sizeof( szTemp ) );
        ZeroMemory( szQueryString, sizeof( szQueryString ) );
        
        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            lstrcpy( szTemp, QUERY_SUPER_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_IE_POLICY );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            lstrcpy( szTemp, QUERY_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_IE_POLICY );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ), 
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );
        
        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }
                
                break;
            }
            bGotClass = TRUE;
      
            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            lstrcpy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ) );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );       

            // Get the program information
            bResult = PropertyGet( pClass, CPV_PROGRAM, bTemp, FALSE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_PROGRAM_SETTING ) );
            if( bTemp == VAR_TRUE )
            {
                ShowMessage( stdout, GetResString( IDS_YES ) );
            }
            else
            {
                ShowMessage( stdout, GetResString( IDS_NO ) );
            }
            
            ShowMessage( stdout, NEW_LINE );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );
    
    return;
}

/*********************************************************************************************
Routine Description
    
    This function displays the information on the important URLs.

Arguments:

    [in] IWbemServices      *pNamespace     :   pointer to IWbemServices.  
    [in] COAUTHIDENTITY     *pAuthIdentity  :   pointer to the authorization structure
    [in] BOOL               bSuperVerbose   :   set to TRUE if the super verbose 
                                                info is to be displayed.
    
Return Value:

    None
*********************************************************************************************/
VOID DisplayIEImpURLS( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity, 
                        BOOL bSuperVerbose )
{
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotClass = FALSE;
    BOOL                        bTemp = FALSE;

    ULONG                       ulReturned = 0;

    IWbemClassObject            *pClass = NULL;
    IEnumWbemClassObject        *pEnumClass = NULL;

    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    TCHAR                       szQueryString [ MAX_STRING_LENGTH ];
    CHString                    strTemp;

    try
    {
        if( pNameSpace == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        ZeroMemory( szTemp, sizeof( szTemp ) );
        ZeroMemory( szQueryString, sizeof( szQueryString ) );
        
        // Form the query string
        if( bSuperVerbose == TRUE )
        {
            // ennumerate all the classes
            lstrcpy( szTemp, QUERY_SUPER_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_IE_POLICY );
        }
        else
        {
            // ennumerate all the classes with precedance = 1
            lstrcpy( szTemp, QUERY_VERBOSE );
            FORMAT_STRING( szQueryString, szTemp, CLS_IE_POLICY );
        }

        // Get the pointer to ennumerate with
        hResult = pNameSpace->ExecQuery( _bstr_t( QUERY_LANGUAGE ),
                                            _bstr_t( szQueryString ), 
                                            WBEM_FLAG_FORWARD_ONLY |
                                            WBEM_FLAG_RETURN_IMMEDIATELY,
                                            NULL, &pEnumClass );
        CHECK_HRESULT( hResult );
        
        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, pAuthIdentity );
        CHECK_HRESULT( hResult );

        hResult = WBEM_S_NO_ERROR;
        while( WBEM_S_NO_ERROR == hResult )
        {
            // get the next class
            hResult = pEnumClass->Next( WBEM_INFINITE , 1, &pClass, &ulReturned );
            CHECK_HRESULT( hResult );

            if( ulReturned == 0 )
            {
                // No more classes to enumerate
                // Display N/A if there were no classes
                if( bGotClass == FALSE )
                {
                    ShowMessage( stdout, GetResString( IDS_NEWLINE_TABTHREE ) );
                    ShowMessage( stdout, V_NOT_AVAILABLE );
                    ShowMessage( stdout, NEW_LINE );
                }
                
                break;
            }
            bGotClass = TRUE;
      
            // Get the GPO id
            bResult = PropertyGet( pClass, CPV_GPOID, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            lstrcpy( szTemp, strTemp.GetBuffer( strTemp.GetLength() ) );
            ShowMessage( stdout, GetResString( IDS_GPO ) );
            GpoName( pNameSpace, szTemp, pAuthIdentity );       

            // Get the home page URL
            bResult = PropertyGet( pClass, CPV_HOMEPAGEURL, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_HOMEPAGEURL ) );
            ShowMessage( stdout, strTemp );

            // Get the search bar URL
            bResult = PropertyGet( pClass, CPV_SEARCHBARURL, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_SEARCHBARURL ) );
            ShowMessage( stdout, strTemp );

            // Get the Online Help Page URL
            bResult = PropertyGet( pClass, CPV_HELPPAGEURL, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            ShowMessage( stdout, GetResString( IDS_HELPPAGEURL ) );
            ShowMessage( stdout, strTemp );

            ShowMessage( stdout, NEW_LINE );
        }// while
    }
    catch( _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }
    catch( CHeap_Exception )
    {
        SetLastError( E_OUTOFMEMORY );
        SaveLastError();
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }

    // Release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\gpresult\verboseloggingdata.h ===
/*********************************************************************************************

Copyright (c) Microsoft Corporation
 
Module Name: 

    VerboseLoggingData.h

Abstract:

    Header file containing the constants and function prototypes pertaining to the 
    Verbose information display

Author:

    Wipro Technologies

Revision History:

    22-Feb-2001 : Created It.

*********************************************************************************************/ 
#ifndef _GVERBOSE_H
#define _GVERBOSE_H

//
// constants
// CLS stands for class
#define CLS_WIN32_DOMAIN            _T( "Win32_ComputerSystem" )
#define CLS_WIN32_USER              _T( "Win32_UserAccount" )
#define CLS_SOFTWARE                _T( "RSOP_ApplicationManagementPolicySetting" )
#define CLS_PASSWD_POLICY           _T( "RSOP_SecuritySettingNumeric" )
#define CLS_SECURITY_BOOLEAN        _T( "RSOP_SecuritySettingBoolean" )
#define CLS_SECURITY_STRING         _T( "RSOP_SecuritySettingString" )
#define CLS_SCRIPTS                 _T( "RSOP_ScriptPolicySetting" )
#define CLS_EVENTLOG_BOOLEAN        _T( "RSOP_SecurityEventLogSettingBoolean"  )
#define CLS_EVENTLOG_NUMERIC        _T( "RSOP_SecurityEventLogSettingNumeric"  )
#define CLS_USER_RIGHTS             _T( "RSOP_UserPrivilegeRight"  )
#define CLS_AUDIT_POLICY            _T( "RSOP_AuditPolicy"  )
#define CLS_RESTRICTED_GROUPS       _T( "RSOP_RestrictedGroup" )
#define CLS_SYSTEM_SERVICES         _T( "RSOP_SystemService" )
#define CLS_REGISTRY                _T( "RSOP_RegistryKey" )
#define CLS_FILE                    _T( "RSOP_File" )
#define CLS_ADMIN                   _T( "RSOP_RegistryPolicySetting" )
#define CLS_FOLDER_REDIRECTION      _T( "RSOP_FolderRedirectionPolicySetting" )
#define CLS_IE_FAVLINKORITEM        _T( "RSOP_IEFavoriteOrLinkItem" )
#define CLS_IE_SECURITY_CONTENT     _T( "RSOP_IESecurityContentRatings" )
#define CLS_IE_SECURITY_ZONE        _T( "RSOP_IESecurityZoneSettings" )
#define CLS_IE_CONNECTION           _T( "RSOP_IEConnectionSettings" )
#define CLS_IE_POLICY               _T( "RSOP_IEAKPolicySetting" )

// Class Property Value
#define CPV_ID                      _T( "id" )
#define CPV_GPOID                   _T( "GPOID" )
#define CPV_KEYNAME1                _T( "Keyname" )
#define CPV_SETTING1                _T( "Setting" )
#define CPV_TYPE                    _T( "Type" )
#define CPV_REG_FS                  _T( "Path" )
#define CPV_SCRIPTLIST              _T( "scriptList" ) 
#define CPV_USERRIGHT               _T( "UserRight" )
#define CPV_ACCOUNTLIST             _T( "AccountList" ) 
#define CPV_CATEGORY                _T( "Category" )
#define CPV_SUCCESS                 _T( "Success" )
#define CPV_FAILURE                 _T( "Failure" )
#define CPV_GROUP                   _T( "GroupName" )
#define CPV_MEMBERS                 _T( "Members" )
#define CPV_SERVICE                 _T( "Service" )
#define CPV_STARTUP                 _T( "StartupMode" )
#define CPV_PRECEDENCE              _T( "precedence" )
#define CPV_REGISTRY                _T( "registryKey" )
#define CPV_AUTO_INSTALL            _T( "DemandInstallable" )
#define CPV_ORIGIN                  _T( "EntryType" )
#define CPV_SCRIPT                  _T( "script" )
#define CPV_ARGUMENTS               _T( "arguments" )
#define CPV_EXECTIME                _T( "executionTime" )
#define CPV_DELETED                 _T( "deleted" )

// Properties for folder re-direction
#define CPV_FRINSTYPE               _T( "installationType" )
#define CPV_FRSECGROUP              _T( "redirectingGroup" )
#define CPV_FRPATH                  _T( "redirectedPaths" )
#define CPV_FRGRANT                 _T( "grantType" )
#define CPV_FRMOVE                  _T( "moveType" )
#define CPV_FRREMOVAL               _T( "policyRemoval" )

// Properties for IE settings
#define CPV_HOMEPAGEURL             _T( "homePageURL" )
#define CPV_SEARCHBARURL            _T( "searchBarURL" )
#define CPV_HELPPAGEURL             _T( "onlineHelpPageURL" )
#define CPV_BITMAPNAME              _T( "largeAnimatedBitmapName" )
#define CPV_LOGOBITMAPNAME          _T( "largeCustomLogoBitmapName" )
#define CPV_USERAGENTTEXT           _T( "userAgentText" )
#define CPV_TITLEBARTEXT            _T( "titleBarCustomText" )   
#define CPV_ALWAYSVIEW              _T( "alwaysViewableSites" )
#define CPV_ENABLEPASSWORD          _T( "passwordOverrideEnabled" )
#define CPV_DISPLAY_NAME            _T( "displayName" )
#define CPV_ZONEMAPPINGS            _T( "zoneMappings" )
#define CPV_URL                     _T( "url" )
#define CPV_AVAILOFFLINE            _T( "makeAvailableOffline" )
#define CPV_HTTP_PROXY              _T( "httpProxyServer" )
#define CPV_SECURE_PROXY            _T( "secureProxyServer" )
#define CPV_FTP_PROXY               _T( "ftpProxyServer" )
#define CPV_GOPHER_PROXY            _T( "gopherProxyServer" )
#define CPV_SOCKS_PROXY             _T( "socksProxyServer" )
#define CPV_AUTO_CONFIG_ENABLE      _T( "autoConfigEnable" )
#define CPV_ENABLE_PROXY            _T( "enableProxy" )
#define CPV_USE_SAME_PROXY          _T( "useSameProxy" )
#define CPV_PROGRAM                 _T( "importProgramSettings" )
#define CPV_SEC_CONTENT             _T( "importContentRatingsSettings" )
#define CPV_SEC_ZONE                _T( "importSecurityZoneSettings" )
#define CPV_AUTH_CODE               _T( "importAuthenticodeSecurityInfo" )
#define CPV_TRUST_PUB               _T( "enableTrustedPublisherLockdown" )
#define CPV_TOOL_BUTTONS            _T( "deleteExistingToolbarButtons" )

// Software Installation
#define CPV_APP_NAME                _T( "name" )  
#define CPV_VER_HI                  _T( "VersionNumberHi" )  
#define CPV_VER_LO                  _T( "VersionNumberLo" )  
#define CPV_DEPLOY_STATE            _T( "DeploymentType" )
#define CPV_APP_SRC                 _T( "PackageLocation" )  

#define FPR_STARTUP                 _T( "startup" )
#define FPR_SHUTDOWN                _T( "shutdown" )

// Query Strings
#define QUERY_VERBOSE               _T( "SELECT * from %s WHERE precedence=1" )
#define QUERY_SUPER_VERBOSE         _T( "SELECT * from %s" )
#define QUERY_START_UP              _T( "Select * from %s WHERE ScriptType=3" )
#define QUERY_SHUT_DOWN             _T( "Select * from %s WHERE ScriptType=4" )
#define QUERY_ADMIN_TEMP            _T( "Select * from %s WHERE (valueType = 1 OR valueType = 4 OR Deleted = TRUE)" )
#define QUERY_ADD_VERBOSE           _T( " AND precedence=1" )

//
// function prototypes
VOID DisplaySoftwareInstallations( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                                    BOOL bSuperVerbose );

VOID DisplayPasswordPolicy( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                            BOOL bSuperVerbose );

VOID DisplayAuditPolicy( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                            BOOL bSuperVerbose );

VOID DisplayUserRights( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                        BOOL bSuperVerbose);

VOID DisplayFolderRedirection( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                                BOOL bSuperVerbose );

VOID DisplayRestrictedGroups( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                                BOOL bSuperVerbose );

VOID DisplaySystemServices( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                            BOOL bSuperVerbose );

VOID DisplayScripts( IWbemServices *pNameSpace, BOOL bScriptFlag, 
                        COAUTHIDENTITY *pAuthIdentity, BOOL bSuperVerbose );

VOID DisplaySecurityandEvents( IWbemServices *pNameSpace, BSTR pszClassName, 
                                COAUTHIDENTITY *pAuthIdentity, BOOL bSuperVerbose );

VOID DisplayRegistryandFileInfo( IWbemServices *pNameSpace, BSTR pszClassName, 
                                    COAUTHIDENTITY *pAuthIdentity, BOOL bSuperVerbose );

VOID DisplayTemplates( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                        BOOL bSuperVerbose );

VOID GpoName( IWbemServices *pNameSpace, LPTSTR lpszGpoid, 
                            COAUTHIDENTITY *pAuthIdentity );

VOID DisplayIEPolicy( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                        BOOL bSuperVerbose );

VOID DisplayIEFavorites( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity );

VOID DisplayIESecurityContent( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity );

VOID DisplayIESecurity( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                        BOOL bSuperVerbose );

VOID DisplayIEPrograms( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity,
                        BOOL bSuperVerbose );

VOID DisplayIEProxySetting( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity );

VOID DisplayIEImpURLS( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity, 
                        BOOL bSuperVerbose );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\gpresult\wmi.cpp ===
/*********************************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

    WMI.cpp

Abstract: 
    
    Common functionlity for dealing with WMI.
 
Author:

    Wipro Technologies

Revision History:

    22-Dec-2000 : Created It.
    24-Apr-2001 : Closing the review comments given by client.  

*********************************************************************************************/ 

#include "pch.h"
#include "wmi.h"
#include "resource.h"

//
// messages
//
#define INPUT_PASSWORD              GetResString( IDS_STR_INPUT_PASSWORD )

// error constants
#define E_SERVER_NOTFOUND           0x800706ba

//
// private function prototype(s)
//
BOOL IsValidUserEx( LPCWSTR pwszUser );
HRESULT GetSecurityArguments( IUnknown* pInterface, 
                              DWORD& dwAuthorization, DWORD& dwAuthentication );
HRESULT SetInterfaceSecurity( IUnknown* pInterface, 
                              LPCWSTR pwszServer, LPCWSTR pwszUser, 
                              LPCWSTR pwszPassword, COAUTHIDENTITY** ppAuthIdentity );
HRESULT WINAPI SetProxyBlanket( IUnknown* pInterface,
                                DWORD dwAuthnSvc, DWORD dwAuthzSvc,
                                LPWSTR pwszPrincipal, DWORD dwAuthLevel, DWORD dwImpLevel,
                                RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities );
HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser, LPCWSTR pwszPassword, 
                                      LPCWSTR pwszDomain, COAUTHIDENTITY** ppAuthIdent );
HRESULT RegQueryValueWMI( IWbemServices* pWbemServices, 
                          LPCWSTR pwszMethod, DWORD dwHDefKey, 
                          LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, _variant_t& varValue );

/*********************************************************************************************
Routine Description:

    Checks wether the User name is a valid one or not
          
Arguments:

    [in] LPCWSTR    :   String containing the user name
  
Return Value:
    
    TRUE on success
    FALSE on failure
*********************************************************************************************/
BOOL IsValidUserEx( LPCWSTR pwszUser )
{
    // local variables
    CHString strUser;
    LONG lPos = 0;

    if ( pwszUser == NULL )
    {
        return TRUE;
    }

    try
    {
        // get user into local memory
        strUser = pwszUser;

        // user name should not be just '\'
        if ( strUser.CompareNoCase( L"\\" ) == 0 )
        {
            return FALSE;
        }

        // user name should not contain invalid characters
        if ( strUser.FindOneOf( L"/[]:|<>+=;,?*" ) != -1 )
        {
            return FALSE;
        }

        // SPECIAL CHECK
        // check for multiple '\' characters in the user name
        lPos = strUser.Find( L'\\' );
        if ( lPos != -1 )
        {
            // '\' character exists in the user name
            // strip off the user info upto first '\' character
            // check for one more '\' in the remaining string
            // if it exists, invalid user
            strUser = strUser.Mid( lPos + 1 );
            lPos = strUser.Find( L'\\' );
            if ( lPos != -1 )
            {
                return FALSE;
            }
        }
    }
    catch( ... )
    {
        SetLastError( E_OUTOFMEMORY );
        return FALSE;
    }

    // user name is valid
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    Checks wether the Server name is a valid one or not
          
Arguments:

    [in]  LPCWSTR   :   String containing the user name
    [out] BOOL      :   Is set to TRUE if the local system is being queried.

Return Value:

    TRUE on success
    FALSE on failure 
*********************************************************************************************/
BOOL IsValidServerEx( LPCWSTR pwszServer, BOOL& bLocalSystem )
{
    // local variables
    CHString strTemp;

    if ( pwszServer == NULL )
    {
        return FALSE;
    }

    // kick-off
    bLocalSystem = FALSE;

    // get a local copy
    strTemp = pwszServer;

    // remove the forward slashes (UNC) if exist in the begining of the server name
    if ( IsUNCFormat( strTemp ) == TRUE )
    {
        strTemp = strTemp.Mid( 2 );
        if ( strTemp.GetLength() == 0 )
        {
            return FALSE;
        }
    }

    // now check if any '\' character appears in the server name. If so error
    if ( strTemp.Find( L'\\' ) != -1 )
    {
        return FALSE;
    }

    // now check if server name is '.' only which represent local system in WMI
    // else determine whether this is a local system or not
    if ( strTemp.CompareNoCase( L"." ) == 0 )
    {
        bLocalSystem = TRUE;
    }
    else
    {
        bLocalSystem = IsLocalSystem( strTemp );
    }

    // inform that server name is valid
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    Initializes the COM library

Arguments:

    [in] IWbemLocator   :   pointer to the IWbemLocator

Return Value:

    TRUE on success
    FALSE on failure 
*********************************************************************************************/
BOOL InitializeCom( IWbemLocator** ppLocator )
{
    // local variables
    HRESULT hr;
    BOOL bResult = FALSE;

    try
    {
        // assume that connection to WMI namespace is failed
        bResult = FALSE;

        // initialize the COM library
        SAFE_EXECUTE( CoInitializeEx( NULL, COINIT_APARTMENTTHREADED ) );

        // initialize the security
        SAFE_EXECUTE( CoInitializeSecurity( NULL, -1, NULL, NULL,
            RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0 ) );

        // create the locator and get the pointer to the interface of IWbemLocator
        SAFE_RELEASE( *ppLocator );         // safe side
        SAFE_EXECUTE( CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, 
            IID_IWbemLocator, ( LPVOID* ) ppLocator ) );

        // initialization successful
        bResult = TRUE;
    }
    catch( _com_error& e )
    {
        // save the WMI error
        WMISaveError( e );
    }

    // return the result;
    return bResult;
}

/*********************************************************************************************
Routine Description:

    This function makes a connection to WMI.

Arguments:

    [in] IWbemLocator           :   pointer to the IWbemLocator
    [in] IWbemServices          :   pointer to the IWbemServices
    [in] LPCWSTR                :   string containing the server name
    [in] LPCWSTR                :   string containing the User name
    [in] LPCWSTR                :   string containing the password
    [in] COAUTHIDENTITY         :   pointer to AUTHIDENTITY structure
    [in] BOOL                   :   set to TRUE if we should try to connect with 
                                    current credentials
    [in] LPCWSTR                :   string containing the namespace to connect to
    [out] HRESULT               :   the hResult value returned
    [out] BOOL                  :   set to TRUE if we are querying for the local system

Return Value:

    TRUE on success
    FALSE on failure 
*********************************************************************************************/
BOOL ConnectWmi( IWbemLocator* pLocator, 
                 IWbemServices** ppServices, 
                 LPCWSTR pwszServer, LPCWSTR pwszUser, LPCWSTR pwszPassword, 
                 COAUTHIDENTITY** ppAuthIdentity, BOOL bCheckWithNullPwd, 
                 LPCWSTR pwszNamespace, HRESULT* phr, BOOL* pbLocalSystem )
{
    // local variables
    HRESULT hr;
    BOOL bResult = FALSE;
    BOOL bLocalSystem = FALSE;
    _bstr_t bstrServer;
    _bstr_t bstrNamespace;
    _bstr_t bstrUser, bstrPassword;

    // kick-off
    if ( pbLocalSystem != NULL )
    {
        *pbLocalSystem = FALSE;
    }

    // ...
    if ( phr != NULL )
    {
        *phr = NO_ERROR;
    }

    try
    {
        // clear the error
        SetLastError( WBEM_S_NO_ERROR );

        // assume that connection to WMI namespace is failed
        bResult = FALSE;

        // check whether locator object exists or not
        // if not exists, return
        if ( pLocator == NULL )
        {
            if ( phr != NULL )
            {
                *phr = WBEM_E_INVALID_PARAMETER;
            }

            // return failure
            return FALSE;
        }

        // validate the server name
        // NOTE: The error being raised in custom define for '0x800706ba' value
        //       The message that will be displayed in "The RPC server is unavailable."
        if ( IsValidServerEx( pwszServer, bLocalSystem ) == FALSE )
        {
            _com_issue_error( E_SERVER_NOTFOUND );
        }

        // validate the user name
        if ( IsValidUserEx( pwszUser ) == FALSE )
        {
            _com_issue_error( ERROR_NO_SUCH_USER );
        }

        // prepare namespace
        bstrNamespace = pwszNamespace;              // name space
        if ( pwszServer != NULL && bLocalSystem == FALSE )
        {
            // get the server name
            bstrServer = pwszServer;

            // prepare the namespace
            // NOTE: check for the UNC naming format of the server and do
            if ( IsUNCFormat( pwszServer ) == TRUE )
            {
                bstrNamespace = bstrServer + L"\\" + pwszNamespace;
            }
            else
            {
                bstrNamespace = L"\\\\" + bstrServer + L"\\" + pwszNamespace;
            }

            // user credentials
            if ( pwszUser != NULL && lstrlen( pwszUser ) != 0 )
            {
                // copy the user name
                bstrUser = pwszUser;

                // if password is empty string and if we need to check with
                // null password, then do not set the password and try
                bstrPassword = pwszPassword;
                if ( bCheckWithNullPwd == TRUE && bstrPassword.length() == 0 )
                {
                    bstrPassword = (LPWSTR) NULL;
                }
            }
        }

        // release the existing services object ( to be in safer side )
        SAFE_RELEASE( *ppServices );

        // connect to the remote system's WMI
        // there is a twist here ... 
        // do not trap the ConnectServer function failure into exception
        // instead handle that action manually
        // by default try the ConnectServer function as the information which we have
        // in our hands at this point. If the ConnectServer is failed, 
        // check whether password variable has any contents are not ... if no contents
        // check with "" (empty) password ... this might pass in this situation ..
        // if this call is also failed ... nothing is there that we can do ... throw the exception
        hr = pLocator->ConnectServer( bstrNamespace, 
            bstrUser, bstrPassword, 0L, 0L, NULL, NULL, ppServices );
        if ( FAILED( hr ) )
        {
            //
            // special case ...

            // check whether password exists or not
            // NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
            //       this error code says that user with the current credentials is not
            //       having access permisions to the 'namespace'
            if ( hr == E_ACCESSDENIED )
            {
                // check if we tried to connect to the system using null password
                // if so, then try connecting to the remote system with empty string
                if ( bCheckWithNullPwd == TRUE &&
                     bstrUser.length() != 0 && bstrPassword.length() == 0 )
                {
                    // now invoke with ...
                    hr = pLocator->ConnectServer( bstrNamespace, 
                        bstrUser, _bstr_t( L"" ), 0L, 0L, NULL, NULL, ppServices );
                }
            }
            else if ( hr == WBEM_E_LOCAL_CREDENTIALS )
            {
                // credentials were passed to the local system. 
                // So ignore the credentials and try to reconnect
                bLocalSystem = TRUE;
                bstrUser = (LPWSTR) NULL;
                bstrPassword = (LPWSTR) NULL;
                bstrNamespace = pwszNamespace;              // name space
                hr = pLocator->ConnectServer( bstrNamespace, 
                    NULL, NULL, 0L, 0L, NULL, NULL, ppServices );
            }

            // now check the result again .. if failed .. ummmm..
            if ( FAILED( hr ) )
            {
                _com_issue_error( hr );
            }
            else
            {
                bstrPassword = L"";
            }
        }

        // set the security at the interface level also
        SAFE_EXECUTE( SetInterfaceSecurity( *ppServices, 
            pwszServer, bstrUser, bstrPassword, ppAuthIdentity ) );

        // connection to WMI is successful
        bResult = TRUE;

        // save the hr value if needed by the caller
        if ( phr != NULL )
        {
            *phr = WBEM_S_NO_ERROR;
        }
    }
    catch( _com_error& e )
    {
        // save the error
        WMISaveError( e );

        // save the hr value if needed by the caller
        if ( phr != NULL )
        {
            *phr = e.Error();
        }
    }

    // ...
    if ( pbLocalSystem != NULL )
    {
        *pbLocalSystem = bLocalSystem;
    }

    // return the result
    return bResult;
}

/*********************************************************************************************
Routine Description:

    This function is a wrapper function for the ConnectWmi function.

Arguments:

    [in] IWbemLocator           :   pointer to the IWbemLocator
    [in] IWbemServices          :   pointer to the IWbemServices
    [in] LPCWSTR                :   string containing the server name
    [in] LPCWSTR                :   string containing the User name
    [in] LPCWSTR                :   string containing the password
    [in] COAUTHIDENTITY         :   pointer to AUTHIDENTITY structure
    [in] BOOL                   :   set to TRUE if we should try to connect with 
                                    current credentials
    [in] LPCWSTR                :   string containing the namespace to connect to
    [out] HRESULT               :   the hResult value returned
    [out] BOOL                  :   set to TRUE if we are querying for the local system

Return Value:

    TRUE on success
    FALSE on failure  
*********************************************************************************************/
BOOL ConnectWmiEx( IWbemLocator* pLocator, 
                   IWbemServices** ppServices, 
                   LPCWSTR pwszServer, CHString& strUserName, CHString& strPassword, 
                   COAUTHIDENTITY** ppAuthIdentity, 
                   BOOL bNeedPassword, LPCWSTR pwszNamespace, BOOL* pbLocalSystem )
{
    // local variables
    HRESULT hr;
    DWORD dwSize = 0;
    BOOL bResult = FALSE;
    LPWSTR pwszPassword = NULL;
    CHString strBuffer = NULL_STRING;

    // clear the error .. if any
    SetLastError( WBEM_S_NO_ERROR );

    // sometime users want the utility to prompt for the password
    // check what user wants the utility to do
    if ( bNeedPassword == TRUE && strPassword.Compare( L"*" ) == 0 )
    {
        // user wants the utility to prompt for the password
        // so skip this part and let the flow directly jump the password acceptance part
    }
    else
    {
        // try to establish connection to the remote system with the credentials supplied
        if ( strUserName.GetLength() == 0 )
        {
            // user name is empty
            // so, it is obvious that password will also be empty
            // even if password is specified, we have to ignore that
            bResult = ConnectWmi( pLocator, ppServices, 
                pwszServer, NULL, NULL, ppAuthIdentity, FALSE, pwszNamespace, &hr, pbLocalSystem );
        }
        else
        {
            // credentials were supplied
            // but password might not be specified ... so check and act accordingly
            LPCWSTR pwszTemp = NULL;
            BOOL bCheckWithNull = TRUE;
            if ( bNeedPassword == FALSE )
            {
                pwszTemp = strPassword;
                bCheckWithNull = FALSE;
            }

            // ...
            bResult = ConnectWmi( pLocator, ppServices, pwszServer,
                strUserName, pwszTemp, ppAuthIdentity, bCheckWithNull, pwszNamespace, &hr, pbLocalSystem );
        }

        // check the result ... if successful in establishing connection ... return
        if ( bResult == TRUE )
        {
            return TRUE;
        }

        // now check the kind of error occurred
        switch( hr )
        {
        case E_ACCESSDENIED:
            break;

        case WBEM_E_LOCAL_CREDENTIALS:
            // needs to do special processing
            break;

        case WBEM_E_ACCESS_DENIED:
        default:
            // NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
            //       this error code says that user with the current credentials is not
            //       having access permisions to the 'namespace'
            WMISaveError( hr );
            return FALSE;       // no use of accepting the password .. return failure
            break;
        }

        // if failed in establishing connection to the remote terminal
        // even if the password is specifed, then there is nothing to do ... simply return failure
        if ( bNeedPassword == FALSE )
        {
            return FALSE;
        }
    }

    // check whether user name is specified or not
    // if not, get the local system's current user name under whose credentials, the process
    // is running
    if ( strUserName.GetLength() == 0 )
    {
        // sub-local variables
        LPWSTR pwszUserName = NULL;

        try
        {
            // get the required buffer
            pwszUserName = strUserName.GetBufferSetLength( MAX_STRING_LENGTH );
        }
        catch( ... )
        {
            SetLastError( E_OUTOFMEMORY );
            SaveLastError();
            return FALSE;
        }

        // get the user name
        DWORD dwUserLength = MAX_STRING_LENGTH;
        if ( GetUserNameEx( NameSamCompatible, pwszUserName, &dwUserLength ) == FALSE )
        {
            // error occured while trying to get the current user info
            SaveLastError();
            return FALSE;
        }

        // release the extra buffer allocated
        strUserName.ReleaseBuffer();
    }

    try
    {
        // get the required buffer
        pwszPassword = strPassword.GetBufferSetLength( MAX_STRING_LENGTH );
    }
    catch( ... )
    {
        SetLastError( E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // accept the password from the user
    strBuffer.Format( INPUT_PASSWORD, strUserName );
    WriteConsoleW( GetStdHandle( STD_ERROR_HANDLE ), 
        strBuffer, strBuffer.GetLength(), &dwSize, NULL );
    
    bResult = GetPassword( pwszPassword, MAX_PASSWORD_LENGTH );
    if ( bResult != TRUE )
    {
        return FALSE;
    }

    // release the buffer allocated for password
    strPassword.ReleaseBuffer();

    // now again try to establish the connection using the currently
    // supplied credentials
    bResult = ConnectWmi( pLocator, ppServices, pwszServer,
        strUserName, strPassword, ppAuthIdentity, FALSE, pwszNamespace, NULL, pbLocalSystem );

    // return the failure
    return bResult;
}

/*********************************************************************************************
Routine Description:

    This function gets the values for the security services.

Arguments:
    
    [in] IUnknown   :   pointer to the IUnkown interface
    [out] DWORD     :   to hold the authentication service value
    [out] DWORD     :   to hold the authorization service value

Return Value:
    
    HRESULT
*********************************************************************************************/
HRESULT GetSecurityArguments( IUnknown* pInterface, 
                              DWORD& dwAuthorization, DWORD& dwAuthentication )
{
    // local variables
    HRESULT hr;
    DWORD dwAuthnSvc = 0, dwAuthzSvc = 0;
    IClientSecurity* pClientSecurity = NULL;

    // try to get the client security services values if possible
    hr = pInterface->QueryInterface( IID_IClientSecurity, (void**) &pClientSecurity );
    if ( SUCCEEDED( hr ) )
    {
        // got the client security interface
        // now try to get the security services values
        hr = pClientSecurity->QueryBlanket( pInterface, 
            &dwAuthnSvc, &dwAuthzSvc, NULL, NULL, NULL, NULL, NULL );
        if ( SUCCEEDED( hr ) )
        {
            // we've got the values from the interface
            dwAuthentication = dwAuthnSvc;
            dwAuthorization = dwAuthzSvc;
        }

        // release the client security interface
        SAFE_RELEASE( pClientSecurity );
    }

    // return always success
    return S_OK;
}

/*********************************************************************************************
Routine Description:

    This function sets the interface security parameters.

Arguments:
    
    [in] IUnknown           :   pointer to the IUnkown interface
    [in] LPCWSTR            :   string containing the server name
    [in] LPCWSTR            :   string containing the User name
    [in] LPCWSTR            :   string containing the password
    [in] COAUTHIDENTITY     :   pointer to AUTHIDENTITY structure

Return Value:

    HRESULT
*********************************************************************************************/
HRESULT SetInterfaceSecurity( IUnknown* pInterface, 
                              LPCWSTR pwszServer, LPCWSTR pwszUser, 
                              LPCWSTR pwszPassword, COAUTHIDENTITY** ppAuthIdentity )
{
    // local variables
    HRESULT hr;
    CHString strUser;
    CHString strDomain;
    LPCWSTR pwszUserArg = NULL;
    LPCWSTR pwszDomainArg = NULL;
    DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
    DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

    // check the interface
    if ( pInterface == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // check the authentity strcuture ... if authentity structure is already ready
    // simply invoke the 2nd version of SetInterfaceSecurity
    if ( *ppAuthIdentity != NULL )
    {
        return SetInterfaceSecurity( pInterface, *ppAuthIdentity );
    }

    // get the current security argument value
    /*hr = GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );
    if ( FAILED( hr ) )
    {
        return hr;
    }*/

    // If we are doing trivial case, just pass in a null authenication structure 
    // for which the current logged in user's credentials will be considered
    if ( pwszUser == NULL && pwszPassword == NULL )
    {
        // set the security
        hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, 
            NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

        // return the result
        return hr;
    }

    // parse and find out if the user name contains the domain name
    // if contains, extract the domain value from it
    LONG lPos = -1;
    strDomain = L"";
    strUser = pwszUser;
    if ( ( lPos = strUser.Find( L'\\' ) ) != -1 )
    {
        // user name contains domain name ... domain\user format
        strDomain = strUser.Left( lPos );
        strUser = strUser.Mid( lPos + 1 );
    }
    else if ( ( lPos = strUser.Find( L'@' ) ) != -1 )
    {
        // NEED TO IMPLEMENT THIS ... IF NEEDED
        // This implementation needs to be done if WMI does not support
        // UPN name formats directly and if we have to split the 
        // name(user@domain)
    }
    else
    {
        // server itself is the domain
        // NOTE: NEED TO DO SOME R & D ON BELOW COMMENTED LINE
        // strDomain = pwszServer;
    }

    // get the domain info if it exists only
    if ( strDomain.GetLength() != 0 )
    {
        pwszDomainArg = strDomain;
    }

    // get the user info if it exists only
    if ( strUser.GetLength() != 0 )
    {
        pwszUserArg = strUser;
    }

    // check if authenication info is available or not ...
    // initialize the security authenication information ... UNICODE VERSION STRUCTURE
    if ( ppAuthIdentity == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    else if ( *ppAuthIdentity == NULL )
    {
        hr = WbemAllocAuthIdentity( pwszUserArg, pwszPassword, pwszDomainArg, ppAuthIdentity );
        if ( hr != S_OK )
        {
            return hr;
        }
    }

    // set the security information to the interface
    hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
        RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, *ppAuthIdentity, EOAC_NONE );

    // return the result
    return hr;
}

/*********************************************************************************************
Routine Description:

    This function sets the interface security parameters.

Arguments:
    
    [in] IUnknown           :   pointer to the IUnkown interface
    [in] COAUTHIDENTITY     :   pointer to AUTHIDENTITY structure

Return Value:

    HRESULT
*********************************************************************************************/
HRESULT SetInterfaceSecurity( IUnknown* pInterface, COAUTHIDENTITY* pAuthIdentity )
{
    // local variables
    HRESULT hr;
    LPWSTR pwszDomain = NULL;
    DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
    DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

    // check the interface
    if ( pInterface == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // get the current security argument value
    hr = GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    // set the security information to the interface
    hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
        RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, pAuthIdentity, EOAC_NONE );

    // return the result
    return hr;
}

/*********************************************************************************************
Routine Description:

    This function sets the authentication information (the security blanket) 
    that will be used to make calls.

Arguments:

    [in] IUnknown                       :   pointer to the IUnkown interface
    [in] DWORD                          :   contains the authentication service to use
    [in] DWORD                          :   contains the authorization service to use
    [in] LPWSTR                         :   the server principal name to use
    [in] DWORD                          :   contains the authentication level to use
    [in] DWORD                          :   contains the impersonation level to use
    [in] RPC_AUTH_IDENTITY_HANDLE       :   pointer to the identity of the client
    [in] DWORD                          :   contains the capability flags

Return Value:

    HRESULT
*********************************************************************************************/
HRESULT WINAPI SetProxyBlanket( IUnknown* pInterface,
                                DWORD dwAuthnSvc, DWORD dwAuthzSvc,
                                LPWSTR pwszPrincipal, DWORD dwAuthLevel, DWORD dwImpLevel,
                                RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities )
{
    // local variables
    HRESULT hr;
    IUnknown * pUnknown = NULL;
    IClientSecurity * pClientSecurity = NULL;

    // get the IUnknown interface ... to check whether this is a valid interface or not
    hr = pInterface->QueryInterface( IID_IUnknown, (void **) &pUnknown );
    if ( hr != S_OK )
    {
        return hr;
    }

    // now get the client security interface
    hr = pInterface->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
    if ( hr != S_OK )
    {
        SAFE_RELEASE( pUnknown );
        return hr;
    }

    //
    // Can't set pAuthInfo if cloaking requested, as cloaking implies
    // that the current proxy identity in the impersonated thread (rather
    // than the credentials supplied explicitly by the RPC_AUTH_IDENTITY_HANDLE)
    // is to be used.
    // See MSDN info on CoSetProxyBlanket for more details.
    //
    if ( dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING) )
    {
        pAuthInfo = NULL;
    }

    // now set the security
    hr = pClientSecurity->SetBlanket( pInterface, dwAuthnSvc, dwAuthzSvc, pwszPrincipal,
                                        dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pUnknown );
        SAFE_RELEASE( pClientSecurity );
        return hr;
    }

    // release the security interface
    SAFE_RELEASE( pClientSecurity );

    // we should check the auth identity structure. if exists .. set for IUnknown also
    if ( pAuthInfo != NULL )
    {
        hr = pUnknown->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
        if ( hr == S_OK )
        {
            // set security authentication
            hr = pClientSecurity->SetBlanket( pUnknown, dwAuthnSvc, dwAuthzSvc, pwszPrincipal, 
                                                dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );
            
            // release
            SAFE_RELEASE( pClientSecurity );
        }
        else if ( hr == E_NOINTERFACE )
        {
            hr = S_OK;      // ignore no interface errors
        }
    }

    // release the IUnknown
    SAFE_RELEASE( pUnknown );

    // return the result
    return hr;
}

/*********************************************************************************************
Routine Description:

    This function allocates memory for the AUTHIDENTITY structure.

Arguments:

    [in] LPCWSTR            :   string containing the user name
    [in] LPCWSTR            :   string containing the password
    [in] LPCWSTR            :   string containing the domain name
    [out] COAUTHIDENTITY    :   pointer to the pointer to AUTHIDENTITY structure

Return Value:

    HRESULT
*********************************************************************************************/
HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser, LPCWSTR pwszPassword, 
                                      LPCWSTR pwszDomain, COAUTHIDENTITY** ppAuthIdent )
{
    // local variables
    COAUTHIDENTITY* pAuthIdent = NULL;

    // validate the input parameter
    if ( ppAuthIdent == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // allocation thru COM API
    pAuthIdent = ( COAUTHIDENTITY* ) CoTaskMemAlloc( sizeof( COAUTHIDENTITY ) );
    if ( NULL == pAuthIdent )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    // init with 0's
    ZeroMemory( ( void* ) pAuthIdent, sizeof( COAUTHIDENTITY ) );

    //
    // Allocate needed memory and copy in data.  Cleanup if anything goes wrong

    // user
    if ( pwszUser != NULL )
    {
        // allocate memory for user
        LONG lLength = wcslen( pwszUser ); 
        pAuthIdent->User = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->User == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->UserLength = lLength;
        wcscpy( pAuthIdent->User, pwszUser );
    }

    // domain
    if ( pwszDomain != NULL )
    {
        // allocate memory for domain
        LONG lLength = wcslen( pwszDomain ); 
        pAuthIdent->Domain = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->Domain == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->DomainLength = lLength;
        wcscpy( pAuthIdent->Domain, pwszDomain );
    }

    // passsord
    if ( pwszPassword != NULL )
    {
        // allocate memory for passsord
        LONG lLength = wcslen( pwszPassword ); 
        pAuthIdent->Password = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->Password == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

        // set the length and do copy contents
        pAuthIdent->PasswordLength = lLength;
        wcscpy( pAuthIdent->Password, pwszPassword );
    }

    // type of the structure
    pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    // final set the address to out parameter
    *ppAuthIdent = pAuthIdent;

    // return result
    return S_OK;
}

/*********************************************************************************************
Routine Description:

    This function releases the memory allocated for the AUTHIDENTITY structure.

Arguments:

    [in] COAUTHIDENTITY     :   pointer to the pointer to AUTHIDENTITY structure
    
Return Value:

    None
*********************************************************************************************/
VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY** ppAuthIdentity )
{
    // make sure we have a pointer, then walk the structure members and  cleanup.
    if ( *ppAuthIdentity != NULL )
    {
        // free the memory allocated for user
        if ( (*ppAuthIdentity)->User != NULL )
        {
            CoTaskMemFree( (*ppAuthIdentity)->User );
        }

        // free the memory allocated for password
        if ( (*ppAuthIdentity)->Password != NULL )
        {
            CoTaskMemFree( (*ppAuthIdentity)->Password );
        }

        // free the memory allocated for domain
        if ( (*ppAuthIdentity)->Domain != NULL )
        {
            CoTaskMemFree( (*ppAuthIdentity)->Domain );
        }

        // final the structure
        CoTaskMemFree( *ppAuthIdentity );
    }

    // set to NULL
    *ppAuthIdentity = NULL;
}

/*********************************************************************************************
Routine Description:

    This function saves the description of the last error returned by WMI

Arguments:

    HRESULT     :   The last return value from WMI

Return Value:

    NONE
*********************************************************************************************/
VOID WMISaveError( HRESULT hrError )
{
    // local variables
    HRESULT hr;
    CHString strBuffer = NULL_STRING;
    IWbemStatusCodeText* pWbemStatus = NULL;

    // if the error is win32 based, choose FormatMessage to get the message
    switch( hrError )
    {
    case E_ACCESSDENIED:            // Message: "Access Denied"
    case ERROR_NO_SUCH_USER:        // Message: "The specified user does not exist."
        {
            // change the error message to "Logon failure: unknown user name or bad password." 
            if ( hrError == E_ACCESSDENIED )
            {
                hrError = ERROR_LOGON_FAILURE;
            }

            // ...
            SetLastError( hrError );
            SaveLastError();
            return;
        }
    }

    try
    {
        // get the pointer to buffer
        LPWSTR pwszBuffer = NULL;
        pwszBuffer = strBuffer.GetBufferSetLength( MAX_STRING_LENGTH );

        // get the wbem specific status code text
        hr = CoCreateInstance( CLSID_WbemStatusCodeText, 
            NULL, CLSCTX_INPROC_SERVER, IID_IWbemStatusCodeText, (LPVOID*) &pWbemStatus );

        // check whether we got the interface or not
        if ( SUCCEEDED( hr ) )
        {
            // get the error message
            BSTR bstr = NULL;
            hr = pWbemStatus->GetErrorCodeText( hrError, 0, 0, &bstr );
            if ( SUCCEEDED( hr ) )
            {
                // get the error message in proper format
                GetCompatibleStringFromUnicode( bstr, pwszBuffer, MAX_STRING_LENGTH );

                //
                // supress all the new-line characters and add '.' at the end ( if not exists )
                LPWSTR pwszTemp = NULL;
                pwszTemp = wcstok( pwszBuffer, L"\r\n" );
                if ( *( pwszTemp + lstrlenW( pwszTemp ) - 1 ) != L'.' )
                {
                    lstrcatW( pwszTemp, L"." );
                }

                // free the BSTR
                SysFreeString( bstr );
                bstr = NULL;

                // now release status code interface
                SAFE_RELEASE( pWbemStatus );
            }
            else
            {
                // failed to get the error message ... get the com specific error message
                _com_issue_error( hrError );
            }
        }
        else
        {
            // failed to get the error message ... get the com specific error message
            _com_issue_error( hrError );
        }

        // release the buffer
        strBuffer.ReleaseBuffer();
    }
    catch( _com_error& e )
    {
        try
        {
            // get the error message
            strBuffer.ReleaseBuffer();
            if ( e.ErrorMessage() != NULL )
                strBuffer = e.ErrorMessage();
        }
        catch( ... )
        {
            SetLastError( E_OUTOFMEMORY );
            SaveLastError();
        }
    }
    catch( ... )
    {
        SetLastError( E_OUTOFMEMORY );
        SaveLastError();
        return;
    }

    // set the reason
    strBuffer += L"\n";
    SetReason( strBuffer );
}

/*********************************************************************************************
Routine Description:

    Gets the value of the property from the WMI class object

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   property name
    [out] _variant_t            :   value of the property

Return Value:

    HRESULT
*********************************************************************************************/
HRESULT PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue )
{
    // local variables
    HRESULT hr;
    VARIANT vtValue;

    // check with object and property passed to the function are valid or not
    // if not, return failure
    if ( pWmiObject == NULL || pwszProperty == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        // initialize the variant and then get the value of the specified property
        VariantInit( &vtValue );
        hr = pWmiObject->Get( _bstr_t( pwszProperty ), 0, &vtValue, NULL, NULL );
        if ( FAILED( hr ) )
        {
            // clear the variant variable
            VariantClear( &vtValue );

            // failed to get the value for the property
            return hr;
        }

        // set the value
        varValue = vtValue;

        // clear the variant variable
        VariantClear( &vtValue );
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return e.Error();
    }

    // inform success
    return S_OK;
}

/*********************************************************************************************
Routine Description:

    Gets the value of the property from the WMI class object in string format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] CHString              :   variable to hold the retrieved property
    [in] LPCWSTR                :   string containing the default value for the property

Return Value:

    TRUE on success
    FALSE on failure  
*********************************************************************************************/
BOOL PropertyGet( IWbemClassObject* pWmiObject, 
                  LPCWSTR pwszProperty, CHString& strValue, LPCWSTR pwszDefault )
{
    // local variables
    HRESULT hr;
    _variant_t var;

    // first copy the default value
    strValue = pwszDefault;

    // check with object and property passed to the function are valid or not
    // if not, return failure
    if ( pWmiObject == NULL || pwszProperty == NULL )
    {
        return FALSE;
    }

    // get the property value
    hr = PropertyGet( pWmiObject, pwszProperty, var );
    if ( FAILED( hr ) )
    {
        return FALSE;
    }

    try
    {
        // get the value
        if ( var.vt != VT_NULL && var.vt != VT_EMPTY )
        {
            strValue = (LPCWSTR) _bstr_t( var );
        }
    }
    catch( ... )
    {
        SetLastError( E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // return
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    Gets the value of the property from the WMI class object in dword format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] DWORD                 :   variable to hold the retrieved property
    [in] DWORD                  :   dword containing the default value for the property

Return Value:

    TRUE on success
    FALSE on failure  
*********************************************************************************************/
BOOL PropertyGet( IWbemClassObject* pWmiObject, 
                  LPCWSTR pwszProperty,  DWORD& dwValue, DWORD dwDefault )
{
    // local variables
    HRESULT hr;
    _variant_t var;

    // first set the defaul value
    dwValue = dwDefault;

    // check with object and property passed to the function are valid or not
    // if not, return failure
    if ( pWmiObject == NULL || pwszProperty == NULL )
    {
        return FALSE;
    }

    // get the value of the property
    hr = PropertyGet( pWmiObject, pwszProperty, var );
    if ( FAILED( hr ) )
    {
        return FALSE;
    }

    // get the process id from the variant
    if ( var.vt != VT_NULL && var.vt != VT_EMPTY )
    {
        dwValue = (LONG) var;
    }

    // return
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    Gets the value of the property from the WMI class object in bool format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] BOOL                  :   variable to hold the retrieved property
    [in] BOOL                   :   bool containing the default value for the property

Return Value:

    TRUE on success
    FALSE on failure   
*********************************************************************************************/
BOOL PropertyGet( IWbemClassObject* pWmiObject, 
                  LPCWSTR pwszProperty,  BOOL& bValue, BOOL bDefault )
{
    // local variables
    HRESULT hr;
    _variant_t var;

    // first set the default value
    bValue = bDefault;

    // check with object and property passed to the function are valid or not
    // if not, return failure
    if ( pWmiObject == NULL || pwszProperty == NULL )
    {
        return FALSE;
    }

    // get the value of the property
    hr = PropertyGet( pWmiObject, pwszProperty, var );
    if ( FAILED( hr ) )
    {
        return FALSE;
    }

    // get the process id from the variant
    if ( var.vt != VT_NULL && var.vt != VT_EMPTY )
    {
        bValue = var.boolVal;
    }
    
    // return
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    Gets the value of the property from the WMI class object in ulongulong format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] ULONGULONG            :   variable to hold the retrieved property
    
Return Value:

    TRUE on success
    FALSE on failure  
*********************************************************************************************/
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  ULONGLONG& ullValue )
{
    // local variables
    CHString str;

    // first set the default value
    ullValue = 1;

    // check with object and property passed to the function are valid or not
    // if not, return failure
    if ( pWmiObject == NULL || pwszProperty == NULL )
    {
        return FALSE;
    }

    // get the value of the property
    if ( PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) == FALSE )
    {
        return FALSE;
    }

    // get the 64-bit value
    ullValue = _wtoi64( str );

    // return
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    Gets the value of the property from the WMI class object in wbemtime format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] WBEMTime              :   variable to hold the retrieved property
    
Return Value:

    TRUE on success
    FALSE on failure   
*********************************************************************************************/
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  WBEMTime& wbemtime )
{
    // local variables
    CHString str;

    // Clear method sets the time in the WBEMTime object to an invalid time.
    wbemtime.Clear();

    // check with object and property passed to the function are valid or not
    // if not, return failure
    if ( pWmiObject == NULL || pwszProperty == NULL )
    {
        return FALSE;
    }

    // get the value of the property
    if ( PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) == FALSE )
    {
        return FALSE;
    }

    try
    {
        // convert into the time value
        wbemtime = _bstr_t( str );
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return FALSE;
    }

    // return
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    Gets the value of the property from the WMI class object in systemtime format

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [out] WBEMTime              :   variable to hold the retrieved property
    
Return Value:

    TRUE on success
    FALSE on failure   

*********************************************************************************************/
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  SYSTEMTIME& systime )
{
    // local variables
    CHString strTime;

    // check with object and property passed to the function are valid or not
    // if not, return failure
    if ( pWmiObject == NULL || pwszProperty == NULL )
    {
        return FALSE;
    }

    // get the value of the property
    // 16010101000000.000000+000 is the default time
    if ( PropertyGet( pWmiObject, pwszProperty, strTime, _T( "16010101000000.000000+000" ) ) == FALSE )
    {
        return FALSE;
    }

    // prepare the systemtime structure
    // yyyymmddHHMMSS.mmmmmmsUUU
    systime.wYear = (WORD) AsLong( strTime.Left( 4 ), 10 );
    systime.wMonth = (WORD) AsLong( strTime.Mid( 4, 2 ), 10 );
    systime.wDayOfWeek = 0;
    systime.wDay = (WORD) AsLong( strTime.Mid( 6, 2 ), 10 );
    systime.wHour = (WORD) AsLong( strTime.Mid( 8, 2 ), 10 );
    systime.wMinute = (WORD) AsLong( strTime.Mid( 10, 2 ), 10 );
    systime.wSecond = (WORD) AsLong( strTime.Mid( 12, 2 ), 10 );
    systime.wMilliseconds = (WORD) AsLong( strTime.Mid( 15, 6 ), 10 );

    // return
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    Sets the value of the property to the WMI class object

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [in] WBEMTime               :   variable holding the property to set
    
Return Value:

    TRUE on success
    FALSE on failure   
*********************************************************************************************/
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue )
{
    // local variables
    HRESULT hr;
    VARIANT var;

    // check the input value
    if ( pWmiObject == NULL || pwszProperty == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        // put the value
        var = varValue;
        hr = pWmiObject->Put( _bstr_t( pwszProperty ), 0, &var, 0 );
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        hr = e.Error();
    }
    
    // return the result
    return hr;
}

/*********************************************************************************************
Routine Description:

    Sets the string value of the property to the WMI class object

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [in] LPCWSTR                :   variable holding the property to set
    
Return Value:

    TRUE on success
    FALSE on failure   
*********************************************************************************************/
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, LPCWSTR pwszValue )
{
    // local variables
    HRESULT hr = S_OK;
    _variant_t varValue;

    // check the input value
    if ( pWmiObject == NULL || pwszProperty == NULL || pwszValue == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        varValue = pwszValue;
        PropertyPut( pWmiObject, pwszProperty, varValue );
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        hr = e.Error();
    }

    // return 
    return hr;
}

/*********************************************************************************************
Routine Description:

    Sets the dword value of the property to the WMI class object

Arguments:

    [in] IWbemClassObject       :   pointer to the WBEM class object
    [in] LPCWSTR                :   the name of the property to retrieve
    [in] DWORD                  :   variable holding the property to set
    
Return Value:

    TRUE on success
    FALSE on failure   
*********************************************************************************************/
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, DWORD dwValue )
{
    // local variables
    HRESULT hr;
    _variant_t varValue;

    // check the input value
    if ( pWmiObject == NULL || pwszProperty == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        varValue = ( LONG ) dwValue;
        PropertyPut( pWmiObject, pwszProperty, varValue );
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        hr = e.Error();
    }

    // return 
    return hr;
}

/*********************************************************************************************
Routine Description:

    This function retrieves the value of the property from the specified registry key.

Arguments:

    [in] IWbemServices          :   pointer to the IWbemServices object
    [in] LPCWSTR                :   the name of the method to execute
    [in] DWORD                  :   the key in the registry whose value has to be retrieved
    [in] LPCWSTR                :   the name of the subkey to retrieve
    [in] LPCWSTR                :   the name of the value to retrieve
    [in] _variant_t             :   variable holding the property value retrieved
    
Return Value:

    TRUE on success
    FALSE on failure   
*********************************************************************************************/
HRESULT RegQueryValueWMI( IWbemServices* pWbemServices, 
                          LPCWSTR pwszMethod, DWORD dwHDefKey, 
                          LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, _variant_t& varValue )
{
    // local variables
    HRESULT hr;
    BOOL bResult = FALSE;
    DWORD dwReturnValue = 0;
    IWbemClassObject* pClass = NULL;
    IWbemClassObject* pMethod = NULL;
    IWbemClassObject* pInParams = NULL;
    IWbemClassObject* pInParamsInstance = NULL;
    IWbemClassObject* pOutParamsInstance = NULL;

    // check the input value
    if (pWbemServices == NULL || pwszMethod == NULL || pwszSubKeyName == NULL || pwszValueName == NULL)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    try
    {
        // get the registry class object
        SAFE_EXECUTE( pWbemServices->GetObject( 
            _bstr_t( WMI_REGISTRY ), WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pClass, NULL ) );
        if ( pClass == NULL )                       // check the object .. safety sake
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // get the method reference required
        SAFE_EXECUTE( pClass->GetMethod( pwszMethod, 0, &pInParams, NULL ) );
        if ( pInParams == NULL )                    // check the object .. safety sake
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // create the instance for the in parameters
        SAFE_EXECUTE( pInParams->SpawnInstance( 0, &pInParamsInstance ) );
        if ( pInParamsInstance == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // set the input values
        PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_HDEFKEY ), dwHDefKey );
        PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_SUBKEY ), pwszSubKeyName );
        PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_VALUENAME ), pwszValueName );

        // now execute the method
        SAFE_EXECUTE( pWbemServices->ExecMethod( _bstr_t( WMI_REGISTRY ),
            _bstr_t( pwszMethod ), 0, NULL, pInParamsInstance, &pOutParamsInstance, NULL ) );
        if ( pOutParamsInstance == NULL )           // check the object .. safety sake
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // now check the return value of the method from the output params object
        bResult = PropertyGet( pOutParamsInstance, 
            _bstr_t( WMI_REGISTRY_OUT_RETURNVALUE ), dwReturnValue );
        if ( bResult == FALSE || dwReturnValue != 0 )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // now everything is sucess .. get the required value
        if ( lstrcmp( pwszMethod, WMI_REGISTRY_M_DWORDVALUE ) == 0 )
        {
            PropertyGet( pOutParamsInstance, _bstr_t( WMI_REGISTRY_OUT_VALUE_DWORD ), varValue );
        }
        else
        {
            PropertyGet( pOutParamsInstance, _bstr_t( WMI_REGISTRY_OUT_VALUE ), varValue );
        }
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return e.Error();
    }

    // release the interfaces
    SAFE_RELEASE( pClass );
    SAFE_RELEASE( pMethod );
    SAFE_RELEASE( pInParams );
    SAFE_RELEASE( pInParamsInstance );
    SAFE_RELEASE( pOutParamsInstance );

    // return success
    return S_OK;
}

/*********************************************************************************************
Routine Description:

    This function retrieves the string value of the property from the specified registry key.

Arguments:

    [in] IWbemServices          :   pointer to the IWbemServices object
    [in] DWORD                  :   the key in the registry whose value has to be retrieved
    [in] LPCWSTR                :   the name of the subkey to retrieve
    [in] LPCWSTR                :   the name of the value to retrieve
    [out] CHString              :   variable holding the property value retrieved
    [in] LPCWSTR                :   the default value for this property
    
Return Value:

    TRUE on success
    FALSE on failure   
*********************************************************************************************/
BOOL RegQueryValueWMI( IWbemServices* pWbemServices, 
                       DWORD dwHDefKey, LPCWSTR pwszSubKeyName, 
                       LPCWSTR pwszValueName, CHString& strValue, LPCWSTR pwszDefault )
{
    // local variables
    HRESULT hr;
    _variant_t varValue;

    try
    {
        // set the default value
        if ( pwszDefault != NULL )
        {
            strValue = pwszDefault;
        }

        // check the input
        if ( pWbemServices == NULL || pwszSubKeyName == NULL || pwszValueName == NULL )
        {
            return FALSE;
        }

        // get the value
        hr = RegQueryValueWMI( pWbemServices, 
            WMI_REGISTRY_M_STRINGVALUE, dwHDefKey, pwszSubKeyName, pwszValueName, varValue );
        if ( FAILED( hr ) )
        {
            return FALSE;
        }

        // get the value from the variant
        // get the value
        if ( varValue.vt != VT_NULL && varValue.vt != VT_EMPTY )
        {
            strValue = (LPCWSTR) _bstr_t( varValue );
        }
    }
    catch( ... )
    {
        SetLastError( E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // return success
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    This function retrieves the dword value of the property from the specified registry key.

Arguments:

    [in] IWbemServices          :   pointer to the IWbemServices object
    [in] DWORD                  :   the key in the registry whose value has to be retrieved
    [in] LPCWSTR                :   the name of the subkey to retrieve
    [in] LPCWSTR                :   the name of the value to retrieve
    [out] DWORD                 :   variable holding the property value retrieved
    [in] DWORD                  :   the default value for this property
    
Return Value:

    TRUE on success
    FALSE on failure   
*********************************************************************************************/
BOOL RegQueryValueWMI( IWbemServices* pWbemServices, 
                       DWORD dwHDefKey, LPCWSTR pwszSubKeyName, 
                       LPCWSTR pwszValueName, DWORD& dwValue, DWORD dwDefault )
{
    // local variables
    HRESULT hr;
    _variant_t varValue;

    try
    {
        // set the default value
        dwValue = dwDefault;
        
        // check the input
        if ( pWbemServices == NULL || pwszSubKeyName == NULL || pwszValueName == NULL )
        {
            return FALSE;
        }

        // get the value
        hr = RegQueryValueWMI( pWbemServices, WMI_REGISTRY_M_DWORDVALUE, dwHDefKey, 
                                pwszSubKeyName, pwszValueName, varValue );
        if ( FAILED( hr ) )
        {
            return FALSE;
        }

        // get the value from the variant
        // get the value
        if ( varValue.vt != VT_NULL && varValue.vt != VT_EMPTY )
        {
            dwValue = (LONG) varValue;
        }
    }
    catch( ... )
    {
        SetLastError( E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // return success
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    This function gets the version of the system from which we are trying to retrieve
    information from.

Arguments:

    [in] IWbemServices      :   pointer to the IWbemServices object
    [in] COAUTHIDENTITY     :   pointer to the pointer to AUTHIDENTITY structure

Return Value:

    DWORD   -   Target version of the machine
*********************************************************************************************/
DWORD GetTargetVersionEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity )
{
    // local variables
    HRESULT hr;
    LONG lPos = 0;
    DWORD dwMajor = 0;
    DWORD dwMinor = 0;
    DWORD dwVersion = 0;
    ULONG ulReturned = 0;
    CHString strVersion;
    IWbemClassObject* pWbemObject = NULL;
    IEnumWbemClassObject* pWbemInstances = NULL;

    // check the input value
    if ( pWbemServices == NULL )
    {
        return 0;
    }

    try
    {
        // get the OS information
        SAFE_EXECUTE( pWbemServices->CreateInstanceEnum( 
            _bstr_t( CLASS_CIMV2_Win32_OperatingSystem ), 0, NULL, &pWbemInstances ) );

        // set the security on the enumerated object
        SAFE_EXECUTE( SetInterfaceSecurity( pWbemInstances, pAuthIdentity ) );

        // get the enumerated objects information
        // NOTE: This needs to be traversed only one time. 
        SAFE_EXECUTE( pWbemInstances->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned ) );

        // to be on safer side ... check the count of objects returned
        if ( ulReturned == 0 )
        {
            // release the interfaces
            SAFE_RELEASE( pWbemObject );
            SAFE_RELEASE( pWbemInstances );
            return 0;
        }

        // now get the os version value
        if ( PropertyGet( pWbemObject, L"Version", strVersion ) == FALSE )
        {
            // release the interfaces
            SAFE_RELEASE( pWbemObject );
            SAFE_RELEASE( pWbemInstances );
            return 0;
        }

        // release the interfaces .. we dont need them furthur
        SAFE_RELEASE( pWbemObject );
        SAFE_RELEASE( pWbemInstances );
    
        //
        // now determine the os version
        dwMajor = dwMinor = 0;

        // get the major version
        lPos = strVersion.Find( L'.' );
        if ( lPos == -1 )
        {
            // the version string itself is version ... THIS WILL NEVER HAPPEN
            dwMajor = AsLong( strVersion, 10 );
        }
        else
        {
            // major version
            dwMajor = AsLong( strVersion.Mid( 0, lPos ), 10 );

            // get the minor version
            strVersion = strVersion.Mid( lPos + 1 );
            lPos = strVersion.Find( L'.' );
            if ( lPos == -1 )
            {
                dwMinor = AsLong( strVersion, 10 );
            }
            else
            {
                dwMinor = AsLong( strVersion.Mid( 0, lPos ), 10 );
            }
        }

        // mix the version info
        dwVersion = dwMajor * 1000 + dwMinor;
    }
    catch( _com_error& e )
    {
        WMISaveError( e );
        return 0;
    }

    // return 
    return dwVersion;
}

/*********************************************************************************************
Routine Description:

    This function retrieves a property from the safe array.

Arguments:

    [in] SAFEARRAY          :   pointer to the array of elements
    [in] LONG               :   index to retrieve the data from
    [out] CHString          :   variable to hold the return value
    [in] VARTYPE            :   The type of variable to retrieve from the array

Return Value:

    TRUE on success
    FALSE on failure   
*********************************************************************************************/
BOOL GetPropertyFromSafeArray( SAFEARRAY *pSafeArray, LONG lIndex, CHString& strValue, 
                                VARTYPE vartype )
{
    // check the inputs
    if ( pSafeArray == NULL )
    {
        return FALSE;
    }

    try
    {
        // sub-local variables
        VARIANT var;
            
        // get the value
        V_VT( &var ) = vartype;
        SafeArrayGetElement( pSafeArray, &lIndex, &V_UI1( &var ) );

        // add the information to the dynamic array
        switch( vartype )
        {
        case VT_BSTR:
            strValue = V_BSTR( &var );
            break;
        default:
            return FALSE;
        }
    }
    catch( ... )
    {
        return FALSE;   // failure
    }

    // return
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    This function retrieves a property from the safe array.

Arguments:

    [in] SAFEARRAY          :   pointer to the array of elements
    [in] LONG               :   index to retrieve the data from
    [out] IWbemClassObject  :   variable to hold the return value
    [in] VARTYPE            :   The type of variable to retrieve from the array

Return Value:

    TRUE on success
    FALSE on failure   
*********************************************************************************************/
BOOL GetPropertyFromSafeArray( SAFEARRAY *pSafeArray, LONG lIndex, 
                                IWbemClassObject **pScriptObject, VARTYPE vartype )
{
    // check the inputs
    if ( pSafeArray == NULL )
    {
        return FALSE;
    }

    try
    {
        // sub-local variables
        VARIANT var;
            
        // get the value
        V_VT( &var ) = vartype;
        SafeArrayGetElement( pSafeArray, &lIndex, &V_UI1( &var ) );

        // add the information to the dynamic array
        switch( vartype )
        {
        case VT_UNKNOWN:
            *pScriptObject = (IWbemClassObject *) var.punkVal;
            break;
        default:
            return FALSE;
        }
    }
    catch( ... )
    {
        return FALSE;   // failure
    }

    // return
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\lib\cmdlineparser.c ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//  
// 	  CmdLineParser.c
//  
//  Abstract:
//  
// 	  This modules implements parsing of command line arguments for the specified options
// 	
//  Author:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 1-Sep-2000
//  
//  Revision History:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 1-Sep-2000 : Created It.
//  
// *********************************************************************************
#include "pch.h"
#include "cmdline.h"
#include "CmdLineRes.h"

//
// macros
//
#define CHECK_FLAG( value, mask, flag )	( ( value & mask ) == flag ? TRUE : FALSE )
#define TYPEIS_NUMERIC( flag )	( CHECK_FLAG( flag, CP_TYPE_MASK, CP_TYPE_NUMERIC ) )

//
// defines / constants / enumerations
//
#define	OPTION_CHARACTERS			_T( "-/" )

// error messages
#define ERROR_CMDPARSER_LENGTH_EXCEEDED				\
			GetResString( IDS_ERROR_CMDPARSER_LENGTH_EXCEEDED )
#define ERROR_CMDPARSER_VALUE_EXPECTED				\
			GetResString( IDS_ERROR_CMDPARSER_VALUE_EXPECTED )
#define ERROR_CMDPARSER_NOTINLIST					\
			GetResString( IDS_ERROR_CMDPARSER_NOTINLIST )
#define ERROR_CMDPARSER_INVALID_NUMERIC				\
			GetResString( IDS_ERROR_CMDPARSER_INVALID_NUMERIC )
#define ERROR_CMDPARSER_INVALID_FLOAT				\
			GetResString( IDS_ERROR_CMDPARSER_INVALID_FLOAT )
#define ERROR_CMDPARSER_OPTION_REPEATED				\
			GetResString( IDS_ERROR_CMDPARSER_OPTION_REPEATED )
#define ERROR_CMDPARSER_MANDATORY_OPTION_MISSING	\
			GetResString( IDS_ERROR_CMDPARSER_MANDATORY_OPTION_MISSING )
#define ERROR_CMDPARSER_INVALID_OPTION				\
			GetResString( IDS_ERROR_CMDPARSER_INVALID_OPTION )
#define ERROR_CMDPARSER_DEFAULT_OPTION_MISSING		\
		GetResString( IDS_ERROR_CMDPARSER_DEFAULT_OPTION_MISSING )
#define ERROR_CMDPARSER_DEFAULT_OPTION_REPEATED		\
			GetResString( IDS_ERROR_CMDPARSER_DEFAULT_OPTION_REPEATED )
#define ERROR_CMDPARSER_DEFAULT_NOTINLIST			\
			GetResString( IDS_ERROR_CMDPARSER_DEFAULT_NOTINLIST )

//
// private functions ... used only within this file
//

// ***************************************************************************
// Routine Description: 
//		returns the argument value is option or not
//		  
// Arguments: 
//		[ in ] szOption	: a pointer to a constant string
//  
// Return Value: 
//		TRUE or FALSE
// 
// ***************************************************************************
BOOL __IsOption( LPCTSTR szOption )
{
	// check the input value
	if ( szOption == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return FALSE;
	}

	// check whether the string starts with '-' or '/' character
	if ( lstrlen( szOption ) > 1 && _tcschr( OPTION_CHARACTERS, szOption[ 0 ] ) != NULL )
		return TRUE;		// string value is an option

	// this is not an option
	return FALSE;
}

// ***************************************************************************
// Routine Description:
//		compares the option value with argument and returns true
//		or false accordingly
//		  
// Arguments:	
//		[in] szOption	:	a pointer to a string which specifies the option
//							against which the argument is to be compared
//		[in] szArgument	:	a pointer to a string which specifies the argument
//							for which the option string is to be compared
//      [in] bIgnoreCase :  Ignore the case
//
// Return Value: 
//      TRUE or FALSE
// 
// ***************************************************************************
BOOL __CompareArgument( LPCTSTR szOption, LPCTSTR szArgument, BOOL bIgnoreCase )
{
	// local variables
	BOOL bResult = FALSE;

	// check the input value
	if ( szOption == NULL || szArgument == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return FALSE;
	}

	// first check whether the argument is an option or not
	// if the argument is not an option, return from here itself
	if ( __IsOption( szArgument ) == FALSE ) 
		return FALSE;

	// do the case-insensitive comparision 
	// Note: here while comparing ignore the first character in the argument
	//		 this is im-material for us ... 'coz we are comparing the option and the argument
	//		 only after confirming that the argument is starting with the option character
	bResult = InString( szArgument + 1, szOption, TRUE );

	// return the result
	return bResult;
}

// ***************************************************************************
// Routine Description: 
//		checks the  cmdOptions array for the given option and  
//		returns the index of the cmdOptions array at which the given option
//		matches
//		  
// Arguments:  
//      [ in ] dwOptions	:	no. of options in the options array
//		[ in ] pcmdOptions	:	an array of TCMDPARSER structors (i.e. options array)
//		[ in ] szOption		:	a pointer to a string which is the option that is to be
//								compared
//
// Return Value: 
//    The index of the options array at which the given option matches
// 
// ***************************************************************************
LONG __MatchOption( DWORD dwOptions, PTCMDPARSER pcmdOptions, LPCTSTR szOption )
{
	// local variables
	DWORD dwIndex = 0;
	BOOL bOption = TRUE;
	LONG lDefaultIndex = -1;				// holds the default options index

	// check the input value
	if ( pcmdOptions == NULL || szOption == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return -1;
	}

	// check whether the passed argument is an option or not.
	// option : starts with '-' or '/'
	bOption = __IsOption( szOption );

	// parse thru the list of options and return the appropriate option id to the caller
	for( dwIndex = 0; dwIndex < dwOptions; dwIndex++ )
	{
		// get the 
		TCMDPARSER cmdparser = pcmdOptions[ dwIndex ];

		// check if the current cmdparser option referes to the default option
		// if yes, save the index
		if ( cmdparser.dwFlags & CP_DEFAULT )
			lDefaultIndex = dwIndex;

		// based on the argument, if it starts with option character
		if ( bOption )
		{
			// find the appropriate option entry in parser list
			if ( __CompareArgument( cmdparser.szOption, szOption, TRUE ) )
				return dwIndex;		// option matched
		}
		else
		{
			// else find the default option entry
			if ( cmdparser.dwFlags & CP_DEFAULT )
				return dwIndex;			// the current entry represents the default
		}
	}

	// here we know that option is not found
	return lDefaultIndex;
};

// ***************************************************************************
// Routine Description: 
//		  
// Arguments:	
//  
// Return Value: 
// 
// ***************************************************************************
VOID __SplitColon( LPCTSTR pszOption, LPTSTR* ppszOptionArg, LPTSTR* ppszValueArg )
{
	// local variables
	DWORD dwValueLength = 0;
    DWORD dwOptionLength = 0;
	LPCTSTR pszTemp = NULL;

	// search for ':' seperator
	pszTemp = _tcschr( pszOption, _T( ':' ) );
	if ( pszTemp == NULL )
		return;

	// determine the length of option and value arguments
	dwValueLength = lstrlen( pszTemp ) - 1;
	dwOptionLength = lstrlen( pszOption ) - dwValueLength - 1;

	// now allocate buffers for option and value arguments
	*ppszValueArg = __calloc( dwValueLength + 5, sizeof( TCHAR ) );
	*ppszOptionArg = __calloc( dwOptionLength + 5, sizeof( TCHAR ) );
	if ( *ppszValueArg == NULL || *ppszOptionArg == NULL )
	{
		__free( *ppszValueArg );
		__free( *ppszOptionArg );
		*ppszValueArg = NULL;
		*ppszOptionArg = NULL;
		return;
	}

	// copy the values into appropriate buffers
	lstrcpy( *ppszValueArg, pszTemp + 1 );
	lstrcpyn( *ppszOptionArg, pszOption, dwOptionLength + 1 );		// +1 for null character
}

//
// public functions ... exposed to external world
//

// ***************************************************************************
// Routine Description: 
//		The routine will parse the command line arguments for the options
//		  
// Arguments:	
//		[ in ] dwCount			:	an integer variable represents no. of arguments supplied 
//									through command line
//		[ in ] argv				:	an array of command line arguments
//		[ in ] dwOptionsCount	:	an integer represents the no.of elements in pcmdOptions
//									array
//		[ in ] pcmdOptions		:	an array of TCMDPARSER structures (i.e an array of options)
//  
// Return Value: 
//   returns TRUE if parsing done successfully, otherwise returns FALSE
// 
// ***************************************************************************
BOOL DoParseParam( DWORD dwCount, 
				   LPCTSTR argv[], 
				   DWORD dwOptionsCount,
				   PTCMDPARSER pcmdOptions )
{
	
	// local variables
	DWORD i = 0;
	LONG lTemp = 0;
	LONG lIndex = 0;
	BOOL bUsage = FALSE;
	BOOL bResult = FALSE;
	BOOL bDefault = TRUE;
	BOOL bProcessValue = FALSE;
	BOOL bOptionHasValue = FALSE;
	BOOL bValueWithColon = FALSE;
	LPCTSTR pszValue = NULL;
	LPCTSTR pszOption = NULL;
	LPTSTR pszValueArg = NULL;
	LPTSTR pszOptionArg = NULL;
	PTCMDPARSER pcmdparser = NULL;
	__STRING_512 szBuffer = NULL_STRING;
	__STRING_512 szUtilityName = NULL_STRING;

	BOOL bCheck = FALSE ; 	

	// check the input value
	if ( argv == NULL || pcmdOptions == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return FALSE;
	}

	// check for version compatibility
	if ( IsWin2KOrLater() == FALSE )
	{
		SetReason( ERROR_OS_INCOMPATIBLE );
		return FALSE;
	}

	//
	// prepare the utility name
	{
		pszOption = NULL;
		for( i = 0; i < dwOptionsCount; i++ )
		{
			pcmdparser = pcmdOptions + i;
			if ( pcmdparser->dwFlags & CP_MAIN_OPTION )
			{
				pszOption = pcmdparser->szOption;
				break;
			}
		}

		//
		// strip the utility name
		lIndex = 0;
		while ( (pszValue = FindOneOf( argv[ 0 ], _T( "\\:" ), lIndex )) != NULL )
		{
			// determine and save the position
			lIndex = lstrlen( argv[ 0 ] ) - lstrlen( pszValue ) + 1;
		}

		// ...
		lstrcpy( szUtilityName, _X( argv[ 0 ] + lIndex ) );

		// check whether .EXE is present in the name or not if yes detach it
		lIndex = lstrlen( szUtilityName ) - 4;			// total length - length of ".EXE"
		if ( lIndex <= 0 || StringCompare( szUtilityName + lIndex, _T( ".EXE" ), TRUE, 0 ) == 0 )
		{
			szUtilityName[ lIndex ] = '\0';
		}

		// if main option is available, add it
		if ( pszOption != NULL )
		{
			// add one space ( seperation )
			lstrcat( szUtilityName, _T( " /" ) );
			lstrcat( szUtilityName, pszOption );
		}

		// now add the help string ( /? )
		lstrcat( szUtilityName, _T( " /?" ) );

		// convert the string into upper case
		CharUpper( szUtilityName );
	}

	// Note: though the array starts at index 0 in C, the value at the array index 0
	// in a command line is the executable name ... so leave and parse the command line
	// from the second parameter i.e; array index 1
	SetReason( NULL_STRING );				// clear the existing error reason
	for( i = 1; i < dwCount; i++ )
	{
		// reset ...
		pszOptionArg = NULL;
		pszValueArg = NULL;
		bProcessValue = FALSE;					// assume no need to process the value
		bOptionHasValue = FALSE;				// assume that next arg is not a value
		bValueWithColon = FALSE;
		pszValue = NULL_STRING;					// clear the existing contents

		// check the length of the value ... it should not exceed
		// the value defined with MAX_STRING_LENGTH
		if ( lstrlen( argv[ i ] ) > MAX_STRING_LENGTH )
		{
			SetReason( ERROR_CMDPARSER_LENGTH_EXCEEDED );
			SetLastError( MK_E_SYNTAX );
			return FALSE;
		}

		// find the appropriate the option match
		pszOption = argv[ i ];
		lIndex = __MatchOption( dwOptionsCount, pcmdOptions, pszOption );

		// check whether the option was found or not
		if ( lIndex == -1 )
		{
			//
			// invalid option ... syntax error
			// but as a special case user might have specified the value
			// along with the option using ':' as delimiter
			__SplitColon( pszOption, &pszOptionArg, &pszValueArg );
			if ( pszOptionArg != NULL && pszValueArg != NULL )
				lIndex = __MatchOption( dwOptionsCount, pcmdOptions, pszOptionArg );

			// check whether option was found atleast now or not
			if ( lIndex == -1 )
			{
				// set the reason for the failure and return
				FORMAT_STRING2( szBuffer, ERROR_CMDPARSER_INVALID_OPTION, _X( pszOption ), szUtilityName );
				SetLastError( MK_E_SYNTAX );
				SetReason( szBuffer );
				return FALSE;
			}
			else
			{
				pszValue = pszValueArg;
				pszOption = pszOptionArg;
				bValueWithColon = TRUE;
				bProcessValue = TRUE;
				bOptionHasValue = TRUE;
			}
		}

		// now get the structure entry representing the current option
		// and check the address pValue
		pcmdparser = pcmdOptions + lIndex;
		if ( pcmdparser->pValue == NULL )
		{
			SetLastError( ERROR_NOACCESS );
			__free( pszOptionArg );
			__free( pszValueArg );
			SaveLastError();
			return FALSE;
		}

		// now determine whether user has specified default parameter or option
		bDefault = FALSE;
		if ( pcmdparser->dwFlags & CP_DEFAULT )
		{
			//
			// default option 
			// but there is twist ... still user might have given default argument
			// and again an option ... here there is a twist ... for example
			// for some utilities, server names can be given directly without any option
			// or else along with the option say -s. We need to handle this carefully
			bDefault = ! ( __IsOption( pszOption ) && 
				__CompareArgument( pcmdparser->szOption, pszOption, TRUE ) );
		}

		// do furthur checking on the current option
		// this is to determine whether this is a default option
		// option which doesn't take any value
		// note: checking depends on the type of the current argument
		if ( bDefault == FALSE && __IsOption( pszOption ) == TRUE )
		{
			// check whether next argument is available in array or not
			if ( i + 1 < dwCount && bOptionHasValue == FALSE )
			{
				// check whether the next argument length is greater than 255
						if ( lstrlen( argv[ i + 1 ] ) > MAX_STRING_LENGTH )
						{
							SetReason( ERROR_CMDPARSER_LENGTH_EXCEEDED );
							SetLastError( MK_E_SYNTAX );
							return FALSE;
						}
				// check whether next argument starts with option character or not

				if ( __IsOption( argv[ i + 1 ] ) == TRUE )
				{
					// if the option is expecting a numeric value, check if it is a
					// numeric value or not. if it is a numeric value
					if ( TYPEIS_NUMERIC( pcmdparser->dwFlags ) && IsNumeric( argv[ i+1 ], 10, TRUE ) )
					{
						// next argument is value ... possibly a -ve value
						bOptionHasValue = TRUE;		
					}
					else 
					{
						// check if this is an valid option or value
						lTemp = __MatchOption( dwOptionsCount, pcmdOptions, argv[ i + 1 ] );
						if ( lTemp == -1 && ( pcmdparser->dwFlags & CP_VALUE_MASK ) )
						{
							// this is not an option ... it should a value only
							bOptionHasValue = TRUE;
						}
					}
				}
				else if ( pcmdparser->dwFlags & CP_VALUE_MASK )
					bOptionHasValue = TRUE;		// next option can store this value
			}
			
			// now check whether the next argument is value or not for an option 
			// who should have value as mandatory
			if ( ( pcmdparser->dwFlags & CP_VALUE_MANDATORY ) && bOptionHasValue == FALSE )
			{
				//
				// error ... this option is expecting a value
				
				// set the reason for the failure and return
				__free( pszOptionArg );
				__free( pszValueArg );
				FORMAT_STRING2( szBuffer, ERROR_CMDPARSER_VALUE_EXPECTED, _X( pszOption ), szUtilityName );
				SetLastError( MK_E_SYNTAX );
				SetReason( szBuffer );
				return FALSE;
			}

			// now, if the next argument is a value for the option
			if ( bOptionHasValue )
			{
				// if value is not specified with colon, then next argument is the
				// value for this option
				if ( bValueWithColon == FALSE )
					pszValue = argv[ i + 1 ];

				// check the length of the value ... it should not exceed
				// the value defined with MAX_STRING_LENGTH
				if ( lstrlen( pszValue ) > MAX_STRING_LENGTH )
				{
					__free( pszOptionArg );
					__free( pszValueArg );
					SetReason( ERROR_CMDPARSER_LENGTH_EXCEEDED );
					SetLastError( MK_E_SYNTAX );
					return FALSE;
				}

				// indicate that value has to be validated
				bProcessValue = TRUE;
			}
		}
		else if ( bDefault == TRUE )
		{
			// check the length of the value in the argv ... it should not exceed
			// the value defined with MAX_STRING_LENGTH
			if ( lstrlen( pszOption ) >= MAX_STRING_LENGTH )
			{
				__free( pszOptionArg );
				__free( pszValueArg );
				SetReason( ERROR_CMDPARSER_LENGTH_EXCEEDED );
				SetLastError( MK_E_SYNTAX );
				return FALSE;
			}

			// this is a default option
			bProcessValue = TRUE;				// need to process the value
			pszValue = pszOption;				// current option itself is a value
		}

		// check whether we need to do the process the value or not
		if ( bProcessValue && ( ! ( pcmdparser->dwFlags & CP_IGNOREVALUE ) ) )
		{
			// check whether this value should be in the list of values
			if ( ( pcmdparser->dwFlags & CP_MODE_VALUES ) &&
					( ! InString( pszValue, pcmdparser->szValues, TRUE ) ) )
			{
				// current option value is not fitting the list of valid values

				// set the reason for the failure and return
				if ( bDefault == TRUE )
				{
					FORMAT_STRING2( szBuffer, ERROR_CMDPARSER_DEFAULT_NOTINLIST, _X( argv[ i ] ), szUtilityName );
				}
				else
				{
					FORMAT_STRING3( szBuffer, 
						ERROR_CMDPARSER_NOTINLIST, _X1( argv[ i + 1 ] ), _X2( argv[ i ] ), szUtilityName );
				}

				// ...
				
				if( bCheck == FALSE )
				{
					bCheck = TRUE ; 
					SetLastError( MK_E_SYNTAX );
					SetReason( szBuffer );
				}
			}

			// validate and set the value based on the 'type' option is expecting
			switch( pcmdparser->dwFlags & CP_TYPE_MASK )
			{
			case CP_TYPE_TEXT:
				{
					// check the mode of the input
					if ( pcmdparser->dwFlags & CP_MODE_ARRAY )
					{
						// if the mode is array, add to the array 
						// but before adding check whether duplicates 
						// has to be eliminated or not
						lIndex = -1;
						if ( pcmdparser->dwFlags & CP_VALUE_NODUPLICATES )
						{
							// check whether current value already exists in the list or not
							lIndex = DynArrayFindString( 
								*((PTARRAY) pcmdparser->pValue), pszValue, TRUE, 0 );
						}

						// now add the value to array only if the item doesn't exist in list
						if ( lIndex == -1 )
							DynArrayAppendString( *((PTARRAY) pcmdparser->pValue), pszValue, 0 );
					}
					else
					{
						// else just do copy
						lstrcpy( ( LPTSTR ) pcmdparser->pValue, pszValue );
					}
					
					// break from the switch ... case
					break;
				}

			case CP_TYPE_NUMERIC:
				{
					// check whether the value is numeric or not
					if ( IsNumeric( pszValue, 10, TRUE ) == FALSE )
					{
						//
						// error ... non numeric value
						
						// set the reason for the failure and return
						
						if( bCheck == FALSE )
						{
							bCheck = TRUE ; 
							FORMAT_STRING2( szBuffer, ERROR_CMDPARSER_INVALID_NUMERIC, _X( argv[ i ] ), szUtilityName );
							SetLastError( MK_E_SYNTAX );
							SetReason( szBuffer );
						}

						break; 
					}

					// check the mode of the input
					// if the mode is array, add to the array 
					if ( pcmdparser->dwFlags & CP_MODE_ARRAY )
					{
						DynArrayAppendLong( 
							*((PTARRAY) pcmdparser->pValue), AsLong( pszValue, 10 ) );
					}
					else	// else just do copy
					{
						*( ( LONG* ) pcmdparser->pValue ) = AsLong( pszValue, 10 );
					}

					// break from the switch ... case
					break;
				}

			case CP_TYPE_UNUMERIC:
				{
					// check whether the value is numeric or not
					if ( IsNumeric( pszValue, 10, FALSE ) == FALSE )
					{
						//
						// error ... non numeric value
						
						// set the reason for the failure and return
						
						if( bCheck == FALSE )
						{
							bCheck = TRUE ; 
							FORMAT_STRING2( szBuffer, ERROR_CMDPARSER_INVALID_NUMERIC, _X( argv[ i ] ), szUtilityName );
							SetLastError( MK_E_SYNTAX );
							SetReason( szBuffer );
						}
						break;
					}

					// check the mode of the input
					// if the mode is array, add to the array 
					if ( pcmdparser->dwFlags & CP_MODE_ARRAY )
					{
						DynArrayAppendDWORD( 
							*((PTARRAY) pcmdparser->pValue), (DWORD) AsLong( pszValue, 10 ) );
					}
					else	// else just do copy
					{
						*( ( DWORD* ) pcmdparser->pValue ) = (DWORD) AsLong( pszValue, 10 );
					}

					// break from the switch ... case
					break;
				}

			case CP_TYPE_FLOAT:
				{
					// check whether the value is floating point or not
					if ( IsFloatingPoint( pszValue ) == FALSE )
					{
						//
						// error ... non floating point value
						
						// set the reason for the failure and return
					
						if( bCheck == FALSE )
						{
							bCheck = TRUE ; 
							FORMAT_STRING2( szBuffer, ERROR_CMDPARSER_INVALID_FLOAT, _X( argv[ i ] ), szUtilityName );
							SetLastError( MK_E_SYNTAX );
							SetReason( szBuffer );
						}
						break;
					}

					// check the mode of the input
					// if the mode is array, add to the array 
					if ( pcmdparser->dwFlags & CP_MODE_ARRAY )
					{
						DynArrayAppendFloat( 
							*((PTARRAY) pcmdparser->pValue), (float) AsFloat( pszValue ) );
					}
					else	// else just do copy
					{
						*( ( float* ) pcmdparser->pValue ) = (float) AsFloat( pszValue );
					}

					// break from the switch ... case
					break;
				}

			case CP_TYPE_DOUBLE:
				{
					// check whether the value is floating point or not
					if ( IsFloatingPoint( pszValue ) == FALSE )
					{
						//
						// error ... non floating point value
						
						// set the reason for the failure and return
					
						if( bCheck == FALSE )
						{
							bCheck = TRUE ; 
							FORMAT_STRING2( szBuffer, ERROR_CMDPARSER_INVALID_FLOAT, _X( argv[ i ] ), szUtilityName );
							SetLastError( MK_E_SYNTAX );
							SetReason( szBuffer );
						}
						break;
					}

					// check the mode of the input
					// if the mode is array, add to the array 
					if ( pcmdparser->dwFlags & CP_MODE_ARRAY )
					{
						DynArrayAppendDouble( *((PTARRAY) pcmdparser->pValue), AsFloat( pszValue ) );
					}
					else	// else just do copy
					{
						*( ( double* ) pcmdparser->pValue ) = AsFloat( pszValue );
					}

					// break from the switch ... case
					break;
				}

			case CP_TYPE_CUSTOM:
				{
					// check whether function pointer is specified or not
					// if not specified, error
					if ( pcmdparser->pFunction == NULL )
					{
						//
						// function ptr not specified ... error
						
						// set the reason for the failure and return
					
						if( bCheck == FALSE )
						{
							bCheck = TRUE ; 
							SetLastError( STG_E_INVALIDPARAMETER );
							SaveLastError();
						}
						break; 
					}

					// call the custom function
					// and result itself is return value of this function
					bResult = ( *pcmdparser->pFunction)( argv[ i ], pszValue,
						pcmdparser->pFunctionData == NULL ? pcmdparser : pcmdparser->pFunctionData );

					// check the result
					
					if ( ( bResult == FALSE ) && (bCheck == FALSE )  )
					{
						bCheck = TRUE ;
						break ; 
					}

					// break from the switch ... case
					break;
				}

			case CP_TYPE_DATE:
			case CP_TYPE_TIME:
			case CP_TYPE_DATETIME:
				{
					// break from the switch ... case
					break;
				}

			default:
				{
					// default is assumed to boolean type
					*( ( BOOL* ) pcmdparser->pValue ) = TRUE;

					// break from the switch ... case
					break;
				}
			}
		}
		else
		{
			// default is assumed to boolean type
			// NOTE: only in case the option is not accepting optional value
			if ( (pcmdparser->dwFlags & CP_VALUE_MASK) != CP_VALUE_OPTIONAL )
				*( ( BOOL* ) pcmdparser->pValue ) = TRUE;
		}

		// check whether next argument is treated as value or not
		// if next argument is treated as value and finished, processing, 
		// increment the argument index variable so that it will process the next option
		if ( bOptionHasValue && bValueWithColon == FALSE )
			i++;

		// increment the option repetition count at the command prompt
		pcmdparser->dwActuals++;

		// find out if the current option refers help item
		if ( pcmdparser->dwFlags & CP_USAGE )
			bUsage = TRUE;		// usage is specified

		// now check whether option repeated excess no. of times or not
		if ( pcmdparser->dwCount != 0 && pcmdparser->dwActuals > pcmdparser->dwCount )
		{
			//
			// syntax error ... option repeatition count exceeded
			// set the reason for the failure and return

			if ( bDefault == TRUE )
			{
				// its an default argument
				FORMAT_STRING2( szBuffer, 
					ERROR_CMDPARSER_DEFAULT_OPTION_REPEATED, pcmdparser->dwCount, szUtilityName );
			}
			else
			{
				// its an option
				FORMAT_STRING3( szBuffer, 
					ERROR_CMDPARSER_OPTION_REPEATED, _X( pszOption ), pcmdparser->dwCount, szUtilityName );
			}

			// ...
			SetReason( NULL_STRING );
			__free( pszOptionArg );
			__free( pszValueArg );
			SetLastError( MK_E_SYNTAX );
			SetReason( szBuffer );
			return FALSE;
		}

		// release memory
		__free( pszValueArg );
		__free( pszOptionArg );
	}

	// atlast check whether the mandatory options has come or not
	// NOTE: checking of mandatory options will be done only if help is requested
	for( i = 0; bUsage == FALSE && i < dwOptionsCount; i++ )
	{
		// check whether the option has come or not if it is mandatory
		pcmdparser = pcmdOptions + i;
		if ( ( pcmdparser->dwFlags & CP_MANDATORY ) && pcmdparser->dwActuals == 0 )
		{
			//
			// mandatory option not exist ... fail
			
			// set the reason for the failure and return
			if ( lstrlen( pcmdparser->szOption ) != 0 )
			{
				FORMAT_STRING2( szBuffer, 
					ERROR_CMDPARSER_MANDATORY_OPTION_MISSING, pcmdparser->szOption, szUtilityName );
			}
			else
			{
				FORMAT_STRING( szBuffer, ERROR_CMDPARSER_DEFAULT_OPTION_MISSING, szUtilityName );
			}
			
			SetReason( NULL_STRING ); 
			SetLastError( MK_E_SYNTAX );
			SetReason( szBuffer );
			return FALSE;
		}
	}

	// command line parsing went well ... return success
	
	if( bCheck == TRUE )
	{
		return FALSE ;
	}
	else
	{
		return TRUE;
	}
}

// ***************************************************************************
// Routine Description: Counts the no. of times the option is repeated at cmd prompt
//		  
// Arguments:
//			[in] szOption	:	a pointer to string which is an option for which the search
//								is to be made in options array
//			[in] dwCount	:	no. of entries in the cmdOptions array
//			[in] pcmdOptions:	an array of TCMDPARSER structure (i.e an array of options)
//  
// Return Value:
//	the count of no. of time the option is repeated at command prompt
// 
// ***************************************************************************
DWORD GetOptionCount( LPCTSTR szOption, DWORD dwCount, PTCMDPARSER pcmdOptions )
{
	// local variables
	DWORD dw;
	PTCMDPARSER pcp;

	// check the input value
	if ( szOption == NULL || pcmdOptions == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return -1;
	}

	// traverse thru the loop and find out how many times, the option has repeated at cmd prompt
	for( dw = 0; dw < dwCount; dw++ )
	{
		// get the option information and check whether we are looking for this option or not
		// if the option is matched, return the no. of times the option is repeated at the command prompt
		pcp = pcmdOptions + dw;
		if ( StringCompare( pcp->szOption, szOption, TRUE, 0 ) == 0 )
			return pcp->dwActuals;
	}

	// this will / shouldn't occur
	return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\lib\dynarray.c ===
/***************************************************************************************
Copyright (c) Microsoft Corporation

Module Name: 

   DynArray.C

Abstract: 
   This module deals with the various functionalities such as creation of DynamicArrays, deletion of Dynamic Arrays,insertion
		   of elements into Dynamic Arrays	and various other related functionalities. 

Author:

G.V.N Murali Sunil. 1-9-2000

Revision History :
***************************************************************************************/ 


#include "pch.h"
#include "cmdline.h"

//
// constants / compiler defines / enumerations
//

// signatures
#define _SIGNATURE_ARRAY		9
#define _SIGNATURE_ITEM		99

// hidden item types
#define _TYPE_NEEDINIT		DA_TYPE_NONE

//
// private structures ... structures declared in this area are not exposed to 
// the external world ... hidden structures
//

// represents array item
typedef struct __tagItem
{
	DWORD dwSignature;			// signature ... used for validation
	DWORD dwType;				// says the type of the current item
	DWORD dwSize;				// size of the memory allocated
	LPVOID pValue;				// value of the item ( address )
	struct __tagItem* pNext;	// pointer to the next item
} __TITEM;

typedef __TITEM* __PTITEM;				// pointer typedefintion

// represents the array
typedef struct __tagArray
{
	DWORD dwSignature;		// signature ... for validating pointer
	DWORD dwCount;			// count of items in the array
	__PTITEM pStart;		// pointer to the first item
	__PTITEM pLast;			// pointer to the last item
} __TARRAY;

typedef __TARRAY* __PTARRAY;				// pointer typedefintion

// 
// private function(s) ... used only in this file
//

// ***************************************************************************
// Routine Description: 
//		To append any type of item into the Dynamic Array 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array containing the result 
//		[ in ] dwIndex			- Index of the  item
//		[ in ] ppPreviousItem	- pointer to the previous item.
//
// Return Value:  
//
//		Pointer to the structure containing the Item
// 
// ***************************************************************************

__PTITEM __DynArrayGetItem( TARRAY pArray, DWORD dwIndex, __PTITEM* ppPreviousItem )
{
	// local variables
	DWORD i;
	__PTITEM pItem = NULL;
	__PTITEM pPrevItem = NULL;
	__PTARRAY pArrayEx = NULL;

	// check whether the array is valid or not
	if ( IsValidArray( pArray ) == FALSE ) 
		return NULL;
	
	// convert the passed memory location info into appropriate structure
	pArrayEx = ( __PTARRAY ) pArray;

	// check the size of the array with the position of the item required
	// if the size is less, return NULL
	if ( pArrayEx->dwCount <= dwIndex ) 
		return NULL;
	
	// traverse thru the list and find the appropriate item
	pPrevItem = NULL;
	pItem = pArrayEx->pStart;
	for( i = 1; i <= dwIndex; i++ )
	{
		// store the current pointer and fetch the next pointer
		pPrevItem = pItem;
		pItem = pItem->pNext;
	}

	// if the previous pointer is also requested, update the previous pointer
	if ( ppPreviousItem != NULL ) *ppPreviousItem = pPrevItem;

	// now return the __TITEM pointer
	return pItem;
}

// ***************************************************************************
// Routine Description: 
//		To append any type of item into the Dynamic Array 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array containing the result 
//		[ in ] dwType			- type of the  item
//		[ in ] dwSize			- Size of the item
//		[ in ] pValue			- pointer to the Item.
//
// Return Value:  
//
//		If successfully added the item to the list then return index else -1
// 
// ***************************************************************************
LONG __DynArrayAppend( TARRAY pArray, DWORD dwType, DWORD dwSize, LPVOID pValue )
{
	// local variables
	__PTITEM pItem = NULL;
	__PTARRAY pArrayEx = NULL;

	// check whether the array is valid or not
	if ( IsValidArray( pArray ) == FALSE ) 
		return -1;
	
	// create an item and check the result. if memory allocation failed, error
	pItem = ( __PTITEM ) __calloc( 1, sizeof( __TITEM ) );
	if ( pItem == NULL ) 
		return -1;

	// initialize the newly allocated item structure with appropriate data
	pItem->pNext = NULL;
	pItem->dwType = dwType;
	pItem->dwSize = dwSize;
	pItem->pValue = pValue;
	pItem->dwSignature = _SIGNATURE_ITEM;

	// convert the passed memory location info into appropriate structure
	pArrayEx = ( __PTARRAY ) pArray;
	pArrayEx->dwCount++;	// update the count of items in array info

	// now add the newly created item to the array at the end of the list
	if ( pArrayEx->pStart == NULL ) 
	{
		// first item in the array
		pArrayEx->pStart = pArrayEx->pLast = pItem;
	}
	else
	{
		// appending to the existing list
		pArrayEx->pLast->pNext = pItem;
		pArrayEx->pLast = pItem;
	}

	// successfully added the item to the list ... return index
	return ( pArrayEx->dwCount - 1 );		// count - 1 = index
}

// ***************************************************************************
// Routine Description: 
//		To insert  an item into the Dynamic Array 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array containing the result 
//		[ in ] dwIndex			- index of the  item
//		[ in ] dwType			- type of the item
//		[ in ] dwSize			- Size to the Item.
//		[ in ] pValue			- pointer to the item.
// Return Value:  
//
//		If successfully added the item to the list then return index else -1
// 
// ***************************************************************************

LONG __DynArrayInsert( TARRAY pArray, DWORD dwIndex, DWORD dwType, DWORD dwSize, LPVOID pValue )
{
	// local variables
	DWORD i;
	__PTITEM pItem = NULL;
	__PTITEM pBeforeInsert = NULL;
	__PTARRAY pArrayEx = NULL;

	// check whether the array is valid or not
	if ( ! IsValidArray( pArray ) ) 
		return -1;
	
	// convert the passed memory location info into appropriate structure
	pArrayEx = ( __PTARRAY ) pArray;

	// check the size of the array with the position of the insertion that has to be done
	// if the size is less, treat this call as just a call to Append function 
	if ( pArrayEx->dwCount <= dwIndex ) 
		return __DynArrayAppend( pArray, dwType, dwSize, pValue );
	
	// create an item and check the result. if memory allocation failed, error
	pItem = ( __PTITEM ) __calloc( 1, sizeof( __TITEM ) );
	if ( pItem == NULL ) 
		return -1;

	// initialize the newly allocated item structure with appropriate data
	pItem->pNext = NULL;
	pItem->dwType = dwType;
	pItem->dwSize = dwSize;
	pItem->pValue = pValue;
	pItem->dwSignature = _SIGNATURE_ITEM;

	// update the count of the array items
	pArrayEx->dwCount++;

	// check whether the new item has to be added at the begining of the list
	if ( dwIndex == 0 )
	{
		// put the new item at the begining of the list
		pItem->pNext = pArrayEx->pStart;
		pArrayEx->pStart = pItem;

		// return as the operation is completed
		return TRUE;
	}

	// traverse thru the list and find the location where the insertion of 
	// new element has to be done
	pBeforeInsert = pArrayEx->pStart;
	for( i = 0; i < dwIndex - 1; i++ )
		pBeforeInsert = pBeforeInsert->pNext;

	// insert the new item at the new location and update the chain
	pItem->pNext = pBeforeInsert->pNext;
	pBeforeInsert->pNext = pItem;

	// return as the operation is completed	... return index position
	return dwIndex;			// passed index itself is return value
}


// ***************************************************************************
// Routine Description: 
//		Frees the items present in a Dynamic array 
//		  
// Arguments: 
//		[ in ] pItem			- pointer to the item to be freed
//
// Return Value:  
//		none
// 
// ***************************************************************************
VOID __DynArrayFreeItemValue( __PTITEM pItem )
{
	// validate the pointer
	if ( pItem == NULL )
		return;

	// now free the items value based on its type
	switch( pItem->dwType )
	{
	case DA_TYPE_STRING:
	case DA_TYPE_LONG:
	case DA_TYPE_DWORD:
	case DA_TYPE_BOOL:
	case DA_TYPE_FLOAT:
	case DA_TYPE_DOUBLE:
	case DA_TYPE_HANDLE:
	case DA_TYPE_SYSTEMTIME:
	case DA_TYPE_FILETIME:
		__free( pItem->pValue );			// free the value
		pItem->pValue = NULL;				// reset to null value
		break;

	case DA_TYPE_GENERAL:
		break;				// user program itself should de-allocate memory for this item

	case _TYPE_NEEDINIT:
		break;				// memory is not yet allocated for value of this item

	case DA_TYPE_ARRAY:
		// destroy the dynamic array
		DestroyDynamicArray( &pItem->pValue );
		pItem->pValue = NULL;
		break;

	default:
		break;
	}

	// return
	return;
}


// ***************************************************************************
// Routine Description: 
//		To find  an item in the Dynamic Array 
//		  
// Arguments: 
//		[ in ] pArray				- Dynamic Array containing the result 
//		[ in ] dwType				- type of the item
//		[ in ] pValue				- Size to the Item.
//		[ in ] bIgnoreCase			- boolean indicating if the search is case-insensitive
//		[ in ] dwCount				- 
// Return Value:  
//
//		If successfully found the item in the DynamicArray then return index 
//		-1 in case of error.
// 
// ***************************************************************************
LONG __DynArrayFind( TARRAY pArray,
					 DWORD dwType, LPVOID pValue, 
					 BOOL bIgnoreCase, DWORD dwCount )
{
	// local variables
	DWORD dw = 0;
	__PTITEM pItem = NULL;
	__PTARRAY pArrayEx = NULL;

	// temp variables
	FILETIME* pFTime1 = NULL;
	FILETIME* pFTime2 = NULL;
	SYSTEMTIME* pSTime1 = NULL;
	SYSTEMTIME* pSTime2 = NULL;

	// validate the array
	if ( ! IsValidArray( pArray ) ) 
		return -1;				// array is not valid

	// get the reference to the actual array
	pArrayEx = ( __PTARRAY ) pArray;

	// now traverse thru the array and search for the requested value
	pItem = pArrayEx->pStart;
	for ( dw = 0; dw < pArrayEx->dwCount; pItem = pItem->pNext, dw++ )
	{
		// before checking the value, check the data type of the item
		if ( pItem->dwType != dwType )
			continue;			// item is not of needed type, skip this item

		// now check the value of the item with the needed value
		switch ( dwType )
		{
		case DA_TYPE_LONG:
			{
				// value of type LONG
				if ( *( ( LONG* ) pItem->pValue ) == *( ( LONG* ) pValue ) )
					return dw;			// value matched

				// break the case
				break;
			}

		case DA_TYPE_DWORD:
			{
				// value of type DWORD
				if ( *( ( DWORD* ) pItem->pValue ) == *( ( DWORD* ) pValue ) )
					return dw;			// value matched

				// break the case
				break;
			}

		case DA_TYPE_FLOAT:
			{
				// value of type float
				if ( *( ( float* ) pItem->pValue ) == *( ( float* ) pValue ) )
					return dw;			// value matched

				// break the case
				break;
			}

		case DA_TYPE_DOUBLE:
			{
				// value of type double
				if ( *( ( double* ) pItem->pValue ) == *( ( double* ) pValue ) )
					return dw;			// value matched

				// break the case
				break;
			}

		case DA_TYPE_HANDLE:
			{
				// value of type HANDLE
				if ( *( ( HANDLE* ) pItem->pValue ) == *( ( HANDLE* ) pValue ) )
					return dw;			// value matched

				// break the case
				break;
			}

		case DA_TYPE_STRING:
			{
				// value of type string
				if ( StringCompare( (LPCTSTR) pItem->pValue, 
											(LPCTSTR) pValue, bIgnoreCase, dwCount ) == 0 )
					return dw;	// value matched

				// break the case
				break;
			}

		case DA_TYPE_FILETIME:
			{
				// get the values ( for readability sake )
				pFTime1 = ( FILETIME* ) pValue;
				pFTime2 = ( FILETIME* ) pItem->pValue;
				if ( pFTime1->dwHighDateTime == pFTime2->dwHighDateTime &&
					 pFTime1->dwLowDateTime == pFTime2->dwLowDateTime )
					return dw;	// value matched

				// break the case
				break;
			}

		case DA_TYPE_SYSTEMTIME:
			{
				// get the values ( for readability sake )
				pSTime1 = ( SYSTEMTIME* ) pValue;
				pSTime2 = ( SYSTEMTIME* ) pItem->pValue;
				if ( pSTime1->wDay == pSTime2->wDay &&
					 pSTime1->wDayOfWeek == pSTime1->wDayOfWeek &&
					 pSTime1->wHour == pSTime1->wHour &&
					 pSTime1->wMilliseconds == pSTime2->wMilliseconds &&
					 pSTime1->wMinute == pSTime2->wMinute &&
					 pSTime1->wMonth == pSTime2->wMonth &&
					 pSTime1->wSecond == pSTime2->wSecond &&
					 pSTime1->wYear == pSTime2->wYear )
					return dw;	// value matched

				// break the case
				break;
			}

		default:
			{
				// just break ... nothin special to do
				break;
			}
		}
	}

	// value not found
	return -1;
}

// ***************************************************************************
// Routine Description: 
//		To find  an item in the a 2 dimensional Dynamic Array . 
//		this function is private to this module only.  
// Arguments: 
//		[ in ] pArray				- Dynamic Array containing the result 
//		[ in ] dwColumn				- The number of columns
//		[ in ] dwType				- type of the item
//		[ in ] pValue				- Size to the Item.
//		[ in ] bIgnoreCase			- boolean indicating if the search is case-insensitive
//		[ in ] dwCount				- used in case of string type comparisions. The number of 
//									  characters that have to be compared in a  particular column.
// Return Value:  
//
//		If successfully found the item in the DynamicArray then return index 
//		-1 in case of error.
// 
// ***************************************************************************
LONG __DynArrayFindEx( TARRAY pArray, DWORD dwColumn,
					   DWORD dwType, LPVOID pValue, 
					   BOOL bIgnoreCase, DWORD dwCount )
{
	// local variables
	DWORD dw = 0;
	__PTITEM pItem = NULL;
	__PTITEM pColumn = NULL;
	__PTARRAY pArrayEx = NULL;

	// temp variables
	FILETIME* pFTime1 = NULL;
	FILETIME* pFTime2 = NULL;
	SYSTEMTIME* pSTime1 = NULL;
	SYSTEMTIME* pSTime2 = NULL;

	// validate the array
	if ( ! IsValidArray( pArray ) ) 
		return -1;				// array is not valid

	// get the reference to the actual array
	pArrayEx = ( __PTARRAY ) pArray;

	// now traverse thru the array and search for the requested value
	pItem = pArrayEx->pStart;
	for ( dw = 0; dw < pArrayEx->dwCount; pItem = pItem->pNext, dw++ )
	{
		// check whether the current value is of ARRAY type or not
		if ( pItem->dwType != DA_TYPE_ARRAY )
			continue;			// item is not of ARRAY type, skip this item

		// now get the item at the required column
		pColumn = __DynArrayGetItem( pItem->pValue, dwColumn, NULL );
		if ( pColumn == NULL )
			continue;			// column not found ... skip this item

		// get the type of the column value
		if ( pColumn->dwType != dwType )
			continue;			// column is not of needed type, skip this item also

		// now check the value of the column with the needed value
		switch ( dwType )
		{
		case DA_TYPE_LONG:
			{
				// value of type LONG
				if ( *( ( LONG* ) pColumn->pValue ) == *( ( LONG* ) pValue ) )
					return dw;			// value matched

				// break the case
				break;
			}

		case DA_TYPE_DWORD:
			{
				// value of type DWORD
				if ( *( ( DWORD* ) pColumn->pValue ) == *( ( DWORD* ) pValue ) )
					return dw;			// value matched

				// break the case
				break;
			}

		case DA_TYPE_FLOAT:
			{
				// value of type float
				if ( *( ( float* ) pColumn->pValue ) == *( ( float* ) pValue ) )
					return dw;			// value matched

				// break the case
				break;
			}

		case DA_TYPE_DOUBLE:
			{
				// value of type double
				if ( *( ( double* ) pColumn->pValue ) == *( ( double* ) pValue ) )
					return dw;			// value matched

				// break the case
				break;
			}

		case DA_TYPE_HANDLE:
			{
				// value of type HANDLE
				if ( *( ( HANDLE* ) pColumn->pValue ) == *( ( HANDLE* ) pValue ) )
					return dw;			// value matched

				// break the case
				break;
			}

		case DA_TYPE_STRING:
			{
				// value of type string
				if ( StringCompare( (LPCTSTR) pColumn->pValue, 
											(LPCTSTR) pValue, bIgnoreCase, dwCount ) == 0 )
					return dw;	// value matched

				// break the case
				break;
			}

		case DA_TYPE_FILETIME:
			{
				// get the values ( for readability sake )
				pFTime1 = ( FILETIME* ) pValue;
				pFTime2 = ( FILETIME* ) pItem->pValue;
				if ( pFTime1->dwHighDateTime == pFTime2->dwHighDateTime &&
					 pFTime1->dwLowDateTime == pFTime2->dwLowDateTime )
					return dw;	// value matched

				// break the case
				break;
			}

		case DA_TYPE_SYSTEMTIME:
			{
				// get the values ( for readability sake )
				pSTime1 = ( SYSTEMTIME* ) pValue;
				pSTime2 = ( SYSTEMTIME* ) pItem->pValue;
				if ( pSTime1->wDay == pSTime2->wDay &&
					 pSTime1->wDayOfWeek == pSTime1->wDayOfWeek &&
					 pSTime1->wHour == pSTime1->wHour &&
					 pSTime1->wMilliseconds == pSTime2->wMilliseconds &&
					 pSTime1->wMinute == pSTime2->wMinute &&
					 pSTime1->wMonth == pSTime2->wMonth &&
					 pSTime1->wSecond == pSTime2->wSecond &&
					 pSTime1->wYear == pSTime2->wYear )
					return dw;	// value matched

				// break the case
				break;
			}

		default:
			{
				// just break ... nothing special to do
				break;
			}
		}
	}

	// value not found
	return -1;
}

//
// implementation of public functions
// 

// ***************************************************************************
// Routine Description: 
//		 // validate the array
//		
// Arguments: 
//		[ in ] pArray				- Dynamic Array  

// Return Value:  
//
//		TRUE - if it is a valid array else FALSE
//		
//		
// 
// ***************************************************************************
BOOL IsValidArray( TARRAY pArray )
{
	// check the signature 
	return ( pArray != NULL && ( ( __PTARRAY ) pArray )->dwSignature == _SIGNATURE_ARRAY );
}

// ***************************************************************************
// Routine Description:
//		  This function creates a dynamic array.
// Arguments:
//		  None.
// Return Value:
//		  pointer to the newly created array 	
// 
// ***************************************************************************
TARRAY CreateDynamicArray()
{
	// local variables
	__PTARRAY pArray;

	// memory allocation ... array is being created
	pArray = ( __PTARRAY ) __calloc( 1, sizeof( __TARRAY ) );

	// check the allocation result
	if ( pArray == NULL )
		return NULL;

	// initialize the structure variables
	pArray->dwCount = 0;
	pArray->pStart = NULL;
	pArray->pLast = NULL;
	pArray->dwSignature = _SIGNATURE_ARRAY;

	// return array reference
	return pArray;
}

// ***************************************************************************
// Routine Description:
//		   traverse thru the Dynamic Array and delete elements one by one
// Arguments:
//		  [in]  pArray  - pointer to an array
// Return Value:
//		  None.
// 
// ***************************************************************************

VOID DynArrayRemoveAll( TARRAY pArray )
{
	// local variables
	__PTITEM pItem = NULL;
	__PTITEM pNextItem = NULL;
	__PTARRAY pArrayEx = NULL;

	// check whether the array is valid or not
	if ( ! IsValidArray( pArray ) ) 
		return;
	
	// convert the passed memory location info into appropriate structure
	pArrayEx = ( __PTARRAY ) pArray;

	// traverse thru the list and delete elements one by one
	pItem = pArrayEx->pStart;
	while ( pItem != NULL )
	{
		pNextItem = pItem->pNext;				// get the next item in the list
		__DynArrayFreeItemValue( pItem );		// free memory allocated for data
		__free( pItem );	// now free the memory allocated for the current item
		pItem = pNextItem;	// make the previously fetched next item as the current item
	}

	// as all the items are removed, reset the contents
	pArrayEx->dwCount = 0;
	pArrayEx->pStart = NULL;
	pArrayEx->pLast = NULL;

	// return
	return;
}

// ***************************************************************************
// Routine Description:
//		Destory the Dynamic array and free the memory		  
// Arguments:
//		[in] pArray  - Pointer to the Dynamic array.
// Return Value:
//		none.
// ***************************************************************************
VOID DestroyDynamicArray( PTARRAY pArray )
{
	// check whether the array is valid or not
	if ( ! IsValidArray( *pArray ) ) 
		return;
	
	// remove all the elements in the array
	DynArrayRemoveAll( *pArray );

	// now free the memory allocated 
	__free( *pArray );
	*pArray = NULL;			// set the pointer to null value
}

// ***************************************************************************
// Routine Description: 
//		To append any type of item into the Dynamic Array 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array containing the result 
//		[ in ] pValue			- pointer to the Item.
//
// Return Value:  
//
//		If successfully added the item to the list then return index else -1
// 
// ***************************************************************************
LONG DynArrayAppend( TARRAY pArray, LPVOID pValue )
{
	// validate the pointer value
	if ( pValue == NULL )
		return -1;			// invalid memory address passed

	// append the value and return the result
	return __DynArrayAppend( pArray, DA_TYPE_GENERAL, sizeof( LPVOID ), pValue );
}

// ***************************************************************************
// Routine Description: 
//		To append a string into the Dynamic Array 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array containing the result 
//		[ in ] szValue			- pointer to the string
//		[ in ] dwLength			- Length of the String to be passed.
// Return Value:  
//
//		If successfully added the item to the list then return index else -1
// 
// ***************************************************************************
LONG DynArrayAppendString( TARRAY pArray, LPCTSTR szValue, DWORD dwLength )
{
	// local variables
	LONG lIndex = -1;
	LPTSTR pszValue = NULL;
	__PTARRAY pArrayEx = NULL;

	// check whether the array is valid or not
	if ( ! IsValidArray( pArray ) ) 
		return -1;

	// convert the passed memory location info into appropriate structure
	pArrayEx = ( __PTARRAY ) pArray;

	// determine the length of string ( memory ) that has to be allocated
	if ( dwLength == 0 )
		dwLength = lstrlen( szValue );

	// accomodate space for storing NULL character
	dwLength += 1;

	// allocate memory for value and check the result of memory allocation
	pszValue = ( LPTSTR ) __calloc( dwLength, sizeof( TCHAR ) );
	if ( pszValue == NULL ) 
		return -1;

	// copy the contents of the string ( copy should be based on the length )
	lstrcpyn( pszValue, szValue, dwLength );

	// now add this item to the array
	lIndex = __DynArrayAppend( pArray, DA_TYPE_STRING, dwLength * sizeof( TCHAR ), pszValue );
	if ( lIndex == -1 )
	{
		// failed in adding this item to the array
		// so, free the memory allocated and return from the function
		__free( pszValue );
		return -1;
	}

	// added the item to the array
	return lIndex;
}


// ***************************************************************************
// Routine Description: 
//		To append a variable of type Long  into the Dynamic Array 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array containing the result 
//		[ in ] lValue			- Variable to be appended.
//		
// Return Value:  
//
//		If successfully added the item to the list then return index else -1
// 
// ***************************************************************************
LONG DynArrayAppendLong( TARRAY pArray, LONG lValue )
{
	// local variables
	LONG lIndex = -1;
	PLONG plValue = NULL;

	// check whether the array is valid or not
	if ( ! IsValidArray( pArray ) ) 
		return -1;

	// allocate memory for value and check the result of memory allocation
	plValue = ( LONG* ) __calloc( 1, sizeof( LONG ) );
	if ( plValue == NULL ) 
		return -1;

	// set the value
	*plValue = lValue;

	// now add this item value to the array
	lIndex = __DynArrayAppend( pArray, DA_TYPE_LONG, sizeof( LONG ), plValue );
	if ( lIndex == -1 )
	{
		// failed in adding this item to the array
		// so, free the memory allocated and return from the function
		__free( plValue );
		return -1;
	}

	// added the item to the array
	return lIndex;
}

// ***************************************************************************
// Routine Description: 
//		To append a variable of type DWORD  into the Dynamic Array 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array containing the result 
//		[ in ] dwValue			- DWORD type Variable to be appended.
//		
// Return Value:  
//
//		If successfully added the item to the list then return index else -1
// 
// ***************************************************************************
LONG DynArrayAppendDWORD( TARRAY pArray, DWORD dwValue )
{
	// local variables
	LONG lIndex = -1;
	PDWORD pdwValue = NULL;

	// check whether the array is valid or not
	if ( ! IsValidArray( pArray ) ) 
		return -1;

	// allocate memory for value and check the result of memory allocation
	pdwValue = ( DWORD* ) __calloc( 1, sizeof( DWORD ) );
	if ( pdwValue == NULL ) 
		return -1;

	// set the value
	*pdwValue = dwValue;

	// now add this item value to the array
	lIndex = __DynArrayAppend( pArray, DA_TYPE_DWORD, sizeof( DWORD ), pdwValue );
	if ( lIndex == -1  )
	{
		// failed in adding this item to the array
		// so, free the memory allocated and return from the function
		__free( pdwValue );
		return -1;
	}

	// added the item to the array
	return lIndex;
}

// ***************************************************************************
// Routine Description: 
//		To append a variable of type BOOL  into the Dynamic Array 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array containing the result 
//		[ in ] bValue			- BOOL type Variable to be appended.
//		
// Return Value:  
//
//		If successfully added the item to the list then return index else -1
// 
// ***************************************************************************
LONG DynArrayAppendBOOL( TARRAY pArray, BOOL bValue )
{
	// local variables
	LONG lIndex = -1;
	PBOOL pbValue = NULL;

	// check whether the array is valid or not
	if ( ! IsValidArray( pArray ) ) 
		return -1;

	// allocate memory for value and check the result of memory allocation
	pbValue = ( PBOOL ) __calloc( 1, sizeof( BOOL ) );
	if ( pbValue == NULL ) 
		return -1;

	// set the value
	*pbValue = bValue;

	// now add this item value to the array
	lIndex = __DynArrayAppend( pArray, DA_TYPE_BOOL, sizeof( BOOL ), pbValue );
	if ( lIndex == -1 )
	{
		// failed in adding this item to the array
		// so, free the memory allocated and return from the function
		__free( pbValue );
		return -1;
	}

	// added the item to the array
	return lIndex;
}

// ***************************************************************************
// Routine Description: 
//		To append a variable of type Float  into the Dynamic Array 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array containing the result 
//		[ in ] fValue			- Float type Variable to be appended.
//		
// Return Value:  
//
//		If successfully added the item to the list then return index else -1
// 
// ***************************************************************************

LONG DynArrayAppendFloat( TARRAY pArray, float fValue )
{
	// local variables
	LONG lIndex = -1;
	float* pfValue = NULL;

	// check whether the array is valid or not
	if ( ! IsValidArray( pArray ) ) 
		return -1;

	// allocate memory for value and check the result of memory allocation
	pfValue = ( float* ) __calloc( 1, sizeof( float ) );
	if ( pfValue == NULL ) 
		return -1;

	// set the value
	*pfValue = fValue;

	// now add this item value to the array
	lIndex = __DynArrayAppend( pArray, DA_TYPE_FLOAT, sizeof( float ), pfValue );
	if ( lIndex == -1  )
	{
		// failed in adding this item to the array
		// so, free the memory allocated and return from the function
		__free( pfValue );
		return -1;
	}

	// added the item to the array
	return lIndex;
}

// ***************************************************************************
// Routine Description: 
//		To append a variable of type Double  into the Dynamic Array 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array containing the result 
//		[ in ] dblValue			- Double type Variable to be appended.
//		
// Return Value:  
//
//		If successfully added the item to the list then return index else -1
// 
// ***************************************************************************
LONG DynArrayAppendDouble( TARRAY pArray, double dblValue )
{
	// local variables
	LONG lIndex = -1;
	double* pdblValue = NULL;

	// check whether the array is valid or not
	if ( ! IsValidArray( pArray ) ) 
		return -1;

	// allocate memory for value and check the result of memory allocation
	pdblValue = ( double* ) __calloc( 1, sizeof( double ) );
	if ( pdblValue == NULL ) 
		return -1;

	// set the value
	*pdblValue = dblValue;

	// now add this item value to the array
	lIndex = __DynArrayAppend( pArray, DA_TYPE_DOUBLE, sizeof( double ), pdblValue );
	if ( lIndex == -1 )
	{
		// failed in adding this item to the array
		// so, free the memory allocated and return from the function
		__free( pdblValue );
		return -1;
	}

	// added the item to the array
	return lIndex;
}

// ***************************************************************************
// Routine Description: 
//		To append a variable of type HANDLE  into the Dynamic Array 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array containing the result 
//		[ in ] hValue			- HANDLE to be appended.
//		
// Return Value:  
//
//		If successfully added the item to the list then return index else -1
// 
// ***************************************************************************

LONG DynArrayAppendHandle( TARRAY pArray, HANDLE hValue )
{
	// local variables
	LONG lIndex = -1;
	HANDLE* phValue = NULL;

	// check whether the array is valid or not
	if ( ! IsValidArray( pArray ) ) 
		return -1;

	// allocate memory for value and check the result of memory allocation
	phValue = ( HANDLE* ) __calloc( 1, sizeof( HANDLE ) );
	if ( phValue == NULL ) 
		return -1;

	// set the value
	*phValue = hValue;

	// now add this item value to the array
	lIndex = __DynArrayAppend( pArray, DA_TYPE_HANDLE, sizeof( HANDLE ), phValue );
	if ( lIndex == -1 )
	{
		// failed in adding this item to the array
		// so, free the memory allocated and return from the function
		__free( phValue );
		return -1;
	}

	// added the item to the array
	return lIndex;
}

// ***************************************************************************
// Routine Description: 
//		To append a variable of type FILETIME  into the Dynamic Array 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array containing the result 
//		[ in ] ftValue			- FILETIME to be appended.
//		
// Return Value:  
//
//		If successfully added the item to the list then return index else -1
// 
// ***************************************************************************

LONG DynArrayAppendFileTime( TARRAY pArray, FILETIME ftValue )
{
	// local variables
	LONG lIndex = -1;
	FILETIME* pftValue = NULL;

	// check whether the array is valid or not
	if ( ! IsValidArray( pArray ) ) 
		return -1;

	// allocate memory for value and check the result of memory allocation
	pftValue = ( FILETIME* ) __calloc( 1, sizeof( FILETIME ) );
	if ( pftValue == NULL ) 
		return -1;

	// set the value
	*pftValue = ftValue;

	// now add this item value to the array
	lIndex = __DynArrayAppend( pArray, DA_TYPE_FILETIME, sizeof( FILETIME ), pftValue );
	if ( lIndex == -1 )
	{
		// failed in adding this item to the array
		// so, free the memory allocated and return from the function
		__free( pftValue );
		return -1;
	}

	// added the item to the array
	return lIndex;
}

// ***************************************************************************
// Routine Description: 
//		To append a variable of type SYSTEMTIME  into the Dynamic Array 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array containing the result 
//		[ in ] stValue			- variable of type SYSTEMTIME to be appended.
//		
// Return Value:  
//
//		If successfully added the item to the list then return index else -1
// 
// ***************************************************************************

LONG DynArrayAppendSystemTime( TARRAY pArray, SYSTEMTIME stValue )
{
	// local variables
	LONG lIndex = -1;
	SYSTEMTIME* pstValue = NULL;

	// check whether the array is valid or not
	if ( ! IsValidArray( pArray ) ) 
		return -1;

	// allocate memory for value and check the result of memory allocation
	pstValue = ( SYSTEMTIME* ) __calloc( 1, sizeof( SYSTEMTIME ) );
	if ( pstValue == NULL ) 
		return -1;

	// set the value
	*pstValue = stValue;

	// now add this item value to the array
	lIndex = __DynArrayAppend( pArray, DA_TYPE_SYSTEMTIME, sizeof( SYSTEMTIME ), pstValue );
	if ( lIndex == -1 )
	{
		// failed in adding this item to the array
		// so, free the memory allocated and return from the function
		__free( pstValue );
		return -1;
	}

	// added the item to the array
	return lIndex;
}

// ***************************************************************************
// Routine Description: 
//		To add a empty Row to the 2-dimensional Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwColumns		- No of columns the Row contains. 
//		
// Return Value:  
//
//		return the row number of the newly added row if successful else -1.
// 
// ***************************************************************************
LONG DynArrayAppendRow( TARRAY pArray, DWORD dwColumns )
{
	// local variables
	DWORD dw = 0;
	LONG lIndex = -1;
	TARRAY arrSubArray = NULL;

	// validate the array
	if ( ! IsValidArray( pArray ) ) 
		return -1;				// array is not valid

	// create the dynamic array
	arrSubArray = CreateDynamicArray();
	if ( arrSubArray == NULL )
		return -1;				// failed in creating the dynamic array

	// add the required no. of columns to the sub array
	for( dw = 0; dw < dwColumns; dw++ )
	{
		// add the dummy item to the array and check the result
		// if operation failed, break
		if ( __DynArrayAppend( arrSubArray, _TYPE_NEEDINIT, 0, NULL ) == -1 )
			break;
	}

	// check whether the operation is successfull or not
	if ( dw != dwColumns )
	{
		// adding of columns failed
		// destroy the dynamic array and return
		DestroyDynamicArray( &arrSubArray );
		return -1;
	}

	// now add this sub array to the main array and check the result
	lIndex = __DynArrayAppend( pArray, DA_TYPE_ARRAY, sizeof( TARRAY ), arrSubArray );
	if ( lIndex == -1 )
	{
		// failed in attaching the sub array to the main array
		// destroy the dynamic array and return failure
		DestroyDynamicArray( &arrSubArray );
		return -1;
	}

	// operation is successfull
	return lIndex;
}

// ***************************************************************************
// Routine Description: 
//		To add 'n' no. of columns to the array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwColumns		- No of columns the Row contains. 
//		
// Return Value:  
//		returns the no. of columns added
// 
// ***************************************************************************
DWORD DynArrayAddColumns( TARRAY pArray, DWORD dwColumns )
{
	// local variables
	DWORD dw = 0;

	// validate the array
	if ( ! IsValidArray( pArray ) ) 
		return -1;				// array is not valid

	// add the required no. of columns to the sub array
	for( dw = 0; dw < dwColumns; dw++ )
	{
		// add the dummy item to the array and check the result
		// if operation failed, break
		if ( __DynArrayAppend( pArray, _TYPE_NEEDINIT, 0, NULL ) == -1 )
			break;
	}

	// finish ...
	return dw;
}

// ***************************************************************************
// Routine Description: 
//		inserts 'n' no. of columns to the array at the n'th location
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwColumns		- No of columns the Row contains. 
//		
// Return Value:  
//		returns the no. of columns added
// 
// ***************************************************************************
DWORD DynArrayInsertColumns( TARRAY pArray, DWORD dwIndex, DWORD dwColumns )
{
	// local variables
	DWORD dw = 0;

	// validate the array
	if ( ! IsValidArray( pArray ) ) 
		return -1;				// array is not valid

	// add the required no. of columns to the sub array
	for( dw = 0; dw < dwColumns; dw++ )
	{
		// add the dummy item to the array and check the result
		// if operation failed, break
		if ( __DynArrayInsert( pArray, dwIndex, _TYPE_NEEDINIT, 0, NULL ) == -1 )
			break;
	}

	// finish ...
	return dw;
}

// ***************************************************************************
// Routine Description: 
//		To append a variable to a row in a  2-dimensional Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- Specifies the row posn for which the new value 
//								  is to be added.
//		[ in ] pValue			- pointer to the value
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// 
// ***************************************************************************

LONG DynArrayAppend2( TARRAY pArray, DWORD dwRow, LPVOID pValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the value to the sub array and return the result to the caller
	return DynArrayAppend( pItem->pValue, pValue );
}

// ***************************************************************************
// Routine Description: 
//		To append a string variable to a  2-dimensional Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- Specifies the row posn for which the new value 
//								  is to be added.
//		[ in ] szValue			- pointer to the string value
//		[ in ] dwLength			- length of the string.

// Return Value:  
//		-1 on failure
//		
//		
// 
// ***************************************************************************

LONG DynArrayAppendString2( TARRAY pArray, DWORD dwRow, LPCTSTR szValue, DWORD dwLength )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayAppendString( pItem->pValue, szValue, dwLength );
}

// ***************************************************************************
// Routine Description: 
//		To append a long type variable to a row in a  2-dimensional Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- Specifies the row posn for which the new value 
//								  is to be added.
//		[ in ] lValue			- long type value to be appended.
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// 
// ***************************************************************************

LONG DynArrayAppendLong2( TARRAY pArray, DWORD dwRow, LONG lValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayAppendLong( pItem->pValue, lValue );
}

/// ***************************************************************************
// Routine Description: 
//		To append a DWORD type variable to a row in a  2-dimensional Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- Specifies the row posn for which the new value 
//								  is to be added.
//		[ in ] dwValue			- DWORD type value to be appended.
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// 
// ***************************************************************************

LONG DynArrayAppendDWORD2( TARRAY pArray, DWORD dwRow, DWORD dwValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayAppendDWORD( pItem->pValue, dwValue );
}

/// ***************************************************************************
// Routine Description: 
//		To append a BOOL type variable to a row in a  2-dimensional Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- Specifies the row posn for which the new value 
//								  is to be added.
//		[ in ] bValue			- BOOL type value to be appended.
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// 
// ***************************************************************************

LONG DynArrayAppendBOOL2( TARRAY pArray, DWORD dwRow, BOOL bValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayAppendBOOL( pItem->pValue, bValue );
}


/// ***************************************************************************
// Routine Description: 
//		To append a Float type variable to a row in a  2-dimensional Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- Specifies the row posn for which the new value 
//								  is to be added.
//		[ in ] fValue			- Float type value to be appended.
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// 
// ***************************************************************************

LONG DynArrayAppendFloat2( TARRAY pArray, DWORD dwRow, float fValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayAppendFloat( pItem->pValue, fValue );
}

/// ***************************************************************************
// Routine Description: 
//		To append a double type variable to a row in a  2-dimensional Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- Specifies the row posn for which the new value 
//								  is to be added.
//		[ in ] dblValue			- dblValue type value to be appended.
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// 
// ***************************************************************************

LONG DynArrayAppendDouble2( TARRAY pArray, DWORD dwRow, double dblValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayAppendDouble( pItem->pValue, dblValue );
}

/// ***************************************************************************
// Routine Description: 
//		To append a Handle type variable to a row in a  2-dimensional Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- Specifies the row posn for which the new value 
//								  is to be added.
//		[ in ] hValue			- Handle value to be appended.
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// 
// ***************************************************************************

LONG DynArrayAppendHandle2( TARRAY pArray, DWORD dwRow, HANDLE hValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayAppendHandle( pItem->pValue, hValue );
}

/// ***************************************************************************
// Routine Description: 
//		To append a FILETIME type variable to a row in a  2-dimensional Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- Specifies the row posn for which the new value 
//								  is to be added.
//		[ in ] ftValue			- variable of type FILETIME to be appended.
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// 
// ***************************************************************************

LONG DynArrayAppendFileTime2( TARRAY pArray, DWORD dwRow, FILETIME ftValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayAppendFileTime( pItem->pValue, ftValue );
}

/// ***************************************************************************
// Routine Description: 
//		To append a SYSTEMTIME type variable to a row in a  2-dimensional Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- Specifies the row posn for which the new value 
//								  is to be added.
//		[ in ] stValue			- variable of type SYSTEMTIME to be appended.
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// 
// ***************************************************************************

LONG DynArrayAppendSystemTime2( TARRAY pArray, DWORD dwRow, SYSTEMTIME stValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayAppendSystemTime( pItem->pValue, stValue );
}

/// ***************************************************************************
// Routine Description: 
//		To insert a variable into a  Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- Specifies the index.
//								  
//		[ in ] pValue			- value to be inserted.
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// 
// ***************************************************************************

LONG DynArrayInsert( TARRAY pArray, DWORD dwIndex, LPVOID pValue )
{
	// validate the pointer value
	if ( pValue == NULL )
		return -1;			// invalid memory address passed

	// append the value and return the result
	return __DynArrayInsert( pArray, dwIndex, DA_TYPE_GENERAL, sizeof( LPVOID ), pValue );
}

/// ***************************************************************************
// Routine Description: 
//		To insert a string type variable into a  Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- Specifies the index.
//		[ in ] szValue			- pointer to the string		  
//		[ in ] dwLength			- length of the string.
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// ***************************************************************************

LONG DynArrayInsertString( TARRAY pArray, DWORD dwIndex, LPCTSTR szValue, DWORD dwLength )
{
	// local variables
	LONG lIndex = -1;
	LPTSTR pszValue = NULL;
	__PTARRAY pArrayEx = NULL;

	// check whether the array is valid or not
	if ( ! IsValidArray( pArray ) ) 
		return -1;

	// convert the passed memory location info into appropriate structure
	pArrayEx = ( __PTARRAY ) pArray;

	// determine the length of string ( memory ) that has to be allocated
	if ( dwLength == 0 )
		dwLength = lstrlen( szValue );

	// accomodate space for storing NULL character
	dwLength += 1;

	// allocate memory for and check the result of memory allocation
	pszValue = ( LPTSTR ) __calloc( dwLength, sizeof( TCHAR ) );
	if ( pszValue == NULL ) 
		return -1;

	// copy the contents of the string ( copy should be based on the length )
	lstrcpyn( pszValue, szValue, dwLength );

	// now add this item value to the array
	lIndex = __DynArrayInsert( pArray, dwIndex, 
		DA_TYPE_STRING, dwLength * sizeof( TCHAR ), pszValue );
	if ( lIndex == -1 )
	{
		// failed in adding this item to the array
		// so, free the memory allocated and return from the function
		__free( pszValue );
		return -1;
	}

	// added the item to the array
	return lIndex;
}

/// ***************************************************************************
// Routine Description: 
//		To insert a string type variable into a  Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- Specifies the index.
//		[ in ] lValue			- pointer to the string.		  
// 
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// ***************************************************************************

LONG DynArrayInsertLong( TARRAY pArray, DWORD dwIndex, LONG lValue )
{
	// local variables
	LONG lIndex = -1;
	PLONG plValue = NULL;

	// check whether the array is valid or not
	if ( ! IsValidArray( pArray ) ) 
		return -1;

	// allocate memory for value and check the result of memory allocation
	plValue = ( LONG* ) __calloc( 1, sizeof( LONG ) );
	if ( plValue == NULL ) 
		return -1;

	// set the value
	*plValue = lValue;

	// now add this item value to the array
	lIndex = __DynArrayInsert( pArray, dwIndex, DA_TYPE_LONG, sizeof( LONG ), plValue );
	if ( lIndex == -1 )
	{
		// failed in adding this item to the array
		// so, free the memory allocated and return from the function
		__free( plValue );
		return -1;
	}

	// added the item to the array
	return lIndex;
}

/// ***************************************************************************
// Routine Description: 
//		To insert a DWORD type variable into a  Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- Specifies the index.
//		[ in ] dwValue			- specifies the variable to be inserted.		  
// 
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// ***************************************************************************

LONG DynArrayInsertDWORD( TARRAY pArray, DWORD dwIndex, DWORD dwValue )
{
	// local variables
	LONG lIndex = -1;
	PDWORD pdwValue = NULL;

	// check whether the array is valid or not
	if ( ! IsValidArray( pArray ) ) 
		return -1;

	// allocate memory for value and check the result of memory allocation
	pdwValue = ( PDWORD ) __calloc( 1, sizeof( DWORD ) );
	if ( pdwValue == NULL ) 
		return -1;

	// set the value
	*pdwValue = dwValue;

	// now add this item value to the array
	lIndex = __DynArrayInsert( pArray, dwIndex, DA_TYPE_DWORD, sizeof( DWORD ), pdwValue );
	if ( lIndex == -1 )
	{
		// failed in adding this item to the array
		// so, free the memory allocated and return from the function
		__free( pdwValue );
		return -1;
	}

	// added the item to the array
	return lIndex;
}

/// ***************************************************************************
// Routine Description: 
//		To insert a BOOL type variable into a  Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- Specifies the index.
//		[ in ] bValue			- specifies the  BOOL variable to be inserted.		  
// 
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// ***************************************************************************

LONG DynArrayInsertBOOL( TARRAY pArray, DWORD dwIndex, BOOL bValue )
{
	// local variables
	LONG lIndex = -1;
	PBOOL pbValue = NULL;

	// check whether the array is valid or not
	if ( ! IsValidArray( pArray ) ) 
		return -1;

	// allocate memory for value and check the result of memory allocation
	pbValue = ( PBOOL ) __calloc( 1, sizeof( BOOL ) );
	if ( pbValue == NULL ) 
		return -1;

	// set the value
	*pbValue = bValue;

	// now add this item value to the array
	lIndex = __DynArrayInsert( pArray, dwIndex, DA_TYPE_BOOL, sizeof( BOOL ), pbValue );
	if ( lIndex == -1 )
	{
		// failed in adding this item to the array
		// so, free the memory allocated and return from the function
		__free( pbValue );
		return -1;
	}

	// added the item to the array
	return lIndex;
}


/// ***************************************************************************
// Routine Description: 
//		To insert a float type variable into a  Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- Specifies the index.
//		[ in ] fValue			- specifies the  float type  variable to be inserted.		  
// 
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// ***************************************************************************

LONG DynArrayInsertFloat( TARRAY pArray, DWORD dwIndex, float fValue )
{
	// local variables
	LONG lIndex = -1;
	float* pfValue = NULL;

	// check whether the array is valid or not
	if ( ! IsValidArray( pArray ) ) 
		return -1;

	// allocate memory for value and check the result of memory allocation
	pfValue = ( float* ) __calloc( 1, sizeof( float ) );
	if ( pfValue == NULL ) 
		return -1;

	// set the value
	*pfValue = fValue;

	// now add this item value to the array
	lIndex = __DynArrayInsert( pArray, dwIndex, DA_TYPE_FLOAT, sizeof( float ), pfValue );
	if ( lIndex == -1 )
	{
		// failed in adding this item to the array
		// so, free the memory allocated and return from the function
		__free( pfValue );
		return -1;
	}

	// added the item to the array
	return lIndex;
}

/// ***************************************************************************
// Routine Description: 
//		To insert a double type variable into a  Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- Specifies the index.
//		[ in ] dblValue			- specifies the  double type  variable to be inserted.		  
// 
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// ***************************************************************************

LONG DynArrayInsertDouble( TARRAY pArray, DWORD dwIndex, double dblValue )
{
	// local variables
	LONG lIndex = -1;
	double* pdblValue = NULL;

	// check whether the array is valid or not
	if ( ! IsValidArray( pArray ) ) 
		return -1;

	// allocate memory for value and check the result of memory allocation
	pdblValue = ( double* ) __calloc( 1, sizeof( double ) );
	if ( pdblValue == NULL ) 
		return -1;

	// set the value
	*pdblValue = dblValue;

	// now add this item value to the array
	lIndex = __DynArrayInsert( pArray, dwIndex, DA_TYPE_DOUBLE, sizeof( double ), pdblValue );
	if ( lIndex == -1 )
	{
		// failed in adding this item to the array
		// so, free the memory allocated and return from the function
		__free( pdblValue );
		return -1;
	}

	// added the item to the array
	return lIndex;
}

/// ***************************************************************************
// Routine Description: 
//		To insert a HANDLE type variable into a  Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- Specifies the index.
//		[ in ] hValue			- specifies the  HANDLE type  variable to be inserted.		  
// 
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// ***************************************************************************

LONG DynArrayInsertHandle( TARRAY pArray, DWORD dwIndex, HANDLE hValue )
{
	// local variables
	LONG lIndex = -1;
	HANDLE* phValue = NULL;

	// check whether the array is valid or not
	if ( ! IsValidArray( pArray ) ) 
		return -1;

	// allocate memory for value and check the result of memory allocation
	phValue = ( HANDLE* ) __calloc( 1, sizeof( HANDLE ) );
	if ( phValue == NULL ) 
		return -1;

	// set the value
	*phValue = hValue;

	// now add this item value to the array
	lIndex = __DynArrayInsert( pArray, dwIndex, DA_TYPE_HANDLE, sizeof( HANDLE ), phValue );
	if ( lIndex == -1 )
	{
		// failed in adding this item to the array
		// so, free the memory allocated and return from the function
		__free( phValue );
		return -1;
	}

	// added the item to the array
	return lIndex;
}

/// ***************************************************************************
// Routine Description: 
//		To insert a SYSTEMTIME type variable into a  Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- Specifies the index.
//		[ in ] stValue			- specifies the  SYSTEMTIME type  variable to be inserted.		  
// 
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// ***************************************************************************

LONG DynArrayInsertSystemTime( TARRAY pArray, DWORD dwIndex, SYSTEMTIME stValue )
{
	// local variables
	LONG lIndex = -1;
	SYSTEMTIME* pstValue = NULL;

	// check whether the array is valid or not
	if ( ! IsValidArray( pArray ) ) 
		return -1;

	// allocate memory for value and check the result of memory allocation
	pstValue = ( SYSTEMTIME* ) __calloc( 1, sizeof( SYSTEMTIME ) );
	if ( pstValue == NULL ) 
		return -1;

	// set the value
	*pstValue = stValue;

	// now add this item value to the array
	lIndex = __DynArrayInsert( pArray, dwIndex, DA_TYPE_SYSTEMTIME, 
		sizeof( SYSTEMTIME ), pstValue );
	if ( lIndex == -1 )
	{
		// failed in adding this item to the array
		// so, free the memory allocated and return from the function
		__free( pstValue );
		return -1;
	}

	// added the item to the array
	return lIndex;
}

/// ***************************************************************************
// Routine Description: 
//		To insert a SYSTEMTIME type variable into a  Dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- Specifies the index.
//		[ in ] ftValue			- specifies the  SYSTEMTIME type  variable to be inserted.		  
// 
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// ***************************************************************************

LONG DynArrayInsertFileTime( TARRAY pArray, DWORD dwIndex, FILETIME ftValue )
{
	// local variables
	LONG lIndex = -1;
	FILETIME* pftValue = NULL;

	// check whether the array is valid or not
	if ( ! IsValidArray( pArray ) ) 
		return -1;

	// allocate memory for value and check the result of memory allocation
	pftValue = ( FILETIME* ) __calloc( 1, sizeof( FILETIME ) );
	if ( pftValue == NULL ) 
		return -1;

	// set the value
	*pftValue = ftValue;

	// now add this item value to the array
	lIndex = __DynArrayInsert( pArray, dwIndex, DA_TYPE_FILETIME, 
		sizeof( FILETIME ), pftValue );
	if ( lIndex == -1 )
	{
		// failed in adding this item to the array
		// so, free the memory allocated and return from the function
		__free( pftValue );
		return -1;
	}

	// added the item to the array
	return lIndex;
}

/// ***************************************************************************
// Routine Description: 
//		this funtion insert a new row to a dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- Specifies the index.
//		[ in ] dwColumns		- specifies the  number of columns to be inserted.
// 
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// ***************************************************************************

LONG DynArrayInsertRow( TARRAY pArray, DWORD dwIndex, DWORD dwColumns )
{
	// local variables
	DWORD dw = 0;
	LONG lIndex = -1;
	TARRAY arrSubArray = NULL;

	// validate the array
	if ( ! IsValidArray( pArray ) ) 
		return -1;				// array is not valid

	// create the dynamic array
	arrSubArray = CreateDynamicArray();
	if ( arrSubArray == NULL )
		return -1;				// failed in creating the dynamic array

	// add the required no. of columns to the sub array
	for( dw = 0; dw < dwColumns; dw++ )
	{
		// add the dummy item to the array and check the result
		// if operation failed, break
		if ( ! __DynArrayAppend( arrSubArray, _TYPE_NEEDINIT, 0, NULL ) )
			break;
	}

	// check whether the operation is successfull or not
	if ( dw != dwColumns )
	{
		// adding of columns failed
		// destroy the dynamic array and return
		DestroyDynamicArray( &arrSubArray );
		return -1;
	}

	// now add this sub array to the main array and check the result
	lIndex = __DynArrayInsert( pArray, dwIndex, DA_TYPE_ARRAY, sizeof( TARRAY ), arrSubArray );
	if ( lIndex == -1 )
	{
		// failed in attaching the sub array to the main array
		// destroy the dynamic array and return failure
		DestroyDynamicArray( &arrSubArray );
		return -1;
	}

	// operation is successfull
	return lIndex;
}

/// ***************************************************************************
// Routine Description: 
//		this funtion insert a new row to a 2-dimensional  dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- Specifies the row.
//		[ in ] dwColIndex		- specifies the column 
//		[ in ] pValue			- pointer to the value.
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// ***************************************************************************

LONG DynArrayInsert2( TARRAY pArray, DWORD dwRow, DWORD dwColIndex, LPVOID pValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the value to the sub array and return the result to the caller
	return DynArrayInsert( pItem->pValue, dwColIndex, pValue );
}


/// ***************************************************************************
// Routine Description: 
//		this funtion insert a new string into a 2-dimensional  dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- Specifies the row.
//		[ in ] dwColIndex		- specifies the column 
//		[ in ] szValue			- pointer to the value.
//		[ in ] dwLength			- string length.
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// ***************************************************************************


LONG DynArrayInsertString2( TARRAY pArray, 
						    DWORD dwRow, DWORD dwColIndex, LPCTSTR szValue, DWORD dwLength )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayInsertString( pItem->pValue, dwColIndex, szValue, dwLength );
}


/// ***************************************************************************
// Routine Description: 
//		this funtion insert a new long type varaible into a 2-dimensional  dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- Specifies the row.
//		[ in ] dwColIndex		- specifies the column 
//		[ in ] lValue 			- long type value to be inserted.
//		
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// ***************************************************************************

LONG DynArrayInsertLong2( TARRAY pArray, DWORD dwRow, DWORD dwColIndex, LONG lValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayInsertLong( pItem->pValue, dwColIndex, lValue );
}

/// ***************************************************************************
// Routine Description: 
//		this funtion insert a new DWORD type varaible into a 2-dimensional  dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- Specifies the row.
//		[ in ] dwColIndex		- specifies the column 
//		[ in ] dwValue 			- DWORD value to be inserted.
//		
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// ***************************************************************************

LONG DynArrayInsertDWORD2( TARRAY pArray, DWORD dwRow, DWORD dwColIndex, DWORD dwValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayInsertDWORD( pItem->pValue, dwColIndex, dwValue );
}

/// ***************************************************************************
// Routine Description: 
//		this funtion insert a new BOOL type variable into a 2-dimensional  dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- Specifies the row.
//		[ in ] dwColIndex		- specifies the column 
//		[ in ] bValue 			- BOOL type value to be inserted.
//		
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// ***************************************************************************

LONG DynArrayInsertBOOL2( TARRAY pArray, DWORD dwRow, DWORD dwColIndex, BOOL bValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayInsertBOOL( pItem->pValue, dwColIndex, bValue );
}

/// ***************************************************************************
// Routine Description: 
//		this funtion insert a new float type variable into a 2-dimensional  dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- Specifies the row.
//		[ in ] dwColIndex		- specifies the column 
//		[ in ] fValue 			- float type value to be inserted.
//		
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// ***************************************************************************

LONG DynArrayInsertFloat2( TARRAY pArray, DWORD dwRow, DWORD dwColIndex, float fValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayInsertFloat( pItem->pValue, dwColIndex, fValue );
}

/// ***************************************************************************
// Routine Description: 
//		this funtion insert a new double type variable into a 2-dimensional  dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- Specifies the row.
//		[ in ] dwColIndex		- specifies the column 
//		[ in ] dblValue 		- double type value to be inserted.
//		
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// ***************************************************************************

LONG DynArrayInsertDouble2( TARRAY pArray, DWORD dwRow, DWORD dwColIndex, double dblValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayInsertDouble( pItem->pValue, dwColIndex, dblValue );
}

/// ***************************************************************************
// Routine Description: 
//		this funtion insert a new double type variable into a 2-dimensional  dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- Specifies the row.
//		[ in ] dwColIndex		- specifies the column 
//		[ in ] hValue	 		- HANDLE type value to be inserted.
//		
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// ***************************************************************************

LONG DynArrayInsertHandle2( TARRAY pArray, DWORD dwRow, DWORD dwColIndex, HANDLE hValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayInsertHandle( pItem->pValue, dwColIndex, hValue );
}

/// ***************************************************************************
// Routine Description: 
//		this funtion insert a new  SYSTEMTIME type variable into a 2-dimensional  dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- Specifies the row.
//		[ in ] dwColIndex		- specifies the column 
//		[ in ] stValue	 		- SYSTEMTIME type value to be inserted.
//		
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// ***************************************************************************

LONG DynArrayInsertSystemTime2( TARRAY pArray, 
							    DWORD dwRow, DWORD dwColIndex, SYSTEMTIME stValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayInsertSystemTime( pItem->pValue, dwColIndex, stValue );
}


/// ***************************************************************************
// Routine Description: 
//		this funtion insert a new  FILETIME type variable into a 2-dimensional  dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- Specifies the row.
//		[ in ] dwColIndex		- specifies the column 
//		[ in ] ftValue	 		- FILETIME type value to be inserted.
//		
// Return Value:  
//		-1 on failure
//		index in the case of success.
//		
// ***************************************************************************

LONG DynArrayInsertFileTime2( TARRAY pArray, DWORD dwRow, DWORD dwColIndex, FILETIME ftValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayInsertFileTime( pItem->pValue, dwColIndex, ftValue );
}

/// ***************************************************************************
// Routine Description: 
//		this funtion empties the contents of the dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex		- specifies the column 
//		
// Return Value:  
//		false on failure
//		true ON SUCCESS.
//		
// ***************************************************************************

BOOL DynArrayRemove( TARRAY pArray, DWORD dwIndex )
{
	// local variables
	__PTITEM pItem = NULL;
	__PTITEM pPrevItem = NULL;
	__PTARRAY pArrayEx = NULL;

	// get the pointer to the item that has to be removed and also its previous item
	pItem = __DynArrayGetItem( pArray, dwIndex, &pPrevItem );
	if ( pItem == NULL ) 
		return FALSE;	// index or array is invalid ... cannot proceed

	// convert the passed memory location info into appropriate structure
	pArrayEx = ( __PTARRAY ) pArray;

	// unlink the item from the list first
	// before unlinking, check whether item which is going to deleted 
	//		is the first item in the list
	//		is the last item in the list
	//		is the middle item in the list
	if ( pPrevItem != NULL ) pPrevItem->pNext = pItem->pNext;
	if ( pPrevItem == NULL ) pArrayEx->pStart = pItem->pNext;
	if ( pItem == pArrayEx->pLast ) pArrayEx->pLast = pPrevItem;

	// update the count of the array item
	pArrayEx->dwCount--;

	// free the memory being used by the currently unlinked item and return success
	__DynArrayFreeItemValue( pItem );	// free the memory allocated for storing data
	__free( pItem );		// finally free the memory allocated for item itself
	return TRUE;
}


/// ***************************************************************************
// Routine Description: 
//		this funtion REMOVES a column from a  dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- specifies the row.
//		[ in ] dwColumn			- specifies the column 
//		
// Return Value:  
//		false on failure
//		true ON SUCCESS.
//		
// ***************************************************************************

BOOL DynArrayRemoveColumn( TARRAY pArray, DWORD dwRow, DWORD dwColumn )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return FALSE;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayRemove( pItem->pValue, dwColumn );
}



/// ***************************************************************************
// Routine Description: 
//		this function retreives the number of rows in a 1-dimensional  dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		
// Return Value:  
//		false on failure
//		true ON SUCCESS.
//		
// ***************************************************************************

DWORD DynArrayGetCount( TARRAY pArray )
{
	// local variables
	__PTARRAY pArrayEx = NULL;

	// check whether the array is valid or not
	if ( IsValidArray( pArray ) == FALSE ) 
		return 0;
	
	// convert the passed memory location info into appropriate structure
	pArrayEx = ( __PTARRAY ) pArray;

	// return the size of the array
	return pArrayEx->dwCount;
}


/// ***************************************************************************
// Routine Description: 
//		this function retreives the number of columns in a 2-dimensional  dynamic array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow            - row for which the number of columns have to be got.
// Return Value:  
//		false on failure
//		true ON SUCCESS.
//		
// ***************************************************************************

DWORD DynArrayGetCount2( TARRAY pArray, DWORD dwRow )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return FALSE;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayGetCount( pItem->pValue );
}


/// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a dynamic array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex          - index.
// Return Value:  
//		false on failure
//		true ON SUCCESS.
//		
// ***************************************************************************

LPVOID DynArrayItem( TARRAY pArray, DWORD dwIndex )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL ) return NULL;		// index / array is not valid

	// check the type of the item first
	// if the type doesn't match, return some default value
	if ( pItem->dwType != DA_TYPE_GENERAL && pItem->dwType != DA_TYPE_ARRAY )
		return NULL;
	
	// now return the contents of the __TITEM structure
	return pItem->pValue;
}

/// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a dynamic array as a string.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex          - index.
// Return Value:  
//		false on failure
//		true ON SUCCESS.
//		
// ***************************************************************************

LPCTSTR DynArrayItemAsString( TARRAY pArray, DWORD dwIndex )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL ) 
		return NULL;		// index / array is not valid

	// check the type of the item first
	// if the type doesn't match, return some default value
	if ( pItem->dwType != DA_TYPE_STRING )
		return NULL;
	
	// now return the contents of the __TITEM structure
	return ( ( LPCTSTR ) pItem->pValue );
}

/// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a dynamic array as a Long varaible.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex          - index.
// Return Value:  
//		false on failure
//		true ON SUCCESS.
//		
// ***************************************************************************

LONG DynArrayItemAsLong( TARRAY pArray, DWORD dwIndex )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL ) return -1;					// index / array is not valid
	
	// check the type of the item first
	// if the type doesn't match, return some default value
	if ( pItem->dwType != DA_TYPE_DWORD && pItem->dwType != DA_TYPE_LONG )
		return -1;
	
	// now return the contents of the __TITEM structure
	return ( *( PLONG ) pItem->pValue );
}

/// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a dynamic array as a DWORD varaible.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex          - index.
// Return Value:  
//		false on failure
//		true ON SUCCESS.
//		
// ***************************************************************************

DWORD DynArrayItemAsDWORD( TARRAY pArray, DWORD dwIndex )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL ) 
		return -1;					// index / array is not valid
	
	// check the type of the item first
	// if the type doesn't match, return some default value
	if ( pItem->dwType != DA_TYPE_DWORD && pItem->dwType != DA_TYPE_LONG )
		return -1;
	
	// now return the contents of the __TITEM structure
	return *( ( PDWORD ) pItem->pValue );
}

/// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a dynamic array as a bool type varaible.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex          - index.
// Return Value:  
//		false on failure
//		true ON SUCCESS.
//		
// ***************************************************************************

BOOL DynArrayItemAsBOOL( TARRAY pArray, DWORD dwIndex )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL ) 
		return FALSE;					// index / array is not valid
	
	// check the type of the item first
	// if the type doesn't match, return some default value
	if ( pItem->dwType != DA_TYPE_BOOL )
		return FALSE;
	
	// now return the contents of the __TITEM structure
	return *( ( PBOOL ) pItem->pValue );
}


/// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a dynamic array as a float type varaible.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex          - index.
// Return Value:  
//		false on failure
//		true ON SUCCESS.
//		
// ***************************************************************************

float DynArrayItemAsFloat( TARRAY pArray, DWORD dwIndex )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL ) 
		return -1.0f;					// index / array is not valid
	
	// check the type of the item first
	// if the type doesn't match, return some default value
	if ( pItem->dwType != DA_TYPE_FLOAT )
		return -1.0f;
	
	// now return the contents of the __TITEM structure
	return *( ( float* ) pItem->pValue );
}


/// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a dynamic array as a double type varaible.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex          - index.
// Return Value:  
//		false on failure
//		true ON SUCCESS.
//		
// ***************************************************************************

double DynArrayItemAsDouble( TARRAY pArray, DWORD dwIndex )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL ) 
		return -1.0;					// index / array is not valid
	
	// check the type of the item first
	// if the type doesn't match, return some default value
	if ( pItem->dwType != DA_TYPE_DOUBLE )
		return -1.0;
	
	// now return the contents of the __TITEM structure
	return *( ( double* ) pItem->pValue );
}


/// ***************************************************************************
// Routine Description: 
//		This function retreives the item from a dynamic array as a handle type varaible.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex          - index.
// Return Value:  
//		false on failure
//		true ON SUCCESS.
//		
// ***************************************************************************

HANDLE DynArrayItemAsHandle( TARRAY pArray, DWORD dwIndex )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL ) 
		return NULL;					// index / array is not valid
	
	// check the type of the item first
	// if the type doesn't match, return some default value
	if ( pItem->dwType != DA_TYPE_HANDLE )
		return NULL;
	
	// now return the contents of the __TITEM structure
	return *( ( HANDLE* ) pItem->pValue );
}


/// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a dynamic array as a SYSTEMTIME type varaible.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex          - index.
// Return Value:  
//		false on failure
//		true ON SUCCESS.
//		
// ***************************************************************************

SYSTEMTIME DynArrayItemAsSystemTime( TARRAY pArray, DWORD dwIndex )
{
	// local variables
	__PTITEM pItem = NULL;
	FILETIME ftTemp = { 0, 0 };
	SYSTEMTIME stTemp = { 0, 0, 0, 0, 0, 0 };			// dummy 

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL ) 
		return stTemp;					// index / array is not valid
	
	// check the type of the item first
	// if the type doesn't match, return some default value
	if ( pItem->dwType != DA_TYPE_SYSTEMTIME && pItem->dwType != DA_TYPE_FILETIME )
		return stTemp;

	// now do the needed manipulations ( if needed )
	if ( pItem->dwType == DA_TYPE_SYSTEMTIME )
	{
		// value itself is of required type
		stTemp = *( ( SYSTEMTIME* ) pItem->pValue );
	}
	else
	{
		// need to do conversions
		ftTemp = *( ( FILETIME* ) pItem->pValue );
		FileTimeToSystemTime( &ftTemp, &stTemp );
	}
	
	// now return the contents of the __TITEM structure
	return stTemp;
}

/// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a dynamic array as a FILETIME type varaible.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex          - index.
// Return Value:  
//		false on failure
//		true ON SUCCESS.
//		
// ***************************************************************************

FILETIME DynArrayItemAsFileTime( TARRAY pArray, DWORD dwIndex )
{
	// local variables
	__PTITEM pItem = NULL;
	FILETIME ftTemp = { 0, 0 };			// dummy
	SYSTEMTIME stTemp = { 0, 0, 0, 0, 0, 0 };			// dummy 

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL )	
		return ftTemp;					// index / array is not valid
	
	// check the type of the item first
	// if the type doesn't match, return some default value
	if ( pItem->dwType != DA_TYPE_SYSTEMTIME && pItem->dwType != DA_TYPE_FILETIME )
		return ftTemp;
	
	// now do the needed manipulations ( if needed )
	if ( pItem->dwType == DA_TYPE_SYSTEMTIME )
	{
		// value itself is of required type
		ftTemp = *( ( FILETIME* ) pItem->pValue );
	}
	else
	{
		// need to do conversions
		stTemp = *( ( SYSTEMTIME* ) pItem->pValue );
		SystemTimeToFileTime( &stTemp, &ftTemp );
	}
	
	// now return the contents of the __TITEM structure
	return ftTemp;
}

/// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a dynamic array in string format.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex          - index.
//		[ in ] szBuffer			- buffer to hold the string
//		[ in ] dwlength			- string length.
// Return Value:  
//		false on failure
//		true ON SUCCESS.
//		
// ***************************************************************************

DWORD DynArrayItemAsStringEx( TARRAY pArray, DWORD dwIndex, LPTSTR szBuffer, DWORD dwLength )
{
	// local variables
	__PTITEM pItem = NULL;
	__MAX_SIZE_STRING szTemp = NULL_STRING;

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL )
		return 0;					// index / array is not valid

	// give the value based on the type of the current item
	lstrcpy( szBuffer, NULL_STRING );		// clear the existing contents

	// check the length specified
	if ( dwLength == 0 )
		return 0;

	// convert and get the values in string format
	switch( pItem->dwType )
	{
	case DA_TYPE_STRING:
		lstrcpyn( szBuffer, ( LPCTSTR ) pItem->pValue, dwLength );
		break;

	case DA_TYPE_LONG:
	case DA_TYPE_DWORD:
		FORMAT_STRING( szTemp, _T( "%ld" ), *( LONG* ) pItem->pValue );
		lstrcpyn( szBuffer, szTemp, dwLength );
		break;

	case DA_TYPE_FLOAT:
		FORMAT_STRING( szTemp, _T( "%f" ), *( float* ) pItem->pValue );
		lstrcpyn( szBuffer, szTemp, dwLength );
		break;

	case DA_TYPE_DOUBLE:
		FORMAT_STRING( szTemp, _T( "%f" ), *( double* ) pItem->pValue );
		lstrcpyn( szBuffer, szTemp, dwLength );
		break;

	case DA_TYPE_BOOL:
	case DA_TYPE_ARRAY:
	case DA_TYPE_HANDLE:
	case DA_TYPE_SYSTEMTIME:
	case DA_TYPE_FILETIME:
	case DA_TYPE_GENERAL:
	case _TYPE_NEEDINIT:
	default:
		break;		// no value can be set
	}

	// return
	return lstrlen( szBuffer );
}

/// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a dynamic array 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow            - The number of rows
//		[ in ] dwColumn			- The number of columns 
//		
// Return Value:  
//		pointer to the item.	
//		
//		
// ***************************************************************************

LPVOID DynArrayItem2( TARRAY pArray, DWORD dwRow, DWORD dwColumn )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return NULL;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayItem( pItem->pValue, dwColumn );
}


/// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a dynamic array as a string.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row .
//		[ in ] dwColumn			- column
//
// Return Value:  
//		pointer to the the constant string.	
//		
//		
// ***************************************************************************

LPCTSTR DynArrayItemAsString2( TARRAY pArray, DWORD dwRow, DWORD dwColumn )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return NULL;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayItemAsString( pItem->pValue, dwColumn );
}


/// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a dynamic array as a long variable.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row .
//		[ in ] dwColumn			- column
//
// Return Value:  
//		The variable of type Long 
//		
//		
// ***************************************************************************

LONG DynArrayItemAsLong2( TARRAY pArray, DWORD dwRow, DWORD dwColumn )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayItemAsLong( pItem->pValue, dwColumn );
}

/// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a dynamic array as a DWORD variable.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row .
//		[ in ] dwColumn			- column
//
// Return Value:  
//		The variable of type DWORD 
//		
//		
// ***************************************************************************

DWORD DynArrayItemAsDWORD2( TARRAY pArray, DWORD dwRow, DWORD dwColumn )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return 0;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayItemAsDWORD( pItem->pValue, dwColumn );
}

//// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a dynamic array as a BOOL variable.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row .
//		[ in ] dwColumn			- column
//
// Return Value:  
//		The variable of type BOOL. 
//		
//		
// ***************************************************************************

BOOL DynArrayItemAsBOOL2( TARRAY pArray, DWORD dwRow, DWORD dwColumn )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return FALSE;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayItemAsBOOL( pItem->pValue, dwColumn );
}

//// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a dynamic array as a float variable.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row .
//		[ in ] dwColumn			- column
//
// Return Value:  
//		The variable of type float. 
//		
//		
// ***************************************************************************

float DynArrayItemAsFloat2( TARRAY pArray, DWORD dwRow, DWORD dwColumn )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1.0f;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayItemAsFloat( pItem->pValue, dwColumn );
}

//// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a dynamic array as a double variable.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row .
//		[ in ] dwColumn			- column
//
// Return Value:  
//		The variable of type double. 
//		
//		
// ***************************************************************************

double DynArrayItemAsDouble2( TARRAY pArray, DWORD dwRow, DWORD dwColumn )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1.0;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayItemAsDouble( pItem->pValue, dwColumn );
}

//// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a dynamic array as a HANDLE variable.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row .
//		[ in ] dwColumn			- column
//
// Return Value:  
//		The variable of type HANDLE. 
//		
//		
// ***************************************************************************

HANDLE DynArrayItemAsHandle2( TARRAY pArray, DWORD dwRow, DWORD dwColumn )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return NULL;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayItemAsHandle( pItem->pValue, dwColumn );
}


//// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a dynamic array as a SYSTEMTIME type variable.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row .
//		[ in ] dwColumn			- column
//
// Return Value:  
//		The variable of type SYSTEMTIME. 
//		
//		
// ***************************************************************************

SYSTEMTIME DynArrayItemAsSystemTime2( TARRAY pArray, DWORD dwRow, DWORD dwColumn )
{
	// local variables
	__PTITEM pItem = NULL;
	SYSTEMTIME stTemp = { 0, 0, 0, 0, 0, 0 };			// dummy 

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return stTemp;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayItemAsSystemTime( pItem->pValue, dwColumn );
}

//// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a 2 dimensional dynamic array as
//		 a string type variable.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row .
//		[ in ] dwColumn			- column
//		[ in ] szBuffer			- String buffer 
//		[ in ] dwLength			-  length of the string.
// Return Value:  
//		The variable of type string. 
//		
//		
// ***************************************************************************

DWORD DynArrayItemAsStringEx2( TARRAY pArray, 
							  DWORD dwRow, DWORD dwColumn, LPTSTR szBuffer, DWORD dwLength )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return 0;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayItemAsStringEx( pItem->pValue, dwColumn, szBuffer, dwLength );
}

//// ***************************************************************************
// Routine Description: 
//		this function retreives the item from a 2 dimensional dynamic array as
//		 a FILETIME type variable.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row .
//		[ in ] dwColumn			- column
//
// Return Value:  
//		The variable of type FILETIME. 
//		
//		
// ***************************************************************************

FILETIME DynArrayItemAsFileTime2( TARRAY pArray, DWORD dwRow, DWORD dwColumn )
{
	// local variables
	__PTITEM pItem = NULL;
	FILETIME ftTemp = { 0, 0 };			// dummy

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return ftTemp;	// no item exists at the specified row or item is not of type array

	// now add the string to the sub array and return the result to the caller
	return DynArrayItemAsFileTime( pItem->pValue, dwColumn );
}

//// ***************************************************************************
// Routine Description: 
//		general function which inserts an item into a 1-dimensional array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- row .
//		[ in ] pValue			- column
//
// Return Value:  
//		TRUE : if successfully inserted the item into the array. 
//		FALSE : if Unsuccessfull .
//		
// ***************************************************************************

BOOL DynArraySet( TARRAY pArray, DWORD dwIndex, LPVOID pValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// validate the pointer value
	if ( pValue == NULL )
		return FALSE;			// invalid memory address passed

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL )
		return FALSE;		// item not found / invalid array pointer
	
	// check the data type ... it should of string type
	if ( pItem->dwType != DA_TYPE_GENERAL && pItem->dwType != _TYPE_NEEDINIT )
		return FALSE;
	
	// if the item is being initialized now ... change the type
	if ( pItem->dwType == _TYPE_NEEDINIT )
		pItem->dwType = DA_TYPE_GENERAL;

	// set the value of the current item
	pItem->pValue = pValue;

	// return the result
	return TRUE;
}

//// ***************************************************************************
// Routine Description: 
//		This function  inserts an string variable into a 1-dimensional array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- position  .
//		[ in ] szValue			- string to be inserted.		
//		[ in ] dwLength			- length of the string to be insertes
//
// Return Value:  
//		TRUE : if successfully inserted the item into the array. 
//		FALSE : if Unsuccessfull .
//		
// ***************************************************************************

BOOL DynArraySetString( TARRAY pArray, DWORD dwIndex, LPCTSTR szValue, DWORD dwLength )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL )
		return FALSE;				// item not found / invalid array pointer
	
	// check the data type ... 
	if ( pItem->dwType != DA_TYPE_STRING && pItem->dwType != _TYPE_NEEDINIT )
		return FALSE;
	
	// determine the length of string ( memory ) that has to be allocated
	if ( dwLength == 0 )
		dwLength = lstrlen( szValue );

	// accomodate space for storing NULL character
	dwLength += 1;

	// memory has to adjusted based on the exisiting memory size and new contents size
	// before that, we need to check whether the current is initialized or not
	// if not yet initialized, we have to initialize it now
	if ( pItem->dwType == _TYPE_NEEDINIT )
	{
		// memory has to be initialized now
		pItem->pValue = __calloc( dwLength, sizeof( TCHAR ) );
		if ( pItem->pValue == NULL ) 
			return FALSE;		// failed in allocation

		// set the type and size information
		pItem->dwType = DA_TYPE_STRING;
		pItem->dwSize = dwLength * sizeof( TCHAR );
	}
	else if ( pItem->dwSize < dwLength * sizeof( TCHAR ) )
	{
		pItem->dwSize = dwLength * sizeof( TCHAR );
		pItem->pValue = realloc( pItem->pValue, pItem->dwSize );
		if ( pItem->pValue == NULL ) 
			return FALSE;		// failed in re-allocation
	}

	// copy the contents of the string ( copy should be based on the length )
	lstrcpyn( ( LPTSTR ) pItem->pValue, szValue, dwLength );

	// copied ... value set successfully
	return TRUE;
}

//// ***************************************************************************
// Routine Description: 
//		This function  inserts an long type variable into a 1-dimensional array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- position  .
//		[ in ] lValue			- long value to be inserted.		
//
// Return Value:  
//		TRUE : if successfully inserted the item into the array. 
//		FALSE : if Unsuccessfull .
//		
// ***************************************************************************

BOOL DynArraySetLong( TARRAY pArray, DWORD dwIndex, LONG lValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL )
		return FALSE;				// item not found / invalid array pointer
	
	// check the data type ... 
	if ( pItem->dwType != DA_TYPE_LONG && pItem->dwType != _TYPE_NEEDINIT )
		return FALSE;

	// if item is not yet allocated memory, we have to allocate now
	if ( pItem->dwType == _TYPE_NEEDINIT )
	{
		// allocate memory
		pItem->pValue = __calloc( 1, sizeof( LONG ) );
		if ( pItem->pValue == NULL )
			return FALSE;		// failed in memory allocation

		// set the type
		pItem->dwType = DA_TYPE_LONG;
		pItem->dwSize = sizeof( LONG );
	}

	// set the new value
	*( ( LONG* ) pItem->pValue ) = lValue;

	// copied ... value set successfully
	return TRUE;
}

//// ***************************************************************************
// Routine Description: 
//		This function  inserts an DWORD type variable into a 1-dimensional array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- position  .
//		[ in ] dwValue			- DWORD value to be inserted.		
//
//	Return Value:  
//		TRUE : if successfully inserted the item into the array. 
//		FALSE : if Unsuccessfull .
//		
// ***************************************************************************

BOOL DynArraySetDWORD( TARRAY pArray, DWORD dwIndex, DWORD dwValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL )
		return FALSE;				// item not found / invalid array pointer
	
	// check the data type ... 
	if ( pItem->dwType != DA_TYPE_DWORD && pItem->dwType != _TYPE_NEEDINIT )
		return FALSE;

	// if item is not yet allocated memory, we have to allocate now
	if ( pItem->dwType == _TYPE_NEEDINIT )
	{
		// allocate memory
		pItem->pValue = __calloc( 1, sizeof( DWORD ) );
		if ( pItem->pValue == NULL )
			return FALSE;		// failed in memory allocation

		// set the type
		pItem->dwType = DA_TYPE_DWORD;
		pItem->dwSize = sizeof( DWORD );
	}

	// set the new value
	*( ( DWORD* ) pItem->pValue ) = dwValue;

	// copied ... value set successfully
	return TRUE;
}

//// ***************************************************************************
// Routine Description: 
//		This function  inserts an BOOL type variable into a 1-dimensional  dynamic array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- position  .
//		[ in ] bValue			- BOOL value to be inserted.		
//
//	Return Value:  
//		TRUE : if successfully inserted the item into the array. 
//		FALSE : if Unsuccessfull .
//		
// ***************************************************************************

BOOL DynArraySetBOOL( TARRAY pArray, DWORD dwIndex, BOOL bValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL )
		return FALSE;				// item not found / invalid array pointer
	
	// check the data type ... 
	if ( pItem->dwType != DA_TYPE_BOOL && pItem->dwType != _TYPE_NEEDINIT )
		return FALSE;

	// if item is not yet allocated memory, we have to allocate now
	if ( pItem->dwType == _TYPE_NEEDINIT )
	{
		// allocate memory
		pItem->pValue = __calloc( 1, sizeof( BOOL ) );
		if ( pItem->pValue == NULL )
			return FALSE;		// failed in memory allocation

		// set the type
		pItem->dwType = DA_TYPE_BOOL;
		pItem->dwSize = sizeof( DWORD );
	}

	// set the new value
	*( ( BOOL* ) pItem->pValue ) = bValue;

	// copied ... value set successfully
	return TRUE;
}

//// ***************************************************************************
// Routine Description: 
//		This function  inserts an Float type variable into a 1-dimensional  dynamic array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- position  .
//		[ in ] fValue			-  float type value to be inserted.		
//
//	Return Value:  
//		TRUE : if successfully inserted the item into the array. 
//		FALSE : if Unsuccessfull .
//		
// ***************************************************************************

BOOL DynArraySetFloat( TARRAY pArray, DWORD dwIndex, float fValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL )
		return FALSE;				// item not found / invalid array pointer
	
	// check the data type ... 
	if ( pItem->dwType != DA_TYPE_FLOAT && pItem->dwType != _TYPE_NEEDINIT )
		return FALSE;

	// if item is not yet allocated memory, we have to allocate now
	if ( pItem->dwType == _TYPE_NEEDINIT )
	{
		// allocate memory
		pItem->pValue = __calloc( 1, sizeof( float ) );
		if ( pItem->pValue == NULL )
			return FALSE;		// failed in memory allocation

		// set the type
		pItem->dwType = DA_TYPE_FLOAT;
		pItem->dwSize = sizeof( float );
	}

	// set the new value
	*( ( float* ) pItem->pValue ) = fValue;

	// copied ... value set successfully
	return TRUE;
}

//// ***************************************************************************
// Routine Description: 
//		This function  inserts an double type variable into a 1-dimensional  dynamic array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- position  .
//		[ in ] dblValue			- double type value to be inserted.		
//
//	Return Value:  
//		TRUE : if successfully inserted the item into the array. 
//		FALSE : if Unsuccessfull .
//		
// ***************************************************************************

BOOL DynArraySetDouble( TARRAY pArray, DWORD dwIndex, double dblValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL )
		return FALSE;				// item not found / invalid array pointer
	
	// check the data type ... 
	if ( pItem->dwType != DA_TYPE_DOUBLE && pItem->dwType != _TYPE_NEEDINIT )
		return FALSE;

	// if item is not yet allocated memory, we have to allocate now
	if ( pItem->dwType == _TYPE_NEEDINIT )
	{
		// allocate memory
		pItem->pValue = __calloc( 1, sizeof( double ) );
		if ( pItem->pValue == NULL )
			return FALSE;		// failed in memory allocation

		// set the type
		pItem->dwType = DA_TYPE_BOOL;
		pItem->dwSize = sizeof( double );
	}

	// set the new value
	*( ( double* ) pItem->pValue ) = dblValue;

	// copied ... value set successfully
	return TRUE;
}

//// ***************************************************************************
// Routine Description: 
//		This function  inserts an Handle type variable into a 1-dimensional dynamic array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- position  .
//		[ in ] hValue			- Handle type value to be inserted.		
//
//	Return Value:  
//		TRUE : if successfully inserted the item into the array. 
//		FALSE : if Unsuccessfull .
//		
// ***************************************************************************

BOOL DynArraySetHandle( TARRAY pArray, DWORD dwIndex, HANDLE hValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL )
		return FALSE;				// item not found / invalid array pointer
	
	// check the data type ... 
	if ( pItem->dwType != DA_TYPE_HANDLE && pItem->dwType != _TYPE_NEEDINIT )
		return FALSE;

	// if item is not yet allocated memory, we have to allocate now
	if ( pItem->dwType == _TYPE_NEEDINIT )
	{
		// allocate memory
		pItem->pValue = __calloc( 1, sizeof( HANDLE ) );
		if ( pItem->pValue == NULL )
			return FALSE;		// failed in memory allocation

		// set the type
		pItem->dwType = DA_TYPE_HANDLE;
		pItem->dwSize = sizeof( HANDLE );
	}

	// set the new value
	*( ( HANDLE* ) pItem->pValue ) = hValue;

	// copied ... value set successfully
	return TRUE;
}

//// ***************************************************************************
// Routine Description: 
//		This function  inserts an SYSTEMTIME type variable into a 1-dimensional dynamic array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- position  .
//		[ in ] stValue			- SYSTEMTIME type value to be inserted.		
//
//	Return Value:  
//		TRUE : if successfully inserted the item into the array. 
//		FALSE : if Unsuccessfull .
//		
// ***************************************************************************

BOOL DynArraySetSystemTime( TARRAY pArray, DWORD dwIndex, SYSTEMTIME stValue )
{
	// local variables
	__PTITEM pItem = NULL;
	FILETIME ftTemp = { 0, 0 };		// dummy

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL )
		return FALSE;				// item not found / invalid array pointer
	
	// check the data type ... 
	if ( pItem->dwType != DA_TYPE_SYSTEMTIME && 
		 pItem->dwType != DA_TYPE_FILETIME && pItem->dwType != _TYPE_NEEDINIT )
	{
		return FALSE;
	}

	// if item is not yet allocated memory, we have to allocate now
	if ( pItem->dwType == _TYPE_NEEDINIT )
	{
		// allocate memory
		pItem->pValue = __calloc( 1, sizeof( SYSTEMTIME ) );
		if ( pItem->pValue == NULL )
			return FALSE;		// failed in memory allocation

		// set the type
		pItem->dwType = DA_TYPE_SYSTEMTIME;
		pItem->dwSize = sizeof( SYSTEMTIME );
	}
	
	// depending on the type set the value
	if ( pItem->dwType == DA_TYPE_FILETIME )
	{
		// do the needed conversions and then set
		SystemTimeToFileTime( &stValue, &ftTemp );
		*( ( FILETIME* ) pItem->pValue ) = ftTemp;
	}
	else
	{
		// set the new value as it is
		*( ( SYSTEMTIME* ) pItem->pValue ) = stValue;
	}

	// copied ... value set successfully
	return TRUE;
}

//// ***************************************************************************
// Routine Description: 
//		This function  inserts an FILETIME type variable into a 1-dimensional dynamic array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- position  .
//		[ in ] ftValue			- FILETIME type value to be inserted.		
//
//	Return Value:  
//		TRUE : if successfully inserted the item into the array. 
//		FALSE : if Unsuccessfull .
//		
// ***************************************************************************

BOOL DynArraySetFileTime( TARRAY pArray, DWORD dwIndex, FILETIME ftValue )
{
	// local variables
	__PTITEM pItem = NULL;
	SYSTEMTIME stTemp = { 0, 0, 0, 0, 0, 0 };			// dummy 

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL )
		return FALSE;				// item not found / invalid array pointer
	
	// check the data type ... 
	if ( pItem->dwType != DA_TYPE_FILETIME && 
		 pItem->dwType != DA_TYPE_SYSTEMTIME && pItem->dwType != _TYPE_NEEDINIT )
	{
		return FALSE;
	}

	// if item is not yet allocated memory, we have to allocate now
	if ( pItem->dwType == _TYPE_NEEDINIT )
	{
		// allocate memory
		pItem->pValue = __calloc( 1, sizeof( FILETIME ) );
		if ( pItem->pValue == NULL )
			return FALSE;		// failed in memory allocation

		// set the type
		pItem->dwType = DA_TYPE_FILETIME;
		pItem->dwSize = sizeof( FILETIME );
	}
	
	// depending on the type set the value
	if ( pItem->dwType == DA_TYPE_SYSTEMTIME )
	{
		// do the needed conversions and then set
		FileTimeToSystemTime( &ftValue, &stTemp );
		*( ( SYSTEMTIME* ) pItem->pValue ) = stTemp;
	}
	else
	{
		// set the new value as it is
		*( ( FILETIME* ) pItem->pValue ) = ftValue;
	}

	// copied ... value set successfully
	return TRUE;
}

//// ***************************************************************************
// Routine Description: 
//		This function is a general function to insert an variable into a 2-dimensional dynamic array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row position  .
//		[ in ] dwcolumn         - column at which the element is to be inserted.	
//		[ in ] pValue			- value to be inserted.		
//
//	Return Value:  
//		TRUE : if successfully inserted the item into the array. 
//		FALSE : if Unsuccessfull .
//		
// ***************************************************************************

BOOL DynArraySet2( TARRAY pArray, DWORD dwRow, DWORD dwColumn, LPVOID pValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return FALSE;	// no item exists at the specified row or item is not of type array

	// now add the value to the sub array and return the result to the caller
	return DynArraySet( pItem->pValue, dwColumn, pValue );
}

//// ***************************************************************************
// Routine Description: 
//		This function inserts a string variable into a 2-dimensional dynamic array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row position  .
//		[ in ] dwcolumn         - column at which the element is to be inserted.	
//		[ in ] szValue			- Pointer to the string	
//		[ in ] dwlength			- length of the string to be inserted
//
//	Return Value:  
//		TRUE : if successfully inserted the item into the array. 
//		FALSE : if Unsuccessfull .
//		
// ***************************************************************************

BOOL DynArraySetString2( TARRAY pArray, 
						 DWORD dwRow, DWORD dwColumn, LPCTSTR szValue, DWORD dwLength )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return FALSE;			// no item exists at the specified row or item is not of type array

	// now add the value to the sub array and return the result to the caller
	return DynArraySetString( pItem->pValue, dwColumn, szValue, dwLength );
}

//// ***************************************************************************
// Routine Description: 
//		This function inserts a Long variable into a 2-dimensional dynamic array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row position  .
//		[ in ] dwcolumn         - column at which the element is to be inserted.	
//		[ in ] lValue			- value to be inserted.
//	Return Value:  
//		TRUE : if successfully inserted the item into the array. 
//		FALSE : if Unsuccessfull .
//		
// ***************************************************************************

BOOL DynArraySetLong2( TARRAY pArray, DWORD dwRow, DWORD dwColumn, LONG lValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return FALSE;	// no item exists at the specified row or item is not of type array

	// now add the value to the sub array and return the result to the caller
	return DynArraySetLong( pItem->pValue, dwColumn, lValue );
}

//// ***************************************************************************
// Routine Description: 
//		This function inserts a DWORD variable into a 2-dimensional dynamic array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row position  .
//		[ in ] dwcolumn         - column at which the element is to be inserted.	
//		[ in ] dwValue			-  DWORD value to be inserted.
//	Return Value:  
//		TRUE : if successfully inserted the item into the array. 
//		FALSE : if Unsuccessfull .
//		
// ***************************************************************************

BOOL DynArraySetDWORD2( TARRAY pArray, DWORD dwRow, DWORD dwColumn, DWORD dwValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return FALSE;	// no item exists at the specified row or item is not of type array

	// now add the value to the sub array and return the result to the caller
	return DynArraySetDWORD( pItem->pValue, dwColumn, dwValue );
}

//// ***************************************************************************
// Routine Description: 
//		This function inserts a BOOL variable into a 2-dimensional dynamic array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row position  .
//		[ in ] dwcolumn         - column at which the element is to be inserted.	
//		[ in ] bValue			-  BOOL value to be inserted.
//	Return Value:  
//		TRUE : if successfully inserted the item into the array. 
//		FALSE : if Unsuccessfull .
//		
// ***************************************************************************

BOOL DynArraySetBOOL2( TARRAY pArray, DWORD dwRow, DWORD dwColumn, BOOL bValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return FALSE;	// no item exists at the specified row or item is not of type array

	// now add the value to the sub array and return the result to the caller
	return DynArraySetBOOL( pItem->pValue, dwColumn, bValue );
}



//// ***************************************************************************
// Routine Description: 
//		This function inserts a float variable into a 2-dimensional dynamic array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row position  .
//		[ in ] dwcolumn         - column at which the element is to be inserted.	
//		[ in ] fValue			-  float type value to be inserted.
//	Return Value:  
//		TRUE : if successfully inserted the item into the array. 
//		FALSE : if Unsuccessfull .
//		
// ***************************************************************************

BOOL DynArraySetFloat2( TARRAY pArray, DWORD dwRow, DWORD dwColumn, float fValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return FALSE;	// no item exists at the specified row or item is not of type array

	// now add the value to the sub array and return the result to the caller
	return DynArraySetFloat( pItem->pValue, dwColumn, fValue );
}

//// ***************************************************************************
// Routine Description: 
//		This function inserts a Double variable into a 2-dimensional dynamic array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row position  .
//		[ in ] dwcolumn         - column at which the element is to be inserted.	
//		[ in ] dblValue			-  Double type value to be inserted.
//	Return Value:  
//		TRUE : if successfully inserted the item into the array. 
//		FALSE : if Unsuccessfull .
//		
// ***************************************************************************

BOOL DynArraySetDouble2( TARRAY pArray, DWORD dwRow, DWORD dwColumn, double dblValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return FALSE;	// no item exists at the specified row or item is not of type array

	// now add the vale to the sub array and return the result to the caller
	return DynArraySetDouble( pItem->pValue, dwColumn, dblValue );
}

//// ***************************************************************************
// Routine Description: 
//		This function inserts a HANDLE variable into a 2-dimensional dynamic array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row position  .
//		[ in ] dwcolumn         - column at which the element is to be inserted.	
//		[ in ] hValue			-  HANDLE type value to be inserted.
//	Return Value:  
//		TRUE : if successfully inserted the item into the array. 
//		FALSE : if Unsuccessfull .
//		
// ***************************************************************************

BOOL DynArraySetHandle2( TARRAY pArray, DWORD dwRow, DWORD dwColumn, HANDLE hValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return FALSE;	// no item exists at the specified row or item is not of type array

	// now add the vale to the sub array and return the result to the caller
	return DynArraySetHandle( pItem->pValue, dwColumn, hValue );
}

//// ***************************************************************************
// Routine Description: 
//		This function inserts a FILETIME variable into a 2-dimensional dynamic array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row position  .
//		[ in ] dwcolumn         - column at which the element is to be inserted.	
//		[ in ] ftValue			- FILETIME type value to be inserted.
//	Return Value:  
//		TRUE : if successfully inserted the item into the array. 
//		FALSE : if Unsuccessfull .
//		
// ***************************************************************************

BOOL DynArraySetFileTime2( TARRAY pArray, DWORD dwRow, DWORD dwColumn, FILETIME ftValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return FALSE;	// no item exists at the specified row or item is not of type array

	// now add the vale to the sub array and return the result to the caller
	return DynArraySetFileTime( pItem->pValue, dwColumn, ftValue );
}

//// ***************************************************************************
// Routine Description: 
//		This function inserts a SYSTEMTIME variable into a 2-dimensional dynamic array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row position  .
//		[ in ] dwcolumn         - column at which the element is to be inserted.	
//		[ in ] stValue			- SYSTEMTIME type value to be inserted.
//	Return Value:  
//		TRUE : if successfully inserted the item into the array. 
//		FALSE : if Unsuccessfull .
//		
// ***************************************************************************

BOOL DynArraySetSystemTime2( TARRAY pArray, DWORD dwRow, DWORD dwColumn, SYSTEMTIME stValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return FALSE;	// no item exists at the specified row or item is not of type array

	// now add the vale to the sub array and return the result to the caller
	return DynArraySetSystemTime( pItem->pValue, dwColumn, stValue );
}


//// ***************************************************************************
// Routine Description: 
//		This function retreives the type of a element in a 1-dimensional dynamic array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- row position  .
//
//	Return Value:  
//		the type of array.
//		
//		
// ***************************************************************************
DWORD DynArrayGetItemType( TARRAY pArray, DWORD dwIndex )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL )
		return DA_TYPE_NONE;				// item not found / invalid array pointer

	// return the type of the array
	return pItem->dwType;
}

//// ***************************************************************************
// Routine Description: 
//		This function retreives the type of a element in a 2-dimensional dynamic array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row position  .
//		[ in ] dwColumn			- column position			
//
//	Return Value:  
//		the type of array.
//
//		
// ***************************************************************************

DWORD DynArrayGetItemType2( TARRAY pArray, DWORD dwRow, DWORD dwColumn )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return FALSE;	// no item exists at the specified row or item is not of type array

	// now add the vale to the sub array and return the result to the caller
	return DynArrayGetItemType( pItem->pValue, dwColumn );
}


//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the Long variable. 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] lValue			- the item to be searched. .
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindLong( TARRAY pArray, LONG lValue )
{
	// return the value
	return __DynArrayFind( pArray, DA_TYPE_LONG, &lValue, FALSE, 0 );
}

//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the DWORD variable. 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwValue			- value to be searched.

//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindDWORD( TARRAY pArray, DWORD dwValue )
{
	// return the value
	return __DynArrayFind( pArray, DA_TYPE_DWORD, &dwValue, FALSE, 0 );
}


//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the float variable. 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] fValue			- the item to be searched. .
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindFloat( TARRAY pArray, float fValue )
{
	// return the value
	return __DynArrayFind( pArray, DA_TYPE_FLOAT, &fValue, FALSE, 0 );
}

//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the double type variable. 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dblValue			- the item to be searched. .
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindDouble( TARRAY pArray, double dblValue )
{
	// return the value
	return __DynArrayFind( pArray, DA_TYPE_DOUBLE, &dblValue, FALSE, 0 );
}


//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the HANDLE type variable. 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] hValue			- the HANDLE type item to be searched. .
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindHandle( TARRAY pArray, HANDLE hValue )
{
	// return the value
	return __DynArrayFind( pArray, DA_TYPE_HANDLE, &hValue, FALSE, 0 );
}

//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the String type variable. 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		 
//		[ in ] szValue			- pointer to the string.
//		[ in ] bIgnoreCase		- boolean indicating if to perform case sensitive search or not.
//		[ in ] dwCount			- string length.	
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindString( TARRAY pArray, LPCTSTR szValue, BOOL bIgnoreCase, DWORD dwCount )
{
	// return the value
	return __DynArrayFind( pArray, DA_TYPE_STRING, ( LPVOID ) szValue, bIgnoreCase, dwCount );
}


//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the SYSTEMTIME type variable. 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] stValue			- the SYSTEMTIME item to be searched. .
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindSystemTime( TARRAY pArray, SYSTEMTIME stValue )
{
	// return the value
	return __DynArrayFind( pArray, DA_TYPE_SYSTEMTIME, &stValue, FALSE, 0 );
}


//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the FILETIME type variable. 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] ftValue			- the item of type FILETIME to be searched. .
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindFileTime( TARRAY pArray, FILETIME ftValue )
{
	// return the value
	return __DynArrayFind( pArray, DA_TYPE_FILETIME, &ftValue, FALSE, 0 );
}


//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the LONG type variable from a 2-d dynamic array. 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row 
//		[ in ] lValue			- the item of type LONG to be searched. .
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindLong2( TARRAY pArray, DWORD dwRow, LONG lValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// return the value
	return DynArrayFindLong( pItem->pValue, lValue );
}

//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the DWORD type variable from a 2-d dynamic array. 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row 
//		[ in ] dwValue			- the item of type DWORD to be searched. .
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindDWORD2( TARRAY pArray, DWORD dwRow, DWORD dwValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// return the value
	return DynArrayFindDWORD( pItem->pValue, dwValue );
}

//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the DWORD type variable from a 2-d dynamic array. 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row 
//		[ in ] szValue			- pointer to the string.
//		[ in ] bIgnoreCase		- boolean for case sensitive search.
//		[ in ] dwCount			- string length. .
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindString2( TARRAY pArray, DWORD dwRow, 
						  LPCTSTR szValue, BOOL bIgnoreCase, DWORD dwCount )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// return the value
	return DynArrayFindString( pItem->pValue, szValue, bIgnoreCase, dwCount );
}

//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the float type variable from a 2-d dynamic array. 
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row 
//		[ in ] fValue			- float value.
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindFloat2( TARRAY pArray, DWORD dwRow, float fValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// return the value
	return DynArrayFindFloat( pItem->pValue, fValue );
}

//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the double type variable from a 2-d array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row posn		
//		[ in ] dblValue			- the item to be searched. .
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindDouble2( TARRAY pArray, DWORD dwRow, double dblValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// return the value
	return DynArrayFindDouble( pItem->pValue, dblValue );
}

//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the HANDLE type variable from a 2-d array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row posn		
//		[ in ] hValue			- the HANDLE type item to be searched. .
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindHandle2( TARRAY pArray, DWORD dwRow, HANDLE hValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// return the value
	return DynArrayFindHandle( pItem->pValue, hValue );
}


//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the SYSTEMTIME type variable from a 2-d array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row posn		
//		[ in ] stValue			- the SYSTEMTIME type item to be searched. .
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindSystemTime2( TARRAY pArray, DWORD dwRow, SYSTEMTIME stValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// return the value
	return DynArrayFindSystemTime( pItem->pValue, stValue );
}


//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the FILETIME type variable from a 2-d array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row posn		
//		[ in ] ftValue			- the FILETIME type item to be searched. .
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindFileTime2( TARRAY pArray, DWORD dwRow, FILETIME ftValue )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// return the value
	return DynArrayFindFileTime( pItem->pValue, ftValue );
}

//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the LONG type variable from a 2-d array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwColumn			- column posn		
//		[ in ] lValue			- the LONG type item to be searched. .
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindLongEx( TARRAY pArray, DWORD dwColumn, LONG lValue )
{
	// return the value
	return __DynArrayFindEx( pArray, dwColumn, DA_TYPE_LONG, &lValue, FALSE, 0 );
}


//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the DWORD type variable from a 2-d array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwColumn			- column posn		
//		[ in ] dwValue			- the DWORD type item to be searched. .
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindDWORDEx( TARRAY pArray, DWORD dwColumn, DWORD dwValue )
{
	// return the value
	return __DynArrayFindEx( pArray, dwColumn, DA_TYPE_DWORD, &dwValue, FALSE, 0 );
}

//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the fValue type variable from a 2-d array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwColumn			- column posn		
//		[ in ] fValue			- the float type item to be searched. .
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindFloatEx( TARRAY pArray, DWORD dwColumn, float fValue )
{
	// return the value
	return __DynArrayFindEx( pArray, dwColumn, DA_TYPE_FLOAT, &fValue, FALSE, 0 );
}

//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the double type variable from a 2-d array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwColumn			- column posn		
//		[ in ] dblValue			- the double type item to be searched. .
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindDoubleEx( TARRAY pArray, DWORD dwColumn, double dblValue )
{
	// return the value
	return __DynArrayFindEx( pArray, dwColumn, DA_TYPE_DOUBLE, &dblValue, FALSE, 0 );
}


//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the HANDLE type variable from a 2-d array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwColumn			- column posn		
//		[ in ] hValue			- the HANDLE type item to be searched. .
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindHandleEx( TARRAY pArray, DWORD dwColumn, HANDLE hValue )
{
	// return the value
	return __DynArrayFindEx( pArray, dwColumn, DA_TYPE_HANDLE, &hValue, FALSE, 0 );
}

//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the SYSTEMTIME type variable from a 2-d array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwColumn			- column posn		
//		[ in ] stValue			- the SYSTEMTIME type item to be searched. .
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************
LONG DynArrayFindSystemTimeEx( TARRAY pArray, DWORD dwColumn, SYSTEMTIME stValue )
{
	// return the value
	return __DynArrayFindEx( pArray, dwColumn, DA_TYPE_SYSTEMTIME, &stValue, FALSE, 0 );
}

//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the FILETIME type variable from a 2-d array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwColumn			- column posn		
//		[ in ] ftValue			- the FILETIME type item to be searched. .
//
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindFileTimeEx( TARRAY pArray, DWORD dwColumn, FILETIME ftValue )
{
	// return the value
	return __DynArrayFindEx( pArray, dwColumn, DA_TYPE_FILETIME, &ftValue, FALSE, 0 );
}


//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the string type variable from a 2-d array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwColumn			- column posn		
//		[ in ] szValue			- pointer to the string
//		[ in ] bIgnorecase		- boolean for case sensitive search.
//		[ in ] dwCount			- string length
//
//	Return Value:  
//		the index of the element .
//
//		
// ***************************************************************************

LONG DynArrayFindStringEx( TARRAY pArray, DWORD dwColumn, 
						   LPCTSTR szValue, BOOL bIgnoreCase, DWORD dwCount )
{
	// return the value
	return __DynArrayFindEx( pArray, dwColumn, 
		DA_TYPE_STRING, (LPVOID) szValue, bIgnoreCase, dwCount );
}

//// ***************************************************************************
// Routine Description: 
//		This function returns the index of the FILETIME type variable from a 2-d array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] pArrItem			- Dynamic Array to be appended.		
//
//
//
//	Return Value:  
//		the pointer to the array.
//
//		
// ***************************************************************************

LONG DynArrayAppendEx( TARRAY pArray, TARRAY pArrItem )
{
	// validate the array
	if ( ! IsValidArray( pArray ) || ! IsValidArray( pArrItem ) )
		return -1;				// array is not valid

	// now add this sub array to the main array and return the result
	return __DynArrayAppend( pArray, DA_TYPE_ARRAY, sizeof( TARRAY ), pArrItem );
}

//// ***************************************************************************
// Routine Description: 
//		replaces  a element with an dynamic array.
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- Dynamic Array to be appended.		
//		[ in ] pArrItem			- pointer to the TARRAY.
//
//
//	Return Value:  
//		the pointer to the array..
//
//		
// ***************************************************************************

LONG DynArrayInsertEx( TARRAY pArray, DWORD dwIndex, TARRAY pArrItem )
{
	// validate the array
	if ( ! IsValidArray( pArray ) || ! IsValidArray( pArrItem ) )
		return -1;				// array is not valid

	// now insert this sub array to the main array and check the result
	return __DynArrayInsert( pArray, dwIndex, DA_TYPE_ARRAY, sizeof( TARRAY ), pArrItem );
}

//// ***************************************************************************
// Routine Description: 
//		inserts  a dynamic array at the specified posn..
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwIndex			- Dynamic Array to be appended.		
//		[ in ] pArrItem			- pointer to the TARRAY.
//
//
//	Return Value:  
//		the pointer to the array..
//
//		
// ***************************************************************************

BOOL DynArraySetEx( TARRAY pArray, DWORD dwIndex, TARRAY pArrItem )
{
	// local variables
	__PTITEM pItem = NULL;

	// validate the array
	if ( ! IsValidArray( pArray ) || ! IsValidArray( pArrItem ) )
		return FALSE;

	// get the item at the required index
	pItem = __DynArrayGetItem( pArray, dwIndex, NULL );
	if ( pItem == NULL )
		return FALSE;		// item not found / invalid array pointer
	
	// check the data type ... it should not be initialized yet or of array type
	if ( pItem->dwType != DA_TYPE_ARRAY && pItem->dwType != _TYPE_NEEDINIT )
		return FALSE;
	
	// set the value of the current item
	pItem->pValue = pArrItem;
	pItem->dwType = DA_TYPE_ARRAY;

	// return the result
	return TRUE;
}

//// ***************************************************************************
// Routine Description: 
//		appends  a dynamic array at the specified posn..
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row no		
//		[ in ] pArrItem			- pointer to the TARRAY.
//
//
//	Return Value:  
//		the pointer to the array..
//
//		
// ***************************************************************************
LONG DynArrayAppendEx2( TARRAY pArray, DWORD dwRow, TARRAY pArrItem )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// return the value
	return DynArrayAppendEx( pItem->pValue, pArrItem );
}


//// ***************************************************************************
// Routine Description: 
//		inserts  a dynamic array at the specified posn..
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row value
//		[ in ] dwColIndex		- column posn.
//		[ in ] pArrItem			- pointer to the TARRAY.
//
//
//	Return Value:  
//		the pointer to the array..
//
//		
// ***************************************************************************

LONG DynArrayInsertEx2( TARRAY pArray, DWORD dwRow, DWORD dwColIndex, TARRAY pArrItem )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// return the value
	return DynArrayInsertEx( pItem->pValue, dwColIndex, pArrItem );
}

//// ***************************************************************************
// Routine Description: 
//		creates  a dynamic array at the specified posn of the 2-d array
//		  
// Arguments: 
//		[ in ] pArray			- Dynamic Array 
//		[ in ] dwRow			- row position
//		[ in ] dwColIndex		- column posn.
//		[ in ] pArrItem			- pointer to the TARRAY.
//
//
//	Return Value:  
//		the pointer to the array..
//
//		
// ***************************************************************************

BOOL DynArraySetEx2( TARRAY pArray, DWORD dwRow, DWORD dwColumn, TARRAY pArrItem )
{
	// local variables
	__PTITEM pItem = NULL;

	// get the item at the required row
	pItem = __DynArrayGetItem( pArray, dwRow, NULL );
	if ( pItem == NULL || pItem->dwType != DA_TYPE_ARRAY )
		return -1;	// no item exists at the specified row or item is not of type array

	// return the value
	return DynArraySetEx( pItem->pValue, dwColumn, pArrItem );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\lib\pch.h ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//  
// 	  pch.h
//  
//  Abstract:
//  
// 	  This module is a precompiled header file for the common functionality
// 	
//  Author:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 1-Sep-2000
//  
//  Revision History:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 1-Sep-2000 : Created It.
//  
// *********************************************************************************


// pch.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#ifndef __PCH_H
#define __PCH_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef __cplusplus
extern "C" {
#endif

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

//
// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <Security.h>
#include <SecExt.h>

//
// public Windows header files
//
#include <windows.h>
#include <winsock2.h>
#include <lm.h>

//
// public C header files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <wchar.h>
#include <crtdbg.h>
#include <malloc.h>

#endif // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\lib\filterresults.c ===
/**********************************************************************************
 
 Copyright (c) Microsoft Corporation
 
 Module Name:
 
    FilterResults.c 
 
 Abstract:
 
 This modules  has functions which are  required to parse Command Line options.
 
 Author:
 
  G.V.N.Murali Sunil  
 
 Revision History:
 
   None 
 
 
 **********************************************************************************/

#include "pch.h"
#include "cmdline.h"

//
//  constants / definitions / enumerations
//

#define OPERATOR_DELIMITER		_T( "|" )
#define CHAR_ASTERISK			_T( '*' )

#define OPERATOR_EQ			_T( "=| eq " )
#define OPERATOR_NE			_T( "!=| ne " )
#define OPERATOR_GT			_T( ">| gt " )
#define OPERATOR_LT			_T( "<| lt " )
#define OPERATOR_GE			_T( ">=| ge " )
#define OPERATOR_LE			_T( "<=| le " )


//
// private user-defined types ... for internal usage only
//
typedef struct ___tagOperator
{
	DWORD dwMask;
	OPERATORS szOperator;
} TOPERATOR;

typedef TOPERATOR* PTOPERATOR;

//
// private functions ... used only within this file
//

/***************************************************************************
 Routine Description:

 Arguments:
     [ in ] dwCount:
     [ in ] optInfo[]:
     [ in ] szOperator:

  
 Return Value:

 
***************************************************************************/
DWORD __FindOperatorMask( DWORD dwCount, TOPERATOR optInfo[], LPCTSTR szOperator )
{
	// local variables
	DWORD dw = 0;	// looping variable

	// check the input value
	if ( optInfo == NULL || szOperator == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return 0;
	}

	// traverse thru the list of operators list
	for( dw = 0; dw < dwCount; dw++ )
	{
		// check whether the current operator information matches
		if ( InString( szOperator, optInfo[ dw ].szOperator, TRUE ) )
			return optInfo[ dw ].dwMask;		// operator matched ... return its mask
	}

	// operator not found
	return 0;
}

/***************************************************************************
 Routine Description:
    Compares Two Strings in two ways  with and without case sensitivily, 
		  
 Arguments:
  [ in ] szValue1 = First String
  [ in ] szValue2 = Second String
  [ in ] bIgnoreCase = Case Sensitivity or not
  [ in ] lCount = no. of characters to be compare

 
 Return Value:
  
     MASK_EQ - if both strings are equal
     MASK_LT - First string is less
     MASK_GT - Second String is less
***************************************************************************/
DWORD __StringCompare( LPCTSTR szValue1, LPCTSTR szValue2, BOOL bIgnoreCase, LONG lCount )
{
	// local variables
	LONG lResult = 0;			// hold the string comparision result

	// check the input value
	if ( szValue1 == NULL || szValue2 == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return 0;
	}

	// if the no. of characters that needs to checked is -1, just return
	if ( lCount == -1 )
		return MASK_ALL;		// that strings are equal

	// compare the two strings and get the result of comparision
	lResult = StringCompare( szValue1, szValue2, bIgnoreCase, lCount );

	//
	// now determine the result value
	if ( lResult == 0 )
		return MASK_EQ;
	else if ( lResult < 0 )
		return MASK_LT;
	else if ( lResult > 0 )
		return MASK_GT;

	// never come across this situation ... still
	return 0;
}

// ***************************************************************************
// Routine Description:
//	    compares two long data type values	  
//
// Arguments:
//      [ in ] lvalue1: First  value
//      [ in ] lvalue2: Second  Value
//
// Return Value:
//       MASK_EQ: both are equal
//       MASK_LT: First is less than second
//       MASK_GT: First is geater than second
// ***************************************************************************
DWORD __LongCompare( LONG lValue1, LONG lValue2 )
{
	//
	// determine the result value
	if ( lValue1 == lValue2 )
		return MASK_EQ;
	else if ( lValue1 < lValue2 )
		return MASK_LT;
	else if ( lValue1 > lValue2 )
		return MASK_GT;

	// never come across this situation ... still
	return 0;
}

// ***************************************************************************
// Routine Description:
//	    compares two DWORD data type values	  
//
// Arguments:
//      [ in ] dwValue1: First  value
//      [ in ] dwValue2: Second  Value
//
// Return Value:
//       MASK_EQ: both are equal
//       MASK_LT: First is less than second
//       MASK_GT: First is geater than second
// ***************************************************************************
DWORD __DWORDCompare( DWORD dwValue1, DWORD dwValue2 )
{
	//
	// determine the result value
	if ( dwValue1 == dwValue2 )
		return MASK_EQ;
	else if ( dwValue1 < dwValue2 )
		return MASK_LT;
	else if ( dwValue1 > dwValue2 )
		return MASK_GT;

	// never come across this situation ... still
	return 0;
}

// ***************************************************************************
// Routine Description:
//	    compares two float data type values	  
//
// Arguments:
//      [ in ] fValue1: First  value
//      [ in ] fValue2: Second  Value
//
// Return Value:
//       MASK_EQ: both are equal
//       MASK_LT: First is less than second
//       MASK_GT: First is geater than second
// ***************************************************************************
DWORD __FloatCompare( float fValue1, float fValue2 )
{
	//
	// determine the result value
	if ( fValue1 == fValue2 )
		return MASK_EQ;
	else if ( fValue1 < fValue2 )
		return MASK_LT;
	else if ( fValue1 > fValue2 )
		return MASK_GT;

	// never come across this situation ... still
	return 0;
}

// ***************************************************************************
// Routine Description:
//	    compares two double data type values	  
//
// Arguments:
//      [ in ] dblValue1: First  value
//      [ in ] dblValue2: Second  Value
//
// Return Value:
//       MASK_EQ: both are equal
//       MASK_LT: First is less than second
//       MASK_GT: First is geater than second
// ***************************************************************************
DWORD __DoubleCompare( double dblValue1, double dblValue2 )
{
	//
	// determine the result value
	if ( dblValue1 == dblValue2 )
		return MASK_EQ;
	else if ( dblValue1 < dblValue2 )
		return MASK_LT;
	else if ( dblValue1 > dblValue2 )
		return MASK_GT;

	// never come across this situation ... still
	return 0;
}

// ***************************************************************************
// Routine Description:
//	    compares two date  data type values	  
//
// Arguments:
//      [ in ] szValue1: First  value
//      [ in ] szValue2: Second  Value
//
// Return Value:
//       MASK_EQ: both are equal
//       MASK_LT: First is less than second
//       MASK_GT: First is geater than second
// ***************************************************************************
DWORD __DateCompare( LPCTSTR szValue1, LPCTSTR szValue2 )
{
	// check the input value
	if ( szValue1 == NULL || szValue2 == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return 0;
	}

	// never come across this situation ... still
	return 0;
}

// ***************************************************************************
// Routine Description:
//	    compares two time data type values	  
// Arguments:
//      szValue1: First  value
//      szValue2: Second  Value
// Return Value:
//       MASK_EQ: both are equal
//       MASK_LT: First is less than second
//       MASK_GT: First is geater than second
// ***************************************************************************
DWORD __TimeCompare( LPCTSTR szValue1, LPCTSTR szValue2 )
{
	// check the input value
	if ( szValue1 == NULL || szValue2 == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return 0;
	}

	// never come across this situation ... still
	return 0;
}

// ***************************************************************************
// Routine Description:
//	    compares two date+time  data type values	  
//
// Arguments:
//      [ in ] szValue1: First  value
//      [ in ] szValue2: Second  Value
//
// Return Value:
//       MASK_EQ: both are equal
//       MASK_LT: First is less than second
//       MASK_GT: First is geater than second
// ***************************************************************************
DWORD __DateTimeCompare( LPCTSTR szValue1, LPCTSTR szValue2 )
{
	// check the input value
	if ( szValue1 == NULL || szValue2 == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return 0;
	}

	// never come across this situation ... still
	return 0;
}

// ***************************************************************************
// Routine Description:
//	    compares value stored in arrRecords and arrFilter array depending on
//      filterConfig structure
//
// Arguments:
//      [ in ] arrRecord: First  value
//      [ in ] arrFilter: Second  Value
//      [ in ] filterConfig: Compare criteria. 
// Return Value:
//       MASK_EQ: both are equal
//       MASK_LT: First is less than second
//       MASK_GT: First is geater than second
// ***************************************************************************
DWORD __DoComparision( TARRAY arrRecord, TARRAY arrFilter, TFILTERCONFIG filter )
{
	// local variables
	LONG lLength = 0;					// used for pattern matched strings
	LPTSTR pszTemp = NULL;
	DWORD dwCompareResult = 0;
	__MAX_SIZE_STRING szValue = NULL_STRING;

	// variables used for comparision
	LPVOID pData = NULL;
	LONG lValue1 = 0, lValue2 = 0;
	DWORD dwValue1 = 0, dwValue2 = 0;
	float fValue1 = 0.0f, fValue2 = 0.0f;
	double dblValue1 = 0.0f, dblValue2 = 0.0f;
	LPCTSTR pszValue1 = NULL, pszValue2 = NULL;
	LPCTSTR pszProperty = NULL, pszOperator = NULL, pszValue = NULL;

	// check the input value
	if ( arrRecord == NULL || arrFilter == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return 0;
	}

	// do the comparision
	switch( filter.dwFlags & F_TYPE_MASK )
	{
	case F_TYPE_TEXT:
		{
			//
			// string comparision

			// get the value at the specified column and filter value
			pszValue1 = DynArrayItemAsString( arrRecord, filter.dwColumn );
			pszValue2 = DynArrayItemAsString( arrFilter, F_PARSED_INDEX_VALUE );

			// check the values we got from the dynamic array
			if ( pszValue1 == NULL || pszValue2 == NULL )
				return F_RESULT_REMOVE;

			// determine the length of the string that has to be compared
			lLength = 0;
			if ( filter.dwFlags & F_MODE_PATTERN )
			{
				// needs to do the pattern matching
				// identify till which part string should be compared
				lstrcpy( szValue, pszValue2 );
				pszTemp = _tcschr( szValue, CHAR_ASTERISK );
				if ( pszTemp != NULL )
				{
					lLength = lstrlen( szValue ) - lstrlen( pszTemp );

					// special case:
					// if the pattern is just asterisk, which means that all the
					// information needs to passed thru the filter
					if ( lLength == 0 )
						lLength = -1;		// match all values
				}
			}

			// do the comparision and get the result
			dwCompareResult = __StringCompare( pszValue1, pszValue2, TRUE, lLength );

			// break from the switch case
			break;
		}

	case F_TYPE_NUMERIC:
		{
			//
			// numeric comparision

			// get the value into buffer - PREFIX PURPOSE
			pszValue = DynArrayItemAsString( arrFilter, F_PARSED_INDEX_VALUE );
			if ( pszValue == NULL )
				return 0;

			// get the value at the specified column and filter value
			lValue1 = DynArrayItemAsLong( arrRecord, filter.dwColumn );
			lValue2 = AsLong( pszValue, 10 );

			// do the comparision and get the result
			dwCompareResult = __LongCompare( lValue1, lValue2 );

			// break from the switch case
			break;
		}

	case F_TYPE_UNUMERIC:
		{
			//
			// unsigned numeric comparision

			// get the value into buffer - PREFIX PURPOSE
			pszValue = DynArrayItemAsString( arrFilter, F_PARSED_INDEX_VALUE );
			if ( pszValue == NULL )
				return 0;

			// get the value at the specified column and filter value
			dwValue1 = DynArrayItemAsLong( arrRecord, filter.dwColumn );
			dwValue2 = (DWORD) AsLong( pszValue, 10 );

			// do the comparision and get the result
			dwCompareResult = __DWORDCompare( dwValue1, dwValue2 );

			// break from the switch case
			break;
		}

	case F_TYPE_DATE:
	case F_TYPE_TIME:
	case F_TYPE_DATETIME:
		{
			// not yet implemented
			dwCompareResult = F_RESULT_KEEP;

			// break from the switch case
			break;
		}

	case F_TYPE_FLOAT:
		{
			//
			// float comparision

			// get the value into buffer - PREFIX PURPOSE
			pszValue = DynArrayItemAsString( arrFilter, F_PARSED_INDEX_VALUE );
			if ( pszValue == NULL )
				return 0;

			// get the value at the specified column and filter value
			fValue1 = DynArrayItemAsFloat( arrRecord, filter.dwColumn );
			fValue2 = (float) AsFloat( pszValue );

			// do the comparision and get the result
			dwCompareResult = __FloatCompare( fValue1, fValue2 );

			// break from the switch case
			break;
		}

	case F_TYPE_DOUBLE:
		{
			//
			// double comparision

			// get the value into buffer - PREFIX PURPOSE
			pszValue = DynArrayItemAsString( arrFilter, F_PARSED_INDEX_VALUE );
			if ( pszValue == NULL )
				return 0;

			// get the value at the specified column and filter value
			dblValue1 = DynArrayItemAsDouble( arrRecord, filter.dwColumn );
			dblValue2 = AsFloat( pszValue );

			// do the comparision and get the result
			dwCompareResult = __DoubleCompare( dblValue1, dblValue2 );

			// break from the switch case
			break;
		}

	case F_TYPE_CUSTOM:
		{
			//
			// custom comparision

			// get the filter values
			pszProperty = DynArrayItemAsString( arrFilter, F_PARSED_INDEX_PROPERTY );
			pszOperator = DynArrayItemAsString( arrFilter, F_PARSED_INDEX_OPERATOR );
			pszValue = DynArrayItemAsString( arrFilter, F_PARSED_INDEX_VALUE );

			// check ...
			if ( pszProperty == NULL || pszOperator == NULL || pszValue == NULL )
				return 0;
		
			// call the custom function
			dwCompareResult = (filter.pFunction)( pszProperty, pszOperator, pszValue, 
				filter.pFunctionData == NULL ? &filter : filter.pFunctionData, arrRecord );

			// break from the switch case
			break;
		}

	default:
		{
			// not yet implemented
			dwCompareResult = F_RESULT_KEEP;

			// break from the switch case
			break;
		}
	}

	// return the result
	return dwCompareResult;
}

// ***************************************************************************
// Routine Description:
//	    compares two arrays
//
// Arguments:
//      [ in ] arrRecord: First  Value
//      [ in ] arrFilter: Second  Value
//      [ in ] filterConfig: Comperison Criteria   
//
// Return Value:
//       MASK_EQ: both are equal
//       MASK_LT: First is less than second
//       MASK_GT: First is geater than second
// ***************************************************************************
DWORD __DoArrayComparision( TARRAY arrRecord, TARRAY arrFilter, TFILTERCONFIG filterConfig )
{
	// local variables
	LONG lIndex = 0;
	LONG lLength = 0;					// used for pattern matched strings
	DWORD dwCompareResult = 0;
	LPCTSTR pszTemp = NULL;
	__MAX_SIZE_STRING szValue = NULL_STRING;

	// variables used for comparision
	TARRAY arrValues = NULL;
	LPCTSTR pszFilterValue = NULL;

	// check the input value
	if ( arrRecord == NULL || arrFilter == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return F_RESULT_REMOVE;
	}

	// array data in the record
	arrValues = DynArrayItem( arrRecord, filterConfig.dwColumn );
	if ( arrValues == NULL )
		return F_RESULT_REMOVE;

	switch( filterConfig.dwFlags & F_TYPE_MASK )
	{
	case F_TYPE_TEXT:
		{
			//
			// string comparision

			// get the value at the specified column and filter value
			pszFilterValue = DynArrayItemAsString( arrFilter, F_PARSED_INDEX_VALUE );
			if ( pszFilterValue == NULL )
				return F_RESULT_REMOVE;

			// determine the length of the string that has to be compared
			lLength = 0;
			if ( filterConfig.dwFlags & F_MODE_PATTERN )
			{
				// needs to do the pattern matching
				// identify till which part string should be compared
				lstrcpy( szValue, pszFilterValue );
				pszTemp = _tcschr( szValue, CHAR_ASTERISK );
				if ( pszTemp != NULL )
				{
					lLength = lstrlen( szValue ) - lstrlen( pszTemp );

					// special case:
					// if the pattern is just asterisk, which means that all the
					// information needs to passed thru the filter
					if ( lLength == 0 )
						lLength = -1;		// match all values
				}
			}

			// do the comparision and get the result
			if ( lLength == -1 )
			{
				// filter has to be passed
				dwCompareResult = MASK_ALL;
			}
			else
			{
				// find the string in the array and check the result
				lIndex = DynArrayFindString( arrValues, pszFilterValue, TRUE, lLength );
				if ( lIndex == -1 )
				{
					// value not found
					dwCompareResult = MASK_NE;
				}
				else
				{
					pszTemp = DynArrayItemAsString( arrValues, lIndex );
					if ( pszTemp == NULL )
						return F_RESULT_REMOVE;

					// comparision ...
					dwCompareResult = __StringCompare(pszTemp, pszFilterValue, TRUE, lLength);
				}
			}

			// break from the switch case
			break;
		}
	}

	// return the result
	return dwCompareResult;
}

// ***************************************************************************
// Routine Description:
//    Prepares a two dimensional array(arrOperators)based on Operator information 
//    supplied with pfilterConfigs variable
//    
//		  
// Arguments:
//      [ in]  dwCount          =  No. of operatores
//      [ in]  pfilterConfigs   =  Pointer to TFILTERCONFIG structure
//      [out]  arrOperators     =  Array of operators. 
//
// Return Value:
//      NONE
//
// ***************************************************************************
VOID __PrepareOperators( DWORD dwCount, PTFILTERCONFIG pfilterConfigs, TARRAY arrOperators )
{
	// local variables
	DWORD i = 0;							// looping varible
	LONG lIndex = 0;						// holds the result of find operation
	LPTSTR pszOperator = NULL;				// operator specified in filter
	PTFILTERCONFIG pFilter = NULL;			// temporary filter configuration
	__MAX_SIZE_STRING szTemp = NULL_STRING;	// temporary string buffer

	// check the input value
	if ( pfilterConfigs == NULL || arrOperators == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return;
	}

	// NOTE:- Here in this logic, we are compromising on the memory Vs time
	//        At the cost of using more memory, the time taken by the validating
	//		  functionality is improved.
	//

	// collect all the operators that are supported and save them in the local array
	// Idea:-
	//		=> This is a two-dimensional array
	//		=> In all rows, the first column will have the operator
	//		=> operator column is followed by the index of the filter property supporting
	//		   this operator, and this column is followed by filter property name
	//		=> This filter property index and its name's can be any number
	//		=> The operator is being treated as key field in the array
	//
	// SAMPLE:
	//		0		1	2			3	4			5	6
	//		-------------------------------------------------------------------
	//		=		1	property1	2	property2
	//		!=		0	property0	2	property2
	//		<=		0	property0	3	property3
	//		>=		1	property1	3	property3	4	property4
	//
	for( i = 0; i < dwCount; i++ )
	{
		// get the filter info at the specified index into local memory
		pFilter = pfilterConfigs + i;

		// collect operators and prepare with all the available operators
		lstrcpy( szTemp, pFilter->szOperators );				// IMP. get the local copy.
		pszOperator = _tcstok( szTemp, OPERATOR_DELIMITER );	// get the first token
		while ( pszOperator != NULL )
		{
			// check whether this operator exists in the operators array
			lIndex = DynArrayFindStringEx( arrOperators, 0, pszOperator, TRUE, 0 );
			if ( lIndex == -1 )
			{
				//
				// operator is not in the list
				
				// add the new operator to the list and set the index to the row added
				// for this operator
				lIndex = DynArrayAppendRow( arrOperators, 0 );
				if ( lIndex == -1 )
					return;
				
				// now add the operator as the first column to the newly added row
				DynArrayAppendString2( arrOperators, lIndex, pszOperator, 0 );
			}

			// add the filter property info and its index to the operator row
			DynArrayAppendLong2( arrOperators, lIndex, i );
			DynArrayAppendString2( arrOperators, lIndex, pFilter->szProperty, 0 );

			// fetch the next token
			pszOperator = _tcstok( NULL, OPERATOR_DELIMITER );
		}
	}
}

// ***************************************************************************
// Routine Description:
//	    Checks the type of pszValue string for the criteria given by fcInfo
//      filters.  
	  
// Arguments:
//      [ in ]  fcInfo =   filter stucture.
//      [ in ]  pszProperty = property string
//      [ in ]  pszOperator = operator
//      [ in ]  pszValue = string to be checked      
//
// Return Value:
//       TRUE =   valid line
//       FALSE =  not a valid line
// ***************************************************************************
BOOL __CheckValue( TFILTERCONFIG fcInfo, 
				   LPCTSTR pszProperty, LPCTSTR pszOperator, LPCTSTR pszValue )
{
	// local variables
	DWORD dwResult = 0;
	LPTSTR pszTemp = NULL;
	__MAX_SIZE_STRING szValue = NULL_STRING;

	// check the input value
	if ( pszProperty == NULL || pszOperator == NULL || pszValue == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return FALSE;
	}

	// check the length of the value string ... it should not be empty
	if ( lstrlen( pszValue ) == 0 )
		return FALSE;		// value string is empty

	// start validating the data
	switch( fcInfo.dwFlags & F_TYPE_MASK )
	{
	case F_TYPE_TEXT:
		{
			// check if the pattern is supported
			// if supported, see the '*' is appearing only at the end. if not error
			if ( fcInfo.dwFlags & F_MODE_PATTERN )
			{
				// copy the current value to the local buffer
				lstrcpy( szValue, pszValue );

				// search for the wild card character
				pszTemp = _tcschr( szValue, CHAR_ASTERISK );

				// if the wild card character was found and if it is not the last character
				// (or) wild card is the only character specified, then invalid filter
				if ( pszTemp != NULL && ( lstrlen( pszTemp ) != 1 || pszTemp == szValue ) )
					return FALSE;		// error ... invalid pattern string
			}

			// for all these types, no need to do any special checking
			// provided, they need not be checked with the list of values
			if ( ! ( fcInfo.dwFlags & F_MODE_VALUES ) )
				return TRUE;			// no special validation

			// check for the value in the list and return the result
			return ( InString( pszValue, fcInfo.szValues, TRUE ) );

			// break from the switch
			break;
		}

	case F_TYPE_NUMERIC:
		{
			// if the value is not of numeric type, invalid value
			if ( ! IsNumeric( pszValue, 10, TRUE ) )
				return FALSE;

			// check for the value in the list and return the result
			// if values are pre-defined
			if ( fcInfo.dwFlags & F_MODE_VALUES )
				return ( InString( fcInfo.szValues, pszValue, TRUE ) );

			// value is valid
			return TRUE;

			// break from the switch
			break;
		}

	case F_TYPE_UNUMERIC:
		{
			// if the value is not of unsigned numeric type, invalid value
			if ( ! IsNumeric( pszValue, 10, FALSE ) )
				return FALSE;

			// check for the value in the list and return the result
			// if values are pre-defined
			if ( fcInfo.dwFlags & F_MODE_VALUES )
				return ( InString( fcInfo.szValues, pszValue, TRUE ) );

			// value is valid
			return TRUE;

			// break from the switch
			break;
		}

	case F_TYPE_FLOAT:
	case F_TYPE_DOUBLE:
		{
			// NOTE: Values attribute is ignored for this data type

			// return the result of the type validation function itself
			return ( IsFloatingPoint( pszValue ) );

			// break from the switch
			break;
		}

	case F_TYPE_DATE:
	case F_TYPE_TIME:
	case F_TYPE_DATETIME:
		{
			// break from the switch
			break;
		}

	case F_TYPE_CUSTOM:
		{
			// check whether function pointer is specified or not
			// if not specified, error
			if ( fcInfo.pFunction == NULL )
				return FALSE;		// function ptr not specified ... error

			// call the custom function
			dwResult = (*fcInfo.pFunction)( pszProperty, pszOperator, pszValue,
				fcInfo.pFunctionData == NULL ? &fcInfo : fcInfo.pFunctionData, NULL );

			// check the result and return appropriately
			if ( dwResult == F_FILTER_INVALID )
				return FALSE;
			else
				return TRUE;

			// break from the switch
			break;
		}

	default:
		{
			// invalid configuration information
			return FALSE;

			// break from the switch
			break;
		}
	}

	// not a valid value
	return FALSE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//      [ in] szFilter = filter
//      [  in ] arrOperators = Array of Operators
//      [  in ] pfilterConfigs = filter configurations 
//      [ in  ] pszProperty =property
//      [ in  ] pszOperator = operator
//      [  in ] pszValue - value
//
// Return Value: Returns a long value
// 
// ***************************************************************************
LONG __IdentifyFilterConfig( LPCTSTR szFilter, 
							 TARRAY arrOperators, 
							 PTFILTERCONFIG pfilterConfigs,
							 LPTSTR pszProperty, LPTSTR pszOperator, LPTSTR pszValue )
{
	// local variables
	DWORD dw = 0;							// looping variable
	LONG lPosition = 0;						// used to result of 'find' function
	LONG lIndex = 0;
	DWORD dwOperators = 0;					// holds the count of operators supported
	LPTSTR pszBuffer = NULL;
	__MAX_SIZE_STRING szTemp = NULL_STRING;	// temporary string buffer
	__MAX_SIZE_STRING szFmtFilter = NULL_STRING;
	__MAX_SIZE_STRING szFmtOperator = NULL_STRING;

	// check the input value
	if ( szFilter == NULL || arrOperators == NULL || pfilterConfigs == NULL || 
		 pszProperty == NULL || pszOperator == NULL || pszValue == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return -1;
	}

	// get the filter info into local format buffer and change the case
	lstrcpy( szFmtFilter, szFilter );
	CharUpper( szFmtFilter );

	// initially assume the filter is unknown and set the message
	SetLastError( ERROR_DS_FILTER_UNKNOWN );
	SaveLastError();

	// traverse thru the list of operators available and check
	// whether the filter is having any of the supported operator
	dwOperators = DynArrayGetCount( arrOperators );		// no. of operators supported
	for( dw = 0; dw < dwOperators; dw++ )
	{
		// get the operator
		pszBuffer = ( LPTSTR ) DynArrayItemAsString2( arrOperators, dw, 0 );
		if ( pszBuffer == NULL )
		{
			SetLastError( EVENT_E_INTERNALERROR );
			SaveLastError();
			return -1;
		}

		// ...
		lstrcpy( pszOperator, pszBuffer );
		lstrcpy( szFmtOperator, pszOperator );		// also get the operator
		CharUpper( szFmtOperator );					// into format buffer and chane the case

		// search for the current operator in the filter
		// check whether the operator was found or not
		// before processing, copy to the temp buffer and do manipulations on that
		lstrcpy( szTemp, szFmtFilter );
		if ( ( pszBuffer = _tcsstr( szTemp, szFmtOperator ) ) != NULL )
		{
			//
			// operator was found

			// extract the property, and value information
			// => property name 
			//    ( total length of the string -  position where the operator starts )
			// => value
			//    ( start position of operator + length of operator )
			szTemp[ lstrlen( szTemp ) - lstrlen( pszBuffer ) ] = NULL_CHAR;
			lstrcpy( pszProperty, szTemp );

			// value might not have specified at all ... so be careful
			if ( (pszBuffer + lstrlen(pszOperator)) != NULL )
			{
				// copy the value part
				lstrcpy( pszValue, (pszBuffer + lstrlen(pszOperator)) );

				//
				// now cross-check whether the property name exists or not for the current
				// operator.
				
				// remove the leading and trailing spaces ( if any ) 
				// in the property name and value
				lstrcpy( pszValue, TrimString( pszValue, TRIM_ALL ) );
				lstrcpy( pszProperty, TrimString( pszProperty, TRIM_ALL ) );

				// check whether this property exists or not
				// if found, return to the caller, else continue furthur
				// this might match with some with some other operator
				lPosition = DynArrayFindString2( arrOperators, dw, pszProperty, TRUE, 0 );
				if ( lPosition > 1 )
				{
					// NOTE:
					// we know that the property name if exist, starts from index number 
					// 2 only that is the reason why, the condition is > 1 is only valid

					// get the corresponding filter config. info
					lIndex = DynArrayItemAsLong2( arrOperators, dw, lPosition - 1 );

					// now check whether the filter is having appropriate value
					if ( __CheckValue( pfilterConfigs[ lIndex ], pszProperty, pszOperator, pszValue) )
					{
						//
						// filter is having valid value
						SetLastError( NOERROR );
						SetReason( NULL_STRING );

						// return the filter configuration index
						return lIndex;
					}
				}
			}
		}
	}

	// filter is not valid
	return -1;
}

//
// public functions ... exposed to external world
//

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//      [ in ] dwCount = Count
//      [ in ] pfilterConfigs = filter configurations
//      [ in ] arrFilterArgs = filter arguments
//      [ in ] parrParsedFilters = array of parsed filters
//  
// Return Value:return a boolean value
// 
// ***************************************************************************
BOOL ParseAndValidateFilter( DWORD dwCount,
							 PTFILTERCONFIG pfilterConfigs,
							 TARRAY arrFilterArgs, PTARRAY parrParsedFilters )
{
	// local variables
	DWORD dw = 0;								// looping variables
	DWORD dwFilters = 0;						// holds the count of filters
	LONG lIndex = 0;							// index variable
	LONG lNewIndex = 0;							// index variable
	BOOL bResult = FALSE;						// holds the result of the filter validation
	__MAX_SIZE_STRING szValue = NULL_STRING;	// value specified in filter
	__MAX_SIZE_STRING szOperator = NULL_STRING;	// operator specified in filter
	__MAX_SIZE_STRING szProperty = NULL_STRING;	// property specified in filter
	LPCTSTR pszFilter = NULL;
	TARRAY arrOperators = NULL;					// operator-wise filter configuration

	// check the input value
	if ( pfilterConfigs == NULL || arrFilterArgs == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return FALSE;
	}

	//
	// parse the filter configuration information and customize the information
	// to fasten the performance of the validating functionality
	//
	// create the dynamic array and prepare
	arrOperators = CreateDynamicArray();
	if ( arrOperators == NULL )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// ...
	__PrepareOperators( dwCount, pfilterConfigs, arrOperators );

	// check whether filters ( parsed ) needs to initialized
	if ( parrParsedFilters != NULL && *parrParsedFilters == NULL )
	{
		*parrParsedFilters = CreateDynamicArray();		// create a dynamic array
		if ( *parrParsedFilters == NULL )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return FALSE;
		}
	}

	//
	// now start validating the filter
	//

	// traverse through the filters information and validate them
	bResult = TRUE;			// assume that filter validation is passed
	dwFilters = DynArrayGetCount( arrFilterArgs );		// count of filter specified
	for( dw = 0; dw < dwFilters; dw++ )
	{
		// reset all the needed variables
		lstrcpy( szValue, NULL_STRING );
		lstrcpy( szOperator, NULL_STRING );
		lstrcpy( szProperty, NULL_STRING );

		// get the filter
		pszFilter = DynArrayItemAsString( arrFilterArgs, dw );
		if ( pszFilter == NULL )
		{
			// error occured
			bResult = FALSE;
			break;				// break from the loop ... no need of furthur processing
		}

		// identify the filter config for the current filter
		lIndex = __IdentifyFilterConfig( pszFilter, 
			arrOperators, pfilterConfigs, szProperty, szOperator, szValue );

		// check whether the filter is found or not
		if ( lIndex == -1 )
		{
			// filter found to be invalid
			bResult = FALSE;
			break;				// break from the loop ... no need of furthur processing
		}

		// now that we found, current filter is having
		// valid property name, operator and valid value
		// save the parsed filter info and its corresponding filter configuration index
		// in global dynamic array if it is available
		if ( parrParsedFilters != NULL )
		{
			// append the filter info at the end of the array
			lNewIndex = DynArrayAppendRow( *parrParsedFilters, F_PARSED_INFO_COUNT );
			if ( lNewIndex == -1 )
			{
				SetLastError( E_OUTOFMEMORY );
				SaveLastError();
				return FALSE;
			}

			// ...
			DynArraySetDWORD2( *parrParsedFilters, lNewIndex, F_PARSED_INDEX_FILTER, lIndex );
			DynArraySetString2( *parrParsedFilters, lNewIndex, F_PARSED_INDEX_PROPERTY, szProperty, 0 );
			DynArraySetString2( *parrParsedFilters, lNewIndex, F_PARSED_INDEX_OPERATOR, szOperator, 0 );
			DynArraySetString2( *parrParsedFilters, lNewIndex, F_PARSED_INDEX_VALUE, szValue, 0 );
		}
	}

	// destroy the operators array
	DestroyDynamicArray( &arrOperators );

	// return the filter validation result
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//      [ in ] dwCount = count
//      [ in ] filterConfigs[] = filter configurations 
//      [ in ] arrRecord = array of records
//  
//      [   ]arrParsedFilters = array of parsed filters
// Return Value:return a boolean value
// 
// ***************************************************************************
BOOL CanFilterRecord( DWORD dwCount, 
				      TFILTERCONFIG filterConfigs[],
				      TARRAY arrRecord, TARRAY arrParsedFilters )
{
	// local variables
	DWORD dw = 0;					// looping variables
	DWORD dwFilters = 0;			// holds the total no. of filter available
	DWORD dwOperator = 0;			// holds the mask of the current filter
	DWORD dwFilterIndex = 0;
	DWORD dwCompareResult = 0;		// holds the result of comparision
	LPCTSTR pszTemp = NULL;
	TARRAY arrTemp = NULL;

	// prepare the operators mappings
	DWORD dwOperatorsCount = 0;
	TOPERATOR operators[] = {
		{ MASK_EQ, OPERATOR_EQ },
		{ MASK_NE, OPERATOR_NE },
		{ MASK_GT, OPERATOR_GT },
		{ MASK_LT, OPERATOR_LT },
		{ MASK_GE, OPERATOR_GE },
		{ MASK_LE, OPERATOR_LE }
	};

	// check the input value
	if ( filterConfigs == NULL || arrRecord == NULL || arrParsedFilters == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return FALSE;
	}

	// traverse thru all the filters
	dwFilters = DynArrayGetCount( arrParsedFilters );
	dwOperatorsCount = sizeof( operators ) / sizeof( operators[ 0 ] );
	for( dw = 0; dw < dwFilters; dw++ )
	{
		// get the current filter configuration index
		dwFilterIndex = DynArrayItemAsDWORD2( arrParsedFilters, dw, F_PARSED_INDEX_FILTER );

		// get the appropriate operator mask
		pszTemp = DynArrayItemAsString2( arrParsedFilters, dw, F_PARSED_INDEX_OPERATOR );
		if ( pszTemp == NULL )
			continue;

		// ...
		dwOperator = __FindOperatorMask( dwOperatorsCount, operators, pszTemp );

		// if the operator is undefined, the filter should have 
		// custom validation mask
		if ( dwOperator == 0 && 
			  ( filterConfigs[ dwFilterIndex ].dwFlags & F_TYPE_MASK ) != F_TYPE_CUSTOM )
			return FALSE;		// invalid filter configuration

		// get the parsed filter info into local buffer
		arrTemp = DynArrayItem( arrParsedFilters, dw );
		if ( arrTemp == NULL )
			return FALSE;
		
		// do the comparision and get the result
		if ( filterConfigs[ dwFilterIndex ].dwFlags & F_MODE_ARRAY )
		{
			dwCompareResult = __DoArrayComparision( 
				arrRecord, arrTemp, filterConfigs[ dwFilterIndex ] );
		}
		else
		{
			dwCompareResult = __DoComparision( arrRecord, arrTemp, filterConfigs[ dwFilterIndex ] );
		}

		// now check whether the current can be kept or not
		// if the filter is failed, break from the loop so that this row can be deleted
		if ( ( dwCompareResult & dwOperator ) == 0 )
			break;		// filter failed
	}

	// return the result of filter operation
	return ( dw != dwFilters );		// TRUE : delete record, FALSE : keep record
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//      [ in ] dwCount = count 
//      [ in ] filterConfigs[] = filter configurations
//      [ in ] arrData = array of data
//      [ in ] arrParsedFilters = array of parsed filters
//  
// Return Value: Return a DWord
// 
// ***************************************************************************
DWORD FilterResults( DWORD dwCount, 
					 TFILTERCONFIG filterConfigs[],
				     TARRAY arrData, TARRAY arrParsedFilters )
{
	// local variables
	DWORD dw = 0;					// looping variables
	DWORD dwDeleted = 0;
	DWORD dwRecords = 0;			// holds the total no. of records
	LPCTSTR szTemp = NULL;
	TARRAY arrRecord = NULL;

	// check the input value
	if ( filterConfigs == NULL || arrData == NULL || arrParsedFilters == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return 0;
	}	

	//
	// start filtering the data

	// get the count of filters and records
	dwRecords = DynArrayGetCount( arrData );

	// traverse thru all thru the data
	for( dw = 0; dw < dwRecords; dw++ )
	{
		// get the current row ... this is just to increase fastness
		arrRecord = DynArrayItem( arrData, dw );
		if ( arrRecord == NULL )
		{
			SetLastError( ERROR_INVALID_PARAMETER );
			SaveLastError();
			return 0;
		}

		// check whether this record needs to be deleted or not
		if ( CanFilterRecord( dwCount, filterConfigs, arrRecord, arrParsedFilters ) )
		{
			DynArrayRemove( arrData, dw );	// delete record
			dw--;				// adjust the next record position
			dwRecords--;		// also adjust the total no. of records information
			dwDeleted++;
		}
	}

	// return no. of records deleted
	return dwDeleted;
}

// ***************************************************************************
// Routine Description:
//		retuns the mathematical operator from english operator
//		  
// Arguments:
//      [ in ] szOperator = mathematical (or) english operator
//  
// Return Value: 
//		Return a mathematical operator
// 
// ***************************************************************************
LPCTSTR FindOperator( LPCTSTR szOperator )
{
	// local variables
	DWORD dwMask = 0;
	DWORD dwOperatorsCount = 0;
	TOPERATOR operators[] = {
		{ MASK_EQ, OPERATOR_EQ },
		{ MASK_NE, OPERATOR_NE },
		{ MASK_GT, OPERATOR_GT },
		{ MASK_LT, OPERATOR_LT },
		{ MASK_GE, OPERATOR_GE },
		{ MASK_LE, OPERATOR_LE }
	};

	// check the input value
	if ( szOperator == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return MATH_EQ;
	}

	// find the operator mask
	dwOperatorsCount = sizeof( operators ) / sizeof( operators[ 0 ] );
	dwMask = __FindOperatorMask( dwOperatorsCount, operators, szOperator );
	switch ( dwMask )
	{
	case MASK_EQ:
		return MATH_EQ;
		break;

	case MASK_NE:
		return MATH_NE;
		break;

	case MASK_LT:
		return MATH_LT;
		break;

	case MASK_GT:
		return MATH_GT;
		break;

	case MASK_LE:
		return MATH_LE;
		break;

	case MASK_GE:
		return MATH_GE;
		break;

	default:
		// default to be on safe side ... return '=' operator
		return MATH_EQ;
		break;

	}

	// defaul
	return MATH_EQ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\gpresult\wmi.h ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//
//      WMI.h  
//  
//  Abstract:
//  
//      Common functionality for WMI
//
//  Author:
//  
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000
//  
//  Revision History:
//  
//      Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000 : Created It.
//  
// *********************************************************************************

#ifndef __WMI_H
#define __WMI_H

//
// macros
//
#define SAFE_RELEASE( interfacepointer )    \
    if ( (interfacepointer) != NULL )   \
    {   \
        (interfacepointer)->Release();  \
        (interfacepointer) = NULL;  \
    }   \
    1

#define SAFE_EXECUTE( statement )               \
    hr = statement;     \
    if ( FAILED( hr ) ) \
    {   \
        _com_issue_error( hr ); \
    }   \
    1

//
// define(s) / enumerators / constants
//
#define WMI_NAMESPACE_CIMV2     L"root\\cimv2"
#define WMI_NAMESPACE_DEFAULT   L"root\\default"

#define WMI_CLAUSE_AND          L"AND"
#define WMI_CLAUSE_OR           L"OR"
#define WMI_CLAUSE_WHERE        L"WHERE"

#define CLASS_CIMV2_Win32_OperatingSystem   L"Win32_OperatingSystem"

#define WMI_REGISTRY                    L"StdRegProv"
#define WMI_REGISTRY_M_STRINGVALUE      L"GetStringValue"
#define WMI_REGISTRY_M_DWORDVALUE       L"GetDwordValue"

#define WMI_REGISTRY_IN_HDEFKEY         L"hDefKey"
#define WMI_REGISTRY_IN_SUBKEY          L"sSubKeyName"
#define WMI_REGISTRY_IN_VALUENAME       L"sValueName"
#define WMI_REGISTRY_OUT_VALUE          L"sValue"
#define WMI_REGISTRY_OUT_VALUE_DWORD    L"uValue"
#define WMI_REGISTRY_OUT_RETURNVALUE    L"ReturnValue"

#define WMI_HKEY_CLASSES_ROOT               2147483648 
#define WMI_HKEY_CURRENT_USER               2147483649
#define WMI_HKEY_LOCAL_MACHINE              2147483650
#define WMI_HKEY_USERS                      2147483651
#define WMI_HKEY_CURRENT_CONFIG             2147482652

// messages
// #define ERROR_COM_ERROR                  GetResString( IDS_ERROR_COM_ERROR )

//
// function prototype(s)
//
BOOL InitializeCom( IWbemLocator** ppLocator );
BOOL ConnectWmi( IWbemLocator* pLocator, 
                 IWbemServices** ppServices, 
                 LPCWSTR pwszServer, LPCWSTR pwszUser, LPCWSTR pwszPassword, 
                 COAUTHIDENTITY** ppAuthIdentity, 
                 BOOL bCheckWithNullPwd = FALSE, 
                 LPCWSTR pwszNamespace = WMI_NAMESPACE_CIMV2, 
                 HRESULT* phr = NULL, BOOL* pbLocalSystem = NULL );
BOOL ConnectWmiEx( IWbemLocator* pLocator, 
                   IWbemServices** ppServices, 
                   LPCWSTR pwszServer, CHString& strUserName, CHString& strPassword, 
                   COAUTHIDENTITY** ppAuthIdentity, BOOL bNeedPassword = FALSE, 
                   LPCWSTR pszNamespace = WMI_NAMESPACE_CIMV2, BOOL* pbLocalSystem = NULL );
BOOL IsValidServerEx( LPCWSTR pwszServer, BOOL& bLocalSystem );
HRESULT SetInterfaceSecurity( IUnknown* pInterface, COAUTHIDENTITY* pAuthIdentity );
VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY** ppAuthIdentity );
VOID WMISaveError( HRESULT hrError );
HRESULT PropertyGet( IWbemClassObject* pWmiObject, 
                     LPCWSTR pwszProperty, _variant_t& varValue );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, 
                  CHString& strValue, LPCWSTR pwszDefault = V_NOT_AVAILABLE );
BOOL PropertyGet( IWbemClassObject* pWmiObject, 
                  LPCWSTR pwszProperty,  DWORD& dwValue, DWORD dwDefault = 0 );
BOOL PropertyGet( IWbemClassObject* pWmiObject, 
                  LPCWSTR pwszProperty,  BOOL& dwValue, BOOL bDefault = FALSE );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  ULONGLONG& ullValue );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  WBEMTime& wbemtime );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  SYSTEMTIME& systime );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, DWORD dwValue );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, LPCWSTR pwszValue );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue );
DWORD GetTargetVersionEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity );
BOOL RegQueryValueWMI( IWbemServices* pWbemServices, DWORD dwHDefKey, 
                       LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, 
                       CHString& strValue, LPCWSTR pwszDefault = V_NOT_AVAILABLE );
BOOL RegQueryValueWMI( IWbemServices* pWbemServices, 
                       DWORD dwHDefKey, LPCWSTR pwszSubKeyName, 
                       LPCWSTR pwszValueName, DWORD& dwValue, DWORD dwDefault = 0 );
BOOL GetPropertyFromSafeArray( SAFEARRAY *pSafeArray, LONG lIndex, CHString& strValue,
                                VARTYPE vartype );
BOOL GetPropertyFromSafeArray( SAFEARRAY *pSafeArray, LONG lIndex, 
                                IWbemClassObject **pScriptObject, VARTYPE vartype );

//
// inline functions
//

// ***************************************************************************
// Routine Description:
//        
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
inline VOID WMISaveError( _com_error& e )
{
    WMISaveError( e.Error() );
}

#endif // __WMI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\lib\cmdline.c ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//  
// 	  Common.c
//  
//  Abstract:
//  
// 	  This modules implements common functionality for all the command line tools.
// 	
//   
//  Author:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 01-Sep-2000
//  
//  Revision History:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 01-Sep-2000 : Created It.
//  
// *********************************************************************************

#include "pch.h"
#include "cmdlineres.h"
#include "cmdline.h"
#include <limits.h>

//
// global variable(s) that are exposed to the external world 
//
#ifdef _MT
// multi-threaded variable ( thread local storage )
_declspec( thread ) static LPTSTR g_pszInfo = NULL;
_declspec( thread ) static LPTSTR g_pszString = NULL;
_declspec( thread ) static LPWSTR g_pwszResourceString = NULL;
_declspec( thread ) static TARRAY g_arrQuotes = NULL;
#else
static LPTSTR g_pszInfo = NULL;				// holds the reason for the last failure
static LPTSTR g_pszString = NULL;			// used to get the resource table's string
static LPWSTR g_pwszResourceString = NULL;	// temporary unicode buffer
static TARRAY g_arrQuotes = NULL;
#endif

// SPECIAL: process level globals
BOOL g_bWinsockLoaded = FALSE;
DWORD g_dwMajorVersion = 5;
DWORD g_dwMinorVersion = 1;
WORD g_wServicePackMajor = 0;

//
// private functions
//
BOOL SetThreadUILanguage0( DWORD dwReserved );

//
// public functions
//

// ***************************************************************************
// Routine Description:
//
// Arguments:
//  
// Return Value:
//
// ***************************************************************************
BOOL SetOsVersion( DWORD dwMajor, DWORD dwMinor, WORD wServicePackMajor )
{
	// local variables
	static BOOL bSet = FALSE;

	// we won't support below Windows 2000
	if ( dwMajor < 5 )
	{
		return FALSE;
	}
	else if ( bSet == TRUE )
	{
		// version is already set -- version cannot be changed frequently
		return FALSE;
	}

	// rest of information we need not bother
	bSet = TRUE;
	g_dwMajorVersion = dwMajor;
	g_dwMinorVersion = dwMinor;
	g_wServicePackMajor = wServicePackMajor;

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//
// Arguments:
//  
// Return Value:
//
// ***************************************************************************
BOOL IsWin2KOrLater() 
{
	// local variables
	OSVERSIONINFOEX osvi;
	DWORDLONG dwlConditionMask = 0;

	// Initialize the OSVERSIONINFOEX structure.
	ZeroMemory( &osvi, sizeof( OSVERSIONINFOEX ) );
	osvi.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );
	osvi.dwMajorVersion = g_dwMajorVersion;
	osvi.dwMinorVersion = g_dwMinorVersion;
	osvi.wServicePackMajor = g_wServicePackMajor;

	// Initialize the condition mask.
	VER_SET_CONDITION( dwlConditionMask, VER_MAJORVERSION, VER_GREATER_EQUAL );
	VER_SET_CONDITION( dwlConditionMask, VER_MINORVERSION, VER_GREATER_EQUAL );
	VER_SET_CONDITION( dwlConditionMask, VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL );

	// Perform the test.
	return VerifyVersionInfo( &osvi, VER_MAJORVERSION | VER_MINORVERSION, dwlConditionMask );
}

// ***************************************************************************
// Routine Description:
//	
// Saves the last occured windows error.
//
// Arguments:
//
// None.
//  
// Return Value:
// 
// VOID
//
// ***************************************************************************
VOID SaveLastError()
{
	// local variables
	DWORD dwErrorCode = 0;
	LPVOID lpMsgBuf = NULL;		// pointer to handle error message

	// get the last error
	dwErrorCode = GetLastError();

    //  Complex scripts cannot be rendered in the console, so we
    //  force the English (US) resource.
	SetThreadUILanguage0( 0 );

	// load the system error message from the windows itself
	FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL, dwErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf, 0, NULL );

	// display error message on console screen ... ERROR place
	if ( lpMsgBuf != NULL )
		SetReason( ( LPCTSTR ) lpMsgBuf );

	// Free the buffer ... using LocalFree is slow, but still, we are using ...
	//					   later on need to replaced with HeapXXX functions
	if ( lpMsgBuf != NULL )
		LocalFree( lpMsgBuf );
}

// ***************************************************************************
// Routine Description:
//
// Saves the last occured windows network error and returns the error code obtained.		  
//
// Arguments:
//  
// None
//
// Return Value:
//
// DWORD					-- error code
//
// ***************************************************************************
DWORD WNetSaveLastError()
{
	// local variables
	DWORD dwErrorCode = 0;
	__MAX_SIZE_STRING szMessage = NULL_STRING;		// handle error message
	__MAX_SIZE_STRING szProvider = NULL_STRING;		// store the provider for error

	// load the system error message from the windows itself
	WNetGetLastError( &dwErrorCode, szMessage, SIZE_OF_ARRAY( szMessage ), 
		szProvider, SIZE_OF_ARRAY( szProvider ) );

	// save the error
	SetReason( szMessage );

	// return the error code obtained
	return dwErrorCode;
}

// ***************************************************************************
// Routine Description:
//
// writes the last saved error description in the given file.
//		  
// Arguments:
//
//    [in] fp					-- file to write the error description.
//  
// Return Value:
// 
// VOID
//
// ***************************************************************************
VOID ShowLastError( FILE* fp )
{
	// local variables
	DWORD dwErrorCode = 0;
	LPVOID lpMsgBuf = NULL;		// pointer to handle error message

	// get the last error
	dwErrorCode = GetLastError();

    //  Complex scripts cannot be rendered in the console, so we
    //  force the English (US) resource.
	SetThreadUILanguage0( 0 );

	// load the system error message from the windows itself
	FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL, dwErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf, 0, NULL );

	// buffer might not have allocated
	if ( lpMsgBuf == NULL )
		return;

	// display error message on console screen ... ERROR place
	DISPLAY_MESSAGE( fp, ( LPCTSTR ) lpMsgBuf );

	// Free the buffer ... using LocalFree is slow, but still, we are using ...
	//					   later on need to replaced with HeapXXX functions
	LocalFree( lpMsgBuf );
}

// ***************************************************************************
// Routine Description:
//		  
// writes the last saved nerwork error description in the given file.
//
// Arguments:
//
// [in]  fp					--fle to write the error description.
//
// Return Value:
//
// DWORD					--error code
//  
// ***************************************************************************
DWORD WNetShowLastError( FILE* fp )
{
	// local variables
	DWORD dwErrorCode = 0;
	__MAX_SIZE_STRING szMessage = NULL_STRING;		// handle error message
	__MAX_SIZE_STRING szProvider = NULL_STRING;	// store the provider for error

	// load the system error message from the windows itself
	WNetGetLastError( &dwErrorCode, szMessage, SIZE_OF_ARRAY( szMessage ), 
		szProvider, SIZE_OF_ARRAY( szProvider ) );

	// display error message on console screen ... ERROR place
	DISPLAY_MESSAGE( fp, szMessage );

	// return the error code obtained
	return dwErrorCode;
}

// ***************************************************************************
// Routine Description:
//	
// Releases all the global values that are used.
//	  
// Arguments:
//
// None.
//  
// Return Value:
//
// VOID
// 
// ***************************************************************************
LONG StringLengthInBytes( LPCTSTR pszText )
{
	// local variables
	LONG lLength = 0;

#ifdef UNICODE
	// get the length of the string in bytes
	// since this function includes the count for null character also, ignore that information
	lLength = WideCharToMultiByte( _DEFAULT_CODEPAGE, 0, pszText, -1, NULL, 0, NULL, NULL ) - 1;
#else
	lLength = lstrlen( pszText );
#endif

	// return the length information
	return lLength;
}

// ***************************************************************************
// Routine Description:
//
// Converts the Unicode string to ansi string.
//		  
// Arguments:
//
// [in] pszSource				--Unicode string to be converted, 
// [out] pszDestination				--Converted String
// [in] dwLength					--Length of the string
// 
// Return Value:
//
// LPSTR							--Converted string
// 
// ***************************************************************************
LPSTR GetAsMultiByteString( LPCTSTR pszSource, LPSTR pszDestination, DWORD dwLength )
{
	// check the input values
	if ( pszSource == NULL || pszDestination == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return "";
	}

	// initialize the values with zeros
	// NOTE:- WideCharToMultiByte wont null terminate its result so 
	//		  if its not initialized to nulls, you'll get junk after 
	//		  the converted string and will result in crashes
	ZeroMemory( pszDestination, dwLength * sizeof( char ) );

#ifdef UNICODE

	// convert string from UNICODE version to ANSI version
	WideCharToMultiByte( _DEFAULT_CODEPAGE, 0, pszSource, -1, 
		pszDestination, dwLength, NULL, NULL );
#else

	// just do the copy
	lstrcpyn( pszDestination, pszSource, dwLength );
#endif

	// return the destination as return value
	return pszDestination;
}

// ***************************************************************************
// Routine Description:
// 
// Convertes a wide charecter string to Ansi string.
//		  
// Arguments:
//
// [in] pwszSource			--Wide charecter string to convert.
// [out] pszDestination,		--Translated String
// [in] dwLength				--Size of the String
//  
// Return Value:
// 
// LPSTR						--Translated String.
//
// ***************************************************************************
LPSTR GetAsMultiByteStringEx( LPCWSTR pwszSource, LPSTR pszDestination, DWORD dwLength )
{
	// check the input values
	if ( pwszSource == NULL || pszDestination == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return "";
	}

	// initialize the values with zeros
	// NOTE:- WideCharToMultiByte wont null terminate its result so 
	//		  if its not initialized to nulls, you'll get junk after 
	//		  the converted string and will result in crashes
	ZeroMemory( pszDestination, dwLength * sizeof( char ) );

	// convert string from UNICODE version to ANSI version
	WideCharToMultiByte( _DEFAULT_CODEPAGE, 0, pwszSource, -1, 
		pszDestination, dwLength, NULL, NULL );

	// return the destination as return value
	return pszDestination;
}

// ***************************************************************************
// Routine Description:
//
// Translates the Ansi string in to the Unicode string.
//		  
// Arguments:
//
// [in] pszSource		-- Ansi string to be translated, 
// [out] pwszDestination	-- Translated string.
// [in] dwLength			-- Size of the string
//  
// Return Value:
//
// LPWSTR					--Translated string.
// 
// ***************************************************************************
LPWSTR GetAsUnicodeString( LPCTSTR pszSource, LPWSTR pwszDestination, DWORD dwLength )
{
	// check the input values
	if ( pszSource == NULL || pwszDestination == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return L"";
	}

	// initialize the values with zeros
	// NOTE:- MultiByteToWideChar wont null terminate its result so 
	//		  if its not initialized to nulls, you'll get junk after 
	//		  the converted string and will result in crashes
	ZeroMemory( pwszDestination, dwLength * sizeof( wchar_t ) );

#ifdef UNICODE

	// just do the copy
	lstrcpyn( pwszDestination, pszSource, dwLength );
#else

	// convert string from ANSI version to UNICODE version
	MultiByteToWideChar( _DEFAULT_CODEPAGE, 0, pszSource, -1, pwszDestination, dwLength );
#endif

	// return the destination as return value
	return pwszDestination;
}

// ***************************************************************************
// Routine Description:
//
// Convertes ansi string to wide charecter string.
//		  
// Arguments:
//
// [in] pszSource				-- String to be converted.
// [out] pwszDestination		-- Converted string
// [in] dwLength				-- length of the string
//  
// Return Value:
//
// LPWSTR						--Converted String
// 
// ***************************************************************************
LPWSTR GetAsUnicodeStringEx( LPCSTR pszSource, LPWSTR pwszDestination, DWORD dwLength )
{
	// check the input values
	if ( pszSource == NULL || pwszDestination == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return L"";
	}

	// initialize the values with zeros
	// NOTE:- MultiByteToWideChar wont null terminate its result so 
	//		  if its not initialized to nulls, you'll get junk after 
	//		  the converted string and will result in crashes
	ZeroMemory( pwszDestination, dwLength * sizeof( wchar_t ) );

	// convert string from ANSI version to UNICODE version
	MultiByteToWideChar( _DEFAULT_CODEPAGE, 0, pszSource, -1, pwszDestination, dwLength );

	// return the destination as return value
	return pwszDestination;
}

// ***************************************************************************
// Routine Description:
//		  
// Convertes the given string as a float value.
//
// Arguments:
//
// [in] szValue		-- String to convert
//  
// Return Value:
//
// double				-- converted double
// 
// ***************************************************************************
double AsFloat( LPCTSTR szValue )
{
	// local variables
	double dblValue = 0;
	LPTSTR pszStopString = NULL;
	__MAX_SIZE_STRING szValueString = NULL_STRING;

	// check the input value
	if ( szValue == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return 0.0f;
	}

	// convert the string value into double value
	lstrcpy( szValueString, szValue );		// copy org value into local buffer
	dblValue = _tcstod( szValueString, &pszStopString );

	// return converted value
	return dblValue;
}

// ***************************************************************************
// Routine Description:
//
// Convertes the string in to the long value based on the given base.
//
// Arguments:
//
// [in] szValue		--Srtring to convert 
// [in] dwBase			--Base value
//  
// Return Value:
//
// LONG					--converted long value
// 
// ***************************************************************************
LONG AsLong( LPCTSTR szValue, DWORD dwBase )
{
	// local variables
	LONG lValue = 0;
	LPTSTR pszStopString = NULL;
	__MAX_SIZE_STRING szValueString = NULL_STRING;

	// validate the base
	// value should be in the range of 2 - 36 only
	if ( dwBase < 2 || dwBase > 36 )
		return -1;

	// check the input value
	if ( szValue == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return 0L;
	}

	// convert the string value into long value
	lstrcpy( szValueString, szValue );		// copy org value into local buffer
	lValue = _tcstol( szValueString, &pszStopString, dwBase );

	// return converted value
	return lValue;
}

// ***************************************************************************
// Routine Description:
//
// Checks whether the given string is a float string
//		  
// Arguments:
//
// [in] szValue			--String to check
//  
// Return Value:
//
// BOOL						--True if the given string is a floating point string
//							--False Otherwise
// 
// ***************************************************************************
BOOL IsFloatingPoint( LPCTSTR szValue )
{
	// local variables
	double dblValue = 0;
	LPTSTR pszStopString = NULL;
	__MAX_SIZE_STRING szValueString = NULL_STRING;

	// check the input value
	if ( szValue == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return FALSE;
	}

	// convert the string value into double value
	lstrcpy( szValueString, szValue );		// copy org value into local buffer
	dblValue = _tcstod( szValueString, &pszStopString );

	// now check whether the value is completely converted to floating point or not
	// if not converted completely, then value is not correct
	// if completely converted, the value is pure floating point
	if ( lstrlen( pszStopString ) != 0 )
		return FALSE;

	// value is valid floating point
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Checks whether the given string is Numeric or not.
//
// Arguments:
//
// [in] szValue	--String to check
// [in] dwBase		-- The base value
// [in] bSigned		-- signed information 
//					-- true if signed, otherwise false
//  
// Return Value:
//
// BOOL				--true if it is a numeric with that base
//					--false otherwise.
// 
// ***************************************************************************
BOOL IsNumeric( LPCTSTR szValue, DWORD dwBase, BOOL bSigned )
{
	// local variables
	long lValue = 0;
	double dblValue = 0;
	LPTSTR pszStopString = NULL;
	__MAX_SIZE_STRING szValueString = NULL_STRING;

	// validate the base
	// value should be in the range of 2 - 36 only
	if ( dwBase < 2 || dwBase > 36 )
		return FALSE;

	// check the input value
	if ( szValue == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return FALSE;
	}

	// convert the string value into numeric value
	lstrcpy( szValueString, szValue );		// copy org value into local buffer
	lValue = _tcstol( szValueString, &pszStopString, dwBase );

	// now check whether the value is completely converted to numeric value or not
	// if not converted completely, then value is not correct
	// if completely converted, the value is pure numeric value
	if ( lstrlen( pszStopString ) != 0 )
		return FALSE;

	// check whether the numeric value can be signed or not
	if ( bSigned == FALSE && lValue < 0 )
		return FALSE;			// value cannot be -ve

	// furthur check whether converted value is valid or not - overflow might have occurred
	// NOTE: because of the limitations of libraries which we have in 'C' we cannot 
	//       check for the overflow exactly using the LONG datatype.
	//       for that reason we are using 'double' data type to check for overflow
	lstrcpy( szValueString, szValue );		// copy org value into local buffer
	dblValue = _tcstod( szValueString, &pszStopString );

	// validate the number
	if ( bSigned == FALSE && dblValue > ((double) ULONG_MAX) )
		return FALSE;
	else if (bSigned && ( dblValue > ((double) LONG_MAX) || dblValue < ((double) LONG_MIN) ))
		return FALSE;

	// value is valid numeric
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//
// Replicates the szChar string dwCount times and saves the result in pszBuffer.
//		  
// Arguments:
//
// [in] pszBuffer		--String to copy the replicate string
// [in] szChar		--String to replicate
// [in] dwCount		-- Number of times
//  
// Return Value:
// 
// LPTSTR				--Replicated string
//
// ***************************************************************************
LPTSTR Replicate( LPTSTR pszBuffer, LPCTSTR szChar, DWORD dwCount )
{
	// local variables
	DWORD dw = 0;

	// validate the input buffers
	if ( pszBuffer == NULL || szChar == NULL )
		return NULL_STRING;

	// form the string of required length
	lstrcpy( pszBuffer, NULL_STRING );
	for( dw = 0; dw < dwCount; dw++ )
	{
		// append the replication character
		lstrcat( pszBuffer, szChar );
	}

	// return the replicated buffer
	return pszBuffer;
}

// ***************************************************************************
// Routine Description:
//
// Adjust the length of a string with spaces depending on the given pad.
//
// Arguments:
//
// [in] szValue		-- Given string
// [in] dwLength		-- Actual length of the string
// [in] bPadLeft		-- Padding property
//						-- true if left padding is required
//						-- false otherwise
// Return Value:
// 
// LPTSTR				-- String with actual length.
//
// ***************************************************************************
LPTSTR AdjustStringLength( LPTSTR szValue, DWORD dwLength, BOOL bPadLeft )
{
	// local variables
	DWORD dw = 0;
	DWORD dwTemp = 0;
	DWORD dwCurrLength = 0;
	LPTSTR pszBuffer = NULL;
	LPTSTR pszSpaces = NULL;

	// check the input value
	if ( szValue == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return NULL_STRING;
	}

	// allocate the buffers 
	// ( accomadate space double the original buffer/required length - this will save us from crashes )
	dwTemp = (( StringLengthInBytes( szValue ) > (LONG) dwLength ) ? StringLengthInBytes( szValue ) : dwLength );
	pszSpaces = __calloc( dwTemp * 2, sizeof( TCHAR ) );
	pszBuffer = __calloc( dwTemp * 2, sizeof( TCHAR ) );
	if ( pszBuffer == NULL || pszSpaces == NULL )
	{
		__free( pszBuffer );
		__free( pszSpaces );
		return szValue;
	}

	// get the current length of the string
	// NOTE: the string might contain the meta characters which will count in length
	//       so get the actual string contents which whill be displayed
	lstrcpy( pszBuffer, szValue );
	wsprintf( pszSpaces, pszBuffer );
	dwCurrLength = StringLengthInBytes( pszSpaces );

	// reset the data
	lstrcpy( pszBuffer, NULL_STRING );
	lstrcpy( pszSpaces, NULL_STRING );

	// adjust the string value
	if ( dwCurrLength < dwLength )
	{
		// 
		// length of the current value is less than the needed

		// get the spaces for the rest of the length
		Replicate( pszSpaces, _T( " " ), dwLength - dwCurrLength );

		// append the spaces either to the end of the value or begining of the value
		// based on the padding property
		if ( bPadLeft )
		{
			// spaces first and then value
			lstrcpy( pszBuffer, pszSpaces );
			lstrcat( pszBuffer, szValue );
		}
		else
		{
			// value first and then spaces
			lstrcpy( pszBuffer, szValue );
			lstrcat( pszBuffer, pszSpaces );
		}
	}
	else
	{
		// prepare the buffer ... we will avoid '%' characters here
		lstrcpy( pszSpaces, szValue );
		wsprintf( pszBuffer, pszSpaces );

		// copy only the characters of required length
		lstrcpyn( pszSpaces, pszBuffer, dwLength + 1 );

		// now re-insert the '%' characters
		lstrcpy( pszBuffer, _X( pszSpaces ) );
	}

	// copy the contents back to the original buffer
	lstrcpy( szValue, pszBuffer );

	// free the buffer
	__free( pszBuffer );
	__free( pszSpaces );

	// return the same buffer back to the caller
	return szValue;
}

// ***************************************************************************
// Routine Description:
//
// Trims the string on both sides (left and/or right)
//		  
// Arguments:
//
// [in] lpsz		--String to trim
// [in] dwFlags		--Flags for specifying left and/or right trim
//  
// Return Value:
//
// LPTSTR				-- Trimmed string.
// 
// ***************************************************************************
LPTSTR TrimString( LPTSTR lpsz, DWORD dwFlags )
{
	// local varibles
	DWORD dwBegin = 0, dwEnd = 0;
	LPTSTR pszTemp = NULL;
	LPTSTR pszBuffer = NULL;

	// validate the parameter
	if ( lpsz == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return NULL_STRING;
	}

	// check length of the string if it empty string ...
	if ( lstrlen( lpsz ) == 0 )
		return lpsz;

	// get the duplicate copy
	pszTemp = _tcsdup( lpsz );
	if ( pszTemp == NULL )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return NULL_STRING;
	}

	// traverse both from the end of the string and begining of the string
	dwBegin = 0;
	dwEnd = lstrlen( pszTemp ) - 1;
	for( ; *( pszTemp + dwBegin ) == _T( ' ' ) || *( pszTemp + dwEnd ) == _T( ' ' ); )
	{
		// check the character at the current begining .. if space, move the pointer
		if ( *( pszTemp + dwBegin ) == _T( ' ' ) && ( dwFlags & TRIM_LEFT ) )
			dwBegin++;

		// check whether the last character is space or not
		// if space, decrement the size
		if ( *( pszTemp + dwEnd ) == _T( ' ' ) && ( dwFlags & TRIM_RIGHT ) )
			dwEnd--;
	}

	// do the actual trimming now
	pszBuffer = pszTemp;							// save the pointer ... needs to freed
	*( pszTemp + dwEnd + 1 ) = NULL_CHAR;			// remove trailing spaces first
	pszTemp += dwBegin;								// then leading spaces
	lstrcpy( lpsz, pszTemp );						// copy to the source buffer
	free( pszBuffer );								// release the duplicated memory

	// return the string
	return lpsz;
}

// ***************************************************************************
// Routine Description:
//
// Takes the password from the keyboard. While entering the password it shows
// the charecters as '*'
//
// Arguments:
//
// [in] pszPassword		--password string to store password
// [in] dwMaxPasswordSize	--Maximun size of the password. MAX_PASSWORD_LENGTH.
//  
// Return Value:
//
// BOOL						--If this function succeds returns true otherwise retuens false.
// 
// ***************************************************************************
BOOL GetPassword( LPTSTR pszPassword, DWORD dwMaxPasswordSize )
{
	// local variables
	TCHAR ch;
	DWORD dwIndex = 0;
	DWORD dwCharsRead = 0;
	DWORD dwCharsWritten = 0;
	DWORD dwPrevConsoleMode = 0;
	HANDLE hInputConsole = NULL;
	TCHAR szBuffer[ 10 ] = NULL_STRING;		// actually contains only character at all the times
	BOOL bIndirectionInput	= FALSE;
	TCHAR szTmpBuffer[MAX_PASSWORD_LENGTH] = NULL_STRING;
	HANDLE hnd;
	

	// check the input value
	if ( pszPassword == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return FALSE;
	}

	// get the handle for the standard input
	hInputConsole = GetStdHandle( STD_INPUT_HANDLE );
	if ( hInputConsole == NULL )
	{
		// could not get the handle so return failure
		return FALSE;
	}

	// check for the input redirect
	if( ( hInputConsole != (HANDLE)0x00000003 ) && ( hInputConsole != INVALID_HANDLE_VALUE ) )
	{
		bIndirectionInput	= TRUE;
	}

	// redirect the data from StdIn.txt file into the console
	if ( bIndirectionInput	== FALSE )
	{
		// Get the current input mode of the input buffer
		GetConsoleMode( hInputConsole, &dwPrevConsoleMode );
		
		// Set the mode such that the control keys are processed by the system
		if ( SetConsoleMode( hInputConsole, ENABLE_PROCESSED_INPUT ) == 0 )
		{
			// could not set the mode, return failure
			return FALSE;
		}
	}

	//	Read the characters until a carriage return is hit
	while( TRUE )
	{
		if ( bIndirectionInput == TRUE )
		{
			//read the contents of file 
			if ( ReadFile( hInputConsole, &ch, 1, &dwCharsRead, NULL ) == FALSE )
			{
				return FALSE;
			}

			// check for end of file
			if ( dwCharsRead == 0 )
			{
				break;
			}
		}
		else
		{
			if ( ReadConsole( hInputConsole, &ch, 1, &dwCharsRead, NULL ) == 0 )
			{
				// Set the original console settings
				SetConsoleMode( hInputConsole, dwPrevConsoleMode );
				
				// return failure
				return FALSE;
			}
		}
		
		// Check for carraige return
		if ( ch == CARRIAGE_RETURN )
		{
			// break from the loop
			break;
		}

		// Check id back space is hit
		if ( ch == BACK_SPACE )
		{
			if ( dwIndex != 0 )
			{
				//
				// Remove a asterix from the console

				// move the cursor one character back
				FORMAT_STRING( szBuffer, _T( "%c" ), BACK_SPACE );
				WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1, 
					&dwCharsWritten, NULL );
				
				// replace the existing character with space
				FORMAT_STRING( szBuffer, _T( "%c" ), BLANK_CHAR );
				WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1, 
					&dwCharsWritten, NULL );

				// now set the cursor at back position
				FORMAT_STRING( szBuffer, _T( "%c" ), BACK_SPACE );
				WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1, 
					&dwCharsWritten, NULL );

				// decrement the index 
				dwIndex--;
			}
			
			// process the next character
			continue;
		}

		// if the max password length has been reached then sound a beep
		if ( dwIndex == ( dwMaxPasswordSize - 1 ) )
		{
			WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), BEEP_SOUND, 1, 
				&dwCharsWritten, NULL );
		}
		else
		{
			// check for new line character
			if ( ch != '\n' )	
			{
				// store the input character
				*( pszPassword + dwIndex ) = ch;
				dwIndex++;

				// display asterix onto the console
				WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), ASTERIX, 1, 
					&dwCharsWritten, NULL );
			}
			
		}
	}

	// Add the NULL terminator
	*( pszPassword + dwIndex ) = NULL_CHAR;

	//Set the original console settings
	SetConsoleMode( hInputConsole, dwPrevConsoleMode );

	// display the character ( new line character )
	FORMAT_STRING( szBuffer, _T( "%s" ), _T( "\n\n" ) );
	WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 2, 
		&dwCharsWritten, NULL );

	//	Return success
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//
// Searches for a string in a string.
//
// Arguments:
//  
// [in] szString			--Null termibated string to search
// [in] szList			--Null-terminated string to search for 
// [in] bIgnoreCase			--True for ignore the case
//							--False for case sensitive search
//
// Return Value:
//
// BOOL						--True if the string is found otherwise false
// 
// ***************************************************************************
BOOL InString( LPCTSTR szString, LPCTSTR szList, BOOL bIgnoreCase )
{
	// local variables
	__MAX_SIZE_STRING szFmtList = NULL_STRING;
	__MAX_SIZE_STRING szFmtString = NULL_STRING;

	// check the input value
	if ( szString == NULL || szList == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return FALSE;
	}

	// prepare the strings for searching
	FORMAT_STRING( szFmtList, _T( "|%s|" ), szList );
	FORMAT_STRING( szFmtString, _T( "|%s|" ), szString );

	// check whether is comparision is case-sensitive or case-insensitive
	if ( bIgnoreCase )
	{
		// convert the list and string to uppercase
		CharUpper( szFmtList );
		CharUpper( szFmtString );
	}

	// search for the string in the list and return result based
	return ( _tcsstr( szFmtList, szFmtString ) != NULL );
}

// ***************************************************************************
// Routine Description:
//
// Compares the two given strings.
//	  
// Arguments:
//
// [in] szString1			--first null-terminated string to be compared
// [in] szString2			--second first null-terminated string to be compared
// [in] bIgnoreCase				--True for ignoring the case.
//								--False for case sensitive.
// [in] dwCount				--Number of charecters to compare.
//  
// Return Value:
//
// LONG							-- < 0 szString1 substring less than szString2 substring
//								-- = 0 szString1 substring identical to szString2 substring
//								-- > 0 szString1 substring greater than szString2 substring 
// 
// ***************************************************************************
LONG StringCompare( LPCTSTR szString1, LPCTSTR szString2, BOOL bIgnoreCase, DWORD dwCount )
{
	// local variables
	LONG lResult;

	// check the input value
	if ( szString1 == NULL || szString2 == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return 0;
	}

	//
	// start the comparision
	if ( bIgnoreCase )
	{
		//
		// do case in-sensitive comparision
		
		// if count info is not available,
		if ( dwCount == 0 )
			lResult = lstrcmpi( szString1, szString2 );
		else	// otherwise
			lResult = _tcsnicmp( szString1, szString2, dwCount );
	}
	else	// case sensitive
	{
		//
		// do case in-sensitive comparision
		
		// if count info is not available,
		if ( dwCount == 0 )
			lResult = lstrcmp( szString1, szString2 );
		else	// otherwise
			lResult = _tcsncmp( szString1, szString2, dwCount );
	}

	// now return comparision result
	return lResult;
}

// ***************************************************************************
// Routine Description:
//		  
// Returns the resource string from the resource for the given resource ID.
//
// Arguments:
//
// [in] uID				--Windows string resource identifier. 
//  
// Return Value:
//
// LPCTSTR				--Resource string from the resource.
// 
// ***************************************************************************
LPCTSTR GetResString( UINT uID )
{
	// check whether memory is allocated or not
	// if memory is not allocated, allocate now
	if ( g_pszString == NULL )
	{
		g_pszString = ( LPTSTR ) __calloc( MAX_RES_STRING + 5, sizeof( TCHAR ) );
		if ( g_pszString == NULL )
			return NULL_STRING;
	}

	// load the string from the resource table
	if ( LoadResString( uID, g_pszString, MAX_RES_STRING ) == 0 )
		return NULL_STRING;

	// return the string
	return g_pszString;
}

// ***************************************************************************
// Routine Description:
//		  
// Returns the resourse string from the resource for the given resource ID.
//
// Arguments:
//
// [in] uID				--Windows string resource identifier. 
//  
// Return Value:
//
// LPTSTR				--Resource string from the resource.
// 
// ***************************************************************************
LPTSTR GetResStringEx( UINT uID )
{
	// local variables
	LPTSTR pszBuffer = NULL;

	// allocate the memory
	pszBuffer = ( LPTSTR ) __calloc( MAX_RES_STRING + 5, sizeof( TCHAR ) );
	if ( pszBuffer == NULL )
	{
		// ran out of memory
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return NULL;
	}

	// load the string from the resource table
	if ( LoadResString( uID, pszBuffer, MAX_RES_STRING ) == 0 )
		return NULL;

	// return the string
	return pszBuffer;
}

// ***************************************************************************
// Routine Description:
//		  
// Loads the Resource String corresponding to the given ID.
//
// Arguments:
//
// [in] uID					--Windows string resource identifier. 
// LPTSTR pszValue			--Nullterminated string to get the resource string.
// DWORD dwBufferMax		--Size of the pszvalue.
//
// Return Value:
//
// DWORD					--if success,Returns the size of the resource string.
//							--otherwise returns 0.
// 
// ***************************************************************************
DWORD LoadResString( UINT uID, LPTSTR pszValue, DWORD dwBufferMax )
{
	// local variables
	DWORD dwResult = 0;
	static DWORD dwCurrentSize = 0;
	static BOOL bThreadLocale = FALSE;

	//
	// because we operate in multi-lingual mode, it is good to set the appropriate 
	// thread locale and get the strings from resource table
	//
	if ( bThreadLocale == FALSE )
	{
		SetThreadUILanguage0( 0 );
		bThreadLocale = TRUE;
	}

	// check the input value
	if ( pszValue == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return 0;
	}

	// allocate memory for unicode buffer
	if ( g_pwszResourceString == NULL )
	{
		dwCurrentSize = dwBufferMax;		// save the size of the buffer
		g_pwszResourceString = ( LPWSTR ) __calloc( dwBufferMax + 5, sizeof( wchar_t ) );
		if ( g_pwszResourceString == NULL )
		{
			// ran out of memory
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return 0;
		}
	}
	else if ( dwCurrentSize < dwBufferMax )
	{
		// the existing size is less than the required, re-allocate buffer
		dwCurrentSize = dwBufferMax;
		g_pwszResourceString = ( LPWSTR ) __realloc( g_pwszResourceString, 
			(dwBufferMax + 1) * sizeof( wchar_t ) );
		if ( g_pwszResourceString == NULL )
		{
			// ran out of memory
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return 0;
		}
	}

	// ( try ) loading the string from resource file string table
	dwResult = LoadStringW( NULL, uID, g_pwszResourceString, dwBufferMax );

	// check the result of loading string from string table
	// if success, make the string into compatible string and copy it to the 
	// specified buffer
	if ( dwResult != 0 )
	{
		// get the compatible string
		GetCompatibleStringFromUnicode( g_pwszResourceString, pszValue, dwBufferMax );
	}

	// return 
	return dwResult;
}

// ***************************************************************************
// Routine Description:
//	
// Writes the Message corrsponding to the given id in the given file.
//	  
// Arguments:
//
// [in] fp				--File to write the string.
// [in] uID				--Windows string resource identifier. 
//  
// Return Value:
//
// VOID
// 
// ***************************************************************************
VOID ShowResMessage( FILE* fp, UINT uID )
{
	// local variables
	__RESOURCE_STRING szValue = NULL_STRING;

	// check the input value
	if ( fp == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return;
	}

	// load the string from the resource table
	if ( LoadResString( uID, szValue, MAX_RES_STRING ) )
	{
		DISPLAY_MESSAGE( fp, szValue );		// display the message to the specified file
	}
}

// ***************************************************************************
// Routine Description:
// Displays the given input message	  
// Arguments:
// [in] fp - file pointer
// [in] szMessage - Message to be shown
//  
// Return Value:
// 
// ***************************************************************************
VOID ShowMessage( FILE* fp, LPCTSTR szMessage )
{
	// local variables
	DWORD dw = 0;
	DWORD dwTemp = 0;
	DWORD dwLength = 0;
	DWORD dwBufferSize = 0;
	BOOL bResult = FALSE;
	BOOL bCustom = FALSE;
	HANDLE hOutput = NULL;
	DWORD dwStdHandle = 0;
	LPTSTR pszTemp = NULL;
	LPCTSTR pszMessageBuffer = NULL;
	char szBuffer[ 256 ] = "\0";

	// check the input value
	if ( fp == NULL || szMessage == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return;
	}

	// determine the length(s)
	dwLength = lstrlen( szMessage );
	dwBufferSize = SIZE_OF_ARRAY( szBuffer );

	// determine the file handle
	bCustom = FALSE;
	if ( fp == stdout )
	{
		dwStdHandle = STD_OUTPUT_HANDLE;
	}
	else if ( fp == stderr )
	{
		dwStdHandle = STD_ERROR_HANDLE;
	}
	else
	{
		// currently default the unknown files to stderr
		bCustom = TRUE;
		dwStdHandle = STD_OUTPUT_HANDLE;
	}

	// get the handle to the stdout ( console )
	hOutput = GetStdHandle( dwStdHandle );
	if ( bCustom == FALSE && (((DWORD_PTR) hOutput) & 1) )
	{
		//
		// sting might have contained '%' (extra) chars added by QuoteMeta
		if ( FindOneOf( szMessage, _T( "%" ), 0 ) != NULL )
		{
			// allocate memory for formatting
			pszTemp = __calloc( lstrlen( szMessage ) + 10, sizeof( TCHAR ) );
			if ( pszTemp != NULL )
			{
				// we are not checking for non-null case which is out of memory error
				// just to avoid too many complications
				wsprintf( pszTemp, szMessage );

				// make the temporary pointer point to the formatted text
				pszMessageBuffer = pszTemp;
			}
		}

		// check whether we did any formatting or not
		if ( pszMessageBuffer == NULL )
		{
			// make the temporary pointer point to the original text
			pszMessageBuffer = szMessage;
		}

		// display the output
        bResult = WriteConsole( hOutput, pszMessageBuffer, dwLength, &dwTemp, NULL );

		// free the memory allocated if allocated
		if ( pszTemp != NULL )
		{
			__free( pszTemp );
			pszTemp = NULL;
		}
	}
	else
	{
		// show the text in shunks of buffer size
		dw = 0;
		while ( dwLength > dw )
		{
			// get the string in 'multibyte' format
			GetAsMultiByteString( szMessage + dw, szBuffer, dwBufferSize - 1 );
			// WideCharToMultiByte( CP_ACP, 0, 
			//	szMessage + dw, dwBufferSize, szBuffer, dwBufferSize, NULL, NULL );

			// determine the remaining buffer length
			dw += dwBufferSize - 1;

			// display string onto the specified file
	        // bResult = WriteFile( hOutput, szBuffer, lstrlenA( szBuffer ), &dwTemp, NULL );
			// if ( bResult == FALSE )
			// {
			// 	break;
			// }
			fprintf( fp, szBuffer );
			fflush( fp );
		}
	}
}

// ***************************************************************************
// Routine Description:
//	
// Gets the Last error description
//	  
// Arguments:
//  
// None
//
// Return Value:
//
// LPCTSTR	The error description string 
// 
// ***************************************************************************
LPCTSTR GetReason()
{
	// check whether buffer is allocated or not ... if not, empty string
	if ( g_pszInfo == NULL )
		return NULL_STRING;

	// returh the reason for the last failure
	return g_pszInfo;
}

// ***************************************************************************
// Routine Description:
//
// Sets teh last occured error as the given string.
//
// Arguments:
//
// [in] szReason			-- Null terminated string taht holds the error description.
//  
// Return Value:
//
// VOID
// 
// ***************************************************************************
VOID SetReason( LPCTSTR szReason )
{
	// check the input value
	if ( szReason == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return;
	}

	// check whether memory is allocated or not
	// if memory is not allocated, allocate now
	if ( g_pszInfo == NULL )
	{
		g_pszInfo = ( LPTSTR ) __calloc( MAX_STRING_LENGTH + 5, sizeof( TCHAR ) );
		if ( g_pszInfo == NULL )
			return;
	}

	// set the reason .. max. allowed characters only
	lstrcpyn( g_pszInfo, szReason, MAX_STRING_LENGTH + 1 );
}

// ***************************************************************************
// Routine Description:
//
// Arguments:
//  
// Return Value:
//
// ***************************************************************************
LPCTSTR FindChar( LPCTSTR pszText, TCHAR ch, DWORD dwFrom )
{
	// local variables
	DWORD i = 0;
	DWORD dwLength = 0;

	// check the inputs
	if ( pszText == NULL )
		return NULL;

	// get the lengths
	dwLength = lstrlen( pszText );

	// check the length of the text that has to be find. if it is 
	// more than the original it is obvious that it cannot be found
	if ( dwLength == 0 || dwFrom >= dwLength )
		return NULL;

	// traverse thru the original text
	for( i = dwFrom; i < dwLength; i++ )
	{
		// traverse thru the find string until characters were matching (or) string reached NULL
		if ( pszText[ i ] == ch )
			return pszText + i;
	}

	// string not found
	return NULL;
}

// ***************************************************************************
// Routine Description:
//
// Arguments:
//  
// Return Value:
//
// ***************************************************************************
LPCTSTR FindString( LPCTSTR pszText, LPCTSTR pszTextToFind, DWORD dwFrom )
{
	// local variables
	DWORD i = 0, j = 0;
	DWORD dwLength = 0;
	DWORD dwFindLength = 0;

	// check the inputs
	if ( pszText == NULL || pszTextToFind == NULL )
		return NULL;

	// get the lengths
	dwLength = lstrlen( pszText );
	dwFindLength = lstrlen( pszTextToFind );

	// check the length of the text that has to be find. if it is 
	// more than the original it is obvious that it cannot be found
	if ( (dwLength + dwFrom < dwFindLength) || dwFindLength == 0 || dwLength == 0 )
		return NULL;

	// traverse thru the original text
	for( i = dwFrom; i < dwLength; i++ )
	{
		// traverse thru the find string until characters were matching (or) string reached NULL
		for( j = 0; pszText[ i + j ] == pszTextToFind[ j ] && j < dwFindLength; j++ );

		// check whether completer string is matched or not
		if ( j == dwFindLength )
			return pszText + i;
	}

	// string not found
	return NULL;
}

// ***************************************************************************
// Routine Description:
//
// Arguments:
//  
// Return Value:
//
// ***************************************************************************
LPCTSTR FindOneOf( LPCTSTR pszText, LPCTSTR pszTextToFind, DWORD dwFrom )
{
	// local variables
	DWORD i = 0, j = 0;
	DWORD dwLength = 0;
	DWORD dwFindLength = 0;

	// check the inputs
	if ( pszText == NULL || pszTextToFind == NULL )
		return NULL;

	// get the lengths
	dwLength = lstrlen( pszText );
	dwFindLength = lstrlen( pszTextToFind );

	// check the length of the text that has to be find. if it is 
	// more than the original it is obvious that it cannot be found
	if ( dwLength == 0 || dwFindLength == 0 || dwFrom >= dwLength )
		return NULL;

	// traverse thru the original text
	for( i = dwFrom; i < dwLength; i++ )
	{
		// traverse thru the find string until characters were matching (or) string reached NULL
		for( j = 0; pszText[ i ] != pszTextToFind[ j ] && j < dwFindLength; j++ );

		// check whether completer string is matched or not
		if ( j != dwFindLength )
			return pszText + i;
	}

	// string not found
	return NULL;
}

// ***************************************************************************
// Routine Description:
//	  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
LPCTSTR QuoteMeta( LPCTSTR pszText, DWORD dwQuoteIndex )
{
	// local variables
	DWORD dw = 0;
	DWORD dwIndex = 0;
	DWORD dwLength = 0;
	LPCTSTR pszTemp = NULL;
	LPTSTR pszQuoteText = NULL;
	TCHAR pszQuoteChars[] = _T( "%" );

	// check the inputs
	if ( pszText == NULL || dwQuoteIndex == 0 )
		return NULL_STRING;

	// create the quote data storage location
	if ( g_arrQuotes == NULL )
	{
		g_arrQuotes = CreateDynamicArray();
		if ( g_arrQuotes == NULL )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return NULL_STRING;
		}
	}

	// check whether needed indexes exist or not
	dwIndex = DynArrayGetCount( g_arrQuotes );
	if ( dwIndex < dwQuoteIndex )
	{
		// add the needed no. of columns
		dw = DynArrayAddColumns( g_arrQuotes, dwQuoteIndex - dwIndex + 1 );
		
		// check whether columns were added or not
		if ( dw != dwQuoteIndex - dwIndex + 1 )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return NULL_STRING;
		}
	}

	// check whether the special chacters do exist in the text or not
	// if not, simply return
	if ( FindOneOf( pszText, pszQuoteChars, 0 ) == NULL )
		return pszText;

	// determine the length of the text that needs to be quoted
	dwLength = lstrlen( pszText );
	if ( dwLength == 0 )
		return pszText;

	// allocate the buffer ... it should twice the original
	pszQuoteText = __calloc( (dwLength + 5) * 2, sizeof( TCHAR ) );
	if ( pszQuoteText == NULL )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return NULL_STRING;
	}

	// do the quoting ...
	dwIndex = 0;
	for( dw = 0; dw < dwLength; dw++ )
	{
		// check whether the current character is quote char or not
		// NOTE: for time being this function only suppresses the '%' character escape sequences
		if ( FindChar( pszQuoteChars, pszText[ dw ], 0 ) != NULL )
			pszQuoteText[ dwIndex++ ] = _T( '%' );
		
		// copy the character
		pszQuoteText[ dwIndex++ ] = pszText[ dw ];
	}

	// put the null character
	pszQuoteText[ dwIndex ] = _T( '\0' );

	// save the quoted text in dynamic array
	if ( DynArraySetString( g_arrQuotes, dwQuoteIndex, pszQuoteText, 0 ) == FALSE )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		__free( pszQuoteText );
		return NULL_STRING;
	}

	// release the memory allocated for quoted text
	__free( pszQuoteText );

	// get the text from the array
	pszTemp = DynArrayItemAsString( g_arrQuotes, dwQuoteIndex );
	if ( pszTemp == NULL )
	{
		SetLastError( STG_E_UNKNOWN );
		SaveLastError();
		return NULL_STRING;
	}

	// return
	return pszTemp;
}


// ***************************************************************************
// Routine Description:
//	
//		Complex scripts cannot be rendered in the console, so we
//		force the English (US) resource.
//	  
// Arguments:
//		[ in ] dwReserved  => must be zero
//
// Return Value:
//		TRUE / FALSE
//
// ***************************************************************************
BOOL SetThreadUILanguage0( DWORD dwReserved )
{
	// local variables
	HMODULE hKernel32Lib = NULL;
	const CHAR cstrFunctionName[] = "SetThreadUILanguage";
	typedef BOOLEAN (WINAPI * FUNC_SetThreadUILanguage)( DWORD dwReserved );
	FUNC_SetThreadUILanguage pfnSetThreadUILanguage = NULL;
	
	// try loading the kernel32 dynamic link library
	hKernel32Lib = LoadLibrary( _T( "kernel32.dll" ) );
	if ( hKernel32Lib != NULL )
	{
		// library loaded successfully ... now load the addresses of functions
		pfnSetThreadUILanguage = (FUNC_SetThreadUILanguage) GetProcAddress( hKernel32Lib, cstrFunctionName );

		// we will keep the library loaded in memory only if all the functions were loaded successfully
		if ( pfnSetThreadUILanguage == NULL )
		{
			// some (or) all of the functions were not loaded ... unload the library
			FreeLibrary( hKernel32Lib );
			hKernel32Lib = NULL;
			pfnSetThreadUILanguage = NULL;
			return FALSE;
		}
	}

	// call the function
	((FUNC_SetThreadUILanguage) pfnSetThreadUILanguage)( dwReserved );

	// unload the library and return success
	FreeLibrary( hKernel32Lib );
	hKernel32Lib = NULL;
	pfnSetThreadUILanguage = NULL;
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//	
// Releases all the global values that are used.
//	  
// Arguments:
//
// None.
//  
// Return Value:
//
// VOID
// 
// ***************************************************************************
VOID ReleaseGlobals()
{
	// local variables
	DWORD dw = 0;

	//
	// memory is allocated then free memory
	
	// free memory for variable that holds the reason for failure
	if ( g_pszInfo != NULL )
	{
		__free( g_pszInfo );
	}

	// free memory for variable that used to get the string in resource table
	if ( g_pszString != NULL )
	{
		__free( g_pszString );
	}

	// free memory for variable that used to get the string in resource table in UNICODE
	if ( g_pwszResourceString != NULL )
	{
		__free( g_pwszResourceString );
	}

	// free the memory allocs for quote metas
	DestroyDynamicArray( &g_arrQuotes );

	// if winsock module is loaded, release it
	if ( g_bWinsockLoaded == TRUE )
		WSACleanup();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\lib\showresults.c ===
// *********************************************************************************
// 
// Copyright (c) Microsoft Corporation
// 
// Module Name:
// 
//		ShowResults.c 
//  
// Abstract:
//  
//		This modules  has functions which are  to shoow formatted Results on screen.
//  
// Author:
// 
//		Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000
//  
// Revision History:
//  
//		Sunil G.V.N. Murali (murali.sunil@wipro.com) 01-Sep-2000 : Created It.
//  
// *********************************************************************************

#include "pch.h"
#include "cmdline.h"
#include "cmdlineres.h"

//
// constants / defines / enumerations
//

//
// private functions ... used only within this file
//

// ***************************************************************************
// Routine Description:
//		Prepares the pszBuffer string by taking values from arrValues and 
//      formate these values as per szFormat string.   
//
// Arguments:
//      [ in ] arrValues	: values to be formated.
//      [ out ] pszBuffer	: output string
//      [ in ] dwLength		: string length.
//      [ in ] szFormat		: format 
//      [ in ] szSeperator	: Seperator string
//
// Return Value:
//      NONE
// 
// ***************************************************************************
VOID __PrepareString( TARRAY arrValues, 
					  LPTSTR pszBuffer, DWORD dwLength, 
					  LPCTSTR szFormat, LPCTSTR szSeperator )
{
	// local variables
	DWORD dw = 0;
	DWORD dwCount = 0;
	LPTSTR pszTemp = NULL;
	LPTSTR pszValue = NULL;

	//
	// kick off 

	// init
	lstrcpy( pszBuffer, NULL_STRING );
	dwCount = DynArrayGetCount( arrValues );

	// allocate memory for buffers
	pszTemp = __calloc( dwLength + 5, sizeof( TCHAR ) );
	pszValue = __calloc( dwLength + 5, sizeof( TCHAR ) );
	if ( pszTemp == NULL || pszValue == NULL )
	{
		// release memories
		__free( pszTemp );
		__free( pszValue );
		return;
	}

	//
	// traverse thru the list of the values and concatenate them 
	// to the destination buffer
	for( dw = 0; dw < dwCount; dw++ )
	{
		// get the current value into the temporary string buffer
		DynArrayItemAsStringEx( arrValues, dw, pszValue, dwLength );

		// concatenate the temporary string to the original buffer
		FORMAT_STRING( pszTemp, szFormat, _X( pszValue ) );
		lstrcat( pszBuffer, pszTemp );
		dwLength -= StringLengthInBytes( pszTemp );
		
		// check whether this is the last value or not
		if ( dw + 1 < dwCount )
		{
			// there are some more values
			// check whether is space for adding the seperator or not
			if ( dwLength < (DWORD) StringLengthInBytes( szSeperator ) )
			{
				// no more space available ... break
				break;
			}
			else
			{
				// add the seperator and update the length accordingly
				lstrcat( pszBuffer, szSeperator );
				dwLength -= StringLengthInBytes( szSeperator );
			}
		}
	}

	// release memories
	__free( pszTemp );
	__free( pszValue );
}

// ***************************************************************************
// Routine Description:
//		Gets the value from arrRecord and copies it to pszValue using 
//      proper format. 
//
// Arguments:
//      [ in ] pColumn			:  format info.
//      [ in ] dwColumn			:  no of columns
//      [ in ] arrRecord		: value to be formatted
//      [ out ] pszValue		: output string
//      [ in ] szArraySeperator : seperator used.
//  
// Return Value:
//      NONE
// 
// ***************************************************************************
VOID __GetValue( PTCOLUMNS pColumn, 
				 DWORD dwColumn, TARRAY arrRecord, 
				 LPTSTR pszValue, LPCTSTR szArraySeperator )
{
	// local variables
	LPVOID pData = NULL;						// data to be passed to formatter function
	TARRAY arrTemp = NULL;
	LPCTSTR pszTemp = NULL;
	__STRING_64 szFormat = NULL_STRING;	// format

	// variables used in formatting time
	DWORD dwReturn = 0;
	SYSTEMTIME systime = { 0 };

	// init first
	lstrcpy( pszValue, NULL_STRING );

	// get the column value and do formatting appropriately
	switch( pColumn->dwFlags & SR_TYPE_MASK )
	{
	case SR_TYPE_STRING:
		{
			// identify the format to be used
			if ( pColumn->dwFlags & SR_VALUEFORMAT )
				lstrcpy( szFormat, pColumn->szFormat );
			else
				lstrcpy( szFormat, _T( "%s" ) );		// default format

			// copy the value to the temporary buffer based on the flags specified
			if ( pColumn->dwFlags & SR_ARRAY )
			{
				// get the value into buffer first - AVOIDING PREFIX BUGS
				arrTemp = DynArrayItem( arrRecord, dwColumn );
				if ( arrTemp == NULL )
					return;

				// form the array of values into one single string with ',' seperated
				__PrepareString( arrTemp, pszValue, pColumn->dwWidth, szFormat, szArraySeperator );
			}
			else
			{
				// get the value into buffer first - AVOIDING PREFIX BUGS
				pszTemp = DynArrayItemAsString( arrRecord, dwColumn );
				if ( pszTemp == NULL )
					return;

				// now copy the value into buffer
				FORMAT_STRING( pszValue, szFormat, _X( pszTemp ) );
			}

			// switch case completed
			break;
		}

	case SR_TYPE_NUMERIC:
		{
			// identify the format to be used
			if ( pColumn->dwFlags & SR_VALUEFORMAT )
				lstrcpy( szFormat, pColumn->szFormat );
			else
				lstrcpy( szFormat, _T( "%d" ) );		// default format

			// copy the value to the temporary buffer based on the flags specified
			if ( pColumn->dwFlags & SR_ARRAY )
			{
				// get the value into buffer first - AVOIDING PREFIX BUGS
				arrTemp = DynArrayItem( arrRecord, dwColumn );
				if ( arrTemp == NULL )
					return;

				// form the array of values into one single string with ',' seperated
				__PrepareString( arrTemp, pszValue, pColumn->dwWidth, szFormat, _T( ", " ) );
			}
			else 
			{
				// get the value using format specified
				FORMAT_STRING( pszValue, szFormat, DynArrayItemAsDWORD( arrRecord, dwColumn ) );
			}

			// switch case completed
			break;
		}
	
	case SR_TYPE_FLOAT:
		{
			// identify the format to be used
			// NOTE: for this type, format needs to be specified
			// if not, value displayed is unpredictable
			if ( pColumn->dwFlags & SR_VALUEFORMAT )
				lstrcpy( szFormat, pColumn->szFormat );
			else
				lstrcpy( szFormat, _T( "%f" ) );		// default format

			// copy the value to the temporary buffer based on the flags specified
			if ( pColumn->dwFlags & SR_ARRAY )
			{
				// get the value into buffer first - AVOIDING PREFIX BUGS
				arrTemp = DynArrayItem( arrRecord, dwColumn );
				if ( arrTemp == NULL )
					return;

				// form the array of values into one single string with ',' seperated
				__PrepareString( arrTemp, pszValue, pColumn->dwWidth, szFormat, szArraySeperator );
			}
			else
			{
				// get the value using format specified
				FORMAT_STRING( pszValue, szFormat, DynArrayItemAsFloat( arrRecord, dwColumn ) );
			}

			// switch case completed
			break;
		}

	case SR_TYPE_DOUBLE:
		{
			// identify the format to be used
			// NOTE: for this type, format needs to be specified
			// if not, value displayed is unpredictable
			if ( pColumn->dwFlags & SR_VALUEFORMAT )
				lstrcpy( szFormat, pColumn->szFormat );
			else
				lstrcpy( szFormat, _T( "%f" ) );		// default format

			// copy the value to the temporary buffer based on the flags specified
			if ( pColumn->dwFlags & SR_ARRAY )
			{
				// get the value into buffer first - AVOIDING PREFIX BUGS
				arrTemp = DynArrayItem( arrRecord, dwColumn );
				if ( arrTemp == NULL )
					return;

				// form the array of values into one single string with ',' seperated
				__PrepareString( arrTemp, pszValue, pColumn->dwWidth, szFormat, szArraySeperator );
			}
			else
			{
				// get the value using format specified
				FORMAT_STRING( pszValue, szFormat, DynArrayItemAsDouble( arrRecord, dwColumn ) );
			}

			// switch case completed
			break;
		}

	case SR_TYPE_TIME:
		{
			// get the time in the required format
			systime = DynArrayItemAsSystemTime( arrRecord, dwColumn );

			// get the time in current locale format
			dwReturn = GetTimeFormat( LOCALE_USER_DEFAULT, LOCALE_NOUSEROVERRIDE, 
				&systime, NULL, pszValue, MAX_STRING_LENGTH );

			// check the result
			if ( dwReturn == 0 )
			{
				// save the error info that has occurred
				SaveLastError();
				lstrcpy( pszValue, GetReason() );
			}

			// switch case completed
			break;
		}

	case SR_TYPE_CUSTOM:
		{
			// check whether function pointer is specified or not
			// if not specified, error
			if ( pColumn->pFunction == NULL )
				return;			// function ptr not specified ... error

			// determine the data to be passed to the formatter function
			pData = pColumn->pFunctionData;
			if ( pData == NULL ) // function data is not defined
				pData = pColumn;		// the current column info itself as data

			// call the custom function
			( *pColumn->pFunction)( dwColumn, arrRecord, pData, pszValue );

			// switch case completed
			break;
		}

	case SR_TYPE_DATE:
	case SR_TYPE_DATETIME:
	default:
		{
			// this should not occur ... still
			lstrcpy( pszValue, NULL_STRING );

			// switch case completed
			break;
		}
	}

	// user wants to display "N/A", when the value is empty, copy that
	if ( lstrlen( pszValue ) == 0 && pColumn->dwFlags & SR_SHOW_NA_WHEN_BLANK )
	{
		// copy N/A
		lstrcpy( pszValue, V_NOT_AVAILABLE );
	}
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//
// Return Value:
// 
// ***************************************************************************
VOID __DisplayTextWrapped( FILE* fp, LPTSTR pszValue, LPCTSTR pszSeperator, DWORD dwWidth )
{
	// local variables
	LPTSTR pszBuffer = NULL;
	LPCTSTR pszRestValue = NULL;
	DWORD dwTemp = 0, dwLength = 0, dwSepLength = 0;

	// check the input
	if ( pszValue == NULL || dwWidth == 0 || fp == NULL )
		return;

	// allocate buffer
	dwLength = StringLengthInBytes( pszValue );
	if ( dwLength < dwWidth )
		dwLength = dwWidth;

	// ...
	pszBuffer = __calloc( dwLength + 5, sizeof( TCHAR ) );
	if ( pszBuffer == NULL )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		lstrcpy( pszValue, NULL_STRING );			// null-ify the remaining text
		return;
	}

	// determine the length of the seperator
	dwSepLength = 0;
	if ( pszSeperator != NULL )
		dwSepLength = StringLengthInBytes( pszSeperator );

	// determine the length of the data that can be displayed in this row
	dwTemp = 0;
	dwLength = 0;
	while ( 1 )
	{
		pszRestValue = NULL;
		if ( pszSeperator != NULL )
			pszRestValue = FindString( pszValue, pszSeperator, dwLength );

		// check whether seperator is found or not
		if ( pszRestValue != NULL )
		{
			// determine the position
			dwTemp = StringLengthInBytes( pszValue ) - StringLengthInBytes( pszRestValue ) + dwSepLength;

			// check the length
			if ( dwTemp >= dwWidth )
			{
				// string position exceed the max. width
				if ( dwLength == 0 || dwTemp == dwWidth )
					dwLength = dwWidth;

				// break from the loop
				break;
			}

			// store the current position
			dwLength = dwTemp;
		}
		else
		{
			// check if length is determined or not .. if not required width itself is length
			if ( dwLength == 0 || ((StringLengthInBytes( pszValue ) - dwLength) > dwWidth) )
 				dwLength = dwWidth;
			else if ( StringLengthInBytes( pszValue ) <= (LONG) dwWidth )
				dwLength = StringLengthInBytes( pszValue );
	
			// break the loop
			break;
		}
	}

	// get the partial value that has to be displayed
	lstrcpyn( pszBuffer, pszValue, dwLength + 1 );			// +1 for NULL character
	AdjustStringLength( pszBuffer, dwWidth, FALSE );		// adjust the string
	ShowMessage( fp, pszBuffer );							// display the value

	// change the buffer contents so that it contains rest of the undisplayed text
	lstrcpy( pszBuffer, pszValue );
	if ( StringLengthInBytes( pszValue ) > (LONG) dwLength )
		lstrcpy( pszValue, pszBuffer + dwLength );
	else
		lstrcpy( pszValue, _T( "" ) );

	// release the memory allocated
	__free( pszBuffer );
}

// ***************************************************************************
// Routine Description:
//		Displays the arrData in Tabular form.
//		  
// Arguments:
//      [ in ] fp			: Output Device
//      [ in ] dwColumns	: no. of columns
//      [ in ] pColumns		: Header strings
//      [ in ] dwFlags		: flags
//      [ in ] arrData		: data to be shown
//
// Return Value:
//      NONE
// 
// ***************************************************************************
VOID __ShowAsTable( FILE* fp, DWORD dwColumns, 
				    PTCOLUMNS pColumns, DWORD dwFlags, TARRAY arrData )
{
	// local variables
	DWORD dwCount = 0;							// holds the count of the records
	DWORD i = 0, j = 0, k = 0;					// looping variables
	DWORD dwColumn = 0;
	LONG lLastColumn = 0;
	DWORD dwMultiLineColumns = 0;
	BOOL bNeedSpace = FALSE;
	BOOL bPadLeft = FALSE;
	TARRAY arrRecord = NULL;
	TARRAY arrMultiLine = NULL;
	LPCTSTR pszData = NULL;
	LPCTSTR pszSeperator = NULL;
	__STRING_4096 szValue = NULL_STRING;	// custom value formatter

	// constants
	const DWORD cdwColumn = 0;
	const DWORD cdwSeperator = 1;
	const DWORD cdwData = 2;

	// create an multi-line data display helper array
	arrMultiLine = CreateDynamicArray();
	if ( arrMultiLine == NULL )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return;
	}

	// check whether header has to be displayed or not
	if ( ! ( dwFlags & SR_NOHEADER ) )
	{
		// 
		// header needs to be displayed

		// traverse thru the column headers and display
		bNeedSpace = FALSE;
		for ( i = 0; i < dwColumns; i++ )
		{
			//	check whether user wants to display this column or not
			if ( pColumns[ i ].dwFlags & SR_HIDECOLUMN ) 
				continue;		// user doesn't want this column to be displayed .. skip

			// determine the padding direction
			bPadLeft = FALSE;
			if ( pColumns[ i ].dwFlags & SR_ALIGN_LEFT )
				bPadLeft = TRUE;
			else 
			{ 
				switch( pColumns[ i ].dwFlags & SR_TYPE_MASK )
				{
				case SR_TYPE_NUMERIC:
				case SR_TYPE_FLOAT:
				case SR_TYPE_DOUBLE:
					bPadLeft = TRUE;
					break;
				}
			}

			// check if column header seperator is needed or not and based on that show
			if ( bNeedSpace == TRUE )
			{
				// show space as column header seperator
				DISPLAY_MESSAGE( fp, _T( " " ) );
			}

			// print the column heading
			// NOTE: column will be displayed either by expanding or shrinking
			//		 based on the length of the column heading as well as width of the column
			FORMAT_STRING_EX( szValue, _T( "%s" ), 
				pColumns[ i ].szColumn, pColumns[ i ].dwWidth, bPadLeft );
			DISPLAY_MESSAGE( fp, szValue );	// column heading

			// inform that from next time onward display column header separator
			bNeedSpace = TRUE;
		}

		// display the new line character ... seperation b/w headings and separator line
		DISPLAY_MESSAGE( fp, _T( "\n" ) );
	
		//	display the seperator chars under each column header
		bNeedSpace = FALSE;
		for ( i = 0; i < dwColumns; i++ )
		{
			//	check whether user wants to display this column or not
			if ( pColumns[ i ].dwFlags & SR_HIDECOLUMN ) 
				continue;		// user doesn't want this column to be displayed .. skip
			
			// check if column header seperator is needed or not and based on that show
			if ( bNeedSpace == TRUE )
			{
				// show space as column header seperator
				DISPLAY_MESSAGE( fp, _T( " " ) );
			}

			//	display seperator based on the required column width
			DISPLAY_MESSAGE( fp, Replicate( szValue, _T( "=" ), pColumns[ i ].dwWidth ) );

			// inform that from next time onward display column header separator
			bNeedSpace = TRUE;
		}

		// display the new line character ... seperation b/w headings and actual data
		DISPLAY_MESSAGE( fp, _T( "\n" ) );
	}
	
	//
	// start displaying

	// get the total no. of records available
	dwCount = DynArrayGetCount( arrData );

	// traverse thru the records one-by-one
	for( i = 0; i < dwCount; i++ )
	{
		// clear the existing value
		lstrcpy( szValue, NULL_STRING );

		// get the pointer to the current record
		arrRecord = DynArrayItem( arrData, i );
		if ( arrRecord == NULL )
			continue;

		// traverse thru the columns and display the values
		bNeedSpace = FALSE;
		for ( j = 0; j < dwColumns; j++ )
		{
			// sub-local variables used in this loop
			DWORD dwTempWidth = 0;
			BOOL bTruncation = FALSE;

			//	check whether user wants to display this column or not
			if ( pColumns[ j ].dwFlags & SR_HIDECOLUMN ) 
				continue;		// user doesn't want this column to be displayed .. skip
			
			// get the value of the column
			// NOTE: CHECK IF USER ASKED NOT TO TRUNCATE THE DATA OR NOT
			if ( pColumns[ j ].dwFlags & SR_NO_TRUNCATION )
			{
				bTruncation = TRUE;
				dwTempWidth = pColumns[ j ].dwWidth;
				pColumns[ j ].dwWidth = SIZE_OF_ARRAY( szValue );
			}

			// prepare the value
			__GetValue( &pColumns[ j ], j, arrRecord, szValue, _T( ", " ) );

			// determine the padding direction
			bPadLeft = FALSE;
			if ( bTruncation == FALSE )
			{
				if ( pColumns[ j ].dwFlags & SR_ALIGN_LEFT )
					bPadLeft = TRUE;
				else 
				{ 
					switch( pColumns[ j ].dwFlags & SR_TYPE_MASK )
					{
					case SR_TYPE_NUMERIC:
					case SR_TYPE_FLOAT:
					case SR_TYPE_DOUBLE:
						bPadLeft = TRUE;
						break;
					}
				}

				// adjust ...
				AdjustStringLength( szValue, pColumns[ j ].dwWidth, bPadLeft );
			}
			
			// reset the width of the current column if it is modified
			if ( bTruncation == TRUE )
				pColumns[ j ].dwWidth = dwTempWidth;

			// check if column header seperator is needed or not and based on that show
			if ( bNeedSpace == TRUE )
			{
				// show space as column header seperator
				DISPLAY_MESSAGE( fp, _T( " " ) );
			}

			// now display the value
			if ( pColumns[ j ].dwFlags & SR_WORDWRAP )
			{
				// display the text ( might be partial )
				__DisplayTextWrapped( fp, szValue, _T( ", " ), pColumns[ j ].dwWidth );

				// check if any info is left to be displayed
				if ( StringLengthInBytes( szValue ) != 0 )
				{
					LONG lIndex = 0;
					lIndex = DynArrayAppendRow( arrMultiLine, 3 );
					if ( lIndex != -1 )
					{
						DynArraySetDWORD2( arrMultiLine, lIndex, cdwColumn, j );
						DynArraySetString2( arrMultiLine, lIndex, cdwData, szValue, 0 );
						DynArraySetString2( arrMultiLine, lIndex, cdwSeperator, _T( ", " ), 0 );
					}
				}
			}
			else
			{
				DISPLAY_MESSAGE( fp, szValue );
			}

			// inform that from next time onward display column header separator
			bNeedSpace = TRUE;
		}

		// display the new line character ... seperation b/w two record
		DISPLAY_MESSAGE( fp, _T( "\n" ) );

		// now display the multi-line column values
		dwMultiLineColumns = DynArrayGetCount( arrMultiLine );
		while( dwMultiLineColumns != 0 )
		{
			// reset
			dwColumn = 0;
			lLastColumn = -1;
			bNeedSpace = FALSE;

			// ...
			for( j = 0; j < dwMultiLineColumns; j++ )
			{
				// ge the column number
				dwColumn = DynArrayItemAsDWORD2( arrMultiLine, j, cdwColumn );

				// show spaces till the current column from the last column
				for( k = lLastColumn + 1; k < dwColumn; k++ )
				{
					//	check whether user wants to display this column or not
					if ( pColumns[ k ].dwFlags & SR_HIDECOLUMN ) 
						continue;		// user doesn't want this column to be displayed .. skip
					
					// check if column header seperator is needed or not and based on that show
					if ( bNeedSpace == TRUE )
					{
						// show space as column header seperator
						DISPLAY_MESSAGE( fp, _T( " " ) );
					}

					//	display seperator based on the required column width
					DISPLAY_MESSAGE( fp, Replicate( szValue, _T( " " ), pColumns[ k ].dwWidth ) );

					// inform that from next time onward display column header separator
					bNeedSpace = TRUE;
				}

				// update the last column
				lLastColumn = dwColumn;

				// check if column header seperator is needed or not and based on that show
				if ( bNeedSpace == TRUE )
				{
					// show space as column header seperator
					DISPLAY_MESSAGE( fp, _T( " " ) );
				}

				// get the seperator and data
				pszData = DynArrayItemAsString2( arrMultiLine, j, cdwData );
				pszSeperator = DynArrayItemAsString2( arrMultiLine, j, cdwSeperator );
				if ( pszData == NULL || pszSeperator == NULL )
					continue;

				// display the information
				lstrcpyn( szValue, pszData, SIZE_OF_ARRAY( szValue ) );
				__DisplayTextWrapped( fp, szValue, pszSeperator, pColumns[ dwColumn ].dwWidth );

				// update the multi-line array with rest of the line
				if ( StringLengthInBytes( szValue ) == 0 )
				{
					// data in this column is completely displayed ... remove it
					DynArrayRemove( arrMultiLine, j );

					// update the indexes
					j--;
					dwMultiLineColumns--;
				}
				else
				{
					// update the multi-line array with the remaining value
					DynArraySetString2( arrMultiLine, j, cdwData, szValue, 0 );
				}
			}

			// display the new line character ... seperation b/w two lines
			DISPLAY_MESSAGE( fp, _T( "\n" ) );
		}
	}

	// destroy the array
	DestroyDynamicArray( &arrMultiLine );
}

// ***************************************************************************
// Routine Description:
//		Displays the  in List format
//		  
// Arguments:
//      [ in ] fp			: Output Device
//      [ in ] dwColumns	: no. of columns
//      [ in ] pColumns		: Header strings
//      [ in ] dwFlags		: flags
//      [ in ] arrData		: data to be shown
//
// Return Value:
//      NONE
// 
// ***************************************************************************
VOID __ShowAsList( FILE* fp, DWORD dwColumns, 
				   PTCOLUMNS pColumns, DWORD dwFlags, TARRAY arrData )
{
	// local variables
	DWORD dwCount = 0;			// holds the count of all records
	DWORD i  = 0, j = 0;		// looping variables
	DWORD dwTempWidth = 0;
	DWORD dwMaxColumnLen = 0;	// holds the length of the which max. among all the columns
	LPTSTR pszTemp = NULL;
	TARRAY arrRecord = NULL;
	__STRING_64 szBuffer = NULL_STRING;
	__STRING_4096 szValue = NULL_STRING;	// custom value formatter

	// find out the max. length among all the column headers
	dwMaxColumnLen = 0;
	for ( i = 0; i < dwColumns; i++ )
	{
		if ( dwMaxColumnLen < ( DWORD ) StringLengthInBytes( pColumns[ i ].szColumn ) )
			dwMaxColumnLen = StringLengthInBytes( pColumns[ i ].szColumn );
	}
	
	//
	// start displaying the data

	// get the total no. of records available
	dwCount = DynArrayGetCount( arrData );

	// get the total no. of records available
	for( i = 0; i < dwCount; i++ )
	{
		// get the pointer to the current record
		arrRecord = DynArrayItem( arrData, i );
		if ( arrRecord == NULL )
			continue;

		// traverse thru the columns and display the values
		for ( j = 0; j < dwColumns; j++)
		{
			// clear the existing value
			lstrcpy( szValue, NULL_STRING );

			//	check whether user wants to display this column or not
			if ( pColumns[ j ].dwFlags & SR_HIDECOLUMN ) 
				continue;		// user doesn't want this column to be displayed .. skip

			// display the column heading and its value
			// ( heading will be displayed based on the max. column length )
			FORMAT_STRING_EX( szValue, _T( "%s:" ), 
				pColumns[ j ].szColumn, dwMaxColumnLen + 2, FALSE );
			DISPLAY_MESSAGE( fp, szValue );
			
			// get the value of the column
			dwTempWidth = pColumns[ j ].dwWidth;				// save the current width
			pColumns[ j ].dwWidth = SIZE_OF_ARRAY( szValue );	// change the width
			__GetValue( &pColumns[ j ], j, arrRecord, szValue, _T( "\n" ) );
			pColumns[ j ].dwWidth = dwTempWidth;		// restore the original width

			// display the [ list of ] values
			pszTemp = _tcstok( szValue, _T( "\n" ) );
			while ( pszTemp != NULL )
			{
				// display the value
				DISPLAY_MESSAGE( fp, pszTemp );
				pszTemp = _tcstok( NULL, _T( "\n" ) );
				if ( pszTemp != NULL )
				{
					// prepare the next line
					FORMAT_STRING_EX( szBuffer, _T( "%s" ), _T( " " ), 
						dwMaxColumnLen + 2, FALSE );
					DISPLAY_MESSAGE( fp, _T( "\n" ) );
					DISPLAY_MESSAGE( fp, szBuffer );
				}
			}

			// display the next line character seperation b/w two fields
			DISPLAY_MESSAGE( fp, _T( "\n" ) );
		}

		// display the new line character ... seperation b/w two records
		// NOTE: do this only if there are some more records
		if ( i + 1 < dwCount )
		{
			DISPLAY_MESSAGE( fp, _T( "\n" ) );
		}
	}
}

// ***************************************************************************
// Routine Description:
//     Displays the arrData in CSV form.
//		  
// Arguments:
//      [ in ] fp			: Output Device
//      [ in ] dwColumns	: no. of columns
//      [ in ] pColumns		: Header strings
//      [ in ] dwFlags		: flags
//      [ in ] arrData		: data to be shown
//
// Return Value:
//      NONE
// 
// ***************************************************************************
VOID __ShowAsCSV( FILE* fp, DWORD dwColumns, 
				  PTCOLUMNS pColumns, DWORD dwFlags, TARRAY arrData )
{
	// local variables
	DWORD dwCount = 0;			// holds the count of all records
	DWORD i  = 0, j = 0;		// looping variables
	DWORD dwTempWidth = 0;
	BOOL bNeedComma = FALSE;
	TARRAY arrRecord = NULL;
	__STRING_4096 szValue = NULL_STRING;

	// check whether header has to be displayed or not
	if ( ! ( dwFlags & SR_NOHEADER ) )
	{
		// 
		// header needs to be displayed

		// first display the columns ... with comma seperated
		bNeedComma = FALSE;
		for ( i = 0; i < dwColumns; i++ )
		{
			//	check whether user wants to display this column or not
			if ( pColumns[ i ].dwFlags & SR_HIDECOLUMN ) 
				continue;		// user doesn't want this column to be displayed .. skip

			// check whether we need to display ',' or not and then display
			if ( bNeedComma == TRUE )
			{
				// ',' has to be displayed
				DISPLAY_MESSAGE( fp, _T( "," ) );
			}

			// display the column heading
			DISPLAY_MESSAGE1( fp, szValue, _T( "\"%s\"" ), pColumns[ i ].szColumn );

			// inform that from next time onwards we need to display comma before data
			bNeedComma = TRUE;
		}

		// new line character
		DISPLAY_MESSAGE( fp, _T( "\n" ) );
	}
	
	//
	// start displaying the data

	// get the total no. of records available
	dwCount = DynArrayGetCount( arrData );

	// get the total no. of records available
	for( i = 0; i < dwCount; i++ )
	{
		// get the pointer to the current record
		arrRecord = DynArrayItem( arrData, i );
		if ( arrRecord == NULL )
			continue;

		// traverse thru the columns and display the values
		bNeedComma = FALSE;
		for ( j = 0; j < dwColumns; j++ )
		{
			// clear the existing value
			lstrcpy( szValue, NULL_STRING );

			//	check whether user wants to display this column or not
			if ( pColumns[ j ].dwFlags & SR_HIDECOLUMN ) 
				continue;		// user doesn't want this column to be displayed .. skip

			// get the value of the column
			dwTempWidth = pColumns[ j ].dwWidth;			// save the current width
			pColumns[ j ].dwWidth = SIZE_OF_ARRAY( szValue );		// change the width
			__GetValue( &pColumns[ j ], j, arrRecord, szValue, _T( "," ) );
			pColumns[ j ].dwWidth = dwTempWidth;		// restore the original width

			// check whether we need to display ',' or not and then display
			if ( bNeedComma == TRUE )
			{
				// ',' has to be displayed
				DISPLAY_MESSAGE( fp, _T( "," ) );
			}

			// print the value
			DISPLAY_MESSAGE( fp, _T( "\"" ) );
			DISPLAY_MESSAGE( fp, szValue );
			DISPLAY_MESSAGE( fp, _T( "\"" ) );

			// inform that from next time onwards we need to display comma before data
			bNeedComma = TRUE;
		}

		// new line character
		DISPLAY_MESSAGE( fp, _T( "\n" ) );
	}
}

//
// public functions ... exposed to external world
//

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//
// Return Value:
// 
// ***************************************************************************
VOID ShowResults( DWORD dwColumns, PTCOLUMNS pColumns, DWORD dwFlags, TARRAY arrData )
{
	// just call the main function ... with stdout
	ShowResults2( stdout, dwColumns, pColumns, dwFlags, arrData );
}

// ***************************************************************************
// Routine Description:
//      Show the resuls (arrData) on the screen.
//		  
// Arguments:
//      [ in ] dwColumns	: No. of Columns to be shown
//      [ in ] pColumns		: Columns header
//      [ in ] dwFlags		: Required format
//      [ in ] arrData		: Data to be displayed.
//
// Return Value:
//      NONE
// 
// ***************************************************************************
VOID ShowResults2( FILE* fp, DWORD dwColumns, PTCOLUMNS pColumns, DWORD dwFlags, TARRAY arrData )
{
	// local variables
	
	//
	//	Display the information in the format specified
	//
	switch( dwFlags & SR_FORMAT_MASK )
	{
	case SR_FORMAT_TABLE:
		{
			// show the data in table format
			__ShowAsTable( fp, dwColumns, pColumns, dwFlags, arrData );

			// switch case completed
			break;
		}

	case SR_FORMAT_LIST:
		{
			// show the data in table format
			__ShowAsList( fp, dwColumns, pColumns, dwFlags, arrData );

			// switch case completed
			break;
		}

	case SR_FORMAT_CSV:
		{
			// show the data in table format
			__ShowAsCSV( fp, dwColumns, pColumns, dwFlags, arrData );

			// switch case completed
			break;
		}

	default:
		{
			// invalid format requested by the user
			break;
		}
	}

	// flush the memory onto the file buffer
	fflush( fp );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\lib\rmtconnectivity.c ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//  
// 	  RmtConnectivity.c
//  
//  Abstract:
//  
// 	  This modules implements remote connectivity functionality for all the 
//	  command line tools.
//   
//  Author:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 13-Nov-2000
//  
//  Revision History:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 13-Sep-2000 : Created It.
//  
// *********************************************************************************
#include "pch.h"
#include "cmdline.h"
#include "cmdlineres.h"

//
// constants / defines / enumerations
//
#define STR_INPUT_PASSWORD			GetResString( IDS_STR_INPUT_PASSWORD )
#define ERROR_LOCAL_CREDENTIALS		GetResString( IDS_ERROR_LOCAL_CREDENTIALS )

// share names
#define SHARE_IPC			_T( "IPC$" )
#define SHARE_ADMIN			_T( "ADMIN$" )
#define SHARE_CDRIVE		_T( "C$" )
#define SHARE_DDRIVE		_T( "D$" )

// externs
extern BOOL g_bWinsockLoaded;

// ***************************************************************************
// Routine Description:
//		Validates the server name
//		  
// Arguments:
//		[ in ] pszServer		: server name
//
// Return Value:
//		TRUE if valid, FALSE if not valid
// ***************************************************************************
BOOL IsValidIPAddress( LPCTSTR pszAddress )
{
	// local variables
	DWORD dw = 0;
	LONG lValue = 0;
	LPTSTR pszTemp = NULL;
	DWORD dwOctets[ 4 ] = { 0, 0, 0, 0 };
	__MAX_SIZE_STRING szBuffer = NULL_STRING;

	// check the buffer
	if ( pszAddress == NULL )
	{
		SetLastError( DNS_ERROR_INVALID_TYPE );
		SaveLastError();
		return FALSE;
	}

	// parse and get the octet values
	lstrcpy( szBuffer, pszAddress );
	pszTemp = _tcstok( szBuffer, _T( "." ) );
	while ( pszTemp != NULL )
	{
		// check whether the current octet is numeric or not
		if ( IsNumeric( pszTemp, 10, FALSE ) == FALSE )
			return FALSE;

		// get the value of the octet and check the range
		lValue = AsLong( pszTemp, 10 );
		if ( lValue < 0 || lValue >= 255 )
			return FALSE;

		// fetch next octet
		dwOctets[ dw++ ] = lValue;
		pszTemp = _tcstok( NULL, _T( "." ) );
	}

	// check and return
	if ( dw != 4 )
	{
		SetLastError( DNS_ERROR_INVALID_TYPE );
		SaveLastError();
		return FALSE;
	}

	// now check the special condition
	// ?? time being this is not implemented ??

	// return the validity of the ip address
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Validates the server name
//		  
// Arguments:
//		[ in ] pszServer		: server name
//
// Return Value:
//		TRUE if valid, FALSE if not valid
// ***************************************************************************
BOOL IsValidServer( LPCTSTR pszServer )
{
	// local variables
	LONG lIndex = 0;
	LPTSTR pszTemp = NULL;
	LPCTSTR pszComputerName = NULL;
	TCHAR pszInvalidChars[] = _T( " \\/[]:|<>+=;,?$#()!@^\"`{}*%" );

	// check for NULL ... if NULL return
	if ( pszServer == NULL )
		return TRUE;

	// check the length of the string
	if ( lstrlen( pszServer ) == 0 )
		return TRUE;

	// check whether this is a valid ip address or not
	if ( IsValidIPAddress( pszServer ) == TRUE )
		return TRUE;			// it's valid ip address ... so is valid server name

	// now check the server name for invalid characters 
	//						\/[]:|<>+=;,?$#()!@^"`{}*%
	pszTemp = __calloc( lstrlen( pszServer ) + 5, sizeof( TCHAR ) );
	if ( pszTemp == NULL )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// copy the contents into the internal buffer and check for the invalid characters
	lstrcpy( pszTemp, pszServer );
	for( lIndex = 0; lIndex < lstrlen( pszInvalidChars ); lIndex++ )
	{
		if ( _tcschr( pszTemp, pszInvalidChars[ lIndex ] ) != NULL )
		{
			SetLastError( ERROR_BAD_NETPATH );
			SaveLastError();
			__free( pszTemp );
			return FALSE;
		}
	}

	// copy the server name again ... and check if the computer name by any chance is a number
	lstrcpy( pszTemp, pszServer );
	pszComputerName = _tcstok( pszTemp, _T( "." ) );
	if ( pszComputerName == NULL )
		pszComputerName = pszServer;

	// check for the numeric system name .. 
	if ( pszComputerName[ 0 ] != _T('-') && IsNumeric(pszComputerName, 10, FALSE) == TRUE )
	{
		SetLastError( ERROR_INVALID_COMPUTERNAME );
		SaveLastError();
		__free( pszTemp );
		return FALSE;
	}

	// valid server name
	__free( pszTemp );
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Get HostName  from ipaddress.
//
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL GetHostByIPAddr( LPCTSTR pszServer, LPTSTR pszHostName, BOOL bNeedFQDN )
{
	// local variables
	WSADATA wsaData;
	DWORD dwErr = 0;
	DWORD dwLength = 0;
    ULONG ulInetAddr  = 0;
	HOSTENT* pHostEnt = NULL;
	BOOL bReturnValue = FALSE;
	LPSTR pszTemp = NULL;
	WORD wVersionRequested = 0;

	// check whether winsock module is loaded into process memory or not
	// if not load it now
	if ( g_bWinsockLoaded == FALSE )
	{
		// initiate the use of Ws2_32.dll by a process ( VERSION: 2.2 )
		wVersionRequested = MAKEWORD( 2, 2 );
		dwErr = WSAStartup( wVersionRequested, &wsaData );
		if ( dwErr != 0 ) 
		{
			SetLastError( WSAGetLastError() );
			__free( pszTemp );
			return FALSE;
		}

		// remember that winsock library is loaded
		g_bWinsockLoaded = TRUE;
	}

	// allocate the a buffer to store the server name in multibyte format
	dwLength = lstrlen( pszServer );
	pszTemp = ( LPSTR ) __calloc( dwLength + 5,  sizeof( CHAR ) );
	if ( pszTemp == NULL )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// convert the server name into multibyte string. this is because curren winsock implementation
	// works only with multibyte string and there is no support for unicode
    GetAsMultiByteString( pszServer, pszTemp, dwLength );
        
    // inet_addr function converts a string containing an Internet Protocol (Ipv4) 
	// dotted address into a proper address for the IN_ADDR structure.
    ulInetAddr  = inet_addr( pszTemp );
	if ( ulInetAddr == INADDR_NONE )
	{
		__free( pszTemp );
		SetLastError( STG_E_UNKNOWN );
		SaveLastError();
		return FALSE;
	}
        
    // gethostbyaddr function retrieves the host information corresponding to a network address.
    pHostEnt = gethostbyaddr( (LPSTR) &ulInetAddr, sizeof( ulInetAddr ), PF_INET );
    if ( pHostEnt == NULL )
    {
		// ?? DONT KNOW WHAT TO DO IF THIS FUNCTION FAILS ??
		// ?? CURRENTLY SIMPLY RETURNS FALSE              ??
        return FALSE;
	}

	// release the memory allocated so far
	__free( pszTemp );

	// check whether user wants the FQDN name or NetBIOS name
	// if NetBIOS name is required, then remove the domain name
	pszTemp = pHostEnt->h_name;
	if ( bNeedFQDN == FALSE )
		pszTemp = strtok( pHostEnt->h_name, "." );
	
	// we got info in char type ... convert it into current build's compatible type
	GetCompatibleStringFromMultiByte( pszTemp, pszHostName, MAX_COMPUTERNAME_LENGTH );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Connects to the remote Server. This is stub function.
//		  
// Arguments:
//		[ in ] pszServer	: server name
//		[ in ] pszUser		: user
//		[ in ] pszPassword	: password
//
// Return Value:
//		NO_ERROR if succeeds other appropriate error code if failed
// 
// ***************************************************************************
DWORD ConnectServer( LPCTSTR pszServer, LPCTSTR pszUser, LPCTSTR pszPassword )
{
	// invoke the original function and return the result
	return ConnectServer2( pszServer, pszUser, pszPassword, _T( "IPC$" ) );
}

// ***************************************************************************
// Routine Description:
//		Connects to the remote Server
//		  
// Arguments:
//		[ in ] pszServer	: server name
//		[ in ] pszUser		: user
//		[ in ] pszPassword	: password
//      [ in ] pszShare		: share name to connect to
//
// Return Value:
//		NO_ERROR if succeeds other appropriate error code if failed
// 
// ***************************************************************************
DWORD ConnectServer2( LPCTSTR pszServer, LPCTSTR pszUser, 
					  LPCTSTR pszPassword, LPCTSTR pszShare )
{
	// local variables
	DWORD dwSize = 0;
	DWORD dwConnect = 0;
	NETRESOURCE resource;
	__MAX_SIZE_STRING szUNCPath = NULL_STRING;
	__MAX_SIZE_STRING szMachine = NULL_STRING;

	// if the server name refers to the local system, 
	// and also, if user credentials were not supplied, then treat
	// connection is successfull
	// if user credentials information is passed for local system, 
	// return ERROR_LOCAL_CREDENTIALS
	if ( IsLocalSystem( pszServer ) == TRUE )
	{
		if ( pszUser == NULL || lstrlen( pszUser ) == 0 )
			return NO_ERROR;			// local sustem
		else
		{
			SetLastError( E_LOCAL_CREDENTIALS );
			SetReason( ERROR_LOCAL_CREDENTIALS );
			return E_LOCAL_CREDENTIALS;
		}
	}

	// check whether the server name is in UNC format or not
	// if yes, extract the server name
	lstrcpy( szMachine, pszServer );			// assume server is not in UNC format
	if ( IsUNCFormat( pszServer ) == TRUE )
		lstrcpy( szMachine, pszServer + 2 );

	// validate the server name
	if ( IsValidServer( szMachine ) == FALSE )
		return GetLastError();

	//
	// prepare the machine name into UNC format
	lstrcpy( szUNCPath, NULL_STRING );
	if ( pszShare == NULL || lstrlen( pszShare ) == 0 )
	{
		FORMAT_STRING( szUNCPath, _T( "\\\\%s" ), szMachine );
	}
	else
	{
		FORMAT_STRING2( szUNCPath, _T( "\\\\%s\\%s" ), szMachine, pszShare );
	}

	// initialize the resource structure with null
	ZeroMemory( &resource, sizeof( resource ) );
	resource.dwType = RESOURCETYPE_ANY;
	resource.lpProvider = NULL;
	resource.lpLocalName = NULL;
	resource.lpRemoteName = szUNCPath;

	// try establishing connection to the remote server
	dwConnect = WNetAddConnection2( &resource, pszPassword, pszUser, 0 );

	// check the result
	// and if error has occured, get the appropriate message
	switch( dwConnect )
	{
	case NO_ERROR:
		{
			dwConnect = 0;
			SetReason( NULL_STRING );		// clear the error message

			// check for the OS compatibilty
			if ( IsCompatibleOperatingSystem( GetTargetVersion( szMachine ) ) == FALSE )
			{
				// since the connection already established close the connection
				CloseConnection( szMachine );

				// set the error text
				SetReason( ERROR_OS_INCOMPATIBLE );
				dwConnect = ERROR_EXTENDED_ERROR;
			}

			// ...
			break;
		}

	case ERROR_EXTENDED_ERROR:
		WNetSaveLastError();		// save the extended error
		break;

	default:
		// set the last error
		SaveLastError();
		break;
	}

	// return the result of the connection establishment
	return dwConnect;
}

// ***************************************************************************
// Routine Description:
//	
//	Closes the remote connection.
//	  
// Arguments:
// [in] szServer		--remote machine to close the connection
//  
// Return Value:
//
// DWORD				--NO_ERROR if succeeds.
//						--Possible error codes.
// 
// ***************************************************************************
DWORD CloseConnection( LPCTSTR szServer )
{
	// forcibly close the connection
	return CloseConnection2( szServer, NULL, CI_CLOSE_BY_FORCE | CI_SHARE_IPC );
}

// ***************************************************************************
// Routine Description:
//		Closes the established connection on the remote system.
//		  
// Arguments:
//		[ in ] szServer		-   Null terminated string that specifies the remote 
//								system name. NULL specifie the local system.
// 
// Return Value:
// 
// ***************************************************************************
DWORD CloseConnection2( LPCTSTR szServer, LPCTSTR pszShare, DWORD dwFlags )
{
	// local variables
	BOOL bForce = FALSE;
	DWORD dwCancel = 0;
	__STRING_256 szMachine = NULL_STRING;
	__STRING_256 szUNCServer = NULL_STRING;

	// check the server contents ... it might be referring to the local system
	if ( szServer == NULL || lstrlen( szServer ) == 0 )
		return NO_ERROR;

	// check whether the server name is in UNC format or not
	// if yes, extract the server name
	lstrcpy( szMachine, szServer );			// assume server is not in UNC format
	if ( IsUNCFormat( szServer ) == TRUE )
		lstrcpy( szMachine, szServer + 2 );

	// determine if share name has to appended or not for this server name
	if ( dwFlags & CI_SHARE_IPC )
	{
		// --> \\server\ipc$
		FORMAT_STRING2( szUNCServer, _T( "\\\\%s\\%s" ), szMachine, SHARE_IPC );
	}
	else if ( dwFlags & CI_SHARE_ADMIN )
	{
		// --> \\server\admin$
		FORMAT_STRING2( szUNCServer, _T( "\\\\%s\\%s" ), szMachine, SHARE_ADMIN );
	}
	else if ( dwFlags & CI_SHARE_CDRIVE )
	{
		// --> \\server\c$
		FORMAT_STRING2( szUNCServer, _T( "\\\\%s\\%s" ), szMachine, SHARE_CDRIVE );
	}
	else if ( dwFlags & CI_SHARE_DDRIVE )
	{
		// --> \\server\d$
		FORMAT_STRING2( szUNCServer, _T( "\\\\%s\\%s" ), szMachine, SHARE_DDRIVE );
	}
	else if ( dwFlags & CI_SHARE_CUSTOM && pszShare != NULL )
	{
		// --> \\server\share
		FORMAT_STRING2( szUNCServer, _T( "\\\\%s\\%s" ), szMachine, pszShare );
	}
	else
	{
		// --> \\server
		FORMAT_STRING( szUNCServer, _T( "\\\\%s" ), szMachine );
	}

	// determine whether to close this connection forcibly or not
	if ( dwFlags & CI_CLOSE_BY_FORCE )
		bForce = TRUE;

	//
	// cancel the connection
	dwCancel = WNetCancelConnection2( szUNCServer, 0, bForce );

	// check the result
	// and if error has occured, get the appropriate message
	switch( dwCancel )
	{
	case NO_ERROR:
		dwCancel = 0;
		SetReason( NULL_STRING );		// clear the error message
		break;

	case ERROR_EXTENDED_ERROR:
		WNetSaveLastError();		// save the extended error
		break;

	default:
		// set the last error
		SaveLastError();
		break;
	}

	// return the result of the cancelling the connection 
	return dwCancel;
}

// ***************************************************************************
// Routine Description:
//		Determines whether server name is specified in UNC format or not
//		  
// Arguments:
//		[ in ] pszServer	: server name
//  
// Return Value:
//		TRUE	: if specified in UNC format
//		FALSE	: if not specified in UNC format
// 
// ***************************************************************************
BOOL IsUNCFormat( LPCTSTR pszServer )
{
	return ( StringCompare( pszServer, _T( "\\\\" ), TRUE, 2 ) == 0 );
}

// ***************************************************************************
// Routine Description:
//		Determines whether server is referring to the local or remote system
//		  
// Arguments:
//		[ in ] pszServer	: server name
//  
// Return Value:
//		TRUE	: for local system
//		FALSE	: for remote system
// 
// ***************************************************************************
BOOL IsLocalSystem( LPCTSTR pszServer )
{
	// local variables
	DWORD dwSize = 0;
	__STRING_128 szTemp = NULL_STRING;
	__STRING_128 szHostName = NULL_STRING;

	// if the server name is empty, it is a local system
	if ( pszServer == NULL || lstrlen( pszServer ) == 0 )
		return TRUE;

	// get the local system name and check
	dwSize = SIZE_OF_ARRAY( szTemp );
	GetComputerNameEx( ComputerNamePhysicalNetBIOS, szTemp, &dwSize );
	if ( StringCompare( szTemp, pszServer, TRUE, 0 ) == 0 )
		return TRUE;

    //Check pszSever having IP address
	if( IsValidIPAddress( pszServer ) == TRUE )
	{
		// resolve the ipaddress to host name
		if( GetHostByIPAddr( pszServer, szHostName, FALSE ) == FALSE )
			return FALSE;

		// check if resolved ipaddress matches with the current host name
		if ( StringCompare( szTemp, szHostName, TRUE, 0 ) == 0 )
			return TRUE;			// local system
		else
			return FALSE;			// not a local system
	}

	// get the local system fully qualified name and check
	dwSize = SIZE_OF_ARRAY( szTemp );
	GetComputerNameEx( ComputerNamePhysicalDnsFullyQualified, szTemp, &dwSize );
	if ( StringCompare( szTemp, pszServer, TRUE, 0 ) == 0 )
		return TRUE;

	// finally ... it might not be local system name
	// NOTE: there are chances for us to not be able to identify whether
	//       the system name specified is a local system or remote system
	return FALSE;
}

// ***************************************************************************
// Routine Description:
//
// Establishes a connection to the remote system.
//
// Arguments:
//
// [in] szServer				--Nullterminated string to establish the conection.
//								--NULL connects to the local system.
// [in] szUserName			--Null terminated string that specifies the user name.
//								--NULL takes the default user name.
// [in] dwUserLength			--Length of the username.
// [in] szPassword			--Null terminated string that specifies the password
//								--NULL takes the default user name's password.
// [in] dwPasswordLength		--Length of the password.
// [in] bNeedPassword			--True if password is required to establish the connection.
//								--False if it is not required.
//  
// Return Value:
//
// BOOL							--True if it establishes
//								--False if it fails.
// 
// ***************************************************************************
BOOL EstablishConnection( LPCTSTR szServer, LPTSTR szUserName, DWORD dwUserLength, 
						  LPTSTR szPassword, DWORD dwPasswordLength, BOOL bNeedPassword )
{
	// local variables
	DWORD dwSize = 0;
	BOOL bDefault = FALSE;
	DWORD dwConnectResult = 0;
	__MAX_SIZE_STRING szBuffer = NULL_STRING;

	// clear the error .. if any
	SetLastError( NO_ERROR );

	// sometime users want the utility to prompt for the password
	// check what user wants the utility to do
	if ( bNeedPassword == TRUE && szPassword != NULL && lstrcmp( szPassword, _T( "*" ) ) == 0 )
	{
		// user wants the utility to prompt for the password
		// so skip this part and let the flow directly jump the password acceptance part
	}
	else
	{
		// try to establish connection to the remote system with the credentials supplied
		bDefault = FALSE;
		if ( lstrlen( szUserName ) == 0 )
		{
			// user name is empty
			// so, it is obvious that password will also be empty
			// even if password is specified, we have to ignore that
			bDefault = TRUE;
			dwConnectResult = ConnectServer( szServer, NULL, NULL );
		}
		else
		{
			// credentials were supplied
			// but password might not be specified ... so check and act accordingly
			dwConnectResult = ConnectServer( szServer, 
				szUserName, ( bNeedPassword == FALSE ? szPassword : NULL ) );

			// determine whether to close the connection or retain the connection
			if ( bNeedPassword == FALSE )
			{
				// connection might have already established .. so to be on safer side
				// we inform the caller not to close the connection
				bDefault = TRUE;
			}
		}

		// check the result ... if successful in establishing connection ... return
		if ( dwConnectResult == NO_ERROR )
		{
			// if connected with default params, pass additional information to the caller
			if ( bDefault == TRUE )
				SetLastError( I_NO_CLOSE_CONNECTION );

			return TRUE;
		}

		// now check the kind of error occurred
		switch( dwConnectResult )
		{
		case ERROR_LOGON_FAILURE:
		case ERROR_INVALID_PASSWORD:
			break;

		case ERROR_SESSION_CREDENTIAL_CONFLICT:
			// user credentials conflict ... client has to handle this situation
			// wrt to this module, connection to the remote system is success
			SetLastError( dwConnectResult );
			return TRUE;

		case E_LOCAL_CREDENTIALS:
			// user credentials not accepted for local system
			SetLastError( E_LOCAL_CREDENTIALS );
			SetReason( ERROR_LOCAL_CREDENTIALS );
			return TRUE;

		case ERROR_DUP_NAME:
		case ERROR_NETWORK_UNREACHABLE:
		case ERROR_HOST_UNREACHABLE:
		case ERROR_PROTOCOL_UNREACHABLE:
		case ERROR_INVALID_NETNAME:
			// change the error code so that user gets correct message
			SetLastError( ERROR_NO_NETWORK );
			SaveLastError();
			SetLastError( dwConnectResult );		// reset the error code
			return FALSE;

		default:
			return FALSE;		// no use of accepting the password .. return failure
			break;
		}

		// if failed in establishing connection to the remote terminal
		// even if the password is specifed, then there is nothing to do ... simply return failure
		if ( bNeedPassword == FALSE )
			return FALSE;
	}

	// check whether user name is specified or not
	// if not, get the local system's current user name under whose credentials, the process
	// is running
	if ( lstrlen( szUserName ) == 0 )
	{
		// get the user name
		if ( GetUserNameEx( NameSamCompatible, szUserName, &dwUserLength ) == FALSE )
		{
			// error occured while trying to get the current user info
			SaveLastError();
			return FALSE;
		}
	}

	// format the user name
	// if ( _tcschr( szUserName, _T( '\\' ) ) == NULL )
	// {
	//	// server not present in user name ... prepare ... this is only for display purpose
	//	FORMAT_STRING2( szBuffer, _T( "%s\\%s" ), szServer, szUserName );
	//	lstrcpy( szUserName, szBuffer );
	// }

	// accept the password from the user
	FORMAT_STRING( szBuffer, STR_INPUT_PASSWORD, szUserName );
	WriteConsole( GetStdHandle( STD_ERROR_HANDLE ), 
		szBuffer, lstrlen( szBuffer ), &dwSize, NULL );
	GetPassword( szPassword, MAX_PASSWORD_LENGTH );

	// now again try to establish the connection using the currently
	// supplied credentials
	dwConnectResult = ConnectServer( szServer, szUserName, szPassword );
	if ( dwConnectResult == NO_ERROR )
		return TRUE;			// connection established successfully

	// now check the kind of error occurred
	switch( dwConnectResult )
	{
	case ERROR_SESSION_CREDENTIAL_CONFLICT:
		// user credentials conflict ... client has to handle this situation
		// wrt to this module, connection to the remote system is success
		SetLastError( dwConnectResult );
		return TRUE;

	case E_LOCAL_CREDENTIALS:
		// user credentials not accepted for local system
		SetLastError( E_LOCAL_CREDENTIALS );
		SetReason( ERROR_LOCAL_CREDENTIALS );
		return TRUE;

	case ERROR_DUP_NAME:
	case ERROR_NETWORK_UNREACHABLE:
	case ERROR_HOST_UNREACHABLE:
	case ERROR_PROTOCOL_UNREACHABLE:
	case ERROR_INVALID_NETNAME:
		// change the error code so that user gets correct message
		SetLastError( ERROR_NO_NETWORK );
		SaveLastError();
		SetLastError( dwConnectResult );		// reset the error code
		return FALSE;
	}

	// return the failure
	return FALSE;
}

// ***************************************************************************
// Routine Description:
//		Establishes a connection to the remote system.
//
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL EstablishConnection2( PTCONNECTIONINFO pci ) 
{
	// local variables
	LPCTSTR pszShare = NULL;

	// clear the error .. if any
	SetLastError( NO_ERROR );

	// identify the share to which user wishes to connect to
	if ( pci->dwFlags & CI_SHARE_IPC )
		pszShare = SHARE_IPC;
	else if ( pci->dwFlags & CI_SHARE_ADMIN )
		pszShare = SHARE_ADMIN;
	else if ( pci->dwFlags & CI_SHARE_CDRIVE )
		pszShare = SHARE_CDRIVE;
	else if ( pci->dwFlags & CI_SHARE_DDRIVE )
		pszShare = SHARE_DDRIVE;

	return TRUE;
}

// ***************************************************************************
// Routine Description:
//
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
DWORD GetTargetVersion( LPCTSTR pszServer )
{
	// local variables
	DWORD dwVersion = 0;
	LPTSTR pszUNCPath = NULL;
	NET_API_STATUS netstatus;
	SERVER_INFO_101* pSrvInfo = NULL;

	// check the inputs
	if ( pszServer == NULL )
		return 0;

	// allocate memory for having server in UNC format
	pszUNCPath = (LPTSTR) __calloc( lstrlen( pszServer ) + 5, sizeof( TCHAR ) );
	if ( pszUNCPath == NULL )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return 0;
	}

	// prepare the server name in UNC format
	lstrcpy( pszUNCPath, pszServer );
	if ( lstrlen( pszServer ) != 0 && IsUNCFormat( pszServer ) == FALSE )
	{
		FORMAT_STRING( pszUNCPath, _T( "\\\\%s" ), pszServer );
	}

	// get the version info
	netstatus = NetServerGetInfo( pszUNCPath, 101, (LPBYTE*) &pSrvInfo );

	// release the memory
	__free( pszUNCPath );

	// check the result .. if not success return
	if ( netstatus != NERR_Success )
		return 0;

	// prepare the version
	dwVersion = 0;
	if ( ( pSrvInfo->sv101_type & SV_TYPE_NT ) )
	{
		//	--> "sv101_version_major" least significant 4 bits of the byte, 
		//		the major release version number of the operating system.
		//	--> "sv101_version_minor"  the minor release version number of the operating system
		dwVersion = (pSrvInfo->sv101_version_major & MAJOR_VERSION_MASK) * 1000;
		dwVersion += pSrvInfo->sv101_version_minor;
	}

	// release the buffer allocated by network api
	NetApiBufferFree( pSrvInfo );

	// return
	return dwVersion;
}

// ***************************************************************************
// Routine Description:
//
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL IsCompatibleOperatingSystem( DWORD dwVersion )
{
	// OS version above windows 2000 is compatible
	return (dwVersion >= 5000);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\power\resource.h ===
#define IDS_ON                          1
#define IDS_OFF                         2
#define IDS_HIBER_INVALID_STATE         3
#define IDS_HIBER_UNSUPPORTED           4
#define IDS_HIBER_CONFIG_FAIL           5
#define IDS_SYSCAP_FAIL                 6
#define IDS_INVALID_CMDLINE_PARAM       7
#define IDS_OUT_OF_MEMORY               8
#define IDS_SCHEME_NOT_FOUND            9
#define IDS_ACTIVE_SCHEME_INVALID       10
#define IDS_SCHEME_ALREADY_EXISTS       11
#define IDS_SCHEME_CREATE_FAIL          12
#define IDS_CURRENTLY_ACTIVE_SCHEME     13

#define IDS_SCHEME_NAME                 14
#define IDS_SCHEME_DESCRIPTION          15
#define IDS_MONITOR_TIMEOUT_AC          16
#define IDS_MONITOR_TIMEOUT_DC          17
#define IDS_DISK_TIMEOUT_AC             18
#define IDS_DISK_TIMEOUT_DC             19
#define IDS_STANDBY_TIMEOUT_AC          20
#define IDS_STANDBY_TIMEOUT_DC          21
#define IDS_HIBER_TIMEOUT_AC            22
#define IDS_HIBER_TIMEOUT_DC            23

#define IDS_USAGE_START                 24
#define IDS_USAGE_01                    25
#define IDS_USAGE_02                    26
#define IDS_USAGE_03                    27
#define IDS_USAGE_04                    28
#define IDS_USAGE_05                    29
#define IDS_USAGE_06                    30
#define IDS_USAGE_07                    31
#define IDS_USAGE_08                    32
#define IDS_USAGE_09                    33
#define IDS_USAGE_10                    34
#define IDS_USAGE_11                    35
#define IDS_USAGE_12                    36
#define IDS_USAGE_13                    37
#define IDS_USAGE_14                    38
#define IDS_USAGE_15                    39
#define IDS_USAGE_16                    40
#define IDS_USAGE_17                    41
#define IDS_USAGE_18                    42
#define IDS_USAGE_19                    43
#define IDS_USAGE_20                    44
#define IDS_USAGE_21                    45
#define IDS_USAGE_22                    46
#define IDS_USAGE_23                    47
#define IDS_USAGE_24                    48
#define IDS_USAGE_25                    49
#define IDS_USAGE_26                    50
#define IDS_USAGE_27                    51
#define IDS_USAGE_28                    52
#define IDS_USAGE_29                    53
#define IDS_USAGE_30                    54
#define IDS_USAGE_31                    55
#define IDS_USAGE_32                    56
#define IDS_USAGE_33                    57
#define IDS_USAGE_34                    58
#define IDS_USAGE_35                    59
#define IDS_USAGE_36                    60
#define IDS_USAGE_37                    61
#define IDS_USAGE_38                    62
#define IDS_USAGE_39                    63
#define IDS_USAGE_40                    64
#define IDS_USAGE_41                    65
#define IDS_USAGE_42                    66
#define IDS_USAGE_43                    67
#define IDS_USAGE_44                    68
#define IDS_USAGE_45                    69
#define IDS_USAGE_46                    70
#define IDS_USAGE_47                    71
#define IDS_USAGE_48                    72
#define IDS_USAGE_49                    73
#define IDS_USAGE_50                    74
#define IDS_USAGE_51                    75
#define IDS_USAGE_52                    76
#define IDS_USAGE_53                    77
#define IDS_USAGE_54                    78
#define IDS_USAGE_55                    79
#define IDS_USAGE_56                    80
#define IDS_USAGE_57                    81
#define IDS_USAGE_58                    82
#define IDS_USAGE_59                    83
#define IDS_USAGE_60                    84
#define IDS_USAGE_61                    85
#define IDS_USAGE_END                   86

#define IDS_LIST_HEADER1                87
#define IDS_LIST_HEADER2                88
#define IDS_QUERY_HEADER1               89
#define IDS_QUERY_HEADER2               90
#define IDS_QUERY_FOOTER                91
#define IDS_UNEXPECTED_ERROR            92
#define IDS_HIBER_OUT_OF_RANGE          93
#define IDS_MINUTES                     94
#define IDS_DISABLED                    95
#define IDS_UNSUPPORTED                 96
#define IDS_STANDBY_WARNING             97
#define IDS_HIBER_WARNING               98
#define IDS_MONITOR_WARNING             99
#define IDS_DISK_WARNING               100
#define IDS_HIBER_PRIVILEGE            101
#define IDS_DEFAULT_FILENAME           102

#define IDS_THROTTLE_AC                103
#define IDS_THROTTLE_DC                104
#define IDS_THROTTLE_NONE              105
#define IDS_THROTTLE_CONSTANT          106
#define IDS_THROTTLE_DEGRADE           107
#define IDS_THROTTLE_ADAPTIVE          108
#define IDS_THROTTLE_UNKNOWN           109
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\power\powercfg.h ===
#ifndef __POWERCFG_H
#define __POWERCFG_H

/*++

Copyright (c) 2001  Microsoft Corporation
 
Module Name:
 
    powercfg.h
 
Abstract:
 
    Allows users to view and modify power schemes and system power settings
    from the command line.  May be useful in unattended configuration and
    for headless systems.
 
Author:
 
    Ben Hertzberg (t-benher) 1-Jun-2001
 
Revision History:
 
    Ben Hertzberg (t-benher) 4-Jun-2001   - import/export added
    Ben Hertzberg (t-benher) 1-Jun-2001   - created it.
 
--*/


#include <tchar.h>

// main options
#define CMDOPTION_LIST           _T( "l|list" )
#define CMDOPTION_QUERY          _T( "q|query" )
#define CMDOPTION_CREATE         _T( "c|create" )
#define CMDOPTION_DELETE         _T( "d|delete" )
#define CMDOPTION_SETACTIVE      _T( "s|setactive" )
#define CMDOPTION_CHANGE         _T( "x|change" )
#define CMDOPTION_HIBERNATE      _T( "h|hibernate" )
#define CMDOPTION_EXPORT         _T( "e|export" )
#define CMDOPTION_IMPORT         _T( "i|import" )
#define CMDOPTION_USAGE          _T( "?|help" )

// 'change' sub-options
#define CMDOPTION_MONITOR_OFF_AC _T( "monitor-timeout-ac" )
#define CMDOPTION_MONITOR_OFF_DC _T( "monitor-timeout-dc" )
#define CMDOPTION_DISK_OFF_AC    _T( "disk-timeout-ac" )
#define CMDOPTION_DISK_OFF_DC    _T( "disk-timeout-dc" )
#define CMDOPTION_STANDBY_AC     _T( "standby-timeout-ac" )
#define CMDOPTION_STANDBY_DC     _T( "standby-timeout-dc" )
#define CMDOPTION_HIBER_AC       _T( "hibernate-timeout-ac" )
#define CMDOPTION_HIBER_DC       _T( "hibernate-timeout-dc" )
#define CMDOPTION_THROTTLE_AC    _T( "processor-throttle-ac" )
#define CMDOPTION_THROTTLE_DC    _T( "processor-throttle-dc" )

// 'import' / 'export' sub-options
#define CMDOPTION_FILE           _T( "f|file" )

// main option indicies
#define CMDINDEX_LIST            0
#define CMDINDEX_QUERY           1
#define CMDINDEX_CREATE          2
#define CMDINDEX_DELETE          3
#define CMDINDEX_SETACTIVE       4
#define CMDINDEX_CHANGE          5
#define CMDINDEX_HIBERNATE       6
#define CMDINDEX_EXPORT          7
#define CMDINDEX_IMPORT          8
#define CMDINDEX_USAGE           9

#define NUM_MAIN_CMDS            10 // max(main option CMDINDEX_xxx) + 1

// 'change' sub-option indices
#define CMDINDEX_MONITOR_OFF_AC  10
#define CMDINDEX_MONITOR_OFF_DC  11
#define CMDINDEX_DISK_OFF_AC     12
#define CMDINDEX_DISK_OFF_DC     13
#define CMDINDEX_STANDBY_AC      14
#define CMDINDEX_STANDBY_DC      15
#define CMDINDEX_HIBER_AC        16
#define CMDINDEX_HIBER_DC        17
#define CMDINDEX_THROTTLE_AC     18
#define CMDINDEX_THROTTLE_DC     19
#define CMDINDEX_FILE            20

#define NUM_CMDS                 21 // max(any CMDINDEX_xxx) + 1



// Other constants


// Exit values
#define EXIT_SUCCESS        0
#define EXIT_FAILURE        1  


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scheduledtasks\commonheaderfiles.h ===
/******************************************************************************

	Copyright(c) Microsoft Corporation

	Module Name:

		CommonHeaderFiles.h

	Abstract:

		This module includes the common files needed for all the source files
		in this project.

	Author:

		G.Surender Reddy  30-oct-2000 

	Revision History:

		G.Surender Reddy  30-oct-2000 : Created it
		Venu Gopal Choudary 12-Mar-2001 : Added run.h and end.h 
		
******************************************************************************/ 

#ifndef __COMHEADERFILES_H
#define __COMHEADERFILES_H

//common include files needed for all other cpp files in this project

#include "scheduledtasks.h"
#include "resource.h"
#include "create.h"
#include "query.h"
#include "change.h"
#include "run.h"
#include "end.h"

#endif //__COMHEADERFILES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\power\powercfg.c ===
/*++

Copyright (c) 2001  Microsoft Corporation
 
Module Name:
 
    powercfg.c
 
Abstract:
 
    Allows users to view and modify power schemes and system power settings
    from the command line.  May be useful in unattended configuration and
    for headless systems.
 
Author:
 
    Ben Hertzberg (t-benher) 1-Jun-2001
 
Revision History:
 
    Ben Hertzberg (t-benher) 15-Jun-2001   - CPU throttle added
    Ben Hertzberg (t-benher)  4-Jun-2001   - import/export added
    Ben Hertzberg (t-benher)  1-Jun-2001   - created it.
 
--*/

// standard win includes

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>


// app-specific includes

#include <stdio.h>
#include "cmdline.h"
#include "cmdlineres.h"
#include "powrprof.h"
#include "powercfg.h"
#include "resource.h"

// app-specific structures

// structure to manage the scheme list information.
// note that descriptions are currently not visible in the
// GUI tool (as of 6-1-2001), so they are not visible in this
// app either, although the framework is already there if
// someone decides to add the descriptions at a later date.
typedef struct _SCHEME_LIST
{
    LIST_ENTRY                      le;
    UINT                            uiID;
    LPTSTR                          lpszName;
    LPTSTR                          lpszDesc;
    PPOWER_POLICY                   ppp;
    PMACHINE_PROCESSOR_POWER_POLICY pmppp;
} SCHEME_LIST, *PSCHEME_LIST;

// structure to manage the change parameters
typedef struct _CHANGE_PARAM
{
    BOOL   bVideoTimeoutAc;
    ULONG  ulVideoTimeoutAc;
    BOOL   bVideoTimeoutDc;
    ULONG  ulVideoTimeoutDc;
    BOOL   bSpindownTimeoutAc;
    ULONG  ulSpindownTimeoutAc;
    BOOL   bSpindownTimeoutDc;
    ULONG  ulSpindownTimeoutDc;
    BOOL   bIdleTimeoutAc;
    ULONG  ulIdleTimeoutAc;
    BOOL   bIdleTimeoutDc;
    ULONG  ulIdleTimeoutDc;
    BOOL   bDozeS4TimeoutAc;
    ULONG  ulDozeS4TimeoutAc;
    BOOL   bDozeS4TimeoutDc;
    ULONG  ulDozeS4TimeoutDc;
    BOOL   bDynamicThrottleAc;
    LPTSTR lpszDynamicThrottleAc;
    BOOL  bDynamicThrottleDc;
    LPTSTR lpszDynamicThrottleDc;
} CHANGE_PARAM, *PCHANGE_PARAM;

// forward decl's

BOOL
DoList();

BOOL 
DoQuery(
    LPCTSTR lpszName,
    BOOL bNameSpecified
    );

BOOL 
DoCreate(
    LPTSTR lpszName
    );

BOOL 
DoDelete(
    LPCTSTR lpszName
    );

BOOL 
DoSetActive(
    LPCTSTR lpszName
    );

BOOL 
DoChange(
    LPCTSTR lpszName,
    PCHANGE_PARAM pcp
    );

BOOL
DoHibernate(
    LPCTSTR lpszBoolStr
    );

BOOL 
DoExport(
    LPCTSTR lpszName,
    LPCTSTR lpszFile
    );

BOOL 
DoImport(
    LPCTSTR lpszName,
    LPCTSTR lpszFile
    );

BOOL
DoUsage();

// global data

LPCTSTR    g_lpszErr = NULL_STRING; // string holding const error description
LPTSTR     g_lpszErr2 = NULL;       // string holding dyn-alloc error msg
TCHAR      g_lpszBuf[256];          // formatting buffer
BOOL       g_bHiberFileSupported = FALSE; // true iff hiberfile supported
BOOL       g_bHiberTimerSupported = FALSE; // true iff hibertimer supported
BOOL       g_bStandbySupported = FALSE; // true iff standby supported
BOOL       g_bMonitorPowerSupported = FALSE; // true iff has power support
BOOL       g_bDiskPowerSupported = FALSE; // true iff has power support
BOOL       g_bThrottleSupported = FALSE; // true iff has throttle support

// functions


DWORD _cdecl 
_tmain(
    DWORD     argc,
    LPCTSTR   argv[]
)
/*++
 
Routine Description:
 
    This routine is the main function.  It parses parameters and takes 
    apprpriate action.
 
Arguments:
 
    argc - indicates the number of arguments
    argv - array of null terminated strings indicating arguments.  See usage
           for actual meaning of arguments.
 
Return Value:
 
    EXIT_SUCCESS if successful
    EXIT_FAILURE if something goes wrong
 
--*/
{

    // command line flags
    BOOL     bList      = FALSE;
    BOOL     bQuery     = FALSE;
    BOOL     bCreate    = FALSE;
    BOOL     bDelete    = FALSE;
    BOOL     bSetActive = FALSE;
    BOOL     bChange    = FALSE;
    BOOL     bHibernate = FALSE;
    BOOL     bImport    = FALSE;
    BOOL     bExport    = FALSE;
    BOOL     bFile      = FALSE;
    BOOL     bUsage     = FALSE;
    
    // error status
    BOOL     bFail      = FALSE;
    
    // dummy
    INT      iDummy     = 1;
    
    // parse result value vars
    LPTSTR   lpszName = NULL;
    LPTSTR   lpszBoolStr = NULL;
    LPTSTR   lpszFile = NULL;
    LPTSTR   lpszThrottleAcStr = NULL;
    LPTSTR   lpszThrottleDcStr = NULL;

    CHANGE_PARAM tChangeParam;
    
    // parser info struct
    TCMDPARSER cmdOptions[NUM_CMDS];
  
    // system power caps struct
    SYSTEM_POWER_CAPABILITIES SysPwrCapabilities;

    // determine upper bound on input string length
    UINT     uiMaxInLen = 0;
    DWORD    dwIdx;
    for(dwIdx=1; dwIdx<argc; dwIdx++)
    {
        UINT uiCurLen = lstrlen(argv[dwIdx]);
        if (uiCurLen > uiMaxInLen)
        {
            uiMaxInLen = uiCurLen;
        }
    }
    
    // allocate space for scheme name and boolean string
    lpszName = LocalAlloc(LPTR,(uiMaxInLen+1)*sizeof(TCHAR));
    if (!lpszName)
    {
        DISPLAY_MESSAGE(stderr,GetResString(IDS_OUT_OF_MEMORY));
        return EXIT_FAILURE;
    }
    lpszBoolStr = LocalAlloc(LPTR,(uiMaxInLen+1)*sizeof(TCHAR));
    if (!lpszBoolStr)
    {
        LocalFree(lpszName);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_OUT_OF_MEMORY));
        return EXIT_FAILURE;
    }
    if (uiMaxInLen < (UINT)lstrlen(GetResString(IDS_DEFAULT_FILENAME)))
    {
        lpszFile = LocalAlloc(LPTR,(lstrlen(GetResString(IDS_DEFAULT_FILENAME))+1)*sizeof(TCHAR));
    }
    else
    {
        lpszFile = LocalAlloc(LPTR,(uiMaxInLen+1)*sizeof(TCHAR));
    }
    if (!lpszFile)
    {
        LocalFree(lpszName);
        LocalFree(lpszBoolStr);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_OUT_OF_MEMORY));
        return EXIT_FAILURE;
    }
    lpszThrottleAcStr = LocalAlloc(LPTR,(uiMaxInLen+1)*sizeof(TCHAR));
    if (!lpszThrottleAcStr)
    {
        LocalFree(lpszName);
        LocalFree(lpszBoolStr);
        LocalFree(lpszFile);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_OUT_OF_MEMORY));
        return EXIT_FAILURE;
    }
    lpszThrottleDcStr = LocalAlloc(LPTR,(uiMaxInLen+1)*sizeof(TCHAR));
    if (!lpszThrottleDcStr)
    {
        LocalFree(lpszThrottleAcStr);
        LocalFree(lpszName);
        LocalFree(lpszBoolStr);
        LocalFree(lpszFile);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_OUT_OF_MEMORY));
        return EXIT_FAILURE;
    }

    // initialize the allocated strings
    lstrcpy(lpszName,NULL_STRING);
    lstrcpy(lpszBoolStr,NULL_STRING);
    lstrcpy(lpszFile,GetResString(IDS_DEFAULT_FILENAME));
    lstrcpy(lpszThrottleAcStr,NULL_STRING);
    lstrcpy(lpszThrottleDcStr,NULL_STRING);
    

    // determine system capabilities
    if (GetPwrCapabilities(&SysPwrCapabilities)) 
    {
        g_bHiberFileSupported = SysPwrCapabilities.SystemS4;
        g_bHiberTimerSupported = 
            (SysPwrCapabilities.RtcWake >= PowerSystemHibernate);
        g_bStandbySupported = SysPwrCapabilities.SystemS1 | 
            SysPwrCapabilities.SystemS2 | 
            SysPwrCapabilities.SystemS3;
        g_bDiskPowerSupported = SysPwrCapabilities.DiskSpinDown;
        g_bThrottleSupported = SysPwrCapabilities.ProcessorThrottle;
        g_bMonitorPowerSupported  = SystemParametersInfo(
            SPI_GETLOWPOWERACTIVE,
            0, 
            &iDummy, 
            0
            );
        if (!g_bMonitorPowerSupported ) {
            g_bMonitorPowerSupported  = SystemParametersInfo(
                SPI_GETPOWEROFFACTIVE,
                0, 
                &iDummy, 
                0
                );
        }
    } 
    else 
    {
        g_lpszErr = GetResString(IDS_UNEXPECTED_ERROR);
        return EXIT_FAILURE;
    }
    
    
    //fill in the TCMDPARSER array
    
    // option 'list'
    cmdOptions[CMDINDEX_LIST].dwFlags       = CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_LIST].dwCount       = 1;
    cmdOptions[CMDINDEX_LIST].dwActuals     = 0;
    cmdOptions[CMDINDEX_LIST].pValue        = &bList;
    cmdOptions[CMDINDEX_LIST].pFunction     = NULL;
    cmdOptions[CMDINDEX_LIST].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_LIST].szOption,
        CMDOPTION_LIST
        );
    lstrcpy(
        cmdOptions[CMDINDEX_LIST].szValues,
        NULL_STRING
        );
    
    // option 'query'
    cmdOptions[CMDINDEX_QUERY].dwFlags       = CP_TYPE_TEXT | 
                                               CP_VALUE_OPTIONAL | 
                                               CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_QUERY].dwCount       = 1;
    cmdOptions[CMDINDEX_QUERY].dwActuals     = 0;
    cmdOptions[CMDINDEX_QUERY].pValue        = lpszName;
    cmdOptions[CMDINDEX_QUERY].pFunction     = NULL;
    cmdOptions[CMDINDEX_QUERY].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_QUERY].szOption,
        CMDOPTION_QUERY
        );
    lstrcpy(
        cmdOptions[CMDINDEX_QUERY].szValues,
        NULL_STRING
        );
    
    // option 'create'
    cmdOptions[CMDINDEX_CREATE].dwFlags       = CP_TYPE_TEXT | 
                                                CP_VALUE_MANDATORY | 
                                                CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_CREATE].dwCount       = 1;
    cmdOptions[CMDINDEX_CREATE].dwActuals     = 0;
    cmdOptions[CMDINDEX_CREATE].pValue        = lpszName;
    cmdOptions[CMDINDEX_CREATE].pFunction     = NULL;
    cmdOptions[CMDINDEX_CREATE].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_CREATE].szOption,
        CMDOPTION_CREATE
        );
    lstrcpy(
        cmdOptions[CMDINDEX_CREATE].szValues,
        NULL_STRING
        );
    
    // option 'delete'
    cmdOptions[CMDINDEX_DELETE].dwFlags       = CP_TYPE_TEXT | 
                                                CP_VALUE_MANDATORY | 
                                                CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_DELETE].dwCount       = 1;
    cmdOptions[CMDINDEX_DELETE].dwActuals     = 0;
    cmdOptions[CMDINDEX_DELETE].pValue        = lpszName;
    cmdOptions[CMDINDEX_DELETE].pFunction     = NULL;
    cmdOptions[CMDINDEX_DELETE].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_DELETE].szOption,
        CMDOPTION_DELETE
        );
    lstrcpy(
        cmdOptions[CMDINDEX_DELETE].szValues,
        NULL_STRING
        );
    
    // option 'setactive'
    cmdOptions[CMDINDEX_SETACTIVE].dwFlags       = CP_TYPE_TEXT | 
                                                   CP_VALUE_MANDATORY | 
                                                   CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_SETACTIVE].dwCount       = 1;
    cmdOptions[CMDINDEX_SETACTIVE].dwActuals     = 0;
    cmdOptions[CMDINDEX_SETACTIVE].pValue        = lpszName;
    cmdOptions[CMDINDEX_SETACTIVE].pFunction     = NULL;
    cmdOptions[CMDINDEX_SETACTIVE].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_SETACTIVE].szOption,
        CMDOPTION_SETACTIVE
        );
    lstrcpy(
        cmdOptions[CMDINDEX_SETACTIVE].szValues,
        NULL_STRING
        );
    
    // option 'change'
    cmdOptions[CMDINDEX_CHANGE].dwFlags       = CP_TYPE_TEXT | 
                                                CP_VALUE_MANDATORY | 
                                                CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_CHANGE].dwCount       = 1;
    cmdOptions[CMDINDEX_CHANGE].dwActuals     = 0;
    cmdOptions[CMDINDEX_CHANGE].pValue        = lpszName;
    cmdOptions[CMDINDEX_CHANGE].pFunction     = NULL;
    cmdOptions[CMDINDEX_CHANGE].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_CHANGE].szOption,
        CMDOPTION_CHANGE
        );
    lstrcpy(
        cmdOptions[CMDINDEX_CHANGE].szValues,
        NULL_STRING
        );
    
    // option 'hibernate'
    cmdOptions[CMDINDEX_HIBERNATE].dwFlags       = CP_TYPE_TEXT | 
                                                   CP_VALUE_MANDATORY | 
                                                   CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_HIBERNATE].dwCount       = 1;
    cmdOptions[CMDINDEX_HIBERNATE].dwActuals     = 0;
    cmdOptions[CMDINDEX_HIBERNATE].pValue        = lpszBoolStr;
    cmdOptions[CMDINDEX_HIBERNATE].pFunction     = NULL;
    cmdOptions[CMDINDEX_HIBERNATE].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_HIBERNATE].szOption,
        CMDOPTION_HIBERNATE
        );
    lstrcpy(
        cmdOptions[CMDINDEX_HIBERNATE].szValues,
        NULL_STRING
        );  
    
    // option 'export'
    cmdOptions[CMDINDEX_EXPORT].dwFlags       = CP_TYPE_TEXT | 
                                                CP_VALUE_MANDATORY | 
                                                CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_EXPORT].dwCount       = 1;
    cmdOptions[CMDINDEX_EXPORT].dwActuals     = 0;
    cmdOptions[CMDINDEX_EXPORT].pValue        = lpszName;
    cmdOptions[CMDINDEX_EXPORT].pFunction     = NULL;
    cmdOptions[CMDINDEX_EXPORT].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_EXPORT].szOption,
        CMDOPTION_EXPORT
        );
    lstrcpy(
        cmdOptions[CMDINDEX_EXPORT].szValues,
        NULL_STRING
        );  

    // option 'import'
    cmdOptions[CMDINDEX_IMPORT].dwFlags       = CP_TYPE_TEXT | 
                                                CP_VALUE_MANDATORY | 
                                                CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_IMPORT].dwCount       = 1;
    cmdOptions[CMDINDEX_IMPORT].dwActuals     = 0;
    cmdOptions[CMDINDEX_IMPORT].pValue        = lpszName;
    cmdOptions[CMDINDEX_IMPORT].pFunction     = NULL;
    cmdOptions[CMDINDEX_IMPORT].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_IMPORT].szOption,
        CMDOPTION_IMPORT
        );
    lstrcpy(
        cmdOptions[CMDINDEX_IMPORT].szValues,
        NULL_STRING
        );  

    // option 'usage'
    cmdOptions[CMDINDEX_USAGE].dwFlags       = CP_USAGE | 
                                               CP_MAIN_OPTION;
    cmdOptions[CMDINDEX_USAGE].dwCount       = 1;
    cmdOptions[CMDINDEX_USAGE].dwActuals     = 0;
    cmdOptions[CMDINDEX_USAGE].pValue        = &bUsage;
    cmdOptions[CMDINDEX_USAGE].pFunction     = NULL;
    cmdOptions[CMDINDEX_USAGE].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_USAGE].szOption,
        CMDOPTION_USAGE
        );
    lstrcpy(
        cmdOptions[CMDINDEX_USAGE].szValues,
        NULL_STRING
        );
    
    // sub-option 'monitor-timeout-ac'
    cmdOptions[CMDINDEX_MONITOR_OFF_AC].dwFlags       = CP_TYPE_UNUMERIC | 
                                                        CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_MONITOR_OFF_AC].dwCount       = 1;
    cmdOptions[CMDINDEX_MONITOR_OFF_AC].dwActuals     = 0;
    cmdOptions[CMDINDEX_MONITOR_OFF_AC].pValue        = 
        &tChangeParam.ulVideoTimeoutAc;
    cmdOptions[CMDINDEX_MONITOR_OFF_AC].pFunction     = NULL;
    cmdOptions[CMDINDEX_MONITOR_OFF_AC].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_MONITOR_OFF_AC].szOption,
        CMDOPTION_MONITOR_OFF_AC
        );
    lstrcpy(
        cmdOptions[CMDINDEX_MONITOR_OFF_AC].szValues,
        NULL_STRING
        );
    
    // sub-option 'monitor-timeout-dc'
    cmdOptions[CMDINDEX_MONITOR_OFF_DC].dwFlags       = CP_TYPE_UNUMERIC | 
                                                        CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_MONITOR_OFF_DC].dwCount       = 1;
    cmdOptions[CMDINDEX_MONITOR_OFF_DC].dwActuals     = 0;
    cmdOptions[CMDINDEX_MONITOR_OFF_DC].pValue        = 
        &tChangeParam.ulVideoTimeoutDc;
    cmdOptions[CMDINDEX_MONITOR_OFF_DC].pFunction     = NULL;
    cmdOptions[CMDINDEX_MONITOR_OFF_DC].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_MONITOR_OFF_DC].szOption,
        CMDOPTION_MONITOR_OFF_DC
        );
    lstrcpy(
        cmdOptions[CMDINDEX_MONITOR_OFF_DC].szValues,
        NULL_STRING
        );
    
    // sub-option 'disk-timeout-ac'
    cmdOptions[CMDINDEX_DISK_OFF_AC].dwFlags       = CP_TYPE_UNUMERIC | 
                                                     CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_DISK_OFF_AC].dwCount       = 1;
    cmdOptions[CMDINDEX_DISK_OFF_AC].dwActuals     = 0;
    cmdOptions[CMDINDEX_DISK_OFF_AC].pValue        = 
        &tChangeParam.ulSpindownTimeoutAc;
    cmdOptions[CMDINDEX_DISK_OFF_AC].pFunction     = NULL;
    cmdOptions[CMDINDEX_DISK_OFF_AC].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_DISK_OFF_AC].szOption,
        CMDOPTION_DISK_OFF_AC
        );
    lstrcpy(
        cmdOptions[CMDINDEX_DISK_OFF_AC].szValues,
        NULL_STRING
        );
    
    // sub-option 'disk-timeout-dc'
    cmdOptions[CMDINDEX_DISK_OFF_DC].dwFlags       = CP_TYPE_UNUMERIC | 
                                                     CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_DISK_OFF_DC].dwCount       = 1;
    cmdOptions[CMDINDEX_DISK_OFF_DC].dwActuals     = 0;
    cmdOptions[CMDINDEX_DISK_OFF_DC].pValue        = 
        &tChangeParam.ulSpindownTimeoutDc;
    cmdOptions[CMDINDEX_DISK_OFF_DC].pFunction     = NULL;
    cmdOptions[CMDINDEX_DISK_OFF_DC].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_DISK_OFF_DC].szOption,
        CMDOPTION_DISK_OFF_DC
        );
    lstrcpy(
        cmdOptions[CMDINDEX_DISK_OFF_DC].szValues,
        NULL_STRING
        );
    
    // sub-option 'standby-timeout-ac'
    cmdOptions[CMDINDEX_STANDBY_AC].dwFlags       = CP_TYPE_UNUMERIC | 
                                                    CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_STANDBY_AC].dwCount       = 1;
    cmdOptions[CMDINDEX_STANDBY_AC].dwActuals     = 0;
    cmdOptions[CMDINDEX_STANDBY_AC].pValue        = 
        &tChangeParam.ulIdleTimeoutAc;
    cmdOptions[CMDINDEX_STANDBY_AC].pFunction     = NULL;
    cmdOptions[CMDINDEX_STANDBY_AC].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_STANDBY_AC].szOption,
        CMDOPTION_STANDBY_AC
        );
    lstrcpy(
        cmdOptions[CMDINDEX_STANDBY_AC].szValues,
        NULL_STRING
        );
    
    // sub-option 'standby-timeout-dc'
    cmdOptions[CMDINDEX_STANDBY_DC].dwFlags       = CP_TYPE_UNUMERIC | 
                                                    CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_STANDBY_DC].dwCount       = 1;
    cmdOptions[CMDINDEX_STANDBY_DC].dwActuals     = 0;
    cmdOptions[CMDINDEX_STANDBY_DC].pValue        = 
        &tChangeParam.ulIdleTimeoutDc;
    cmdOptions[CMDINDEX_STANDBY_DC].pFunction     = NULL;
    cmdOptions[CMDINDEX_STANDBY_DC].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_STANDBY_DC].szOption,
        CMDOPTION_STANDBY_DC
        );
    lstrcpy(
        cmdOptions[CMDINDEX_STANDBY_DC].szValues,
        NULL_STRING
        );
    
    // sub-option 'hibernate-timeout-ac'
    cmdOptions[CMDINDEX_HIBER_AC].dwFlags       = CP_TYPE_UNUMERIC | 
                                                  CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_HIBER_AC].dwCount       = 1;
    cmdOptions[CMDINDEX_HIBER_AC].dwActuals     = 0;
    cmdOptions[CMDINDEX_HIBER_AC].pValue        = 
        &tChangeParam.ulDozeS4TimeoutAc;
    cmdOptions[CMDINDEX_HIBER_AC].pFunction     = NULL;
    cmdOptions[CMDINDEX_HIBER_AC].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_HIBER_AC].szOption,
        CMDOPTION_HIBER_AC
        );
    lstrcpy(
        cmdOptions[CMDINDEX_HIBER_AC].szValues,
        NULL_STRING
        );
    
    // sub-option 'hibernate-timeout-dc'
    cmdOptions[CMDINDEX_HIBER_DC].dwFlags       = CP_TYPE_UNUMERIC | 
                                                  CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_HIBER_DC].dwCount       = 1;
    cmdOptions[CMDINDEX_HIBER_DC].dwActuals     = 0;
    cmdOptions[CMDINDEX_HIBER_DC].pValue        = 
        &tChangeParam.ulDozeS4TimeoutDc;
    cmdOptions[CMDINDEX_HIBER_DC].pFunction     = NULL;
    cmdOptions[CMDINDEX_HIBER_DC].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_HIBER_DC].szOption,
        CMDOPTION_HIBER_DC
        );
    lstrcpy(
        cmdOptions[CMDINDEX_HIBER_DC].szValues,
        NULL_STRING
        );
    
    // sub-option 'processor-throttle-ac'
    cmdOptions[CMDINDEX_THROTTLE_AC].dwFlags       = CP_TYPE_TEXT | 
                                                     CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_THROTTLE_AC].dwCount       = 1;
    cmdOptions[CMDINDEX_THROTTLE_AC].dwActuals     = 0;
    cmdOptions[CMDINDEX_THROTTLE_AC].pValue        = lpszThrottleAcStr;
    cmdOptions[CMDINDEX_THROTTLE_AC].pFunction     = NULL;
    cmdOptions[CMDINDEX_THROTTLE_AC].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_THROTTLE_AC].szOption,
        CMDOPTION_THROTTLE_AC
        );
    lstrcpy(
        cmdOptions[CMDINDEX_THROTTLE_AC].szValues,
        NULL_STRING
        );

    // sub-option 'processor-throttle-dc'
    cmdOptions[CMDINDEX_THROTTLE_DC].dwFlags       = CP_TYPE_TEXT | 
                                                     CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_THROTTLE_DC].dwCount       = 1;
    cmdOptions[CMDINDEX_THROTTLE_DC].dwActuals     = 0;
    cmdOptions[CMDINDEX_THROTTLE_DC].pValue        = lpszThrottleDcStr;
    cmdOptions[CMDINDEX_THROTTLE_DC].pFunction     = NULL;
    cmdOptions[CMDINDEX_THROTTLE_DC].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_THROTTLE_DC].szOption,
        CMDOPTION_THROTTLE_DC
        );
    lstrcpy(
        cmdOptions[CMDINDEX_THROTTLE_DC].szValues,
        NULL_STRING
        );
    
    // sub-option 'file'
    cmdOptions[CMDINDEX_FILE].dwFlags       = CP_TYPE_TEXT | 
                                              CP_VALUE_MANDATORY;
    cmdOptions[CMDINDEX_FILE].dwCount       = 1;
    cmdOptions[CMDINDEX_FILE].dwActuals     = 0;
    cmdOptions[CMDINDEX_FILE].pValue        = lpszFile;
    cmdOptions[CMDINDEX_FILE].pFunction     = NULL;
    cmdOptions[CMDINDEX_FILE].pFunctionData = NULL;
    lstrcpy(
        cmdOptions[CMDINDEX_FILE].szOption,
        CMDOPTION_FILE
        );
    lstrcpy(
        cmdOptions[CMDINDEX_FILE].szValues,
        NULL_STRING
        );
    

    // parse parameters, take appropriate action
    if(DoParseParam(argc,argv,NUM_CMDS,cmdOptions))
    {
        
        // make sure only one command issued
        DWORD dwCmdCount = 0;
        DWORD dwParamCount = 0;
        for(dwIdx=0;dwIdx<NUM_CMDS;dwIdx++)
        {
            if (dwIdx < NUM_MAIN_CMDS)
            {
                dwCmdCount += cmdOptions[dwIdx].dwActuals;
            }
            else
            {
                dwParamCount += cmdOptions[dwIdx].dwActuals;
            }
        }
        
        // determine other flags
        bQuery     = (cmdOptions[CMDINDEX_QUERY].dwActuals != 0);
        bCreate    = (cmdOptions[CMDINDEX_CREATE].dwActuals != 0);
        bDelete    = (cmdOptions[CMDINDEX_DELETE].dwActuals != 0);
        bSetActive = (cmdOptions[CMDINDEX_SETACTIVE].dwActuals != 0);
        bChange    = (cmdOptions[CMDINDEX_CHANGE].dwActuals != 0);   
        bHibernate = (cmdOptions[CMDINDEX_HIBERNATE].dwActuals != 0);
        bExport    = (cmdOptions[CMDINDEX_EXPORT].dwActuals != 0);
        bImport    = (cmdOptions[CMDINDEX_IMPORT].dwActuals != 0);
        bFile      = (cmdOptions[CMDINDEX_FILE].dwActuals != 0);
        tChangeParam.bVideoTimeoutAc = 
            (cmdOptions[CMDINDEX_MONITOR_OFF_AC].dwActuals != 0);
        tChangeParam.bVideoTimeoutDc = 
            (cmdOptions[CMDINDEX_MONITOR_OFF_DC].dwActuals != 0);
        tChangeParam.bSpindownTimeoutAc = 
            (cmdOptions[CMDINDEX_DISK_OFF_AC].dwActuals != 0);
        tChangeParam.bSpindownTimeoutDc = 
            (cmdOptions[CMDINDEX_DISK_OFF_DC].dwActuals != 0);
        tChangeParam.bIdleTimeoutAc = 
            (cmdOptions[CMDINDEX_STANDBY_AC].dwActuals != 0);
        tChangeParam.bIdleTimeoutDc = 
            (cmdOptions[CMDINDEX_STANDBY_DC].dwActuals != 0);
        tChangeParam.bDozeS4TimeoutAc = 
            (cmdOptions[CMDINDEX_HIBER_AC].dwActuals != 0);
        tChangeParam.bDozeS4TimeoutDc = 
            (cmdOptions[CMDINDEX_HIBER_DC].dwActuals != 0);
        tChangeParam.bDynamicThrottleAc =
            (cmdOptions[CMDINDEX_THROTTLE_AC].dwActuals != 0);
        tChangeParam.bDynamicThrottleDc =
            (cmdOptions[CMDINDEX_THROTTLE_DC].dwActuals != 0);
        tChangeParam.lpszDynamicThrottleAc = lpszThrottleAcStr;
        tChangeParam.lpszDynamicThrottleDc = lpszThrottleDcStr;


        if ((dwCmdCount == 1) && 
            ((dwParamCount == 0) || 
             (bChange && (dwParamCount > 0) && (!bFile)) ||
             ((bImport || bExport) && bFile && (dwParamCount == 1))))
        {
            
            // check flags, take appropriate action
            if(bList)
            {
                DoList();
            }
            else if (bQuery)
            {
                bFail = !DoQuery(lpszName,(lstrlen(lpszName) != 0));
            }
            else if (bCreate)
            {
                bFail = !DoCreate(lpszName);
            }
            else if (bDelete)
            {
                bFail = !DoDelete(lpszName);
            }
            else if (bSetActive)
            {
                bFail = !DoSetActive(lpszName);
            }
            else if (bChange)
            {
                bFail = !DoChange(lpszName,&tChangeParam);
            }
            else if (bHibernate)
            {
                bFail = !DoHibernate(lpszBoolStr);
            }
            else if (bExport)
            {
                bFail = !DoExport(lpszName,lpszFile);
            }
            else if (bImport)
            {
                bFail = !DoImport(lpszName,lpszFile);
            }
            else if (bUsage)
            {
                DoUsage();
            }
            else 
            {
                if(lstrlen(g_lpszErr) == 0)
                    g_lpszErr = GetResString(IDS_INVALID_CMDLINE_PARAM);
                bFail = TRUE;
            }
        } 
        else 
        {
            // handle error conditions
            if(lstrlen(g_lpszErr) == 0)
            {
                g_lpszErr = GetResString(IDS_INVALID_CMDLINE_PARAM);
            }
            bFail = TRUE;
        }
    } 
    else
    {
        g_lpszErr = GetResString(IDS_INVALID_CMDLINE_PARAM);
        bFail = TRUE;
    }
    
    // check error status, display msg if needed
    if(bFail)
    {
        if(g_lpszErr2)
        {
            DISPLAY_MESSAGE(stderr,g_lpszErr2);
        }
        else
        {
            DISPLAY_MESSAGE(stderr,g_lpszErr);
        }
    }

    // clean up allocs
    LocalFree(lpszBoolStr);
    LocalFree(lpszName);
    LocalFree(lpszFile);
    LocalFree(lpszThrottleAcStr);
    LocalFree(lpszThrottleDcStr);
    if (g_lpszErr2)
    {
        LocalFree(g_lpszErr2);
    }
    
    // return appropriate result code
    if(bFail)
    {
        return EXIT_FAILURE;
    }
    else
    {
        return EXIT_SUCCESS;
    }
}


BOOL
FreeScheme(
    PSCHEME_LIST psl
)
/*++
 
Routine Description:
 
    Frees the memory associated with a scheme list entry.
 
Arguments:
 
    psl - the PSCHEME_LIST to be freed
    
Return Value:

    Always returns TRUE, indicating success.
 
--*/
{
    LocalFree(psl->lpszName);
    LocalFree(psl->lpszDesc);
    LocalFree(psl->ppp);
    LocalFree(psl->pmppp);
    LocalFree(psl);
    return TRUE;
}


BOOL 
FreeSchemeList(
    PSCHEME_LIST psl, 
    PSCHEME_LIST pslExcept
)
/*++
 
Routine Description:
 
    Deallocates all power schemes in a linked-list of power schemes, except
    for the one pointed to by pslExcept
 
Arguments:
 
    psl - the power scheme list to deallocate
    pslExcept - a scheme not to deallocate (null to deallocate all)
    
Return Value:
 
    Always returns TRUE, indicating success.
 
--*/
{
    PSCHEME_LIST cur = psl;
    PSCHEME_LIST next;
    while (cur != NULL)
    {
        next = CONTAINING_RECORD(
            cur->le.Flink,
            SCHEME_LIST,
            le
            );
        if (cur != pslExcept)
        {
            FreeScheme(cur);
        }
        else
        {
            cur->le.Flink = NULL;
            cur->le.Blink = NULL;
        }
        cur = next;
    }
    return TRUE;
}


PSCHEME_LIST 
CreateScheme(
    UINT                    uiID,
    DWORD                   dwNameSize,
    LPCTSTR                 lpszName,
    DWORD                   dwDescSize,
    LPCTSTR                 lpszDesc,
    PPOWER_POLICY           ppp
)
/*++
 
Routine Description:
 
    Builds a policy list entry.  Note that the scheme is allocated and must
    be freed when done.
 
Arguments:
 
    uiID - the numerical ID of the scheme
    dwNameSize - the number of bytes needed to store lpszName
    lpszName - the name of the scheme
    dwDescSize - the number of bytes needed to store lpszDesc
    lpszDesc - the description of the scheme
    ppp - the power policy for this scheme, may be NULL
    
Return Value:
 
    A PSCHEME_LIST entry containing the specified values, with the next
    entry field set to NULL
 
--*/
{
    
    PSCHEME_LIST psl = (PSCHEME_LIST)LocalAlloc(LPTR,sizeof(SCHEME_LIST));
    
    if (psl)
    {    
        // deal with potentially null input strings
        if(lpszName == NULL)
        {
            lpszName = NULL_STRING;
        }
        if(lpszDesc == NULL)
        {
            lpszDesc = NULL_STRING;
        }

        // allocate fields
        psl->ppp = (PPOWER_POLICY)LocalAlloc(LPTR,sizeof(POWER_POLICY));
        if (!psl->ppp)
        {
            g_lpszErr = GetResString(IDS_OUT_OF_MEMORY);
            return NULL;
        }
        psl->pmppp = (PMACHINE_PROCESSOR_POWER_POLICY)LocalAlloc(
            LPTR,
            sizeof(MACHINE_PROCESSOR_POWER_POLICY)
            );
        if (!psl->pmppp)
        {
            LocalFree(psl->ppp);
            g_lpszErr = GetResString(IDS_OUT_OF_MEMORY);
            return NULL;
        }
        psl->lpszName = (LPTSTR)LocalAlloc(LPTR,dwNameSize);
        if (!psl->lpszName)
        {
            LocalFree(psl->ppp);
            LocalFree(psl->pmppp);
            g_lpszErr = GetResString(IDS_OUT_OF_MEMORY);
            return NULL;
        }
        psl->lpszDesc = (LPTSTR)LocalAlloc(LPTR,dwDescSize);
        if (!psl->lpszDesc)
        {
            LocalFree(psl->ppp);
            LocalFree(psl->pmppp);
            LocalFree(psl->lpszName);
            g_lpszErr = GetResString(IDS_OUT_OF_MEMORY);
            return NULL;
        }
        
        // initialize structure
        psl->uiID = uiID;
        memcpy(psl->lpszName,lpszName,dwNameSize);
        memcpy(psl->lpszDesc,lpszDesc,dwDescSize);
        if (ppp)
        {
            memcpy(psl->ppp,ppp,sizeof(POWER_POLICY));
        }
        psl->le.Flink = NULL;
        psl->le.Blink = NULL;

    } 
    else
    {
        g_lpszErr = GetResString(IDS_OUT_OF_MEMORY);
    }
    return psl;
}


BOOLEAN CALLBACK 
PowerSchemeEnumProc(
    UINT                    uiID,
    DWORD                   dwNameSize,
    LPTSTR                  lpszName,
    DWORD                   dwDescSize,
    LPTSTR                  lpszDesc,
    PPOWER_POLICY           ppp,
    LPARAM                  lParam
)
/*++
 
Routine Description:
 
    This is a callback used in retrieving the policy list.
 
Arguments:
 
    uiID - the numerical ID of the scheme
    dwNameSize - the number of bytes needed to store lpszName
    lpszName - the name of the scheme
    dwDescSize - the number of bytes needed to store lpszDesc
    lpszDesc - the description of the scheme
    ppp - the power policy for this scheme
    lParam - used to hold a pointer to the head-of-list pointer, allowing
             for insertions at the head of the list
    
Return Value:
 
    TRUE to continue enumeration
    FALSE to abort enumeration
 
--*/
{
    PSCHEME_LIST psl;
    
    // Allocate and initalize a policies element.
    if ((psl = CreateScheme(
            uiID, 
            dwNameSize, 
            lpszName, 
            dwDescSize, 
            lpszDesc, 
            ppp
            )) != NULL)
    {
        // add the element to the head of the linked list
        psl->le.Flink = *((PLIST_ENTRY *)lParam);
        if(*((PLIST_ENTRY *)lParam))
        {
            (*((PLIST_ENTRY *)lParam))->Blink = &(psl->le);
        }
        (*(PLIST_ENTRY *)lParam) = &(psl->le);
        return TRUE;
    }
    return FALSE;
}


PSCHEME_LIST 
CreateSchemeList() 
/*++
 
Routine Description:
 
    Creates a linked list of existing power schemes.
 
Arguments:
 
    None
    
Return Value:
 
    A pointer to the head of the list.  
    NULL would correspond to an empty list.
 
--*/
{
    PLIST_ENTRY ple = NULL;
    PSCHEME_LIST psl;
    EnumPwrSchemes(PowerSchemeEnumProc, (LPARAM)(&ple));
    if(ple)
    {
        PSCHEME_LIST res = CONTAINING_RECORD(
            ple,
            SCHEME_LIST,
            le
            );
        psl = res;
        while(psl != NULL)
        {
            if(!ReadProcessorPwrScheme(psl->uiID,psl->pmppp))
            {
                FreeSchemeList(res,NULL);
                g_lpszErr = GetResString(IDS_UNEXPECTED_ERROR);
                return NULL;
            }
            psl = CONTAINING_RECORD(
                psl->le.Flink,
                SCHEME_LIST,
                le);
        }
        return res;
    }
    else
    {
        return NULL;
    }
}


PSCHEME_LIST 
FindScheme(
    LPCTSTR lpszName,
    UINT    uiID
)
/*++
 
Routine Description:
 
    Finds the policy with the matching name
 
Arguments:
 
    lpszName - the name of the scheme to find
    
Return Value:
 
    the matching scheme list entry, null if none
 
--*/
{
    PSCHEME_LIST psl = CreateSchemeList();
    PSCHEME_LIST pslRes = NULL;
    // find scheme entry
    while(psl != NULL)
    {
        // check for match
        if (((lpszName != NULL) && (!lstrcmpi(lpszName, psl->lpszName))) ||
            ((lpszName == NULL) && (uiID == psl->uiID)))
        { 
            pslRes = psl;
            break;
        }
        // traverse list
        psl = CONTAINING_RECORD(
            psl->le.Flink,
            SCHEME_LIST,
            le
            );
    }
    FreeSchemeList(psl,pslRes); // all except for pslRes
    if (pslRes == NULL)
        g_lpszErr = GetResString(IDS_SCHEME_NOT_FOUND);
    return pslRes;
}

BOOL 
MyWriteScheme(
    PSCHEME_LIST psl
)
/*++

Routine Description:
 
    Writes a power scheme -- both user/machine power policies and
    processor power policy.  The underlying powrprof.dll does not
    treat the processor power policy as part of the power policy
    because the processor power policies were added at a later
    date and backwards compatibility must be maintained.
 
Arguments:
 
    psl - The  scheme list entry to write
    
Return Value:
 
    TRUE if successful, otherwise FALSE
 
--*/
{
    g_lpszErr = GetResString(IDS_UNEXPECTED_ERROR);
    if(WritePwrScheme(
        &psl->uiID,
        psl->lpszName,
        psl->lpszDesc,
        psl->ppp))
    {
        return WriteProcessorPwrScheme(
            psl->uiID,
            psl->pmppp
            );
    }
    else
    {
        return FALSE;
    }
}


BOOL 
MapIdleValue(
    ULONG           ulVal, 
    PULONG          pulIdle, 
    PULONG          pulHiber,
    PPOWER_ACTION   ppapIdle
)
/*++
 
Routine Description:
 
    Modifies Idle and Hibernation settings to reflect the desired idle
    timeout. See GUI tool's PWRSCHEM.C MapHiberTimer for logic.
 
Arguments:
 
    ulVal - the new idle timeout
    pulIdle - the idle timeout variable to be updated
    pulHiber - the hiber timeout variable to be updated
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    // if previously, hiber was enabled and standby wasn't, standby timer
    // takes over the hibernation timer's role
    if (*ppapIdle == PowerActionHibernate)
    {
        if (ulVal > 0)
        { // enable standby
            *pulHiber = *pulIdle + ulVal;
            *pulIdle = ulVal;
            *ppapIdle = PowerActionSleep;
        }
        else { // standby already disabled, no change
        }
    } 
    else // standby timer actually being used for standby (not hiber)
    {
        if (ulVal > 0)
        { // enable standby
            if ((*pulHiber) != 0)
            {
                *pulHiber = *pulHiber + ulVal - *pulIdle;
            }
            *pulIdle = ulVal;
            if (ulVal > 0)
            {
                *ppapIdle = PowerActionSleep;
            }
            else
            {
                *ppapIdle = PowerActionNone;
            }
        } 
        else 
        { // disable standby
            if ((*pulHiber) != 0) 
            {
                *pulIdle = *pulHiber;
                *pulHiber = 0;
                *ppapIdle = PowerActionHibernate;
            } 
            else 
            {
                *pulIdle = 0;
                *ppapIdle = PowerActionNone;
            }      
        }
    }
    return TRUE;
}


BOOL 
MapHiberValue(
    ULONG ulVal, 
    PULONG pulIdle, 
    PULONG pulHiber,
    PPOWER_ACTION ppapIdle
)
/*++
 
Routine Description:
 
    Modifies Idle and Hibernation settings to reflect the desired hibernation
    timeout. See GUI tool's PWRSCHEM.C MapHiberTimer for logic.
 
Arguments:
 
    ulVal - the new hibernation timeout
    pulIdle - the idle timeout variable to be updated
    pulHiber - the hiber timeout variable to be updated
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/

{
    // check valid input
    if (ulVal < (*pulIdle)) 
    {
        g_lpszErr = GetResString(IDS_HIBER_OUT_OF_RANGE);
        return FALSE;
    }

    // check for disable-hibernation
    if (ulVal == 0) 
    {
        if (((*ppapIdle) == PowerActionHibernate) || (!g_bStandbySupported))
        {
            *pulIdle = 0;
            *pulHiber = 0;
            *ppapIdle = PowerActionNone;
        } 
        else 
        {
            *pulHiber = 0;
            if ((*pulIdle) == 0) {
                *ppapIdle = PowerActionNone;
            }
            else
            {
                *ppapIdle = PowerActionSleep;
            }
        }
    } 
    else // enabled hibernation
    {
        if (((*ppapIdle) == PowerActionHibernate) || (!g_bStandbySupported))
        {
            *pulHiber = 0;
            *pulIdle = ulVal;
            *ppapIdle = PowerActionHibernate;
        } 
        else 
        {
            *pulHiber = *pulHiber + ulVal - *pulIdle;
            *ppapIdle = PowerActionSleep;
        }
    }
    return TRUE;
}


BOOL 
DoList() 
/*++
 
Routine Description:
 
    Lists the existing power schemes on stdout
 
Arguments:
 
    none
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    PSCHEME_LIST psl = CreateSchemeList();
    if (psl != NULL) 
    {
        DISPLAY_MESSAGE(stdout,GetResString(IDS_LIST_HEADER1));
        DISPLAY_MESSAGE(stdout,GetResString(IDS_LIST_HEADER2));
    } 
    else
    {
      return FALSE;
    }
    while(psl != NULL) 
    {
        DISPLAY_MESSAGE(stdout, psl->lpszName);
        DISPLAY_MESSAGE(stdout, L"\n");
        psl = CONTAINING_RECORD(
            psl->le.Flink,
            SCHEME_LIST,
            le
            );
    }
    FreeSchemeList(psl,NULL); // free all entries
    return TRUE;
}


BOOL 
DoQuery(
    LPCTSTR lpszName, 
    BOOL bNameSpecified
)
/*++
 
Routine Description:
 
    Show details of an existing scheme
 
Arguments:
 
    lpszName - the name of the scheme
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    
    PSCHEME_LIST psl;

    // check if querying specific scheme or active scheme and deal w/it
    if (bNameSpecified) 
    {
        psl = FindScheme(lpszName,0);
    } 
    else  // fetch the active scheme
    {
        POWER_POLICY pp;
        UINT uiID;
        if (GetActivePwrScheme(&uiID)) 
        {
            psl = FindScheme(NULL,uiID);
        } 
        else 
        {
            g_lpszErr = GetResString(IDS_ACTIVE_SCHEME_INVALID);
            return FALSE;
        }
    }
    
    // display info
    if (psl) 
    {
        
        // header
        DISPLAY_MESSAGE(stdout, GetResString(IDS_QUERY_HEADER1));
        DISPLAY_MESSAGE(stdout, GetResString(IDS_QUERY_HEADER2));
        
        // name
        DISPLAY_MESSAGE1(
            stdout,
            g_lpszBuf,
            GetResString(IDS_SCHEME_NAME),
            psl->lpszName
            );
        
        // monitor timeout AC
        DISPLAY_MESSAGE(stdout, GetResString(IDS_MONITOR_TIMEOUT_AC));
        if (!g_bMonitorPowerSupported)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_UNSUPPORTED));
        }
        else if (psl->ppp->user.VideoTimeoutAc == 0) {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_DISABLED));
        }
        else
        {
            DISPLAY_MESSAGE1(
                stdout, 
                g_lpszBuf,
                GetResString(IDS_MINUTES),
                psl->ppp->user.VideoTimeoutAc/60
                );
        }

        // monitor timeout DC
        DISPLAY_MESSAGE(stdout, GetResString(IDS_MONITOR_TIMEOUT_DC));
        if (!g_bMonitorPowerSupported)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_UNSUPPORTED));
        }
        else if (psl->ppp->user.VideoTimeoutDc == 0)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_DISABLED));
        }
        else
        {
            DISPLAY_MESSAGE1(
                stdout, 
                g_lpszBuf,
                GetResString(IDS_MINUTES),
                psl->ppp->user.VideoTimeoutDc/60
                );
        }

        // disk timeout AC
        DISPLAY_MESSAGE(stdout, GetResString(IDS_DISK_TIMEOUT_AC));
        if (!g_bDiskPowerSupported)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_UNSUPPORTED));
        }
        else if (psl->ppp->user.SpindownTimeoutAc == 0)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_DISABLED));
        }
        else
        {
            DISPLAY_MESSAGE1(
                stdout, 
                g_lpszBuf,
                GetResString(IDS_MINUTES),
                psl->ppp->user.SpindownTimeoutAc/60
                );
        }
        
        // disk timeout DC
        DISPLAY_MESSAGE(stdout, GetResString(IDS_DISK_TIMEOUT_DC));
        if (!g_bDiskPowerSupported)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_UNSUPPORTED));
        }
        else if (psl->ppp->user.SpindownTimeoutDc == 0)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_DISABLED));
        }
        else
        {
            DISPLAY_MESSAGE1(
                stdout, 
                g_lpszBuf,
                GetResString(IDS_MINUTES),
                psl->ppp->user.SpindownTimeoutDc/60
                );
        }

        // standby timeout AC
        DISPLAY_MESSAGE(stdout, GetResString(IDS_STANDBY_TIMEOUT_AC));
        if (!g_bStandbySupported)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_UNSUPPORTED));
        }
        else if (psl->ppp->user.IdleAc.Action != PowerActionSleep)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_DISABLED));
        }
        else
        {
            DISPLAY_MESSAGE1(
                stdout, 
                g_lpszBuf,
                GetResString(IDS_MINUTES),
                psl->ppp->user.IdleTimeoutAc/60
                );
        }

        // standby timeout DC
        DISPLAY_MESSAGE(stdout, GetResString(IDS_STANDBY_TIMEOUT_DC));
        if (!g_bStandbySupported)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_UNSUPPORTED));
        }
        else if (psl->ppp->user.IdleDc.Action != PowerActionSleep)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_DISABLED));
        }
        else
        {
            DISPLAY_MESSAGE1(
                stdout, 
                g_lpszBuf,
                GetResString(IDS_MINUTES),
                psl->ppp->user.IdleTimeoutDc/60
                );
        }

        // hibernate timeout AC
        DISPLAY_MESSAGE(stdout, GetResString(IDS_HIBER_TIMEOUT_AC));
        if (!g_bHiberTimerSupported)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_UNSUPPORTED));
        }
        else if ((psl->ppp->mach.DozeS4TimeoutAc == 0) && 
            ((psl->ppp->user.IdleAc.Action != PowerActionHibernate) || 
            (psl->ppp->user.IdleTimeoutAc == 0)))
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_DISABLED));
        }
        else
        {
             DISPLAY_MESSAGE1(
                stdout, 
                g_lpszBuf,
                GetResString(IDS_MINUTES),
                (psl->ppp->mach.DozeS4TimeoutAc + 
                 psl->ppp->user.IdleTimeoutAc)/60
                );
        }

        // hibernate timeout DC
        DISPLAY_MESSAGE(stdout, GetResString(IDS_HIBER_TIMEOUT_DC));
        if (!g_bHiberTimerSupported)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_UNSUPPORTED));
        }
        else if ((psl->ppp->mach.DozeS4TimeoutDc == 0) && 
            ((psl->ppp->user.IdleDc.Action != PowerActionHibernate) ||
            (psl->ppp->user.IdleTimeoutDc == 0)))
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_DISABLED));
        }
        else
        {
             DISPLAY_MESSAGE1(
                stdout, 
                g_lpszBuf,
                GetResString(IDS_MINUTES),
                (psl->ppp->mach.DozeS4TimeoutDc + 
                 psl->ppp->user.IdleTimeoutDc)/60
                );
        }

        // throttle policy AC
        DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_AC));
        if (!g_bThrottleSupported)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_UNSUPPORTED));
        }
        else 
        {
            switch(psl->pmppp->ProcessorPolicyAc.DynamicThrottle) 
            {
                case PO_THROTTLE_NONE:
                    DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_NONE));
                    break;
                case PO_THROTTLE_CONSTANT:
                    DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_CONSTANT));
                    break;
                case PO_THROTTLE_DEGRADE:
                    DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_DEGRADE));
                    break;
                case PO_THROTTLE_ADAPTIVE:
                    DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_ADAPTIVE));
                    break;
                default:
                    DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_UNKNOWN));
                    break;
            }
        }

        // throttle policy DC
        DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_DC));
        if (!g_bThrottleSupported)
        {
            DISPLAY_MESSAGE(stdout, GetResString(IDS_UNSUPPORTED));
        }
        else 
        {
            switch(psl->pmppp->ProcessorPolicyDc.DynamicThrottle) {
                case PO_THROTTLE_NONE:
                    DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_NONE));
                    break;
                case PO_THROTTLE_CONSTANT:
                    DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_CONSTANT));
                    break;
                case PO_THROTTLE_DEGRADE:
                    DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_DEGRADE));
                    break;
                case PO_THROTTLE_ADAPTIVE:
                    DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_ADAPTIVE));
                    break;
                default:
                    DISPLAY_MESSAGE(stdout, GetResString(IDS_THROTTLE_UNKNOWN));
                    break;
            }
        }


        FreeScheme(psl);
        return TRUE;
  } 
  else 
  {
      return FALSE;
  }
}


BOOL DoCreate(
    LPTSTR lpszName
)
/*++
 
Routine Description:
 
    Adds a new power scheme
    The description will match the name
    All other details are copied from the active power scheme
    Fails if scheme already exists
 
Arguments:
 
    lpszName - the name of the scheme
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    PSCHEME_LIST psl = FindScheme(lpszName,0);
    UINT uiID;
    POWER_POLICY pp;
    BOOL bRes;
    LPTSTR lpszNewName;
    LPTSTR lpszNewDesc;
    if(psl)  // already existed -> fail
    {
        FreeScheme(psl);
        g_lpszErr = GetResString(IDS_SCHEME_ALREADY_EXISTS);
        return FALSE;
    }
    
    // create a new scheme
    if(GetActivePwrScheme(&uiID))
    {
        psl = FindScheme(NULL,uiID);
        if(!psl) 
        {
            g_lpszErr = GetResString(IDS_SCHEME_CREATE_FAIL);
            return FALSE;
        }
        lpszNewName = LocalAlloc(LPTR,(lstrlen(lpszName)+1)*sizeof(TCHAR));
        if(!lpszNewName) 
        {
            FreeScheme(psl);
            g_lpszErr = GetResString(IDS_OUT_OF_MEMORY);
            return FALSE;
        }
        lpszNewDesc = LocalAlloc(LPTR,(lstrlen(lpszName)+1)*sizeof(TCHAR));
        if(!lpszNewDesc) 
        {
            LocalFree(lpszNewName);
            FreeScheme(psl);
            g_lpszErr = GetResString(IDS_OUT_OF_MEMORY);
            return FALSE;
        }
        lstrcpy(lpszNewName,lpszName);
        lstrcpy(lpszNewDesc,lpszName);
        LocalFree(psl->lpszName);
        LocalFree(psl->lpszDesc);
        psl->lpszName = lpszNewName;
        psl->lpszDesc = lpszNewDesc;
        psl->uiID = NEWSCHEME;
        g_lpszErr = GetResString(IDS_UNEXPECTED_ERROR);            
        bRes = MyWriteScheme(psl);
        FreeScheme(psl);
        return bRes;
    }
    
    g_lpszErr = GetResString(IDS_SCHEME_CREATE_FAIL);
    
    return FALSE;
    
}


BOOL DoDelete(
    LPCTSTR lpszName
)
/*++
 
Routine Description:
 
    Deletes an existing scheme
 
Arguments:
 
    lpszName - the name of the scheme
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    PSCHEME_LIST psl = FindScheme(lpszName,0);
    
    if (psl) 
    {
        BOOL bRes = DeletePwrScheme(psl->uiID);
        FreeScheme(psl);
        g_lpszErr = GetResString(IDS_UNEXPECTED_ERROR);
        return bRes;
    } 
    else 
    {
        return FALSE;
    }
}


BOOL DoSetActive(
    LPCTSTR lpszName
)
/*++
 
Routine Description:
 
    Sets the active scheme
 
Arguments:
 
    lpszName - the name of the scheme
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    
    PSCHEME_LIST psl = FindScheme(lpszName,0);
    
    if (psl) 
    {
        BOOL bRes = SetActivePwrScheme(
            psl->uiID,
            NULL,
            NULL
            );
        FreeScheme(psl);
        g_lpszErr = GetResString(IDS_UNEXPECTED_ERROR);
        return bRes;
    } 
    else 
    {
        return FALSE;
    }
}


BOOL 
DoChange(
    LPCTSTR lpszName, 
    PCHANGE_PARAM pcp
)
/*++
 
Routine Description:
 
    Modifies an existing scheme
 
Arguments:
 
    lpszName - the name of the scheme
    pcp - PCHANGE_PARAM pointing to the parameter structure,
          indicates which variable(s) to change
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    BOOL bRes = TRUE;
    PSCHEME_LIST psl = FindScheme(lpszName,0);
    
    if (psl) 
    {
        // check for feature support
        if ((pcp->bIdleTimeoutAc || 
             pcp->bIdleTimeoutDc) && 
            !g_bStandbySupported) 
        {
            DISPLAY_MESSAGE(stderr, GetResString(IDS_STANDBY_WARNING));
        }
        if ((pcp->bDozeS4TimeoutAc || 
             pcp->bDozeS4TimeoutDc) && 
            !g_bHiberTimerSupported) 
        {
            DISPLAY_MESSAGE(stderr, GetResString(IDS_HIBER_WARNING));
        }
        if ((pcp->bVideoTimeoutAc || 
             pcp->bVideoTimeoutDc) && 
            !g_bMonitorPowerSupported)
        {
            DISPLAY_MESSAGE(stderr, GetResString(IDS_MONITOR_WARNING));
        }
        if ((pcp->bSpindownTimeoutAc || 
             pcp->bSpindownTimeoutDc) && 
            !g_bDiskPowerSupported)
        {
            DISPLAY_MESSAGE(stderr, GetResString(IDS_DISK_WARNING));
        }


        // change params
        if (pcp->bVideoTimeoutAc)
        {
            psl->ppp->user.VideoTimeoutAc = pcp->ulVideoTimeoutAc*60;
        }
        if (pcp->bVideoTimeoutDc)
        {
            psl->ppp->user.VideoTimeoutDc = pcp->ulVideoTimeoutDc*60;
        }
        if (pcp->bSpindownTimeoutAc)
        {
            psl->ppp->user.SpindownTimeoutAc = pcp->ulSpindownTimeoutAc*60;
        }
        if (pcp->bSpindownTimeoutDc)
        {
            psl->ppp->user.SpindownTimeoutDc = pcp->ulSpindownTimeoutDc*60;
        }
        if (pcp->bIdleTimeoutAc)
        {
            bRes = bRes & MapIdleValue(
                pcp->ulIdleTimeoutAc*60,
                &psl->ppp->user.IdleTimeoutAc,
                &psl->ppp->mach.DozeS4TimeoutAc,
                &psl->ppp->user.IdleAc.Action
                );
        }
        if (pcp->bIdleTimeoutDc)
        {
            bRes = bRes & MapIdleValue(
                pcp->ulIdleTimeoutDc*60,
                &psl->ppp->user.IdleTimeoutDc,
                &psl->ppp->mach.DozeS4TimeoutDc,
                &psl->ppp->user.IdleDc.Action
                );
        }
        if (pcp->bDozeS4TimeoutAc)
        {
            bRes = bRes & MapHiberValue(
                pcp->ulDozeS4TimeoutAc*60,
                &psl->ppp->user.IdleTimeoutAc,
                &psl->ppp->mach.DozeS4TimeoutAc,
                &psl->ppp->user.IdleAc.Action
                );
        }
        if (pcp->bDozeS4TimeoutDc)
        {
            bRes = bRes & MapHiberValue(
                pcp->ulDozeS4TimeoutDc*60,
                &psl->ppp->user.IdleTimeoutDc,
                &psl->ppp->mach.DozeS4TimeoutDc,
                &psl->ppp->user.IdleDc.Action
                );
        }
        if (pcp->bDynamicThrottleAc)
        {
            if(lstrcmpi(
                pcp->lpszDynamicThrottleAc,
                _T("NONE")
                ) == 0)
            {
                psl->pmppp->ProcessorPolicyAc.DynamicThrottle = 
                    PO_THROTTLE_NONE;
            } else if(lstrcmpi(
                pcp->lpszDynamicThrottleAc,
                _T("CONSTANT")
                ) == 0)
            {
                psl->pmppp->ProcessorPolicyAc.DynamicThrottle = 
                    PO_THROTTLE_CONSTANT;
            } else if(lstrcmpi(
                pcp->lpszDynamicThrottleAc,
                _T("DEGRADE")
                ) == 0)
            {
                psl->pmppp->ProcessorPolicyAc.DynamicThrottle = 
                    PO_THROTTLE_DEGRADE;
            } else if(lstrcmpi(
                pcp->lpszDynamicThrottleAc,
                _T("ADAPTIVE")
                ) == 0)
            {
                psl->pmppp->ProcessorPolicyAc.DynamicThrottle = 
                    PO_THROTTLE_ADAPTIVE;
            } else {
                g_lpszErr = GetResString(IDS_INVALID_CMDLINE_PARAM);
                bRes = FALSE;
            }
        }
        if (pcp->bDynamicThrottleDc)
        {

            if(lstrcmpi(
                pcp->lpszDynamicThrottleDc,
                _T("NONE")
                ) == 0)
            {
                psl->pmppp->ProcessorPolicyDc.DynamicThrottle = 
                    PO_THROTTLE_NONE;
            } else if(lstrcmpi(
                pcp->lpszDynamicThrottleDc,
                _T("CONSTANT")
                ) == 0)
            {
                psl->pmppp->ProcessorPolicyDc.DynamicThrottle = 
                    PO_THROTTLE_CONSTANT;
            } else if(lstrcmpi(
                pcp->lpszDynamicThrottleDc,
                _T("DEGRADE")
                ) == 0)
            {
                psl->pmppp->ProcessorPolicyDc.DynamicThrottle = 
                    PO_THROTTLE_DEGRADE;
            } else if(lstrcmpi(
                pcp->lpszDynamicThrottleDc,
                _T("ADAPTIVE")
                ) == 0)
            {
                psl->pmppp->ProcessorPolicyDc.DynamicThrottle = 
                    PO_THROTTLE_ADAPTIVE;
            } else {
                g_lpszErr = GetResString(IDS_INVALID_CMDLINE_PARAM);
                bRes = FALSE;
            }
        }

        if (bRes)
        {
            // attempt to update power scheme
            g_lpszErr = GetResString(IDS_UNEXPECTED_ERROR);
            
            bRes = MyWriteScheme(psl);
            
            // keep active power scheme consistent
            if (bRes)
            {
                UINT uiIDactive;

                if (GetActivePwrScheme(&uiIDactive) && 
                    (psl->uiID == uiIDactive))
                {
                  bRes = SetActivePwrScheme(psl->uiID,NULL,NULL);
                }
            }

            FreeScheme(psl);
            return bRes;
        } 
        else
        {
            return FALSE;
        }
    } 
    else
    {
        return FALSE;
    }
}


BOOL 
DoExport(
  LPCTSTR lpszName,
  LPCTSTR lpszFile
)
/*++
 
Routine Description:
 
    Exports a power scheme
 
Arguments:
 
    lpszName - the name of the scheme
    lpszFile - the file to hold the scheme
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    DWORD res; // write result value
    HANDLE f; // file handle

    // find scheme
    PSCHEME_LIST psl = FindScheme(lpszName,0);
    if(!psl) {
        return FALSE;
    }

    // write to file
    f = CreateFile(
        lpszFile,
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (f == INVALID_HANDLE_VALUE) 
    {
        FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                FORMAT_MESSAGE_FROM_SYSTEM | 
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                GetLastError(),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR)&g_lpszErr2,
                0,
                NULL 
                );
        FreeScheme(psl);
        return FALSE;
    }
    if (!WriteFile(
        f,
        psl->ppp,
        sizeof(POWER_POLICY),
        &res,
        NULL
        ))
    {
        FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                FORMAT_MESSAGE_FROM_SYSTEM | 
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                GetLastError(),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR)&g_lpszErr2,
                0,
                NULL 
                );
        CloseHandle(f);
        FreeScheme(psl);
        return FALSE;
    }
    if (!WriteFile(
        f,
        psl->pmppp,
        sizeof(MACHINE_PROCESSOR_POWER_POLICY),
        &res,
        NULL
        ))
    {
        FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                FORMAT_MESSAGE_FROM_SYSTEM | 
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                GetLastError(),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR)&g_lpszErr2,
                0,
                NULL 
                );
        CloseHandle(f);
        FreeScheme(psl);
        return FALSE;
    }
    CloseHandle(f);
    FreeScheme(psl);
    return TRUE;
}


BOOL 
DoImport(
  LPCTSTR lpszName,
  LPCTSTR lpszFile
)
/*++
 
Routine Description:
 
    Imports a power scheme
    If the scheme already exists, overwrites it
 
Arguments:
 
    lpszName - the name of the scheme
    lpszFile - the file that holds the scheme
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    DWORD res; // write result value
    HANDLE f; // file handle
    UINT uiIDactive; // active ID

    PSCHEME_LIST psl;
    
    // check for pre-existing scheme
    psl = FindScheme(lpszName,0);

    // if didn't exist, create it
    if (!psl)
    {
        psl = CreateScheme(
            NEWSCHEME,
            (lstrlen(lpszName)+1)*sizeof(TCHAR),
            lpszName,
            (lstrlen(lpszName)+1)*sizeof(TCHAR),
            lpszName,
            NULL // psl->ppp will be allocated but uninitialized
            );
        // check for successful alloc
        if(!psl) {
            return FALSE;
        }
    }

    // open file
    f = CreateFile(
        lpszFile,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (f == INVALID_HANDLE_VALUE) 
    {
        FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                FORMAT_MESSAGE_FROM_SYSTEM | 
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                GetLastError(),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR)&g_lpszErr2,
                0,
                NULL 
                );
        FreeScheme(psl);
        return FALSE;
    }

    // read scheme
    if (!ReadFile(
        f,
        psl->ppp,
        sizeof(POWER_POLICY),
        &res,
        NULL
        ))
    {
        FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                FORMAT_MESSAGE_FROM_SYSTEM | 
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                GetLastError(),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR)&g_lpszErr2,
                0,
                NULL 
                );
        CloseHandle(f);
        FreeScheme(psl);
        return FALSE;
    }
    if (!ReadFile(
        f,
        psl->pmppp,
        sizeof(MACHINE_PROCESSOR_POWER_POLICY),
        &res,
        NULL
        ))
    {
        FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                FORMAT_MESSAGE_FROM_SYSTEM | 
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                GetLastError(),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR)&g_lpszErr2,
                0,
                NULL 
                );
        CloseHandle(f);
        FreeScheme(psl);
        return FALSE;
    }

    CloseHandle(f);
    g_lpszErr = GetResString(IDS_UNEXPECTED_ERROR);

    // save scheme
    if (!MyWriteScheme(psl))
    {
        FreeScheme(psl);        
        return FALSE;
    }

    // check against active scheme
    if (!GetActivePwrScheme(&uiIDactive))
    {
        return FALSE;
    }
    if (uiIDactive == psl->uiID)
    {
        if (!SetActivePwrScheme(psl->uiID,NULL,NULL))
        {
            return FALSE;
        }
    }
    
    FreeScheme(psl);
    return TRUE;
}


BOOL 
DoHibernate(
  LPCTSTR lpszBoolStr
)
/*++
 
Routine Description:
 
    Enables/Disables hibernation

    NOTE: this functionality pretty much taken verbatim from the test program
          "base\ntos\po\tests\ehib\ehib.c"
 
Arguments:
 
    lpszBoolStr - "on" or "off"
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    BOOLEAN                   bEnable; // doesn't work with a BOOL, apparently
    NTSTATUS                  Status;
    HANDLE                    hToken;
    TOKEN_PRIVILEGES          tkp;
    
    // adjust privilege to allow hiber enable/disable

    if( NT_SUCCESS( OpenProcessToken(
        GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
        &hToken
        )))
    {
        if( NT_SUCCESS( LookupPrivilegeValue(
            NULL,
            SE_CREATE_PAGEFILE_NAME,
            &tkp.Privileges[0].Luid
            )))
        {
            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
            if ( !NT_SUCCESS( AdjustTokenPrivileges(
                hToken,
                FALSE,
                &tkp,
                0,
                NULL,
                0
                )))
            {
                g_lpszErr = GetResString(IDS_HIBER_PRIVILEGE);
                return FALSE;
            }

        } else {
            g_lpszErr = GetResString(IDS_HIBER_PRIVILEGE);
            return FALSE;
        }
    } else {
        g_lpszErr = GetResString(IDS_HIBER_PRIVILEGE);
        return FALSE;
    }
    
    // parse enable/disable state
    if (!lstrcmpi(lpszBoolStr,GetResString(IDS_ON))) {
        bEnable = TRUE;
    } else if (!lstrcmpi(lpszBoolStr,GetResString(IDS_OFF))) {
        bEnable = FALSE;
    } else {
        g_lpszErr = GetResString(IDS_HIBER_INVALID_STATE);
        return FALSE;
    }
    
    // enable/disable hibernation
    if (!g_bHiberFileSupported) {
        g_lpszErr = GetResString(IDS_HIBER_UNSUPPORTED);
        return FALSE;
    } else {
        Status = NtPowerInformation(
            SystemReserveHiberFile, 
            &bEnable, 
            sizeof(bEnable), 
            NULL, 
            0
            );
        if (!NT_SUCCESS(Status)) {
            FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                FORMAT_MESSAGE_FROM_SYSTEM | 
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                RtlNtStatusToDosError(Status),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR)&g_lpszErr2,
                0,
                NULL 
                );
            return FALSE;
        }
    }
    
    return TRUE;
}


BOOL 
DoUsage()
/*++
 
Routine Description:
 
    Displays usage information
 
Arguments:

    none
    
Return Value:
 
    TRUE if successful
    FALSE if failed
 
--*/
{
    ULONG ulIdx;
    for(ulIdx=IDS_USAGE_START;ulIdx<=IDS_USAGE_END;ulIdx++)
        DISPLAY_MESSAGE(stdout, GetResString(ulIdx));
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scheduledtasks\change.h ===
/******************************************************************************

	Copyright(c) Microsoft Corporation

	Module Name:

		change.h

	Abstract:

		This module contains the macros, user defined structures & function 
		definitions needed by change.cpp 

	Author:

		Venu Gopal Choudary   01-Mar-2001 

	Revision History:

		Venu Gopal Choudary   01-Mar-2001  : Created it
	
		
******************************************************************************/ 

#ifndef __CHANGE_H
#define __CHANGE_H

#pragma once
#define OI_CHSERVER			1 // Index of -s option in cmdOptions structure.
#define OI_CHUSERNAME		2 // Index of -ru option in cmdOptions structure.
#define OI_CHPASSWORD		3 // Index of -rp option in cmdOptions structure.
#define OI_CHRUNASUSER		4 // Index of -rp option in cmdOptions structure.
#define OI_CHRUNASPASSWORD	5 // Index of -rp option in cmdOptions structure.
#define OI_CHTASKRUN		7 // Index of -tr option in cmdOptions structure.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scheduledtasks\change.cpp ===
/******************************************************************************

	Copyright(c) Microsoft Corporation

	Module Name:

		change.cpp

	Abstract:

		This module changes the parameters of task(s) present in the system 

	Author:

		Venu Gopal Choudary 01-Mar-2001

	Revision History:
	
		Venu Gopal Choudary  01-Mar-2001 : Created it
		

******************************************************************************/ 


//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"


// Function declaration for the Usage function.
VOID DisplayChangeUsage();
BOOL GetTheUserName( LPTSTR pszUserName, DWORD dwMaxUserNameSize );

/*****************************************************************************

	Routine Description:

	This routine  Changes the paraemters of a specified scheduled task(s)

	Arguments:

		[ in ] argc :  Number of command line arguments
		[ in ] argv :  Array containing command line arguments

	Return Value :
		A DWORD value indicating EXIT_SUCCESS on success else 
		EXIT_FAILURE on failure
  
*****************************************************************************/

DWORD
ChangeScheduledTaskParams(  DWORD argc, LPCTSTR argv[] )
{
	// Variables used to find whether Change option, Usage option
	// are specified or not
	BOOL bChange = FALSE;
	BOOL bUsage = FALSE;

	// Set the TaskSchduler object as NULL
	ITaskScheduler *pITaskScheduler = NULL;
 
	// Return value
	HRESULT hr  = S_OK;
	
	// Initialising the variables that are passed to TCMDPARSER structure
	_TCHAR	szServer[ MAX_STRING_LENGTH ]   = NULL_STRING; 
    _TCHAR	szTaskName[ MAX_STRING_LENGTH ] = NULL_STRING;
    _TCHAR	szTaskRun[ MAX_STRING_LENGTH ] = NULL_STRING;
	_TCHAR	szUserName[MAX_STRING_LENGTH] = NULL_STRING;
	_TCHAR	szPassword[MAX_STRING_LENGTH] = NULL_STRING;
	_TCHAR	szRunAsUserName[MAX_STRING_LENGTH] = NULL_STRING;
	_TCHAR	szRunAsPassword[MAX_STRING_LENGTH] = NULL_STRING;


	// Declarations related to Task name
	WCHAR	wszJobName[MAX_TASKNAME_LEN] = NULL_U_STRING;
    WCHAR	wszUserName[MAX_STRING_LENGTH] = NULL_U_STRING;
	WCHAR	wszPassword[MAX_STRING_LENGTH] = NULL_U_STRING;
	WCHAR	wszCommand[_MAX_FNAME] = NULL_U_STRING;
	WCHAR	wszApplName[_MAX_FNAME] = NULL_U_STRING;

	// Dynamic Array contaning array of jobs
	TARRAY arrJobs = NULL;

	// Loop Variable.
	DWORD dwJobCount = 0;

	//buffer for displaying error message
	TCHAR	szMessage[MAX_STRING_LENGTH] = NULL_STRING;
	BOOL bUserName = TRUE;
	BOOL bPassWord = TRUE;
	BOOL bSystemStatus = FALSE;
	BOOL  bNeedPassword = FALSE;
	BOOL  bResult = FALSE;
	BOOL  bCloseConnection = TRUE;

	lstrcpy( szPassword, ASTERIX);
	lstrcpy( szRunAsPassword, ASTERIX);

	// Builiding the TCMDPARSER structure
	TCMDPARSER cmdOptions[] = 
	{
		{ 
		  CMDOPTION_CHANGE,
		  CP_MAIN_OPTION,
		  1,
		  0,
		  &bChange,
		  NULL_STRING,
		  NULL,
		  NULL
		},
		{ 
		  SWITCH_SERVER,
		  CP_TYPE_TEXT | CP_VALUE_MANDATORY, 
		  1,
		  0,
		  &szServer,
		  NULL_STRING,
		  NULL, 
		  NULL
		},
		{ 
			SWITCH_USER,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY,
			OPTION_COUNT,
			0,
			&szUserName,
			NULL_STRING,
			NULL,
			NULL
		},
		{ 
			SWITCH_PASSWORD,
			CP_TYPE_TEXT | CP_VALUE_OPTIONAL,
			OPTION_COUNT,
			0,
			&szPassword,
			NULL_STRING,
			NULL,
			NULL
		},
		{ 
			SWITCH_RUNAS_USER,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY,
			OPTION_COUNT,
			0,
			&szRunAsUserName,
			NULL_STRING,
			NULL,
			NULL
		},
		{ 
			SWITCH_RUNAS_PASSWORD,
			CP_TYPE_TEXT | CP_VALUE_OPTIONAL,
			OPTION_COUNT,
			0,
			&szRunAsPassword,
			NULL_STRING,
			NULL,
			NULL
		},
		{ 
		  SWITCH_TASKNAME,
		  CP_TYPE_TEXT | CP_VALUE_MANDATORY | CP_MANDATORY ,
		  1,
		  0,
		  &szTaskName,
		  NULL_STRING,
		  NULL,
		  NULL
		},
		{ 
		  SWITCH_TASKRUN,
		  CP_TYPE_TEXT | CP_VALUE_MANDATORY,
		  1,
		  0,
		  &szTaskRun,
		  NULL_STRING,
		  NULL,
		  NULL
		},
		{ 
		  CMDOPTION_USAGE,
		  CP_USAGE ,
		  1,
		  0, 
		  &bUsage,
		  NULL_STRING, 
		  NULL, 
		  NULL
		 }
	};	
	
	// Parsing the change option switches
	if ( DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions), cmdOptions ) == FALSE)
	{
		DISPLAY_MESSAGE( stderr, GetResString(IDS_LOGTYPE_ERROR ));
		DISPLAY_MESSAGE( stderr, GetReason() );
		return EXIT_FAILURE;
	}

	// triming the null spaces
	StrTrim(szServer, TRIM_SPACES );
	StrTrim(szUserName, TRIM_SPACES );
	StrTrim(szTaskName, TRIM_SPACES );
	StrTrim(szRunAsUserName, TRIM_SPACES );
	StrTrim(szTaskRun, TRIM_SPACES );

	// check whether password (-p) specified in the command line or not.
	if ( cmdOptions[OI_CHPASSWORD].dwActuals == 0 )
	{
		lstrcpy( szPassword, NULL_STRING );
	}

	// check whether run as password (-rp) specified in the command line or not.
	if ( cmdOptions[OI_CHRUNASPASSWORD].dwActuals == 0 )
	{
		lstrcpy( szRunAsPassword, NULL_STRING );
	}

	// Displaying change usage if user specified -? with -change option
	if( bUsage == TRUE )
	{
		DisplayChangeUsage();
		return EXIT_SUCCESS;
	}

	// check for -s, -ru, -rp or -tr options specified in the cmdline or not
	if( ( cmdOptions[OI_CHSERVER].dwActuals == 0 ) &&  
		( cmdOptions[OI_CHRUNASUSER].dwActuals == 0 ) &&
		( cmdOptions[OI_CHRUNASPASSWORD].dwActuals == 0 ) &&
		( cmdOptions[OI_CHTASKRUN].dwActuals == 0 ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_CHANGE_OPTIONS));	
		return RETVAL_FAIL;
	}

	// check for invalid server
	if( ( cmdOptions[OI_CHSERVER].dwActuals == 1 ) &&  ( lstrlen( szServer ) == 0 ) )
	{
		DISPLAY_MESSAGE(stderr, GetResString(IDS_NO_SERVER));	
		return RETVAL_FAIL;
	}

	// check whether -u or -ru options specified respectively with -p or -rp options or not
	if ( cmdOptions[ OI_CHUSERNAME ].dwActuals == 0 && cmdOptions[ OI_CHPASSWORD ].dwActuals == 1 ) 
	{
		// invalid syntax
		DISPLAY_MESSAGE(stderr, GetResString(IDS_CHPASSWORD_BUT_NOUSERNAME));
		return RETVAL_FAIL;			// indicate failure
	}


	// check for invalid user name
	if( ( cmdOptions[OI_CHSERVER].dwActuals == 0 ) && ( cmdOptions[OI_CHUSERNAME].dwActuals == 1 )  )
	{
		DISPLAY_MESSAGE(stderr, GetResString(IDS_CHANGE_USER_BUT_NOMACHINE));	
		return RETVAL_FAIL;
	}
	
	// check for the length of user name
	if( ( cmdOptions[OI_CHSERVER].dwActuals == 1 ) && ( cmdOptions[OI_CHUSERNAME].dwActuals == 1 ) &&
					( lstrlen( szUserName ) == 0 ) )
	{
		DISPLAY_MESSAGE(stderr, GetResString(IDS_INVALID_USERNAME));	
		return RETVAL_FAIL;
	}

	// check for the length of username
	if( ( lstrlen( szUserName ) > MAX_USERNAME_LENGTH ) ||
			( lstrlen( szRunAsUserName ) > MAX_USERNAME_LENGTH ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_UNAME));
		return RETVAL_FAIL;
	}

	// check for the length of password
	if(	( lstrlen( szRunAsPassword ) > MAX_PASSWORD_LENGTH ) ||
		( lstrlen( szPassword ) > MAX_PASSWORD_LENGTH ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_PASSWORD));
		return RETVAL_FAIL;
	}

	// check for the length of taskname
	if( ( lstrlen( szTaskName ) > MAX_JOB_LEN ) || ( lstrlen(szTaskName) == 0 ) )
	{
		DISPLAY_MESSAGE( stderr, GetResString(IDS_INVALID_TASKLENGTH) );
		return RETVAL_FAIL;
	}
		
	// check for the length of task to run
	if( ( cmdOptions[OI_CHTASKRUN].dwActuals == 1 ) && 
		( ( lstrlen( szTaskRun ) > MAX_TASK_LEN ) ||
		( lstrlen ( szTaskRun ) == 0 ) ) )
	{
		DISPLAY_MESSAGE(stderr, GetResString(IDS_INVALID_TASKRUN));	
		return RETVAL_FAIL;
	}

	// Convert the task name specified by the user to wide char or unicode format
	if( GetAsUnicodeString(szTaskName,wszJobName,SIZE_OF_ARRAY(wszJobName)) == NULL )
	{
		return RETVAL_FAIL;
	}
	
	//for holding values of parameters in FormatMessage()
	_TCHAR* szValues[1] = {NULL};
	BOOL bLocalMachine = FALSE;
	BOOL bRemoteMachine = FALSE;

#ifdef _WIN64
	INT64 dwPos = 0;
#else
	DWORD dwPos = 0;
#endif

    // check whether remote machine specified or not
	if( cmdOptions[OI_CHSERVER].dwActuals == 1 )
	{
		bRemoteMachine = TRUE;
	}
	else
	{
		bLocalMachine = TRUE;	
	}

	// check whether the password (-p) specified in the command line or not 
	// and also check whether '*' or empty is given for -p or not
	if( ( IsLocalSystem( szServer ) == FALSE ) && 
		( ( cmdOptions[OI_CHPASSWORD].dwActuals == 0 ) || ( lstrcmpi ( szPassword, ASTERIX ) == 0 ) ) )
	{
		bNeedPassword = TRUE;
	}
	
	// check whether server (-s) and username (-u) only specified along with the command or not
	if( ( IsLocalSystem( szServer ) == FALSE ) || ( cmdOptions[OI_CHUSERNAME].dwActuals == 1 ) )
	{
		// Establish the connection on a remote machine
		bResult = EstablishConnection(szServer,szUserName,SIZE_OF_ARRAY(szUserName),szPassword,SIZE_OF_ARRAY(szPassword), bNeedPassword );
		if (bResult == FALSE)
		{
			// displays the appropriate error message
			DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_STRING) );
			DISPLAY_MESSAGE( stderr, GetReason());
			return EXIT_FAILURE ;
		}
		else
		{
			// though the connection is successfull, some conflict might have occured
			switch( GetLastError() )
			{
			case I_NO_CLOSE_CONNECTION:
					bCloseConnection = FALSE;
					break;

			// check for mismatched credentials
			case E_LOCAL_CREDENTIALS:
			case ERROR_SESSION_CREDENTIAL_CONFLICT:
				{
					bCloseConnection = FALSE;
					DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_STRING) );
					DISPLAY_MESSAGE( stderr, GetReason());
					return EXIT_FAILURE;
				}
			}
		}
	
	}

	// Get the task Scheduler object for the system.
	pITaskScheduler = GetTaskScheduler( szServer );

	// If the Task Scheduler is not defined then give the error message.
    if ( pITaskScheduler == NULL )
    {	
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
		return EXIT_FAILURE;
    }

	// Validate the Given Task and get as TARRAY in case of taskname 
	arrJobs = ValidateAndGetTasks( pITaskScheduler, szTaskName);
	if( arrJobs == NULL )
	{
		_stprintf( szMessage , GetResString(IDS_TASKNAME_NOTEXIST), szTaskName);	
		DISPLAY_MESSAGE(stderr,szMessage);	

		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
		return EXIT_FAILURE;
		
	}

	IPersistFile *pIPF = NULL;
    ITask *pITask = NULL;

	// returns an pITask inteface for wszJobName
	hr = pITaskScheduler->Activate(wszJobName,IID_ITask,
									   (IUnknown**) &pITask);
 
	if (FAILED(hr))
    {
		DisplayErrorMsg(hr);

		if( pIPF )
			pIPF->Release();

		if( pITask )
			pITask->Release();
			
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
		
		return EXIT_FAILURE;
    }

	//if the user name is not specifed set the current logged on user settings 
	DWORD dwUserLen = MAX_USERNAME_LEN;
	DWORD dwResult = 0;
	BOOL  bFlag = FALSE;
	ULONG ulLong = MAX_RES_STRING;
	TCHAR szBuffer[MAX_STRING_LENGTH] = NULL_STRING;
	TCHAR szRunAsUser[MAX_STRING_LENGTH] = NULL_STRING;

	// declaration for parameter arguments
	wchar_t* wcszParam = L"";

	// get the run as user name for a specified scheduled task
	hr = GetRunAsUser(pITask, szRunAsUser);
	
	if ( ( cmdOptions[OI_CHRUNASUSER].dwActuals == 1 ) && 
		( (lstrlen( szRunAsUserName) == 0) || ( lstrcmpi(szRunAsUserName, NTAUTHORITY_USER ) == 0 ) ||
		(lstrcmpi(szRunAsUserName, SYSTEM_USER ) == 0 ) ) )
	{
		bSystemStatus = TRUE;
		bFlag = TRUE;
	}
	else if ( FAILED (hr) )
	{
		bFlag = TRUE;
	}

	// flag to check whether run as user name is "NT AUTHORITY\SYSTEM" or not
	if ( bFlag == FALSE )
	{
		// check for "NT AUTHORITY\SYSTEM" username
		if( ( ( cmdOptions[OI_CHRUNASUSER].dwActuals == 1 ) && ( lstrlen( szRunAsUserName) == 0 ) ) || 
		( ( cmdOptions[OI_CHRUNASUSER].dwActuals == 1 ) && ( lstrlen( szRunAsUserName) == 0 ) && ( lstrlen(szRunAsPassword ) == 0 ) ) ||
		( ( cmdOptions[OI_CHRUNASUSER].dwActuals == 1 ) && ( lstrcmpi(szRunAsUserName, NTAUTHORITY_USER ) == 0 ) && ( lstrlen(szRunAsPassword ) == 0 )) ||
		( ( cmdOptions[OI_CHRUNASUSER].dwActuals == 1 ) && ( lstrcmpi(szRunAsUserName, NTAUTHORITY_USER ) == 0 ) ) ||
		( ( cmdOptions[OI_CHRUNASUSER].dwActuals == 1 ) && ( lstrcmpi(szRunAsUserName, SYSTEM_USER) == 0 ) && ( lstrlen(szRunAsPassword ) == 0 ) ) ||
		( ( cmdOptions[OI_CHRUNASUSER].dwActuals == 1 ) && ( lstrcmpi(szRunAsUserName, SYSTEM_USER ) == 0 ) ) )
		{
			bSystemStatus = TRUE;
		}
	}

	if ( bSystemStatus == FALSE )
	{
		//check the length of run as user name	
		if ( (lstrlen( szRunAsUserName ) != 0 ))
		{
			// Convert the run as user name specified by the user to wide char or unicode format
			if ( GetAsUnicodeString(szRunAsUserName, wszUserName, SIZE_OF_ARRAY(wszUserName)) == NULL )
			{
				// close the connection that was established by the utility
				if ( bCloseConnection == TRUE )
					CloseConnection( szServer );

				return EXIT_FAILURE;
			}
		}
		else
		{
			bUserName = FALSE;	
		}

		//check for the null password	
		if ( ( lstrlen( szRunAsPassword ) != 0 ) && ( lstrcmpi ( szRunAsPassword, ASTERIX) != 0 ) )
		{
			// Convert the password specified by the user to wide char or unicode format
			if ( GetAsUnicodeString( szRunAsPassword, wszPassword, SIZE_OF_ARRAY(wszPassword)) == NULL )
			{
				// close the connection that was established by the utility
				if ( bCloseConnection == TRUE )
					CloseConnection( szServer );

				return EXIT_FAILURE;
			}

			bPassWord = TRUE;
		}
		else
		{
			// check whether -rp is specified or not
			if (cmdOptions[OI_CHRUNASPASSWORD].dwActuals == 1)
			{
				if( ( lstrcmpi( szRunAsPassword , NULL_STRING ) != 0 ) && ( lstrcmpi ( szRunAsPassword, ASTERIX) != 0 ) )
				{
					bPassWord = TRUE;
				}
				else if ( ( bSystemStatus == FALSE ) && ( lstrlen (szRunAsPassword) == 0 ) )
				{
					DISPLAY_MESSAGE (stderr, GetResString(IDS_NO_PASSWORD));
					
					// close the connection that was established by the utility
					if ( bCloseConnection == TRUE )
						CloseConnection( szServer );

					Cleanup(pITaskScheduler);
					return EXIT_FAILURE;
				}
				else if ( lstrcmpi ( szRunAsPassword, ASTERIX) == 0 )
				{
					bPassWord = FALSE;
				}
			}	
			else if ( bSystemStatus == FALSE )
			{
				bPassWord = FALSE;
			}
		
		}
	}

	// check for the status of username and password
	if( ( bUserName == TRUE ) && ( bPassWord == FALSE ) )
	{
		// check for the local or remote system
		if ( (bLocalMachine == TRUE) || (bRemoteMachine == TRUE) )   
		{
			szValues[0] = (_TCHAR*) (szRunAsUserName);
			FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
					  GetResString(IDS_PROMPT_CHGPASSWD),0,MAKELANGID(LANG_NEUTRAL,
			          SUBLANG_DEFAULT),szBuffer,
			          MAX_STRING_LENGTH,(va_list*)szValues );

			DISPLAY_MESSAGE(stdout,szBuffer);

			// Get the password from the command line
			if (GetPassword( szRunAsPassword, MAX_PASSWORD_LENGTH ) == FALSE )
			{
				// close the connection that was established by the utility
				if ( bCloseConnection == TRUE )
					CloseConnection( szServer );

				return EXIT_FAILURE;
			}

			// check for the length of password
			if( lstrlen(szRunAsPassword) > MAX_PASSWORD_LENGTH )
			{
				DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_PASSWORD));
				Cleanup(pITaskScheduler);
				return E_FAIL;
			}

			//check for the null password
			if( lstrcmpi( szRunAsPassword , NULL_STRING ) == 0 )
			{
				DISPLAY_MESSAGE (stderr, GetResString(IDS_NO_PASSWORD));
				if( pIPF )
					pIPF->Release();

				if( pITask )
					pITask->Release();
			
				// close the connection that was established by the utility
				if ( bCloseConnection == TRUE )
					CloseConnection( szServer );

				Cleanup(pITaskScheduler);
		
				return EXIT_FAILURE;
			}

			// check for the password length > 0
			if(lstrlen( szRunAsPassword ))
			{
				// Convert the password specified by the user to wide char or unicode format
				if ( GetAsUnicodeString( szRunAsPassword, wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
				{
					// close the connection that was established by the utility
					if ( bCloseConnection == TRUE )
						CloseConnection( szServer );

					return EXIT_FAILURE;
				}
			}
		}
				
	}
	// check for the status of user name and password
	else if( ( bUserName == FALSE ) && ( bPassWord == TRUE ) )
	{	
		if ( (bLocalMachine == TRUE) || (bRemoteMachine == TRUE) )  
		{
	
			if ( (bFlag == TRUE ) && ( bSystemStatus == FALSE ) )
			{
				DISPLAY_MESSAGE(stdout, GetResString(IDS_PROMPT_USERNAME));
				
				if ( GetTheUserName( szRunAsUserName, MAX_USERNAME_LENGTH) == FALSE )
				{
					DISPLAY_MESSAGE(stderr, GetResString( IDS_FAILED_TOGET_USER ) );
					// close the connection that was established by the utility
					if ( bCloseConnection == TRUE )
						CloseConnection( szServer );

					return EXIT_FAILURE;
				}

				// check for the length of username
				if( lstrlen(szRunAsUserName) > MAX_USERNAME_LENGTH ) 
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_UNAME  ));
					// close the connection that was established by the utility
					if ( bCloseConnection == TRUE )
						CloseConnection( szServer );

					return EXIT_FAILURE;
				}

				if ( (lstrlen( szRunAsUserName) == 0) || ( lstrcmpi(szRunAsUserName, NTAUTHORITY_USER ) == 0 ) ||
					(lstrcmpi(szRunAsUserName, SYSTEM_USER ) == 0 ) )
				{
					bSystemStatus = TRUE;
					bFlag = TRUE;
				}
				else
				{
					// check for the length of run as user name
					if(lstrlen(szRunAsUserName))
					{
						// Convert the run as user name specified by the user to wide char or unicode format
						if (GetAsUnicodeString(szRunAsUserName, wszUserName, SIZE_OF_ARRAY(wszUserName)) == NULL )
						{
							// close the connection that was established by the utility
							if ( bCloseConnection == TRUE )
								CloseConnection( szServer );

							return EXIT_FAILURE;
						}
					}
				}
			
			}
			else
			{
				// Convert the run as user name specified by the user to wide char or unicode format
				if (GetAsUnicodeString( szRunAsUser, wszUserName, SIZE_OF_ARRAY(wszUserName)) == NULL )
				{
					// close the connection that was established by the utility
					if ( bCloseConnection == TRUE )
						CloseConnection( szServer );

					return EXIT_FAILURE;
				}
			}
	
			// check for the length of password > 0			
			if(lstrlen(szRunAsPassword))
			{
				// Convert the password specified by the user to wide char or unicode format
				if (GetAsUnicodeString(szRunAsPassword, wszPassword, SIZE_OF_ARRAY(wszPassword)) == NULL )
				{
					// close the connection that was established by the utility
					if ( bCloseConnection == TRUE )
						CloseConnection( szServer );

					return EXIT_FAILURE;
				}
			}
		}
					
	}
	// check for the user name and password are not specified
	else if( ( bUserName == FALSE ) && ( bPassWord == FALSE ) )
	{	
		if ( (bLocalMachine == TRUE) || (bRemoteMachine == TRUE) )  
		{
			if ( (bFlag == TRUE ) && ( bSystemStatus == FALSE ) )
			{
				DISPLAY_MESSAGE(stdout, GetResString(IDS_PROMPT_USERNAME));
				
				if ( GetTheUserName( szRunAsUserName, MAX_USERNAME_LENGTH ) == FALSE )
				{
					DISPLAY_MESSAGE(stderr, GetResString( IDS_FAILED_TOGET_USER ) );
					// close the connection that was established by the utility
					if ( bCloseConnection == TRUE )
						CloseConnection( szServer );

					return EXIT_FAILURE;
				}

				// check for the length of username
				if( lstrlen(szRunAsUserName) > MAX_USERNAME_LENGTH ) 
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_UNAME  ));
					// close the connection that was established by the utility
					if ( bCloseConnection == TRUE )
						CloseConnection( szServer );

					return EXIT_FAILURE;
				}

				if ( (lstrlen( szRunAsUserName) == 0) || ( lstrcmpi(szRunAsUserName, NTAUTHORITY_USER ) == 0 ) ||
					(lstrcmpi(szRunAsUserName, SYSTEM_USER ) == 0 ) )
				{
					bSystemStatus = TRUE;
					bFlag = TRUE;
				}
				else
				{
					if(lstrlen(szRunAsUserName))
					{
						// Convert the run as user name specified by the user to wide char or unicode format
						if ( GetAsUnicodeString(szRunAsUserName, wszUserName, SIZE_OF_ARRAY(wszUserName)) == NULL )
						{
							// close the connection that was established by the utility
							if ( bCloseConnection == TRUE )
								CloseConnection( szServer );

							return EXIT_FAILURE;
						}
					}
				}
				
			}
			else 
			{
				// Convert the run as user name specified by the user to wide char or unicode format
				if (GetAsUnicodeString( szRunAsUser, wszUserName, SIZE_OF_ARRAY(wszUserName)) == NULL )
				{
					// close the connection that was established by the utility
					if ( bCloseConnection == TRUE )
						CloseConnection( szServer );

					return EXIT_FAILURE;
				}
			}

			if ( wcslen ( wszUserName ) != 0 )
			{
				szValues[0] = (_TCHAR*) (wszUserName);
			
				FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
				  GetResString(IDS_PROMPT_CHGPASSWD),0,MAKELANGID(LANG_NEUTRAL,
						  SUBLANG_DEFAULT),szBuffer,
						  MAX_STRING_LENGTH,(va_list*)szValues );

				DISPLAY_MESSAGE(stdout,szBuffer);
				
				// Get the run as user password from the command line
				if ( GetPassword( szRunAsPassword, MAX_PASSWORD_LENGTH ) == FALSE )
				{
					// close the connection that was established by the utility
					if ( bCloseConnection == TRUE )
						CloseConnection( szServer );

					return EXIT_FAILURE;
				}

				// check for the length of password
				if( lstrlen(szRunAsPassword) > MAX_PASSWORD_LENGTH )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_PASSWORD));
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}

				//check for the null password
				if( lstrcmpi( szRunAsPassword , NULL_STRING ) == 0 )
				{
					DISPLAY_MESSAGE (stderr, GetResString(IDS_NO_PASSWORD));
					if( pIPF )
						pIPF->Release();

					if( pITask )
						pITask->Release();
				
					// close the connection that was established by the utility
					if ( bCloseConnection == TRUE )
						CloseConnection( szServer );

					Cleanup(pITaskScheduler);
			
					return EXIT_FAILURE;
				}
				
				if(lstrlen( szRunAsPassword ))
				{
					// Convert the password specified by the user to wide char or unicode format
					if (GetAsUnicodeString( szRunAsPassword, wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
					{
						// close the connection that was established by the utility
						if ( bCloseConnection == TRUE )
							CloseConnection( szServer );

						return EXIT_FAILURE;
					}
				}
			}
		
		}
					
	}
 
	// Return a pointer to a specified interface on an object
	hr = pITask->QueryInterface(IID_IPersistFile, (void **) &pIPF);

    if (FAILED(hr))
    {
		DisplayErrorMsg(hr);

		if( pIPF )
			pIPF->Release();

		if( pITask )
			pITask->Release();
			
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
		
		return EXIT_FAILURE;
    }
    
	if( cmdOptions[OI_CHTASKRUN].dwActuals == 0 )
	{
		LPWSTR lpwszApplicationName = NULL;
		LPWSTR lpwszParams =  NULL;

		// get the application name
		hr = pITask->GetApplicationName(&lpwszApplicationName);
		if (FAILED(hr))
		{
			DisplayErrorMsg(hr);

			if( pIPF )
				pIPF->Release();

			if( pITask )
				pITask->Release();
			
			CoTaskMemFree( lpwszApplicationName );
			
			// close the connection that was established by the utility
			if ( bCloseConnection == TRUE )
				CloseConnection( szServer );

			Cleanup(pITaskScheduler);
			return EXIT_FAILURE;
		}

		// get the parameters
		hr = pITask->GetParameters(&lpwszParams);
		if (FAILED(hr))
		{
			DisplayErrorMsg(hr);

			if( pIPF )
				pIPF->Release();

			if( pITask )
				pITask->Release();
			
			CoTaskMemFree( lpwszParams );
			
			// close the connection that was established by the utility
			if ( bCloseConnection == TRUE )
				CloseConnection( szServer );

			Cleanup(pITaskScheduler);
			return EXIT_FAILURE;
		}

		lstrcpy(wszCommand,lpwszApplicationName);
		CoTaskMemFree( lpwszApplicationName );

		// set the task to run application name
		hr = pITask->SetApplicationName(wszCommand);
		if (FAILED(hr))
		{
		DisplayErrorMsg(hr);

		if( pIPF )
			pIPF->Release();

		if( pITask )
			pITask->Release();
			
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
        return EXIT_FAILURE;
		}
	
		lstrcpy(wszCommand,lpwszParams);
		CoTaskMemFree( lpwszParams );

		// set the task to run application name
		hr = pITask->SetParameters(wszCommand);
		if (FAILED(hr))
		{
			DisplayErrorMsg(hr);

			if( pIPF )
				pIPF->Release();

			if( pITask )
				pITask->Release();
				
			// close the connection that was established by the utility
			if ( bCloseConnection == TRUE )
				CloseConnection( szServer );

			Cleanup(pITaskScheduler);
			return EXIT_FAILURE;
		}

	} 
	else
	{
		// Convert the task to run specified by the user to wide char or unicode format
		if ( GetAsUnicodeString(szTaskRun,wszCommand,SIZE_OF_ARRAY(wszCommand)) == NULL )
		{
			// close the connection that was established by the utility
			if ( bCloseConnection == TRUE )
				CloseConnection( szServer );

			return EXIT_FAILURE;
		}
    
		// check for .exe substring string in the given task to run string
		
		wchar_t wcszParam[MAX_RES_STRING] = L"";
	
		DWORD dwProcessCode = 0 ;
		dwProcessCode = ProcessFilePath(wszCommand,wszApplName,wcszParam);
		
		if(dwProcessCode == RETVAL_FAIL)
		{
			if( pIPF )
				pIPF->Release();

			if( pITask )
				pITask->Release();
				
			// close the connection that was established by the utility
			if ( bCloseConnection == TRUE )
				CloseConnection( szServer );

			Cleanup(pITaskScheduler);
			return EXIT_FAILURE;

		}
	
		
		// Set command name with ITask::SetApplicationName
		hr = pITask->SetApplicationName(wszApplName);
		if (FAILED(hr))
		{
			DisplayErrorMsg(hr);

			if( pIPF )
				pIPF->Release();

			if( pITask )
				pITask->Release();
				
			// close the connection that was established by the utility
			if ( bCloseConnection == TRUE )
				CloseConnection( szServer );

			Cleanup(pITaskScheduler);
			return EXIT_FAILURE;
		}
	
	
		//[Working directory =  exe pathname - exe name] 
		wchar_t* wcszStartIn = wcsrchr(wszApplName,_T('\\'));
		if(wcszStartIn != NULL)
			*( wcszStartIn ) = _T('\0');
		
		// set the working directory of command
		hr = pITask->SetWorkingDirectory(wszApplName); 

		if (FAILED(hr))
		{
			DisplayErrorMsg(hr);

			if( pIPF )
				pIPF->Release();

			if( pITask )
				pITask->Release();
				
			// close the connection that was established by the utility
			if ( bCloseConnection == TRUE )
				CloseConnection( szServer );

			Cleanup(pITaskScheduler);
			return EXIT_FAILURE;
		}

		// set the command line parameters for the task
		hr = pITask->SetParameters(wcszParam);
		if (FAILED(hr))
		{
			DisplayErrorMsg(hr);

			if( pIPF )
			{
				pIPF->Release();
			}

			if( pITask )
			{
				pITask->Release();
			}
			
			// close the connection that was established by the utility
			if ( bCloseConnection == TRUE )
				CloseConnection( szServer );

			Cleanup(pITaskScheduler);
			return EXIT_FAILURE;
		}
	}

	if( bSystemStatus == TRUE )
	{
		// Change the account information to "NT AUTHORITY\SYSTEM" user
		hr = pITask->SetAccountInformation(L"",NULL);	
		if ( FAILED(hr) )
		{
			DISPLAY_MESSAGE(stderr, GetResString(IDS_NTAUTH_SYSTEM_ERROR));
			
			if( pIPF )
				pIPF->Release();

			if( pITask )
				pITask->Release();
			
			// close the connection that was established by the utility
			if ( bCloseConnection == TRUE )
				CloseConnection( szServer );

			Cleanup(pITaskScheduler);
			return EXIT_FAILURE;
		}
	}
	else
	{
		// set the account information with the user name and password
		hr = pITask->SetAccountInformation(wszUserName,wszPassword);
	}
	
    if ((FAILED(hr)) && (hr != SCHED_E_NO_SECURITY_SERVICES))
    {
		DisplayErrorMsg(hr);
	
		if( pIPF )
			pIPF->Release();

		if( pITask )
			pITask->Release();
			
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
	    return EXIT_FAILURE;
    }
	
	if ( bSystemStatus == TRUE )
	{
		szValues[0] = (_TCHAR*) (wszJobName);
		FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
					  GetResString(IDS_NTAUTH_SYSTEM_CHANGE_INFO),0,MAKELANGID(LANG_NEUTRAL,
				      SUBLANG_DEFAULT),szBuffer,
				      MAX_STRING_LENGTH,(va_list*)szValues
				     );
			
		DISPLAY_MESSAGE(stdout,szBuffer);
	}
	
	if( (cmdOptions[OI_CHRUNASPASSWORD].dwActuals == 1) && ( bSystemStatus == TRUE ) &&
			(lstrlen( szRunAsPassword ) != 0) )
	{
		DISPLAY_MESSAGE( stdout, GetResString( IDS_PASSWORD_NOEFFECT ) ); 
	}

	// save the copy of an object
	hr = pIPF->Save(NULL,TRUE);

    if( E_FAIL == hr )
    {
		DisplayErrorMsg(hr);
		if(pIPF)
			pIPF->Release();

		if(pITask)
			pITask->Release();
		
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
        return EXIT_FAILURE;
    }

	if (FAILED (hr))
	{
		DisplayErrorMsg(hr);
		if(pIPF)
			pIPF->Release();

		if(pITask)
			pITask->Release();
		
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
        return EXIT_FAILURE;
	}
	else
	{
		// to display a success message
		szValues[0] = (_TCHAR*) (wszJobName);
		FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
					  GetResString(IDS_CHANGE_SUCCESSFUL),0,MAKELANGID(LANG_NEUTRAL,
				      SUBLANG_DEFAULT),szBuffer,
				      MAX_STRING_LENGTH,(va_list*)szValues
				     );
			
		DISPLAY_MESSAGE(stdout,szBuffer);
		
	}

	if( pIPF )
		pIPF->Release();

	if( pITask )
		pITask->Release();
			
	// close the connection that was established by the utility
	if ( bCloseConnection == TRUE )
		CloseConnection( szServer );

	Cleanup(pITaskScheduler);

	return EXIT_SUCCESS;
}

/*****************************************************************************

	Routine Description:

		This routine  displays the usage of -change option

	Arguments:
		None

	Return Value :
		VOID
******************************************************************************/

VOID
DisplayChangeUsage()
{
	// Displaying -change option usage
	DisplayUsage( IDS_CHANGE_HLP1, IDS_CHANGE_HLP33 );
}

// ***************************************************************************
// Routine Description:
//
// Takes the user name from the keyboard.While entering the user name 
//  it displays the user name as it is.
//
// Arguments:
//
// [in] pszUserName		    -- String to store user name
// [in] dwMaxUserNameSize	-- Maximun size of the user name. 
//  
// Return Value:
//
// BOOL				--If this function succeds returns TRUE otherwise returns FALSE.
// 
// ***************************************************************************
BOOL GetTheUserName( LPTSTR pszUserName, DWORD dwMaxUserNameSize )
{
	// local variables
	TCHAR ch;
	DWORD dwIndex = 0;
	DWORD dwCharsRead = 0;
	DWORD dwCharsWritten = 0;
	DWORD dwPrevConsoleMode = 0;
	HANDLE hInputConsole = NULL;
	TCHAR szBuffer[ 10 ] = NULL_STRING;		


	// check the input value
	if ( pszUserName == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return FALSE;
	}
	
	// Get the handle for the standard input
	hInputConsole = GetStdHandle( STD_INPUT_HANDLE );
	if ( hInputConsole == NULL )
	{
		// could not get the handle so return failure
		return FALSE;
	}

	// Get the current input mode of the input buffer
	GetConsoleMode( hInputConsole, &dwPrevConsoleMode );
	
	// Set the mode such that the control keys are processed by the system
	if ( SetConsoleMode( hInputConsole, ENABLE_PROCESSED_INPUT ) == 0 )
	{
		// could not set the mode, return failure
		return FALSE;
	}
	
	//	Read the characters until a carriage return is hit
	while( TRUE )
	{
		
		if ( ReadConsole( hInputConsole, &ch, 1, &dwCharsRead, NULL ) == 0 )
		{
			// Set the original console settings
			SetConsoleMode( hInputConsole, dwPrevConsoleMode );
			
			// return failure
			return FALSE;
		}
		
		// Check for carraige return
		if ( ch == CARRIAGE_RETURN )
		{
			DISPLAY_MESSAGE(stdout, _T("\n"));
			// break from the loop
			break;
		}

			// Check id back space is hit
		if ( ch == BACK_SPACE )
		{
			if ( dwIndex != 0 )
			{
				//
				// Remove a asterix from the console

				// move the cursor one character back
				FORMAT_STRING( szBuffer, _T( "%c" ), BACK_SPACE );
				WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1, 
					&dwCharsWritten, NULL );
				
				// replace the existing character with space
				FORMAT_STRING( szBuffer, _T( "%c" ), BLANK_CHAR );
				WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1, 
					&dwCharsWritten, NULL );

				// now set the cursor at back position
				FORMAT_STRING( szBuffer, _T( "%c" ), BACK_SPACE );
				WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), szBuffer, 1, 
					&dwCharsWritten, NULL );

				// decrement the index 
				dwIndex--;
			}
			
			// process the next character
			continue;
		}

		// if the max user name length has been reached then sound a beep
		if ( dwIndex == ( dwMaxUserNameSize - 1 ) )
		{
			WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), BEEP_SOUND, 1, 
				&dwCharsRead, NULL );
		}
		else
		{
			// store the input character
			*( pszUserName + dwIndex ) = ch;
				
			// display asterix onto the console
			WriteConsole( GetStdHandle( STD_OUTPUT_HANDLE ), ( pszUserName + dwIndex ) , 1, 
				&dwCharsWritten, NULL );

			dwIndex++;

		}
	}

	// Add the NULL terminator
	*( pszUserName + dwIndex ) = NULL_CHAR;

	//	Return success
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scheduledtasks\create.cpp ===
/******************************************************************************

	Copyright(c) Microsoft Corporation

	Module Name:

		create.cpp

	Abstract:

		This module validates the options specied by the user & if correct creates
		a scheduled task.

	Author:

		Raghu babu  10-oct-2000

	Revision History:

		Raghu babu		  10-Oct-2000 : Created it
		G.Surender Reddy  25-oct-2000 : Modified it
		G.Surender Reddy  27-oct-2000 : Modified it
		G.Surender Reddy  30-oct-2000 : Modified it


******************************************************************************/ 

//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"

/******************************************************************************
	Routine Description:

		This routine  initialises the variables to neutral values ,helps in
		creating a new scheduled task

	Arguments:

		[ in ] argc	: The count of arguments specified in the command line
		[ in ] argv	: Array of command line arguments

	Return Value :
		A HRESULT value indicating S_OK on success else S_FALSE on failure
  
******************************************************************************/ 

HRESULT
CreateScheduledTask(DWORD argc , LPCTSTR argv[])
{	
	// declarations of structures
	TCREATESUBOPTS tcresubops;
	TCREATEOPVALS tcreoptvals; 
	DWORD dwScheduleType = 0;
	WORD wUserStatus = FALSE;

	//Initialise the structure to neutral values.	
	lstrcpy(tcresubops.szServer, NULL_STRING); 
    lstrcpy(tcresubops.szUser, NULL_STRING); 
	lstrcpy(tcresubops.szPassword, NULL_STRING);
	lstrcpy(tcresubops.szRunAsUser, NULL_STRING); 
	lstrcpy(tcresubops.szRunAsPassword, NULL_STRING);
    lstrcpy(tcresubops.szSchedType, NULL_STRING);
    lstrcpy(tcresubops.szModifier, NULL_STRING);
    lstrcpy(tcresubops.szDays, NULL_STRING);
    lstrcpy(tcresubops.szMonths, NULL_STRING);
    lstrcpy(tcresubops.szIdleTime, NULL_STRING);
    lstrcpy(tcresubops.szTaskName, NULL_STRING);
    lstrcpy(tcresubops.szStartTime, NULL_STRING);
    lstrcpy(tcresubops.szStartDate, NULL_STRING);
    lstrcpy(tcresubops.szEndDate, NULL_STRING);
    lstrcpy(tcresubops.szTaskRun, NULL_STRING);

	tcresubops.bCreate		   = FALSE;
	tcresubops.bUsage		   = FALSE;

	tcreoptvals.bSetStartDateToCurDate = FALSE;
	tcreoptvals.bSetStartTimeToCurTime = FALSE;
	tcreoptvals.bPassword = FALSE;
	tcreoptvals.bRunAsPassword = FALSE;

	// process the options for -create option
	if( ProcessCreateOptions ( argc, argv, tcresubops, tcreoptvals, &dwScheduleType, &wUserStatus ) )
	{
		if(tcresubops.bUsage == TRUE)
		{
			return S_OK;
		}
		else
		{
			return E_FAIL;
		}
	}
	
	// calls the function to create a scheduled task
	return CreateTask(tcresubops,tcreoptvals,dwScheduleType, wUserStatus );
}


/******************************************************************************
	Routine Description:

	This routine  creates a new scheduled task according to the user 
	specified format

	Arguments:

		[ in ]  tcresubops     : Structure containing the task's properties
		[ out ] tcreoptvals	   : Structure containing optional values to set
		[ in ]  dwScheduleType : Type of schedule[Daily,once,weekly etc]
		[ in ]  bUserStatus	   : bUserStatus will be TRUE when -ru given else FALSE

	Return Value :
		A HRESULT value indicating S_OK on success else S_FALSE on failure
******************************************************************************/ 

HRESULT
CreateTask(TCREATESUBOPTS tcresubops, TCREATEOPVALS &tcreoptvals, DWORD dwScheduleType, 
															WORD wUserStatus)
{
	// Declarations related to the system time
	WORD  wStartDay		= 0;
	WORD  wStartMonth	= 0;
	WORD  wStartYear	= 0;
	WORD  wStartHour	= 0; 
	WORD  wStartMin		= 0;
	WORD  wStartSec		= 0;
	WORD  wEndDay		= 0;
	WORD  wEndYear		= 0;
	WORD  wEndMonth		= 0;
	WORD  wIdleTime		= 0;

	SYSTEMTIME systime = {0,0,0,0,0,0,0,0};
	
	// Declarations related to the new task
    WCHAR	wszJobName[MAX_TASKNAME_LEN] = NULL_U_STRING;
	WCHAR	wszTime[MAX_TIMESTR_LEN] = NULL_U_STRING;
    WCHAR	wszUserName[MAX_STRING_LENGTH] = NULL_U_STRING;
	WCHAR	wszPassword[MAX_STRING_LENGTH] = NULL_U_STRING;
	WCHAR	wszCommand[_MAX_FNAME] = NULL_U_STRING;
	WCHAR	wszApplName[_MAX_FNAME] = NULL_U_STRING;
	TCHAR	szErrorDesc[MAX_RES_STRING] = NULL_STRING;
    TCHAR	szRPassword[MAX_USERNAME_LENGTH] = NULL_STRING;

	HRESULT hr = S_OK;
    IPersistFile *pIPF = NULL;
    ITask *pITask = NULL;
    ITaskTrigger *pITaskTrig = NULL;
	ITaskScheduler *pITaskScheduler = NULL;
    WORD wTrigNumber = 0;
    
	TASK_TRIGGER TaskTrig;
	ZeroMemory(&TaskTrig, sizeof (TASK_TRIGGER));
	TaskTrig.cbTriggerSize = sizeof (TASK_TRIGGER); 
	TaskTrig.Reserved1 = 0; // reserved field and must be set to 0.
	TaskTrig.Reserved2 = 0; // reserved field and must be set to 0.
	_TCHAR* szValues[1] = {NULL};//To pass to FormatMessage() API

	
	// Buffer to store the string obtained from the string table
	TCHAR szBuffer[MAX_STRING_LENGTH] = NULL_STRING;
	
	BOOL bPassWord = FALSE;
	BOOL bUserName = FALSE;
	BOOL bRet = FALSE;
	BOOL bResult = FALSE;
	BOOL bCloseConnection = TRUE;
	ULONG ulLong = MAX_RES_STRING;
	BOOL bVal = FALSE;

	// check whether the taskname contains the characters such 
	// as '<','>',':','/','\\','|'
	bRet = VerifyJobName(tcresubops.szTaskName);
	if(bRet == FALSE)
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_TASKNAME1));
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_TASKNAME2));
		Cleanup(pITaskScheduler);
		return E_FAIL;
	}
	
	// check for the length of taskname
	if( ( lstrlen(tcresubops.szTaskName) > MAX_JOB_LEN ) ||
		( lstrlen(tcresubops.szTaskName) == 0 ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_TASKLENGTH));
		Cleanup(pITaskScheduler);
		return E_FAIL;
	}

	// check for the length of taskrun
	if(( lstrlen(tcresubops.szTaskRun) > MAX_TASK_LEN ) ||
		( lstrlen(tcresubops.szTaskRun) == 0 ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_TASKRUN));
		Cleanup(pITaskScheduler);
		return E_FAIL;
	
	}

	// check for the length of username
	if( ( lstrlen(tcresubops.szRunAsUser) > MAX_USERNAME_LENGTH ) || 
		( lstrlen(tcresubops.szUser) > MAX_USERNAME_LENGTH ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_UNAME  ));
		Cleanup(pITaskScheduler);
		return E_FAIL;
	}

	// check for the length of password
	if( ( lstrlen(tcresubops.szRunAsPassword) > MAX_PASSWORD_LENGTH ) ||
		( lstrlen(tcresubops.szPassword) > MAX_PASSWORD_LENGTH ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_PASSWORD));
		Cleanup(pITaskScheduler);
		return E_FAIL;
	}

	// check for empty password
	if( ( tcreoptvals.bRunAsPassword == TRUE ) && ( lstrlen(tcresubops.szRunAsPassword) == 0 ) &&
		( lstrlen ( tcresubops.szRunAsUser ) != 0 ) &&
		( lstrcmpi(tcresubops.szRunAsUser, NTAUTHORITY_USER ) != 0 ) &&
		( lstrcmpi(tcresubops.szRunAsUser, SYSTEM_USER ) != 0 ) )
	{
		DISPLAY_MESSAGE(stdout, GetResString(IDS_WARN_EMPTY_PASSWORD));
	}

	// Convert the task name specified by the user to wide char or unicode format
	if( GetAsUnicodeString(tcresubops.szTaskName,wszJobName,SIZE_OF_ARRAY(wszJobName) ) == NULL )
	{
		Cleanup(pITaskScheduler);
		return E_FAIL;
	}
	
	// Convert the start time specified by the user to wide char or unicode format
	if(GetAsUnicodeString(tcresubops.szStartTime,wszTime,SIZE_OF_ARRAY(wszTime)) == NULL )
	{
		Cleanup(pITaskScheduler);
		return E_FAIL;
	}	

	// Convert the task to run specified by the user to wide char or unicode format
	if( GetAsUnicodeString(tcresubops.szTaskRun,wszCommand,SIZE_OF_ARRAY(wszCommand)) == NULL )
	{
		Cleanup(pITaskScheduler);
		return E_FAIL;
	}

	// check for the local system
	if ( ( IsLocalSystem( tcresubops.szServer ) == TRUE ) && 
		( lstrlen ( tcresubops.szRunAsUser ) != 0 ) &&
		( lstrcmpi(tcresubops.szRunAsUser, NTAUTHORITY_USER ) != 0 ) &&
		( lstrcmpi(tcresubops.szRunAsUser, SYSTEM_USER ) != 0 ) )

	{
		// Establish the connection on a remote machine
		bResult = EstablishConnection(tcresubops.szServer,tcresubops.szUser,SIZE_OF_ARRAY(tcresubops.szUser),tcresubops.szPassword,SIZE_OF_ARRAY(tcresubops.szPassword), !(tcreoptvals.bPassword));
		if (bResult == FALSE)
		{
			DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_STRING) );
			DISPLAY_MESSAGE( stderr, GetReason());
			Cleanup(pITaskScheduler);
			return EXIT_FAILURE ;
		}
		else
		{
			// though the connection is successfull, some conflict might have occured
			switch( GetLastError() )
			{
			case I_NO_CLOSE_CONNECTION:
				bCloseConnection = FALSE;
				break;

			// check for mismatched credentials	
			case E_LOCAL_CREDENTIALS:
			case ERROR_SESSION_CREDENTIAL_CONFLICT:
				{
					bCloseConnection = FALSE;
					DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_STRING) );
					DISPLAY_MESSAGE( stderr, GetReason());
					Cleanup(pITaskScheduler);
					return EXIT_FAILURE;
				}
			}
	
		}

		if ( lstrlen (tcresubops.szRunAsUser) != 0 )
		{
			// Convert the user name specified by the user to wide char or unicode format
			if ( GetAsUnicodeString( tcresubops.szRunAsUser, wszUserName, SIZE_OF_ARRAY(wszUserName)) == NULL )
			{
				Cleanup(pITaskScheduler);
				return E_FAIL;
			}
				
			bUserName = TRUE;			
			
			if ( tcreoptvals.bRunAsPassword == FALSE )
			{
				szValues[0] = (_TCHAR*) (wszUserName);
				//Display that the task will be created under logged in user name,ask for password 
				MessageBeep(MB_ICONEXCLAMATION);

				FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
							  GetResString(IDS_PROMPT_PASSWD),0,MAKELANGID(LANG_NEUTRAL,
							  SUBLANG_DEFAULT),szBuffer,
							  MAX_STRING_LENGTH,(va_list*)szValues );
							 
				DISPLAY_MESSAGE(stdout,szBuffer);
			
				// getting the password
				if (GetPassword(szRPassword, MAX_PASSWORD_LENGTH) == FALSE )
				{
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}

				// check for empty password
				if( lstrlen ( szRPassword ) == 0 )
				{
					DISPLAY_MESSAGE(stdout, GetResString(IDS_WARN_EMPTY_PASSWORD));
				}

				// check for the length of password
				if( lstrlen( szRPassword ) > MAX_PASSWORD_LENGTH )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_PASSWORD));
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}

				if(lstrlen(szRPassword))
				{
					// Convert the password specified by the user to wide char or unicode format
					if (GetAsUnicodeString(szRPassword,wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
					{
						Cleanup(pITaskScheduler);
						return E_FAIL;
					}
				}

				bPassWord = TRUE;
			}
			else
			{
				// Convert the password specified by the user to wide char or unicode format
				if (GetAsUnicodeString(tcresubops.szRunAsPassword,wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
				{
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}

				bPassWord = TRUE;
			}
		
		}
	}
	// check whether -s option only specified in the cmd line or not
	else if( ( IsLocalSystem( tcresubops.szServer ) == FALSE ) && ( wUserStatus == OI_SERVER ) )
	{
		// Establish the connection on a remote machine
		bResult = EstablishConnection(tcresubops.szServer,tcresubops.szUser,SIZE_OF_ARRAY(tcresubops.szUser),tcresubops.szPassword,SIZE_OF_ARRAY(tcresubops.szPassword), !(tcreoptvals.bPassword));
		if (bResult == FALSE)
		{
			DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_STRING) );
			DISPLAY_MESSAGE( stderr, GetReason());
			Cleanup(pITaskScheduler);
			return EXIT_FAILURE ;
		}
		else
		{
			// though the connection is successfull, some conflict might have occured
			switch( GetLastError() )
			{
			case I_NO_CLOSE_CONNECTION:
				bCloseConnection = FALSE;
				break;

			// check for mismatched credentials	
			case E_LOCAL_CREDENTIALS:
			case ERROR_SESSION_CREDENTIAL_CONFLICT:
				{
					bCloseConnection = FALSE;
					DISPLAY_MESSAGE( stdout, GetResString(IDS_ERROR_STRING) );
					DISPLAY_MESSAGE( stdout, GetReason());
					Cleanup(pITaskScheduler);
					return EXIT_FAILURE;
				}
			}
	
		}
		
		if ( ( bCloseConnection == FALSE ) && ( lstrlen (tcresubops.szUser) == 0 ) )
		{
			//get the current logged on username 
			if ( GetUserNameEx ( NameSamCompatible, tcresubops.szUser , &ulLong) == FALSE )
			{
				DISPLAY_MESSAGE( stderr, GetResString( IDS_LOGGED_USER_ERR ) );
				Cleanup(pITaskScheduler);
				return E_FAIL;
			}

			bUserName = TRUE;

			// Convert the user name specified by the user to wide char or unicode format
			if ( GetAsUnicodeString( tcresubops.szUser, wszUserName, SIZE_OF_ARRAY(wszUserName)) == NULL )
			{
				Cleanup(pITaskScheduler);
				return E_FAIL;
			}
							   
			szValues[0] = (_TCHAR*) (wszUserName);
			//Display that the task will be created under logged in user name,ask for password 
			MessageBeep(MB_ICONEXCLAMATION);

			// format the message for currently logged-on user name
			FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
						  GetResString(IDS_TASK_INFO),0,MAKELANGID(LANG_NEUTRAL,
						  SUBLANG_DEFAULT),szBuffer,
						  MAX_STRING_LENGTH,(va_list*)szValues );
						 
			DISPLAY_MESSAGE(stdout,szBuffer);

			// format the message for getting the password from the console
			FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
						  GetResString(IDS_PROMPT_PASSWD),0,MAKELANGID(LANG_NEUTRAL,
						  SUBLANG_DEFAULT),szBuffer,
						  MAX_STRING_LENGTH,(va_list*)szValues );
						 
			DISPLAY_MESSAGE(stdout,szBuffer);
		
			if (GetPassword(tcresubops.szRunAsPassword, MAX_PASSWORD_LENGTH) == FALSE )
			{
				Cleanup(pITaskScheduler);
				return E_FAIL;
			}

			// check for empty password
			if( lstrlen ( tcresubops.szRunAsPassword ) == 0 )
			{
				DISPLAY_MESSAGE(stdout, GetResString(IDS_WARN_EMPTY_PASSWORD));
			}

			// check for the length of password
			if( lstrlen( tcresubops.szRunAsPassword ) > MAX_PASSWORD_LENGTH )
			{
				DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_PASSWORD));
				Cleanup(pITaskScheduler);
				return E_FAIL;
			}

			// check for the length of the password
			if(lstrlen(tcresubops.szRunAsPassword))
			{
				// Convert the password specified by the user to wide char or unicode format
				if (GetAsUnicodeString(tcresubops.szRunAsPassword,wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
				{
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}
			}
			
			bPassWord = TRUE;

		}

		// Convert the user name specified by the user to wide char or unicode format
		if( GetAsUnicodeString(tcresubops.szUser,wszUserName,SIZE_OF_ARRAY(wszUserName)) == NULL )
		{
			Cleanup(pITaskScheduler);
			return E_FAIL;
		}
		
		// check whether the run as password is specified in the cmdline or not
		if ( tcreoptvals.bRunAsPassword == TRUE )
		{
			// check for -rp "*" or -rp " " to prompt for password
			if ( lstrcmpi( tcresubops.szRunAsPassword, ASTERIX ) == 0 ) 
			{
				// format the message for getting the password
				szValues[0] = (_TCHAR*) (wszUserName);
				FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
					  GetResString(IDS_PROMPT_PASSWD),0,MAKELANGID(LANG_NEUTRAL,
				      SUBLANG_DEFAULT),szBuffer,
				      MAX_STRING_LENGTH,(va_list*)szValues
				     );
			
				DISPLAY_MESSAGE(stdout,szBuffer);

				// Get the run as password from the command line
				if ( GetPassword(tcresubops.szRunAsPassword, MAX_PASSWORD_LENGTH ) == FALSE )
				{
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}
				
				// check for empty password
				if( lstrlen ( tcresubops.szRunAsPassword ) == 0 )
				{
					DISPLAY_MESSAGE(stdout, GetResString(IDS_WARN_EMPTY_PASSWORD));
				}

				// check for the length of the password
				if( lstrlen(tcresubops.szRunAsPassword) > MAX_PASSWORD_LENGTH )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_PASSWORD));
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}

				// Convert the password specified by the user to wide char or unicode format
				if ( GetAsUnicodeString( tcresubops.szRunAsPassword,wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
				{
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}
			}
		}
		else
		{
			// Convert the password specified by the user to wide char or unicode format
			if ( GetAsUnicodeString( tcresubops.szPassword,wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
			{
				Cleanup(pITaskScheduler);
				return E_FAIL;
			}
			
		}
		// set the BOOL variables to TRUE
		bUserName = TRUE;	
		bPassWord = TRUE; 
		
	}
	// check for -s and -u options only specified in the cmd line or not
	else if ( wUserStatus == OI_USERNAME ) 
	{
		
		// Establish the connection on a remote machine
		bResult = EstablishConnection(tcresubops.szServer,tcresubops.szUser,SIZE_OF_ARRAY(tcresubops.szUser),tcresubops.szPassword,SIZE_OF_ARRAY(tcresubops.szPassword), !(tcreoptvals.bPassword));
		if (bResult == FALSE)
		{
			DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_STRING) );
			DISPLAY_MESSAGE( stderr, GetReason());
			Cleanup(pITaskScheduler);
			return EXIT_FAILURE ;
		}
		else
		{
			// though the connection is successfull, some conflict might have occured
			switch( GetLastError() )
			{
			case I_NO_CLOSE_CONNECTION:
				bCloseConnection = FALSE;
				break;

			// for mismatched credentials
			case E_LOCAL_CREDENTIALS:
			case ERROR_SESSION_CREDENTIAL_CONFLICT:
				{
					bCloseConnection = FALSE;
					DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_STRING) );
					DISPLAY_MESSAGE( stderr, GetReason());

					Cleanup(pITaskScheduler);
					return EXIT_FAILURE;
				}
			}
	
		}
			
		// Convert the user name specified by the user to wide char or unicode format
		if( GetAsUnicodeString(tcresubops.szUser,wszUserName,SIZE_OF_ARRAY(wszUserName)) == NULL )
		{
			Cleanup(pITaskScheduler);
			return E_FAIL;
		}
		
		// check whether run as password is specified in the command line or not
		if ( tcreoptvals.bRunAsPassword == TRUE )
		{
			// check for -rp "*" or -rp " " to prompt for password
			if ( lstrcmpi( tcresubops.szRunAsPassword, ASTERIX ) == 0 ) 
			{
				// format the message for getting the password from console
				szValues[0] = (_TCHAR*) (wszUserName);
				FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
					  GetResString(IDS_PROMPT_PASSWD),0,MAKELANGID(LANG_NEUTRAL,
				      SUBLANG_DEFAULT),szBuffer,
				      MAX_STRING_LENGTH,(va_list*)szValues
				     );
			
				DISPLAY_MESSAGE(stdout,szBuffer);

				// Get the password from the command line
				if ( GetPassword(tcresubops.szRunAsPassword, MAX_PASSWORD_LENGTH ) == FALSE )
				{
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}
				
				// check for empty password
				if( lstrlen ( tcresubops.szRunAsPassword ) == 0 )
				{
					DISPLAY_MESSAGE(stdout, GetResString(IDS_WARN_EMPTY_PASSWORD));
				}

				// check for the length of password
				if( lstrlen(tcresubops.szRunAsPassword) > MAX_PASSWORD_LENGTH )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_PASSWORD));
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}

				// Convert the password specified by the user to wide char or unicode format
				if ( GetAsUnicodeString( tcresubops.szRunAsPassword,wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
				{
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}			
			}
			else
			{
				// Convert the password specified by the user to wide char or unicode format
				if ( GetAsUnicodeString( tcresubops.szRunAsPassword,wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
				{
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}
			
				bPassWord = TRUE; 
			}
		}
		else
		{
			if ( lstrlen(tcresubops.szPassword) != 0 )
			{
				// Convert the password specified by the user to wide char or unicode format
				if ( GetAsUnicodeString( tcresubops.szPassword,wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
				{
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}
			}
			else
			{
				// format the message for getting the password from console
				szValues[0] = (_TCHAR*) (wszUserName);
				FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
					  GetResString(IDS_PROMPT_PASSWD),0,MAKELANGID(LANG_NEUTRAL,
					  SUBLANG_DEFAULT),szBuffer,
					  MAX_STRING_LENGTH,(va_list*)szValues
					 );
			
				DISPLAY_MESSAGE(stdout,szBuffer);

				// Get the password from the command line
				if ( GetPassword(tcresubops.szRunAsPassword, MAX_PASSWORD_LENGTH ) == FALSE )
				{
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}

				// check for empty password
				if( lstrlen ( tcresubops.szRunAsPassword ) == 0 )
				{
					DISPLAY_MESSAGE(stdout, GetResString(IDS_WARN_EMPTY_PASSWORD));
				}
								
				// check for the length of password
				if( lstrlen(tcresubops.szRunAsPassword) > MAX_PASSWORD_LENGTH )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_PASSWORD));
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}

				// Convert the password specified by the user to wide char or unicode format
				if ( GetAsUnicodeString( tcresubops.szRunAsPassword,wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
				{
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}
			}
		
		}

		bUserName = TRUE;	
		bPassWord = TRUE; 
	
	}
	// check for -s, -ru or -u options specified in the cmd line or not
	else if ( ( lstrlen (tcresubops.szServer) != 0 ) && ( wUserStatus == OI_RUNASUSERNAME || wUserStatus == OI_RUNANDUSER ) )
	{
		// Establish the connection on a remote machine
		bResult = EstablishConnection(tcresubops.szServer,tcresubops.szUser,SIZE_OF_ARRAY(tcresubops.szUser),tcresubops.szPassword,SIZE_OF_ARRAY(tcresubops.szPassword), !(tcreoptvals.bPassword));
		if (bResult == FALSE)
		{
			DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_STRING) );
			DISPLAY_MESSAGE( stderr, GetReason());
			Cleanup(pITaskScheduler);
			return EXIT_FAILURE ;
		}
		else
		{
			// though the connection is successfull, some conflict might have occured
			switch( GetLastError() )
			{
			case I_NO_CLOSE_CONNECTION:
				bCloseConnection = FALSE;
				break;

			case E_LOCAL_CREDENTIALS:
			case ERROR_SESSION_CREDENTIAL_CONFLICT:
				{
					bCloseConnection = FALSE;
					DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_STRING) );
					DISPLAY_MESSAGE( stderr, GetReason());
					Cleanup(pITaskScheduler);
					return EXIT_FAILURE;
				}
			}
		}

		
		if ( ( ( lstrlen ( tcresubops.szRunAsUser ) == 0 ) || 
			  ( lstrcmpi( tcresubops.szRunAsUser, NTAUTHORITY_USER ) == 0 ) || 
			  ( lstrcmpi( tcresubops.szRunAsUser, SYSTEM_USER ) == 0 ) ) )
		{
			// Convert the run as user name specified by the user to wide char or unicode format
			if( GetAsUnicodeString(tcresubops.szRunAsUser,wszUserName,SIZE_OF_ARRAY(wszUserName)) == NULL )
			{
				Cleanup(pITaskScheduler);
				return E_FAIL;
			}

			szValues[0] = (_TCHAR*) (wszJobName);
			FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
					  GetResString(IDS_NTAUTH_SYSTEM_INFO),0,MAKELANGID(LANG_NEUTRAL,
				      SUBLANG_DEFAULT),szBuffer,
				      MAX_STRING_LENGTH,(va_list*)szValues
				     );
			
			DISPLAY_MESSAGE(stdout,szBuffer);
			if ( ( tcreoptvals.bRunAsPassword == TRUE ) && 
				( lstrlen (tcresubops.szRunAsPassword) != 0 ) )
			{
				DISPLAY_MESSAGE( stdout, GetResString( IDS_PASSWORD_NOEFFECT ) ); 
			}
			bUserName = TRUE;	
			bPassWord = TRUE; 
			bVal = TRUE;
		}
		else
		{
			// check for the length of password
			if ( lstrlen ( tcresubops.szRunAsUser ) != 0 )
			{
				// Convert the run as user name specified by the user to wide char or unicode format
				if( GetAsUnicodeString(tcresubops.szRunAsUser,wszUserName,SIZE_OF_ARRAY(wszUserName)) == NULL )
				{
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}

				bUserName = TRUE;
			}
		}

		// check whether -u and -ru are the same or not. if they are same, we need to 
		// prompt for the run as password. otherwise, will consoder -rp as -p
		if ( lstrcmpi( tcresubops.szRunAsUser, tcresubops.szUser ) != 0) 
		{
			if ( tcreoptvals.bRunAsPassword == TRUE ) 
			{
				if ( (lstrlen(tcresubops.szRunAsUser) != 0) && (lstrcmpi( tcresubops.szRunAsPassword, ASTERIX ) == 0 ) &&
					 ( lstrcmpi( tcresubops.szRunAsUser, NTAUTHORITY_USER ) != 0 ) && 
					 ( lstrcmpi( tcresubops.szRunAsUser, SYSTEM_USER ) != 0 ) ) 
				{
					szValues[0] = (_TCHAR*) (wszUserName);
				
					FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
							  GetResString(IDS_PROMPT_PASSWD),0,MAKELANGID(LANG_NEUTRAL,
							  SUBLANG_DEFAULT),szBuffer,
							  MAX_STRING_LENGTH,(va_list*)szValues
							 );
					
					DISPLAY_MESSAGE(stdout,szBuffer);

					// prompt for the run as password
					if ( GetPassword(szRPassword, MAX_PASSWORD_LENGTH ) == FALSE )
					{
						Cleanup(pITaskScheduler);
						return E_FAIL;
					}

					// check for empty password
					if( lstrlen ( szRPassword ) == 0 )
					{
						DISPLAY_MESSAGE(stdout, GetResString(IDS_WARN_EMPTY_PASSWORD));
					}

					// check for the length of password
					if( lstrlen(szRPassword) > MAX_PASSWORD_LENGTH )
					{
						DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_PASSWORD));
						Cleanup(pITaskScheduler);
						return E_FAIL;
					}
					
					// Convert the password specified by the user to wide char or unicode format
					if ( GetAsUnicodeString( szRPassword,wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
					{
						Cleanup(pITaskScheduler);
						return E_FAIL;
					}
					
					bUserName = TRUE;
					bPassWord = TRUE;
				}
				else
				{
					// Convert the password specified by the user to wide char or unicode format
					if ( GetAsUnicodeString( tcresubops.szRunAsPassword,wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
					{
						Cleanup(pITaskScheduler);
						return E_FAIL;
					}
					
					bUserName = TRUE;
					bPassWord = TRUE;
				}
		  	}
			else
			{
				// check for the length of password
				if ( ( bVal == FALSE ) && ( lstrlen(tcresubops.szRunAsUser) != 0) )
				{
					// format the message for getting the password from console
					szValues[0] = (_TCHAR*) (wszUserName);
					FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
								  GetResString(IDS_PROMPT_PASSWD),0,MAKELANGID(LANG_NEUTRAL,
								  SUBLANG_DEFAULT),szBuffer,
								  MAX_STRING_LENGTH,(va_list*)szValues
								 );
						
					DISPLAY_MESSAGE(stdout,szBuffer);

					// prompt for the run as password
					if ( GetPassword(szRPassword, MAX_PASSWORD_LENGTH ) == FALSE )
					{
						Cleanup(pITaskScheduler);
						return E_FAIL;
					}

					// check for empty password
					if( lstrlen ( szRPassword ) == 0 )
					{
						DISPLAY_MESSAGE(stdout, GetResString(IDS_WARN_EMPTY_PASSWORD));
					}
					
					// check for the length of password
					if( lstrlen(szRPassword) > MAX_PASSWORD_LENGTH )
					{
							DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_PASSWORD));
							Cleanup(pITaskScheduler);
							return E_FAIL;
					}
						
					// Convert the password specified by the user to wide char or unicode format
					if ( GetAsUnicodeString( szRPassword,wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
					{
						Cleanup(pITaskScheduler);
						return E_FAIL;
					}
				}
				bUserName = TRUE;
				bPassWord = TRUE;
			}
		}
		else
		{
			// check whether run as password is specified in the cmdline or not
			if ( tcreoptvals.bRunAsPassword == TRUE ) 
			{
				if ( ( lstrlen ( tcresubops.szRunAsUser ) != 0 ) && ( lstrcmpi( tcresubops.szRunAsPassword, ASTERIX ) == 0 ) )
				{
					szValues[0] = (_TCHAR*) (wszUserName);
					FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
								  GetResString(IDS_PROMPT_PASSWD),0,MAKELANGID(LANG_NEUTRAL,
								  SUBLANG_DEFAULT),szBuffer,
								  MAX_STRING_LENGTH,(va_list*)szValues
								 );
						
					DISPLAY_MESSAGE(stdout,szBuffer);

					// prompt for the run as password
					if ( GetPassword(szRPassword, MAX_PASSWORD_LENGTH ) == FALSE )
					{
						Cleanup(pITaskScheduler);
						return E_FAIL;
					}

					// check for empty password
					if( lstrlen ( szRPassword ) == 0 )
					{
						DISPLAY_MESSAGE(stdout, GetResString(IDS_WARN_EMPTY_PASSWORD));
					}

					// check for the length of password
					if( lstrlen(szRPassword) > MAX_PASSWORD_LENGTH )
					{
							DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_PASSWORD));
							Cleanup(pITaskScheduler);
							return E_FAIL;
					}
						
					// Convert the password specified by the user to wide char or unicode format
					if ( GetAsUnicodeString( szRPassword,wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
					{
						Cleanup(pITaskScheduler);
						return E_FAIL;
					}
					
				}
				else
				{
					// Convert the password specified by the user to wide char or unicode format
					if ( GetAsUnicodeString( tcresubops.szRunAsPassword,wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
					{
						Cleanup(pITaskScheduler);
						return E_FAIL;
					}
				}

			}
			else
			{
				if ( lstrlen (tcresubops.szPassword) )
				{
					// Convert the password specified by the user to wide char or unicode format
					if ( GetAsUnicodeString( tcresubops.szPassword,wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
					{
						Cleanup(pITaskScheduler);
						return E_FAIL;
					}
				}
				else
				{
					if (( lstrlen ( tcresubops.szRunAsUser ) != 0 ) &&
						( lstrcmpi(tcresubops.szRunAsUser, NTAUTHORITY_USER ) != 0 ) &&
						( lstrcmpi(tcresubops.szRunAsUser, SYSTEM_USER ) != 0 ) )
					{
						szValues[0] = (_TCHAR*) (wszUserName);
						FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
									  GetResString(IDS_PROMPT_PASSWD),0,MAKELANGID(LANG_NEUTRAL,
									  SUBLANG_DEFAULT),szBuffer,
									  MAX_STRING_LENGTH,(va_list*)szValues
									 );
							
						DISPLAY_MESSAGE(stdout,szBuffer);

						// prompt for the run as password
						if ( GetPassword(szRPassword, MAX_PASSWORD_LENGTH ) == FALSE )
						{
							Cleanup(pITaskScheduler);
							return E_FAIL;
						}

						// check for empty password
						if( lstrlen ( szRPassword ) == 0 )
						{
							DISPLAY_MESSAGE(stdout, GetResString(IDS_WARN_EMPTY_PASSWORD));
						}

						// check for the length of password
						if( lstrlen(szRPassword) > MAX_PASSWORD_LENGTH )
						{
								DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_PASSWORD));
								Cleanup(pITaskScheduler);
								return E_FAIL;
						}
							
						// Convert the password specified by the user to wide char or unicode format
						if ( GetAsUnicodeString( szRPassword,wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
						{
							Cleanup(pITaskScheduler);
							return E_FAIL;
						}
					}
				}
			}

			bUserName = TRUE;
			bPassWord = TRUE;
		}
		
	}		


	// To check for the -ru values "", "NT AUTHORITY\SYSTEM", "SYSTEM" 
	if( ( ( bVal == FALSE ) && ( wUserStatus == OI_RUNASUSERNAME ) && ( lstrlen( tcresubops.szRunAsUser) == 0 ) && ( tcreoptvals.bRunAsPassword == FALSE ) ) || 
		( ( bVal == FALSE ) && ( wUserStatus == OI_RUNASUSERNAME ) && ( lstrlen( tcresubops.szRunAsUser) == 0 ) && ( lstrlen(tcresubops.szRunAsPassword ) == 0 ) ) ||
		( ( bVal == FALSE ) && ( wUserStatus == OI_RUNASUSERNAME ) && ( lstrcmpi(tcresubops.szRunAsUser, NTAUTHORITY_USER ) == 0 ) && ( tcreoptvals.bRunAsPassword == FALSE ) ) ||
		( ( bVal == FALSE ) && ( wUserStatus == OI_RUNASUSERNAME ) && ( lstrcmpi(tcresubops.szRunAsUser, NTAUTHORITY_USER ) == 0 ) && ( lstrlen( tcresubops.szRunAsPassword) == 0 ) ) ||
		( ( bVal == FALSE ) && ( wUserStatus == OI_RUNASUSERNAME ) && ( lstrcmpi(tcresubops.szRunAsUser, SYSTEM_USER ) == 0 ) && ( tcreoptvals.bRunAsPassword == FALSE ) ) ||
		( ( bVal == FALSE ) && ( wUserStatus == OI_RUNASUSERNAME ) && ( lstrcmpi(tcresubops.szRunAsUser, SYSTEM_USER ) == 0 ) && ( lstrlen(tcresubops.szRunAsPassword) == 0 ) ) )
	{
		//format the message to display the taskname will be created under "NT AUTHORITY\SYSTEM" 
		szValues[0] = (_TCHAR*) (wszJobName);
		FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
					  GetResString(IDS_NTAUTH_SYSTEM_INFO),0,MAKELANGID(LANG_NEUTRAL,
				      SUBLANG_DEFAULT),szBuffer,
				      MAX_STRING_LENGTH,(va_list*)szValues
				     );
			
		DISPLAY_MESSAGE(stdout,szBuffer);

		bUserName = TRUE;	
		bPassWord = TRUE; 
		bVal = TRUE;
	}
	// check whether the -rp value is given with the -ru "", "NT AUTHORITY\SYSTEM", 
	// "SYSTEM" or not
	else if( ( ( bVal == FALSE ) && ( wUserStatus == OI_RUNASUSERNAME || wUserStatus == OI_RUNANDUSER) && ( lstrlen(tcresubops.szRunAsUser) == 0 ) && ( lstrlen(tcresubops.szRunAsPassword) != 0 ) ) || 
		( ( bVal == FALSE ) && ( wUserStatus == OI_RUNASUSERNAME || wUserStatus == OI_RUNANDUSER) && ( lstrcmpi( tcresubops.szRunAsUser, NTAUTHORITY_USER ) == 0 ) && ( tcreoptvals.bRunAsPassword == TRUE ) ) ||
		( ( bVal == FALSE ) && ( wUserStatus == OI_RUNASUSERNAME || wUserStatus == OI_RUNANDUSER) && ( lstrcmpi( tcresubops.szRunAsUser, SYSTEM_USER ) == 0 ) && ( tcreoptvals.bRunAsPassword == TRUE ) ) )
	{	
		szValues[0] = (_TCHAR*) (wszJobName);
		FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
					  GetResString(IDS_NTAUTH_SYSTEM_INFO),0,MAKELANGID(LANG_NEUTRAL,
				      SUBLANG_DEFAULT),szBuffer,
				      MAX_STRING_LENGTH,(va_list*)szValues
				     );
			
		DISPLAY_MESSAGE(stdout,szBuffer);
		// to display a warning message as password will not effect for the system account
		DISPLAY_MESSAGE( stdout, GetResString( IDS_PASSWORD_NOEFFECT ) ); 
		bUserName = TRUE;	
		bPassWord = TRUE; 
		bVal = TRUE;
	}
	// check whether -s, -u, -ru options are given in the cmdline or not
	else if( ( wUserStatus != OI_SERVER ) && ( wUserStatus != OI_USERNAME ) && 
		( wUserStatus != OI_RUNASUSERNAME ) && ( wUserStatus != OI_RUNANDUSER ) &&
		( lstrcmpi( tcresubops.szRunAsPassword , NULL_STRING ) == 0 ) )
	{
			if (tcreoptvals.bRunAsPassword == TRUE)
			{
				bPassWord = TRUE;
			}
			else
			{
				bPassWord = FALSE;
			}
	}
	else if ( ( lstrlen(tcresubops.szServer) == 0 ) && (lstrlen ( tcresubops.szRunAsUser ) != 0 ) )
	{
		// Convert the run as user name specified by the user to wide char or unicode format
		if ( GetAsUnicodeString( tcresubops.szRunAsUser, wszUserName, SIZE_OF_ARRAY(wszUserName)) == NULL )
		{
			Cleanup(pITaskScheduler);
			return E_FAIL;
		}
		
		bUserName = TRUE;

		if ( lstrlen ( tcresubops.szRunAsPassword ) == 0 )
		{
			bPassWord = TRUE;
		}
		else
		{
			// check whether "*" or NULL value is given for -rp or not
			if ( lstrcmpi ( tcresubops.szRunAsPassword , ASTERIX ) == 0 )
			{
				// format a message for getting the password from the console
				szValues[0] = (_TCHAR*) (wszUserName);
				FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
					  GetResString(IDS_PROMPT_PASSWD),0,MAKELANGID(LANG_NEUTRAL,
				      SUBLANG_DEFAULT),szBuffer,
				      MAX_STRING_LENGTH,(va_list*)szValues
				     );
			
				DISPLAY_MESSAGE(stdout,szBuffer);

				// Get the password from the command line 
				if (GetPassword(szRPassword, MAX_PASSWORD_LENGTH ) == FALSE )
				{
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}

				// check for empty password
				if( lstrlen ( szRPassword ) == 0 )
				{
					DISPLAY_MESSAGE(stdout, GetResString(IDS_WARN_EMPTY_PASSWORD));
				}

				// check for the length of password
				if( lstrlen( szRPassword ) > MAX_PASSWORD_LENGTH )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_PASSWORD));
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}

				if(lstrlen(szRPassword))
				{
					// Convert the password specified by the user to wide char or unicode format
					if (GetAsUnicodeString(szRPassword,wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
					{
						Cleanup(pITaskScheduler);
						return E_FAIL;
					}
				}

			}
			else
			{
				// Convert the password specified by the user to wide char or unicode format
				if ( GetAsUnicodeString(tcresubops.szRunAsPassword,wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
				{
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}
			}
			
			bPassWord = TRUE;
		}

	}
	// check whether -ru or -u values are specified in the cmdline or not
	if ( wUserStatus == OI_RUNASUSERNAME || wUserStatus == OI_RUNANDUSER )
	{
		if( ( bUserName == TRUE ) && ( bPassWord == FALSE ) )
		{
			szValues[0] = (_TCHAR*) (wszUserName);
			FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
					  GetResString(IDS_PROMPT_PASSWD),0,MAKELANGID(LANG_NEUTRAL,
				      SUBLANG_DEFAULT),szBuffer,
				      MAX_STRING_LENGTH,(va_list*)szValues
				     );
			
			DISPLAY_MESSAGE(stdout,szBuffer);
			
			// getting the password from the console
			if ( GetPassword(tcresubops.szRunAsPassword, MAX_PASSWORD_LENGTH ) == FALSE )
			{
				Cleanup(pITaskScheduler);
				return E_FAIL;
			}
			
			// check for empty password
			if( lstrlen ( tcresubops.szRunAsPassword ) == 0 )
			{
				DISPLAY_MESSAGE(stdout, GetResString(IDS_WARN_EMPTY_PASSWORD));
			}

			// check for the length of password
			if( lstrlen(tcresubops.szRunAsPassword) > MAX_PASSWORD_LENGTH )
			{
				DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_PASSWORD));
				Cleanup(pITaskScheduler);
				return E_FAIL;
			}

			if(lstrlen(tcresubops.szRunAsPassword))
			{
				// Convert the password specified by the user to wide char or unicode format
				if ( GetAsUnicodeString(tcresubops.szRunAsPassword,wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
				{
					Cleanup(pITaskScheduler);
					return E_FAIL;
				}
			}
					
		}
	}
	
	//if the user name is not specifed set the current logged on user settings 
	DWORD dwUserLen = MAX_USERNAME_LEN;
	DWORD dwResult = 0;
	_TCHAR  szUserName[MAX_RES_STRING];
	

#ifdef _WIN64
	INT64 dwPos = 0;
#else
	DWORD dwPos = 0;
#endif
	
	if( ( bUserName == FALSE ) )
	{	
		//get the current logged on username 
		if ( GetUserNameEx ( NameSamCompatible, szUserName , &ulLong) == FALSE )
		{
			DISPLAY_MESSAGE( stderr, GetResString( IDS_LOGGED_USER_ERR ) );
			Cleanup(pITaskScheduler);
			return E_FAIL;
		}
		
		// Convert the user name specified by the user to wide char or unicode format
		if ( GetAsUnicodeString( szUserName, wszUserName, SIZE_OF_ARRAY(wszUserName)) == NULL )
		{
			Cleanup(pITaskScheduler);
			return E_FAIL;
		}
						   
		szValues[0] = (_TCHAR*) (wszUserName);
		//Display that the task will be created under logged in user name,ask for password 
		MessageBeep(MB_ICONEXCLAMATION);

		FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
					  GetResString(IDS_TASK_INFO),0,MAKELANGID(LANG_NEUTRAL,
			          SUBLANG_DEFAULT),szBuffer,
			          MAX_STRING_LENGTH,(va_list*)szValues );
			         
		DISPLAY_MESSAGE(stdout,szBuffer);

		FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
					  GetResString(IDS_PROMPT_PASSWD),0,MAKELANGID(LANG_NEUTRAL,
			          SUBLANG_DEFAULT),szBuffer,
			          MAX_STRING_LENGTH,(va_list*)szValues );
			         
		DISPLAY_MESSAGE(stdout,szBuffer);
	
		// getting the password
		if (GetPassword(szRPassword, MAX_PASSWORD_LENGTH) == FALSE )
		{
			Cleanup(pITaskScheduler);
			return E_FAIL;
		}


		// check for empty password
		if( lstrlen ( szRPassword ) == 0 )
		{
			DISPLAY_MESSAGE(stdout, GetResString(IDS_WARN_EMPTY_PASSWORD));
		}

		// check for the length of password
		if( lstrlen( szRPassword ) > MAX_PASSWORD_LENGTH )
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_PASSWORD));
			Cleanup(pITaskScheduler);
			return E_FAIL;
		}

		if(lstrlen(szRPassword))
		{
			// Convert the password specified by the user to wide char or unicode format
			if (GetAsUnicodeString(szRPassword,wszPassword,SIZE_OF_ARRAY(wszPassword)) == NULL )
			{
				Cleanup(pITaskScheduler);
				return E_FAIL;
			}
		}
		
	}
	
	// Get the task Scheduler object for the machine.
	pITaskScheduler = GetTaskScheduler( tcresubops.szServer );

	// If the Task Scheduler is not defined then give the error message.
	if ( pITaskScheduler == NULL )
	{
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( tcresubops.szServer );

		Cleanup(pITaskScheduler);
		return E_FAIL;
	}

	// create a work item wszJobName
	hr = pITaskScheduler->NewWorkItem(wszJobName,CLSID_CTask,IID_ITask,
									  (IUnknown**)&pITask);

	if(hr == HRESULT_FROM_WIN32 (ERROR_FILE_EXISTS))
	{		
		DISPLAY_MESSAGE(stderr,GetResString(IDS_CREATE_TASK_EXISTS));
		
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( tcresubops.szServer );

		Cleanup(pITaskScheduler);
		return hr;
	}

    if (FAILED(hr))
    {
		DisplayErrorMsg(hr);
		
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( tcresubops.szServer );

		Cleanup(pITaskScheduler);
		return hr;
    }
	
	// Return a pointer to a specified interface on an object
	hr = pITask->QueryInterface(IID_IPersistFile, (void **) &pIPF);

    if (FAILED(hr))
    {
		DisplayErrorMsg(hr);

		if( pIPF )
		{
			pIPF->Release();
		}

		if( pITask )
		{
			pITask->Release();
		}
			
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( tcresubops.szServer );

		Cleanup(pITaskScheduler);
		
		return hr;
    }
    
  	// declaration for parameter arguments
	wchar_t wcszParam[MAX_RES_STRING] = L"";
	
	DWORD dwProcessCode = 0 ;
	
	dwProcessCode = ProcessFilePath(wszCommand,wszApplName,wcszParam);
	
	if(dwProcessCode == RETVAL_FAIL)
	{
		
		if( pIPF )
		{
			pIPF->Release();
		}

		if( pITask )
		{
			pITask->Release();
		}
			
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( tcresubops.szServer );

		Cleanup(pITaskScheduler);
	    return hr;

	} 

	// check for .exe substring string in the given task to run string
	
	// Set command name with ITask::SetApplicationName
    hr = pITask->SetApplicationName(wszApplName);
    if (FAILED(hr))
    {
		DisplayErrorMsg(hr);

		if( pIPF )
		{
			pIPF->Release();
		}

		if( pITask )
		{
			pITask->Release();
		}
		
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( tcresubops.szServer );

		Cleanup(pITaskScheduler);
        return hr;
    }

	//[Working directory =  exe pathname - exe name] 

	wchar_t* wcszStartIn = wcsrchr(wszApplName,_T('\\'));
	if(wcszStartIn != NULL)
		*( wcszStartIn ) = _T('\0');
	
	// set the command working directory
	hr = pITask->SetWorkingDirectory(wszApplName); 

	if (FAILED(hr))
    {
		DisplayErrorMsg(hr);

		if( pIPF )
		{
			pIPF->Release();
		}

		if( pITask )
		{
			pITask->Release();
		}
			
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( tcresubops.szServer );

		Cleanup(pITaskScheduler);
	    return hr;
    }

	// set the command line parameters for the task
	hr = pITask->SetParameters(wcszParam);
	if (FAILED(hr))
    {
		DisplayErrorMsg(hr);

		if( pIPF )
		{
			pIPF->Release();
		}

		if( pITask )
		{
			pITask->Release();
		}
			
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( tcresubops.szServer );

		Cleanup(pITaskScheduler);
	    return hr;
    }

	// set the flag TASK_FLAG_DELETE_WHEN_DONE
	DWORD dwTaskFlags = TASK_FLAG_DELETE_WHEN_DONE;
	hr = pITask->SetFlags(dwTaskFlags);
	if (FAILED(hr))
    {
		DisplayErrorMsg(hr);

		if( pIPF )
		{
			pIPF->Release();
		}

		if( pITask )
		{
			pITask->Release();
		}
			
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( tcresubops.szServer );

		Cleanup(pITaskScheduler);
	    return hr;
    }
	
	if ( bVal == TRUE )
	{
		// Set account information for "NT AUTHORITY\SYSTEM" user
		hr = pITask->SetAccountInformation(L"",NULL);
	}
	else
	{
		// set the account information with the user name and password
		hr = pITask->SetAccountInformation(wszUserName,wszPassword);
	}
	
    if ((FAILED(hr)) && (hr != SCHED_E_NO_SECURITY_SERVICES))
    {
		DisplayErrorMsg(hr);
		DISPLAY_MESSAGE ( stdout, _T("\n") );
		DISPLAY_MESSAGE ( stdout, GetResString( IDS_ACCNAME_ERR ) );


		if( pIPF )
		{
			pIPF->Release();
		}

		if( pITask )
		{
			pITask->Release();
		}
			
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( tcresubops.szServer );

		Cleanup(pITaskScheduler);
	    return hr;
    }

	//Assign start date 
	if(tcreoptvals.bSetStartDateToCurDate )
	{
		GetLocalTime(&systime);
		wStartDay = systime.wDay;
		wStartMonth = systime.wMonth;
		wStartYear = systime.wYear;
	}
	else if(lstrlen(tcresubops.szStartDate) > 0)
	{
		GetDateFieldEntities(tcresubops.szStartDate, &wStartDay, &wStartMonth, &wStartYear);
	}

	//Assign start time
	if(tcreoptvals.bSetStartTimeToCurTime && (dwScheduleType != SCHED_TYPE_ONIDLE) )
	{
		GetLocalTime(&systime);
		wStartHour = systime.wHour;
		wStartMin = systime.wMinute;
		wStartSec = systime.wSecond;
	}
	else if(lstrlen(tcresubops.szStartTime) > 0)
	{
		GetTimeFieldEntities(tcresubops.szStartTime, &wStartHour, &wStartMin, &wStartSec);
	}
	
	//Set the falgs specific to ONIDLE
	if(dwScheduleType == SCHED_TYPE_ONIDLE)
	{
		pITask->SetFlags(TASK_FLAG_START_ONLY_IF_IDLE);
	
		wIdleTime = (WORD)AsLong(tcresubops.szIdleTime, BASE_TEN);
		
		pITask->SetIdleWait(wIdleTime, 0);
	}

    //create trigger for the corresponding task
    hr = pITask->CreateTrigger(&wTrigNumber, &pITaskTrig);
    if (FAILED(hr))
    {
		DisplayErrorMsg(hr);

		if( pIPF )
		{
			pIPF->Release();
		}

		if( pITaskTrig )
		{
			pITaskTrig->Release();
		}

		if( pITask )
		{
			pITask->Release();
		}
			
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( tcresubops.szServer );

		Cleanup(pITaskScheduler);
	    return hr;
    }
    
    DWORD dwTrigFlags = 0;
	WORD wWhichWeek;
	LONG lMonthlyModifier = 0;	
	DWORD dwDays = 1;

	switch( dwScheduleType )
	{
		
		case SCHED_TYPE_MINUTE:
			TaskTrig.TriggerType = TASK_TIME_TRIGGER_DAILY;
			TaskTrig.Type.Daily.DaysInterval = 1;
		
			TaskTrig.MinutesInterval = AsLong(tcresubops.szModifier, BASE_TEN);
			
			TaskTrig.MinutesDuration = (WORD)(HOURS_PER_DAY*MINUTES_PER_HOUR);

			TaskTrig.wStartHour = wStartHour;
			TaskTrig.wStartMinute = wStartMin; 

			TaskTrig.wBeginDay = wStartDay;
			TaskTrig.wBeginMonth = wStartMonth;
			TaskTrig.wBeginYear = wStartYear;

			if(lstrlen(tcresubops.szEndDate) > 0)
			{
				// Make end date valid; otherwise the enddate parameter is ignored.
				TaskTrig.rgFlags = TASK_TRIGGER_FLAG_HAS_END_DATE;
				// Now set the end date entities.
				GetDateFieldEntities(tcresubops.szEndDate, &wEndDay, &wEndMonth, &wEndYear);
				TaskTrig.wEndDay = wEndDay;
				TaskTrig.wEndMonth = wEndMonth;
				TaskTrig.wEndYear = wEndYear;
			}
			

			break;

		case SCHED_TYPE_HOURLY:
			TaskTrig.TriggerType = TASK_TIME_TRIGGER_DAILY;
			TaskTrig.Type.Daily.DaysInterval = 1;
		
			TaskTrig.MinutesInterval = (WORD)(AsLong(tcresubops.szModifier, BASE_TEN)
												* MINUTES_PER_HOUR); 
			
			TaskTrig.MinutesDuration = (WORD)(HOURS_PER_DAY*MINUTES_PER_HOUR);
		
			TaskTrig.wStartHour = wStartHour;
			TaskTrig.wStartMinute = wStartMin; 

			TaskTrig.wBeginDay = wStartDay;
			TaskTrig.wBeginMonth = wStartMonth;
			TaskTrig.wBeginYear = wStartYear;

			// Now set end date parameters, if the enddate is specified.
			if(lstrlen(tcresubops.szEndDate) > 0)
			{
				// Make end date valid; otherwise the enddate parameter is ignored.
				TaskTrig.rgFlags = TASK_TRIGGER_FLAG_HAS_END_DATE;
				// Now set the end date entities.
				GetDateFieldEntities(tcresubops.szEndDate, &wEndDay, &wEndMonth, &wEndYear);
				TaskTrig.wEndDay = wEndDay;
				TaskTrig.wEndMonth = wEndMonth;
				TaskTrig.wEndYear = wEndYear;
			}

			break;

		// Schedule type is Daily
		case SCHED_TYPE_DAILY:
			TaskTrig.TriggerType = TASK_TIME_TRIGGER_DAILY;
			TaskTrig.wBeginDay = wStartDay;
			TaskTrig.wBeginMonth = wStartMonth;
			TaskTrig.wBeginYear = wStartYear;

			TaskTrig.wStartHour = wStartHour;
			TaskTrig.wStartMinute = wStartMin;

			if( lstrlen(tcresubops.szModifier) > 0 )
			{
				// Set the duration between days to the modifier value specified, if the modifier is specified. 
				TaskTrig.Type.Daily.DaysInterval = (WORD) AsLong(tcresubops.szModifier,
																 BASE_TEN); 
			}
			else
			{
				// Set value for on which day of the week?
				TaskTrig.Type.Weekly.rgfDaysOfTheWeek = GetTaskTrigwDayForDay(tcresubops.szDays);
				TaskTrig.Type.Weekly.WeeksInterval = 1;
			}

			// Now set end date parameters, if the enddate is specified.
			if(lstrlen(tcresubops.szEndDate) > 0)
			{
				// Make end date valid; otherwise the enddate parameter is ignored.
				TaskTrig.rgFlags = TASK_TRIGGER_FLAG_HAS_END_DATE;
				// Now set the end date entities.
				GetDateFieldEntities(tcresubops.szEndDate, &wEndDay, &wEndMonth, &wEndYear);
				TaskTrig.wEndDay = wEndDay;
				TaskTrig.wEndMonth = wEndMonth;
				TaskTrig.wEndYear = wEndYear;
			}
			// No more settings for a Daily type scheduled item.

			break;

		// Schedule type is Weekly
		case SCHED_TYPE_WEEKLY:
			TaskTrig.TriggerType = TASK_TIME_TRIGGER_WEEKLY;
			
			TaskTrig.Type.Weekly.WeeksInterval = (WORD)AsLong(tcresubops.szModifier, BASE_TEN);
		
			// Set value for on which day of the week?
			TaskTrig.Type.Weekly.rgfDaysOfTheWeek = GetTaskTrigwDayForDay(tcresubops.szDays);

			TaskTrig.wStartHour = wStartHour;
			TaskTrig.wStartMinute = wStartMin;
		
			TaskTrig.wBeginDay = wStartDay;
			TaskTrig.wBeginMonth = wStartMonth;
			TaskTrig.wBeginYear = wStartYear;

			// Now set end date parameters, if the enddate is specified.
			if(lstrlen(tcresubops.szEndDate) > 0)
			{
				// Make end date valid; otherwise the enddate parameter is ignored.
				TaskTrig.rgFlags = TASK_TRIGGER_FLAG_HAS_END_DATE;
				// Now set the end date entities.
				GetDateFieldEntities(tcresubops.szEndDate, &wEndDay, &wEndMonth, &wEndYear);
				TaskTrig.wEndDay = wEndDay;
				TaskTrig.wEndMonth = wEndMonth;
				TaskTrig.wEndYear = wEndYear;
			}
			break;

		// Schedule type is Monthly
		case SCHED_TYPE_MONTHLY:

			TaskTrig.wStartHour = wStartHour;
			TaskTrig.wStartMinute = wStartMin;	
			TaskTrig.wBeginDay = wStartDay;
			TaskTrig.wBeginMonth = wStartMonth;
			TaskTrig.wBeginYear = wStartYear;

			// Now set end date parameters, if the enddate is specified.
			if(lstrlen(tcresubops.szEndDate) > 0)
			{
				// Make end date valid; otherwise the enddate parameter is ignored.
				TaskTrig.rgFlags = TASK_TRIGGER_FLAG_HAS_END_DATE; 
				// Set the end date entities.
				GetDateFieldEntities(tcresubops.szEndDate, &wEndDay, &wEndMonth, &wEndYear);
				TaskTrig.wEndDay = wEndDay;
				TaskTrig.wEndMonth = wEndMonth;
				TaskTrig.wEndYear = wEndYear;
			}
			//Find out from modifier which option like 1 - 12 days
			//or FIRST,SECOND ,THIRD ,.... LAST.
			if(lstrlen(tcresubops.szModifier) > 0)
			{
				lMonthlyModifier = AsLong(tcresubops.szModifier, BASE_TEN);
				
				if(lMonthlyModifier >= 1 && lMonthlyModifier <= 12)
				{
					if(lstrlen(tcresubops.szDays) == 0 )
					{
						dwDays  = 1;//default value for days
					}
					else
					{
						dwDays  = (WORD)AsLong(tcresubops.szDays, BASE_TEN);
					}

					TaskTrig.TriggerType = TASK_TIME_TRIGGER_MONTHLYDATE;
					//set the appropriate day bit in rgfDays
					TaskTrig.Type.MonthlyDate.rgfDays = (1 << (dwDays -1)) ;
					TaskTrig.Type.MonthlyDate.rgfMonths = GetMonthId(lMonthlyModifier);
				}
				else
				{

					if( lstrcmpi( tcresubops.szModifier , GetResString( IDS_DAY_MODIFIER_LASTDAY ) ) == 0)
					{
						TaskTrig.TriggerType = TASK_TIME_TRIGGER_MONTHLYDATE;
						//set the appropriate day bit in rgfDays
						TaskTrig.Type.MonthlyDate.rgfDays =
									(1 << (GetNumDaysInaMonth(tcresubops.szMonths, wStartYear ) -1));
						TaskTrig.Type.MonthlyDate.rgfMonths = GetTaskTrigwMonthForMonth(
																	  tcresubops.szMonths);
						break;
									
					}

					if( lstrcmpi(tcresubops.szModifier,
								 GetResString( IDS_TASK_FIRSTWEEK ) ) == 0 )
					{
						wWhichWeek = TASK_FIRST_WEEK;
					}
					else if( lstrcmpi(tcresubops.szModifier,
							          GetResString( IDS_TASK_SECONDWEEK )) == 0 )
					{
						wWhichWeek = TASK_SECOND_WEEK;
					}
					else if( lstrcmpi(tcresubops.szModifier,
									  GetResString( IDS_TASK_THIRDWEEK )) == 0 )
					{
						wWhichWeek = TASK_THIRD_WEEK;
					}
		 			else if( lstrcmpi(tcresubops.szModifier,
									  GetResString( IDS_TASK_FOURTHWEEK )) == 0 )
					{
						wWhichWeek = TASK_FOURTH_WEEK;
					}
					else if( lstrcmpi(tcresubops.szModifier,
									  GetResString( IDS_TASK_LASTWEEK )) == 0 )
					{
						wWhichWeek = TASK_LAST_WEEK;
					}
					
					TaskTrig.TriggerType = TASK_TIME_TRIGGER_MONTHLYDOW;
					TaskTrig.Type.MonthlyDOW.wWhichWeek = wWhichWeek;
					TaskTrig.Type.MonthlyDOW.rgfDaysOfTheWeek = GetTaskTrigwDayForDay(
																	tcresubops.szDays);
					TaskTrig.Type.MonthlyDOW.rgfMonths = GetTaskTrigwMonthForMonth(
																tcresubops.szMonths);
				
				}	
		}
		else
		{
			TaskTrig.TriggerType = TASK_TIME_TRIGGER_MONTHLYDATE;
			TaskTrig.Type.MonthlyDate.rgfMonths = GetTaskTrigwMonthForMonth(
												   tcresubops.szMonths);

			dwDays  = (WORD)AsLong(tcresubops.szDays, BASE_TEN);
			if(dwDays > 1)
			{
				//set the appropriate day bit in rgfDays
				TaskTrig.Type.MonthlyDate.rgfDays = (1 << (dwDays -1));
			}
			else
			{
			TaskTrig.Type.MonthlyDate.rgfDays = 1;
			}

		}

	
		break;

		// Schedule type is Onetime
		case SCHED_TYPE_ONETIME:
			TaskTrig.TriggerType = TASK_TIME_TRIGGER_ONCE;
			TaskTrig.wStartHour = wStartHour;
			TaskTrig.wStartMinute = wStartMin;
			TaskTrig.wBeginDay = wStartDay;
			TaskTrig.wBeginMonth = wStartMonth;
			TaskTrig.wBeginYear = wStartYear;
			break;
	

		// Schedule type is Onlogon
		case SCHED_TYPE_ONSTART:
		case SCHED_TYPE_ONLOGON:
			if(dwScheduleType == SCHED_TYPE_ONLOGON )
				TaskTrig.TriggerType = TASK_EVENT_TRIGGER_AT_LOGON; 
			if(dwScheduleType == SCHED_TYPE_ONSTART )
				TaskTrig.TriggerType = TASK_EVENT_TRIGGER_AT_SYSTEMSTART; 
	
			TaskTrig.wBeginDay = wStartDay;
			TaskTrig.wBeginMonth = wStartMonth;
			TaskTrig.wBeginYear = wStartYear;
			break;

		// Schedule type is Onidle
		case SCHED_TYPE_ONIDLE:

			TaskTrig.TriggerType = TASK_EVENT_TRIGGER_ON_IDLE; 
			TaskTrig.wBeginDay = wStartDay;
			TaskTrig.wBeginMonth = wStartMonth;
			TaskTrig.wBeginYear = wStartYear;
					
			break;

		default:
			
			// close the connection that was established by the utility
			if ( bCloseConnection == TRUE )
				CloseConnection( tcresubops.szServer );
			
			Cleanup(pITaskScheduler);
			return E_FAIL;
		
	}


	szValues[0] = (_TCHAR*) (tcresubops.szTaskName);
				
	// set the task trigger
    hr = pITaskTrig->SetTrigger(&TaskTrig);
    if (hr != S_OK)
    {
		
	FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
					  GetResString(IDS_CREATEFAIL_INVALIDARGS),0,MAKELANGID(LANG_NEUTRAL,
			          SUBLANG_DEFAULT),szBuffer,
			          MAX_STRING_LENGTH,(va_list*)szValues
			         );
			
		DISPLAY_MESSAGE(stderr, szBuffer);
				

		if( pIPF )
		{
			pIPF->Release();
		}

		if( pITaskTrig )
		{
			pITaskTrig->Release();
		}

		if( pITask )
		{
			pITask->Release();
		}
				
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( tcresubops.szServer );

		Cleanup(pITaskScheduler);
		return hr;
    } 
    
	// save the copy of an object
	hr = pIPF->Save(NULL,TRUE);

    if( FAILED(hr) )
    {
		szValues[0] = (_TCHAR*) (tcresubops.szTaskName);

		if ( hr == SCHEDULER_NOT_RUNNING_ERROR_CODE )
		{
			// displays the warning message for an invalid username
			FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
						  GetResString(IDS_SCHEDULER_NOT_RUNNING),0,MAKELANGID(LANG_NEUTRAL,
						  SUBLANG_DEFAULT),szBuffer,
						  MAX_STRING_LENGTH,(va_list*)szValues
						 );
		
		}
		else if ( hr == RPC_SERVER_NOT_AVAILABLE )
		{
			szValues[1] = (_TCHAR*) (tcresubops.szServer);
			// displays the warning message for an invalid username
			FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
						  GetResString(IDS_RPC_SERVER_NOT_AVAIL),0,MAKELANGID(LANG_NEUTRAL,
						  SUBLANG_DEFAULT),szBuffer,
						  MAX_STRING_LENGTH,(va_list*)szValues
						 );

		}
		else
		{
		// displays the warning message for an invalid username
		FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
						  GetResString(IDS_INVALID_USER),0,MAKELANGID(LANG_NEUTRAL,
						  SUBLANG_DEFAULT),szBuffer,
						  MAX_STRING_LENGTH,(va_list*)szValues
						 );
		}

		DISPLAY_MESSAGE(stdout, szBuffer);

		if(pIPF)
		{
			pIPF->Release();
		}
		if(pITaskTrig)
		{
			pITaskTrig->Release();
		}
		if(pITask)
		{
			pITask->Release();
		}

		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( tcresubops.szServer );

		Cleanup(pITaskScheduler);
		return EXIT_SUCCESS;
    }
	
	//displays success message for valid user
	FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
				  GetResString(IDS_CREATE_SUCCESSFUL),0,MAKELANGID(LANG_NEUTRAL,
			      SUBLANG_DEFAULT),szBuffer,
			      MAX_STRING_LENGTH,(va_list*)szValues
			     );
			
	DISPLAY_MESSAGE(stdout,szBuffer);


	// Release interface pointers
	    
    if(pIPF)
	{
		pIPF->Release();
	}

	if(pITask)
	{
		pITask->Release();
	}
     
	if(pITaskTrig)
	{
		pITaskTrig->Release();
	}

	// close the connection that was established by the utility
	if ( bCloseConnection == TRUE )
		CloseConnection( tcresubops.szServer );

	Cleanup(pITaskScheduler);
     
	return hr;

}
/******************************************************************************
	Routine Description:

		This routine  displays the create option usage

	Arguments:

		None

	Return Value :
		None
******************************************************************************/ 

DWORD
DisplayCreateUsage()
{
	TCHAR szBuffer[MAX_STRING_LENGTH] = NULL_STRING;
	_TCHAR* szValues[1] = {NULL};//To pass to FormatMessage() API
	TCHAR szFormat[MAX_DATE_STR_LEN] = NULL_STRING;
	WORD	wFormatID = 0;
	
	if ( GetDateFormatString( szFormat) )
	{
		 return RETVAL_FAIL;
	}

	szValues[0] = (_TCHAR*) (szFormat);

	// Displaying Create usage
	for( DWORD dw = IDS_CREATE_HLP1; dw <= IDS_CREATE_HLP96; dw++ )
	{
		if ( dw == IDS_CREATE_HLP63)
		{
			// To format start date
			FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
			  GetResString(IDS_CREATE_HLP63),0,MAKELANGID(LANG_NEUTRAL,
			          SUBLANG_DEFAULT),szBuffer,
			          MAX_STRING_LENGTH,(va_list*)szValues );

				DISPLAY_MESSAGE(stdout,szBuffer);	
		}
		else if ( dw == IDS_CREATE_HLP66 )
		{
			// To format end date
			FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
			  GetResString(IDS_CREATE_HLP66),0,MAKELANGID(LANG_NEUTRAL,
			          SUBLANG_DEFAULT),szBuffer,
			          MAX_STRING_LENGTH,(va_list*)szValues );

				DISPLAY_MESSAGE(stdout,szBuffer);	
		}
		else if ( dw == IDS_CREATE_HLP87 )
		{
			// get the date format
			if ( RETVAL_FAIL == GetDateFieldFormat( &wFormatID ))
			{
				return RETVAL_FAIL;
			}

			if ( wFormatID == 0) 
			{
				lstrcpy (szValues[0], GetResString (IDS_MMDDYY_VALUE));
			}
			else if ( wFormatID == 1) 
			{
				lstrcpy (szValues[0], GetResString (IDS_DDMMYY_VALUE));
			}
			else 
			{
				lstrcpy (szValues[0], GetResString (IDS_YYMMDD_VALUE));
			}

			// To format -sd and -ed values
			FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
			  GetResString(IDS_CREATE_HLP87),0,MAKELANGID(LANG_NEUTRAL,
			          SUBLANG_DEFAULT),szBuffer,
			          MAX_STRING_LENGTH,(va_list*)szValues );

				DISPLAY_MESSAGE(stdout,szBuffer);	
		}
		else
		{
		DISPLAY_MESSAGE(stdout,GetResString(dw));
		}
	}
	return RETVAL_FAIL;
}

/******************************************************************************
	Routine Description:

		This routine validates the options specified by the user & determines 
		the type of a scheduled task

	Arguments:	

		[ in ]  argc           : The count of arguments given by the user.
		[ in ]  argv           : Array containing the command line arguments.
		[ in ]  tcresubops     : Structure containing Scheduled task's properties.
		[ in ]  tcreoptvals    : Structure containing optional properties to set for a
								 scheduledtask  	.
		[ out ] pdwRetScheType : pointer to the type of a schedule task
								 [Daily,once,weekly etc].
		[ out ] pbUserStatus   : pointer to check whether the -ru is given in 
								 the command line or not.

	Return Value :
		A DWORD value indicating RETVAL_SUCCESS on success else RETVAL_FAIL 
		on failure
******************************************************************************/ 

DWORD
ProcessCreateOptions(DWORD argc, LPCTSTR argv[],TCREATESUBOPTS &tcresubops, 
			 TCREATEOPVALS &tcreoptvals, DWORD* pdwRetScheType, WORD *pwUserStatus)
{

	DWORD dwScheduleType = 0;
	BOOL  bRet = FALSE;
	lstrcpy( tcresubops.szPassword, ASTERIX);
	lstrcpy( tcresubops.szRunAsPassword, ASTERIX);

	// fill the TCMDPARSER structure
	TCMDPARSER cmdOptions[] = {
		{ 
			CMDOPTION_CREATE,
			CP_MAIN_OPTION,
			OPTION_COUNT,
			0,
			&tcresubops.bCreate,
			NULL_STRING,
			NULL,
			NULL
		},
		{ 
			SWITCH_SERVER,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY,
			OPTION_COUNT,
			0,
			&tcresubops.szServer,
			NULL_STRING,
			NULL,
			NULL
		},
		{ 
			SWITCH_RUNAS_USER,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY,
			OPTION_COUNT,
			0,
			tcresubops.szRunAsUser,
			NULL_STRING,
			NULL,
			NULL
		},
		{ 
			SWITCH_RUNAS_PASSWORD,
			CP_TYPE_TEXT | CP_VALUE_OPTIONAL,
			OPTION_COUNT,
			0,
			&tcresubops.szRunAsPassword,
			NULL_STRING,
			NULL,
			NULL
		},
		{ 
			SWITCH_USER,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY,
			OPTION_COUNT,
			0,
			tcresubops.szUser,
			NULL_STRING,
			NULL,
			NULL
		},
		{ 
			SWITCH_PASSWORD,
			CP_TYPE_TEXT | CP_VALUE_OPTIONAL,
			OPTION_COUNT,
			0,
			&tcresubops.szPassword,
			NULL_STRING,
			NULL,
			NULL
		},
		{
			SWITCH_SCHEDULETYPE,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY | CP_MANDATORY,
			OPTION_COUNT,
			0,
			tcresubops.szSchedType,
			NULL_STRING,
			NULL,
			NULL
		},
		{
			SWITCH_MODIFIER,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY,
			OPTION_COUNT,
			0,
			tcresubops.szModifier,
			NULL_STRING,
			NULL,
			NULL
		},
		{
			SWITCH_DAY,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY,
			OPTION_COUNT,
			0,
			tcresubops.szDays,
			NULL_STRING,
			NULL,
			NULL
		},
		{
			SWITCH_MONTHS,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY,
			OPTION_COUNT,
			0,
			tcresubops.szMonths,
			NULL_STRING,
			NULL,
			NULL
		},
		{
			SWITCH_IDLETIME,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY,
			OPTION_COUNT,
			0,
			tcresubops.szIdleTime,
			NULL_STRING,
			NULL,
			NULL
		},
		{
			SWITCH_TASKNAME,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY | CP_MANDATORY,
			OPTION_COUNT,
			0,
			tcresubops.szTaskName,
			NULL_STRING,
			NULL,
			NULL
		},
		{
			SWITCH_TASKRUN,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY | CP_MANDATORY,
			OPTION_COUNT,
			0,
			tcresubops.szTaskRun,
			NULL_STRING,
			NULL,
			NULL
		},
		{
			SWITCH_STARTTIME,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY,
			OPTION_COUNT,
			0,
			tcresubops.szStartTime,
			NULL_STRING,
			NULL,
			NULL
		},
		{
			SWITCH_STARTDATE,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY,
			OPTION_COUNT,
			0,
			tcresubops.szStartDate,
			NULL_STRING,
			NULL,
			NULL
		},
		{
			SWITCH_ENDDATE,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY,
			OPTION_COUNT,
			0,
			tcresubops.szEndDate,
			NULL_STRING,
			NULL,
			NULL
		},
		{
			CMDOPTION_USAGE,
			CP_USAGE ,
			OPTION_COUNT,
			0,
			&tcresubops.bUsage,
			0,
			0 
		}

	};

	// Parsing the copy option switches
	if ( DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions), cmdOptions ) == FALSE )
	{
		//display error message		 
		DISPLAY_MESSAGE( stderr, GetResString(IDS_LOGTYPE_ERROR ));
		DISPLAY_MESSAGE( stderr, GetReason() );
		//DISPLAY_MESSAGE(stderr,GetResString(IDS_CREATE_ERR));
		return RETVAL_FAIL;
	}

	// trim the blank spaces in string values
	StrTrim(tcresubops.szServer, TRIM_SPACES );
	StrTrim(tcresubops.szTaskName, TRIM_SPACES );
	StrTrim(tcresubops.szTaskRun, TRIM_SPACES );
	StrTrim(tcresubops.szModifier, TRIM_SPACES );
	StrTrim(tcresubops.szMonths, TRIM_SPACES );
	StrTrim(tcresubops.szUser, TRIM_SPACES );
	StrTrim(tcresubops.szRunAsUser, TRIM_SPACES );
	StrTrim(tcresubops.szSchedType, TRIM_SPACES );
	StrTrim(tcresubops.szEndDate, TRIM_SPACES );
	StrTrim(tcresubops.szStartDate, TRIM_SPACES );
	StrTrim(tcresubops.szStartTime, TRIM_SPACES );
	StrTrim(tcresubops.szIdleTime, TRIM_SPACES );
	StrTrim(tcresubops.szDays, TRIM_SPACES );

	// check whether password (-p) specified in the command line or not.
	if ( cmdOptions[OI_PASSWORD].dwActuals == 0 )
	{
		lstrcpy(tcresubops.szPassword, NULL_STRING);
	}

	// check whether run as password (-rp) specified in the command line or not.
	if ( cmdOptions[OI_RUNASPASSWORD].dwActuals == 0 )
	{
		lstrcpy(tcresubops.szRunAsPassword, NULL_STRING);
	}

	// Display create usage if user specified -create  -? option
	if( tcresubops.bUsage  == TRUE)
	{
	    DisplayCreateUsage();
		return RETVAL_FAIL;
	}
	
	if( ( cmdOptions[OI_SERVER].dwActuals == 1 ) &&  ( lstrlen( tcresubops.szServer ) == 0 ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_SERVER));	
		return RETVAL_FAIL;
	}

	// check for invalid user name
	if( ( cmdOptions[OI_SERVER].dwActuals == 0 ) && ( cmdOptions[OI_USERNAME].dwActuals == 1 )  )
	{
		DISPLAY_MESSAGE(stderr, GetResString(IDS_CREATE_USER_BUT_NOMACHINE));	
		return RETVAL_FAIL;
	}
	
	// check for the length of user name
	if( ( cmdOptions[OI_SERVER].dwActuals == 1 ) && ( cmdOptions[OI_USERNAME].dwActuals == 1 ) && 
		( lstrlen( tcresubops.szUser ) == 0 ) )
	{
		DISPLAY_MESSAGE(stderr, GetResString(IDS_INVALID_USERNAME));	
		return RETVAL_FAIL;
	}

	//Determine scheduled type
	if( lstrcmpi(tcresubops.szSchedType,GetResString(IDS_SCHEDTYPE_MINUTE)) == 0 )
	{
		dwScheduleType = SCHED_TYPE_MINUTE;
	}
	else if( lstrcmpi(tcresubops.szSchedType,GetResString(IDS_SCHEDTYPE_HOUR)) == 0 )
	{
		dwScheduleType = SCHED_TYPE_HOURLY;
	}
	else if( lstrcmpi(tcresubops.szSchedType,GetResString(IDS_SCHEDTYPE_DAILY)) == 0 )
	{
		dwScheduleType = SCHED_TYPE_DAILY;
	}
	else if( lstrcmpi(tcresubops.szSchedType,GetResString(IDS_SCHEDTYPE_WEEK)) == 0 )
	{
		dwScheduleType = SCHED_TYPE_WEEKLY;
	}
	else if( lstrcmpi(tcresubops.szSchedType,GetResString(IDS_SCHEDTYPE_MONTHLY)) == 0 )
	{
		dwScheduleType = SCHED_TYPE_MONTHLY;
	}
	else if( lstrcmpi(tcresubops.szSchedType,GetResString(IDS_SCHEDTYPE_ONCE)) == 0 )
	{
		dwScheduleType = SCHED_TYPE_ONETIME;
	}
	else if( lstrcmpi(tcresubops.szSchedType,GetResString(IDS_SCHEDTYPE_STARTUP)) == 0 )
	{
		dwScheduleType = SCHED_TYPE_ONSTART;
	}
	else if( lstrcmpi(tcresubops.szSchedType,GetResString(IDS_SCHEDTYPE_LOGON)) == 0 )
	{
		dwScheduleType = SCHED_TYPE_ONLOGON;
	}
	else if( lstrcmpi(tcresubops.szSchedType,GetResString(IDS_SCHEDTYPE_IDLE)) == 0 )
	{
		dwScheduleType = SCHED_TYPE_ONIDLE;
	}
	else
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_SCHEDTYPE));
		return RETVAL_FAIL;
	}

	// Assign the scheduled type to the out parameter.
	*pdwRetScheType = dwScheduleType; 

	// To find whether run as user name is given in the cmd line or not
	
	if( ( cmdOptions[1].dwActuals == 1 ) && 
		( (cmdOptions[2].dwActuals == 0) && (cmdOptions[4].dwActuals == 0) ) ) 
	{
		*pwUserStatus = OI_SERVER;
	}
	else if( (cmdOptions[2].dwActuals == 1) && (cmdOptions[4].dwActuals == 1) ) 
	{
		*pwUserStatus = OI_RUNANDUSER;
	}
	else if( cmdOptions[2].dwActuals == 1 ) 
	{
		*pwUserStatus = OI_RUNASUSERNAME;
	}
	else if ( cmdOptions[4].dwActuals == 1 ) 
	{
		*pwUserStatus = OI_USERNAME;
	}

	// Start validations for the sub-options 
	if( ValidateSuboptVal(tcresubops, tcreoptvals, cmdOptions, dwScheduleType) == RETVAL_FAIL )
	{
		return(RETVAL_FAIL);
	}

	return RETVAL_SUCCESS;

}



/******************************************************************************
	Routine Description:

		This routine splits the input parameters into 2 substrings and returns it. 

	Arguments:	

		[ in ]  szInput           : Input string.
		[ in ]  szFirstString     : First Output string containing the path of the 
									file.	
		[ in ]  szSecondString     : The second  output containing the paramters.
	
	Return Value :
		A DWORD value indicating RETVAL_SUCCESS on success else RETVAL_FAIL 
		on failure
******************************************************************************/ 

DWORD ProcessFilePath(LPTSTR szInput,LPTSTR szFirstString,LPTSTR szSecondString)
{
	
	_TCHAR *pszTok = NULL ;
	_TCHAR *pszSep = NULL ;

	_TCHAR szTmpString[MAX_RES_STRING] = NULL_STRING; 
	_TCHAR szTmpInStr[MAX_RES_STRING] = NULL_STRING; 
	_TCHAR szTmpOutStr[MAX_RES_STRING] = NULL_STRING; 
	_TCHAR szTmpString1[MAX_RES_STRING] = NULL_STRING; 
	DWORD dwCnt = 0 ;
	DWORD dwLen = 0 ;

#ifdef _WIN64
	INT64 dwPos ;
#else
	DWORD dwPos ;
#endif

	//checking if the input parameters are NULL and if so 
	// return FAILURE. This condition will not come
	// but checking for safety sake.

	if( (szInput == NULL) || (_tcslen(szInput)==0))
	{
		return RETVAL_FAIL ;
	}

	_tcscpy(szTmpString,szInput);
	_tcscpy(szTmpString1,szInput);
	_tcscpy(szTmpInStr,szInput);

	// check for first double quote (")
	if ( szTmpInStr[0] == _T('\"') )
	{
		// trim the first double quote
		StrTrim( szTmpInStr, _T("\""));
		
		// check for end double quote
		pszSep  = _tcschr(szTmpInStr,_T('\"')) ;
		
		// get the position
		dwPos = pszSep - szTmpInStr + 1;
	}
	else
	{
		// check for the space 
		pszSep  = _tcschr(szTmpInStr,_T(' ')) ;
		
		// get the position
		dwPos = pszSep - szTmpInStr;

	}

	if ( pszSep != NULL )
	{
		szTmpInStr[dwPos] =  _T('\0'); 
	}
	else
	{
		_tcscpy(szFirstString, szTmpString);
		_tcscpy(szSecondString,NULL_STRING);
		return RETVAL_SUCCESS;
	}

	// intialize the variable
	dwCnt = 0 ;
	
	// get the length of the string
	dwLen = _tcslen ( szTmpString );

	// check for end of string
	while ( ( dwPos <= dwLen )  && szTmpString[dwPos++] != _T('\0') )
	{
		szTmpOutStr[dwCnt++] = szTmpString[dwPos];
	}

	// trim the executable and arguments
	StrTrim( szTmpInStr, _T("\""));
	StrTrim( szTmpInStr, _T(" "));

	_tcscpy(szFirstString, szTmpInStr);
	_tcscpy(szSecondString,szTmpOutStr);
	
	// return success
	return RETVAL_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scheduledtasks\createvalidations.cpp ===
/******************************************************************************

	Copyright(c) Microsoft Corporation

	Module Name:

		CreateValidations.cpp

	Abstract:

		This module validates the various -create sub options specified by the user

	Author:

		B.Raghu babu  20-Sept-2000 : Created 

	Revision History:

		G.Surender Reddy  25-sep-2000 : Modified it
									   [ Added error checking ]

		G.Surender Reddy  10-Oct-2000 : Modified it
										[ made changes in validatemodifierval(),
										  ValidateDayAndMonth() functions ]	

		
		G.Surender Reddy 15-oct-2000 : Modified it
									   [ Moved the strings to Resource table ]

		Venu Gopal S     26-Feb-2001 : Modified it
									   [ Added GetDateFormatString(),
									     GetDateFieldFormat() functions to 
										 gets the date format according to 
										 regional options]

******************************************************************************/ 

//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"

/******************************************************************************
	Routine Description:

		This routine validates the sub options specified by the user  reg.create option 
		& determines the type of a scheduled task.

	Arguments:

		[ in ] tcresubops     : Structure containing the task's properties
		[ in ] tcreoptvals    : Structure containing optional values to set
		[ in ] cmdOptions[]   : Array of type TCMDPARSER 
		[ in ] dwScheduleType : Type of schedule[Daily,once,weekly etc]

	Return Value :
		A DWORD value indicating RETVAL_SUCCESS on success else RETVAL_FAIL
		on failure
******************************************************************************/ 

DWORD
ValidateSuboptVal(TCREATESUBOPTS& tcresubops, TCREATEOPVALS &tcreoptvals,
						TCMDPARSER cmdOptions[], DWORD dwScheduleType)
{
	DWORD	dwRetval = RETVAL_SUCCESS; 
	BOOL	bIsStDtCurDt = FALSE; 
	BOOL	bIsStTimeCurTime = FALSE;
	BOOL	bIsDefltValMod = FALSE; 

	// Validate whether -s, -u, -p options specified correctly or not.
	//Accept password if -p not specified.
	if( dwRetval = ValidateRemoteSysInfo( tcresubops.szServer, tcresubops.szUser,
						 tcresubops.szPassword, cmdOptions, tcresubops, tcreoptvals) )
		return dwRetval; // Error.

	// Validate Modifier value.
	if( dwRetval = ValidateModifierVal( tcresubops.szModifier, dwScheduleType, 
									   cmdOptions[OI_MODIFIER].dwActuals,
									   cmdOptions[OI_DAY].dwActuals,
									   cmdOptions[OI_MONTHS].dwActuals,
									   bIsDefltValMod) )
	{
		
		return dwRetval; // error in modifier value
	}
	else
	{
		if(bIsDefltValMod)
			lstrcpy(tcresubops.szModifier,DEFAULT_MODIFIER_SZ); 
	}

	// Validate Day and Month strings
	if ( dwRetval = ValidateDayAndMonth( tcresubops.szDays, tcresubops.szMonths,
										dwScheduleType,
										cmdOptions[OI_DAY].dwActuals,
										cmdOptions[OI_MONTHS].dwActuals,
										cmdOptions[OI_MODIFIER].dwActuals,
										tcresubops.szModifier) )
	{
		return dwRetval; // Error found in Day/Month string.
	}

	// Validate Start Date value.
	if ( dwRetval = ValidateStartDate( tcresubops.szStartDate, dwScheduleType, 
									  cmdOptions[OI_STARTDATE].dwActuals,
									  bIsStDtCurDt) )
	{
		return dwRetval; // Error in Day/Month string.
	}
	else
	{
		if(bIsStDtCurDt) // Set start date to current date.
			tcreoptvals.bSetStartDateToCurDate = TRUE;
	}

	// Validate End Date value.
	if ( dwRetval = ValidateEndDate( tcresubops.szEndDate, dwScheduleType,
									cmdOptions[OI_ENDDATE].dwActuals) )
	{
		return dwRetval; // Error in Day/Month string.
	}

	//Check Whether end date should be greater than startdate

	WORD wEndDay = 0;
	WORD wEndMonth = 0;
	WORD wEndYear = 0;
	WORD wStartDay = 0;
	WORD wStartMonth = 0;
	WORD wStartYear = 0;
	WORD wFormatID = 0;

	if( cmdOptions[OI_ENDDATE].dwActuals != 0 )
	{
		if( RETVAL_FAIL == GetDateFieldEntities( tcresubops.szEndDate,&wEndDay,
												&wEndMonth,&wEndYear))
		{
			return S_FALSE;
		}
	}

	SYSTEMTIME systime = {0,0,0,0,0,0,0,0};

	if(bIsStDtCurDt)
	{
		GetLocalTime(&systime);
		wStartDay = systime.wDay;
		wStartMonth = systime.wMonth;
		wStartYear = systime.wYear;
	}
	else if( ( cmdOptions[OI_STARTDATE].dwActuals != 0 ) &&
		(RETVAL_FAIL == GetDateFieldEntities(tcresubops.szStartDate,
												 &wStartDay,&wStartMonth,
												 &wStartYear)))
	{
		return S_FALSE;
	}

	if( (cmdOptions[OI_ENDDATE].dwActuals != 0) )
	{
		if( ( wEndYear == wStartYear ) )
		{
			// For same years if the end month is less than start month or for same years and same months
			// if the endday is less than the startday.
			if ( ( wEndMonth < wStartMonth ) || ( ( wEndMonth == wStartMonth ) && ( wEndDay < wStartDay ) ) )
			{
				DISPLAY_MESSAGE(stderr, GetResString(IDS_ENDATE_INVALID));
				return RETVAL_FAIL;
			}

		
		}
		else if ( wEndYear < wStartYear )
		{
			DISPLAY_MESSAGE(stderr, GetResString(IDS_ENDATE_INVALID));
			return RETVAL_FAIL;
		
		}
	}	
	
	// Validate Start Time value.
	if ( dwRetval = ValidateStartTime( tcresubops.szStartTime, dwScheduleType,
									  cmdOptions[OI_STARTTIME].dwActuals, 
									  bIsStTimeCurTime) )
	{
		return dwRetval; // Error found in starttime.
	}
	else
	{
		if(bIsStTimeCurTime)
			tcreoptvals.bSetStartTimeToCurTime = TRUE;
	}

	// Validate Idle Time value.
	if ( dwRetval = ValidateIdleTimeVal( tcresubops.szIdleTime, dwScheduleType,
										cmdOptions[OI_IDLETIME].dwActuals) )
	{
		
		return dwRetval;
	}

	return RETVAL_SUCCESS;
}

/******************************************************************************
	Routine Description:

		This routine validates the options specified by the user  reg.create 
		option for remote server.

	Arguments:

		[ in ] szServer   : Server name
		[ in ] szUser     : User name
		[ in ] szPassword : Password 
		[ in ] cmdOptions : TCMDPARSER Array containg the options given by the user
		[ in ] tcreoptvals: Structure containing optional values to set

	Return Value :
		A DWORD value indicating RETVAL_SUCCESS on success else RETVAL_FAIL 
		on failure
******************************************************************************/ 

DWORD ValidateRemoteSysInfo(LPTSTR szServer, LPTSTR szUser, LPTSTR szPassword,
			TCMDPARSER cmdOptions[], TCREATESUBOPTS& tcresubops, TCREATEOPVALS& tcreoptvals)
{
	
	// "-rp" should not be specified without "-ru"
	if ( ( ( cmdOptions[ OI_RUNASUSERNAME ].dwActuals == 0 ) && ( cmdOptions[ OI_RUNASPASSWORD ].dwActuals == 1 ) ) ||
		( ( cmdOptions[ OI_USERNAME ].dwActuals == 0 ) && ( cmdOptions[ OI_PASSWORD ].dwActuals == 1 ) ) ||
		( ( cmdOptions[ OI_USERNAME ].dwActuals == 0 ) && ( cmdOptions[ OI_RUNASPASSWORD ].dwActuals == 1 ) && ( cmdOptions[ OI_PASSWORD ].dwActuals == 1 ) ) ||
		( ( cmdOptions[ OI_RUNASUSERNAME ].dwActuals == 0 ) && ( cmdOptions[ OI_RUNASPASSWORD ].dwActuals == 1 ) && ( cmdOptions[ OI_PASSWORD ].dwActuals == 1 ) ) ||
		( ( cmdOptions[ OI_USERNAME ].dwActuals == 0 ) && ( cmdOptions[ OI_RUNASUSERNAME ].dwActuals == 0 )  &&
		 ( cmdOptions[ OI_RUNASPASSWORD ].dwActuals == 1 ) && ( cmdOptions[ OI_PASSWORD ].dwActuals == 1 ) ) )
	{
		// invalid syntax
		DISPLAY_MESSAGE(stderr, GetResString(IDS_CPASSWORD_BUT_NOUSERNAME));
		return RETVAL_FAIL;			// indicate failure
	}

	if ( IsLocalSystem( tcresubops.szServer ) == TRUE ) 
	{
		tcreoptvals.bPassword = TRUE;
	}

	// check whether the password (-p) specified in the command line or not 
	// and also check whether '*' or empty is given for -p or not
	if( cmdOptions[ OI_PASSWORD ].dwActuals == 1 ) 
	{
		if ( IsLocalSystem( tcresubops.szServer ) == FALSE )  
		{
			if( lstrcmpi (tcresubops.szPassword, ASTERIX) == 0 )
			{
				tcreoptvals.bPassword = FALSE;
			}
			else
			{
				tcreoptvals.bPassword = TRUE;
			}
		}
	}
	
	if( ( cmdOptions[ OI_RUNASPASSWORD ].dwActuals == 1 ) )
	{
		tcreoptvals.bRunAsPassword = TRUE;
	}
	
	return RETVAL_SUCCESS;
}

/******************************************************************************
	Routine Description:

		This routine validates & determines the modifier value .

	Arguments:

		[ in ] szModifier		 : Modifer value
		[ in ] dwScheduleType  : Type of schedule[Daily,once,weekly etc]
		[ in ] dwModOptActCnt  : Modifier optional value
		[ in ] dwDayOptCnt     :   Days value
		[ in ] dwMonOptCnt     : Months value
		[ out ] bIsDefltValMod : Whether default value should be given for modifier

	Return Value :
		A DWORD value indicating RETVAL_SUCCESS on success else RETVAL_FAIL 
		on failure
******************************************************************************/ 

DWORD
ValidateModifierVal(LPCTSTR szModifier, DWORD dwScheduleType,
					DWORD dwModOptActCnt, DWORD dwDayOptCnt, 
					DWORD dwMonOptCnt, BOOL& bIsDefltValMod
					)
{
	
	TCHAR szDayType[MAX_RES_STRING];
	DWORD dwModifier = 0;

	lstrcpy(szDayType,GetResString(IDS_TASK_FIRSTWEEK));
	lstrcat(szDayType,_T("|"));
	lstrcat(szDayType,GetResString(IDS_TASK_SECONDWEEK));
	lstrcat(szDayType,_T("|"));
	lstrcat(szDayType,GetResString(IDS_TASK_THIRDWEEK));
	lstrcat(szDayType,_T("|"));
	lstrcat(szDayType,GetResString(IDS_TASK_FOURTHWEEK));
	lstrcat(szDayType,_T("|"));
	lstrcat(szDayType,GetResString(IDS_TASK_LASTWEEK));


	bIsDefltValMod = FALSE; // If TRUE : Set modifier to default value, 1.
	LPTSTR pszStopString = NULL;
	
		
	switch( dwScheduleType )
	{
		
		case SCHED_TYPE_MINUTE:   // Schedule type is Minute

			if( (dwModOptActCnt <= 0) || (lstrlen(szModifier) < 0) )
			{
				
				bIsDefltValMod = TRUE;
				return RETVAL_SUCCESS;
			}

			dwModifier = _tcstoul(szModifier,&pszStopString,BASE_TEN);
			if( lstrlen( pszStopString ))
				break;
				

			if( dwModifier > 0 && dwModifier < 1440 ) // Valid Range 1 - 1439
				return RETVAL_SUCCESS;

			break;

		// Schedule type is Hourly
		case SCHED_TYPE_HOURLY:

			if( (dwModOptActCnt <= 0) || (lstrlen(szModifier) < 0) )
			{	
				
				bIsDefltValMod = TRUE;
				return RETVAL_SUCCESS;
			}

			dwModifier = _tcstoul(szModifier,&pszStopString,BASE_TEN);
			if( lstrlen( pszStopString ) )
				break;

			if( dwModifier > 0 && dwModifier < 24 ) // Valid Range 1 - 23
				return RETVAL_SUCCESS;

			break;

		// Schedule type is Daily
		case SCHED_TYPE_DAILY:
			// -days option is NOT APPLICABLE for DAILY type item.
			
			if( (dwDayOptCnt > 0) )
			{// Invalid sysntax. Return error
				// Modifier option and days options both should not specified same time.
				bIsDefltValMod = FALSE;
				DISPLAY_MESSAGE(stderr, GetResString(IDS_DAYS_NA));
				return RETVAL_FAIL;
			}

			// -months option is NOT APPLICABLE for DAILY type item.
			if( dwMonOptCnt > 0 )
			{// Invalid sysntax. Return error
				// Modifier option and days options both should not specified same time.
				bIsDefltValMod = FALSE;
				DISPLAY_MESSAGE(stderr , GetResString(IDS_MON_NA));
				return RETVAL_FAIL;
			}

			// Check whether the -modifier switch is psecified. If not, then take default value.
			if( (dwModOptActCnt <= 0) || (lstrlen(szModifier) < 0) )
			{
				// Modifier options is not specified. So, set it to default value. (i.e, 1 )
				bIsDefltValMod = TRUE;
				return RETVAL_SUCCESS;
			}

			dwModifier = _tcstoul(szModifier,&pszStopString,BASE_TEN);

			if( lstrlen( pszStopString ) )
				break;

			// If the -modifier option is specified, then validate the value.
			if( dwModifier > 0 && dwModifier < 366 ) // Valid Range 1 - 365
			{
				return RETVAL_SUCCESS;
			}
			else
			{
				DISPLAY_MESSAGE(stderr, GetResString(IDS_INVALID_MODIFIER));
				return RETVAL_FAIL;
			}

			break;

		// Schedule type is Weekly
		case SCHED_TYPE_WEEKLY:
			
			// If -modifier option is not specified, then set it to default value.
			if( (dwModOptActCnt <= 0) || (lstrlen(szModifier) < 0) )
			{
				// Modifier options is not specified. So, set it to default value. (i.e, 1 )
				bIsDefltValMod = TRUE;
				return RETVAL_SUCCESS;
			}


			if( dwModOptActCnt > 0)
			{
				dwModifier = _tcstoul(szModifier,&pszStopString,BASE_TEN);
				if( lstrlen( pszStopString ) )
					break;
		
				if( dwModifier > 0 && dwModifier < 53 ) // Valid Range 1 - 52
					return RETVAL_SUCCESS;
				
				break;
			}
		
			break;

		// Schedule type is Monthly
		case SCHED_TYPE_MONTHLY:
			
			// If -modifier option is not specified, then set it to default value.
			if( ( dwModOptActCnt > 0) && (lstrlen(szModifier) == 0) )
			{
				// Modifier option is not proper. So display error and return false.
				bIsDefltValMod = FALSE;
				DISPLAY_MESSAGE(stderr, GetResString(IDS_INVALID_MODIFIER));
				return RETVAL_FAIL;
			}
			//check if the modifier is LASTDAY[not case sensitive]
			if( lstrcmpi( szModifier , GetResString( IDS_DAY_MODIFIER_LASTDAY ) ) == 0)
				return RETVAL_SUCCESS;

			//Check if -mo is in between FIRST,SECOND ,THIRD, LAST
			//then -days[ MON to SUN ] is applicable , -months is also applicable
	
			if( InString ( szModifier , szDayType , TRUE ) )
			{
				return RETVAL_SUCCESS;
				
			}
			else
			{
				
				dwModifier = _tcstoul(szModifier,&pszStopString,BASE_TEN);
				if( lstrlen( pszStopString ) )
					break;
				
				if( ( dwModOptActCnt == 1 ) && ( dwModifier < 1 || dwModifier > 12 ) ) //check whether -mo value is in between 1 - 12
				{
					//invalid -mo value
					DISPLAY_MESSAGE(stderr, GetResString(IDS_INVALID_MODIFIER));
					return RETVAL_FAIL;
				}

				return RETVAL_SUCCESS;
			}
			
			break;

		case SCHED_TYPE_ONETIME:
		case SCHED_TYPE_ONSTART:
		case SCHED_TYPE_ONLOGON:
		case SCHED_TYPE_ONIDLE:

			if( dwModOptActCnt <= 0 )
			{
				// Modifier option is not applicable. So, return success.
				bIsDefltValMod = FALSE;
				return RETVAL_SUCCESS;
			}
			else
			{
				// Modifier option is not applicable. But specified. So, return error.
				bIsDefltValMod = FALSE;
				DISPLAY_MESSAGE(stderr, GetResString(IDS_MODIFIER_NA));
				return RETVAL_FAIL;
			}
			break;

		default:
			return RETVAL_FAIL;
			
	}
	
	// Modifier option is not proper. So display error and return false.
	bIsDefltValMod = FALSE;
	DISPLAY_MESSAGE(stderr, GetResString(IDS_INVALID_MODIFIER));

	return RETVAL_FAIL;
}

/******************************************************************************
	Routine Description:

		This routine validates & determines the day,month value .

	Arguments:

		[ in ] szDay		 : Day value
		[ in ] szMonths		 : Months[Daily,once,weekly etc]
		[ in ] dwSchedType   : Modifier optional value
		[ in ] dwDayOptCnt   : Days option  value
		[ in ] dwMonOptCnt   : Months option value
		[ in ] dwOptModifier : Modifier option value
		[ in ] szModifier    : Whether default value for modifier

	Return Value :
		A DWORD value indicating RETVAL_SUCCESS on success else RETVAL_FAIL 
		on failure
******************************************************************************/ 

DWORD
ValidateDayAndMonth(LPTSTR szDay, LPTSTR szMonths, DWORD dwSchedType,
  DWORD dwDayOptCnt,DWORD dwMonOptCnt, DWORD dwOptModifier, LPTSTR szModifier)
{
			
	DWORD	dwRetval = 0;
	DWORD	dwModifier = 0;
	DWORD	dwDays = 0;
	TCHAR  szDayModifier[MAX_RES_STRING]  = NULL_STRING;
		
	//get the valid  week day modifiers from the rc file
	lstrcpy(szDayModifier,GetResString(IDS_TASK_FIRSTWEEK));
	lstrcat(szDayModifier,_T("|"));
	lstrcat(szDayModifier,GetResString(IDS_TASK_SECONDWEEK));
	lstrcat(szDayModifier,_T("|"));
	lstrcat(szDayModifier,GetResString(IDS_TASK_THIRDWEEK));
	lstrcat(szDayModifier,_T("|"));
	lstrcat(szDayModifier,GetResString(IDS_TASK_FOURTHWEEK));
	lstrcat(szDayModifier,_T("|"));
	lstrcat(szDayModifier,GetResString(IDS_TASK_LASTWEEK));

	switch (dwSchedType)
	{
		case SCHED_TYPE_DAILY:
			// -days and -months optons is not applicable. SO, check for it.
			if( dwDayOptCnt > 0 || dwMonOptCnt > 0)
			{
				return RETVAL_FAIL;
			}
			
			return RETVAL_SUCCESS;

			break;

		case SCHED_TYPE_MONTHLY:

			if( dwMonOptCnt > 0 && lstrlen(szMonths) == 0)
			{
					DISPLAY_MESSAGE(stderr, GetResString(IDS_INVALID_VALUE_FOR_MON));
					return RETVAL_FAIL;
			}
			
			//if the modifier is LASTDAY
			if( lstrcmpi( szModifier , GetResString( IDS_DAY_MODIFIER_LASTDAY ) ) == 0)
			{
				//-day is not applicable for this case only -months is applicable
				if( dwDayOptCnt > 0 )
				{
					DISPLAY_MESSAGE(stderr, GetResString(IDS_DAYS_NA));
					return RETVAL_FAIL;
				}

				if(lstrlen(szMonths))
				{

					if( ( ValidateMonth( szMonths ) == RETVAL_SUCCESS ) ||
						InString( szMonths, ASTERIX, TRUE )  )
					{
						return RETVAL_SUCCESS;
					}
					else
					{
						DISPLAY_MESSAGE(stderr , GetResString(IDS_INVALID_VALUE_FOR_MON));
						return RETVAL_FAIL;
					}
				}
				else
				{
						DISPLAY_MESSAGE(stderr ,GetResString(IDS_NO_MONTH_VALUE));
						return RETVAL_FAIL;
				}
			
			}
			
			// If -day is specified then check whether the day value is valid or not.
			if( InString( szDay, ASTERIX, TRUE) )
			{
				DISPLAY_MESSAGE(stderr ,GetResString(IDS_INVALID_VALUE_FOR_DAY));
				return RETVAL_FAIL;
			}
			if(( lstrlen (szDay ) == 0 )  &&  InString(szModifier, szDayModifier, TRUE))
			{
				DISPLAY_MESSAGE(stderr, GetResString(IDS_NO_DAY_VALUE));
				return RETVAL_FAIL;
			}

			if( dwDayOptCnt )
			{	
				dwModifier = (DWORD) AsLong(szModifier, BASE_TEN); 
				
				//check for multiples days,if then return error

				if ( _tcspbrk ( szDay , COMMA_STRING ) )	
				{
					DISPLAY_MESSAGE(stderr, GetResString(IDS_INVALID_VALUE_FOR_DAY));
					return RETVAL_FAIL;
				}
					

				if( ValidateDay( szDay ) == RETVAL_SUCCESS )			
				{
					//Check the modifier value should be in FIRST, SECOND, THIRD, FOURTH, LAST OR LASTDAY etc..
					if(!( InString(szModifier, szDayModifier, TRUE) ) )
					{
						DISPLAY_MESSAGE(stderr, GetResString(IDS_INVALID_VALUE_FOR_DAY));
						return RETVAL_FAIL;						
					}
					
				}
				else
				{
					dwDays = (DWORD) AsLong(szDay, BASE_TEN); 
				
					if( ( dwDays < 1 ) || ( dwDays > 31 ) )
					{
						DISPLAY_MESSAGE(stderr, GetResString(IDS_INVALID_VALUE_FOR_DAY));
						return RETVAL_FAIL;
					}
					
					if( ( dwOptModifier == 1 ) && ( ( dwModifier < 1 ) || ( dwModifier > 12 ) ) )
					{
						DISPLAY_MESSAGE(stderr, GetResString(IDS_INVALID_MODIFIER));
						return RETVAL_FAIL;
					}
					
					if( InString(szModifier, szDayModifier, TRUE) )
					{
						DISPLAY_MESSAGE(stderr, GetResString(IDS_INVALID_VALUE_FOR_DAY));
						return RETVAL_FAIL;
					}

					if(dwMonOptCnt && lstrlen(szModifier))
					{
						DISPLAY_MESSAGE(stderr ,GetResString(IDS_INVALID_VALUE_FOR_MON));
						return RETVAL_FAIL;
					}
				}
				
			} //end of dwDayOptCnt

			if(lstrlen(szMonths))
			{
				
				if( lstrlen(szModifier) )
				{
					dwModifier = (DWORD) AsLong(szModifier, BASE_TEN); 

					 if(dwModifier >= 1 && dwModifier <= 12)
					 {
						DISPLAY_MESSAGE( stderr ,GetResString(IDS_MON_NA));
						return RETVAL_FAIL;
					 }
				}

				if( ( ValidateMonth( szMonths ) == RETVAL_SUCCESS ) ||
					InString( szMonths, ASTERIX, TRUE )  )
				{
					return RETVAL_SUCCESS;
				}
				else
				{
					DISPLAY_MESSAGE(stderr ,GetResString(IDS_INVALID_VALUE_FOR_MON));
					return RETVAL_FAIL;
				}
			}
			
			
			// assgin default values for month,day
			return RETVAL_SUCCESS;

		case SCHED_TYPE_HOURLY:
		case SCHED_TYPE_ONETIME:
		case SCHED_TYPE_ONSTART:
		case SCHED_TYPE_ONLOGON:
		case SCHED_TYPE_ONIDLE:
		case SCHED_TYPE_MINUTE:
			
			// -months switch is NOT APPLICABLE.
			if( dwMonOptCnt > 0 )
			{
				DISPLAY_MESSAGE(stderr ,GetResString(IDS_MON_NA));
				return RETVAL_FAIL;
			}
			
			// -days switch is NOT APPLICABLE.
			if( dwDayOptCnt > 0 )
			{
				DISPLAY_MESSAGE(stderr ,GetResString(IDS_DAYS_NA));
				return RETVAL_FAIL;
			}

			break;

		case SCHED_TYPE_WEEKLY:

			// -months field is NOT APPLICABLE for WEEKLY item.
			if( dwMonOptCnt > 0 )
			{
				DISPLAY_MESSAGE(stderr ,GetResString(IDS_MON_NA));
				return RETVAL_FAIL;
			}
			
			
			if(dwDayOptCnt > 0)
			{
				if( dwRetval = ValidateDay(szDay) )
				{
					DISPLAY_MESSAGE(stderr ,GetResString(IDS_INVALID_VALUE_FOR_DAY));
					return RETVAL_FAIL;
				}
			}
			

		return RETVAL_SUCCESS;
	
		default:
			break;
	}
	
	return RETVAL_SUCCESS;
}

/******************************************************************************
	Routine Description:

		This routine validates the months values specified by the user 

	Arguments:

		[ in ] szMonths : Months options given by user

	Return Value :
		A DWORD value indicating RETVAL_SUCCESS on success else RETVAL_FAIL 
		on failure
******************************************************************************/ 

DWORD
ValidateMonth(LPTSTR szMonths)
{
	_TCHAR* pMonthstoken = NULL; // For getting months.
	_TCHAR seps[]   = _T(", \n");
	_TCHAR szMonthsList[MAX_STRING_LENGTH] = NULL_STRING;
	_TCHAR szTmpMonths[MAX_STRING_LENGTH] = NULL_STRING;
	_TCHAR szPrevTokens[MAX_TOKENS_LENGTH] = NULL_STRING;
	LPCTSTR lpsz = NULL;

	// If the szMonths string is empty or NULL return error.
	if( szMonths == NULL )
	{
		return RETVAL_FAIL;
	}
	else
	{
		lpsz = szMonths;
	}

	//check for any illegal input like only ,DEC,[comma at the end of month name or before]
	if(*lpsz == _T(','))
		return RETVAL_FAIL;
	
	lpsz = _tcsdec(lpsz, lpsz + _tcslen(lpsz) );

	if( lpsz != NULL )
	{
		if( *lpsz == _T(','))
			return RETVAL_FAIL;
	}

	//get the valid  month modifiers from the rc file
	lstrcpy(szMonthsList,GetResString(IDS_MONTH_MODIFIER_JAN));
	lstrcat(szMonthsList,_T("|"));
	lstrcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_FEB));
	lstrcat(szMonthsList,_T("|"));
	lstrcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_MAR));
	lstrcat(szMonthsList,_T("|"));
	lstrcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_APR));
	lstrcat(szMonthsList,_T("|"));
	lstrcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_MAY));
	lstrcat(szMonthsList,_T("|"));
	lstrcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_JUN));
	lstrcat(szMonthsList,_T("|"));
	lstrcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_JUL));
	lstrcat(szMonthsList,_T("|"));
	lstrcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_AUG));
	lstrcat(szMonthsList,_T("|"));
	lstrcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_SEP));
	lstrcat(szMonthsList,_T("|"));
	lstrcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_OCT));
	lstrcat(szMonthsList,_T("|"));
	lstrcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_NOV));
	lstrcat(szMonthsList,_T("|"));
	lstrcat(szMonthsList,GetResString(IDS_MONTH_MODIFIER_DEC));
	
	if( InString( szMonths , szMonthsList , TRUE )  &&
		InString( szMonths , ASTERIX , TRUE ) )
	{
		return RETVAL_FAIL;
	}
	
	if( InString( szMonths , ASTERIX , TRUE ) )
		return RETVAL_SUCCESS;

	//Check for multiple commas[,] after months like FEB,,,MAR errors
	lpsz = szMonths;
	while ( lstrlen ( lpsz ) )
	{
		if(*lpsz == _T(','))
		{
			lpsz = _tcsinc(lpsz);
			while ( ( lpsz != NULL ) && ( _istspace(*lpsz) ) )
				lpsz = _tcsinc(lpsz);

			if( lpsz != NULL )
			{
				if(*lpsz == _T(','))
					return RETVAL_FAIL;
			}
					
		}
		else
			lpsz = _tcsinc(lpsz);
	}

	lstrcpy(szTmpMonths, szMonths);

	_TCHAR* pPrevtoken = NULL;
	pMonthstoken = _tcstok( szTmpMonths, seps );

	if( !(InString(pMonthstoken, szMonthsList, TRUE)) )
			return RETVAL_FAIL;

	if( pMonthstoken )
		lstrcpy ( szPrevTokens, pMonthstoken);

	while( pMonthstoken != NULL )
	{
		//check if month names are replicated like MAR,MAR from user input
		pPrevtoken = pMonthstoken;
		pMonthstoken = _tcstok( NULL, seps );

		if ( pMonthstoken == NULL)
			return RETVAL_SUCCESS;
		
		if( !(InString(pMonthstoken, szMonthsList, TRUE)) )
			return RETVAL_FAIL;

		if( InString(pMonthstoken,szPrevTokens, TRUE) )
			return RETVAL_FAIL;

		lstrcat( szPrevTokens, _T("|"));
		lstrcat( szPrevTokens, pMonthstoken);
	}

	return RETVAL_SUCCESS;
}


/******************************************************************************
	Routine Description:

		This routine validates the days values specified by the user 

	Arguments:

		[ in ] szDays : Days options given by user

	Return Value :
		A DWORD value indicating RETVAL_SUCCESS on success else RETVAL_FAIL
		on failure
******************************************************************************/ 

DWORD
ValidateDay(LPTSTR szDays)
{
	TCHAR* pDaystoken = NULL; 
	TCHAR seps[]   = _T(", \n");
	TCHAR szDayModifier[MAX_STRING_LENGTH ] = NULL_STRING;
	TCHAR szTmpDays[MAX_STRING_LENGTH] = NULL_STRING;

	//get the valid   day modifiers from the rc file
	lstrcpy(szDayModifier,GetResString(IDS_DAY_MODIFIER_SUN));
	lstrcat(szDayModifier,_T("|"));
	lstrcat(szDayModifier,GetResString(IDS_DAY_MODIFIER_MON));
	lstrcat(szDayModifier,_T("|"));
	lstrcat(szDayModifier,GetResString(IDS_DAY_MODIFIER_TUE));
	lstrcat(szDayModifier,_T("|"));
	lstrcat(szDayModifier,GetResString(IDS_DAY_MODIFIER_WED));
	lstrcat(szDayModifier,_T("|"));
	lstrcat(szDayModifier,GetResString(IDS_DAY_MODIFIER_THU));
	lstrcat(szDayModifier,_T("|"));
	lstrcat(szDayModifier,GetResString(IDS_DAY_MODIFIER_FRI));
	lstrcat(szDayModifier,_T("|"));
	lstrcat(szDayModifier,GetResString(IDS_DAY_MODIFIER_SAT));

	//check for any illegal input like MON, or ,MON [comma at the end of day name or before]
	LPCTSTR lpsz = NULL;
	if( szDays != NULL)
		lpsz = szDays;
	else
		return RETVAL_FAIL;
	
	if(*lpsz == _T(','))
		return RETVAL_FAIL;
	
	lpsz = _tcsdec(lpsz, lpsz + _tcslen(lpsz) );
	if( lpsz != NULL )
	{
		if( *lpsz == _T(',') )
			return RETVAL_FAIL;
	}

	if ( ( lpsz != NULL ) && ( _istspace(*lpsz) ))
	{
		return RETVAL_FAIL;
	}

	if( (InString( szDays , szDayModifier , TRUE )) || (InString( szDays , ASTERIX , TRUE )))
	{
		return RETVAL_SUCCESS;
	}
	
	//Check for multiple commas[,] after days like SUN,,,TUE errors
	lpsz = szDays;
	while ( lstrlen ( lpsz ) )
	{
		if(*lpsz == _T(','))
		{
			lpsz = _tcsinc(lpsz);
			while ( ( lpsz != NULL ) && ( _istspace(*lpsz) ))
				lpsz = _tcsinc(lpsz);

			if( lpsz != NULL )
			{
				if(*lpsz == _T(','))
					return RETVAL_FAIL;
			}
					
		}
		else
		{
			lpsz = _tcsinc(lpsz);
		}
	}
	
	if(szDays != NULL)
		lstrcpy(szTmpDays, szDays);

	// If the szDays string is empty or NULL return error.
	if( (lstrlen(szTmpDays) <= 0) )
	{
		return RETVAL_FAIL;
	}

	//_TCHAR* pPrevtoken = NULL;
	_TCHAR szPrevtokens[MAX_TOKENS_LENGTH] = NULL_STRING;

	// Establish string and get the first token: 
	pDaystoken = _tcstok( szTmpDays, seps );

	if( pDaystoken )
		lstrcpy( szPrevtokens , pDaystoken );

	while( pDaystoken != NULL )
	{
		//check if day names are replicated like SUN,MON,SUN from user input
		
		if( !(InString(pDaystoken,szDayModifier,TRUE)) )
		{
			return RETVAL_FAIL;
		}

		pDaystoken = _tcstok( NULL, seps );
		if( pDaystoken )
		{
			if( (InString(pDaystoken,szPrevtokens,TRUE)) )
			{
				return RETVAL_FAIL;
			}

			lstrcat( szPrevtokens , _T("|") );
			lstrcat( szPrevtokens , pDaystoken );
		}
	}

	return RETVAL_SUCCESS;
}

/******************************************************************************
	Routine Description:

		This routine validates the start date specified by the user 

	Arguments:

		[ in ] szStartDate     : Start date specified by user 
		[ in ] dwSchedType     : Schedule type
		[ in ] dwStDtOptCnt    : whether start  date specified by the user 
		[ out ] bIsCurrentDate : If start date not specified then startdate = current date

Return Value :
	A DWORD value indicating RETVAL_SUCCESS on success else RETVAL_FAIL
	on failure
******************************************************************************/ 

DWORD
ValidateStartDate(LPTSTR szStartDate, DWORD dwSchedType, DWORD dwStDtOptCnt, 
				  BOOL &bIsCurrentDate)
{
		
	DWORD dwRetval = RETVAL_SUCCESS; 
	bIsCurrentDate = FALSE; // If TRUE : Startdate should be set to Current Date.
	TCHAR szBuffer[MAX_STRING_LENGTH] = NULL_STRING;
	_TCHAR* szValues[1] = {NULL};//To pass to FormatMessage() API

	TCHAR szFormat[MAX_DATE_STR_LEN] = NULL_STRING;

	if ( RETVAL_FAIL == GetDateFormatString( szFormat) )
	{
		return RETVAL_FAIL;
	}

	switch (dwSchedType)
	{
		case SCHED_TYPE_MINUTE:
		case SCHED_TYPE_HOURLY:
		case SCHED_TYPE_DAILY:
		case SCHED_TYPE_WEEKLY:
		case SCHED_TYPE_MONTHLY:
		case SCHED_TYPE_ONIDLE:
		case SCHED_TYPE_ONSTART:
		case SCHED_TYPE_ONLOGON:
			
			if( (dwStDtOptCnt <= 0))
			{
				bIsCurrentDate = TRUE;
				return RETVAL_SUCCESS;
			}

			if(dwRetval = ValidateDateString(szStartDate)) 
			{
				szValues[0] = (_TCHAR*) (szFormat);
				FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
					  GetResString(IDS_INVALIDFORMAT_STARTDATE),0,MAKELANGID(LANG_NEUTRAL,
			          SUBLANG_DEFAULT),szBuffer,
			          MAX_STRING_LENGTH,(va_list*)szValues );

				DISPLAY_MESSAGE(stderr, szBuffer);	

				return dwRetval;
			}
			return RETVAL_SUCCESS;

		case SCHED_TYPE_ONETIME:

		if( (dwStDtOptCnt <= 0))
			{
				bIsCurrentDate = TRUE;
				return RETVAL_SUCCESS;

			}
			
			if( (dwRetval = ValidateDateString(szStartDate))) 
			{
				szValues[0] = (_TCHAR*) (szFormat);
				FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
					  GetResString(IDS_INVALIDFORMAT_STARTDATE),0,MAKELANGID(LANG_NEUTRAL,
			          SUBLANG_DEFAULT),szBuffer,
			          MAX_STRING_LENGTH,(va_list*)szValues );

					DISPLAY_MESSAGE(stderr, szBuffer);	
					return dwRetval;
			}

			return RETVAL_SUCCESS;

		default:
				break;
	}

	return RETVAL_FAIL;
}

/******************************************************************************
	Routine Description:

		This routine validates the end date specified by the user 

	Arguments:

	[ in ] szEndDate	   : End date specified by user 
    [ in ] dwSchedType   : Schedule type
	[ in ] dwEndDtOptCnt : whether end date specified by the user 

	Return Value :
		A DWORD value indicating RETVAL_SUCCESS on success else RETVAL_FAIL 
		on failure
******************************************************************************/ 

DWORD
ValidateEndDate(LPTSTR szEndDate, DWORD dwSchedType, DWORD dwEndDtOptCnt)
{
	
	DWORD dwRetval = RETVAL_SUCCESS; // return value
	TCHAR szFormat[MAX_DATE_STR_LEN] = NULL_STRING;
	_TCHAR* szValues[1] = {NULL};//To pass to FormatMessage() API
	TCHAR szBuffer[MAX_STRING_LENGTH] = NULL_STRING;

	if ( RETVAL_FAIL == GetDateFormatString( szFormat) )
	{
		return RETVAL_FAIL;
	}

	switch (dwSchedType)
	{
		case SCHED_TYPE_MINUTE:
		case SCHED_TYPE_HOURLY:
		case SCHED_TYPE_DAILY:
		case SCHED_TYPE_WEEKLY:
		case SCHED_TYPE_MONTHLY:
	
			
			if( (dwEndDtOptCnt <= 0))
			{
				// No default value & Value is not mandatory.. so return success.
				szEndDate = NULL_STRING; // Set to empty string.
				return RETVAL_SUCCESS;
			}
			if(dwRetval = ValidateDateString(szEndDate)) 
			{
				szValues[0] = (_TCHAR*) (szFormat);
				FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
					  GetResString(IDS_INVALIDFORMAT_ENDDATE),0,MAKELANGID(LANG_NEUTRAL,
			          SUBLANG_DEFAULT),szBuffer,
			          MAX_STRING_LENGTH,(va_list*)szValues );

					DISPLAY_MESSAGE(stderr, szBuffer);

					return dwRetval;
			}
			else
			{
				return RETVAL_SUCCESS;
			}
			break;

		case SCHED_TYPE_ONSTART:
		case SCHED_TYPE_ONLOGON:
		case SCHED_TYPE_ONIDLE:
		case SCHED_TYPE_ONETIME:

			if( dwEndDtOptCnt > 0 )
			{
				// Error. End date is not applicable here, but option specified.
				DISPLAY_MESSAGE(stderr,GetResString(IDS_ENDDATE_NA));
				return RETVAL_FAIL;
			}
			else
			{
				return RETVAL_SUCCESS;
			}
			break;

		default:
			// Never comes here.
			break;
	}

	return RETVAL_FAIL;
}


/******************************************************************************
	Routine Description:

		This routine validates the start time specified by the user 

	Arguments:

		[ in ] szStartTime     : End date specified by user 
		[ in ] dwSchedType     : Schedule type
		[ in ] dwStTimeOptCnt  : whether end date specified by the user 
		[ out ] bIsCurrentTime : Determine if start time is present else assign
							   to current time

	Return Value :
		A DWORD value indicating RETVAL_SUCCESS on success else 
		RETVAL_FAIL on failure
  
******************************************************************************/ 


DWORD
ValidateStartTime(LPTSTR szStartTime, DWORD dwSchedType, DWORD dwStTimeOptCnt, 
				  BOOL &bIsCurrentTime)
{
		
	DWORD dwRetval = RETVAL_SUCCESS; // return value
	bIsCurrentTime = FALSE; // If TRUE : Startdate should be set to Current Date.

	switch (dwSchedType)
	{
		case SCHED_TYPE_MINUTE:
		case SCHED_TYPE_HOURLY:
		case SCHED_TYPE_DAILY:
		case SCHED_TYPE_WEEKLY:
		case SCHED_TYPE_MONTHLY:
			
			if( (dwStTimeOptCnt <= 0))
			{
				bIsCurrentTime = TRUE;
				return RETVAL_SUCCESS;
			}
			if(dwRetval = ValidateTimeString(szStartTime)) 
			{
				// Error. Invalid date string.
				DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALIDFORMAT_STARTTIME));
				return dwRetval;
			}
			return RETVAL_SUCCESS;
			
		case SCHED_TYPE_ONETIME:

			if( (dwStTimeOptCnt <= 0))
			{
				// Error. Start Time is not specified.
				DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_STARTTIME));
				return RETVAL_FAIL;
			}
			else if(dwRetval = ValidateTimeString(szStartTime)) 
			{
				// Error. Invalid date string.
				DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALIDFORMAT_STARTTIME));
				return dwRetval;
			}
			
			return RETVAL_SUCCESS;

		case SCHED_TYPE_ONSTART:
		case SCHED_TYPE_ONLOGON:
		case SCHED_TYPE_ONIDLE:

			if( dwStTimeOptCnt > 0 )
			{
				// Start Time is not applicable in this option. 
				//But the -starttime option specified. Display error.
				DISPLAY_MESSAGE(stderr,GetResString(IDS_STARTTIME_NA));
				return RETVAL_FAIL;
			}
			else
			{
				return RETVAL_SUCCESS;
			}
			break;

		default:
			// Never comes here.
			break;
	}

	return RETVAL_FAIL;
}

/******************************************************************************
	Routine Description:

		This routine validates the idle time specified by the user 

	Arguments:

		[ in ] szIdleTime      : Ilde time specified by user 
		[ in ] dwSchedType     : Schedule type
		[ in ] dwIdlTimeOptCnt : whether Idle time specified by the user 

	Return Value :
		A DWORD value indicating RETVAL_SUCCESS on success else 
		RETVAL_FAIL on failure
  
******************************************************************************/ 

DWORD
ValidateIdleTimeVal(LPTSTR szIdleTime, DWORD dwSchedType,
						  DWORD dwIdlTimeOptCnt)
{
	
	long lIdleTime = 0;
	LPTSTR pszStopString = NULL;
	switch (dwSchedType)
	{
		case SCHED_TYPE_MINUTE:
		case SCHED_TYPE_HOURLY:
		case SCHED_TYPE_DAILY:
		case SCHED_TYPE_WEEKLY:
		case SCHED_TYPE_MONTHLY:
		case SCHED_TYPE_ONSTART:
		case SCHED_TYPE_ONLOGON:
		case SCHED_TYPE_ONETIME:
			
			if( dwIdlTimeOptCnt > 0 )
			{
				DISPLAY_MESSAGE(stderr ,GetResString(IDS_IDLETIME_NA));			
				return RETVAL_FAIL;
			}
			else
			{
				return RETVAL_SUCCESS;
			}
			break;

		case SCHED_TYPE_ONIDLE:

			if( dwIdlTimeOptCnt == 0 )
			{
						
				DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_IDLETIME));
				return RETVAL_FAIL;
			}

			lIdleTime = _tcstoul(szIdleTime,&pszStopString,BASE_TEN);
			if( lstrlen( pszStopString ) || ( lIdleTime <= 0 ) || ( lIdleTime > 999 ) )
			{
				DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALIDORNO_IDLETIME));
				return RETVAL_FAIL;
			}
	
			return RETVAL_SUCCESS;

		default:
				break;
	}

	DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALIDORNO_IDLETIME));
	return RETVAL_FAIL;
}

/******************************************************************************
	Routine Description:

		This routine validates the date string. 

	Arguments:

		[ in ] szDate : Date string

	Return Value :
		A DWORD value indicating RETVAL_SUCCESS on success else 
		RETVAL_FAIL on failure
******************************************************************************/ 

DWORD
ValidateDateString(LPTSTR szDate)
{
	WORD  dwDate = 0;
	WORD  dwMon  = 0;
	WORD  dwYear = 0;

	if(lstrlen(szDate) <= 0)
	{ 
		return RETVAL_FAIL;
	}
	
	if( GetDateFieldEntities(szDate, &dwDate, &dwMon, &dwYear) ) // Error
	{
		return RETVAL_FAIL;
	}

	if( ValidateDateFields(dwDate, dwMon, dwYear) )
	{
		return RETVAL_FAIL;
	}
	
	return RETVAL_SUCCESS; // return success if no error.
}

/******************************************************************************
	Routine Description:

		This routine retrives the date field entities out of the date string

	Arguments:

		[ in ] szDate   : Date string
		[ out ] pdwDate : Pointer to date value[1,2,3 ...30,31 etc]
		[ out ] pdwMon  : Pointer to Month value[1,2,3 ...12 etc]
		[ out ] pdwYear : Pointer to year value[2000,3000 etc]

	Return Value :
		A DWORD value indicating RETVAL_SUCCESS on success else 
		RETVAL_FAIL on failure
******************************************************************************/ 

DWORD
GetDateFieldEntities(LPTSTR szDate, WORD* pdwDate, WORD* pdwMon, WORD* pdwYear)
{
	_TCHAR	strDate[MAX_STRING_LENGTH] = NULL_STRING; // Date in _TCHAR type string.
	_TCHAR	tDate[MAX_DATE_STR_LEN] = NULL_STRING; // Date
	_TCHAR	tMon[MAX_DATE_STR_LEN] = NULL_STRING; // Month
	_TCHAR	tYear[MAX_DATE_STR_LEN] = NULL_STRING; // Year
	WORD    wFormatID = 0;
		   
	if(szDate != NULL)	   
		lstrcpy(strDate,szDate);

	if(lstrlen(strDate) <= 0)
		return RETVAL_FAIL; // No value specified in szDate.
	
   	if ( RETVAL_FAIL == GetDateFieldFormat( &wFormatID ))
	{
		return RETVAL_FAIL;
	}

	if ( wFormatID == 0 || wFormatID == 1 )
	{
	if( (lstrlen(strDate) != DATESTR_LEN) || 
		(strDate[FIRST_DATESEPARATOR_POS] != DATE_SEPARATOR_CHAR)
		|| (strDate[SECOND_DATESEPARATOR_POS] != DATE_SEPARATOR_CHAR) )
	{
		return RETVAL_FAIL;
	}
	}
	else
	{
	if( (lstrlen(strDate) != DATESTR_LEN) || 
		(strDate[FOURTH_DATESEPARATOR_POS] != DATE_SEPARATOR_CHAR)
		|| (strDate[SEVENTH_DATESEPARATOR_POS] != DATE_SEPARATOR_CHAR) )
	{
		return RETVAL_FAIL;
	}
	}

	// Get the individual date field entities using _tcstok function 
	// with respect to regional options.
	

	if ( wFormatID == 0 )
	{
	lstrcpy(tMon, _tcstok(strDate,DATE_SEPARATOR_STR)); // Get the Month field.
	if(lstrlen(tMon) > 0)
	{
		lstrcpy(tDate, _tcstok(NULL,DATE_SEPARATOR_STR)); // Get the date field.
		lstrcpy(tYear, _tcstok(NULL,DATE_SEPARATOR_STR)); // Get the Year field.
	}
	}
	else if ( wFormatID == 1 )
	{
	lstrcpy(tDate, _tcstok(strDate,DATE_SEPARATOR_STR)); // Get the Month field.
	if(lstrlen(tDate) > 0)
	{
		lstrcpy(tMon, _tcstok(NULL,DATE_SEPARATOR_STR)); // Get the date field.
		lstrcpy(tYear, _tcstok(NULL,DATE_SEPARATOR_STR)); // Get the Year field.
	}
	}
	else
	{
	lstrcpy(tYear, _tcstok(strDate,DATE_SEPARATOR_STR)); // Get the Month field.
	if(lstrlen(tYear) > 0)
	{
		lstrcpy(tMon, _tcstok(NULL,DATE_SEPARATOR_STR)); // Get the date field.
		lstrcpy(tDate, _tcstok(NULL,DATE_SEPARATOR_STR)); // Get the Year field.
	}
	}

	// Now convert string values to numeric for date validations.
	LPTSTR pszStopString = NULL;

	*pdwDate = (WORD)_tcstoul(tDate,&pszStopString,BASE_TEN);
	if( lstrlen( pszStopString ))
		return RETVAL_FAIL;
	
	*pdwMon = (WORD)_tcstoul(tMon,&pszStopString,BASE_TEN);
	if( lstrlen( pszStopString ))
		return RETVAL_FAIL;

	*pdwYear = (WORD)_tcstoul(tYear,&pszStopString,BASE_TEN);
	if( lstrlen( pszStopString ))
		return RETVAL_FAIL;

	
	
	return RETVAL_SUCCESS;
}

/******************************************************************************
	Routine Description:
	
		This routine validates the date field entities

	Arguments:

		[ in ] dwDate : Date value[Day in a month]
		[ in ] dwMon	: Month constant
		[ in ] dwYear : year value

	Return Value :
		A DWORD value indicating RETVAL_SUCCESS on success else 
		RETVAL_FAIL on failure
******************************************************************************/ 

DWORD
ValidateDateFields( DWORD dwDate, DWORD dwMon, DWORD dwYear)
{

	if(dwYear < MIN_YEAR  || dwYear > MAX_YEAR)
		return RETVAL_FAIL;

	switch(dwMon)
	{
		case IND_JAN:
		case IND_MAR:
		case IND_MAY:
		case IND_JUL:
		case IND_AUG:
		case IND_OCT:
		case IND_DEC:

			if(dwDate > 0 && dwDate <= 31)
			{
				return RETVAL_SUCCESS;
			}
			break;
		
		case IND_APR:
		case IND_JUN:
		case IND_SEP:
		case IND_NOV:

			if(dwDate > 0 && dwDate < 31)
			{
				return RETVAL_SUCCESS;
			}
			break;

		case IND_FEB:

			if( ((dwYear % 4) == 0) && (dwDate > 0 && dwDate <= 29) )
			{
					return RETVAL_SUCCESS;
			}
			else if( ((dwYear % 4) != 0) && (dwDate > 0 && dwDate < 29) )
			{
					return RETVAL_SUCCESS;
			}
	
			break;

		default:

			break;
	}
	
	return RETVAL_FAIL;

}

/******************************************************************************
	Routine Description:

		This routine validates the time specified by the user

	Arguments:

		[ in ] szTime : time string

	Return Value :
		A DWORD value indicating RETVAL_SUCCESS on success else 
		RETVAL_FAIL on failure
******************************************************************************/


DWORD
ValidateTimeString(LPTSTR szTime)
{
	WORD  dwHours = 0;
	WORD  dwMins = 0;
	WORD  dwSecs = 0 ;
	
	// Check for the empty string value.
	if(lstrlen(szTime) <= 0)
	{ 
		return RETVAL_FAIL;
	}
	
	// Get separate entities from the given time string.
	if( GetTimeFieldEntities(szTime, &dwHours, &dwMins, &dwSecs) ) 
	{
		return RETVAL_FAIL;
	}

	// Validate the individual entities of the given time.
	if( ValidateTimeFields(dwHours, dwMins, dwSecs) )
	{
		return RETVAL_FAIL;
	}
		
	return RETVAL_SUCCESS; 
}

/******************************************************************************
	Routine Description:

		This routine retrieves the different fields of time
	Arguments:

		[ in ] szTime    : Time string
 		[ out ] pdwHours : pointer to hours value
		[ out ] pdwMins  : pointer to mins value
		[ out ] pdwSecs  : pointer to seconds value

	Return Value :
		A DWORD value indicating RETVAL_SUCCESS on success else 
		RETVAL_FAIL on failure
******************************************************************************/

DWORD
GetTimeFieldEntities(LPTSTR szTime, WORD* pdwHours, WORD* pdwMins,
					 WORD* pdwSecs)
{
	_TCHAR strTime[MAX_STRING_LENGTH] = NULL_STRING ; // Time in _TCHAR type string.
	_TCHAR tHours[MAX_TIME_STR_LEN] = NULL_STRING ; // Date
	_TCHAR tMins[MAX_TIME_STR_LEN]  = NULL_STRING ; // Month
	_TCHAR tSecs[MAX_TIME_STR_LEN]  = NULL_STRING ; // Year
		 
	if(lstrlen(szTime) <= 0)
		return RETVAL_FAIL; 

	lstrcpy(strTime, szTime);
		
	if( (lstrlen(strTime) != TIMESTR_LEN) || (strTime[FIRST_TIMESEPARATOR_POS] 
			!= TIME_SEPARATOR_CHAR) || (strTime[SECOND_TIMESEPARATOR_POS] != TIME_SEPARATOR_CHAR) )
		return RETVAL_FAIL;

	// Get the individual Time field entities using _tcstok function.in the order "hh" followed by "mm" followed by "ss"
	lstrcpy(tHours, _tcstok(strTime,TIME_SEPARATOR_STR)); // Get the Hours field.
	if(lstrlen(tHours) > 0)
	{
		lstrcpy(tMins, _tcstok(NULL,TIME_SEPARATOR_STR)); // Get the Minutes field.
		lstrcpy(tSecs, _tcstok(NULL,TIME_SEPARATOR_STR)); // Get the Seconds field.
	}
	
	LPTSTR pszStopString = NULL;

	// Now convert string values to numeric for time validations.
	*pdwHours = (WORD)_tcstoul(tHours,&pszStopString,BASE_TEN);
	if( lstrlen( pszStopString ) )
		return RETVAL_FAIL;

	*pdwMins = (WORD)_tcstoul(tMins,&pszStopString,BASE_TEN);
	if( lstrlen( pszStopString ))
		return RETVAL_FAIL;

	*pdwSecs = (WORD)_tcstoul(tSecs,&pszStopString,BASE_TEN);
	if( lstrlen( pszStopString ))
		return RETVAL_FAIL;

	return RETVAL_SUCCESS;
}

/******************************************************************************
	Routine Description:

	This routine validates the time fields of a  given time

	Arguments:

		[ in ] dwHours :Hours value
		[ in ] dwMins  :Minutes value 
		[ in ] dwSecs  : seconds value

	Return Value :
		A DWORD value indicating RETVAL_SUCCESS on success else 
		RETVAL_FAIL on failure
******************************************************************************/

DWORD
ValidateTimeFields( DWORD dwHours, DWORD dwMins, DWORD dwSecs)
{
	
	if ( dwHours <= HOURS_PER_DAY_MINUS_ONE ) 
	{
		if ( ( dwMins < MINUTES_PER_HOUR ) && ( dwSecs < SECS_PER_MINUTE) ) 
		{
			return RETVAL_SUCCESS; 
		}
		else 
		{
			return RETVAL_FAIL;
		}
	}
	else
	{
			return RETVAL_FAIL;
	}

}

/******************************************************************************
	Routine Description:

		This routine validates the time fields of a  given time

	Arguments:

		[ in ] szDay : time string

	Return Value :
		A WORD value containing the day constant [TASK_SUNDAY,TASK_MONDAY etc]
******************************************************************************/

WORD
GetTaskTrigwDayForDay(LPTSTR szDay)
{
	TCHAR szDayBuff[MAX_RES_STRING] = NULL_STRING;
	TCHAR *token = NULL; 
	TCHAR seps[]   = _T(" ,\n");
	WORD dwRetval = 0;

	if(lstrlen(szDay) != 0)
		lstrcpy(szDayBuff, szDay);

	if( lstrlen(szDayBuff) <= 0 )
	{
		return (TASK_MONDAY);//Default value
	}

	token = _tcstok( szDayBuff, seps );
	while( token != NULL )
	{
		if( !(lstrcmpi(token, GetResString( IDS_DAY_MODIFIER_SUN ))) )
			dwRetval |= (TASK_SUNDAY);
		else if( !(lstrcmpi(token, GetResString( IDS_DAY_MODIFIER_MON ))) )
			dwRetval |= (TASK_MONDAY);
		else if( !(lstrcmpi(token, GetResString( IDS_DAY_MODIFIER_TUE ))) )
			dwRetval |= (TASK_TUESDAY);
		else if( !(lstrcmpi(token, GetResString( IDS_DAY_MODIFIER_WED ))) )
			dwRetval |= (TASK_WEDNESDAY);
		else if( !(lstrcmpi(token, GetResString( IDS_DAY_MODIFIER_THU ))) )
			dwRetval |= (TASK_THURSDAY);
		else if( !(lstrcmpi(token,GetResString( IDS_DAY_MODIFIER_FRI ))) )
			dwRetval |= (TASK_FRIDAY);
		else if( !(lstrcmpi(token, GetResString( IDS_DAY_MODIFIER_SAT ))) )
			dwRetval |= (TASK_SATURDAY);
		else if( !(lstrcmpi(token, ASTERIX)) )
			return (TASK_SUNDAY | TASK_MONDAY | TASK_TUESDAY | TASK_WEDNESDAY |
					TASK_THURSDAY | TASK_FRIDAY | TASK_SATURDAY);
		else
			return 0;
		
		token = _tcstok( NULL, seps );
	}

	return dwRetval;
}

/******************************************************************************

	Routine Description:

		This routine validates the time fields of a  given time

	Arguments:

		[ in ] szMonth : Month string

	Return Value :
		A WORD value containing the Month constant
		[TASK_JANUARY,TASK_FEBRUARY etc]

******************************************************************************/

WORD
GetTaskTrigwMonthForMonth(LPTSTR szMonth)
{
	TCHAR *token = NULL; 
	WORD dwRetval = 0;
	TCHAR strMon[MAX_TOKENS_LENGTH] = NULL_STRING;
	TCHAR seps[]   = _T(" ,\n");

	if( lstrlen(szMonth) <= 0 )
	{
		return (TASK_JANUARY | TASK_FEBRUARY | TASK_MARCH | TASK_APRIL | TASK_MAY | TASK_JUNE | 
				TASK_JULY | TASK_AUGUST | TASK_SEPTEMBER | TASK_OCTOBER 
				| TASK_NOVEMBER | TASK_DECEMBER );
	}
	lstrcpy(strMon, szMonth);

	token = _tcstok( szMonth, seps );
	while( token != NULL )
	{
		if( !(lstrcmpi(token, ASTERIX)) )
			return (TASK_JANUARY | TASK_FEBRUARY | TASK_MARCH | TASK_APRIL 
				| TASK_MAY | TASK_JUNE | TASK_JULY | TASK_AUGUST | TASK_SEPTEMBER | TASK_OCTOBER 
				| TASK_NOVEMBER | TASK_DECEMBER );     
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_JAN ))) )
			dwRetval |= (TASK_JANUARY);
		else if( !(lstrcmpi(token,GetResString( IDS_MONTH_MODIFIER_FEB ))) )
			dwRetval |= (TASK_FEBRUARY);
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_MAR ))) )
			dwRetval |= (TASK_MARCH);
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_APR ))) )
			dwRetval |= (TASK_APRIL);
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_MAY ))) )
			dwRetval |= (TASK_MAY);
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_JUN ))) )
			dwRetval |= (TASK_JUNE);
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_JUL ))) )
			dwRetval |= (TASK_JULY);
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_AUG ))) )
			dwRetval |= (TASK_AUGUST);
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_SEP ))) )
			dwRetval |= (TASK_SEPTEMBER);
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_OCT ))) )
			dwRetval |= (TASK_OCTOBER);
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_NOV ))) )
			dwRetval |= (TASK_NOVEMBER);
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_DEC ))) )
			dwRetval |= (TASK_DECEMBER);
		else
			return 0;
	
		token = _tcstok( NULL, seps );
	}
	
	return dwRetval;
 }

/******************************************************************************

	Routine Description:

		This routine returns the corresponding month flag

	Arguments:

		[ in ] dwMonthId : Month index

	Return Value :
		A WORD value containing the Month constant 
		[TASK_JANUARY,TASK_FEBRUARY etc]

******************************************************************************/

WORD
GetMonthId(DWORD dwMonthId)
{
	DWORD dwMonthsArr[] = {TASK_JANUARY,TASK_FEBRUARY ,TASK_MARCH ,TASK_APRIL ,
						   TASK_MAY ,TASK_JUNE ,TASK_JULY ,TASK_AUGUST,
						   TASK_SEPTEMBER ,TASK_OCTOBER ,TASK_NOVEMBER ,TASK_DECEMBER } ;

	DWORD wMonthFlags = 0;
	DWORD dwMod = 0;

	dwMod = dwMonthId - 1;

	while(dwMod < 12)
	{
		wMonthFlags |= dwMonthsArr[dwMod];
		dwMod = dwMod + dwMonthId;
	}

	return (WORD)wMonthFlags;
}

/******************************************************************************

	Routine Description:

		This routine returns the maximum Last day in the  months specifed

	Arguments:

		[ in ] szMonths	  : string containing months specified by user
		[ in ] wStartYear : string containing start year
	 Return Value :
		A DWORD value specifying the maximum last day in the specified months

******************************************************************************/

DWORD GetNumDaysInaMonth(TCHAR* szMonths, WORD wStartYear)
{
	DWORD dwDays = 31;//max.no of days in a month
	BOOL bMaxDays = FALSE;//if any of the months have 31 then days of value 31 is returned			

	if( ( lstrlen(szMonths) == 0 ) || ( lstrcmpi(szMonths,ASTERIX) == 0 ) )
		return dwDays; //All months[default]


  	TCHAR *token = NULL; 
	TCHAR strMon[MAX_MONTH_STR_LEN] = NULL_STRING;
	TCHAR seps[]   = _T(" ,\n");
	
	lstrcpy(strMon, szMonths);

	token = _tcstok( strMon, seps );
	while( token != NULL )
	{
		if( !(lstrcmpi(token,GetResString( IDS_MONTH_MODIFIER_FEB ))) )
		{
			
			if( ( (wStartYear % 400) == 0) || 
				( ( (wStartYear % 4) == 0) && 
				( (wStartYear % 100) != 0) ) )
			{
				dwDays = 29;
			}
			else
			{
				dwDays = 28;
			}
		}
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_JAN ))) )
		{
			bMaxDays = TRUE;			
		}
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_MAR ))) )
		{
			bMaxDays = TRUE;			
		}
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_MAY ))) )
		{
			bMaxDays = TRUE;			
		}
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_JUL ))) )
		{
			bMaxDays = TRUE;			
			
		}
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_AUG ))) )
		{
			bMaxDays = TRUE;			
		
		}
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_OCT ))) )
		{
			bMaxDays = TRUE;			
			
		}
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_DEC ))) )
		{
			bMaxDays = TRUE;			
		}
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_APR ))) )
		{
			dwDays = 30;
		}
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_JUN ))) )
		{
			dwDays = 30;
		}
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_SEP ))) )
		{
			dwDays = 30;
		}
		else if( !(lstrcmpi(token, GetResString( IDS_MONTH_MODIFIER_NOV ))) )
		{
			dwDays =  30;
		}
		
	
		token = _tcstok( NULL, seps );
	}

	if (bMaxDays == TRUE)
		return 31;
	else
		return dwDays;

}

/******************************************************************************

	Routine Description:

		This routine checks the validates the taskname of the task to be created.

	Arguments:

		[ in ] pszJobName : Pointer to the job[task] name
		
	 Return Value :
		If valid task name then TRUE else FALSE

******************************************************************************/

BOOL VerifyJobName(_TCHAR* pszJobName)
{
	_TCHAR szTokens[] = {_T('<'),_T('>'),_T(':'),_T('/'),_T('\\'),_T('|')};
	
	if( _tcspbrk(pszJobName,szTokens)  == NULL)

		return TRUE;
	else
		return FALSE;
}

/******************************************************************************

	Routine Description:

	This routine gets the date format value with respective to regional options.

	Arguments:

		[ out ] pdwFormat : Date format value.
		
	 Return Value :
		Returns RETVAL_FAIL on failure and RETVAL_SUCCESS on success.


******************************************************************************/

DWORD GetDateFieldFormat(WORD* pwFormat)
{
	LCID lcid;
	_TCHAR szBuffer[MAX_BUF_SIZE];

	//Get the user default locale in the users computer
	lcid = GetUserDefaultLCID();

	//Get the date format
	if (GetLocaleInfo(lcid, LOCALE_IDATE, szBuffer, MAX_BUF_SIZE)) 
	{
        switch (szBuffer[0])
		{
            case TEXT('0'):
				*pwFormat = 0;
			     break;
            case TEXT('1'):
                *pwFormat = 1;
		         break;
            case TEXT('2'):
                *pwFormat = 2;
		         break;
            default:
				return RETVAL_FAIL;
        }
	}
	return RETVAL_SUCCESS;
}

/******************************************************************************

	Routine Description:

		This routine gets the date format string with respective to regional options.

	Arguments:

		[ out ] szFormat : Date format string.
		
	 Return Value :
		Returns RETVAL_FAIL on failure and RETVAL_SUCCESS on success.

******************************************************************************/

DWORD GetDateFormatString(LPTSTR szFormat)    
{
	WORD wFormatID = 0;

	if ( RETVAL_FAIL == GetDateFieldFormat( &wFormatID ))
	{
		return RETVAL_FAIL;
	}


	if ( wFormatID == 0 )
	{
		lstrcpy (szFormat, GetResString(IDS_MMDDYY_FORMAT));
	}
	else if ( wFormatID == 1 )
	{
		lstrcpy (szFormat, GetResString( IDS_DDMMYY_FORMAT));
	}
	else if ( wFormatID == 2 )
	{
		lstrcpy (szFormat, GetResString(IDS_YYMMDD_FORMAT));
	}
	else
	{
		return RETVAL_FAIL;
	}

	return RETVAL_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scheduledtasks\create.h ===
/******************************************************************************

	Copyright(c) Microsoft Corporation

	Module Name:

		create.h

	Abstract:

		This module contains the macros, user defined structures & function 
		definitions needed by create.cpp , createvalidations.cpp files.

	Author:

		B.Raghu Babu  10-oct-2000 

	Revision History:

		B.Raghu Babu	 10-oct-2000 : Created it
		G.Surender Reddy 25-oct-2000 : Modified it
									   [ Added macro constants,Function 
									    definitions ]
		
******************************************************************************/ 

#ifndef __CREATE_H
#define __CREATE_H

#pragma once


// Constants declarations
#define MAX_TASKNAME_LEN	512
#define MAX_USERNAME_LEN	300
#define MAX_TIMESTR_LEN		32
#define MAX_SCHEDTYPE_LEN   32
#define MAX_DATESTR_LEN		32
#define MAX_CREATE_OPTIONS	15  // Total Number of sub-options in -create option.
#define MAX_JOB_LEN         239 //Maximum length of task name 
#define MAX_TASK_LEN		262 //Max.length of task run
#define MAX_BUF_SIZE        128 //Maximum buffer size for format message 

 
#define MINUTES_PER_HOUR    60 // Minutes per hour
#define SECS_PER_MINUTE		60 // Minutes per hour
#define HOURS_PER_DAY		24 // Minutes per hour
#define HOURS_PER_DAY_MINUS_ONE	 23 // Minutes per hour minus one
#define MAX_MONTH_STR_LEN	60 // Maximum length of months

#define MIN_YEAR		1752 // Minimum year
#define MAX_YEAR		9999 // Maximum year

#define CASE_SENSITIVE_VAL  0  // case sensitive.
#define BASE_TEN			10 // Base value for AsLong ()function.
#define MAX_DATE_STR_LEN	50  
#define MAX_TIME_STR_LEN	5  
#define MAX_ERROR_STRLEN	2056  // max string len for error messages.

#define OPTION_COUNT		1 // No of times an option can be repeated.(Max)
#define DEFAULT_MODIFIER    1 // Default value for the modifier value.
#define DEFAULT_MODIFIER_SZ    _T("1") // Default value[string] for the modifier value.


#define DATE_SEPARATOR_CHAR			_T('/') 
#define DATE_SEPARATOR_STR			_T("/") 
#define FIRST_DATESEPARATOR_POS		2 
#define SECOND_DATESEPARATOR_POS    5 
#define FOURTH_DATESEPARATOR_POS	4 
#define SEVENTH_DATESEPARATOR_POS   7 

#define SCHEDULER_NOT_RUNNING_ERROR_CODE	0x80041315
#define UNABLE_TO_ESTABLISH_ACCOUNT			0x80041310
#define RPC_SERVER_NOT_AVAILABLE			0x800706B5

#define DATESTR_LEN					10
#define MAX_TOKENS_LENGTH				60

#define TIME_SEPARATOR_CHAR    _T(':')
#define TIME_SEPARATOR_STR    _T(":") 
#define FIRST_TIMESEPARATOR_POS		2 
#define SECOND_TIMESEPARATOR_POS    5 
#define TIMESTR_LEN					8 
#define HOURSPOS_IN_TIMESTR			1 
#define MINSPOS_IN_TIMESTR			2 
#define SECSPOS_IN_TIMESTR			3 
#define EXE_LENGTH					4

#define OI_SERVER			1 // Index of -s option in cmdOptions structure.
#define OI_RUNASUSERNAME	2 // Index of -ru option in cmdOptions structure.
#define OI_RUNASPASSWORD	3 // Index of -rp option in cmdOptions structure.
#define OI_USERNAME			4 // Index of -u option in cmdOptions structure.
#define OI_PASSWORD			5 // Index of -p option in cmdOptions structure.
#define OI_SCHEDTYPE		6 // Index of -scheduletype option in cmdOptions structure.
#define OI_MODIFIER			7 // Index of -modifier option in cmdOptions structure.
#define OI_DAY				8 // Index of -day option in cmdOptions structure.
#define OI_MONTHS			9 // Index of -months option in cmdOptions structure.
#define OI_IDLETIME			10 // Index of -idletime option in cmdOptions structure.
#define OI_TASKNAME			11 // Index of -taskname option in cmdOptions structure.
#define OI_TASKRUN			12 // Index of -taskrun option in cmdOptions structure.
#define OI_STARTTIME		13 // Index of -starttime option in cmdOptions structure.
#define OI_STARTDATE		14 // Index of -startdate option in cmdOptions structure.
#define OI_ENDDATE			15 // Index of -enddate option in cmdOptions structure.
#define OI_USAGE			16 // Index of -? option in cmdOptions structure.

#define OI_RUNANDUSER		6

// Schedule Types
#define SCHED_TYPE_MINUTE	1
#define SCHED_TYPE_HOURLY	2
#define SCHED_TYPE_DAILY	3
#define SCHED_TYPE_WEEKLY	4
#define SCHED_TYPE_MONTHLY	5
#define SCHED_TYPE_ONETIME	6
#define SCHED_TYPE_ONSTART	7
#define SCHED_TYPE_ONLOGON	8
#define SCHED_TYPE_ONIDLE	9

// Months Indices.
#define IND_JAN			1  // January
#define IND_FEB			2  // February
#define IND_MAR			3  // March
#define IND_APR			4  // April
#define IND_MAY			5  // May
#define IND_JUN			6  // June
#define IND_JUL			7  // July
#define IND_AUG			8  // August
#define IND_SEP			9  // September
#define IND_OCT			10 // October
#define IND_NOV			11 // November
#define IND_DEC			12 // December


// Return Values
#define RETVAL_SUCCESS		0
#define RETVAL_FAIL			1

typedef struct __tagCreateSubOps
{
	TCHAR   szServer [ _MAX_PATH ];				// Server Name
	TCHAR	szRunAsUser [ MAX_STRING_LENGTH ] ;		//Run As User Name
	TCHAR	szRunAsPassword [ MAX_STRING_LENGTH ];		// Run As Password
	TCHAR	szUser [ MAX_STRING_LENGTH ] ;		// User Name
	TCHAR	szPassword [ MAX_STRING_LENGTH ];		// Password
	TCHAR	szSchedType [ MAX_TASKNAME_LEN ];	// Schedule Type  
	TCHAR	szModifier [ MAX_SCHEDTYPE_LEN ];	// Modifier Value
	TCHAR	szDays [ MAX_DATE_STR_LEN ];			// Days			  
	TCHAR	szMonths [ MAX_DATE_STR_LEN];		// Months		  
	TCHAR	szIdleTime [ MAX_TIMESTR_LEN];		// Idle Time	  
	TCHAR	szTaskName [ MAX_TASKNAME_LEN];		// Task Name	  
	TCHAR	szStartTime [ MAX_STRING_LENGTH ];		// Task start time  
	TCHAR	szStartDate [ MAX_STRING_LENGTH];		// Task start date
	TCHAR	szEndDate [ MAX_STRING_LENGTH ];		// End Date of the Task
	TCHAR	szTaskRun [ _MAX_PATH ];				// executable name of task
	DWORD	bCreate; // Create option
	DWORD	bUsage;	 // Usage option.
			
} TCREATESUBOPTS;


typedef struct __tagCreateOpsVals
{
	BOOL	bSetStartDateToCurDate;	// Is start date to be set to current date 
	BOOL	bSetStartTimeToCurTime;	// Is start date to be set to current date 
	BOOL	bPassword;
	BOOL	bRunAsPassword;
			
} TCREATEOPVALS;


DWORD DisplayCreateUsage();
HRESULT CreateTask(TCREATESUBOPTS tcresubops, TCREATEOPVALS &tcreoptvals, 
						DWORD dwScheduleType, WORD wUserStatus);
DWORD ProcessCreateOptions(DWORD argc, LPCTSTR argv[],TCREATESUBOPTS &tcresubops,
			TCREATEOPVALS &tcreoptvals, DWORD* pdwRetScheType, WORD *pwUserStatus);
DWORD ValidateSuboptVal(TCREATESUBOPTS& tcresubops, TCREATEOPVALS &tcreoptvals,
						TCMDPARSER cmdOptions[], DWORD dwScheduleType);
DWORD ValidateRemoteSysInfo(LPTSTR szServer, LPTSTR szUser, LPTSTR szPassword, 
			TCMDPARSER cmdOptions[] , TCREATESUBOPTS& tcresubops, TCREATEOPVALS &tcreoptvals);
DWORD ValidateModifierVal(LPCTSTR szModifier, DWORD dwScheduleType,
						  DWORD dwModOptActCnt, DWORD dwDayOptCnt, 
						  DWORD dwMonOptCnt, BOOL &bIsDefltValMod);
DWORD ValidateDayAndMonth(LPTSTR szDay, LPTSTR szMonths, DWORD dwSchedType, 
	DWORD dwDayOptCnt, DWORD dwMonOptCnt, DWORD dwModifier,LPTSTR szModifier);
DWORD ValidateStartDate(LPTSTR szStartDate, DWORD dwSchedType, DWORD dwStDtOptCnt,
						BOOL &bIsCurrentDate);
DWORD ValidateEndDate(LPTSTR szEndDate, DWORD dwSchedType, DWORD dwEndDtOptCnt);
DWORD ValidateStartTime(LPTSTR szStartTime, DWORD dwSchedType, DWORD dwStTimeOptCnt,
						BOOL &bIsCurrentTime);
DWORD ValidateIdleTimeVal(LPTSTR szIdleTime, DWORD dwSchedType, 
						  DWORD dwIdlTimeOptCnt);
DWORD ValidateDateString(LPTSTR szDate);
DWORD ValidateTimeString(LPTSTR szTime);
DWORD GetDateFieldEntities(LPTSTR szDate, WORD* pdwDate, WORD* pdwMon,
						   WORD* pdwYear);
DWORD ValidateDateFields( DWORD dwDate, DWORD dwMon, DWORD dwyear);
DWORD GetTimeFieldEntities(LPTSTR szTime, WORD* pdwHours, WORD* pdwMins,
						   WORD* pdwSecs);
DWORD ValidateTimeFields( DWORD dwHours, DWORD dwMins, DWORD dwSecs);
WORD GetTaskTrigwDayForDay(LPTSTR szDay);
WORD GetTaskTrigwMonthForMonth(LPTSTR szMonth);
DWORD ValidateMonth(LPTSTR szMonths);
DWORD ValidateDay(LPTSTR szDays);
WORD GetMonthId(DWORD dwMonthId);
DWORD GetNumDaysInaMonth(TCHAR* szMonths, WORD wStartYear);
BOOL VerifyJobName(_TCHAR* pszJobName);
DWORD GetDateFieldFormat(WORD* pdwDate);
DWORD GetDateFormatString(LPTSTR szFormat);
DWORD ProcessFilePath(LPTSTR szInput,LPTSTR szFirstString,LPTSTR szSecondString);


#endif // __CREATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scheduledtasks\delete.cpp ===
/******************************************************************************

	Copyright(c) Microsoft Corporation

	Module Name:

		delete.cpp

	Abstract:

		This module deletes the task(s) present in the system 

	Author:

		Hari 10-Sep-2000

	Revision History:
	
		Hari 10-Sep-2000 : Created it
		G.Surender Reddy  25-Sep-2000 : Modified it [added error checking]
		G.Surender Reddy  31-Oct-2000 : Modified it 
										[Moved strings to resource file]
		G.Surender Reddy  18-Nov-2000 : Modified it 
										[Modified usage help to be displayed]
		G.Surender Reddy  15-Dec-2000 : Modified it 
										[Removed getch() fn.& used Console API
											to read characters]
		G.Surender Reddy  22-Dec-2000 : Modified it 
										[Rewrote the DisplayDeleteUsage() fn.]
		G.Surender Reddy  08-Jan-2001 : Modified it 
										[Deleted the unused variables.]

******************************************************************************/ 


//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"
#include <xpsp1res.h>

// Function declaration for the Usage function.
VOID DisplayDeleteUsage();
BOOL ConfirmDelete( LPCTSTR szTaskName , PBOOL pbFalg );
LPWSTR GetSpResString( UINT uID , LPWSTR lpwszBuffer);

/*****************************************************************************

	Routine Description:

	This routine  deletes a specified scheduled task(s)

	Arguments:

		[ in ] argc :  Number of command line arguments
		[ in ] argv : Array containing command line arguments

	Return Value :
		A DWORD value indicating EXIT_SUCCESS on success else 
		EXIT_FAILURE on failure
  
*****************************************************************************/

DWORD
DeleteScheduledTask(  DWORD argc, LPCTSTR argv[] )
{
	// Variables used to find whether Delete main option, Usage option
	// or the force option is specified or not
	BOOL bDelete = FALSE;
	BOOL bUsage = FALSE;
	BOOL bForce = FALSE;

	// Set the TaskSchduler object as NULL
	ITaskScheduler *pITaskScheduler = NULL;

	// Return value
	HRESULT hr  = S_OK;
	
	// Initialising the variables that are passed to TCMDPARSER structure
	_TCHAR	szServer[ MAX_STRING_LENGTH ]   = NULL_STRING; 
    _TCHAR	szTaskName[ MAX_STRING_LENGTH ] = NULL_STRING;
	_TCHAR	szUser[ MAX_STRING_LENGTH ]   = NULL_STRING; 
    _TCHAR	szPassword[ MAX_STRING_LENGTH ] = NULL_STRING;

	// For each task in all the tasks.
	LPCTSTR szEachTaskName = NULL;
	BOOL bWrongValue = FALSE;
    
	// Dynamic Array contaning array of jobs
	TARRAY arrJobs = NULL;

	// Task name or the job name which is to be deleted
	WCHAR wszJobName[MAX_STRING_LENGTH] ; 

	wcscpy(wszJobName,NULL_U_STRING);

	// Loop Variable.
	DWORD dwJobCount = 0;
	//buffer for displaying error message
	TCHAR	szMessage[MAX_STRING_LENGTH] = NULL_STRING;
	BOOL	bNeedPassword = FALSE;
	BOOL   bResult = FALSE;
	BOOL  bCloseConnection = TRUE;

	lstrcpy( szPassword, ASTERIX);

	// Builiding the TCMDPARSER structure
	TCMDPARSER cmdOptions[] = 
	{
		{ 
		  CMDOPTION_DELETE,
		  CP_MAIN_OPTION,
		  1,
		  0,
		  &bDelete,
		  NULL_STRING,
		  NULL,
		  NULL
		},
		{ 
		  SWITCH_SERVER,
		  CP_TYPE_TEXT | CP_VALUE_MANDATORY, 
		  1,
		  0,
		  &szServer,
		  NULL_STRING,
		  NULL, 
		  NULL
		},
		{ 
		  SWITCH_TASKNAME,
		  CP_TYPE_TEXT | CP_VALUE_MANDATORY | CP_MANDATORY ,
		  1,
		  0,
		  &szTaskName,
		  NULL_STRING,
		  NULL,
		  NULL
		},
		{ 
		  SWITCH_FORCE,
		  0,
		  1,
		  0,
		  &bForce,
		  NULL_STRING,
		  NULL,
		  NULL
		},
		{ 
		  CMDOPTION_USAGE,
		  CP_USAGE ,
		  1,
		  0, 
		  &bUsage,
		  NULL_STRING, 
		  NULL, 
		  NULL
		 },
		 { 
			SWITCH_USER,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY,
			OPTION_COUNT,
			0,
			&szUser,
			NULL_STRING,
			NULL,
			NULL
		},
		{ 
			SWITCH_PASSWORD,
			CP_TYPE_TEXT | CP_VALUE_OPTIONAL,
			OPTION_COUNT,
			0,
			&szPassword,
			NULL_STRING,
			NULL,
			NULL
		}
	};	
	
	// Parsing the delete option switches
	if ( DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions), cmdOptions ) == FALSE)
	{
		DISPLAY_MESSAGE( stderr, GetResString(IDS_LOGTYPE_ERROR ));
		DISPLAY_MESSAGE( stderr, GetReason() );
		//DISPLAY_MESSAGE(stderr,GetResString(IDS_DELETE_SYNERROR));
		return EXIT_FAILURE;
	}

	// triming the null spaces
	StrTrim(szServer, TRIM_SPACES );
	StrTrim(szTaskName, TRIM_SPACES );
	StrTrim(szUser, TRIM_SPACES );
	//StrTrim(szPassword, TRIM_SPACES );

	// check whether password (-p) specified in the command line or not.
	if ( cmdOptions[OI_DELPASSWORD].dwActuals == 0 )
	{
		lstrcpy( szPassword, NULL_STRING );
	}

	// Displaying delete usage if user specified -? with -delete option
	if( bUsage == TRUE )
	{
		DisplayDeleteUsage();
		return EXIT_SUCCESS;
	}

	// check for the invalid server name
	if( ( cmdOptions[OI_DELSERVER].dwActuals == 1 ) &&  ( lstrlen( szServer ) == 0 ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_SERVER));	
		return RETVAL_FAIL;
	}

	// check for invalid user name
	if( ( cmdOptions[OI_DELSERVER].dwActuals == 0 ) && ( cmdOptions[OI_DELUSERNAME].dwActuals == 1 )  )
	{
		DISPLAY_MESSAGE(stderr, GetResString(IDS_DELETE_USER_BUT_NOMACHINE));	
		return RETVAL_FAIL;
	}
	
	// check for the length of user name
	if( ( cmdOptions[OI_DELSERVER].dwActuals == 1 ) && ( cmdOptions[OI_DELUSERNAME].dwActuals == 1 ) && 
					( lstrlen( szUser ) == 0 ) )
	{
		DISPLAY_MESSAGE(stderr, GetResString(IDS_INVALID_USERNAME));	
		return RETVAL_FAIL;
	}

	// check whether username is specified or not along with the password
	if ( cmdOptions[ OI_DELUSERNAME ].dwActuals == 0 && cmdOptions[OI_DELPASSWORD].dwActuals == 1 ) 
	{
		// invalid syntax
		DISPLAY_MESSAGE(stderr, GetResString(IDS_DPASSWORD_BUT_NOUSERNAME));
		return RETVAL_FAIL;			
	}

	// check for the length of the taskname
	if( ( lstrlen( szTaskName ) > MAX_JOB_LEN ) || ( lstrlen(szTaskName) == 0 ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_TASKLENGTH));
		return EXIT_FAILURE;
	}

	// check for the length of username
	if( lstrlen( szUser ) > MAX_USERNAME_LENGTH ) 
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_UNAME  ));
		return EXIT_FAILURE;
	}
	
	// check for the length of username
	if( lstrlen( szPassword ) > MAX_PASSWORD_LENGTH ) 
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_PASSWORD));
		return EXIT_FAILURE;
	}

	// check whether the password (-p) specified in the command line or not 
	// and also check whether '*' or empty is given for -p or not
	if( ( IsLocalSystem( szServer ) == FALSE ) && 
		( ( cmdOptions[OI_DELPASSWORD].dwActuals == 0 ) || ( lstrcmpi ( szPassword, ASTERIX ) == 0 ) ))
	{
		bNeedPassword = TRUE;
	}

	if( ( IsLocalSystem( szServer ) == FALSE ) || ( cmdOptions[OI_DELUSERNAME].dwActuals == 1 ) ) 
	{
		// Establish the connection on a remote machine
		bResult = EstablishConnection(szServer,szUser,SIZE_OF_ARRAY(szUser),szPassword,SIZE_OF_ARRAY(szPassword), bNeedPassword );
		if (bResult == FALSE)
		{
			DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_STRING) );
			DISPLAY_MESSAGE( stderr, GetReason());
			return EXIT_FAILURE ;
		}
		else
		{
			// though the connection is successfull, some conflict might have occured
			switch( GetLastError() )
			{
			case I_NO_CLOSE_CONNECTION:
					bCloseConnection = FALSE;
					break;

			// for mismatched credentials
			case E_LOCAL_CREDENTIALS:
			case ERROR_SESSION_CREDENTIAL_CONFLICT:
				{
					bCloseConnection = FALSE;
					DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_STRING) );
					DISPLAY_MESSAGE( stderr, GetReason());
					return EXIT_FAILURE;
				}
			}
		}
	}	
	
	// Get the task Scheduler object for the machine.
	pITaskScheduler = GetTaskScheduler( szServer );

	// If the Task Scheduler is not defined then give the error message.
    if ( pITaskScheduler == NULL )
    {	
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
		return EXIT_FAILURE;
    }

	//for holding values of parameters in FormatMessage()
	_TCHAR* szValues[1] = {szTaskName};

	// Validate the Given Task and get as TARRAY in case of taskname 
	// as *.
	arrJobs = ValidateAndGetTasks( pITaskScheduler, szTaskName);
	if( arrJobs == NULL )
	{
		if(lstrcmpi(szTaskName,ASTERIX) == 0)
		{
			DISPLAY_MESSAGE(stdout,GetResString(IDS_TASKNAME_NOTASKS));
			// close the connection that was established by the utility
			if ( bCloseConnection == TRUE )
				CloseConnection( szServer );

			Cleanup(pITaskScheduler);
			return EXIT_SUCCESS;
		}
		else
		{
			_stprintf( szMessage , GetResString(IDS_TASKNAME_NOTEXIST), szTaskName);
			DISPLAY_MESSAGE(stderr, szMessage);	
		}
		
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
		return EXIT_FAILURE;
		
	}
	
	// Confirm whether delete operation is to be perfromed
	if( !bForce && !ConfirmDelete( szTaskName , &bWrongValue ) )
	{
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
		if ( bWrongValue == TRUE )
		{
			return EXIT_FAILURE;
		}
		else
		{
			return EXIT_SUCCESS;
		}
	}

	// Loop through all the Jobs.
	for( dwJobCount = 0; dwJobCount < DynArrayGetCount(arrJobs); dwJobCount++ )
	{
		// Get Each TaskName in the Array.
		szEachTaskName = DynArrayItemAsString( arrJobs, dwJobCount );

		// Convert the task name specified by the user to wide char or unicode format
		if ( GetAsUnicodeString(szEachTaskName,wszJobName,SIZE_OF_ARRAY(wszJobName)) == NULL )
		{
			// close the connection that was established by the utility
			if ( bCloseConnection == TRUE )
				CloseConnection( szServer );

			return EXIT_FAILURE;
		}

		// Calling the delete method of ITaskScheduler interface
		hr = pITaskScheduler->Delete(wszJobName);
		szValues[0] = (_TCHAR*) szEachTaskName;
		// Based on the return value
		switch (hr)
		{
			case S_OK:
				
				FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
							  GetResString(IDS_SUCCESS_DELETED),0,MAKELANGID(LANG_NEUTRAL,
							   SUBLANG_DEFAULT),szMessage,
					           MAX_STRING_LENGTH,(va_list*)szValues
							);
			
				DISPLAY_MESSAGE(stdout,szMessage);	
				break;
			case E_INVALIDARG:
				DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_ARG));
				
				// close the connection that was established by the utility
				if ( bCloseConnection == TRUE )
				CloseConnection( szServer );

				Cleanup(pITaskScheduler);
				return EXIT_FAILURE;
			case E_OUTOFMEMORY:
				DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_MEMORY));
				
				// close the connection that was established by the utility
				if ( bCloseConnection == TRUE )
					CloseConnection( szServer );

				Cleanup(pITaskScheduler);
				return EXIT_FAILURE;
			default:
				DisplayErrorMsg( hr );
				
				// close the connection that was established by the utility
				if ( bCloseConnection == TRUE )
					CloseConnection( szServer );

				Cleanup(pITaskScheduler);
				return EXIT_FAILURE;
		}
		
	}

	// close the connection that was established by the utility
	if ( bCloseConnection == TRUE )
		CloseConnection( szServer );

	Cleanup(pITaskScheduler);
	return EXIT_SUCCESS;
}

/*****************************************************************************

	Routine Description:

		This routine  displays the usage of -delete option

	Arguments:
		None

	Return Value :
		VOID
******************************************************************************/

VOID
DisplayDeleteUsage()
{
	// Displaying delete usage
	DisplayUsage( IDS_DEL_HLP1, IDS_DEL_HLP23);
}

/******************************************************************************
	Routine Description:

		This function validates whether the tasks to be deleted are present 
		in system & are valid.

	Arguments:

		[ in ] pITaskScheduler : Pointer to the ITaskScheduler Interface

		[ in ] szTaskName      : Array containing Task name

	Return Value :
		Array of type TARRAY containing tasks  
******************************************************************************/ 

TARRAY
ValidateAndGetTasks( ITaskScheduler *pITaskScheduler, LPCTSTR szTaskName)
{
	// Dynamic Array of Jobs
	TARRAY arrJobs = NULL;

	// Enumerating WorkItems
	IEnumWorkItems *pIEnum = NULL;

	if( (pITaskScheduler == NULL ) || ( szTaskName == NULL ) )
	{
		return NULL;
	}

	// Create a Dynamic Array
	arrJobs = CreateDynamicArray();

	// Enumerate the Work Items
	HRESULT hr = pITaskScheduler->Enum(&pIEnum);
	if( FAILED( hr) )
	{
		if( pIEnum )
			pIEnum->Release();
		DestroyDynamicArray(&arrJobs);
		return NULL;
	}

	// Names and Tasks fetches.
	LPWSTR *lpwszNames = NULL;
	DWORD dwFetchedTasks = 0;

	// Task found or not
	BOOL blnFound = FALSE;
	// array containing the Actual Taskname .
	TCHAR szActualTask[MAX_STRING_LENGTH] = NULL_STRING;

	// Enumerate all the Work Items
	while (SUCCEEDED(pIEnum->Next(TASKS_TO_RETRIEVE,
                                   &lpwszNames,
                                   &dwFetchedTasks))
                      && (dwFetchedTasks != 0))
	{
		while (dwFetchedTasks)
		{
			
			// If the Task Name is * then get parse the tokens
			// and append the jobs.
			if(lstrcmpi( szTaskName , ASTERIX) == 0 )
			{
				// Convert the Wide Charater to Multi Byte value.
				if ( GetCompatibleStringFromUnicode(lpwszNames[--dwFetchedTasks],
											   szActualTask ,
											   SIZE_OF_ARRAY(szActualTask)) == NULL )
				{
					CoTaskMemFree(lpwszNames[dwFetchedTasks]);
					
					if( pIEnum )
					{
						pIEnum->Release();
					}

					return NULL;
				}

				// Parse the Task so that .job is removed.
				 if ( ParseTaskName( szActualTask ) )
				 {
					CoTaskMemFree(lpwszNames[dwFetchedTasks]);
					
					if( pIEnum )
					{
						pIEnum->Release();
					}

					return NULL;
				 }

				// Append the task in the job array
				DynArrayAppendString( arrJobs, szActualTask, lstrlen( szActualTask ) );

				// Set the found flag as True.
				blnFound = TRUE;

				// Free the Named Task Memory.
				CoTaskMemFree(lpwszNames[dwFetchedTasks]);
			}
			else
			{
				// Check whether the TaskName is present, if present 
				// then return arrJobs.

				// Convert the Wide Charater to Multi Byte value.
				if ( GetCompatibleStringFromUnicode(lpwszNames[--dwFetchedTasks],
											   szActualTask ,
											   SIZE_OF_ARRAY(szActualTask)) == NULL )
				{
					CoTaskMemFree(lpwszNames[dwFetchedTasks]);
					
					if( pIEnum )
					{
						pIEnum->Release();
					}

					return NULL;
				}

				// Parse the TaskName to remove the .job extension.
				if ( ParseTaskName( szActualTask ) )
				{
					CoTaskMemFree(lpwszNames[dwFetchedTasks]);
					
					if( pIEnum )
					{
						pIEnum->Release();
					}

					return NULL;
				}

				StrTrim(szActualTask, TRIM_SPACES);
				// If the given Task matches with the TaskName present then form
				// the TARRAY with this task and return.
				if( lstrcmpi( szActualTask, szTaskName )  == 0 )
				{
					CoTaskMemFree(lpwszNames[dwFetchedTasks]);
					DynArrayAppendString( arrJobs, szTaskName, 
								     lstrlen( szTaskName ) );
				
					if( pIEnum )
						pIEnum->Release();
					return arrJobs;
				}
			}
			
		}//end while
	}

	CoTaskMemFree(lpwszNames); 

	if( pIEnum )
		pIEnum->Release();

	if( !blnFound )
	{
		DestroyDynamicArray(&arrJobs);
		return NULL;
	}

	// return the TARRAY object.
	return arrJobs;
}


/******************************************************************************
	Routine Description:

		This function confirms from the user really to delete the task(s).

	Arguments:

		[ in ] szTaskName  : Array containing Task name
		[ out ] pbFalg	   : Boolean flag to check whether wrong information entered
							 in the console or not.
	Return Value :
		TRUE on success else FALSE
  
******************************************************************************/ 

BOOL
ConfirmDelete( LPCTSTR szTaskName , PBOOL pbFalg )
{
	// Ch variable to hold the  read character
	TCHAR ch = NULL_CHAR;
	TCHAR chTmp = NULL_CHAR;
	// Buffer for the message.
	TCHAR szMessage[MAX_STRING_LENGTH] = NULL_STRING;

	DWORD   dwCharsRead = 0;
	DWORD   dwPrevConsoleMode = 0;
	HANDLE  hInputConsole = NULL;
	HANDLE  hOutputConsole = NULL;
	_TCHAR* szValues[1] = {NULL};//for holding values of parameters in FormatMessage()
	BOOL	bIndirectionInput	= FALSE;
	FILE	*fpInputFile		= NULL;
	TCHAR   szBuffer[MAX_BUF_SIZE] = NULL_STRING;
	WORD    wCount = 0;
	TCHAR   SpResString[500] = NULL_STRING;

	if ( szTaskName == NULL )
	{
		return FALSE;
	}

	// Get the handle for the standard input
	hInputConsole = GetStdHandle( STD_INPUT_HANDLE );
	if ( hInputConsole == NULL )
	{
		// could not get the handle so return failure
		return FALSE;
	}
	
	// Check for the input redirect
	if( ( hInputConsole != (HANDLE)0x00000003 ) && ( hInputConsole != INVALID_HANDLE_VALUE ) )
	{
		bIndirectionInput	= TRUE;
	}
	
	if ( bIndirectionInput == FALSE )
	{
		// Get the current input mode of the input buffer
		GetConsoleMode( hInputConsole, &dwPrevConsoleMode );
		// Set the mode such that the control keys are processed by the system
		if ( SetConsoleMode( hInputConsole, ENABLE_PROCESSED_INPUT ) == 0 )
		{
			// could not set the mode, return failure
			return FALSE;
		}
	}
	
	hOutputConsole = GetStdHandle( STD_OUTPUT_HANDLE );

	do
	{
		// Print the warning message.accoring to the taskname
		if( lstrcmpi( szTaskName , ASTERIX ) == 0 )
		{
			DISPLAY_MESSAGE(stdout,GetResString(IDS_WARN_DELETEALL));
		}
		else
		{	
			szValues[0] = (_TCHAR*) szTaskName;
			FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
						  GetResString(IDS_WARN_DELETE),0,MAKELANGID(LANG_NEUTRAL,
						  SUBLANG_DEFAULT),szMessage,
						  MAX_STRING_LENGTH,(va_list*)szValues
						  );
			
			DISPLAY_MESSAGE(stdout,szMessage);	
			
		}
		
		// redirect the data from StdIn.txt file into the console
		if ( bIndirectionInput	== TRUE )
		{
			do {
				//read the contents of file 
				if ( ReadFile(hInputConsole, &chTmp, 1, &dwCharsRead, NULL) == FALSE )
				{
					return FALSE;
				}
				
				if ( dwCharsRead == 0 || chTmp == CARRIAGE_RETURN )
				{
					break;
				}

				WriteConsole ( hOutputConsole, &chTmp, 1, &dwCharsRead, NULL );
				ch = chTmp;
				wCount++;
				
			} while (TRUE);

			FORMAT_STRING( szBuffer, L"%c", ch );

			if ( wCount == 1 && ( lstrcmpi ( szBuffer, GetSpResString(IDS_UPPER_YES, SpResString) ) == 0 ) )
			{
				DISPLAY_MESSAGE(stdout, _T("\n") );
				SetConsoleMode( hInputConsole, dwPrevConsoleMode );
				return TRUE;
			}
			if ( wCount == 1 && ( lstrcmpi ( szBuffer, GetSpResString(IDS_UPPER_NO , SpResString) ) == 0 ) )
			{
				DISPLAY_MESSAGE(stdout, _T("\n") );
				SetConsoleMode( hInputConsole, dwPrevConsoleMode );
				return FALSE;
			}
			else if ( wCount  > 1)
			{
				DISPLAY_MESSAGE(stdout, _T("\n") );
				DISPLAY_MESSAGE(stderr, GetResString( IDS_WRONG_INPUT_DELETE ));
				SetConsoleMode( hInputConsole, dwPrevConsoleMode );
				return FALSE;	
			}
			
		}
		else
		{
            
			// Get the Character and loop accordingly.
			if ( ReadConsole( hInputConsole, &ch, 1, &dwCharsRead, NULL ) == 0 )
			{
				// Set the original console settings
				SetConsoleMode( hInputConsole, dwPrevConsoleMode );
				
				// return failure
				return FALSE;
			}
		}

			

		WriteConsole ( hOutputConsole, &ch, 1, &dwCharsRead, NULL );

		FORMAT_STRING( szBuffer, L"%c", ch );
        
		if( lstrcmpi ( szBuffer, GetSpResString(IDS_UPPER_YES, SpResString) ) == 0 )
		{
			//Set the original console settings
			DISPLAY_MESSAGE(stdout,_T("\n") );
			SetConsoleMode( hInputConsole, dwPrevConsoleMode );
			return TRUE;
		}
		else if( lstrcmpi ( szBuffer, GetSpResString(IDS_UPPER_NO, SpResString) ) == 0 )
		{
			DISPLAY_MESSAGE(stdout,_T("\n") );
			SetConsoleMode( hInputConsole, dwPrevConsoleMode );
			return FALSE;
		}
		else
		{
			DISPLAY_MESSAGE(stdout, _T("\n") );
			DISPLAY_MESSAGE(stderr, GetResString( IDS_WRONG_INPUT_DELETE ));
			SetConsoleMode( hInputConsole, dwPrevConsoleMode );
			*pbFalg = TRUE;
			return FALSE;
		}
			
	}while( TRUE );

	//Set the original console settings
	SetConsoleMode( hInputConsole, dwPrevConsoleMode );
	return TRUE;
}

LPWSTR GetSpResString( UINT uID , LPWSTR lpwszBuffer)
{
	static const TCHAR gszResourceDLL[] = L"xpsp1res.dll";
	HINSTANCE hResourceDLL = LoadLibrary(gszResourceDLL);
	int iNum = 0;

	if ( hResourceDLL )
	{ 
		iNum = LoadString ( hResourceDLL, uID, lpwszBuffer, sizeof( lpwszBuffer )/sizeof( TCHAR ));
		FreeLibrary( hResourceDLL );
	} 

	if (iNum != 0 )
			return lpwszBuffer;

	return NULL_STRING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scheduledtasks\pch.h ===
/******************************************************************************

	Copyright(c) Microsoft Corporation

	Module Name:

		pch.h

	Abstract:

		This header file is a precompiled header for this project.
		This module contains the common include files [ system,user defined ]
		which are not changed frequently.

	Author:

		B.Raghu Babu	 10-oct-2000 

	Revision History:

		B.Raghu Babu	 10-oct-2000 : Created it
			
******************************************************************************/ 


#ifndef __PCH_H
#define __PCH_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000	// include header file only once

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <Security.h>
#include <SecExt.h>

//
// public Windows header files
//
#include <windows.h>
#include <objbase.h>
#include <initguid.h>
#include <ole2.h>
#include <mstask.h>
#include <msterr.h>
#include <mbctype.h>
//
// public C header files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <tchar.h>
#include <wchar.h>
#include <io.h>
#include <sys/stat.h>
#include <crtdbg.h>
#include <assert.h>
#include <shlwapi.h>



// private Common header files

#include "cmdline.h"
#include "cmdlineres.h"



#endif	// __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scheduledtasks\end.cpp ===
/******************************************************************************

	Copyright(c) Microsoft Corporation

	Module Name:

		end.cpp

	Abstract:

		This module terminates the schedule task which is currently running in the system 

	Author:

		Venu Gopal Choudary 12-Mar-2001

	Revision History:
	
		Venu Gopal Choudary  12-Mar-2001 : Created it
		

******************************************************************************/ 


//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"


// Function declaration for the Usage function.
VOID DisplayEndUsage();

/*****************************************************************************

	Routine Description:

	This routine terminates the scheduled task(s)

	Arguments:

		[ in ] argc :  Number of command line arguments
		[ in ] argv : Array containing command line arguments

	Return Value :
		A DWORD value indicating EXIT_SUCCESS on success else 
		EXIT_FAILURE on failure
  
*****************************************************************************/

DWORD
TerminateScheduledTask(  DWORD argc, LPCTSTR argv[] )
{
	// Variables used to find whether End option, Usage option
	// are specified or not
	BOOL bEnd = FALSE;
	BOOL bUsage = FALSE;

	// Set the TaskSchduler object as NULL
	ITaskScheduler *pITaskScheduler = NULL;
 
	// Return value
	HRESULT hr  = S_OK;
	
	// Initialising the variables that are passed to TCMDPARSER structure
	_TCHAR	szServer[ MAX_STRING_LENGTH ]   = NULL_STRING; 
    _TCHAR	szTaskName[ MAX_STRING_LENGTH ] = NULL_STRING;
	_TCHAR	szUser[ MAX_STRING_LENGTH ]   = NULL_STRING; 
    _TCHAR	szPassword[ MAX_STRING_LENGTH ] = NULL_STRING;
    
	// Declarations related to Task name
	WCHAR	wszJobName[MAX_TASKNAME_LEN] = NULL_U_STRING;
    
	// Dynamic Array contaning array of jobs
	TARRAY arrJobs = NULL;

	// Loop Variable.
	DWORD dwJobCount = 0;

	BOOL  bNeedPassword = FALSE;
	BOOL  bResult = FALSE;
	BOOL  bCloseConnection = TRUE;
	
	//buffer for displaying error message
	TCHAR	szMessage[MAX_STRING_LENGTH] = NULL_STRING;

	lstrcpy( szPassword, ASTERIX);

	// Builiding the TCMDPARSER structure
	TCMDPARSER cmdOptions[] = 
	{
		{ 
		  CMDOPTION_END,
		  CP_MAIN_OPTION,
		  1,
		  0,
		  &bEnd,
		  NULL_STRING,
		  NULL,
		  NULL
		},
		{ 
		  SWITCH_SERVER,
		  CP_TYPE_TEXT | CP_VALUE_MANDATORY, 
		  1,
		  0,
		  &szServer,
		  NULL_STRING,
		  NULL, 
		  NULL
		},
		{ 
		  SWITCH_TASKNAME,
		  CP_TYPE_TEXT | CP_VALUE_MANDATORY | CP_MANDATORY ,
		  1,
		  0,
		  &szTaskName,
		  NULL_STRING,
		  NULL,
		  NULL
		},
		{ 
		  CMDOPTION_USAGE,
		  CP_USAGE ,
		  1,
		  0, 
		  &bUsage,
		  NULL_STRING, 
		  NULL, 
		  NULL
		 },
		 { 
			SWITCH_USER,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY,
			OPTION_COUNT,
			0,
			&szUser,
			NULL_STRING,
			NULL,
			NULL
		},
		{ 
			SWITCH_PASSWORD,
			CP_TYPE_TEXT | CP_VALUE_OPTIONAL,
			OPTION_COUNT,
			0,
			&szPassword,
			NULL_STRING,
			NULL,
			NULL
		}
	};	
	
	// Parsing the end option switches
	if ( DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions), cmdOptions ) == FALSE)
	{
		DISPLAY_MESSAGE( stderr, GetResString(IDS_LOGTYPE_ERROR ));
		DISPLAY_MESSAGE( stderr, GetReason() );
		//DISPLAY_MESSAGE(stderr, GetResString(IDS_END_SYNERROR));
		return EXIT_FAILURE;
	}

	// triming the null spaces
	StrTrim(szServer, TRIM_SPACES );
	StrTrim(szTaskName, TRIM_SPACES );

	// check whether password (-p) specified in the command line or not.
	if ( cmdOptions[OI_ENDPASSWORD].dwActuals == 0 )
	{
		lstrcpy( szPassword, NULL_STRING );
	}

	// Displaying end usage if user specified -? with -run option
	if( bUsage == TRUE )
	{
		DisplayEndUsage();
		return EXIT_SUCCESS;
	}

	// check for invalid user name
	if( ( cmdOptions[OI_ENDSERVER].dwActuals == 0 ) && ( cmdOptions[OI_ENDUSERNAME].dwActuals == 1 )  )
	{
		DISPLAY_MESSAGE(stderr, GetResString(IDS_END_USER_BUT_NOMACHINE));	
		return RETVAL_FAIL;
	}
	
	// check for the length of user name
	if( ( cmdOptions[OI_ENDSERVER].dwActuals == 1 ) && ( cmdOptions[OI_ENDUSERNAME].dwActuals == 1 ) && 
			( lstrlen( szUser ) == 0 ) )
	{
		DISPLAY_MESSAGE(stderr, GetResString(IDS_INVALID_USERNAME));	
		return RETVAL_FAIL;
	}

	// check for invalid server name
	if( ( cmdOptions[OI_ENDSERVER].dwActuals == 1 ) &&  ( lstrlen( szServer ) == 0 ) )
	{
		DISPLAY_MESSAGE(stderr, GetResString(IDS_NO_SERVER));	
		return RETVAL_FAIL;
	}

	// check for invalid username
	if ( cmdOptions[ OI_ENDUSERNAME ].dwActuals == 0 && cmdOptions[ OI_ENDPASSWORD ].dwActuals == 1 ) 
	{
		// invalid syntax
		DISPLAY_MESSAGE(stderr, GetResString(IDS_EPASSWORD_BUT_NOUSERNAME));
		return RETVAL_FAIL;			// indicate failure
	}

	// check for the length of the taskname
	if( ( lstrlen( szTaskName ) > MAX_JOB_LEN ) || ( lstrlen(szTaskName) == 0 ) )
	{
		DISPLAY_MESSAGE(stderr, GetResString(IDS_INVALID_TASKLENGTH));
		return RETVAL_FAIL;
	}
	
	// Convert the task name specified by the user to wide char or unicode format
	if ( GetAsUnicodeString(szTaskName,wszJobName,SIZE_OF_ARRAY(wszJobName)) == NULL )
	{
		return RETVAL_FAIL;
	}

	// check for the length of the username
	if( lstrlen( szUser ) > MAX_USERNAME_LENGTH ) 
	{
		DISPLAY_MESSAGE( stderr, GetResString(IDS_INVALID_UNAME) );
		return RETVAL_FAIL;
	}
	
	// check for the length of the password
	if( lstrlen( szPassword ) > MAX_PASSWORD_LENGTH ) 
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_PASSWORD));
		return RETVAL_FAIL;
	}

	//for holding values of parameters in FormatMessage()
	_TCHAR* szValues[1] = {NULL};

	// check whether the password (-p) specified in the command line or not 
	// and also check whether '*' or empty is given for -p or not
	if( ( IsLocalSystem( szServer ) == FALSE ) && 
		( ( cmdOptions[OI_ENDPASSWORD].dwActuals == 0 ) || ( lstrcmpi ( szPassword, ASTERIX ) == 0 ) ) )
	{
		bNeedPassword = TRUE;
	}
		
	if( ( IsLocalSystem( szServer ) == FALSE ) || ( cmdOptions[OI_ENDUSERNAME].dwActuals == 1 ))
	{
		// Establish the connection on a remote machine
		bResult = EstablishConnection(szServer,szUser,SIZE_OF_ARRAY(szUser),szPassword,SIZE_OF_ARRAY(szPassword), bNeedPassword);
		if (bResult == FALSE)
		{
			DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_STRING) );
			DISPLAY_MESSAGE( stderr, GetReason());
			return EXIT_FAILURE ;
		}
		else
		{
			// though the connection is successfull, some conflict might have occured
			switch( GetLastError() )
			{
			case I_NO_CLOSE_CONNECTION:
					bCloseConnection = FALSE;
					break;

			case E_LOCAL_CREDENTIALS:
			case ERROR_SESSION_CREDENTIAL_CONFLICT:
				{
					bCloseConnection = FALSE;
					DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_STRING) );
					DISPLAY_MESSAGE( stderr, GetReason());
					return EXIT_FAILURE;
				}
			}
		}
	}
	// Get the task Scheduler object for the machine.
	pITaskScheduler = GetTaskScheduler( szServer );

	// If the Task Scheduler is not defined then give the error message.
    if ( pITaskScheduler == NULL )
    {	
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
		return EXIT_FAILURE;
    }

	// Validate the Given Task and get as TARRAY in case of taskname 
	arrJobs = ValidateAndGetTasks( pITaskScheduler, szTaskName);
	if( arrJobs == NULL )
	{
		_stprintf( szMessage , GetResString(IDS_TASKNAME_NOTEXIST), szTaskName);	
		DISPLAY_MESSAGE(stderr,szMessage);	
		
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
		return EXIT_FAILURE;
		
	}

	IPersistFile *pIPF = NULL;
    ITask *pITask = NULL;

	// return an pITask inteface for wszJobName
	hr = pITaskScheduler->Activate(wszJobName,IID_ITask,
									   (IUnknown**) &pITask);
 
	if (FAILED(hr))
    {
		DisplayErrorMsg(hr);

		if( pIPF )
			pIPF->Release();

		if( pITask )
			pITask->Release();
			
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
		
		return EXIT_FAILURE;
    }

	DWORD dwResult = 0;
	ULONG ulLong = MAX_RES_STRING;
	TCHAR szBuffer[MAX_STRING_LENGTH] = NULL_STRING;

	// terminate the scheduled task
	hr = pITask->Terminate();
	
    if ( FAILED(hr) )
    {
		DisplayErrorMsg(hr);
	
		if( pIPF )
			pIPF->Release();

		if( pITask )
			pITask->Release();
			
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
	    return EXIT_FAILURE;
    }
	else
	{
		szValues[0] = (_TCHAR*) (wszJobName);
		FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
					  GetResString(IDS_END_SUCCESSFUL),0,MAKELANGID(LANG_NEUTRAL,
				      SUBLANG_DEFAULT),szBuffer,
				      MAX_STRING_LENGTH,(va_list*)szValues
				     );
			
		DISPLAY_MESSAGE(stdout,szBuffer);
		
	}

	if( pIPF )
		pIPF->Release();

	if( pITask )
		pITask->Release();
			
	// close the connection that was established by the utility
	if ( bCloseConnection == TRUE )
		CloseConnection( szServer );

	Cleanup(pITaskScheduler);

	return EXIT_SUCCESS;
}

/*****************************************************************************

	Routine Description:

		This routine  displays the usage of -end option

	Arguments:
		None

	Return Value :
		VOID
******************************************************************************/

VOID
DisplayEndUsage()
{
	// Displaying run option usage
	DisplayUsage( IDS_END_HLP1, IDS_END_HLP17);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scheduledtasks\end.h ===
/******************************************************************************

	Copyright(c) Microsoft Corporation

	Module Name:

		run.h

	Abstract:

		This module contains the macros, user defined structures & function 
		definitions needed by end.cpp 

	Author:

		Venu Gopal Choudary   12-Mar-2001 

	Revision History:

		Venu Gopal Choudary   12-Mar-2001  : Created it
	
		
******************************************************************************/ 

#ifndef __END_H
#define __END_H

#pragma once
#define OI_ENDSERVER			1 // Index of -s option in cmdOptions structure.
#define OI_ENDUSERNAME			4 // Index of -u option in cmdOptions structure.
#define OI_ENDPASSWORD			5 // Index of -p option in cmdOptions structure.


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scheduledtasks\query.h ===
/******************************************************************************

	Copyright(c) Microsoft Corporation

	Module Name:

		Query.h

	Abstract:

		This module contains the macros, user defined structures & function 
		definitions needed by Query.cpp , QueryTasks.cpp files.

	Author:

		G.Surender Reddy  10-sept-2000 

	Revision History:

		G.Surender Reddy 10-sept-2000 : Created it
		G.Surender Reddy 25-sep-2000 : Modified it
									   [ Added macro constants,Function 
									    definitions ]
		
******************************************************************************/ 

#ifndef __QUERY_H
#define __QUERY_H

#pragma once		// include header file only once


//width constants for the fields
#define WIDTH_HOSTNAME			AsLong( GetResString( IDS_WIDTH_HOSTNAME ), 10 )
#define WIDTH_TASKNAME			AsLong( GetResString( IDS_WIDTH_TASKNAME ), 10 )
#define WIDTH_NEXTRUNTIME		AsLong( GetResString( IDS_WIDTH_NEXTRUNTIME ), 10 )
#define WIDTH_LASTRUNTIME		AsLong( GetResString( IDS_WIDTH_LASTRUNTIME ), 10 )
#define WIDTH_STATUS			AsLong( GetResString( IDS_WIDTH_STATUS ), 10 )
#define WIDTH_LASTRESULT		AsLong( GetResString( IDS_WIDTH_LASTRESULT ), 10 )
#define WIDTH_CREATOR			AsLong( GetResString( IDS_WIDTH_CREATOR ), 10 )
#define WIDTH_SCHEDULE			AsLong( GetResString( IDS_WIDTH_SCHEDULE ), 10 )
#define WIDTH_APPNAME			AsLong( GetResString( IDS_WIDTH_APPNAME ), 10 )
#define WIDTH_WORKDIRECTORY		AsLong( GetResString( IDS_WIDTH_WORKDIRECTORY ), 10 )
#define WIDTH_COMMENT			AsLong( GetResString( IDS_WIDTH_COMMENT ), 10 )
#define WIDTH_TASKSTATE			AsLong( GetResString( IDS_WIDTH_TASKSTATE ), 10 )
#define WIDTH_TASKTYPE			AsLong( GetResString( IDS_WIDTH_TASKTYPE ), 10 )
#define WIDTH_TASKSTIME			AsLong( GetResString( IDS_WIDTH_TASKSTIME ), 10 )
#define WIDTH_TASKSDATE			AsLong( GetResString( IDS_WIDTH_TASKSDATE ), 10 )
#define WIDTH_TASKEDATE			AsLong( GetResString( IDS_WIDTH_TASKEDATE ), 10 )
#define WIDTH_TASKDAYS			AsLong( GetResString( IDS_WIDTH_TASKDAYS ), 10 )
#define WIDTH_TASKMONTHS		AsLong( GetResString( IDS_WIDTH_TASKMONTHS ), 10 )

#define WIDTH_TASKRUNASUSER		AsLong( GetResString( IDS_WIDTH_TASKRUNASUSER ), 10 )
#define WIDTH_TASKDELETE		AsLong( GetResString( IDS_WIDTH_TASKDELETE ), 10 )
#define WIDTH_TASKSTOP			AsLong( GetResString( IDS_WIDTH_TASKSTOP ), 10 )
#define WIDTH_TASK_RPTEVERY		AsLong( GetResString( IDS_WIDTH_TASK_RPTEVERY ), 10 )
#define WIDTH_TASK_UNTILRPTTIME	AsLong( GetResString( IDS_WIDTH_TASK_UNTILRPTTIME ), 10 )  
#define WIDTH_TASK_RPTDURATION	AsLong( GetResString( IDS_WIDTH_TASK_RPTDURATION ), 10 )
#define WIDTH_TASK_RPTRUNNING	AsLong( GetResString( IDS_WIDTH_TASK_RPTRUNNING ), 10 )

#define WIDTH_TASKIDLE		AsLong( GetResString( IDS_WIDTH_TASKIDLE ), 10 )
#define WIDTH_TASKPOWER		AsLong( GetResString( IDS_WIDTH_TASKPOWERMGMT ), 10 )

//constants of Task properties column numbers

#define HOSTNAME_COL_NUMBER						AsLong( GetResString( IDS_HOSTNAME_COL_NUMBER ), 10 )
#define TASKNAME_COL_NUMBER						AsLong( GetResString( IDS_TASKNAME_COL_NUMBER ), 10 )
#define NEXTRUNTIME_COL_NUMBER					AsLong( GetResString( IDS_NEXTRUNTIME_COL_NUMBER ), 10 )
#define LASTRUNTIME_COL_NUMBER					AsLong( GetResString( IDS_LASTRUNTIME_COL_NUMBER ), 10 )
#define STATUS_COL_NUMBER						AsLong( GetResString( IDS_STATUS_COL_NUMBER ), 10 )
#define LASTRESULT_COL_NUMBER					AsLong( GetResString( IDS_LASTRESULT_COL_NUMBER ), 10 )
#define CREATOR_COL_NUMBER						AsLong( GetResString( IDS_CREATOR_COL_NUMBER ), 10 )
#define SCHEDULE_COL_NUMBER						AsLong( GetResString( IDS_SCHEDULE_COL_NUMBER ), 10 )

#define TASKTORUN_COL_NUMBER					AsLong( GetResString( IDS_TASKTORUN_COL_NUMBER ), 10 )
#define STARTIN_COL_NUMBER						AsLong( GetResString( IDS_STARTIN_COL_NUMBER ), 10 )
#define COMMENT_COL_NUMBER						AsLong( GetResString( IDS_COMMENT_COL_NUMBER ), 10 )
#define TASKSTATE_COL_NUMBER					AsLong( GetResString( IDS_TASKSTATE_COL_NUMBER ), 10 )

#define TASKTYPE_COL_NUMBER						AsLong( GetResString( IDS_TASKTYPE_COL_NUMBER ), 10 )
#define STARTTIME_COL_NUMBER					AsLong( GetResString( IDS_STARTTIME_COL_NUMBER ), 10 )
#define STARTDATE_COL_NUMBER					AsLong( GetResString( IDS_STARTDATE_COL_NUMBER ), 10 )
#define ENDDATE_COL_NUMBER						AsLong( GetResString( IDS_ENDDATE_COL_NUMBER ), 10 )
#define DAYS_COL_NUMBER							AsLong( GetResString( IDS_DAYS_COL_NUMBER ), 10 )
#define MONTHS_COL_NUMBER						AsLong( GetResString( IDS_MONTHS_COL_NUMBER ), 10 )
#define RUNASUSER_COL_NUMBER					AsLong( GetResString( IDS_RUNASUSER_COL_NUMBER ), 10 )
#define DELETE_IFNOTRESCHEDULED_COL_NUMBER		AsLong( GetResString( IDS_DELETE_IFNOTRESCHEDULED_COL_NUMBER ), 10 )
#define STOPTASK_COL_NUMBER						AsLong( GetResString( IDS_STOPTASK_COL_NUMBER ), 10 )

#define REPEAT_EVERY_COL_NUMBER					AsLong( GetResString( IDS_REPEAT_EVERY_COL_NUMBER ), 10 )
#define REPEAT_UNTILTIME_COL_NUMBER				AsLong( GetResString( IDS_REPEAT_UNTILTIME_COL_NUMBER ), 10 )
#define REPEAT_DURATION_COL_NUMBER				AsLong( GetResString( IDS_REPEAT_DURATION_COL_NUMBER ), 10 )
#define REPEAT_STOP_COL_NUMBER					AsLong( GetResString( IDS_REPEAT_STOP_COL_NUMBER ), 10 )


#define IDLE_COL_NUMBER					AsLong( GetResString( IDS_IDLE_COL_NUMBER ), 10 )
#define POWER_COL_NUMBER				AsLong( GetResString( IDS_POWER_MGMT_COL_NUMBER ), 10 ) 

#define COL_FORMAT_STRING				_T("%s")
#define COL_FORMAT_HEX					_T("%d")
#define COL_SIZE_VERBOSE				3 //for Non-verbose mode only 3 columns
#define COL_SIZE_LIST					4 //for LIST non-verbose mode only 4 columns

#define TIME_DATE_SEPERATOR     _T(", ")
#define MAX_DATETIME_LEN 256
#define MAX_TIME_FORMAT_LEN 9
#define VARIABLE_ARGS 2 //for now 2 variable  arguments used in FormatMessage() API

//Constants used in GetTaskTime to identify the type of time needed

#define TASK_NEXT_RUNTIME     0x0 
#define TASK_LAST_RUNTIME     0x1
#define TASK_START_RUNTIME    0x2

// for -delete option
#define OI_DELSERVER			1 // Index of -s option in cmdOptions structure.
#define OI_DELTASKNAME			2 // Index of -f option in cmdOptions structure.
#define OI_DELFORCE				3 // Index of -f option in cmdOptions structure.
#define OI_DELUSERNAME			5 // Index of -u option in cmdOptions structure.
#define OI_DELPASSWORD			6 // Index of -p option in cmdOptions structure.

// for -query option
#define OI_QSERVER				1 // Index of -s option in cmdOptions structure.
#define OI_QFORMAT				2 // Index of -fo option in cmdOptions structure.
#define OI_QUSERNAME			6 // Index of -u option in cmdOptions structure.
#define OI_QPASSWORD			7 // Index of -p option in cmdOptions structure.


//TaskProperties structure
typedef struct _tagTaskProperties
{
	_TCHAR szTaskType[MAX_RES_STRING];
	_TCHAR szTaskEndDate[MAX_RES_STRING];
	_TCHAR szTaskDays[MAX_RES_STRING];
	_TCHAR szTaskMonths[MAX_RES_STRING];
	_TCHAR szTaskStartTime[MAX_DATETIME_LEN];
	_TCHAR szTaskStartDate[MAX_DATETIME_LEN];
	_TCHAR szRepeatEvery[MAX_DATETIME_LEN];
	_TCHAR szRepeatUntilTime[MAX_RES_STRING];
	_TCHAR szRepeatDuration[MAX_RES_STRING];
	_TCHAR szRepeatStop[MAX_RES_STRING];
	
}TASKPROPS;

//Function prototype declarations

VOID DisplayQueryUsage();
HRESULT	DisplayTasks(ITaskScheduler* pITS,BOOL bFilter,DWORD dwFormatType,BOOL bHeader);
HRESULT GetTaskRunTime(ITask* pITask,_TCHAR* pszRunTime,_TCHAR* pszRunDate,DWORD dwTimetype,
					   WORD wCurrentTrigger);
HRESULT GetApplicationToRun(ITask* pIT,_TCHAR* pszApplicationName);
HRESULT GetWorkingDirectory(ITask* pIT,_TCHAR* pszWorkingDirectory);
HRESULT GetComment(ITask* pIT,_TCHAR*  pwszComment);
HRESULT GetCreator(ITask* pITask,_TCHAR* pszCreator);
HRESULT GetTriggerString(ITask* pITask,_TCHAR* pszTrigger,WORD wCurrentTrigger);
HRESULT GetTaskState(ITask* pITask,_TCHAR* pszTaskState,DWORD dwFlag);
HRESULT GetRunAsUser(ITask* pIT,_TCHAR* pszRunAsUser);
HRESULT GetMaxRunTime(ITask* pIT,_TCHAR* pszMaxRunTime);
HRESULT GetTaskProps(ITask* pIT,TASKPROPS* pTaskProps,WORD wCurrentTrigger,_TCHAR* pszScName );
HRESULT GetStatusCode(ITask* pITask,_TCHAR* pszStatusCode);
VOID	CheckWeekDay(DWORD dwFlag,_TCHAR* pWeekDay);
VOID	CheckMonth(DWORD dwFlag,_TCHAR* pWhichMonth);
VOID	CheckWeek(DWORD dwFlag,_TCHAR* pWhichWeek);
LCID	GetSupportedUserLocale( BOOL& bLocaleChanged );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scheduledtasks\run.cpp ===
/******************************************************************************

	Copyright(c) Microsoft Corporation

	Module Name:

		run.cpp

	Abstract:

		This module runs the schedule task present in the system 

	Author:

		Venu Gopal Choudary 12-Mar-2001

	Revision History:
	
		Venu Gopal Choudary  12-Mar-2001 : Created it
		

******************************************************************************/ 


//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"


// Function declaration for the Usage function.
VOID DisplayRunUsage();

/*****************************************************************************

	Routine Description:

	This routine runs the scheduled task(s)

	Arguments:

		[ in ] argc :  Number of command line arguments
		[ in ] argv : Array containing command line arguments

	Return Value :
		A DWORD value indicating EXIT_SUCCESS on success else 
		EXIT_FAILURE on failure
  
*****************************************************************************/

DWORD
RunScheduledTask(  DWORD argc, LPCTSTR argv[] )
{
	// Variables used to find whether Run option, Usage option
	// are specified or not
	BOOL bRun = FALSE;
	BOOL bUsage = FALSE;

	// Set the TaskSchduler object as NULL
	ITaskScheduler *pITaskScheduler = NULL;
 
	// Return value
	HRESULT hr  = S_OK;
	
	// Initialising the variables that are passed to TCMDPARSER structure
	_TCHAR	szServer[ MAX_STRING_LENGTH ]   = NULL_STRING; 
    _TCHAR	szTaskName[ MAX_STRING_LENGTH ] = NULL_STRING;
    _TCHAR		szUser[ MAX_STRING_LENGTH ]   = NULL_STRING; 
    _TCHAR		szPassword[ MAX_STRING_LENGTH ] = NULL_STRING;

	// Declarations related to Task name
	WCHAR	wszJobName[MAX_TASKNAME_LEN] = NULL_U_STRING;
    
	// Dynamic Array contaning array of jobs
	TARRAY arrJobs = NULL;

	// Loop Variable.
	DWORD dwJobCount = 0;
	
	//buffer for displaying error message
	TCHAR	szMessage[MAX_STRING_LENGTH] = NULL_STRING;

	BOOL	bNeedPassword = FALSE;
	BOOL   bResult = FALSE;
	BOOL  bCloseConnection = TRUE;

	lstrcpy( szPassword, ASTERIX );

	// Builiding the TCMDPARSER structure
	TCMDPARSER cmdOptions[] = 
	{
		{ 
		  CMDOPTION_RUN,
		  CP_MAIN_OPTION,
		  1,
		  0,
		  &bRun,
		  NULL_STRING,
		  NULL,
		  NULL
		},
		{ 
		  SWITCH_SERVER,
		  CP_TYPE_TEXT | CP_VALUE_MANDATORY, 
		  1,
		  0,
		  &szServer,
		  NULL_STRING,
		  NULL, 
		  NULL
		},
		{ 
		  SWITCH_TASKNAME,
		  CP_TYPE_TEXT | CP_VALUE_MANDATORY | CP_MANDATORY ,
		  1,
		  0,
		  &szTaskName,
		  NULL_STRING,
		  NULL,
		  NULL
		},
		{ 
		  CMDOPTION_USAGE,
		  CP_USAGE ,
		  1,
		  0, 
		  &bUsage,
		  NULL_STRING, 
		  NULL, 
		  NULL
		 },
		 { 
			SWITCH_USER,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY,
			OPTION_COUNT,
			0,
			&szUser,
			NULL_STRING,
			NULL,
			NULL
		},
		{ 
			SWITCH_PASSWORD,
			CP_TYPE_TEXT | CP_VALUE_OPTIONAL,
			OPTION_COUNT,
			0,
			&szPassword,
			NULL_STRING,
			NULL,
			NULL
		}
	};	
	
	// Parsing the run option switches
	if ( DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions), cmdOptions ) == FALSE)
	{
		DISPLAY_MESSAGE( stderr, GetResString(IDS_LOGTYPE_ERROR ));
		DISPLAY_MESSAGE( stderr, GetReason() );
		//DISPLAY_MESSAGE(stderr, GetResString(IDS_RUN_SYNERROR));
		return EXIT_FAILURE;
	}

	// triming the null spaces
	StrTrim(szServer, TRIM_SPACES );
	StrTrim(szTaskName, TRIM_SPACES );

	// check whether password (-p) specified in the command line or not.
	if ( cmdOptions[OI_RUNPASSWORD].dwActuals == 0 )
	{
		lstrcpy( szPassword, NULL_STRING );
	}

	// Displaying run usage if user specified -? with -run option
	if( bUsage == TRUE )
	{
		DisplayRunUsage();
		return EXIT_SUCCESS;
	}

	// check for invalid server
	if( ( cmdOptions[OI_RUNSERVER].dwActuals == 1 ) &&  ( lstrlen( szServer ) == 0 ) )
	{
		DISPLAY_MESSAGE(stderr, GetResString(IDS_NO_SERVER));	
		return RETVAL_FAIL;
	}
	
	// check for invalid user name
	if( ( cmdOptions[OI_RUNSERVER].dwActuals == 0 ) && ( cmdOptions[OI_RUNUSERNAME].dwActuals == 1 )  )
	{
		DISPLAY_MESSAGE(stderr, GetResString(IDS_RUN_USER_BUT_NOMACHINE));	
		return RETVAL_FAIL;
	}
	
	// check for the length of user name
	if( ( cmdOptions[OI_RUNSERVER].dwActuals == 1 ) && ( cmdOptions[OI_RUNUSERNAME].dwActuals == 1 ) && 
				( lstrlen( szUser ) == 0 ) )
	{
		DISPLAY_MESSAGE(stderr, GetResString(IDS_INVALID_USERNAME));	
		return RETVAL_FAIL;
	}

	// check whether -ru is specified or not
	if ( cmdOptions[ OI_RUNUSERNAME ].dwActuals == 0 && 
				cmdOptions[ OI_RUNPASSWORD ].dwActuals == 1 ) 
	{
		// invalid syntax
		DISPLAY_MESSAGE(stderr, GetResString(IDS_RPASSWORD_BUT_NOUSERNAME));
		return RETVAL_FAIL;			
	}

	// check for the length of taskname
	if( ( lstrlen( szTaskName ) > MAX_JOB_LEN ) || ( lstrlen(szTaskName) == 0 ) )
	{
		DISPLAY_MESSAGE(stderr, GetResString( IDS_INVALID_TASKLENGTH ));
		return RETVAL_FAIL;
	}

	// check for the length of username
	if ( lstrlen( szUser ) > MAX_USERNAME_LENGTH ) 
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_UNAME));
		return RETVAL_FAIL;
	}

	// check for the length of password
	if ( lstrlen( szPassword ) > MAX_PASSWORD_LENGTH )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_PASSWORD));
		return RETVAL_FAIL;
	}

	// Convert the task name specified by the user to wide char or unicode format
	if ( GetAsUnicodeString(szTaskName,wszJobName,SIZE_OF_ARRAY(wszJobName)) == NULL )
	{
		return RETVAL_FAIL;
	}
	
	//for holding values of parameters in FormatMessage()
	_TCHAR* szValues[1] = {NULL};
	
	// check whether the password (-p) specified in the command line or not 
	// and also check whether '*' or empty is given for -p or not
	if( ( IsLocalSystem( szServer ) == FALSE ) && 
		( ( cmdOptions[OI_RUNPASSWORD].dwActuals == 0 ) || ( lstrcmpi ( szPassword, ASTERIX ) == 0 ) ) )
	{
		bNeedPassword = TRUE;
	}
		
	if( ( IsLocalSystem( szServer ) == FALSE ) || ( cmdOptions[OI_RUNUSERNAME].dwActuals == 1 ) )
	{
		// Establish the connection on a remote machine
		bResult = EstablishConnection(szServer,szUser,SIZE_OF_ARRAY(szUser),szPassword,SIZE_OF_ARRAY(szPassword), bNeedPassword );
		if (bResult == FALSE)
		{
			DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_STRING) );
			DISPLAY_MESSAGE( stderr, GetReason());
			return EXIT_FAILURE ;
		}
		else
		{
			// though the connection is successfull, some conflict might have occured
			switch( GetLastError() )
			{
			case I_NO_CLOSE_CONNECTION:
					bCloseConnection = FALSE;
					break;
			case E_LOCAL_CREDENTIALS:
			case ERROR_SESSION_CREDENTIAL_CONFLICT:
				{
					bCloseConnection = FALSE;
					DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_STRING) );
					DISPLAY_MESSAGE( stderr, GetReason());
					return EXIT_FAILURE;
				}
			}
		}
	}
	// Get the task Scheduler object for the machine.
	pITaskScheduler = GetTaskScheduler( szServer );

	// If the Task Scheduler is not defined then give the error message.
    if ( pITaskScheduler == NULL )
    {	
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
		return EXIT_FAILURE;
    }

	// Validate the Given Task and get as TARRAY in case of taskname 
	arrJobs = ValidateAndGetTasks( pITaskScheduler, szTaskName);
	if( arrJobs == NULL )
	{
		_stprintf( szMessage , GetResString(IDS_TASKNAME_NOTEXIST), szTaskName);	
		DISPLAY_MESSAGE(stderr, szMessage);	
		
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
				CloseConnection( szServer );

		Cleanup(pITaskScheduler);
		return EXIT_FAILURE;
		
	}

	IPersistFile *pIPF = NULL;
    ITask *pITask = NULL;

	// returns an pITask inteface for wszJobName
	hr = pITaskScheduler->Activate(wszJobName,IID_ITask,
									   (IUnknown**) &pITask);
 
	if (FAILED(hr))
    {
		DisplayErrorMsg(hr);

		if( pIPF )
			pIPF->Release();

		if( pITask )
			pITask->Release();
			
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
		
		return EXIT_FAILURE;
    }

	DWORD dwResult = 0;
	ULONG ulLong = MAX_RES_STRING;
	TCHAR szBuffer[MAX_STRING_LENGTH] = NULL_STRING;
	HRESULT phrStatus = S_OK;
	_TCHAR	szTaskProperty[MAX_STRING_LENGTH] = NULL_STRING;

	// get the status code
	hr = GetStatusCode(pITask,szTaskProperty);
	if (FAILED(hr))
	{	
		DisplayErrorMsg(hr);
	
		if( pIPF )
			pIPF->Release();

		if( pITask )
			pITask->Release();
			
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
	    return EXIT_FAILURE;
		
	}

	// check whether the task already been running or not
	if ( (lstrcmpi(szTaskProperty , GetResString(IDS_STATUS_RUNNING)) == 0 ))
	{
		szValues[0] = (_TCHAR*) (wszJobName);
		FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
				  GetResString(IDS_RUNNING_ALREADY),0,MAKELANGID(LANG_NEUTRAL,
			      SUBLANG_DEFAULT),szBuffer,
			      MAX_STRING_LENGTH,(va_list*)szValues
			     );
			
		DISPLAY_MESSAGE(stdout, szBuffer);

		if( pIPF )
			pIPF->Release();

		if( pITask )
			pITask->Release();
			
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
	    return EXIT_SUCCESS;
	}

	// run the scheduled task immediately
	hr = pITask->Run();

    if ( FAILED(hr) )
    {
		DisplayErrorMsg(hr);
	
		if( pIPF )
			pIPF->Release();

		if( pITask )
			pITask->Release();
		
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
	    return EXIT_FAILURE;
    }

	szValues[0] = (_TCHAR*) (wszJobName);
	FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
				  GetResString(IDS_RUN_SUCCESSFUL),0,MAKELANGID(LANG_NEUTRAL,
			      SUBLANG_DEFAULT),szBuffer,
			      MAX_STRING_LENGTH,(va_list*)szValues
			     );
			
	DISPLAY_MESSAGE(stdout,szBuffer);
		
	
	if( pIPF )
		pIPF->Release();

	if( pITask )
		pITask->Release();
			
	// close the connection that was established by the utility
	if ( bCloseConnection == TRUE )
		CloseConnection( szServer );

	Cleanup(pITaskScheduler);

	return EXIT_SUCCESS;
}

/*****************************************************************************

	Routine Description:

		This routine  displays the usage of -run option

	Arguments:
		None

	Return Value :
		VOID
******************************************************************************/

VOID
DisplayRunUsage()
{
	// Displaying run option usage
	DisplayUsage( IDS_RUN_HLP1, IDS_RUN_HLP16 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scheduledtasks\query.cpp ===
/******************************************************************************

	Copyright(c) Microsoft Corporation

	Module Name:

		query.cpp

	Abstract:

		This module queries the scheduled tasks present in the system & shows 
		in the appropriate user specifed format.

	Author:

		G.Surender Reddy  10-Sep-2000

	Revision History:

		G.Surender Reddy  10-Sep-2000 : Created it
		G.Surender Reddy  25-Sep-2000 : Modified it
										[ Made changes to avoid memory leaks ]
		G.Surender Reddy  15-oct-2000 : Modified it
									    [ Moved the strings to Resource table ]

******************************************************************************/ 


//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"

/******************************************************************************
	Routine Description:

		This function process the options specified in the command line ,
		Queries the tasks present in the system  and displays according 
		to the user specied format

	Arguments:

		[ in ] argc :	 The count of arguments specified in the command line
		[ in ] argv : Array of command line arguments

	Return Value :
		A DWORD value indicating EXIT_SUCCESS on success else 
		EXIT_FAILURE on failure
******************************************************************************/ 
 
DWORD
QueryScheduledTasks(  DWORD argc, LPCTSTR argv[] )
{

	// Variables used to find whether Query main option or Usage option
	// specified or not
	BOOL	bQuery = FALSE; 
	BOOL	bUsage = FALSE;
	BOOL	bHeader = FALSE;
	BOOL	bVerbose =  FALSE;
	
	// Initialising the variables that are passed to TCMDPARSER structure
	STRING100	szServer        = NULL_STRING; 
    STRING100	szFormat        = NULL_STRING;
	_TCHAR		szUser[ MAX_STRING_LENGTH ]   = NULL_STRING; 
    _TCHAR		szPassword[ MAX_STRING_LENGTH ] = NULL_STRING;

	//Taskscheduler object to operate upon
	ITaskScheduler *pITaskScheduler = NULL;

	BOOL	bNeedPassword = FALSE;
	BOOL   bResult = FALSE;
	BOOL  bCloseConnection = TRUE;

	lstrcpy( szPassword, ASTERIX );

	// Builiding the TCMDPARSER structure
	TCMDPARSER cmdOptions[] = {
		{ 
			CMDOPTION_QUERY,
			CP_MAIN_OPTION,
			0,
			0,
			&bQuery,
			NULL_STRING,
			NULL,
			NULL
		},
		{ 
			SWITCH_SERVER,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY,
			1,
			0,
			&szServer,
			NULL_STRING,
			NULL,
			NULL
		},
		
		{
			SWITCH_FORMAT,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY,
			1,
			0,
			&szFormat,
			NULL_STRING,
			NULL,
			NULL
		},
		{
			SWITCH_NOHEADER,
			1,
			1,
			0,
			&bHeader,
			NULL_STRING,
			NULL,
			NULL
		},
		{
			SWITCH_VERBOSE,
			1,
			1,
			0,
			&bVerbose,
			NULL_STRING,
			NULL,
			NULL
		},
		{
			CMDOPTION_USAGE,
			CP_USAGE ,
			CP_VALUE_MANDATORY,
			0,
			&bUsage,
			0,
			0 
		},
		 { 
			SWITCH_USER,
			CP_TYPE_TEXT | CP_VALUE_MANDATORY,
			OPTION_COUNT,
			0,
			&szUser,
			NULL_STRING,
			NULL,
			NULL
		},
		{ 
			SWITCH_PASSWORD,
			CP_TYPE_TEXT | CP_VALUE_OPTIONAL,
			OPTION_COUNT,
			0,
			&szPassword,
			NULL_STRING,
			NULL,
			NULL
		}
	};
	
	// Parsing the query option switches
 	if (DoParseParam( argc, argv,SIZE_OF_ARRAY(cmdOptions), cmdOptions ) == FALSE)
	{
		DISPLAY_MESSAGE( stderr, GetResString(IDS_LOGTYPE_ERROR ));
		DISPLAY_MESSAGE( stderr, GetReason() );
		//DISPLAY_MESSAGE(stdout,GetResString(IDS_QUERY_USAGE));
		return EXIT_FAILURE;
	}

	// triming the null spaces
	StrTrim(szServer, TRIM_SPACES );
	StrTrim(szFormat, TRIM_SPACES );

	// check whether password (-p) specified in the command line or not.
	if ( cmdOptions[OI_QPASSWORD].dwActuals == 0 )
	{
		lstrcpy( szPassword, NULL_STRING );
	}

	// Displaying query usage if user specified -? with -query option
	if( bUsage == TRUE)
	{
		DisplayQueryUsage();
		return EXIT_SUCCESS;
	}

	// check for -s option 
	if( ( cmdOptions[OI_QSERVER].dwActuals == 1 ) && 
		( ( lstrlen( szServer ) == 0 ) ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_SERVER));	
		return RETVAL_FAIL;
	}

	// check for -fo option 
	if ( ( cmdOptions[OI_QFORMAT].dwActuals == 1 ) &&
		 ( lstrlen ( szFormat ) == 0 ) )
	{
		//wrong format type
		DISPLAY_MESSAGE( stderr , GetResString(IDS_QUERY_FORMAT_ERR ));
		return EXIT_FAILURE; 
	}

	if ( cmdOptions[ OI_QUSERNAME ].dwActuals == 0 && cmdOptions[OI_QPASSWORD].dwActuals == 1 ) 
	{
		// invalid syntax
		DISPLAY_MESSAGE(stderr, GetResString(IDS_QPASSWORD_BUT_NOUSERNAME));
		return RETVAL_FAIL;			
	}

	// check for the length of username
	if( lstrlen( szUser ) > MAX_USERNAME_LENGTH ) 
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_UNAME));
		return RETVAL_FAIL;
	}

	// check for invalid user name
	if( ( cmdOptions[OI_QSERVER].dwActuals == 0 ) && ( cmdOptions[OI_QUSERNAME].dwActuals == 1 )  )
	{
		DISPLAY_MESSAGE(stderr, GetResString(IDS_QUERY_USER_BUT_NOMACHINE));	
		return RETVAL_FAIL;
	}
	
	// check for the length of user name
	if( ( cmdOptions[OI_QSERVER].dwActuals == 1 ) && ( cmdOptions[OI_QUSERNAME].dwActuals == 1 ) && 
				( lstrlen( szUser ) == 0 ) )
	{
		DISPLAY_MESSAGE(stderr, GetResString(IDS_INVALID_USERNAME));	
		return RETVAL_FAIL;
	}

	// check for the length of password
	if( lstrlen( szPassword ) > MAX_PASSWORD_LENGTH )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_PASSWORD));
		return RETVAL_FAIL;
	}

	// check whether the password (-p) specified in the command line or not 
	// and also check whether '*' or empty is given for -p or not
	if( ( IsLocalSystem( szServer ) == FALSE ) 
		&& ( ( cmdOptions[OI_QPASSWORD].dwActuals == 0 ) || ( lstrcmpi ( szPassword, ASTERIX ) == 0 ) ) )
	{
		bNeedPassword = TRUE;
	}
		
	DWORD dwFormatType = SR_FORMAT_TABLE;//default format type(TABLE Format)
	BOOL bNoHeader = TRUE; // For  LIST  format type -nh switch is not applicable

	//Determine the Format for display & check for error if any in format type
		
	if( lstrcmpi( szFormat , GetResString(IDS_QUERY_FORMAT_LIST) ) == 0 )
	{
		dwFormatType = SR_FORMAT_LIST;
		bNoHeader = FALSE;
	}
	else if( lstrcmpi( szFormat , GetResString(IDS_QUERY_FORMAT_CSV) ) == 0 )
	{
		dwFormatType = SR_FORMAT_CSV;
	}
	else
	{	
		if( ( lstrlen( szFormat ) ) &&
			( lstrcmpi( szFormat , GetResString(IDS_QUERY_FORMAT_TABLE) ) != 0 ) )
		{
			//wrong format type
			DISPLAY_MESSAGE( stderr , GetResString(IDS_QUERY_FORMAT_ERR ));
			return EXIT_FAILURE; 
		}

	}

	//If -n is specified for LIST or CSV then report error
	if( ( bNoHeader == FALSE ) && ( bHeader == TRUE ))
	{
		DISPLAY_MESSAGE( stderr , GetResString(IDS_NOHEADER_NA ));
		return EXIT_FAILURE;
	}

	if( ( IsLocalSystem( szServer ) == FALSE ) || ( cmdOptions[OI_QUSERNAME].dwActuals == 1 ) )
	{
		// Establish the connection on a remote machine
		bResult = EstablishConnection(szServer,szUser,SIZE_OF_ARRAY(szUser),szPassword,SIZE_OF_ARRAY(szPassword), bNeedPassword );
		if (bResult == FALSE)
		{
			DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_STRING) );
			DISPLAY_MESSAGE( stderr, GetReason());
			return EXIT_FAILURE ;
		}
		else
		{
			// though the connection is successfull, some conflict might have occured
			switch( GetLastError() )
			{
			case I_NO_CLOSE_CONNECTION:
					bCloseConnection = FALSE;
					break;

			case E_LOCAL_CREDENTIALS:
			case ERROR_SESSION_CREDENTIAL_CONFLICT:
				{
					bCloseConnection = FALSE;
					DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_STRING) );
					DISPLAY_MESSAGE( stderr, GetReason());
					return EXIT_FAILURE;
				}
			}
		}
	
	}
	
	//Fetch the TaskScheduler Interface to operate on	
	pITaskScheduler = GetTaskScheduler( szServer );
	if(pITaskScheduler == NULL)
	{
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
		return EXIT_FAILURE;
	}

	//Display the tasks & its properties in the user specified format
	HRESULT hr = DisplayTasks(pITaskScheduler,bVerbose,dwFormatType,bHeader);

	if(FAILED(hr))
	{	
		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( szServer );

		Cleanup(pITaskScheduler);
		return EXIT_FAILURE;
	}
  
	// close the connection that was established by the utility
	if ( bCloseConnection == TRUE )
		CloseConnection( szServer );

	Cleanup(pITaskScheduler);
 	return EXIT_SUCCESS;
}


/******************************************************************************
	Routine Description:

		This function displays the usage of -query option.

	Arguments:

		None

	Return Value :

		VOID
******************************************************************************/ 

VOID
DisplayQueryUsage()
{
	// Display the usage of -query option
	DisplayUsage( IDS_QUERY_HLP1, IDS_QUERY_HLP25);
}

                
/******************************************************************************
	Routine Description:

		This function retrieves the tasks present in the system & displays according to 
		the user specified format.

	Arguments:

		[ in ] pITaskScheduler : Pointer to the ITaskScheduler Interface

		[ in ] bVerbose		 : flag indicating whether the out is to be filtered.
		[ in ] dwFormatType	 : Format type[TABLE,LIST,CSV etc]
		[ in ] bHeader		 : Whether the header should be displayed in the output	

	Return Value :
		A HRESULT  value indicating success code else failure code
  
******************************************************************************/ 

HRESULT
DisplayTasks(ITaskScheduler* pITaskScheduler,BOOL bVerbose,DWORD dwFormatType,
			 BOOL bHeader)
{
	//declarations
	LPWSTR lpwszComputerName = NULL;
	HRESULT hr = S_OK;
	STRING256 szServerName = NULL_STRING;
	STRING256 szResolvedServerName = NULL_STRING;
	LPTSTR lpszTemp = NULL;
	
	lstrcpy( szServerName , GetResString(IDS_TASK_PROPERTY_NA));

	//Retrieve the name of the computer on which TaskScheduler is operated
	hr = pITaskScheduler->GetTargetComputer(&lpwszComputerName);
	if( SUCCEEDED( hr ) )
	{
		lpszTemp = lpwszComputerName;
		//Remove the backslash[\\] from the computer name
		lpwszComputerName = _wcsspnp( lpwszComputerName , L"\\" ); 
		if ( lpwszComputerName == NULL )
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_CREATE_READERROR));
			CoTaskMemFree(lpszTemp);	
			return S_FALSE;
		}
		
		if (GetCompatibleStringFromUnicode( lpwszComputerName,szServerName,
								    	SIZE_OF_ARRAY(szServerName) ) == NULL )
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_CREATE_READERROR));
			CoTaskMemFree(lpszTemp);	
			return S_FALSE;
		}

		CoTaskMemFree(lpszTemp);

		if ( IsValidIPAddress( szServerName ) == TRUE  )
		{
		
			if( TRUE == GetHostByIPAddr( szServerName, szResolvedServerName , FALSE ) )
			{
				lstrcpy( szServerName , szResolvedServerName );
			}
			else
			{
				lstrcpy( szServerName , GetResString(IDS_TASK_PROPERTY_NA));
			}

		}
	}


	//Initialize the TCOLUMNS structure array

	TCOLUMNS pVerboseCols[] = 
	{
		{NULL_STRING,WIDTH_HOSTNAME, SR_TYPE_STRING, COL_FORMAT_STRING, NULL, NULL},
		{NULL_STRING,WIDTH_TASKNAME,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_NEXTRUNTIME,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_STATUS,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_LASTRUNTIME,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_LASTRESULT,SR_TYPE_NUMERIC|SR_VALUEFORMAT,COL_FORMAT_HEX,NULL,NULL},
		{NULL_STRING,WIDTH_CREATOR,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_SCHEDULE,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_APPNAME,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_WORKDIRECTORY,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_COMMENT,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_TASKSTATE,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_TASKTYPE,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_TASKSTIME,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_TASKSDATE,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_TASKEDATE,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_TASKDAYS,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_TASKMONTHS,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_TASKRUNASUSER,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_TASKDELETE,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_TASKSTOP,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_TASK_RPTEVERY,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_TASK_UNTILRPTTIME,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_TASK_RPTDURATION,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_TASK_RPTRUNNING,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_TASKIDLE,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_TASKPOWER,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL}

	};

	TCOLUMNS pNonVerboseCols[] = 
	{
		{NULL_STRING,WIDTH_TASKNAME,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_NEXTRUNTIME,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL},
		{NULL_STRING,WIDTH_STATUS,SR_TYPE_STRING,COL_FORMAT_STRING,NULL,NULL}
	};

	DWORD dwColCount = 0;
	int   j = 0;
	int   k = 0;

	//Load the column names for non verbose mode
	if ( (dwFormatType == SR_FORMAT_TABLE) || (dwFormatType == SR_FORMAT_CSV) )
	{
		for( dwColCount = IDS_COL_TASKNAME , j = 0 ; dwColCount <= IDS_COL_STATUS;
		 dwColCount++,j++)
		 {
			lstrcpy(pNonVerboseCols[j].szColumn ,GetResString(dwColCount)); 
		 }
	}
	
	//Load the column names for verbose mode
	for( dwColCount = IDS_COL_HOSTNAME , j = 0 ; dwColCount <= IDS_COL_POWER;
		 dwColCount++,j++)
	{
		lstrcpy(pVerboseCols[j].szColumn ,GetResString(dwColCount)); 
	}

	TARRAY pColData = CreateDynamicArray();
	size_t iArrSize = SIZE_OF_ARRAY( pVerboseCols );


	//latest declarations
		
	_TCHAR	szTaskProperty[MAX_STRING_LENGTH] = NULL_STRING;
	_TCHAR	szScheduleName[MAX_STRING_LENGTH] = NULL_STRING;
	_TCHAR	szMessage[MAX_STRING_LENGTH] = NULL_STRING;
	_TCHAR	szBuffer[MAX_STRING_LENGTH] = NULL_STRING;
	_TCHAR	szTmpBuf[MAX_STRING_LENGTH] = NULL_STRING;
	ITask *pITask = NULL;//ITask interface
	DWORD dwExitCode = 0;

	LPWSTR* lpwszNames = NULL;
	DWORD dwFetchedTasks = 0;
	LPTSTR lpStatus = NULL;
	int iTaskCount = 0;
	BOOL bTasksExists = FALSE;
	_TCHAR szTime[MAX_DATETIME_LEN] = NULL_STRING;
	_TCHAR szDate[MAX_DATETIME_LEN] = NULL_STRING;

	//Index to the array of task names
	DWORD dwArrTaskIndex = 0;

	WORD wIdleMinutes = 0;
	WORD wDeadlineMinutes = 0 ;

	STRING100 szIdleTime = NULL_STRING;
	STRING100 szIdleRetryTime = NULL_STRING;
	STRING256 szTaskName = NULL_STRING;
	TASKPROPS tcTaskProperties; 
	_TCHAR* szValues[1] = {NULL};//for holding values of parameters in FormatMessage()
	BOOL    bOnBattery  = FALSE;
	BOOL    bStopTask  = FALSE;
	BOOL    bNotScheduled = FALSE;

	IEnumWorkItems *pIEnum = NULL;
	hr = pITaskScheduler->Enum(&pIEnum);//Get the IEnumWorkItems Interface

	if (FAILED(hr))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_CREATE_READERROR));
		if( pIEnum )
			pIEnum->Release();
		return hr;
	}

	while (SUCCEEDED(pIEnum->Next(TASKS_TO_RETRIEVE,
									&lpwszNames,
									&dwFetchedTasks))
					  && (dwFetchedTasks != 0))
	{
		bTasksExists = TRUE;
		dwArrTaskIndex  = dwFetchedTasks - 1;

		if ( GetCompatibleStringFromUnicode(lpwszNames[dwArrTaskIndex],szTaskName,
									   SIZE_OF_ARRAY(szTaskName)) == NULL )
		{
			CoTaskMemFree(lpwszNames[dwArrTaskIndex]);
			if(pIEnum)
			{
				pIEnum->Release();
			}

			if(pITask)
			{
				pITask->Release();
			}
			return S_FALSE;
		}

		if(szTaskName != NULL)
		{
			//remove the .job extension from the task name
			if (ParseTaskName(szTaskName))
			{
				CoTaskMemFree(lpwszNames[dwArrTaskIndex]);
				if(pIEnum)
					pIEnum->Release();

				if(pITask)
					pITask->Release();
				return S_FALSE;
			}
		}

		// return an pITask inteface for wszJobName
		hr = pITaskScheduler->Activate(lpwszNames[dwArrTaskIndex],IID_ITask,
									   (IUnknown**) &pITask);

  		if ( ( FAILED(hr) ) || (pITask == NULL) )
		{	
			DisplayErrorMsg(hr);
			CoTaskMemFree(lpwszNames[dwArrTaskIndex]);
			if(pIEnum)
				pIEnum->Release();

			if(pITask)
				pITask->Release();
			return hr;
		}

		WORD wTriggerCount = 0;
		BOOL bMultiTriggers = FALSE;

		hr = pITask->GetTriggerCount( &wTriggerCount );

		// check for multiple triggers
		if( wTriggerCount > 1) 
		{
			bMultiTriggers = TRUE;
		}
		
		// check for not scheduled tasks
		if ( wTriggerCount == 0 )
		{
			bNotScheduled = TRUE;
		}

		for( WORD wCurrentTrigger = 0; ( bNotScheduled == TRUE ) || ( wCurrentTrigger < wTriggerCount );
													wCurrentTrigger++ )
		{
			//Start appending to the 2D array
			DynArrayAppendRow(pColData,iArrSize);

			// For LIST format
			if ( ( bVerbose == TRUE ) || (dwFormatType == SR_FORMAT_LIST )) 
			{
				//Insert the server name
				DynArraySetString2(pColData,iTaskCount,HOSTNAME_COL_NUMBER,szServerName,0);
			}

			// For TABLE and CSV formats
			if ( ( bVerbose == FALSE ) && ( (dwFormatType == SR_FORMAT_TABLE) || 
									(dwFormatType == SR_FORMAT_CSV) ) )
			{
				DWORD dwTaskColNumber = TASKNAME_COL_NUMBER - 1;
				//Insert the task name for TABLE or CSV
			    DynArraySetString2(pColData,iTaskCount,dwTaskColNumber,szTaskName,0);
			}
			else
			{
			//Insert the task name for verbose mode
			DynArraySetString2(pColData,iTaskCount,TASKNAME_COL_NUMBER,szTaskName,0);
			}

			lstrcpy(szTime,NULL_STRING);
			lstrcpy(szDate,NULL_STRING);

			//find the next run time of the task						
			hr = GetTaskRunTime(pITask,szTime,szDate,TASK_NEXT_RUNTIME,wCurrentTrigger);
			if (FAILED(hr))
			{	
				lstrcpy( szTaskProperty , GetResString(IDS_TASK_NEVER) );
			}
			else
			{
				if(lstrcmpi( szDate , GetResString( IDS_TASK_IDLE ) ) == 0 ||
				   lstrcmpi( szDate , GetResString( IDS_TASK_SYSSTART )) == 0 ||
				   lstrcmpi( szDate , GetResString( IDS_TASK_LOGON )) == 0 ||
				   lstrcmpi( szDate , GetResString( IDS_TASK_NEVER )) == 0 )	
				  
				{
					lstrcpy( szTaskProperty , szDate );
				}
				else
				{
					lstrcpy( szTaskProperty , szTime );
					lstrcat( szTaskProperty , TIME_DATE_SEPERATOR);
					lstrcat( szTaskProperty , szDate);
				}
			}

			if ( ( bVerbose == FALSE ) && ( (dwFormatType == SR_FORMAT_TABLE) || 
										(dwFormatType == SR_FORMAT_CSV) ) )
			{
				DWORD dwNextRunTime = NEXTRUNTIME_COL_NUMBER - 1;
				//Insert the task name for TABLE or CSV
			    DynArraySetString2(pColData,iTaskCount,dwNextRunTime,szTaskProperty,0);
			}
			else
			{
			//Insert the Next run time of the task
			DynArraySetString2(pColData,iTaskCount,NEXTRUNTIME_COL_NUMBER,szTaskProperty,0);
			}

			//retrieve the status code
			hr = GetStatusCode(pITask,szTaskProperty);
			if (FAILED(hr))
			{	
				lstrcpy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA) );
			}

			if ( ( bVerbose == FALSE ) && ( (dwFormatType == SR_FORMAT_TABLE) || 
										(dwFormatType == SR_FORMAT_CSV) ) )
			{
				DWORD dwStatusColNum = STATUS_COL_NUMBER - 1;
				//Insert the task name for TABLE or CSV
				DynArraySetString2(pColData,iTaskCount,dwStatusColNum,szTaskProperty,0);
			}
			else
			{
			//Insert the status string
			DynArraySetString2(pColData,iTaskCount,STATUS_COL_NUMBER,szTaskProperty,0);
			}

			if( bVerbose) //If V [verbose mode is present ,show all other columns]
			{
				lstrcpy(szTime,NULL_STRING);
				lstrcpy(szDate,NULL_STRING);
				
				//Insert the server name
				//DynArraySetString2(pColData,iTaskCount,HOSTNAME_COL_NUMBER,szServerName,0);

				//find the last run time of the task						
				hr = GetTaskRunTime(pITask,szTime,szDate,TASK_LAST_RUNTIME,wCurrentTrigger);
				if (FAILED(hr))
				{	
					lstrcpy( szTaskProperty , GetResString(IDS_TASK_NEVER) );
				}
				else
				{	
					if(lstrcmpi( szDate , GetResString( IDS_TASK_IDLE ) ) == 0 ||
					   lstrcmpi( szDate , GetResString( IDS_TASK_SYSSTART )) == 0 ||
					   lstrcmpi( szDate , GetResString( IDS_TASK_LOGON )) == 0 ||
					   lstrcmpi( szDate , GetResString( IDS_TASK_NEVER )) == 0 )
					{
						lstrcpy( szTaskProperty , szDate );
					}
					else
					{
						lstrcpy( szTaskProperty , szTime );
						lstrcat( szTaskProperty , TIME_DATE_SEPERATOR);
						lstrcat( szTaskProperty , szDate);
					}
				}
				//Insert the task last run time
				DynArraySetString2(pColData,iTaskCount,LASTRUNTIME_COL_NUMBER,szTaskProperty,0);
				
				//retrieve the exit code
				 pITask->GetExitCode(&dwExitCode);
				
				//Insert the Exit code
				DynArraySetDWORD2(pColData,iTaskCount,LASTRESULT_COL_NUMBER,dwExitCode);
				
				// Get the creator name for the task			
				hr = GetCreator(pITask,szTaskProperty);
				if (FAILED(hr))
				{
					lstrcpy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA) );
				}

				if( lstrcmpi( szTaskProperty , NULL_STRING ) == 0 )
						lstrcpy( szTaskProperty , GetResString(IDS_QUERY_NA) );	
				
				//insert the creator name to 2D array
				DynArraySetString2(pColData,iTaskCount,CREATOR_COL_NUMBER,szTaskProperty,0);

				//retrieve the Trigger string
				hr = GetTriggerString(pITask,szTaskProperty,wCurrentTrigger);
				if (FAILED(hr))
				{
					lstrcpy( szTaskProperty , GetResString(IDS_NOTSCHEDULED_TASK) );
				}
				
				lstrcpy(szScheduleName, szTaskProperty);
					//Insert the trigger string
				DynArraySetString2(pColData,iTaskCount,SCHEDULE_COL_NUMBER,szTaskProperty,0);
				
				
				//Get the application path associated with the task
				hr = GetApplicationToRun(pITask,szTaskProperty);
				if (FAILED(hr))
				{
					lstrcpy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA) );
				}

				if( lstrcmpi( szTaskProperty , NULL_STRING ) == 0 )
					lstrcpy( szTaskProperty , GetResString(IDS_QUERY_NA) );	
				
				//Insert the application associated with task
				DynArraySetString2(pColData,iTaskCount,TASKTORUN_COL_NUMBER,szTaskProperty,0);

				//Get the working directory	of the task's associated application	
				 hr = GetWorkingDirectory(pITask,szTaskProperty);
				 if (FAILED(hr))
				 {
					lstrcpy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA) );
				 }

				 if( lstrcmpi( szTaskProperty , NULL_STRING ) == 0 )
					lstrcpy( szTaskProperty , GetResString(IDS_QUERY_NA) );	

				 //Insert the app.working directory
				 DynArraySetString2(pColData,iTaskCount,STARTIN_COL_NUMBER,szTaskProperty,0);
				

				//Get the comment name associated with the task
				hr = GetComment(pITask,szTaskProperty);
				if (FAILED(hr))
				{
					lstrcpy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA) );
				}
				//Insert the comment name

				if( lstrcmpi( szTaskProperty , NULL_STRING ) == 0 )
					lstrcpy( szTaskProperty , GetResString(IDS_QUERY_NA) );	
				
				DynArraySetString2(pColData,iTaskCount,COMMENT_COL_NUMBER,szTaskProperty,0);

				//Determine the task state properties

				//Determine the TASK_FLAG_DISABLED				
				hr = GetTaskState(pITask,szTaskProperty,TASK_FLAG_DISABLED);
				if (FAILED(hr))
				{	
					lstrcpy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA) );
				}

				//Insert the TASK_FLAG_DISABLED	state			
				DynArraySetString2(pColData,iTaskCount,TASKSTATE_COL_NUMBER,szTaskProperty,0);

				//Determine the TASK_FLAG_DELETE_WHEN_DONE				
				hr = GetTaskState(pITask,szTaskProperty,TASK_FLAG_DELETE_WHEN_DONE );
				if (FAILED(hr))
				{	
					lstrcpy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA) );
				}

				//Insert the TASK_FLAG_DELETE_WHEN_DONE	state	
				DynArraySetString2(pColData,iTaskCount,DELETE_IFNOTRESCHEDULED_COL_NUMBER,
								szTaskProperty,0);

				//TASK_FLAG_START_ONLY_IF_IDLE
				//initialise to neutral values
				lstrcpy(szIdleTime,GetResString(IDS_TASK_PROPERTY_DISABLED));
				lstrcpy(szIdleRetryTime,szIdleTime);

				hr = GetTaskState(pITask,szTaskProperty,TASK_FLAG_START_ONLY_IF_IDLE);
				if (FAILED(hr))
				{	
					lstrcpy( szIdleTime , GetResString(IDS_TASK_PROPERTY_NA) );
					lstrcpy( szIdleRetryTime , GetResString(IDS_TASK_PROPERTY_NA) );
				}
				 
				if(lstrcmpi(szTaskProperty,GetResString(IDS_TASK_PROPERTY_ENABLED)) == 0 )
				{ 									
					//Display the rest applicable Idle fields
					hr = pITask->GetIdleWait(&wIdleMinutes,&wDeadlineMinutes);
									
					if ( SUCCEEDED(hr))
					{
						FORMAT_STRING(szIdleTime,_T("%d"),wIdleMinutes);
						FORMAT_STRING(szIdleRetryTime,_T("%d"),wDeadlineMinutes);
					}
				
					szValues[0] = (_TCHAR*) szIdleTime;
					FormatMessage( FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
						  GetResString(IDS_COL_IDLE_ONLYSTART),0,MAKELANGID(LANG_NEUTRAL,
						  SUBLANG_DEFAULT),szMessage,
						  MAX_STRING_LENGTH,(va_list*)szValues
					  );
					
					lstrcpy( szBuffer, szMessage );
					lstrcat( szBuffer, TIME_DATE_SEPERATOR );
					
					szValues[0] = (_TCHAR*) szIdleRetryTime;
					FormatMessage( FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
						  GetResString(IDS_COL_IDLE_NOTIDLE),0,MAKELANGID(LANG_NEUTRAL,
						  SUBLANG_DEFAULT),szMessage,
						  MAX_STRING_LENGTH,(va_list*)szValues
					  );

					lstrcat( szBuffer, szMessage );

					//Get the property of ( kill task if computer goes idle)
					hr = GetTaskState(pITask,szTaskProperty,TASK_FLAG_KILL_ON_IDLE_END );
					if (FAILED(hr))
					{	
						lstrcpy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA) );
					}

					if(lstrcmpi(szTaskProperty,GetResString(IDS_TASK_PROPERTY_ENABLED)) == 0 )
					{
						lstrcat( szBuffer, TIME_DATE_SEPERATOR );
						lstrcat( szBuffer, GetResString ( IDS_COL_IDLE_STOPTASK ) );
					}

					//Insert the property of ( kill task if computer goes idle)
					DynArraySetString2(pColData,iTaskCount,IDLE_COL_NUMBER,szBuffer,0);

				}
				else
				{
					DynArraySetString2(pColData,iTaskCount,IDLE_COL_NUMBER,szTaskProperty,0);
				}

				
				//Get the Power mgmt.properties
				hr = GetTaskState(pITask,szTaskProperty,TASK_FLAG_DONT_START_IF_ON_BATTERIES );
				if (FAILED(hr))
				{	
					lstrcpy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA) );
				}

				if(lstrcmpi(szTaskProperty,GetResString(IDS_TASK_PROPERTY_ENABLED)) ==0 )
				{
					lstrcpy(szBuffer, GetResString (IDS_COL_POWER_NOSTART));
					bOnBattery = TRUE;
				}
	
				hr = GetTaskState(pITask,szTaskProperty,TASK_FLAG_KILL_IF_GOING_ON_BATTERIES);
				if (FAILED(hr))
				{	
					lstrcpy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA) );
				}
			
				if(lstrcmpi(szTaskProperty,GetResString(IDS_TASK_PROPERTY_ENABLED)) ==0 )
				{
					lstrcpy( szMessage, GetResString (IDS_COL_POWER_STOP));
					bStopTask = TRUE;
				}

				if ( ( bOnBattery == TRUE ) && ( bStopTask == TRUE ) )
				{
					lstrcpy(szTmpBuf, szBuffer);
					lstrcat( szTmpBuf, TIME_DATE_SEPERATOR );
					lstrcat( szTmpBuf, szMessage );
				}
				else if ( ( bOnBattery == FALSE ) && ( bStopTask == TRUE ) )
				{
					lstrcpy( szTmpBuf, szMessage );
				}
				else if ( ( bOnBattery == TRUE ) && ( bStopTask == FALSE ) )
				{
					lstrcpy( szTmpBuf, szBuffer );
				}

				
				if( ( bOnBattery == FALSE )  && ( bStopTask == FALSE ) )
				{
				DynArraySetString2(pColData,iTaskCount,POWER_COL_NUMBER,szTaskProperty,0);
				}
				else
				{
				DynArraySetString2(pColData,iTaskCount,POWER_COL_NUMBER,szTmpBuf,0);
				}
				

				//Get RunAsUser
				hr = GetRunAsUser(pITask, szTaskProperty);
				if (FAILED(hr))
				{
					lstrcpy( szTaskProperty , GetResString(IDS_USER_UNKNOWN) );
				}

				if( lstrcmpi( szTaskProperty , NULL_STRING ) == 0 )
					lstrcpy( szTaskProperty ,  NTAUTHORITY_USER );	


				DynArraySetString2(pColData,iTaskCount,RUNASUSER_COL_NUMBER,szTaskProperty,0);
				
				lstrcpy( szTaskProperty , NULL_STRING );
				//Get the task's maximum run time & insert in the 2D array
				hr = GetMaxRunTime(pITask,szTaskProperty);
				if (FAILED(hr))
				{
					lstrcpy( szTaskProperty , GetResString(IDS_TASK_PROPERTY_NA) );
				}

				DynArraySetString2(pColData,iTaskCount,STOPTASK_COL_NUMBER,szTaskProperty,0);

				hr = GetTaskProps(pITask,&tcTaskProperties,wCurrentTrigger, szScheduleName);
				if (FAILED(hr))
				{
					lstrcpy( tcTaskProperties.szTaskType , GetResString(IDS_TASK_PROPERTY_NA) );
					lstrcpy( tcTaskProperties.szTaskStartTime , GetResString(IDS_TASK_PROPERTY_NA) );
					lstrcpy( tcTaskProperties.szTaskEndDate , GetResString(IDS_TASK_PROPERTY_NA) );
					lstrcpy( tcTaskProperties.szTaskDays , GetResString(IDS_TASK_PROPERTY_NA) );
					lstrcpy( tcTaskProperties.szTaskMonths , GetResString(IDS_TASK_PROPERTY_NA) );
					lstrcpy( tcTaskProperties.szRepeatEvery , GetResString(IDS_TASK_PROPERTY_NA) );
					lstrcpy( tcTaskProperties.szRepeatUntilTime , GetResString(IDS_TASK_PROPERTY_NA) );
					lstrcpy( tcTaskProperties.szRepeatDuration , GetResString(IDS_TASK_PROPERTY_NA) );
					lstrcpy( tcTaskProperties.szRepeatStop , GetResString(IDS_TASK_PROPERTY_NA) );
								
				}


				//Insert Task Type
				DynArraySetString2(pColData,iTaskCount,TASKTYPE_COL_NUMBER,
								   tcTaskProperties.szTaskType, 0);
				//Insert start time
				DynArraySetString2(pColData,iTaskCount,STARTTIME_COL_NUMBER,
								   tcTaskProperties.szTaskStartTime, 0);

				//Insert start Date
				DynArraySetString2(pColData,iTaskCount,STARTDATE_COL_NUMBER,
								   tcTaskProperties.szTaskStartDate, 0);
				//Insert Task idle time
				if( lstrcmpi( tcTaskProperties.szTaskType , GetResString(IDS_TASK_IDLE) ) == 0 )
				{
					hr = pITask->GetIdleWait(&wIdleMinutes,&wDeadlineMinutes);
					if ( SUCCEEDED(hr))
					{
						FORMAT_STRING(szIdleTime,_T("%d"),wIdleMinutes);
					}
					else
					{
						lstrcpy( szIdleTime,  GetResString(IDS_TASK_PROPERTY_NA) );
					
					}
				}

		
				//Insert Task End date
				DynArraySetString2(pColData,iTaskCount,ENDDATE_COL_NUMBER,
								   tcTaskProperties.szTaskEndDate, 0);
				//Insert days value
				DynArraySetString2(pColData,iTaskCount,DAYS_COL_NUMBER,
								   tcTaskProperties.szTaskDays,0);
				//Insert months value
				DynArraySetString2(pColData,iTaskCount,MONTHS_COL_NUMBER,
								   tcTaskProperties.szTaskMonths,	0);
			
				//Insert repeat every time
				DynArraySetString2(pColData,iTaskCount, REPEAT_EVERY_COL_NUMBER ,
								   tcTaskProperties.szRepeatEvery,0);

				//Insert repeat until time
				DynArraySetString2(pColData,iTaskCount,REPEAT_UNTILTIME_COL_NUMBER,
								   tcTaskProperties.szRepeatUntilTime,0);

				//Insert repeat duration
				DynArraySetString2(pColData,iTaskCount,REPEAT_DURATION_COL_NUMBER,
								   tcTaskProperties.szRepeatDuration,0);

				//Insert repeat stop if running
				DynArraySetString2(pColData,iTaskCount,REPEAT_STOP_COL_NUMBER,
								   tcTaskProperties.szRepeatStop,0);
				

			}//end of bVerbose
			if( bMultiTriggers == TRUE)
			{
				iTaskCount++;
			}
			
			bNotScheduled = FALSE;
		}//end of Trigger FOR loop

	
		CoTaskMemFree(lpwszNames[dwArrTaskIndex]);

		if( bMultiTriggers == FALSE)
			iTaskCount++;	

		CoTaskMemFree(lpwszNames);

		if( pITask )
			pITask->Release();
	  		
	}//End of the enumerating tasks
	
	if(pIEnum)
		pIEnum->Release();	

	//if there are no tasks display msg.
	if(bTasksExists == FALSE) 
	{	
		DestroyDynamicArray(&pColData);
		DISPLAY_MESSAGE(stdout,GetResString(IDS_TASKNAME_NOTASKS));
		return S_OK;
	}

	DISPLAY_MESSAGE(stdout,_T("\n"));

	if( bVerbose == FALSE )
	{
		if ( dwFormatType == SR_FORMAT_LIST )
		{
			iArrSize = COL_SIZE_LIST; // for LIST non-verbose mode only 4 columns
		}
		else
		{
			iArrSize = COL_SIZE_VERBOSE; // for non-verbose mode only 3 columns
		}

	}

	if(bHeader)
	{
		if ( ( bVerbose == FALSE ) && 
			( (dwFormatType == SR_FORMAT_TABLE) || (dwFormatType == SR_FORMAT_CSV) ) )
		{
		ShowResults(iArrSize,pNonVerboseCols,SR_HIDECOLUMN|dwFormatType,pColData);
		}
		else
		{
		ShowResults(iArrSize,pVerboseCols,SR_HIDECOLUMN|dwFormatType,pColData);
		}
	}
	else
	{
		if ( ( bVerbose == FALSE ) &&
				( (dwFormatType == SR_FORMAT_TABLE) || (dwFormatType == SR_FORMAT_CSV) ) )
		{
		ShowResults(iArrSize,pNonVerboseCols,dwFormatType,pColData);
		}
		else
		{
		ShowResults(iArrSize,pVerboseCols,dwFormatType,pColData);
		}
	}
	
	DestroyDynamicArray(&pColData);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scheduledtasks\resource.h ===
#define IDS_ERROR_PARSEPARAM				101
#define IDS_MODIFIER_NA						102
#define IDS_INVALID_MODIFIER				103
#define IDS_INVALID_VALUE_FOR_DAY			104
#define IDS_INVALID_VALUE_FOR_MON			105
#define IDS_MON_NA							106
#define IDS_INVALIDFORMAT_STARTDATE			107
#define IDS_NO_STARTDATE					108
#define IDS_INVALIDFORMAT_ENDDATE			109
#define IDS_ENDDATE_NA						110
#define IDS_INVALIDFORMAT_STARTTIME			111
#define IDS_NO_STARTTIME					112
#define IDS_STARTTIME_NA					113
#define IDS_INVALIDORNO_IDLETIME			114
#define IDS_NTAUTH_SYSTEM_ERROR				115
#define IDS_INVALID_NET_ADDRESS				116
#define IDS_FAILED_TOGET_USER				117
#define IDS_INVALID_ARG						118
#define IDS_NO_MEMORY						119
#define IDS_INVALID_TASK					120
#define IDS_INVALID_USERNAME				121
#define IDS_TASKNAME_NOTEXIST				122
#define IDS_DELETE_SYNERROR					123
#define IDS_CHANGE_SYNERROR					124
#define IDS_RUN_SYNERROR					125
#define IDS_END_SYNERROR					126
#define IDS_CREATE_USAGE					127
#define IDS_INVALID_SCHEDTYPE				128
#define IDS_USERNAME_BUT_NOMACHINE			129
#define IDS_PASSWORD_BUT_NOUSERNAME			130
#define IDS_NO_CHANGE_OPTIONS				131
#define IDS_NO_PASSWORD						132
#define IDS_RUN_ERROR						133
#define IDS_FAILED_TOSET_PARAMS				134
#define IDS_FAILED_TOGET_RUNASUSER			135
#define IDS_DAYS_NA							136
#define IDS_CREATEFAIL_INVALIDARGS			137
#define IDS_CREATE_TASK_EXISTS				138
#define IDS_INVALIDFORMAT_DATE				139
#define IDS_NOTAPPLICABLE_SDATE				140
#define IDS_INVALIDIDLETIME_OPTION			141
#define IDS_INVALID_TASKLENGTH				142
#define IDS_INVALID_JOBNAME					143
#define IDS_LOGGED_USER_ERR					144
#define IDS_NOHEADER_NA						145
#define IDS_WRONG_INPUT_DELETE				146
#define IDS_IDLETIME_NA						147
#define IDS_NO_DAY_VALUE					148
#define IDS_NO_MONTH_VALUE					149
#define IDS_INVALID_TASKRUN					150
#define IDS_NO_SERVER						151
#define IDS_INVALID_SERVER					152
#define IDS_DELETEOPTION_ERROR				153
#define IDS_CREATEFILE_USAGE				154
#define IDS_RES_ERROR						155
#define IDS_QUERY_USAGE						156
#define IDS_CREATE_READERROR				157
#define IDS_ENDATE_INVALID					158
#define IDS_CREATE_ERR						159
#define IDS_QUERY_READ						160
#define IDS_LOGTYPE_ERROR					161
#define IDS_MODIFIER_INVALID				162
#define IDS_QUERY_FORMAT_ERR				163
#define IDS_IDLETIME_INVALID				164
#define IDS_INVALID_TASKNAME1				165
#define IDS_NO_IDLETIME						166
#define IDS_OPEN_FAILED						167
#define IDS_READ_FAILED						168
#define IDS_WARNING_STRING					169

#define IDS_RUNNING_ALREADY					201
#define IDS_NTAUTH_SYSTEM_INFO				202
#define IDS_NTAUTH_SYSTEM_CHANGE_INFO		203
#define IDS_TASKNAME_NOTASKS				204
#define IDS_INVALID_TASKNAME2				205

#define IDS_INVALID_USER        			251
#define IDS_PASSWORD_NOEFFECT				252
#define IDS_WARN_DELETEALL					253
#define IDS_WARN_DELETE						254

#define IDS_SUCCESS_DELETED					301
#define IDS_CREATE_SUCCESSFUL				302
#define IDS_CHANGE_SUCCESSFUL				303
#define IDS_RUN_SUCCESSFUL					304
#define IDS_END_SUCCESSFUL					305

#define IDS_COL_HOSTNAME					351
#define IDS_COL_TASKNAME					352
#define IDS_COL_NEXTRUNTIME					353
#define IDS_COL_LASTRUNTIME					354
#define IDS_COL_STATUS						355
#define IDS_COL_LASTRESULT					356
#define IDS_COL_CREATOR						357
#define IDS_COL_SCHEDULE					358
#define IDS_COL_APPNAME						359
#define IDS_COL_WORKDIRECTORY				360
#define IDS_COL_COMMENT						361
#define IDS_COL_TASKSTATE					362
#define IDS_COL_TASKTYPE					363
#define IDS_COL_STARTTIME					364
#define IDS_COL_STARTDATE					365
#define IDS_COL_ENDDATE						366
#define IDS_COL_DAYS						367
#define IDS_COL_MONTHS						368
#define IDS_COL_RUNASUSER					369
#define IDS_COL_DELTASK						370
#define IDS_COL_STOPTASK					371
#define IDS_COL_REPEAT_EVERY				372
#define IDS_COL_REPEAT_UNTILTIME			373
#define IDS_COL_REPEAT_DURATION				374
#define IDS_COL_REPEAT_RUNNING				375
#define IDS_COL_IDLE					    376
#define IDS_COL_POWER					    377

#define IDS_COL_IDLE_START					378
#define IDS_COL_IDLE_ONLYSTART				379
#define IDS_COL_IDLE_NOTIDLE				380
#define IDS_COL_IDLE_STOPTASK				381
#define IDS_COL_POWER_NOSTART				382
#define IDS_COL_POWER_STOP					383

#define IDS_WIDTH_HOSTNAME					601
#define IDS_WIDTH_TASKNAME					602
#define IDS_WIDTH_NEXTRUNTIME				603
#define IDS_WIDTH_LASTRUNTIME				604
#define IDS_WIDTH_STATUS					605
#define IDS_WIDTH_LASTRESULT				606
#define IDS_WIDTH_CREATOR					607
#define IDS_WIDTH_SCHEDULE					608
#define IDS_WIDTH_APPNAME					609
#define IDS_WIDTH_WORKDIRECTORY				610
#define IDS_WIDTH_COMMENT					611
#define IDS_WIDTH_TASKSTATE					612
#define IDS_WIDTH_TASKTYPE					613
#define IDS_WIDTH_TASKMODIFIER				614
#define IDS_WIDTH_TASKSTIME					615
#define IDS_WIDTH_TASKSDATE					616
#define IDS_WIDTH_TASKEDATE					617
#define IDS_WIDTH_TASKDAYS					618
#define IDS_WIDTH_TASKMONTHS				619	
#define IDS_WIDTH_TASKRUNASUSER				620
#define IDS_WIDTH_TASKDELETE				621	
#define IDS_WIDTH_TASK_RPTEVERY				622	
#define IDS_WIDTH_TASK_UNTILRPTTIME			623	
#define IDS_WIDTH_TASK_RPTDURATION			624	
#define IDS_WIDTH_TASK_RPTRUNNING			625	
#define IDS_WIDTH_TASKIDLESTART				626	
#define IDS_WIDTH_TASKIDLEONLYSTART			627	
#define IDS_WIDTH_TASKNOTIDLE				628	
#define IDS_WIDTH_TASKIDLESTOP				629	
#define IDS_WIDTH_TASKPOWERNOSTART			630	
#define IDS_WIDTH_TASKPOWERSTOP				631	
#define IDS_WIDTH_TASKSTOP					632	
#define IDS_WIDTH_TASKIDLE					633
#define IDS_WIDTH_TASKPOWERMGMT             634

#define IDS_HOSTNAME_COL_NUMBER					651
#define IDS_TASKNAME_COL_NUMBER					652
#define IDS_NEXTRUNTIME_COL_NUMBER				653
#define IDS_LASTRUNTIME_COL_NUMBER				654
#define IDS_STATUS_COL_NUMBER					655
#define IDS_LASTRESULT_COL_NUMBER				656
#define IDS_CREATOR_COL_NUMBER					657
#define IDS_SCHEDULE_COL_NUMBER					658
#define IDS_TASKTORUN_COL_NUMBER				659
#define IDS_STARTIN_COL_NUMBER					660
#define IDS_COMMENT_COL_NUMBER					661
#define IDS_TASKSTATE_COL_NUMBER				662
#define IDS_TASKTYPE_COL_NUMBER					663
#define IDS_STARTTIME_COL_NUMBER				664
#define IDS_STARTDATE_COL_NUMBER				665
#define IDS_ENDDATE_COL_NUMBER					666
#define IDS_DAYS_COL_NUMBER						667
#define IDS_MONTHS_COL_NUMBER					668
#define IDS_RUNASUSER_COL_NUMBER				669
#define IDS_DELETE_IFNOTRESCHEDULED_COL_NUMBER	670
#define IDS_STOPTASK_COL_NUMBER					671
#define IDS_REPEAT_EVERY_COL_NUMBER				672
#define IDS_REPEAT_UNTILTIME_COL_NUMBER			673
#define IDS_REPEAT_DURATION_COL_NUMBER			674
#define IDS_REPEAT_STOP_COL_NUMBER				675
#define IDS_IDLE_STARTTIME_COL_NUMBER			676
#define IDS_IDLE_ONLYSTART_IFIDLE_COL_NUMBER	677
#define IDS_IDLE_IFNOTIDLE_COL_NUMBER			678
#define IDS_IDLE_STOPTASK_COL_NUMBER			679
#define IDS_POWER_NOSTARTONBATT_COL_NUMBER		680
#define IDS_POWER_STOPONBATT_COL_NUMBER			681
#define IDS_IDLE_COL_NUMBER						682
#define IDS_POWER_MGMT_COL_NUMBER				683

#define IDS_STATUS_UNKNOWN           401
#define IDS_STATUS_NOTSCHED          402
#define IDS_TASK_PROPERTY_UNKNOWN    403
#define IDS_TASK_PROPERTY_DISABLED   404
#define IDS_TASK_PROPERTY_NONE       405
#define IDS_TASK_PROPERTY_ENABLED    406
#define IDS_USER_UNKNOWN             407
#define IDS_ACCNAME_ERR              408
#define IDS_MINUTES                  411
#define IDS_MMDDYY_FORMAT	         412
#define IDS_DDMMYY_FORMAT			 413
#define IDS_YYMMDD_FORMAT			 414
#define IDS_MMDDYY_VALUE	         415
#define IDS_DDMMYY_VALUE	         416
#define IDS_YYMMDD_VALUE	         417
#define IDS_TASK_IDLE                418
#define IDS_TASK_SYSSTART            419
#define IDS_TASK_LOGON               420
#define IDS_TASK_NEVER               421
#define IDS_STATUS_RUNNING           422
#define IDS_STATUS_READY             423
#define IDS_STATUS_NOTYET            424
#define IDS_STATUS_SCHEDULED         425
#define IDS_PROMPT_USERNAME          426
#define IDS_PROMPT_PASSWD            427
#define IDS_PROMPT_CHGPASSWD         428
#define IDS_TASK_INFO                429
#define IDS_SCHEDTYPE_MINUTE         430
#define IDS_SCHEDTYPE_HOUR           431
#define IDS_SCHEDTYPE_DAILY          432
#define IDS_SCHEDTYPE_WEEK           433
#define IDS_SCHEDTYPE_MONTHLY        434
#define IDS_SCHEDTYPE_ONCE           435
#define IDS_SCHEDTYPE_STARTUP        436
#define IDS_SCHEDTYPE_LOGON          437
#define IDS_SCHEDTYPE_IDLE           438
#define IDS_QUERY_NOENDDATE          439
#define IDS_TASK_PROPERTY_NA         440
#define IDS_TASK_PROPERTY_ONCE       441
#define IDS_TASK_PROPERTY_NEVER      442
#define IDS_TASK_PROPERTY_DAILY      443
#define IDS_TASK_PROPERTY_HOURLY     444
#define IDS_TASK_PROPERTY_MINUTE     445
#define IDS_TASK_HOURLY              446
#define IDS_TASK_MINUTE              447
#define IDS_TASK_PROPERTY_WEEKLY     448
#define IDS_TASK_PROPERTY_MONTHLY    449
#define IDS_TASK_PROPERTY_SPMONTHS   450
#define IDS_TASK_PROPERTY_UNDEF      451
#define IDS_TASK_SUNDAY              452
#define IDS_TASK_MONDAY              453
#define IDS_TASK_TUESDAY             454
#define IDS_TASK_WEDNESDAY           455
#define IDS_TASK_THURSDAY            456
#define IDS_TASK_FRIDAY              457
#define IDS_TASK_SATURDAY            458
#define IDS_TASK_JANUARY             459
#define IDS_TASK_FEBRUARY            460
#define IDS_TASK_MARCH               461
#define IDS_TASK_APRIL               462
#define IDS_TASK_MAY				 463
#define IDS_TASK_JUNE				 464
#define IDS_TASK_JULY				 465
#define IDS_TASK_AUGUST				 466
#define IDS_TASK_SEPTEMBER			 467
#define IDS_TASK_OCTOBER			 468
#define IDS_TASK_NOVEMBER			 469
#define IDS_TASK_DECEMBER			 470
#define IDS_TASK_FIRSTWEEK			 471
#define IDS_TASK_SECONDWEEK			 472
#define IDS_TASK_THIRDWEEK			 473
#define IDS_TASK_FOURTHWEEK			 474
#define IDS_TASK_LASTWEEK			 475
#define IDS_QUERY_FORMAT_TABLE		 476
#define IDS_QUERY_FORMAT_LIST		 477
#define IDS_QUERY_FORMAT_CSV		 478
#define IDS_MONTH_MODIFIER_JAN		 479
#define IDS_MONTH_MODIFIER_FEB		 480
#define IDS_MONTH_MODIFIER_MAR		 481
#define IDS_MONTH_MODIFIER_APR		 482
#define IDS_MONTH_MODIFIER_MAY		 483
#define IDS_MONTH_MODIFIER_JUN		 484
#define IDS_MONTH_MODIFIER_JUL		 485
#define IDS_MONTH_MODIFIER_AUG		 486
#define IDS_MONTH_MODIFIER_SEP		 487
#define IDS_MONTH_MODIFIER_OCT		 488
#define IDS_MONTH_MODIFIER_NOV		 489
#define IDS_MONTH_MODIFIER_DEC		 490
#define IDS_DAY_MODIFIER_SUN		 491
#define IDS_DAY_MODIFIER_MON		 492
#define IDS_DAY_MODIFIER_TUE		 493
#define IDS_DAY_MODIFIER_WED		 494
#define IDS_DAY_MODIFIER_THU		 495
#define IDS_DAY_MODIFIER_FRI		 496
#define IDS_DAY_MODIFIER_SAT		 497
#define IDS_DAY_MODIFIER_LASTDAY	 498
#define IDS_RPTTIME_PROPERTY_MINUTES 499
#define IDS_RPTTIME_PROPERTY_HOURS	 500
#define IDS_RPTDURATION_PROPERTY	 501
#define IDS_DAILY_TYPE				 502
#define IDS_EVERYDAY				 504
#define IDS_WEEK_DISPLAY_STRING		 505
#define IDS_MONTHLY_DISPLAY_STRING	 506
#define IDS_QUERY_NA				 507
#define IDS_ERROR_STRING			 508
#define IDS_STATUS_COULDNOTSTART	 509
#define IDS_NOTSCHEDULED_TASK		 510
#define IDS_INVALID_PASSWORD		 511	
#define IDS_INVALID_UNAME			 512
#define IDS_CPASSWORD_BUT_NOUSERNAME 513
#define IDS_QPASSWORD_BUT_NOUSERNAME 514
#define IDS_DPASSWORD_BUT_NOUSERNAME 515
#define IDS_RPASSWORD_BUT_NOUSERNAME 516
#define IDS_EPASSWORD_BUT_NOUSERNAME 517
#define IDS_CHPASSWORD_BUT_NOUSERNAME 518
#define IDS_SCHEDULER_NOT_RUNNING	  519
#define IDS_RPC_SERVER_NOT_AVAIL	  520
#define IDS_USER_INFO				  521
#define IDS_WARN_EMPTY_PASSWORD       522
#define IDS_CREATE_USER_BUT_NOMACHINE IDS_USERNAME_BUT_NOMACHINE
#define IDS_DELETE_USER_BUT_NOMACHINE IDS_USERNAME_BUT_NOMACHINE
#define IDS_QUERY_USER_BUT_NOMACHINE  IDS_USERNAME_BUT_NOMACHINE
#define IDS_RUN_USER_BUT_NOMACHINE    IDS_USERNAME_BUT_NOMACHINE
#define IDS_END_USER_BUT_NOMACHINE    IDS_USERNAME_BUT_NOMACHINE
#define IDS_CHANGE_USER_BUT_NOMACHINE IDS_USERNAME_BUT_NOMACHINE

#define IDS_CREATE_HLP1         1001
#define IDS_CREATE_HLP2         1002
#define IDS_CREATE_HLP3         1003
#define IDS_CREATE_HLP4         1004
#define IDS_CREATE_HLP5         1005
#define IDS_CREATE_HLP6         1006
#define IDS_CREATE_HLP7         1007
#define IDS_CREATE_HLP8         1008
#define IDS_CREATE_HLP9         1009
#define IDS_CREATE_HLP10        1010
#define IDS_CREATE_HLP11        1011
#define IDS_CREATE_HLP12        1012
#define IDS_CREATE_HLP13        1013
#define IDS_CREATE_HLP14        1014
#define IDS_CREATE_HLP15        1015
#define IDS_CREATE_HLP16        1016
#define IDS_CREATE_HLP17        1017
#define IDS_CREATE_HLP18        1018
#define IDS_CREATE_HLP19        1019
#define IDS_CREATE_HLP20        1020
#define IDS_CREATE_HLP21        1021
#define IDS_CREATE_HLP22        1022
#define IDS_CREATE_HLP23        1023
#define IDS_CREATE_HLP24        1024
#define IDS_CREATE_HLP25        1025
#define IDS_CREATE_HLP26        1026
#define IDS_CREATE_HLP27        1027
#define IDS_CREATE_HLP28        1028
#define IDS_CREATE_HLP29        1029
#define IDS_CREATE_HLP30        1030
#define IDS_CREATE_HLP31        1031
#define IDS_CREATE_HLP32        1032
#define IDS_CREATE_HLP33        1033
#define IDS_CREATE_HLP34        1034
#define IDS_CREATE_HLP35        1035
#define IDS_CREATE_HLP36        1036
#define IDS_CREATE_HLP37        1037
#define IDS_CREATE_HLP38        1038
#define IDS_CREATE_HLP39        1039
#define IDS_CREATE_HLP40        1040
#define IDS_CREATE_HLP41        1041
#define IDS_CREATE_HLP42        1042
#define IDS_CREATE_HLP43        1043
#define IDS_CREATE_HLP44        1044
#define IDS_CREATE_HLP45        1045
#define IDS_CREATE_HLP46        1046
#define IDS_CREATE_HLP47        1047
#define IDS_CREATE_HLP48        1048
#define IDS_CREATE_HLP49        1049
#define IDS_CREATE_HLP50        1050
#define IDS_CREATE_HLP51        1051
#define IDS_CREATE_HLP52        1052
#define IDS_CREATE_HLP53        1053
#define IDS_CREATE_HLP54        1054
#define IDS_CREATE_HLP55        1055
#define IDS_CREATE_HLP56        1056
#define IDS_CREATE_HLP57        1057
#define IDS_CREATE_HLP58        1058
#define IDS_CREATE_HLP59        1059
#define IDS_CREATE_HLP60        1060
#define IDS_CREATE_HLP61        1061
#define IDS_CREATE_HLP62        1062
#define IDS_CREATE_HLP63        1063
#define IDS_CREATE_HLP64        1064
#define IDS_CREATE_HLP65        1065
#define IDS_CREATE_HLP66        1066
#define IDS_CREATE_HLP67        1067
#define IDS_CREATE_HLP68        1068
#define IDS_CREATE_HLP69        1069
#define IDS_CREATE_HLP70        1070
#define IDS_CREATE_HLP71        1071
#define IDS_CREATE_HLP72        1072
#define IDS_CREATE_HLP73        1073
#define IDS_CREATE_HLP74        1074
#define IDS_CREATE_HLP75        1075
#define IDS_CREATE_HLP76        1076
#define IDS_CREATE_HLP77        1077
#define IDS_CREATE_HLP78        1078
#define IDS_CREATE_HLP79        1079
#define IDS_CREATE_HLP80        1080
#define IDS_CREATE_HLP81        1081
#define IDS_CREATE_HLP82        1082
#define IDS_CREATE_HLP83        1083
#define IDS_CREATE_HLP84	    1084
#define IDS_CREATE_HLP85        1085
#define IDS_CREATE_HLP86        1086
#define IDS_CREATE_HLP87        1087
#define IDS_CREATE_HLP88        1088
#define IDS_CREATE_HLP89        1089
#define IDS_CREATE_HLP90        1090
#define IDS_CREATE_HLP91        1091
#define IDS_CREATE_HLP92        1092
#define IDS_CREATE_HLP93        1093
#define IDS_CREATE_HLP94        1094
#define IDS_CREATE_HLP95        1095
#define IDS_CREATE_HLP96        1096
#define IDS_CREATE_HLP97        1097
#define IDS_CREATE_HLP98        1098


#define IDS_MAINHLP1            1101
#define IDS_MAINHLP2            1102
#define IDS_MAINHLP3            1103
#define IDS_MAINHLP4            1104
#define IDS_MAINHLP5            1105
#define IDS_MAINHLP6            1106
#define IDS_MAINHLP7            1107
#define IDS_MAINHLP8            1108
#define IDS_MAINHLP9            1109
#define IDS_MAINHLP10           1110
#define IDS_MAINHLP11           1111
#define IDS_MAINHLP12           1112
#define IDS_MAINHLP13           1113
#define IDS_MAINHLP14           1114
#define IDS_MAINHLP15           1115
#define IDS_MAINHLP16           1116
#define IDS_MAINHLP17           1117
#define IDS_MAINHLP18           1118
#define IDS_MAINHLP19           1119
#define IDS_MAINHLP20           1120
#define IDS_MAINHLP21           1121

#define IDS_QUERY_HLP1          1201
#define IDS_QUERY_HLP2          1202
#define IDS_QUERY_HLP3          1203
#define IDS_QUERY_HLP4          1204
#define IDS_QUERY_HLP5          1205
#define IDS_QUERY_HLP6          1206
#define IDS_QUERY_HLP7          1207
#define IDS_QUERY_HLP8          1208
#define IDS_QUERY_HLP9          1209
#define IDS_QUERY_HLP10         1210
#define IDS_QUERY_HLP11         1211
#define IDS_QUERY_HLP12         1212
#define IDS_QUERY_HLP13         1213
#define IDS_QUERY_HLP14         1214
#define IDS_QUERY_HLP15         1215
#define IDS_QUERY_HLP16         1216
#define IDS_QUERY_HLP17         1217
#define IDS_QUERY_HLP18         1218
#define IDS_QUERY_HLP19         1219
#define IDS_QUERY_HLP20         1220
#define IDS_QUERY_HLP21         1221
#define IDS_QUERY_HLP22         1222
#define IDS_QUERY_HLP23         1223
#define IDS_QUERY_HLP24         1224
#define IDS_QUERY_HLP25         1225

#define IDS_DEL_HLP1            1301
#define IDS_DEL_HLP2            1302
#define IDS_DEL_HLP3            1303
#define IDS_DEL_HLP4            1304
#define IDS_DEL_HLP5            1305
#define IDS_DEL_HLP6            1306
#define IDS_DEL_HLP7            1307
#define IDS_DEL_HLP8            1308
#define IDS_DEL_HLP9            1309
#define IDS_DEL_HLP10           1310
#define IDS_DEL_HLP11           1311
#define IDS_DEL_HLP12           1312
#define IDS_DEL_HLP13           1313
#define IDS_DEL_HLP14           1314
#define IDS_DEL_HLP15           1315
#define IDS_DEL_HLP16           1316
#define IDS_DEL_HLP17           1317
#define IDS_DEL_HLP18           1318
#define IDS_DEL_HLP19           1319
#define IDS_DEL_HLP20           1320
#define IDS_DEL_HLP21           1321
#define IDS_DEL_HLP22           1322
#define IDS_DEL_HLP23           1323
#define IDS_DEL_HLP24           1324

#define IDS_CHANGE_HLP1         1401
#define IDS_CHANGE_HLP2         1402
#define IDS_CHANGE_HLP3         1403
#define IDS_CHANGE_HLP4         1404
#define IDS_CHANGE_HLP5         1405
#define IDS_CHANGE_HLP6         1406
#define IDS_CHANGE_HLP7         1407
#define IDS_CHANGE_HLP8         1408
#define IDS_CHANGE_HLP9         1409
#define IDS_CHANGE_HLP10        1410
#define IDS_CHANGE_HLP11        1411
#define IDS_CHANGE_HLP12        1412
#define IDS_CHANGE_HLP13        1413
#define IDS_CHANGE_HLP14        1414
#define IDS_CHANGE_HLP15        1415
#define IDS_CHANGE_HLP16        1416
#define IDS_CHANGE_HLP17        1417
#define IDS_CHANGE_HLP18        1418
#define IDS_CHANGE_HLP19        1419
#define IDS_CHANGE_HLP20        1420
#define IDS_CHANGE_HLP21        1421
#define IDS_CHANGE_HLP22        1422
#define IDS_CHANGE_HLP23        1423
#define IDS_CHANGE_HLP24        1424
#define IDS_CHANGE_HLP25        1425
#define IDS_CHANGE_HLP26        1426
#define IDS_CHANGE_HLP27        1427
#define IDS_CHANGE_HLP28        1428
#define IDS_CHANGE_HLP29        1429
#define IDS_CHANGE_HLP30        1430
#define IDS_CHANGE_HLP31        1431
#define IDS_CHANGE_HLP32        1432
#define IDS_CHANGE_HLP33        1433

#define IDS_RUN_HLP1			1501
#define IDS_RUN_HLP2			1502
#define IDS_RUN_HLP3			1503
#define IDS_RUN_HLP4			1504
#define IDS_RUN_HLP5			1505
#define IDS_RUN_HLP6			1506
#define IDS_RUN_HLP7			1507
#define IDS_RUN_HLP8			1508
#define IDS_RUN_HLP9			1509
#define IDS_RUN_HLP10			1510
#define IDS_RUN_HLP11			1511
#define IDS_RUN_HLP12			1512
#define IDS_RUN_HLP13			1513
#define IDS_RUN_HLP14			1514
#define IDS_RUN_HLP15			1515
#define IDS_RUN_HLP16			1516

#define IDS_END_HLP1			1601
#define IDS_END_HLP2			1602
#define IDS_END_HLP3			1603
#define IDS_END_HLP4			1604
#define IDS_END_HLP5			1605
#define IDS_END_HLP6			1606
#define IDS_END_HLP7			1607
#define IDS_END_HLP8			1608
#define IDS_END_HLP9			1609
#define IDS_END_HLP10			1610
#define IDS_END_HLP11			1611
#define IDS_END_HLP12			1612
#define IDS_END_HLP13			1613
#define IDS_END_HLP14			1614
#define IDS_END_HLP15			1615
#define IDS_END_HLP16			1616
#define IDS_END_HLP17			1617
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scheduledtasks\querytasks.cpp ===
/******************************************************************************

	Copyright(c) Microsoft Corporation

	Module Name:

		QueryTasks.cpp

	Abstract:

		This module queries the different properties of a Scheduled Task

	Author:

		G.Surender Reddy  10-Sept-2000 

	Revision History:

		G.Surender Reddy  10-Sep-2000 : Created it
		G.Surender Reddy  25-Sep-2000 : Modified it
										[ Made changes to avoid memory leaks,
										  changed to suit localization ]
		G.Surender Reddy  15-oct-2000 : Modified it
									    [ Moved the strings to Resource table ]
******************************************************************************/ 


//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"


/******************************************************************************

	Routine Description:

		This function returns the next or last  run time of the task depending on
		the type of time specified by user. 

	Arguments:

		[ in ]  pITask	   : Pointer to the ITask interface
		[ out ] pszRunTime : pointer to the string containing Task run time[last or next]
		[ out ] pszRunDate : pointer to the string containing Task run Date[last or next]
		[ in ]  dwTimetype : Type of run time[TASK_LAST_RUNTIME or TASK_NEXT_RUNTIME]

	Return Value:

		A HRESULT  value indicating S_OK on success  else S_FALSE on failure 

******************************************************************************/ 

HRESULT
GetTaskRunTime(ITask* pITask,_TCHAR* pszRunTime,_TCHAR* pszRunDate,DWORD dwTimetype,
			   WORD wTriggerNum)
{
	HRESULT	hr = S_OK;
	SYSTEMTIME tRunTime = {0,0,0,0,0,0,0,0};
	_TCHAR szTime[MAX_DATETIME_LEN] = NULL_STRING; 
	_TCHAR szDate[MAX_DATETIME_LEN] = NULL_STRING; 
	int iBuffSize = 0;
	BOOL bNoStartTime  = FALSE;
	BOOL bLocaleChanged = FALSE;
	LCID lcid;

	if(pITask == NULL)
	{
		return S_FALSE;
	}


	ITaskTrigger *pITaskTrigger = NULL;

	if( ( dwTimetype == TASK_NEXT_RUNTIME ) || ( dwTimetype == TASK_START_RUNTIME ) )
	{	
		//determine the task type 
		hr = pITask->GetTrigger(wTriggerNum,&pITaskTrigger);
		if ( FAILED(hr) )
		{
			if(pITaskTrigger)
			{
				pITaskTrigger->Release();
			}

			return hr;
		}

		TASK_TRIGGER Trigger;
		ZeroMemory(&Trigger, sizeof (TASK_TRIGGER));

		hr = pITaskTrigger->GetTrigger(&Trigger);
		if ( FAILED(hr) )
		{
			if( pITaskTrigger )
			{
				pITaskTrigger->Release();
			}

			return hr;
		}

		if( dwTimetype == TASK_START_RUNTIME )
		{
			tRunTime.wDay = Trigger.wBeginDay;
			tRunTime.wMonth = Trigger.wBeginMonth;
			tRunTime.wYear = Trigger.wBeginYear;
			tRunTime.wHour = Trigger.wStartHour;
			tRunTime.wMinute = Trigger.wStartMinute;

		}

		if((Trigger.TriggerType >= TASK_EVENT_TRIGGER_ON_IDLE)	&&
		   (Trigger.TriggerType <= TASK_EVENT_TRIGGER_AT_LOGON))
		{
			switch(Trigger.TriggerType )
			{
				case TASK_EVENT_TRIGGER_ON_IDLE ://On Idle time
					LoadResString(IDS_TASK_IDLE , pszRunTime ,
								  MAX_DATETIME_LEN );
					break;
				case TASK_EVENT_TRIGGER_AT_SYSTEMSTART://At system start
					LoadResString(IDS_TASK_SYSSTART , pszRunTime ,
						          MAX_DATETIME_LEN );
					break;
				case TASK_EVENT_TRIGGER_AT_LOGON ://At logon time
					LoadResString(IDS_TASK_LOGON , pszRunTime ,
						          MAX_DATETIME_LEN );
					break;

				default:
					break;
					
							
			}	

			if( dwTimetype == TASK_START_RUNTIME )
			{
				bNoStartTime  = TRUE;
			}

			if( dwTimetype == TASK_NEXT_RUNTIME )
			{
				lstrcpy( pszRunDate,pszRunTime );
				if( pITaskTrigger )
				{
					pITaskTrigger->Release();
				}
				return S_OK;
			}
		}

		
		if( dwTimetype == TASK_NEXT_RUNTIME )
		{
			hr = pITask->GetNextRunTime(&tRunTime);
			if (FAILED(hr))
			{
				if( pITaskTrigger )
				{
					pITaskTrigger->Release();
				}
				
				return hr;
			}

                       // check whether the task has next run time to run or not..
                       // If not, Next Run Time would be "Never".
                       if ( tRunTime.wHour == 0 && tRunTime.wMinute == 0 &&
                            tRunTime.wDay == 0 && tRunTime.wMonth == 0 && tRunTime.wYear == 0 )
                       {
				LoadResString(IDS_TASK_NEVER , pszRunTime , MAX_DATETIME_LEN );
				lstrcpy( pszRunDate,pszRunTime );
				if( pITaskTrigger )
				{
					pITaskTrigger->Release();
				}
				return S_OK;
			}

		} 
		if( pITaskTrigger )
		{
			pITaskTrigger->Release();
		}
	} 
	//Determine Task last run time
	else if(dwTimetype == TASK_LAST_RUNTIME ) 
	{	
		// Retrieve task's last run time 
		hr = pITask->GetMostRecentRunTime(&tRunTime);
		if (FAILED(hr))
		{
			return hr;
		}
	}
	else 
	{
		return S_FALSE;
	}


	if((hr == SCHED_S_TASK_HAS_NOT_RUN) && (dwTimetype == TASK_LAST_RUNTIME))
	{
		LoadResString(IDS_TASK_NEVER , pszRunTime , MAX_DATETIME_LEN );
		lstrcpy( pszRunDate,pszRunTime );
		return S_OK;
	}
	
	// verify whether console supports the current locale fully or not
	lcid = GetSupportedUserLocale( bLocaleChanged );

	//Retrieve  the Date
	iBuffSize = GetDateFormat( lcid, 0, &tRunTime, 
		(( bLocaleChanged == TRUE ) ? L"MM/dd/yyyy" : NULL), szDate, SIZE_OF_ARRAY( szDate ) );

	if(iBuffSize == 0)
	{
		return S_FALSE;
	}

	// to give the time string format as hh:mm:ss
	//_TCHAR szFormat[MAX_TIME_FORMAT_LEN] = NULL_STRING;
	//lstrcpy(szFormat , GetResString(IDS_TIME_FORMAT) );

	if(!bNoStartTime )
	{
		
		iBuffSize = GetTimeFormat( lcid, TIME_FORCE24HOURFORMAT, 
			&tRunTime,	L"HH:mm:ss",szTime, SIZE_OF_ARRAY( szTime ) ); 

		if(iBuffSize == 0)
		{
			return S_FALSE; 
		}

	}

	if( lstrlen(szTime) )
	{
		lstrcpy(pszRunTime,szTime);
	}

	if( lstrlen(szDate) )
	{
		lstrcpy(pszRunDate,szDate);
	}

	return S_OK;

}

/******************************************************************************

	Routine Description:

		This function returns the status code description of a particular task.

	Arguments:

		[ in ] pITask		  : Pointer to the ITask interface
		[ out ] pszStatusCode : pointer to the Task's status string

	Return Value:

		A HRESULT  value indicating S_OK on success  else S_FALSE on failure 

******************************************************************************/ 

HRESULT
GetStatusCode(ITask* pITask,_TCHAR* pszStatusCode)
{
	HRESULT hrStatusCode = S_OK;
	HRESULT hr = S_OK;
	DWORD   dwExitCode = 0;

	hr = pITask->GetStatus(&hrStatusCode);//Got status of the task
	if (FAILED(hr))
	{
		return hr;
	}

	*pszStatusCode = NULL_CHAR;
	
	switch(hrStatusCode)
	{
		case SCHED_S_TASK_READY:
			hr = pITask->GetExitCode(&dwExitCode);
			if (FAILED(hr))
			{
			LoadResString(IDS_STATUS_COULDNOTSTART , pszStatusCode , MAX_STRING_LENGTH );
			}
			else
			{
			LoadResString(IDS_STATUS_READY , pszStatusCode , MAX_STRING_LENGTH );
			}
		    break;
		case SCHED_S_TASK_RUNNING:
			LoadResString(IDS_STATUS_RUNNING , pszStatusCode , MAX_STRING_LENGTH );
			break;
		case SCHED_S_TASK_NOT_SCHEDULED:

			hr = pITask->GetExitCode(&dwExitCode);
			if (FAILED(hr))
			{
			LoadResString(IDS_STATUS_COULDNOTSTART , pszStatusCode , MAX_STRING_LENGTH );
			}
			else
			{
			LoadResString(IDS_STATUS_NOTYET , pszStatusCode , MAX_STRING_LENGTH );
			}
			break;
        case SCHED_S_TASK_HAS_NOT_RUN:
			
			hr = pITask->GetExitCode(&dwExitCode);
			if (FAILED(hr))
			{
			LoadResString(IDS_STATUS_COULDNOTSTART , pszStatusCode , MAX_STRING_LENGTH );
			}
			else
			{
			LoadResString(IDS_STATUS_NOTYET , pszStatusCode , MAX_STRING_LENGTH );
			}
			break;
		case SCHED_S_TASK_DISABLED:
			hr = pITask->GetExitCode(&dwExitCode);
			if (FAILED(hr))
			{
			LoadResString(IDS_STATUS_COULDNOTSTART , pszStatusCode , MAX_STRING_LENGTH );
			}
			else
			{
			LoadResString(IDS_STATUS_NOTYET , pszStatusCode , MAX_STRING_LENGTH );
			}
			break;

	   default:
			LoadResString(IDS_STATUS_UNKNOWN , pszStatusCode , MAX_STRING_LENGTH );
			break;
	}

	return S_OK;
}

/******************************************************************************

	Routine Description:

		This function returns the path of the scheduled task application 

	Arguments:

		[ in ] pITask				: Pointer to the ITask interface
		[ out ] pszApplicationName	: pointer to the Task's scheduled application name

	Return Value:

		A HRESULT  value indicating S_OK on success  else S_FALSE on failure 

******************************************************************************/ 

HRESULT
GetApplicationToRun(ITask* pITask,_TCHAR* pszApplicationName)
{
	LPWSTR lpwszApplicationName = NULL;
	LPWSTR lpwszParameters = NULL;
	_TCHAR szAppName[MAX_STRING_LENGTH] = NULL_STRING;
	_TCHAR szParams[MAX_STRING_LENGTH] = NULL_STRING;

	// get the entire path of application name
	HRESULT hr = pITask->GetApplicationName(&lpwszApplicationName);
	if (FAILED(hr))
	{
		return hr;
	}
	
	// get the parameters
	hr = pITask->GetParameters(&lpwszParameters);
	if (FAILED(hr))
	{
		return hr;
	}

	if ( GetCompatibleStringFromUnicode(lpwszApplicationName,szAppName,
								   SIZE_OF_ARRAY(szAppName)) == NULL )
	{
		return S_FALSE;
	}

	if ( GetCompatibleStringFromUnicode(lpwszParameters, szParams,
								   SIZE_OF_ARRAY(szParams)) == NULL )
	{
		return S_FALSE;
	}

	if(lstrlen(szAppName) == 0)
	{
		lstrcpy(pszApplicationName,NULL_STRING);
	}
	else
	{
		lstrcat( szAppName, _T(" ") );
		lstrcat( szAppName, szParams );
		lstrcpy( pszApplicationName, szAppName);
	}
	
	CoTaskMemFree(lpwszApplicationName);
	CoTaskMemFree(lpwszParameters);
    return S_OK;
}

/******************************************************************************

	Routine Description:

		This function returns the WorkingDirectory of the scheduled task application 

	Arguments:

		[ in ] pITask		: Pointer to the ITask interface
		[ out ] pszWorkDir	: pointer to the Task's scheduled application working 
							  directory

	Return Value:

		A HRESULT  value indicating S_OK on success  else S_FALSE on failure 

******************************************************************************/ 

HRESULT
GetWorkingDirectory(ITask* pITask,_TCHAR* pszWorkDir)
{

	LPWSTR lpwszWorkDir = NULL;
	_TCHAR szWorkDir[MAX_STRING_LENGTH] = NULL_STRING;
	HRESULT hr = S_OK;

	hr = pITask->GetWorkingDirectory(&lpwszWorkDir);
	if(FAILED(hr))
	{
		return hr;
	}
  
  	if ( GetCompatibleStringFromUnicode(lpwszWorkDir,szWorkDir,
								   SIZE_OF_ARRAY(szWorkDir)) == NULL )
	{
		return S_FALSE;
	}
	if(lstrlen(szWorkDir) == 0)
	{
		lstrcpy(pszWorkDir,NULL_STRING);
	}
	else
	{
		lstrcpy(pszWorkDir,szWorkDir);
	}
	
	CoTaskMemFree(lpwszWorkDir);

	return S_OK;
}

/******************************************************************************

	Routine Description:

		This function returns the comment of a task

	Arguments:

		[ in ] pITask	    : Pointer to the ITask interface
		[ in ] pszComment : pointer to the Task's comment name

	Return Value:

		A HRESULT  value indicating S_OK on success  else S_FALSE on failure 

********************************************************************************/ 

HRESULT
GetComment(ITask* pITask,_TCHAR* pszComment)
{
	LPWSTR lpwszComment = NULL;
	_TCHAR szTaskComment[MAX_STRING_LENGTH] = NULL_STRING;
	HRESULT hr = S_OK;

	hr = pITask->GetComment(&lpwszComment);
	if (FAILED(hr))
	{
		return hr;
	}
	if ( GetCompatibleStringFromUnicode(lpwszComment,szTaskComment,
								   SIZE_OF_ARRAY(szTaskComment)) == NULL )
	{
		return S_FALSE;
	}

	if(lstrlen(szTaskComment) == 0)
	{
		lstrcpy(pszComment,NULL_STRING);
	}
	else
	{
		lstrcpy(pszComment,szTaskComment);
	}
	
	CoTaskMemFree(lpwszComment);		
	return S_OK;
}

/******************************************************************************

	Routine Description:

		This function returns the creator name of a task

	Arguments:

		[ in ] pITask		: Pointer to the ITask interface
		[ in ] pszCreator	: pointer to the Task's creator name

	Return Value:

		A HRESULT  value indicating S_OK on success  else S_FALSE on failure 

*******************************************************************************/ 

HRESULT
GetCreator(ITask* pITask,_TCHAR* pszCreator)
{
	LPWSTR lpwszCreator = NULL;
	_TCHAR szTaskCreator[MAX_STRING_LENGTH] = NULL_STRING;
	HRESULT hr = S_OK;

	hr = pITask->GetCreator(&lpwszCreator);
	if (FAILED(hr))
	{
		return hr;
	}

	if ( GetCompatibleStringFromUnicode(lpwszCreator,szTaskCreator,
								   SIZE_OF_ARRAY(szTaskCreator)) == NULL )
	{
		return S_FALSE;
	}

	if(lstrlen(szTaskCreator) == 0)
	{
		lstrcpy(pszCreator,NULL_STRING);
	}
	else
	{
		lstrcpy(pszCreator,szTaskCreator);
	}
	
	CoTaskMemFree(lpwszCreator);		
	return S_OK;
}


/******************************************************************************

	Routine Description:

		This function returns the Trigger string of a task

	Arguments:

		[ in ] pITask		: Pointer to the ITask interface
		[ out ] pszTrigger  : pointer to the Task's trigger string

	Return Value:

		A HRESULT  value indicating S_OK on success  else S_FALSE on failure 

******************************************************************************/ 

HRESULT
GetTriggerString(ITask* pITask,_TCHAR* pszTrigger,WORD wTriggNum)
{
	LPWSTR lpwszTrigger = NULL;
	_TCHAR szTaskTrigger[MAX_STRING_LENGTH] = NULL_STRING;
	HRESULT hr = S_OK;
	
	hr = pITask->GetTriggerString(wTriggNum,&lpwszTrigger);
	if (FAILED(hr))
	{
		return hr;
	}
	if (GetCompatibleStringFromUnicode(lpwszTrigger,szTaskTrigger,
								   SIZE_OF_ARRAY(szTaskTrigger)) == NULL )
	{
		return S_FALSE;
	}

	if(lstrlen(szTaskTrigger) == 0)
	{
		lstrcpy(pszTrigger,NULL_STRING);
	}
	else
	{
		lstrcpy(pszTrigger,szTaskTrigger);
	}
	
	CoTaskMemFree(lpwszTrigger);		
	return S_OK;
}

/******************************************************************************

	Routine Description:

		This function returns the user name of task

	Arguments:
	
		[ in ]  pITask	     : Pointer to the ITask interface
		[ out ] pszRunAsUser : pointer to the user's task name

	Return Value:

		A HRESULT  value indicating S_OK on success  else S_FALSE on failure 

*******************************************************************************/ 

HRESULT
GetRunAsUser(ITask* pITask,_TCHAR* pszRunAsUser)
{
	LPWSTR lpwszUser = NULL;
	_TCHAR szUserName[MAX_STRING_LENGTH] = NULL_STRING;
	HRESULT hr = S_OK;

	hr = pITask->GetAccountInformation(&lpwszUser);

	
	if (FAILED(hr))
	{
		CoTaskMemFree(lpwszUser);
		return hr;
	}

	if ( GetCompatibleStringFromUnicode(lpwszUser,szUserName,
								   SIZE_OF_ARRAY(szUserName)) == NULL )
	{
		return S_FALSE;
	}

	if(lstrlen(szUserName) == 0)
	{
		lstrcpy(pszRunAsUser,NULL_STRING);
	}
	else
	{
		lstrcpy(pszRunAsUser,szUserName);
	}

	CoTaskMemFree(lpwszUser);
 	return S_OK;

}


/******************************************************************************

	Routine Description:

		This function returns the Maximium run time of a  task.

	Arguments:

		[ in ]  pITask		    : Pointer to the ITask interface
		[ out ] pszMaxRunTime	: pointer to the Task's Maximum run time

	Return Value:

		A HRESULT  value indicating S_OK on success  else S_FALSE on failure 

******************************************************************************/ 

HRESULT
GetMaxRunTime(ITask* pITask,_TCHAR* pszMaxRunTime)
{
	
	DWORD dwRunTime = 0;
	DWORD dwHrs = 0;
	DWORD dwMins = 0;

	//Get the task max run time in milliseconds
	HRESULT hr = pITask->GetMaxRunTime(&dwRunTime);
	if (FAILED(hr))
	{
		return hr;
	}
	
	dwHrs = (dwRunTime / (1000 * 60 * 60));//Convert ms to hours
	dwMins = (dwRunTime % (1000 * 60 * 60));//get the minutes portion
	dwMins /= (1000 * 60);// Now convert to Mins

	if( (( dwHrs > 999 ) && ( dwMins > 99 )) ||(( dwHrs == 0 ) && ( dwMins == 0 ) ) )
	{
		//dwHrs = 0;
		//dwMins = 0;
		lstrcpy( pszMaxRunTime , GetResString(IDS_TASK_PROPERTY_DISABLED) );

	}
	else if ( dwHrs == 0 ) 
	{
		if( dwMins < 99 )
		{
			FORMAT_STRING2(pszMaxRunTime,_T("%d:%d"),dwHrs,dwMins);
		}
	}
	else if ( (dwHrs < 999) && (dwMins < 99) )
	{
		FORMAT_STRING2(pszMaxRunTime,_T("%d:%d"),dwHrs,dwMins);
	}
	else
	{
		lstrcpy( pszMaxRunTime , GetResString(IDS_TASK_PROPERTY_DISABLED) );
	}


	return S_OK;
}


/******************************************************************************

	Routine Description:

		This function returns the state of the task properties

	Arguments:

		[ in ]  pITask		  : Pointer to the ITask interface
		[ out ] pszTaskState  : pointer holding the task's state
		[ in ]  dwFlagType	  : flag indicating the task state

	Return Value:

		A HRESULT  value indicating S_OK on success  else S_FALSE on failure 

********************************************************************************/ 

HRESULT
GetTaskState(ITask* pITask,_TCHAR* pszTaskState,DWORD dwFlagType)
{
	DWORD dwFlags = 0;
	HRESULT hr = S_OK;

	hr = pITask->GetFlags(&dwFlags);
	if(FAILED(hr))
	{
		return hr;
	}

	if(dwFlagType == TASK_FLAG_DISABLED)
	{
		if((dwFlags & dwFlagType) ==  dwFlagType)
		{
			LoadResString(IDS_TASK_PROPERTY_DISABLED , pszTaskState , MAX_STRING_LENGTH );
		}
		else
		{
			LoadResString(IDS_TASK_PROPERTY_ENABLED , pszTaskState , MAX_STRING_LENGTH );
		}

		return S_OK;
	}

	if((dwFlags & dwFlagType) ==  dwFlagType)
	{
		LoadResString(IDS_TASK_PROPERTY_ENABLED , pszTaskState , MAX_STRING_LENGTH );
	}
	else
	{
		LoadResString(IDS_TASK_PROPERTY_DISABLED , pszTaskState , MAX_STRING_LENGTH );
	}

	return S_OK;
}

/******************************************************************************

	Routine Description:

		This function retrives the task properties [modfier,task nextrun time etc]

	Arguments:

		[ in ]  pITask	   : Pointer to the ITask interface 
		[ out ] pTaskProps : pointer to the array of task properties

	Return Value:

		A HRESULT  value indicating S_OK on success  else S_FALSE on failure 

******************************************************************************/ 

HRESULT
GetTaskProps(ITask* pITask,TASKPROPS* pTaskProps,WORD wTriggNum, _TCHAR* pszScName)
{
	_TCHAR szWeekDay[MAX_STRING_LENGTH] = NULL_STRING;
	_TCHAR szMonthDay[MAX_STRING_LENGTH] = NULL_STRING;
	_TCHAR szWeek[MAX_STRING_LENGTH]  = NULL_STRING;
	_TCHAR szTime[MAX_DATETIME_LEN] = NULL_STRING;
	_TCHAR szDate[MAX_DATETIME_LEN] = NULL_STRING;
	_TCHAR* szValues[3] = {NULL,NULL,NULL};//for holding values of parameters in FormatMessage()
	_TCHAR szBuffer[MAX_RES_STRING]  = NULL_STRING;
	_TCHAR szTempBuf[MAX_RES_STRING]  = NULL_STRING;
	_TCHAR szScheduleName[MAX_RES_STRING] = NULL_STRING;
	
	ITaskTrigger *pITaskTrigger = NULL;
	HRESULT hr = S_OK;
	_TCHAR *szToken = NULL; 
	_TCHAR seps[]   = _T(" ");
	BOOL bMin = FALSE;
	BOOL bHour = FALSE;
	DWORD dwMinutes = 0;
	DWORD dwHours = 0;
	DWORD dwMinInterval = 0;
	DWORD dwMinDuration = 0;

	if ( lstrlen(pszScName) != 0)
	{
		lstrcpy(szScheduleName, pszScName);
	}

	hr = pITask->GetTrigger(wTriggNum,&pITaskTrigger);
	if (FAILED(hr))
	{
		if(pITaskTrigger)
		{
			pITaskTrigger->Release();
		}

		return hr;
	}

	TASK_TRIGGER Trigger;
	ZeroMemory(&Trigger, sizeof (TASK_TRIGGER));

	hr = pITaskTrigger->GetTrigger(&Trigger);
	if (FAILED(hr))
	{
		if(pITaskTrigger)
		{
			pITaskTrigger->Release();
		}
		return hr;
	}
	
	//Get the task start time & start date
	hr = GetTaskRunTime(pITask,szTime,szDate,TASK_START_RUNTIME,wTriggNum);
	if (FAILED(hr))
	{	
		lstrcpy( pTaskProps->szTaskStartTime , GetResString(IDS_TASK_PROPERTY_NA) );
	}
	else
	{
		lstrcpy( pTaskProps->szTaskStartTime , szTime );
		lstrcpy(pTaskProps->szTaskStartDate, szDate );
	}

	//Initialize to default values	
	lstrcpy(pTaskProps->szRepeatEvery, GetResString(IDS_TASK_PROPERTY_DISABLED));
	lstrcpy(pTaskProps->szRepeatUntilTime, GetResString(IDS_TASK_PROPERTY_DISABLED));
	lstrcpy(pTaskProps->szRepeatDuration, GetResString(IDS_TASK_PROPERTY_DISABLED));
	lstrcpy(pTaskProps->szRepeatStop, GetResString(IDS_TASK_PROPERTY_DISABLED));

	if((Trigger.TriggerType >= TASK_TIME_TRIGGER_ONCE ) &&
	   (Trigger.TriggerType <= TASK_TIME_TRIGGER_MONTHLYDOW ))
	{
		if(Trigger.MinutesInterval > 0) 
		{
		// Getting the minute interval	
		dwMinInterval =  Trigger.MinutesInterval;
		
		if ( dwMinInterval >= 60)
		{
			// convert minutes into hours
			dwHours = dwMinInterval / 60;
				
			szValues[0] = _ultot(dwHours,szBuffer,10);
				
			FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
						  GetResString(IDS_RPTTIME_PROPERTY_HOURS),0,MAKELANGID(LANG_NEUTRAL,
						  SUBLANG_DEFAULT),pTaskProps->szRepeatEvery,
						  MAX_RES_STRING,(va_list*)szValues
						  );

		}
		else
		{
			szValues[0] = _ultot(dwMinInterval,szBuffer,10);
				
			FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
						  GetResString(IDS_RPTTIME_PROPERTY_MINUTES),0,MAKELANGID(LANG_NEUTRAL,
						  SUBLANG_DEFAULT),pTaskProps->szRepeatEvery,
						  MAX_RES_STRING,(va_list*)szValues
						  );
		}

		if ( dwMinInterval )
		{
			lstrcpy(pTaskProps->szRepeatUntilTime, GetResString(IDS_TASK_PROPERTY_NONE));
		}

		// Getting the minute duration
		dwMinDuration = Trigger.MinutesDuration;

		dwHours = dwMinDuration / 60;
		dwMinutes = dwMinDuration % 60;
			
		szValues[0] = _ultot(dwHours,szBuffer,10);
		szValues[1] = _ultot(dwMinutes,szTempBuf,10);

				
		FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
						  GetResString(IDS_RPTDURATION_PROPERTY),0,MAKELANGID(LANG_NEUTRAL,
						  SUBLANG_DEFAULT),pTaskProps->szRepeatDuration,
						  MAX_RES_STRING,(va_list*)szValues
					  );

		}
	}

	lstrcpy(pTaskProps->szTaskMonths, GetResString(IDS_TASK_PROPERTY_NA));

	switch(Trigger.TriggerType)
	{
		case TASK_TIME_TRIGGER_ONCE:
			
			lstrcpy(pTaskProps->szTaskType, GetResString(IDS_TASK_PROPERTY_ONCE));
			lstrcpy(pTaskProps->szTaskEndDate,GetResString(IDS_TASK_PROPERTY_NA));
			lstrcpy(pTaskProps->szTaskMonths, GetResString(IDS_TASK_PROPERTY_NA));
			lstrcpy(pTaskProps->szTaskDays,GetResString(IDS_TASK_PROPERTY_NA) );
			break;
		
		case TASK_TIME_TRIGGER_DAILY :
			
			szToken = _tcstok( szScheduleName, seps );
			if ( szToken != NULL )
			{
				szToken = _tcstok( NULL , seps );
				if ( szToken != NULL )
				{
					szToken = _tcstok( NULL , seps );
				}
				
				if ( szToken != NULL )
				{
					if (lstrcmpi(szToken, GetResString( IDS_TASK_HOURLY )) == 0)
					{
						bHour = TRUE;
					}
					else if (lstrcmpi(szToken, GetResString( IDS_TASK_MINUTE )) == 0)
					{
						bMin = TRUE;
					}
				}

			}

			if ( bHour == TRUE )
			{
				lstrcpy(pTaskProps->szTaskType, GetResString(IDS_TASK_PROPERTY_HOURLY));
			}
			else if ( bMin == TRUE )
			{
				lstrcpy(pTaskProps->szTaskType, GetResString(IDS_TASK_PROPERTY_MINUTE));
			}
			else
			{
			lstrcpy(pTaskProps->szTaskType, GetResString(IDS_TASK_PROPERTY_DAILY));
			}

			lstrcpy(pTaskProps->szTaskDays, GetResString(IDS_DAILY_TYPE));
			
			break;
			
		case TASK_TIME_TRIGGER_WEEKLY :

			lstrcpy(pTaskProps->szTaskType, GetResString(IDS_TASK_PROPERTY_WEEKLY));
			CheckWeekDay(Trigger.Type.Weekly.rgfDaysOfTheWeek,szWeekDay);

			lstrcpy(pTaskProps->szTaskDays,szWeekDay);
			break;
	
		case TASK_TIME_TRIGGER_MONTHLYDATE :
			{
			
				lstrcpy(pTaskProps->szTaskType, GetResString(IDS_TASK_PROPERTY_MONTHLY));
				CheckMonth(Trigger.Type.MonthlyDate.rgfMonths ,szMonthDay);

				DWORD dwDays = (Trigger.Type.MonthlyDate.rgfDays);
				DWORD dwModdays = 0;
				DWORD  dw  = 0x0; //loop counter
				DWORD dwTemp = 0x1;
				DWORD dwBits = sizeof(DWORD) * 8; //total no. of bits in a DWORD.
				
				//find out the day no.by finding out which particular bit is set

				for(dw = 0; dw <= dwBits; dw++)
				{			
					if( (dwDays  & dwTemp) == dwDays )
						dwModdays = dw + 1;
					dwTemp = dwTemp << 1;

				}

								
				FORMAT_STRING(pTaskProps->szTaskDays,_T("%d"),dwModdays);
				
				lstrcpy(pTaskProps->szTaskMonths,szMonthDay);
				}
			break;

		case TASK_TIME_TRIGGER_MONTHLYDOW:
			
			lstrcpy(pTaskProps->szTaskType,GetResString(IDS_TASK_PROPERTY_MONTHLY));
			CheckWeek(Trigger.Type.MonthlyDOW.wWhichWeek,szWeek);
			CheckWeekDay(Trigger.Type.MonthlyDOW.rgfDaysOfTheWeek,szWeekDay);

			lstrcpy(pTaskProps->szTaskDays,szWeekDay);
			CheckMonth(Trigger.Type.MonthlyDOW.rgfMonths,szMonthDay);
			FORMAT_STRING(pTaskProps->szTaskMonths,_T("%s"),szMonthDay);
			break;

		case TASK_EVENT_TRIGGER_ON_IDLE :

			lstrcpy(pTaskProps->szTaskType, GetResString(IDS_TASK_IDLE));
			lstrcpy(pTaskProps->szTaskDays,pTaskProps->szTaskMonths);
			lstrcpy(pTaskProps->szTaskEndDate, GetResString(IDS_TASK_PROPERTY_NA));

			if(pITaskTrigger)
				pITaskTrigger->Release();
			return S_OK;
	
		case TASK_EVENT_TRIGGER_AT_SYSTEMSTART :
			
			lstrcpy(pTaskProps->szTaskType, GetResString(IDS_TASK_SYSSTART));
			lstrcpy(pTaskProps->szTaskEndDate, GetResString(IDS_TASK_PROPERTY_NA));
			lstrcpy(pTaskProps->szTaskDays, pTaskProps->szTaskMonths);

			if(pITaskTrigger)
				pITaskTrigger->Release();
			return S_OK;

		case TASK_EVENT_TRIGGER_AT_LOGON :

			lstrcpy(pTaskProps->szTaskType, GetResString(IDS_TASK_LOGON));
			lstrcpy(pTaskProps->szTaskEndDate, GetResString(IDS_TASK_PROPERTY_NA));
			lstrcpy(pTaskProps->szTaskDays, pTaskProps->szTaskMonths);
			
			if(pITaskTrigger)
				pITaskTrigger->Release();
			return S_OK;
	
		default:

			lstrcpy(pTaskProps->szTaskType, GetResString(IDS_TASK_PROPERTY_UNDEF));
			lstrcpy(pTaskProps->szTaskEndDate, pTaskProps->szTaskType);
			lstrcpy(pTaskProps->szTaskDays, pTaskProps->szTaskType);
			lstrcpy(pTaskProps->szTaskStartTime, pTaskProps->szTaskType);
			lstrcpy(pTaskProps->szTaskStartDate, pTaskProps->szTaskType);
			if(pITaskTrigger)
				pITaskTrigger->Release();
			return S_OK;
			
	}
	
	//Determine whether the end date is specified.
	int iBuffSize = 0;//buffer to know how many TCHARs for end date
	SYSTEMTIME tEndDate = {0,0,0,0,0,0,0,0 };
	LCID lcid;
	BOOL bLocaleChanged = FALSE;

	// verify whether console supports the current locale fully or not
	lcid = GetSupportedUserLocale( bLocaleChanged );

	if((Trigger.rgFlags & TASK_TRIGGER_FLAG_HAS_END_DATE ) == TASK_TRIGGER_FLAG_HAS_END_DATE)
	{
		
		tEndDate.wMonth = Trigger.wEndMonth;
		tEndDate.wDay = Trigger.wEndDay;
		tEndDate.wYear = Trigger.wEndYear;

		iBuffSize = GetDateFormat(LOCALE_USER_DEFAULT,0,
			&tEndDate,(( bLocaleChanged == TRUE ) ? L"MM/dd/yyyy" : NULL),pTaskProps->szTaskEndDate,0);
		if(iBuffSize)
		{
			GetDateFormat(LOCALE_USER_DEFAULT,0,
			 &tEndDate,(( bLocaleChanged == TRUE ) ? L"MM/dd/yyyy" : NULL),pTaskProps->szTaskEndDate,iBuffSize);
		}
		else
		{
			lstrcpy( pTaskProps->szTaskEndDate , GetResString(IDS_TASK_PROPERTY_NA));
		}

	}
	
	else
	{
		lstrcpy(pTaskProps->szTaskEndDate,GetResString(IDS_QUERY_NOENDDATE));
	}

	if(pITaskTrigger)
		pITaskTrigger->Release();

	return S_OK;

}


/******************************************************************************

	Routine Description:

		This function checks the week modifier[ -monthly option] & returns the app.week 
		day. 

	Arguments:

		[ in ]	dwFlag	    : Flag indicating the week type
		[ out ] pWhichWeek  : address of pointer containing the week string

	Return Value :
		None	

******************************************************************************/ 

VOID
CheckWeek(DWORD dwFlag,_TCHAR* pWhichWeek)
{
	lstrcpy(pWhichWeek,NULL_STRING);


	if( dwFlag == TASK_FIRST_WEEK )
	{
		lstrcat(pWhichWeek, GetResString(IDS_TASK_FIRSTWEEK));
		lstrcat(pWhichWeek,COMMA_STRING);
	}

	if( dwFlag == TASK_SECOND_WEEK )
	{
		lstrcat(pWhichWeek, GetResString(IDS_TASK_SECONDWEEK));
		lstrcat(pWhichWeek,COMMA_STRING);
	}

	if( dwFlag == TASK_THIRD_WEEK )
	{
		lstrcat(pWhichWeek, GetResString(IDS_TASK_THIRDWEEK));
		lstrcat(pWhichWeek,COMMA_STRING);
	}

	if( dwFlag == TASK_FOURTH_WEEK )
	{
		lstrcat(pWhichWeek, GetResString(IDS_TASK_FOURTHWEEK));
		lstrcat(pWhichWeek,COMMA_STRING);
	}

	if( dwFlag == TASK_LAST_WEEK )
	{
		lstrcat(pWhichWeek, GetResString(IDS_TASK_LASTWEEK));
		lstrcat(pWhichWeek,COMMA_STRING);
	}

	int iLen = lstrlen(pWhichWeek);
	if(iLen)
		*( ( pWhichWeek ) + iLen - lstrlen( COMMA_STRING ) ) = NULL_CHAR;
		

}

/******************************************************************************

	Routine Description:

		This function checks the days in the week  & returns the app. day. 
 
	Arguments:

		[ in ]  dwFlag	  	: Flag indicating the day type
		[ out ] pWeekDay 	: resulting day string

	Return Value :
		None

******************************************************************************/ 

VOID
CheckWeekDay(DWORD dwFlag,_TCHAR* pWeekDay)
{
	lstrcpy(pWeekDay,NULL_STRING);

	if((dwFlag & TASK_SUNDAY) == TASK_SUNDAY)
	{
		
		lstrcat(pWeekDay, GetResString(IDS_TASK_SUNDAY));
		lstrcat(pWeekDay,COMMA_STRING);
	
	}
	
	if((dwFlag & TASK_MONDAY) == TASK_MONDAY)
	{
		lstrcat(pWeekDay, GetResString(IDS_TASK_MONDAY));
		lstrcat(pWeekDay,COMMA_STRING);
	}

	if((dwFlag & TASK_TUESDAY) == TASK_TUESDAY)
	{
		lstrcat(pWeekDay, GetResString(IDS_TASK_TUESDAY));
		lstrcat(pWeekDay,COMMA_STRING);
	}

	if((dwFlag & TASK_WEDNESDAY) == TASK_WEDNESDAY)
	{
		lstrcat(pWeekDay, GetResString(IDS_TASK_WEDNESDAY));
		lstrcat(pWeekDay,COMMA_STRING);
	}

	if((dwFlag & TASK_THURSDAY) == TASK_THURSDAY)
	{
		lstrcat(pWeekDay, GetResString(IDS_TASK_THURSDAY));
		lstrcat(pWeekDay,COMMA_STRING);
	}

	if((dwFlag& TASK_FRIDAY) == TASK_FRIDAY)
	{
		lstrcat(pWeekDay, GetResString(IDS_TASK_FRIDAY));
		lstrcat(pWeekDay,COMMA_STRING);
	}

	if((dwFlag & TASK_SATURDAY)== TASK_SATURDAY)
	{
		lstrcat(pWeekDay, GetResString(IDS_TASK_SATURDAY));
		lstrcat(pWeekDay,COMMA_STRING);
	}

	//Remove the comma from the end of the string.
	int iLen = lstrlen(pWeekDay);
	if(iLen)
	{
		*( ( pWeekDay ) + iLen - lstrlen( COMMA_STRING ) ) = NULL_CHAR;
	}

}

/******************************************************************************

	Routine Description:

		This function checks the months in a year & returns the app.Month(s)
 

	Arguments:

		[ in ]  dwFlag	    : Flag indicating the Month type
		[ out ] pWhichMonth : resulting Month string

	Return Value :
		None

******************************************************************************/ 

VOID
CheckMonth(DWORD dwFlag,_TCHAR* pWhichMonth)
{
	lstrcpy(pWhichMonth,NULL_STRING);

	if((dwFlag & TASK_JANUARY) == TASK_JANUARY)
	{
		lstrcat(pWhichMonth, GetResString(IDS_TASK_JANUARY));
		lstrcat(pWhichMonth,COMMA_STRING);

	}

	if((dwFlag & TASK_FEBRUARY) == TASK_FEBRUARY)
	{
		lstrcat(pWhichMonth, GetResString(IDS_TASK_FEBRUARY));
		lstrcat(pWhichMonth,COMMA_STRING);
	}

	if((dwFlag & TASK_MARCH) == TASK_MARCH)
	{
		lstrcat(pWhichMonth, GetResString(IDS_TASK_MARCH));
		lstrcat(pWhichMonth,COMMA_STRING);
	}

	if((dwFlag & TASK_APRIL) == TASK_APRIL)
	{
		lstrcat(pWhichMonth, GetResString(IDS_TASK_APRIL));
		lstrcat(pWhichMonth,COMMA_STRING);
	}

	if((dwFlag & TASK_MAY) == TASK_MAY)
	{
		lstrcat(pWhichMonth, GetResString(IDS_TASK_MAY));
		lstrcat(pWhichMonth,COMMA_STRING);
	}

	if((dwFlag& TASK_JUNE) == TASK_JUNE)
	{
		lstrcat(pWhichMonth, GetResString(IDS_TASK_JUNE));
		lstrcat(pWhichMonth,COMMA_STRING);

	}

	if((dwFlag & TASK_JULY)== TASK_JULY)
	{
		lstrcat(pWhichMonth, GetResString(IDS_TASK_JULY));
		lstrcat(pWhichMonth,COMMA_STRING);
	}

	if((dwFlag & TASK_AUGUST)== TASK_AUGUST)
	{
		lstrcat(pWhichMonth, GetResString(IDS_TASK_AUGUST));
		lstrcat(pWhichMonth,COMMA_STRING);
	}
	
	if((dwFlag & TASK_SEPTEMBER)== TASK_SEPTEMBER)
	{
		lstrcat(pWhichMonth, GetResString(IDS_TASK_SEPTEMBER));
		lstrcat(pWhichMonth,COMMA_STRING);
	}

	if((dwFlag & TASK_OCTOBER)== TASK_OCTOBER)
	{
		lstrcat(pWhichMonth, GetResString(IDS_TASK_OCTOBER));
		lstrcat(pWhichMonth,COMMA_STRING);
	}

	if((dwFlag & TASK_NOVEMBER)== TASK_NOVEMBER)
	{
		lstrcat(pWhichMonth, GetResString(IDS_TASK_NOVEMBER));
		lstrcat(pWhichMonth,COMMA_STRING);
	}

	if((dwFlag & TASK_DECEMBER)== TASK_DECEMBER)
	{
		lstrcat(pWhichMonth, GetResString(IDS_TASK_DECEMBER));
		lstrcat(pWhichMonth,COMMA_STRING);
	}

	int iLen = lstrlen(pWhichMonth);

	//Remove the comma from the end of the string.
	if(iLen)
	{
		*( ( pWhichMonth ) + iLen - lstrlen( COMMA_STRING ) ) = NULL_CHAR;
	}
}

/******************************************************************************

	Routine Description:

		This function checks whether the current locale supported by our tool or not.

	Arguments:

		[ out ] bLocaleChanged : Locale change flag

	Return Value :
		None

******************************************************************************/ 
LCID GetSupportedUserLocale( BOOL& bLocaleChanged )
{
	// local variables
    LCID lcid;

	// get the current locale
	lcid = GetUserDefaultLCID();

	// check whether the current locale is supported by our tool or not
	// if not change the locale to the english which is our default locale
	bLocaleChanged = FALSE;
    if ( PRIMARYLANGID( lcid ) == LANG_ARABIC || PRIMARYLANGID( lcid ) == LANG_HEBREW ||
         PRIMARYLANGID( lcid ) == LANG_THAI   || PRIMARYLANGID( lcid ) == LANG_HINDI  ||
         PRIMARYLANGID( lcid ) == LANG_TAMIL  || PRIMARYLANGID( lcid ) == LANG_FARSI )
    {
		bLocaleChanged = TRUE;
        lcid = MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_DEFAULT ), SORT_DEFAULT ); // 0x409;
    }

	// return the locale
    return lcid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scheduledtasks\run.h ===
/******************************************************************************

	Copyright(c) Microsoft Corporation

	Module Name:

		run.h

	Abstract:

		This module contains the macros, user defined structures & function 
		definitions needed by run.cpp 

	Author:

		Venu Gopal Choudary   12-Mar-2001 

	Revision History:

		Venu Gopal Choudary   12-Mar-2001  : Created it
	
		
******************************************************************************/ 

#ifndef __RUN_H
#define __RUN_H

#pragma once
#define OI_RUNSERVER			1 // Index of -s option in cmdOptions structure.
#define OI_RUNUSERNAME			4 // Index of -u option in cmdOptions structure.
#define OI_RUNPASSWORD			5 // Index of -p option in cmdOptions structure.

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scriptpw\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scriptpw\password.cpp ===
// Password.cpp : Implementation of CPassword
#include "stdafx.h"
#include "ScriptPW.h"
#include "Password.h"
#include <conio.h>

#define MAX_PASSWORD_SIZE 256
#define CARRIAGE_RETURN 0x0D



/////////////////////////////////////////////////////////////////////////////
// CPassword


STDMETHODIMP CPassword::GetPassword(BSTR *bstrOutPassword)
{
	// TODO: Add your implementation code here
	HANDLE hConsoleInput;
	TCHAR	*tstrPassword;
	TCHAR wch;
	int i=0;

	DWORD nNumberOfCharsToRead=1;
	DWORD dwNumberOfCharsRead;
	DWORD dwPrevConsoleMode;

	hConsoleInput = GetStdHandle(STD_INPUT_HANDLE);

	GetConsoleMode(hConsoleInput, &dwPrevConsoleMode);
	
	if(!SetConsoleMode(hConsoleInput,ENABLE_PROCESSED_INPUT))
		return E_FAIL;
	
	tstrPassword = (TCHAR *)malloc(MAX_PASSWORD_SIZE * sizeof(TCHAR));

	if(tstrPassword == NULL)
		return E_FAIL;

	while(1)
	{
		if(!ReadConsole(hConsoleInput,         // handle to console input buffer
					&wch,					// data buffer
					nNumberOfCharsToRead,   // number of characters to read
					&dwNumberOfCharsRead,  // number of characters read
					NULL))
		{
			//Set the original console settings
			SetConsoleMode(hConsoleInput, dwPrevConsoleMode);
			//Free the memory
			if(tstrPassword)
				free(tstrPassword);
			return E_FAIL;

		}
		if(wch == CARRIAGE_RETURN)
			break;
		*(tstrPassword+i) = wch;
		i++;
		if(i == MAX_PASSWORD_SIZE)
			break;
	}

	*(tstrPassword+i) = _T('\0');

	CComBSTR bstrPassword(tstrPassword);
	*bstrOutPassword = bstrPassword.Copy();

	//Set the original console settings
	SetConsoleMode(hConsoleInput, dwPrevConsoleMode);

	//Free the memory
	if(tstrPassword)
		free(tstrPassword);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scheduledtasks\scheduledtasks.cpp ===
/******************************************************************************

	Copyright(c) Microsoft Corporation

	Module Name:

		ScheduledTasks.cpp

	Abstract:

		This module initialises the OLE library,Interfaces, & reads the  input data 
		from the command line.This module calls the appropriate functions for acheiving
		the functionality of different options.

	Author:

		Raghu B  10-Sep-2000

	Revision History:

		Raghu B  10-Sep-2000 : Created it
	
		G.Surender Reddy 25-sep-2000 : Modified it
									   [ Added error checking ]

		G.Surender Reddy 10-oct-2000 : Modified it
									   [ Moved the strings to Resource table ]

		Venu Gopal Choudary 01-Mar-2001 : Modified it
									    [ Added -change option]	

		Venu Gopal Choudary 12-Mar-2001 : Modified it
									    [ Added -run and -end options]	

******************************************************************************/ 

//common header files needed for this file
#include "pch.h"
#include "CommonHeaderFiles.h"


//Helper functions used internally from this file
HRESULT Init( ITaskScheduler **pITaskScheduler );
VOID displayMainUsage();
BOOL preProcessOptions( DWORD argc, LPCTSTR argv[], PBOOL pbUsage, PBOOL pbCreate, 
	PBOOL pbQuery, PBOOL pbDelete, PBOOL pbChange, PBOOL pbRun, PBOOL pbEnd, PBOOL pbDefVal );

/******************************************************************************

	Routine Description:

		This function process the options specified in the command line & routes to
		different appropriate options [-create,-query,-delete,-change,-run,-end] 
		handling functions.This is the MAIN entry point for this utility.

	Arguments:

		[ in ] argc : The count of arguments specified in the command line
		[ in ] argv : Array of command line arguments

	Return Value :
		A DWORD value indicating EXIT_SUCCESS on success else 
		EXIT_FAILURE on failure

******************************************************************************/ 


DWORD _cdecl
_tmain( DWORD argc, LPCTSTR argv[] )
{
	// Declaring the main option switches as boolean values
	BOOL	bUsage	= FALSE;
	BOOL	bCreate = FALSE;
	BOOL	bQuery  = FALSE;
	BOOL	bDelete = FALSE;
	BOOL	bChange = FALSE;
	BOOL	bRun	= FALSE;
	BOOL	bEnd	= FALSE;
	BOOL    bDefVal	= FALSE;

	DWORD	dwRetStatus = EXIT_SUCCESS;
	HRESULT hr = S_OK;
	
	 // Call the preProcessOptions function to find out the option selected by the user
	 BOOL bValue = preProcessOptions( argc , argv , &bUsage , &bCreate , &bQuery , &bDelete , 
										&bChange , &bRun , &bEnd , &bDefVal );


	if(bValue == FALSE)
	{
		ReleaseGlobals();
		return EXIT_FAILURE;
	}

	// If ScheduledTasks.exe /?
	if( bUsage &&  ( bCreate + bQuery + bDelete + bChange + bRun + bEnd ) == 0 ) 
	{
		displayMainUsage();
		ReleaseGlobals();
		return EXIT_SUCCESS;
	}

	// If ScheduledTasks.exe -create option is selected
	if( bCreate  == TRUE)
	{
		hr = CreateScheduledTask( argc, argv );

		ReleaseGlobals();

		if ( FAILED(hr) )
		{
			return EXIT_FAILURE;
		}
		else
		{
			return EXIT_SUCCESS;
		}
				
	}
	
	// If ScheduledTasks.exe -Query option is selected
	if( bQuery == TRUE )
	{
		dwRetStatus = QueryScheduledTasks( argc, argv );
		ReleaseGlobals();
		return dwRetStatus;
	}

	// If ScheduledTasks.exe -delete option is selected
	if( bDelete  == TRUE)
	{
		dwRetStatus = DeleteScheduledTask( argc, argv );
		ReleaseGlobals();
		return dwRetStatus;
	}

	// If ScheduledTasks.exe -change option is selected
	if( bChange  == TRUE)
	{
		dwRetStatus = ChangeScheduledTaskParams( argc, argv );
		ReleaseGlobals();
		return dwRetStatus;
	}

	// If ScheduledTasks.exe -run option is selected
	if( bRun  == TRUE)
	{
		dwRetStatus = RunScheduledTask( argc, argv );
		ReleaseGlobals();
		return dwRetStatus;
	}

	// If ScheduledTasks.exe -end option is selected
	if( bEnd  == TRUE)
	{
		dwRetStatus = TerminateScheduledTask( argc, argv );
		ReleaseGlobals();
		return dwRetStatus;
	}

	// If ScheduledTasks.exe option is selected
	if( bDefVal == TRUE )
	{
		dwRetStatus = QueryScheduledTasks( argc, argv );
		ReleaseGlobals();
		return dwRetStatus;
	}
	
	ReleaseGlobals();
	return	dwRetStatus;	
      
}

/******************************************************************************

	Routine Description:

		This function process the options specified in the command line & routes to
		different appropriate functions.

	Arguments:

		[ in ]  argc		 : The count of arguments specified in the command line
		[ in ]  argv	   	 : Array of command line arguments
		[ out ] pbUsage		 : pointer to flag for determining [usage] -? option  
		[ out ] pbCreate	 : pointer to flag for determining -create option 
		[ out ] pbQuery	     : pointer to flag for determining -query option  
		[ out ] pbDelete	 : pointer to flag for determining -delete option  
		[ out ] pbChange	 : pointer to flag for determining -change option  
		[ out ] pbRun		 : pointer to flag for determining -run option  
		[ out ] pbEnd		 : pointer to flag for determining -end option  
		[ out ] pbDefVal	 : pointer to flag for determining default value 

	Return Value :
		A BOOL value indicating TRUE on success else FALSE

******************************************************************************/ 

BOOL
preProcessOptions( DWORD argc, LPCTSTR argv[] , PBOOL pbUsage, PBOOL pbCreate, 
 PBOOL pbQuery, PBOOL pbDelete , PBOOL pbChange , PBOOL pbRun , PBOOL pbEnd , PBOOL pbDefVal )
{
	
	BOOL bOthers = FALSE;
	BOOL bParse = FALSE;

	//fill in the TCMDPARSER array
	TCMDPARSER cmdOptions[] = {
		{
			CMDOPTION_CREATE,
			0,
			OPTION_COUNT,
			0,
			pbCreate,
			NULL_STRING,
			NULL,
			NULL
		},
		{ 
			CMDOPTION_QUERY,
			0,
			OPTION_COUNT,
			0,
			pbQuery,
			NULL_STRING,
			NULL,
			NULL
		},
		{ 
			CMDOPTION_DELETE,
			0,
			OPTION_COUNT,
			0,
			pbDelete,
			NULL_STRING,
			NULL,
			NULL
		},
		{
			CMDOPTION_USAGE,
			CP_USAGE ,
			OPTION_COUNT,
			0,
			pbUsage,
			NULL_STRING,
			NULL,
			NULL
		},
		{
			CMDOPTION_CHANGE,
			0,
			OPTION_COUNT,
			0,
			pbChange,
			NULL_STRING,
			NULL,
			NULL
		},
		{
			CMDOPTION_RUN,
			0,
			OPTION_COUNT,
			0,
			pbRun,
			NULL_STRING,
			NULL,
			NULL
		},
		{
			CMDOPTION_END,
			0,
			OPTION_COUNT,
			0,
			pbEnd,
			NULL_STRING,
			NULL,
			NULL
		},
		{ 
			CMDOTHEROPTIONS,
			CP_DEFAULT,
			0,
			0,
			&bOthers,
			NULL_STRING,
			NULL,
			NULL
		}	
	};
	
	
 //if there is an error display app. error message
    if (( ( DoParseParam( argc, argv,SIZE_OF_ARRAY(cmdOptions), cmdOptions ) == FALSE ) && 
         ( bParse = TRUE ) ) || 
         ((*pbCreate + *pbQuery + *pbDelete + *pbChange + *pbRun + *pbEnd)> 1 ) || 
         ( *pbUsage && bOthers ) || 
         (( *pbCreate + *pbQuery + *pbDelete + *pbChange + *pbRun + *pbEnd + *pbUsage ) == 0 ) 
       )
	{
		if ( bParse == TRUE )
		{
			DISPLAY_MESSAGE( stderr, GetResString(IDS_LOGTYPE_ERROR ));
			DISPLAY_MESSAGE( stderr, GetReason() );
			return FALSE;
		}
		else if ( ( *pbCreate + *pbQuery + *pbDelete + *pbChange + *pbRun + *pbEnd + *pbUsage ) > 1 )
		{
			DISPLAY_MESSAGE( stderr, GetResString(IDS_RES_ERROR ));
			return FALSE;
		}
		else if( *pbCreate == TRUE )
		{
			DISPLAY_MESSAGE(stderr, GetResString(IDS_CREATE_USAGE));
			return FALSE;
		}
		else if( *pbQuery == TRUE )
		{
			DISPLAY_MESSAGE(stderr, GetResString(IDS_QUERY_USAGE));
			return FALSE;
		}
		else if( *pbDelete == TRUE )
		{
			DISPLAY_MESSAGE(stderr, GetResString(IDS_DELETE_SYNERROR));
			return FALSE;
		}
		else if( *pbChange == TRUE )
		{
			DISPLAY_MESSAGE(stderr, GetResString(IDS_CHANGE_SYNERROR));
			return FALSE;
		}
		else if( *pbRun == TRUE )
		{
			DISPLAY_MESSAGE(stderr, GetResString(IDS_RUN_SYNERROR));
			return FALSE;
		}
		else if( *pbEnd == TRUE )
		{
			DISPLAY_MESSAGE(stderr, GetResString(IDS_END_SYNERROR));
			return FALSE;
		}
		else if( ( *pbUsage && bOthers ) || ( !( *pbQuery ) && ( bOthers ) ) )
		{
			DISPLAY_MESSAGE( stderr, GetResString(IDS_RES_ERROR ));
			return FALSE;
		}
		else
		{
			*pbDefVal = TRUE;
		}	
	}

	return TRUE;
}

/******************************************************************************

	Routine Description:

		This function fetches the ITaskScheduler Interface.It also connects to 
		the remote machine if specified & 	helps  to operate 
		ITaskScheduler on the specified target m/c.

	Arguments:

		[ in ] szServer   : server's name 
		
	Return Value :
		ITaskScheduler interface pointer on success else NULL

******************************************************************************/ 

ITaskScheduler*
GetTaskScheduler( LPCTSTR szServer )
{
	HRESULT hr = S_OK;
	ITaskScheduler *pITaskScheduler = NULL;
	WCHAR wszComputerName[ MAX_RES_STRING ] = NULL_U_STRING;
	WCHAR wszActualComputerName[ 2 * MAX_RES_STRING ] = DOMAIN_U_STRING;
	wchar_t* pwsz = NULL_U_STRING; 
	WORD wSlashCount = 0 ;

	hr = Init( &pITaskScheduler );		

	if( FAILED(hr))
	{
		DisplayErrorMsg(hr);
		return NULL;
	}
	
	//If the operation is on remote machine
	if( lstrlen(szServer) > 0 )
	{
		// Convert the server name specified by the user to wide char or unicode format
		if ( GetAsUnicodeString(szServer,wszComputerName, SIZE_OF_ARRAY(wszComputerName)) == NULL )
		{
			return NULL;
		}
		
		if( wszComputerName != NULL )
		{
			pwsz =  wszComputerName;
			while ( ( *pwsz != NULL_U_CHAR ) && ( *pwsz == BACK_SLASH_U )  )
			{
				pwsz = _wcsinc(pwsz);
				wSlashCount++;
			}

			if( (wSlashCount == 2 ) ) // two back slashes are present
			{
				wcscpy( wszActualComputerName, wszComputerName );
			}
			else if ( wSlashCount == 0 )
			{
				//Append "\\" to computer name
				wcscat(wszActualComputerName,wszComputerName); 	
			}
			else
			{
				DISPLAY_MESSAGE (stderr, GetResString ( IDS_INVALID_NET_ADDRESS ));
				return NULL;
			}
	
		}

		hr = pITaskScheduler->SetTargetComputer( wszActualComputerName );

	}
	else
	{
		//Local Machine
		hr = pITaskScheduler->SetTargetComputer( NULL );
	}

	if( FAILED( hr ) )
	{
		DisplayErrorMsg(hr);
		return NULL;
	}
				
	return pITaskScheduler;
}

/******************************************************************************

	Routine Description:

		This function initialises the COM library & fetches the ITaskScheduler interface.

	Arguments:

		[ in ] pITaskScheduler  : double pointer to taskscheduler interface

	Return Value:

		A HRESULT  value indicating success code else failure code
  
******************************************************************************/ 

HRESULT
Init( ITaskScheduler **pITaskScheduler )
{
	// Initalize the HRESULT value.
    HRESULT hr = S_OK;

    // Bring in the library
    hr = CoInitializeEx( NULL , COINIT_APARTMENTTHREADED );
    if (FAILED(hr))
    {
        return hr;
    }

	hr = CoInitializeSecurity(NULL, -1, NULL, NULL,
								RPC_C_AUTHN_LEVEL_NONE, 
								RPC_C_IMP_LEVEL_IMPERSONATE, 
								NULL, EOAC_NONE, 0 );
	if (FAILED(hr))
    {
        CoUninitialize();
		return hr;
    }
	
    

    // Create the pointer to Task Scheduler object
    // CLSID from the header file mstask.h
	// Fill the task schdeuler object.
    hr = CoCreateInstance( CLSID_CTaskScheduler, NULL, CLSCTX_ALL, 
						   IID_ITaskScheduler,(LPVOID*) pITaskScheduler );
	
    // Should we fail, unload the library
    if (FAILED(hr))
    {
        CoUninitialize();
    }
	
    return hr;
}



/******************************************************************************

	Routine Description:

		This function releases the ITaskScheduler & unloads the COM library

	Arguments:

		[ in ] pITaskScheduler : pointer to the ITaskScheduler

	Return Value :
		VOID
  
******************************************************************************/ 

VOID
Cleanup( ITaskScheduler *pITaskScheduler )
{
	if (pITaskScheduler)
    {
        pITaskScheduler->Release();
      
    }
   
    // Unload the library, now that our pointer is freed.
    CoUninitialize();
	return;
    
}


/******************************************************************************

	Routine Description:

		This function displays the main  usage help of this utility

	Arguments:

		None

	Return Value :
		VOID

******************************************************************************/ 

VOID
displayMainUsage()
{

	DisplayUsage( IDS_MAINHLP1, IDS_MAINHLP21);
	return;
	
}

/******************************************************************************

	Routine Description:

		This function deletes the .job extension from the task name

	Arguments:

		[ in ] lpszTaskName : Task name

	Return Value :
		None
  
******************************************************************************/ 

DWORD
ParseTaskName( LPTSTR lpszTaskName )
{

	if(lpszTaskName == NULL)
		return ERROR_INVALID_PARAMETER;

	// Remove the .Job extension from the task name
	lpszTaskName[lstrlen(lpszTaskName ) - lstrlen(JOB) ] = NULL_CHAR;
	return EXIT_SUCCESS;
}

/******************************************************************************

	Routine Description:

		This function displays the appropriate error message w.r.t HRESULT value

	Arguments:

		[ in ] hr : An HRESULT value

	Return Value :
		VOID
  
******************************************************************************/

VOID
DisplayErrorMsg(HRESULT hr)
{	
	TCHAR szErrorDesc[ MAX_RES_STRING ] = NULL_STRING;
	TCHAR szErrorString[ 2*MAX_RES_STRING ] = NULL_STRING;

	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, hr,
			      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
				  szErrorDesc,SIZE_OF_ARRAY(szErrorDesc), NULL);

	//Append ERROR: string in front of the actual error message
	lstrcpy( szErrorString, GetResString(IDS_ERROR_STRING) );
	lstrcat( szErrorString,szErrorDesc );
	DISPLAY_MESSAGE( stderr, szErrorString );

	return;
}

/******************************************************************************

	Routine Description:

		This function displays the messages for usage of different option

	Arguments:

		[ in ] StartingMessage : First string to display
		[ in ] EndingMessage   : Last string to display

	Return Value :
		DWORD
  
******************************************************************************/

DWORD DisplayUsage( ULONG StartingMessage, ULONG EndingMessage )
{
     ULONG       ulCounter = 0;
     LPCTSTR     lpszCurrentString = NULL;
 
     for( ulCounter = StartingMessage; ulCounter <= EndingMessage; ulCounter++ ) 
	 {
         lpszCurrentString = GetResString( ulCounter );
 
         if( lpszCurrentString != NULL ) 
		 {
             DISPLAY_MESSAGE( stdout, lpszCurrentString );
         } 
		 else 
		 {
             return ERROR_INVALID_PARAMETER;
         }
 
	 }
	return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scheduledtasks\scheduledtasks.h ===
/******************************************************************************

	Copyright(c) Microsoft Corporation

	Module Name:

		ScheduledTasks.h

	Abstract:

		This module contains the macros, user defined structures & function 
		definitions needed by ScheduledTasks.cpp , create.cpp , delete.cpp , 
		query.cpp , createvalidations.cpp , change.cpp , run.cpp and end.cpp files.

	Author:

		G.Surender Reddy  10-sept-2000 

	Revision History:

		G.Surender Reddy 10-sept-2000 : Created it
		G.Surender Reddy 25-sep-2000 : Modified it
									   [ Added macro constants,Function 
									    definitions ]
		Venu Gopal Choudary 01-Mar-2001 : Modified it
									    [ Added -change option]	

		Venu Gopal Choudary 12-Mar-2001 : Modified it
									    [ Added -run and -end options]	
		
******************************************************************************/ 

#ifndef __SCHEDULEDTASKS_H
#define __SCHEDULEDTASKS_H

#pragma once		// include header file only once

// constants / defines / enumerations

// Options
#define CMDOPTION_CREATE                    _T( "create" )
#define CMDOPTION_DELETE					_T( "delete" )
#define CMDOPTION_QUERY						_T( "query" )
#define CMDOPTION_CHANGE					_T( "change" )
#define CMDOPTION_RUN						_T( "run" )
#define CMDOPTION_END						_T( "end" )
#define CMDOPTION_USAGE						_T( "?|help|h" )

#define CMDOTHEROPTIONS  _T( "s|ru|rp|f|sc|mo|d|m|i|tn|tr|st|sd|ed|fo|v|nh|u|p")
											   

// Other switches or sub-options
#define SWITCH_SERVER                       _T( "s" )
#define SWITCH_RUNAS_USER					_T( "ru" )	
#define SWITCH_RUNAS_PASSWORD				_T( "rp" )
#define SWITCH_USER							_T( "u" )	
#define SWITCH_PASSWORD						_T( "p" )
#define SWITCH_FORMAT						_T( "fo" )
#define SWITCH_VERBOSE						_T( "v")
#define SWITCH_FORCE                        _T( "f" )
#define SWITCH_SCHEDULETYPE                 _T( "sc" )
#define SWITCH_MODIFIER                     _T( "mo" )
#define SWITCH_DAY                          _T( "d" )
#define SWITCH_MONTHS                       _T( "m" )
#define SWITCH_IDLETIME                     _T( "i" )
#define SWITCH_TASKNAME                     _T( "tn" )
#define SWITCH_TASKRUN                      _T( "tr" )
#define SWITCH_STARTTIME                    _T( "st" )
#define SWITCH_STARTDATE                    _T( "sd" )
#define SWITCH_ENDDATE                      _T( "ed" )
#define SWITCH_NOHEADER                     _T( "nh" )

// Other constants

//To retrive 1 tasks at a time ,used in TaskScheduler API fns.
#define TASKS_TO_RETRIEVE	1
#define TRIM_SPACES TEXT(" \0")

#define NTAUTHORITY_USER _T("NT AUTHORITY\\SYSTEM")
#define SYSTEM_USER		 _T("SYSTEM")

// Exit values
#define EXIT_SUCCESS        0
#define EXIT_FAILURE        1  


#define DOMAIN_U_STRING		L"\\\\"
#define NULL_U_STRING		L""
#define NULL_U_CHAR			L'\0'
#define BACK_SLASH_U		L'\\'

#define JOB				_T(".job")

#define MAX_MESSAGE_LEN  2056
#define NULL_U_CHAR		 L'\0'
#define MAX_PASSWORD_LEN 64

#define COMMA_STRING	 _T(",")
#define TEMP_LOG_FILE	 _T("StdIn.log")

// Typedefs of standard string sizes
//typedef TCHAR STRING32 [ 32 ];
//typedef TCHAR STRING64 [ 64 ];
typedef TCHAR STRING100 [ 100 ];
typedef TCHAR STRING256 [ 256 ];

// Main functions
HRESULT CreateScheduledTask( DWORD argc , LPCTSTR argv[] );
DWORD DeleteScheduledTask( DWORD argc , LPCTSTR argv[] );
DWORD QueryScheduledTasks( DWORD argc , LPCTSTR argv[] );
DWORD ChangeScheduledTaskParams( DWORD argc , LPCTSTR argv[] );
DWORD RunScheduledTask( DWORD argc , LPCTSTR argv[] );
DWORD TerminateScheduledTask( DWORD argc , LPCTSTR argv[] );

VOID Cleanup( ITaskScheduler *pITaskScheduler);
ITaskScheduler* GetTaskScheduler( LPCTSTR pszServerName );
TARRAY ValidateAndGetTasks( ITaskScheduler * pITaskScheduler, LPCTSTR pszTaskName);
DWORD ParseTaskName( LPTSTR lpszTaskName );
void DisplayErrorMsg(HRESULT hr);
DWORD DisplayUsage( ULONG StartingMessage, ULONG EndingMessage );

#endif // __SCHEDULEDTASKS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scriptpw\password.h ===
// Password.h : Declaration of the CPassword

#ifndef __PASSWORD_H_
#define __PASSWORD_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPassword
class ATL_NO_VTABLE CPassword : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPassword, &CLSID_Password>,
	public IDispatchImpl<IPassword, &IID_IPassword, &LIBID_SCRIPTPWLib>
{
public:
	CPassword()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_PASSWORD)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPassword)
	COM_INTERFACE_ENTRY(IPassword)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IPassword
public:
	STDMETHOD(GetPassword)(/*[out, retval]*/ BSTR *bstrOutPassword);
};

#endif //__PASSWORD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scriptpw\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ScriptPW.rc
//
#define IDS_PROJNAME                    100
#define IDR_PASSWORD                    101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scriptpw\scriptpw.cpp ===
// ScriptPW.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ScriptPWps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ScriptPW.h"

#include "ScriptPW_i.c"
#include "Password.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Password, CPassword)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SCRIPTPWLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\scriptpw\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__CBE0A547_8DA2_4974_82A0_E68E9186DA77__INCLUDED_)
#define AFX_STDAFX_H__CBE0A547_8DA2_4974_82A0_E68E9186DA77__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__CBE0A547_8DA2_4974_82A0_E68E9186DA77__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\appearprop.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    srcprop.h

Abstract:

    Data Appear Property Page

--*/

#ifndef _APPEARPROP_H_07242000_
#define _APPEARPROP_H_07242000_

#include "smonprop.h"

// Dialog Controls
#define IDD_APPEAR_PROPP_DLG        600
#define IDC_COLOROBJECTS            601
#define IDC_COLORBUTTON             602
#define IDC_FONTBUTTON              604
#define IDC_FONTSAMPLE              605
#define IDC_STATIC_COLOR            606
#define IDC_STATIC_FONT             607
#define IDC_COLORSAMPLE             608

typedef enum ColorChoices {
    GraphColor,
    ControlColor,
    TextColor,
    GridColor,
    TimebarColor
};

// Data Appear property page class
class CAppearPropPage : public CSysmonPropPage
{
public:
   
    CAppearPropPage(void);
    virtual ~CAppearPropPage(void);

protected:

    virtual BOOL GetProperties(void);   //Read current properties
    virtual BOOL SetProperties(void);   //Set new properties
    virtual BOOL InitControls(void);
    virtual void DialogItemChange(WORD wId, WORD wMsg); // Handle item change
    virtual BOOL WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam); // Special msg processing 


private:    
    COLORREF m_Color;
    LOGFONT  m_Font;
    void ColorizeButton();
    void SampleFont();
};
typedef CAppearPropPage *PCAppearPropPage;

// {e49741e9-93a8-4ab1-8e96-bf4482282e9c}
DEFINE_GUID(CLSID_AppearPropPage,
    0xe49741e9, 0x93a8, 0x4ab1, 0x8e, 0x96, 0xbf, 0x44, 0x82, 0x28, 0x2e, 0x9c);

#endif //_APPEARPROP_H_07242000_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\appearprop.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    srcprop.cpp

Abstract:

    Implementation of the Appearance property page.

--*/

#include <windows.h>
#include <stdio.h>
#include <assert.h>
#include "polyline.h"
#include "appearprop.h"
#include "utils.h"
#include <pdhmsg.h>
#include "smonmsg.h"
#include "strids.h"
#include "unihelpr.h"
#include "winhelpr.h"
#include <Commdlg.h>

COLORREF        CustomColors[16];

CAppearPropPage::CAppearPropPage()
{
    m_uIDDialog = IDD_APPEAR_PROPP_DLG;
    m_uIDTitle = IDS_APPEAR_PROPP_TITLE;
}

CAppearPropPage::~CAppearPropPage(
    void
    )
{
    return;
}

BOOL
CAppearPropPage::InitControls ( void )
{
    BOOL    bResult = TRUE;
    HWND hWnd;

    for (int i=0; i<16; i++){
        CustomColors[i]=RGB(255, 255, 255);
    }

    hWnd = GetDlgItem( m_hDlg, IDC_COLOROBJECTS );
    if( NULL != hWnd ){
        CBInsert( hWnd, GraphColor, ResourceString(IDS_COLORCHOICE_GRAPH) );
        CBInsert( hWnd, ControlColor, ResourceString(IDS_COLORCHOICE_CONTROL) );
        CBInsert( hWnd, TextColor, ResourceString(IDS_COLORCHOICE_TEXT) );
        CBInsert( hWnd, GridColor, ResourceString(IDS_COLORCHOICE_GRID) );
        CBInsert( hWnd, TimebarColor, ResourceString(IDS_COLORCHOICE_TIMEBAR) );
        CBSetSelection( hWnd, 0 );
    }

    return bResult;
}

void 
CAppearPropPage::ColorizeButton()
{
    HBRUSH hbr;
    RECT rect;
    int shift = 3;
    
    HWND hWnd;

    hWnd = GetDlgItem( m_hDlg, IDC_COLOROBJECTS );
    if( hWnd != NULL ){

        ColorChoices sel = (ColorChoices)CBSelection( hWnd );

        COLORREF color = (COLORREF)CBData( hWnd, sel );
    
        HWND hDlg = GetDlgItem( m_hDlg, IDC_COLORSAMPLE );
        if( hDlg != NULL ){
            HDC hDC = GetWindowDC( hDlg );
            if( hDC != NULL ){

                hbr = CreateSolidBrush( color );
                GetClientRect( hDlg, &rect );
                rect.top += shift;
                rect.bottom += shift;
                rect.left += shift;
                rect.right += shift;

                if ( NULL != hbr ) {
                    FillRect(hDC, (LPRECT)&rect, hbr);
                }
                ReleaseDC( hDlg, hDC );
            }
        }
    }

}

void CAppearPropPage::SampleFont()
{
    HFONT hFont;
    HWND hSample = GetDlgItem( m_hDlg, IDC_FONTSAMPLE );
    if( hSample != NULL ){
        hFont = CreateFontIndirect( &m_Font );
        if( hFont != NULL ){
            SendMessage( hSample, WM_SETFONT, (WPARAM)hFont, (LPARAM)TRUE );
        }
    }
}

BOOL 
CAppearPropPage::WndProc(
    UINT uMsg, 
    WPARAM /* wParam */, 
    LPARAM /* lParam */)
{
    if( uMsg == WM_CTLCOLORBTN ){
        ColorizeButton();
        return TRUE;
    }
    return FALSE;   
}

/*
 * CAppearPropPage::GetProperties
 * 
 */

BOOL CAppearPropPage::GetProperties(void)
{
    BOOL    bReturn = TRUE;
    ISystemMonitor  *pObj;
    CImpISystemMonitor *pPrivObj;
    IFontDisp* pFontDisp;
    LPFONT  pIFont;
    HFONT hFont;
    HRESULT hr;
    HWND hWnd;

    if (m_cObjects == 0) {
        bReturn = FALSE;
    } else {
        pObj = m_ppISysmon[0];

        // Get pointer to actual object for internal methods
        pPrivObj = (CImpISystemMonitor*)pObj;
        pPrivObj->get_Font( &pFontDisp );

        if ( NULL == pFontDisp ) {
            bReturn = FALSE;
        } else {
            hr = pFontDisp->QueryInterface(IID_IFont, (PPVOID)&pIFont);
            if (SUCCEEDED(hr)) {
                pIFont->get_hFont( &hFont );
                GetObject( hFont, sizeof(LOGFONT), &m_Font );
                pIFont->Release();
            }

            SampleFont();
        }

        hWnd = GetDlgItem( m_hDlg, IDC_COLOROBJECTS );
        if( hWnd != NULL ){
            OLE_COLOR color;

            pPrivObj->get_BackColor( &color );
            CBSetData( hWnd, GraphColor, color );

            pPrivObj->get_BackColorCtl( &color );
            CBSetData( hWnd, ControlColor, color );

            pPrivObj->get_ForeColor( &color );
            CBSetData( hWnd, TextColor, color );

            pPrivObj->get_GridColor( &color );
            CBSetData( hWnd, GridColor, color );

            pPrivObj->get_TimeBarColor( &color );
            CBSetData( hWnd, TimebarColor, color );
            
            ColorizeButton();
        }
        
   
    }

    return bReturn;
}


/*
 * CAppearPropPage::SetProperties
 * 
 */

BOOL CAppearPropPage::SetProperties(void)
{
    BOOL bReturn = TRUE;
    IFontDisp* pFontDisp;
    ISystemMonitor  *pObj;
    CImpISystemMonitor *pPrivObj;

    if (m_cObjects == 0) {
        bReturn = FALSE;
    } else {
        
        FONTDESC fd;
        pObj = m_ppISysmon[0];
        pPrivObj = (CImpISystemMonitor*)pObj;

        fd.cbSizeofstruct = sizeof(FONTDESC);
        fd.lpstrName = m_Font.lfFaceName;
        fd.sWeight = (short)m_Font.lfWeight;
        fd.sCharset = m_Font.lfCharSet;
        fd.fItalic = m_Font.lfItalic;
        fd.fUnderline = m_Font.lfUnderline;
        fd.fStrikethrough = m_Font.lfStrikeOut;

        long lfHeight = m_Font.lfHeight;
        int ppi;
		HDC hdc;

        if (lfHeight < 0){
	        lfHeight = -lfHeight;
        }

		hdc = ::GetDC(GetDesktopWindow());
		ppi = GetDeviceCaps(hdc, LOGPIXELSY);
		::ReleaseDC(GetDesktopWindow(), hdc);

        fd.cySize.Lo = lfHeight * 720000 / ppi;
        fd.cySize.Hi = 0;
        
        OleCreateFontIndirect(&fd, IID_IFontDisp, (void**) &pFontDisp);
        
        pPrivObj->putref_Font( pFontDisp );   
        pFontDisp->Release();

        HWND hWnd = GetDlgItem( m_hDlg, IDC_COLOROBJECTS );
        if( hWnd != NULL ){
            OLE_COLOR color;

            color = (OLE_COLOR)CBData( hWnd, GraphColor );
            pPrivObj->put_BackColor( color );

            color = (OLE_COLOR)CBData( hWnd, ControlColor );
            pPrivObj->put_BackColorCtl( color );

            color = (OLE_COLOR)CBData( hWnd, TextColor );
            pPrivObj->put_ForeColor( color );

            color = (OLE_COLOR)CBData( hWnd, GridColor );
            pPrivObj->put_GridColor( color );

            color = (OLE_COLOR)CBData( hWnd, TimebarColor );
            pPrivObj->put_TimeBarColor( color );
        }


    }


    return bReturn;
}


void 
CAppearPropPage::DialogItemChange(
    WORD wID, 
    WORD /* wMsg */)
{
    BOOL bChanged = FALSE;

    switch(wID) {
    case IDC_COLOROBJECTS:
        ColorizeButton();
        break;
    case IDC_COLORSAMPLE:
    case IDC_COLORBUTTON:
        {
            CHOOSECOLOR     cc;
            OLE_COLOR       color;

            HWND hWnd = GetDlgItem( m_hDlg, IDC_COLOROBJECTS );
            
            if( NULL != hWnd ){
                
                ColorChoices sel = (ColorChoices)CBSelection( hWnd );
                color = (COLORREF)CBData( hWnd, sel );

                memset(&cc, 0, sizeof(CHOOSECOLOR));
                cc.lStructSize=sizeof(CHOOSECOLOR);
                cc.lpCustColors=CustomColors;
                cc.hwndOwner = m_hDlg;
                cc.Flags=CC_RGBINIT;
                cc.rgbResult = color;
                if( ChooseColor(&cc) ){
                    CBSetData( hWnd, sel, cc.rgbResult );
                    ColorizeButton();
                    bChanged = TRUE;
                }
            }
            
            break;
        }
    case IDC_FONTBUTTON:
    case IDC_FONTSAMPLE:
        {
            CHOOSEFONT  cf;
            LOGFONT lf;
            
            memset(&cf, 0, sizeof(CHOOSEFONT));
            memcpy( &lf, &m_Font, sizeof(LOGFONT) );

            cf.lStructSize = sizeof(CHOOSEFONT);
            cf.hwndOwner = m_hDlg;
            cf.lpLogFont = &lf;    // give initial font
            cf.Flags = CF_INITTOLOGFONTSTRUCT | CF_FORCEFONTEXIST | CF_SCREENFONTS;
            cf.nSizeMin = 5; 
            cf.nSizeMax = 50;

            if( ChooseFont(&cf) ){
                memcpy( &m_Font, &lf, sizeof(LOGFONT) );
                SampleFont();
                bChanged = TRUE;
            }
            break;
        }
    }

    if( bChanged == TRUE ){
        SetChange();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\appmema.cpp ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    appmema.cpp

Abstract:

    This file contains the memory allocation function "wrappers"
    to allow monitoring of the memory usage by a performance monitoring
    application (e.g. PERFMON).

--*/

#ifdef DO_TIMING_BUILD

#include <windows.h>
#include <assert.h>
#include "appmema.h"

HANDLE ThisDLLHandle = NULL;

HANDLE  hAppMemSharedMemory = NULL;     // Handle of counter Shared Memory

PAPPMEM_DATA_HEADER pDataHeader = NULL; // pointer to header of shared mem
PAPPMEM_INSTANCE    pAppData = NULL;    // pointer to the app data for this app

static
BOOL
DllProcessAttach (
    IN  HANDLE DllHandle
)
/*++

Description:

    Initializes the interface to the performance counters DLL by
    opening the Shared Memory file used to communicate statistics
    from the application to the counter DLL. If the Shared memory
    file does not exist, it is created, formatted and initialized.
    If the file has already been created and formatted, then the
    next available APPMEM_INSTANCE entry is moved from the free list
    to the InUse list and the corresponding pointer is saved for
    subsequent use by this application
   
--*/
{
    LONG    status;
    TCHAR   szMappedObject[] = SHARED_MEMORY_OBJECT_NAME;
    DWORD   dwBytes;

    // save this DLL handle
    ThisDLLHandle = DllHandle;

    // disable thread attach & detach calls to save the overhead
    // since we don't care about them.
    DisableThreadLibraryCalls (DllHandle);

    // open & initialize shared memory file
    SetLastError (ERROR_SUCCESS);   // just to clear it out

    // open/create shared memory used by the application to pass performance values
    status = GetSharedMemoryDataHeader (
        &hAppMemSharedMemory, NULL, &pDataHeader,
        FALSE); // read/write access is required
    // here the memory block should be initialized and ready for use
    if (status == ERROR_SUCCESS) {
        if (pDataHeader->dwFirstFreeOffset != 0) {
            // then there are blocks left so get the next free
            pAppData = FIRST_FREE(pDataHeader);
            // update free list to make next item the first in list
            pDataHeader->dwFirstFreeOffset = pAppData->dwOffsetOfNext;

            // insert the new item into the head of the in use list
            pAppData->dwOffsetOfNext = pDataHeader->dwFirstInUseOffset;
            pDataHeader->dwFirstInUseOffset = (DWORD)((LPBYTE)pAppData -
                                                      (LPBYTE)pDataHeader);

            // now initialize this instance's data
            pAppData->dwProcessId = GetCurrentProcessId(); // id of process using this instance

            dwBytes = sizeof (APP_DATA_SAMPLE) * TD_TOTAL;
            dwBytes += sizeof (DWORD) * DD_TOTAL;
            memset (&pAppData->TimeData[0], 0, dwBytes);

            pDataHeader->dwInstanceCount++;    // increment count
        } else {
            // no more free slots left
            assert (pDataHeader->dwFirstFreeOffset != 0);
        }
    } else {
        // unable to open shared memory file
        // even though this is an error we should return true so as to 
        // not abort the application. No performance data will be 
        // collected though.
    }
    return TRUE;
}

static
BOOL
DllProcessDetach (
    IN  HANDLE DllHandle
)
{
    PAPPMEM_INSTANCE    pPrevItem;

    // remove instance for this app
    if ((pAppData != NULL) && (pDataHeader != NULL)) {
        // zero the fields out first
        memset (pAppData, 0, sizeof (APPMEM_INSTANCE));
        // move from in use (busy) list back to the free list
        if ((pDataHeader->dwFirstFreeOffset != 0) && (pDataHeader->dwFirstInUseOffset != 0)) {
            // find previous item in busy list
            if (FIRST_INUSE(pDataHeader) != pAppData) {
                // not the first so walk down the list
                pPrevItem = FIRST_INUSE(pDataHeader);
                while (APPMEM_INST(pDataHeader, pPrevItem->dwOffsetOfNext) != pAppData) {
                    pPrevItem = APPMEM_INST(pDataHeader, pPrevItem->dwOffsetOfNext);
                    if (pPrevItem->dwOffsetOfNext == 0) break; // end of list
                }
                if (APPMEM_INST(pDataHeader, pPrevItem->dwOffsetOfNext) == pAppData) {
                    APPMEM_INST(pDataHeader, pPrevItem->dwOffsetOfNext)->dwOffsetOfNext =
                        pAppData->dwOffsetOfNext;
                } else {
                    // it was never in the busy list (?!?)
                }
            } else {
                // this is the first in the list so update it
                pDataHeader->dwFirstInUseOffset = pAppData->dwOffsetOfNext;
            }
            // here, pAppData has been removed from the InUse list and now
            // it must be inserted back at the beginning of the free list
            pAppData->dwOffsetOfNext = pDataHeader->dwFirstFreeOffset;
            pDataHeader->dwFirstFreeOffset = (DWORD)((LPBYTE)pAppData - (LPBYTE)pDataHeader);
        }
    }

    // decrement instance counter
    pDataHeader->dwInstanceCount--;    // decrement count

    // close shared memory file handle

    if (hAppMemSharedMemory != NULL) CloseHandle (hAppMemSharedMemory);

    // clear pointers
    hAppMemSharedMemory = NULL;
    pDataHeader = NULL;
    pAppData = NULL;

    return TRUE;
}

BOOL
__stdcall
AppPerfOpen(HINSTANCE   hInstance)
{
    return DllProcessAttach (hInstance);
}
BOOL
__stdcall
AppPerfClose(HINSTANCE  hInstance)
{
    return DllProcessDetach (hInstance);
}

void
UpdateAppPerfTimeData (
    DWORD   dwItemId,
    DWORD   dwStage
)
{
    LONGLONG    llTime;
    assert (dwItemId < TD_TOTAL);
    QueryPerformanceCounter ((LARGE_INTEGER *)&llTime);
//  GetSystemTimeAsFileTime ((LPFILETIME)&llTime);
    if (dwStage == TD_BEGIN) {
        assert (pAppData->TimeData[dwItemId].dw1 == 0); // this shouldn't be called while timing
        pAppData->TimeData[dwItemId].ll1 = llTime;  // save start time
        pAppData->TimeData[dwItemId].dw1++;     // indicate were counting
    } else {
        assert (pAppData->TimeData[dwItemId].dw1 == 1); // this should only be called while timing
        pAppData->TimeData[dwItemId].ll0 += llTime; // add in current time
        // then remove the start time
        pAppData->TimeData[dwItemId].ll0 -= pAppData->TimeData[dwItemId].ll1;
        // increment completed operation count
        pAppData->TimeData[dwItemId].dw0++;
        // decrement busy count
        pAppData->TimeData[dwItemId].dw1--;
    }
    return;
}

void
UpdateAppPerfDwordData (
    DWORD   dwItemId,
    DWORD   dwValue
)
{
    assert (dwItemId < DD_TOTAL);
    pAppData->DwordData[dwItemId] = dwValue;
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\appmema.h ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    appmema.h

Abstract:

    application memory performance counter definitions

--*/

#ifndef _APPMEMA_H_
#define _APPMEMA_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifdef DO_TIMING_BUILD

#include ".\perfdll\perfdll\appmemi.h"

extern struct  _APPMEM_DATA_HEADER *pDataHeader;
extern struct  _APPMEM_INSTANCE    *pAppData;

#define IncrementAppPerfDwordData(dwItemId) pAppData->DwordData[dwItemId]++;

BOOL
__stdcall
AppPerfOpen(HINSTANCE   hInstance);

BOOL
__stdcall
AppPerfClose(HINSTANCE  hInstance);

void
UpdateAppPerfTimeData (
    DWORD   dwItemId,
    DWORD   dwStage
);

void
UpdateAppPerfDwordData (
    DWORD   dwItemId,
    DWORD   dwValue
);

#else
// a regular build
#define AppPerfOpen(x)
#define AppPerfClose(x)
#define UpdateAppPerfTimeData(x,y)
#define UpdateAppPerfDwordData(x,y)
#define IncrementAppPerfDwordData(x)
#endif

#ifdef __cplusplus
}
#endif
#endif // _APPMEMA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\browser.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    browser.h

Abstract:

    Header file for the sysmon.ocx interaction with Pdh browse
	counters dialog.

--*/

#ifndef _BROWSER_H_
#define _BROWSER_H_

#define BROWSE_WILDCARD		1

typedef HRESULT (*ENUMPATH_CALLBACK)(LPTSTR pszPath, DWORD_PTR lpUserData, DWORD dwFlags);

extern HRESULT
BrowseCounters (	
    IN HLOG     hDataSource,
	IN DWORD	dwDetailLevel,
	IN HWND	    hwndOwner,
	IN ENUMPATH_CALLBACK pCallback,
	IN LPVOID	lpUserData,
    IN BOOL     bUseInstanceIndex
	);


extern HRESULT
EnumExpandedPath (
    HLOG    hDataSource,
	LPTSTR	pszCtrPath,
	ENUMPATH_CALLBACK pCallback,
	LPVOID	lpUserData
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\bstrutil.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    bstrutil.h

Abstract:

    Declares B string utility methods.

--*/


INT SysStringAnsiLen (
	IN BSTR bstr
	);

HRESULT BStrToStream (
	IN	LPSTREAM pIStream, 
	IN	INT	 nChar,
	IN	BSTR bstr
	);

HRESULT BStrFromStream (
	IN	LPSTREAM pIStream,
	IN	INT nChar,
	OUT	BSTR *pbstr
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\cntrtree.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    cntrtree.h

Abstract:

    Header for the counter hierarchy.

--*/

#ifndef _CNTRTREE_H_
#define _CNTRTREE_H_

#include "namenode.h"

enum {
    MACHINE_NODE,
    OBJECT_NODE,
    INSTANCE_NODE,
    COUNTER_NODE,
    ITEM_NODE
};


//
class CMachineNode;
class CObjectNode;
class CCounterNode;
class CInstanceNode;
class CReport;
class CGraphItem;

//
// Class CCounterTree
//
class CCounterTree
{
    friend CMachineNode;
    friend CInstanceNode;

    public:
        CCounterTree( void );
        HRESULT AddCounterItem( LPTSTR pszPath, CGraphItem* pItem, BOOL bMonitorDuplicateInstances );
        void RemoveCounterItem( CGraphItem* pItem );
        void RemoveMachine( CMachineNode *pMachine);

        HRESULT GetMachine( LPTSTR pszName, CMachineNode **pMachineRet );
        CMachineNode *FirstMachine( void ) { return (CMachineNode*)m_listMachines.First(); }
        CGraphItem* FirstCounter( void );
        INT NumCounters( void )  { return m_nItems; }

    private:
        CNamedNodeList m_listMachines;
        INT m_nItems;

};

typedef CCounterTree *PCCounterTree;

//
// Class CMachineNode
//
class CMachineNode : public CNamedNode
{
    friend CCounterTree;
    friend CGraphItem;
    friend CReport;

    public:

//        void *operator new( size_t stBlock, LPTSTR pszName );
#if _MSC_VER >= 1300
        void operator delete ( void *pObject );
#endif
        void *operator new( size_t stBlock, UINT iLength);
        void operator delete ( void *pObject, UINT );

        CMachineNode( void ) { m_xWidth = -1; }

        HRESULT GetCounterObject(LPTSTR pszName, CObjectNode **ppObject);
        HRESULT AddObject(CObjectNode *pObject);
        void RemoveObject(CObjectNode *pObject);
        void DeleteNode (BOOL bPropagateUp);

        LPCTSTR Name( void ) {return m_szName;}
        CMachineNode *Next( void ) { return (CMachineNode*)m_pnodeNext; }
        CObjectNode *FirstObject( void ) { return (CObjectNode*)m_listObjects.First(); }

    private:
        PCCounterTree m_pCounterTree;
        CNamedNodeList m_listObjects;
        INT   m_xWidth;
        INT   m_yPos;
        TCHAR m_szName[1];
};

typedef CMachineNode *PCMachineNode;

//
// Class CObjectNode
//
class CObjectNode : public CNamedNode
{
    friend CMachineNode;
    friend CGraphItem;
    friend CReport;

    public:
//        void *operator new( size_t stBlock, LPTSTR pszName );
#if _MSC_VER >= 1300
        void operator delete ( void *pObject );
#endif
        void *operator new( size_t stBlock, UINT iLength);
        void operator delete ( void *pObject, UINT );
        CObjectNode( void ) { m_xWidth = -1; }

        LPCTSTR Name() {return m_szName;}

        HRESULT GetCounter(LPTSTR pszName, CCounterNode **ppObject);
        HRESULT AddCounter(CCounterNode *pCounter);
        void RemoveCounter(CCounterNode *pCounter);
        void DeleteNode (BOOL bPropagateUp);

        HRESULT GetInstance(
                    LPTSTR pszParent,
                    LPTSTR pszName,
                    DWORD dwIndex,
                    BOOL bMonitorDuplicateInstances,
                    CInstanceNode **ppObject );
        HRESULT AddInstance(CInstanceNode *pInstance);
        void RemoveInstance(CInstanceNode *pInstance);

        CObjectNode *Next( void ) { return (CObjectNode*)m_pnodeNext; }
        CInstanceNode *FirstInstance( void ) { return (CInstanceNode*)m_listInstances.First(); }
        CCounterNode *FirstCounter( void ) { return (CCounterNode*)m_listCounters.First(); }

    private:
        PCMachineNode   m_pMachine;
        CNamedNodeList  m_listCounters;
        CNamedNodeList  m_listInstances;
        INT   m_yPos;
        INT   m_xWidth;
        TCHAR m_szName[1];
};

typedef CObjectNode *PCObjectNode;

//
// Class CInstanceNode
//
class CInstanceNode : public CNamedNode
{
    friend CObjectNode;
    friend CGraphItem;
    friend CReport;

    private:
        PCObjectNode    m_pObject;
        CGraphItem   *m_pItems;
        INT    m_xPos;
        INT    m_xWidth;
        INT    m_nParentLen;
        TCHAR  m_szName[1];

    public:
//        void *operator new( size_t stBlock, LPTSTR pszName );
#if _MSC_VER >= 1300
        void operator delete ( void *pObject );
#endif
        void *operator new( size_t stBlock, UINT iLength);
        void operator delete ( void *pObject, UINT );
        CInstanceNode() { m_pItems = NULL; m_xWidth = -1;}


        LPCTSTR Name( void ) {return m_szName;}
        BOOL HasParent( void ) {return m_nParentLen; }
        INT GetParentName ( LPTSTR pszName );
        INT GetInstanceName ( LPTSTR pszName );

        HRESULT AddItem( CCounterNode *pCounter, CGraphItem* pItemNew );
        void RemoveItem( CGraphItem* pItem );
        void DeleteNode (BOOL bPropagateUp);

        CInstanceNode *Next( void ) { return (CInstanceNode*)m_pnodeNext; }
        CGraphItem *FirstItem( void ) { return m_pItems; }

};

typedef CInstanceNode *PCInstanceNode;

//
// Class CCounterNode
//
class CCounterNode : public CNamedNode
{
    friend CObjectNode;
    friend CGraphItem;
    friend CReport;

    public:
        CGraphItem *m_pFirstGenerated;

//        void *operator new( size_t stBlock, LPTSTR pszName );
#if _MSC_VER >= 1300
        void operator delete ( void *pObject );
#endif
        void *operator new( size_t stBlock, UINT iLength);
        void operator delete ( void *pObject, UINT );

        CCounterNode( void ) { m_nCounterRef = 0;m_xWidth = -1;}
        void AddItem ( CGraphItem* ) { m_nCounterRef++; }
        void RemoveItem ( CGraphItem* ) { if (--m_nCounterRef == 0) m_pObject->RemoveCounter(this); }

        LPCTSTR Name( void ) {return m_szName;}
        CCounterNode *Next( void ) { return (CCounterNode*)m_pnodeNext; }
        void DeleteNode (BOOL bPropagateUp);

    private:
        PCObjectNode    m_pObject;
        INT    m_nCounterRef;
        INT    m_yPos;
        INT    m_xWidth;

        TCHAR m_szName[1];

};

typedef CCounterNode *PCCounterNode;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\bstrutil.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    bstrutil.cpp

Abstract:

    B string utility functions.

--*/

#include "ole2.h"

#include "bstrutil.h"

INT SysStringAnsiLen (
    IN  BSTR bstr
    )
{
    if (bstr == NULL)
        return 0;

#ifndef OLE2ANSI
    return WideCharToMultiByte(CP_ACP, 0, bstr, SysStringLen(bstr),
                                 NULL, 0, NULL, NULL);
#else
    return SysStringLen(bstr);
#endif
}


HRESULT BStrToStream (
    IN  LPSTREAM pIStream, 
    IN  INT  nMbChar,
    IN  BSTR bstr
    )
{
    LPSTR   pchBuf;
    HRESULT hr;

    // If empty string just return
    if (SysStringLen(bstr) == 0)
        return NO_ERROR;

#ifndef OLE2ANSI
    // Convert to multibyte string
    pchBuf = new char[nMbChar + 1];
    if (pchBuf == NULL)
        return E_OUTOFMEMORY;

    WideCharToMultiByte(CP_ACP, 0, bstr, SysStringLen(bstr),
                                 pchBuf, nMbChar+1, NULL, NULL);
    // Write string to stream
    hr = pIStream->Write(pchBuf, nMbChar, NULL);

    delete [] pchBuf;
#else
    hr = pIStream->Write(bstr, nMbChar, NULL);
#endif

    return hr;
}


HRESULT BStrFromStream (
    IN  LPSTREAM pIStream,
    IN  INT nChar,
    OUT BSTR *pbstrRet
    )
{
    HRESULT hr;
    BSTR    bstr;   
    ULONG   nRead;
    LPSTR   pchBuf;
    INT     nWChar;

    *pbstrRet = NULL;    

    // if zero-length string just return
    if (nChar == 0)
        return NO_ERROR;

#ifndef OLE2ANSI

    // Allocate char array and read in string
    pchBuf = new char[nChar];
    if (pchBuf == NULL)
        return E_OUTOFMEMORY;
        
    hr = pIStream->Read(pchBuf, nChar, &nRead);
    
    // Verify read count
    if (!FAILED(hr)) {
        if (nRead != (ULONG)nChar)
            hr = E_FAIL;
    }
    
    if (!FAILED(hr)) {
        // Allocate BString for UNICODE translation
        nWChar = MultiByteToWideChar(CP_ACP, 0, pchBuf, nChar, NULL, 0);
        bstr = SysAllocStringLen(NULL, nWChar);

        if (bstr != NULL)   {
            MultiByteToWideChar(CP_ACP, 0, pchBuf, nChar, bstr, nWChar);
            bstr[nWChar] = 0;
            *pbstrRet = bstr;
        }
        else
            hr = E_OUTOFMEMORY;
     }

    delete [] pchBuf;
    
#else
    // Allocate BString
    bstr = SysAllocStringLen(NULL, nChar);
    if (bstr == NULL)
        return E_OUTOFMEMORY;

    // Read in string
    hr = pIStream->Read(bstr, nChar, &nRead);

    // Verify read count
    if (!FAILED(hr)) {
        if (nRead != (ULONG)nChar)
            hr = E_FAIL;
    }

    // Return or free string
    if (!FAILED(hr))
        *pbstrRet = bstr;
    else
        SysFreeString(bstr);
#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\cathelp.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    cathelp.cpp

Abstract:

    Component category implementation.

--*/

#include "comcat.h"


// Helper function to create a component category and associated description
HRESULT 
CreateComponentCategory (
    CATID catid, 
    WCHAR* catDescription )
{

    CATEGORYINFO catinfo;
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    SIZE_T len;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
            NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (FAILED(hr))
        return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

    // Make sure the provided description is not too long.
    // Only copy the first 127 characters if it is
    len = wcslen(catDescription);
    if (len>127)
        len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
    // Make sure the description is null terminated
    catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
    pcr->Release();

    return hr;
}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
    {
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
            NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
  
    return hr;
    }

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
    {
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
            NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
  
    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\cntrtree.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    cntrtree.cpp

Abstract:

    Implements internal counter management.

--*/

#include <assert.h>
#include <stdio.h>
#include "polyline.h"
#include "smonmsg.h"
#include "appmema.h"
#include "grphitem.h"
#include "cntrtree.h"

CCounterTree::CCounterTree()
:   m_nItems (0)
{
}

HRESULT
CCounterTree::AddCounterItem(LPTSTR pszPath, PCGraphItem pItem, BOOL bMonitorDuplicateInstances)
{
    HRESULT hr;
    TCHAR achInfoBuf[sizeof(PDH_COUNTER_PATH_ELEMENTS) + MAX_PATH + 5];
    PPDH_COUNTER_PATH_ELEMENTS pPathInfo = (PPDH_COUNTER_PATH_ELEMENTS)achInfoBuf;
    ULONG ulBufSize;
    PDH_STATUS stat;

    CMachineNode *pMachine;
    CObjectNode  *pObject;
    CCounterNode *pCounter;
    CInstanceNode *pInstance;

    // Record whether machine is explicit or defaults to local
    pItem->m_fLocalMachine = !(pszPath[0] == TEXT('\\') && pszPath[1] == TEXT('\\'));

    // Parse pathname
    ulBufSize = sizeof(achInfoBuf);
    stat = PdhParseCounterPath(pszPath, pPathInfo, &ulBufSize, 0);
    if (stat != 0)
        return E_FAIL;

/*
    stat = PdhValidatePath(pszPath);
    if (stat != 0)
        return E_FAIL;
*/
    // Find or create each level of hierarchy
    hr = GetMachine( pPathInfo->szMachineName, &pMachine);
    if (FAILED(hr))
        return hr;

    hr = pMachine->GetCounterObject(pPathInfo->szObjectName, &pObject);
    if (FAILED(hr))
        return hr;

    hr = pObject->GetCounter(pPathInfo->szCounterName, &pCounter);
    if (FAILED(hr))
        return hr;

    hr = pObject->GetInstance(
            pPathInfo->szParentInstance,
            pPathInfo->szInstanceName,
            pPathInfo->dwInstanceIndex,
            bMonitorDuplicateInstances,
            &pInstance);

    if (FAILED(hr))
        return hr;

    hr = pInstance->AddItem(pCounter, pItem);

    if (SUCCEEDED(hr)) {
        m_nItems++;
        UpdateAppPerfDwordData (DD_ITEM_COUNT, m_nItems);
    }

    return hr;
}


HRESULT
CCounterTree::GetMachine (
    IN  LPTSTR pszName,
    OUT PCMachineNode *ppMachineRet
    )
{
    PCMachineNode pMachine;
    PCMachineNode pMachineNew;

    if (m_listMachines.FindByName(pszName, FIELD_OFFSET(CMachineNode, m_szName), (PCNamedNode*)&pMachine)) {
        *ppMachineRet = pMachine;
        return NOERROR;
    }

    pMachineNew = new(lstrlen(pszName) * sizeof(TCHAR)) CMachineNode;
    if (!pMachineNew)
        return E_OUTOFMEMORY;

    pMachineNew->m_pCounterTree = this;
    lstrcpy(pMachineNew->m_szName, pszName);

    m_listMachines.Add(pMachineNew, pMachine);

    *ppMachineRet = pMachineNew;

    return NOERROR;
}


void
CCounterTree::RemoveMachine (
    IN PCMachineNode pMachine
    )
{
    // Remove machine from list and delete it
    m_listMachines.Remove(pMachine);
    delete pMachine ;
}

PCGraphItem
CCounterTree::FirstCounter (
    void
    )
{
    if (!FirstMachine())
        return NULL;
    else
        return FirstMachine()->FirstObject()->FirstInstance()->FirstItem();
}

HRESULT
CMachineNode::GetCounterObject (
    IN  LPTSTR pszName,
    OUT PCObjectNode *ppObjectRet
    )
{
    PCObjectNode pObject;
    PCObjectNode pObjectNew;

    if (m_listObjects.FindByName(pszName, FIELD_OFFSET(CObjectNode, m_szName), (PCNamedNode*)&pObject)) {
        *ppObjectRet = pObject;
        return NOERROR;
    }

    pObjectNew = new(lstrlen(pszName) * sizeof(TCHAR)) CObjectNode;
    if (!pObjectNew)
        return E_OUTOFMEMORY;

    pObjectNew->m_pMachine = this;
    lstrcpy(pObjectNew->m_szName, pszName);

    m_listObjects.Add(pObjectNew, pObject);

    *ppObjectRet = pObjectNew;

    return NOERROR;
}


void
CMachineNode::RemoveObject (
    IN PCObjectNode pObject
    )
{
    // Remove object from list and delete it
    m_listObjects.Remove(pObject);
    delete pObject;

    // If this was the last one, remove ourself
    if (m_listObjects.IsEmpty())
        m_pCounterTree->RemoveMachine(this);

}

void
CMachineNode::DeleteNode (
    BOOL    bPropagateUp
    )
{
    PCObjectNode pObject;
    PCObjectNode pNextObject;

    // Delete all object nodes
    pObject = FirstObject();
    while ( NULL != pObject ) {
        pNextObject = pObject->Next();
        pObject->DeleteNode(FALSE);
        m_listObjects.Remove(pObject);
        delete pObject;
        pObject = pNextObject;
    }

    assert(m_listObjects.IsEmpty());

    // Notify parent if requested
    if (bPropagateUp) {
        m_pCounterTree->RemoveMachine(this);
    }
}

HRESULT
CObjectNode::GetCounter (
    IN  LPTSTR pszName,
    OUT PCCounterNode *ppCounterRet
    )
{

    PCCounterNode pCounter;
    PCCounterNode pCounterNew;

    if (m_listCounters.FindByName(pszName, FIELD_OFFSET(CCounterNode, m_szName), (PCNamedNode*)&pCounter)) {
        *ppCounterRet = pCounter;
        return NOERROR;
    }

    pCounterNew = new(lstrlen(pszName) * sizeof(TCHAR)) CCounterNode;
    if (!pCounterNew)
        return E_OUTOFMEMORY;

    pCounterNew->m_pObject = this;
    lstrcpy(pCounterNew->m_szName, pszName);

    m_listCounters.Add(pCounterNew, pCounter);

    *ppCounterRet = pCounterNew;

    return NOERROR;
}


HRESULT
CObjectNode::GetInstance (
    IN  LPTSTR pszParent,
    IN  LPTSTR pszInstance,
    IN  DWORD  dwIndex,
    IN  BOOL bMonitorDuplicateInstances,
    OUT PCInstanceNode *ppInstanceRet
    )
{

    PCInstanceNode pInstance;
    PCInstanceNode pInstanceNew;
    INT nParentLen = 0;
    TCHAR achInstName[MAX_PATH];


    if (pszInstance) {
        if (pszParent) {
            nParentLen = lstrlen(pszParent);
            lstrcpy(achInstName, pszParent);
            achInstName[nParentLen] = TEXT('/');
            lstrcpy(&achInstName[nParentLen+1], pszInstance);
        }
        else {
            lstrcpy(achInstName, pszInstance);
        }
        
        // "#n" is only appended to the stored name if the index is > 0.
        if ( dwIndex > 0 && bMonitorDuplicateInstances ) {
            _stprintf(&achInstName[lstrlen(achInstName)], TEXT("#%d"), dwIndex);
        }


    } else {
        achInstName[0] = 0;
    }

    if (m_listInstances.FindByName(achInstName, FIELD_OFFSET(CInstanceNode, m_szName), (PCNamedNode*)&pInstance)) {
        *ppInstanceRet = pInstance;
        return NOERROR;
    }

    pInstanceNew = new(lstrlen(achInstName) * sizeof(TCHAR)) CInstanceNode;
    if (!pInstanceNew)
        return E_OUTOFMEMORY;

    pInstanceNew->m_pObject = this;
    pInstanceNew->m_nParentLen = nParentLen;
    lstrcpy(pInstanceNew->m_szName, achInstName);

    m_listInstances.Add(pInstanceNew, pInstance);

    *ppInstanceRet = pInstanceNew;

    return NOERROR;
}

void
CObjectNode::RemoveInstance (
    IN PCInstanceNode pInstance
    )
{
    // Remove instance from list and delete it
    m_listInstances.Remove(pInstance);
    delete pInstance ;

    // if that was the last instance, remove ourself
    if (m_listInstances.IsEmpty())
        m_pMachine->RemoveObject(this);
}

void
CObjectNode::RemoveCounter (
    IN PCCounterNode pCounter
    )
{
    // Remove counter from list and delete it
    m_listCounters.Remove(pCounter);
    delete pCounter;

    // Don't propagate removal up to object.
    // It will go away when the last instance is removed.
}

void
CObjectNode::DeleteNode (
    BOOL    bPropagateUp
    )
{
    PCInstanceNode pInstance;
    PCInstanceNode pNextInstance;

    // Delete all instance nodes
    pInstance = FirstInstance();
    while ( NULL != pInstance ) {
        pNextInstance = pInstance->Next();
        pInstance->DeleteNode(FALSE);
        m_listInstances.Remove(pInstance);
        delete pInstance;
        pInstance = pNextInstance;
    }

    // No need to delete counters nodes as they get
    // deleted as their last paired instance does

    // Notify parent if requested
    if (bPropagateUp)
        m_pMachine->RemoveObject(this);
}

HRESULT
CInstanceNode::AddItem (
    IN  PCCounterNode pCounter,
    IN  PCGraphItem   pItemNew
    )
{
    PCGraphItem pItemPrev = NULL;
    PCGraphItem pItem = m_pItems;
    INT iStat = 1;

    // Check for existing item for specified counter, stopping at insertion point
    while ( pItem != NULL && (iStat = lstrcmp(pCounter->Name(), pItem->m_pCounter->Name())) > 0) {
        pItemPrev = pItem;
        pItem = pItem->m_pNextItem;
    }

    // if item exists, return duplicate error status
    if (iStat == 0) {
        return SMON_STATUS_DUPL_COUNTER_PATH;
    }
    // else insert the new item
    else {
        if (pItemPrev != NULL) {
            pItemNew->m_pNextItem = pItemPrev->m_pNextItem;
            pItemPrev->m_pNextItem = pItemNew;
        }
        else if (m_pItems != NULL) {
            pItemNew->m_pNextItem = m_pItems;
            m_pItems = pItemNew;
        }
        else {
            m_pItems = pItemNew;
        }
    }

    // Set back links
    pItemNew->m_pInstance = this;
    pItemNew->m_pCounter = pCounter;

    pCounter->AddItem(pItem);

    return NOERROR;

}

void
CInstanceNode::RemoveItem (
    IN PCGraphItem pitem
    )
{
    PCGraphItem pitemPrev = NULL;
    PCGraphItem pitemTemp = m_pItems;

    // Locate item in list
    while (pitemTemp != NULL && pitemTemp != pitem) {
        pitemPrev = pitemTemp;
        pitemTemp = pitemTemp->m_pNextItem;
    }

    if (pitemTemp == NULL)
        return;

    // Remove from list
    if (pitemPrev)
        pitemPrev->m_pNextItem = pitem->m_pNextItem;
    else
        m_pItems = pitem->m_pNextItem;

    // Remove item from Counter set
    pitem->Counter()->RemoveItem(pitem);

    // Decrement the total item count
    pitem->Tree()->m_nItems--;
  UpdateAppPerfDwordData (DD_ITEM_COUNT, pitem->Tree()->m_nItems);

  // Release the item
    pitem->Release();

    // if last item under this instance, remove the instance
    if (m_pItems == NULL)
        m_pObject->RemoveInstance(this);
}


void
CInstanceNode::DeleteNode (
    BOOL bPropagateUp
    )
{
    PCGraphItem pItem;

    pItem = m_pItems;

    while ( NULL != pItem ) {
        m_pItems = pItem->m_pNextItem;
        pItem->Delete(FALSE);
        pItem->Counter()->RemoveItem(pItem);
        pItem->Release();
        pItem = m_pItems;
    }

    if (bPropagateUp)
        m_pObject->RemoveInstance(this);
}


INT
CInstanceNode::GetParentName (
    LPTSTR pszName
    )
{
    if (m_nParentLen)
        lstrcpyn(pszName, m_szName, m_nParentLen + 1);
    else
        pszName[0] = 0;

    return m_nParentLen;
}


INT
CInstanceNode::GetInstanceName (
    LPTSTR pszName
    )
{
    LPTSTR pszInst = m_nParentLen ? (m_szName + m_nParentLen + 1) : m_szName;

    lstrcpy(pszName, pszInst);

    return lstrlen(pszInst);
}

void
CCounterNode::DeleteNode (
    BOOL bPropagateUp
    )
{
    PCInstanceNode pInstance, pInstNext;
    PCGraphItem pItem, pItemNext;

    if (!bPropagateUp)
        return;

    // We have to delete the counters item via the instances
    // because they maintain the linked list of items
    pInstance = m_pObject->FirstInstance();
    while (pInstance) {

        pInstNext = pInstance->Next();

        pItem = pInstance->FirstItem();
        while (pItem) {

            if (pItem->Counter() == this) {

                // Delete all UI associated with the item
                pItem->Delete(FALSE);

                pItemNext = pItem->m_pNextItem;

                // Note that Instance->RemoveItem() will
                // also remove counters that have no more items
                pItem->Instance()->RemoveItem(pItem);

                pItem = pItemNext;
            }
            else {
                pItem = pItem->m_pNextItem;
            }
        }

        pInstance = pInstNext;
    }
}


/*******************************

CCounterNode::~CCounterNode (
    IN  PCGraphItem pItem
    )
{

    PCGraphItem pItemPrev = NULL;
    PCGraphItem pItemFind = m_pItems;

    // Find item in list
    while (pItemFind != NULL && pItemFind != pItem) {
        pItemPrev = pItem;
        pItem = pItem->m_pNextItem;
    }

    if (pItemFind != pItem)
        return E_FAIL;

    // Unlink from counter item list
    if (pItemPrev)
        pItemPrev->m_pNextItem = pItem->m_pNextItem;
    else
        m_pItems = pItem->m_pNextItem;

    // Unlink from instance
    pItem->m_pInstance->RemoveCounter(pItem);

    // if no more items, remove self from parnet object
    if (m_pItems == NULL) {
        m_pObject->RemoveCounter(this);

    return NOERROR;
}
*******************************/
/*
void*
CMachineNode::operator new( size_t stBlock, LPTSTR pszName )
{ return malloc(stBlock + lstrlen(pszName) * sizeof(TCHAR)); }


void
CMachineNode::operator delete ( void * pObject, LPTSTR )
{ free(pObject); }

void*
CObjectNode::operator new( size_t stBlock, LPTSTR pszName )
{ return malloc(stBlock + lstrlen(pszName) * sizeof(TCHAR)); }

void
CObjectNode::operator delete ( void * pObject, LPTSTR )
{ free(pObject); }

void*
CInstanceNode::operator new( size_t stBlock, LPTSTR pszName )
{ return malloc(stBlock + lstrlen(pszName) * sizeof(TCHAR)); }

void
CInstanceNode::operator delete ( void * pObject, LPTSTR )
{ free(pObject); }

void*
CCounterNode::operator new( size_t stBlock, LPTSTR pszName )
{ return malloc(stBlock + lstrlen(pszName) * sizeof(TCHAR)); }

void
CCounterNode::operator delete ( void * pObject, LPTSTR )
{ free(pObject); }CMachineNode::operator new( size_t stBlock, INT iLength )
*/

void *
CMachineNode::operator new( size_t stBlock, UINT iLength )
{ return malloc(stBlock + iLength); }


void
CMachineNode::operator delete ( void * pObject, UINT )
{ free(pObject); }

void*
CObjectNode::operator new( size_t stBlock, UINT iLength  )
{ return malloc(stBlock + iLength); }

void
CObjectNode::operator delete ( void * pObject, UINT )
{ free(pObject); }

void*
CInstanceNode::operator new( size_t stBlock, UINT iLength  )
{ return malloc(stBlock + iLength); }

void
CInstanceNode::operator delete ( void * pObject, UINT )
{ free(pObject); }

void*
CCounterNode::operator new( size_t stBlock, UINT iLength  )
{ return malloc(stBlock + iLength); }

void
CCounterNode::operator delete ( void * pObject, UINT )
{ free(pObject); }

#if _MSC_VER >= 1300
void
CMachineNode::operator delete ( void * pObject )
{ free(pObject); }

void
CObjectNode::operator delete ( void * pObject )
{ free(pObject); }

void
CInstanceNode::operator delete ( void * pObject )
{ free(pObject); }

void
CCounterNode::operator delete ( void * pObject )
{ free(pObject); }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\colefont.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    colefont.cpp

Abstract:

    Font class.

--*/

#include "polyline.h"
#include "utils.h"
#include "smonctrl.h"
#include "unihelpr.h"
#include "COleFont.h"

#pragma warning ( disable : 4355 ) // "this" used in initializer list

const   LPWSTR  COleFont::m_cwszDefaultFaceName = L"MS Shell Dlg";
const   INT     COleFont::m_iDefaultTmHeight = 13;
const   SHORT   COleFont::m_iDefaultTmWeight = 400;
const   INT     COleFont::m_iDefaultRiPxlsPerInch = 96;

COleFont::COleFont (
    CSysmonControl  *pCtrl
    ) 
    : m_NotifySink( this )
{
    m_pIFont = NULL;
    m_pIFontBold = NULL;
    m_pCtrl = pCtrl;
    m_pIConnPt = NULL;
}

#pragma warning ( default : 4355 ) // "this" used in initializer list


COleFont::~COleFont (
    void 
    )
{
    // Release current connection point
    if (m_pIConnPt) {
        m_pIConnPt->Unadvise(m_dwCookie);
        ReleaseInterface(m_pIConnPt);
    }

    // Release fonts
    ReleaseInterface(m_pIFont);
    ReleaseInterface(m_pIFontBold);

    return;
}
void 
COleFont::InitDefaultFontDesc (
    FONTDESC&   rFontDesc,
    INT&        riPxlsPerInch,
    WCHAR       achFaceName[LF_FACESIZE+1])
{
    TEXTMETRIC  TextMetrics;
    HFONT       hFontOld;
    HDC         hDC;

    USES_CONVERSION
        
// Todo:  Must define proper default values, move them to resources
// for localization.

    ZeroMemory ( &rFontDesc, sizeof ( FONTDESC ) );

    // Select default font
    hDC = GetDC(NULL);
    
    if ( NULL != hDC ) {

        hFontOld = SelectFont(hDC, (HFONT)GetStockObject(DEFAULT_GUI_FONT));

        // Get face name and size
        GetTextMetrics(hDC, &TextMetrics);
        GetTextFaceW(hDC, LF_FACESIZE, achFaceName);

        // Get pixels per inch
        riPxlsPerInch = GetDeviceCaps(hDC, LOGPIXELSY);

        // Create a default font
        rFontDesc.lpstrName = achFaceName;
        rFontDesc.cySize.int64 = ((TextMetrics.tmHeight * 72) / riPxlsPerInch) * 10000;
        rFontDesc.sWeight = (short)TextMetrics.tmWeight; 

        SelectFont(hDC, hFontOld);

        ReleaseDC(NULL, hDC);

    } else {
        
        riPxlsPerInch = m_iDefaultRiPxlsPerInch;
        lstrcpyW ( achFaceName, m_cwszDefaultFaceName );
        // Create a default font
        rFontDesc.lpstrName = achFaceName;
        rFontDesc.cySize.int64 = ((m_iDefaultTmHeight * 72) / m_iDefaultRiPxlsPerInch) * 10000;
        rFontDesc.sWeight = m_iDefaultTmWeight; 
    }

    rFontDesc.cbSizeofstruct = sizeof(rFontDesc);
    rFontDesc.sCharset = DEFAULT_CHARSET; 
    rFontDesc.fItalic = 0; 
    rFontDesc.fUnderline = 0; 
    rFontDesc.fStrikethrough = 0;

    return;
}

HRESULT COleFont::Init (
    VOID
    )
{
    HRESULT     hr;
    FONTDESC    fontDesc;
    WCHAR       achFontFaceName[LF_FACESIZE+1];
    LPFONT      pIFont;
    INT         iPxlsPerInch;

    InitDefaultFontDesc ( fontDesc, iPxlsPerInch, achFontFaceName );

    hr = OleCreateFontIndirect(&fontDesc, IID_IFont, (void**)&pIFont);
    if (FAILED(hr))
        return hr;

    pIFont->SetRatio(iPxlsPerInch, HIMETRIC_PER_INCH);

    hr = SetIFont(pIFont);

    pIFont->Release();

    return hr;

}


STDMETHODIMP COleFont::SetIFont(

    LPFONT  pIFont
    )
{
    HRESULT hr;
    IConnectionPointContainer *pIConnPtCont;
    IPropertyNotifySink *pISink;

    // Release current connection point
    if (m_pIConnPt) {
        m_pIConnPt->Unadvise(m_dwCookie);
        ReleaseInterface(m_pIConnPt);
    }

    // Release current fonts
    ReleaseInterface(m_pIFont);
    ReleaseInterface(m_pIFontBold);

    // Addref and hold new IFont
    m_pIFont = pIFont;
    m_pIFont->AddRef();

    // Get it's property notify connection point
    hr = pIFont->QueryInterface(IID_IConnectionPointContainer, (void **)&pIConnPtCont);
    if (SUCCEEDED(hr)) {

        hr = pIConnPtCont->FindConnectionPoint(IID_IPropertyNotifySink, &m_pIConnPt);
        pIConnPtCont->Release();

        // Connect our sink to it
        if (SUCCEEDED(hr)) {
            m_NotifySink.QueryInterface(IID_IPropertyNotifySink, (void **)&pISink);
            hr = m_pIConnPt->Advise(pISink, &m_dwCookie);
        }
    }

    // Force a change notification 
    FontChange(DISPID_UNKNOWN);

    return hr;
}

void
COleFont::FontChange (
    DISPID DispId
    )
{
    CY  size;
    BOOL bool;
    short weight;
    BSTR  bstrName;

    // if not bold font, force clone of normal font
    if (m_pIFontBold == NULL)
        DispId = DISPID_UNKNOWN;

    // Copy changed parameter to bold font
    switch (DispId) {

    case DISPID_FONT_NAME:
        if (SUCCEEDED(m_pIFont->get_Name(&bstrName))) {
            m_pIFontBold->put_Name(bstrName);
            SysFreeString(bstrName);
        }
        break;

    case DISPID_FONT_SIZE:
        m_pIFont->get_Size(&size);
        m_pIFontBold->put_Size(size);
        break;

    case DISPID_FONT_ITALIC:
        m_pIFont->get_Italic(&bool);
        m_pIFontBold->put_Italic(bool);
        break;

    case DISPID_FONT_UNDER:
        m_pIFont->get_Underline(&bool);
        m_pIFontBold->put_Underline(bool);
        break;

    case DISPID_FONT_STRIKE:
        m_pIFont->get_Strikethrough(&bool);
        m_pIFontBold->put_Strikethrough(bool);
        break;

    case DISPID_FONT_WEIGHT:
        m_pIFont->get_Weight(&weight);
        m_pIFontBold->put_Weight(weight);
        m_pIFontBold->put_Bold(TRUE);
        break;

    case DISPID_UNKNOWN:
        ReleaseInterface(m_pIFontBold);
        if (SUCCEEDED(m_pIFont->Clone(&m_pIFontBold))) {
            m_pIFontBold->put_Bold(TRUE);
        }
    }

    // Notify owner of font change
    m_pCtrl->FontChanged();
}


STDMETHODIMP COleFont::GetFontDisp (
    OUT IFontDisp **ppFont
    )
{
    *ppFont = NULL;

    if (m_pIFont == NULL)
        return E_UNEXPECTED;

    return m_pIFont->QueryInterface(IID_IFontDisp, (void **)ppFont);
}


STDMETHODIMP COleFont::GetHFont (
    OUT HFONT *phFont
    )
{
    if ( m_pIFont == NULL ) {
        *phFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    } else {
        if ( FAILED(m_pIFont->get_hFont(phFont)) ) {
            *phFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
        }
    }

    return S_OK;
}


STDMETHODIMP COleFont::GetHFontBold (
    OUT HFONT *phFont
    )
{
    if (m_pIFontBold == NULL ) {
        *phFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
    } else {
        if ( FAILED(m_pIFontBold->get_hFont(phFont)) ) {
            *phFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
        }
    }

    return S_OK;
}


STDMETHODIMP COleFont::LoadFromStream (
    LPSTREAM  pIStream
    )
{
    HRESULT hr;
    IPersistStream *pIPersist = NULL;
    FONTDESC    fontDesc;
    WCHAR       achFontFaceName[LF_FACESIZE+1];
    LPFONT      pIFont = NULL;
    INT         iPxlsPerInch;

    if (m_pIFont == NULL)
        return E_FAIL;

    // Calling pIPersist for the existing font seems to miss some
    // important notification, so create a new font, load properties 
    // from the stream, and replace the current font.

    InitDefaultFontDesc ( fontDesc, iPxlsPerInch, achFontFaceName );

    hr = OleCreateFontIndirect(&fontDesc, IID_IFont, (void**)&pIFont);
    if (FAILED(hr))
        return hr;

    pIFont->SetRatio(iPxlsPerInch, HIMETRIC_PER_INCH);    
    
    hr = pIFont->QueryInterface(IID_IPersistStream, (void **)&pIPersist);
    
    if (SUCCEEDED(hr)) {
        hr = pIPersist->Load(pIStream);
        pIPersist->Release();
        hr = SetIFont(pIFont);
    }

    pIFont->Release();
    return hr;
}

STDMETHODIMP COleFont::SaveToStream (
    LPSTREAM  pIStream,
    BOOL fClearDirty
)
{
    IPersistStream *pIPersist;
    HRESULT hr;

    if (m_pIFont == NULL)
        return E_FAIL;

    hr = m_pIFont->QueryInterface(IID_IPersistStream, (void **)&pIPersist);
    if (SUCCEEDED(hr)) {
        hr = pIPersist->Save(pIStream, fClearDirty);
        pIPersist->Release();
    }

    return hr;
}

HRESULT 
COleFont::LoadFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog* pIErrorLog )
{
    HRESULT     hr = S_OK;
    WCHAR       achFontFaceName[LF_FACESIZE+1];
    WCHAR       achPropBagFaceName[LF_FACESIZE+1];
    INT         iBufSize = LF_FACESIZE+1;
    FONTDESC    fontDesc;
    LPFONT      pIFont;

    VARIANT     vValue;
    BOOL        bValue;
    SHORT       iValue;
    CY          cySize;
    INT         iPxlsPerInch;

    if (m_pIFont == NULL)
        return E_FAIL;
    
    InitDefaultFontDesc ( fontDesc, iPxlsPerInch, achFontFaceName );

    hr = StringFromPropertyBag (
            pIPropBag,
            pIErrorLog,
            L"FontName",
            achPropBagFaceName,
            iBufSize );

    if ( SUCCEEDED( hr ) ) {
        fontDesc.lpstrName = T2W(achPropBagFaceName);
    }

    hr = CyFromPropertyBag ( pIPropBag, pIErrorLog, L"FontSize", cySize );
    if ( SUCCEEDED( hr ) ){
        fontDesc.cySize.int64 = cySize.int64;
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, L"FontItalic", bValue );
    if ( SUCCEEDED( hr ) ){
        fontDesc.fItalic = ( 0 == bValue ? 0 : 1 );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, L"FontUnderline", bValue );
    if ( SUCCEEDED( hr ) ){
        fontDesc.fUnderline = ( 0 == bValue ? 0 : 1 );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, L"FontStrikethrough", bValue );
    if ( SUCCEEDED( hr ) ){
        fontDesc.fStrikethrough = ( 0 == bValue ? 0 : 1 );
    }

    hr = ShortFromPropertyBag ( pIPropBag, pIErrorLog, L"FontWeight", iValue );
    if ( SUCCEEDED( hr ) ){
        fontDesc.sWeight = iValue;
    }

    hr = OleCreateFontIndirect(&fontDesc, IID_IFont, (void**)&pIFont);
    if (FAILED(hr))
        return hr;

//    pIFont->SetRatio(iPxlsPerInch, HIMETRIC_PER_INCH);

    hr = SetIFont(pIFont);

    pIFont->Release();

    VariantClear ( &vValue );

    return hr;
}

HRESULT 
COleFont::SaveToPropertyBag (
    IPropertyBag* pIPropBag,
    BOOL /* fClearDirty */,
    BOOL /* fSaveAllProps */ )
{
    HRESULT hr = NOERROR;
    VARIANT vValue;
    BOOL    bValue;

    if (m_pIFont == NULL)
        return E_FAIL;

    VariantInit( &vValue );
    vValue.vt = VT_BSTR;
    hr = m_pIFont->get_Name( &vValue.bstrVal);

    if ( SUCCEEDED( hr ) ) {

        hr = pIPropBag->Write(L"FontName", &vValue );    

        VariantClear ( &vValue );
    }

    if ( SUCCEEDED( hr ) ) {
        if ( SUCCEEDED( hr ) ){
            CY cySize;
            hr = m_pIFont->get_Size ( &cySize );
            if ( SUCCEEDED( hr ) ) {
                hr = CyToPropertyBag ( pIPropBag, L"FontSize", cySize );
            }
        }
    }

    if ( SUCCEEDED( hr ) ) {
        if ( SUCCEEDED( hr ) ){
            hr = m_pIFont->get_Italic ( &bValue );
            if ( SUCCEEDED( hr ) ) {
                hr = BOOLToPropertyBag ( pIPropBag, L"FontItalic", bValue );
            }
        }
    }

    if ( SUCCEEDED( hr ) ) {
        if ( SUCCEEDED( hr ) ){
            hr = m_pIFont->get_Underline ( &bValue );
            if ( SUCCEEDED( hr ) ) {
                hr = BOOLToPropertyBag ( pIPropBag, L"FontUnderline", bValue );
            }
        }
    }

    if ( SUCCEEDED( hr ) ) {
        if ( SUCCEEDED( hr ) ){
            hr = m_pIFont->get_Strikethrough ( &bValue );
            if ( SUCCEEDED( hr ) ) {
                hr = BOOLToPropertyBag ( pIPropBag, L"FontStrikethrough", bValue );
            }
        }
    }

    if ( SUCCEEDED( hr ) ) {
        if ( SUCCEEDED( hr ) ){
            SHORT iValue;
            hr = m_pIFont->get_Weight ( &iValue );
            if ( SUCCEEDED( hr ) ) {
                hr = ShortToPropertyBag ( pIPropBag, L"FontWeight", iValue );
            }
        }
    }

    return hr;
}
//----------------------------------------------------------------------------
// CImpIPropertyNotifySink Interface Implementation
//----------------------------------------------------------------------------

/*
 * CImpIPropertyNotifySink::CImpIPropertyNotifySink
 * CImpIPropertyNotifySink::~CImpIPropertyNotifySink
 *
 */

CImpIPropertyNotifySink::CImpIPropertyNotifySink (
    IN COleFont *pOleFont
    )
{
    m_cRef=0;
    m_pOleFont = pOleFont;
}


CImpIPropertyNotifySink::~CImpIPropertyNotifySink (
    void
    )
{
    return;
}


/*
 * CImpIPropertyNotifySink::QueryInterface
 * CImpIPropertyNotifySink::AddRef
 * CImpIPropertyNotifySink::Release
 *
 * Purpose:
 *  Non-delegating IUnknown members for CImpIPropertyNotifySink.
 */

STDMETHODIMP 
CImpIPropertyNotifySink::QueryInterface ( 
    IN  REFIID riid,
    OUT LPVOID *ppv
    )
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IPropertyNotifySink==riid)
        *ppv=(LPVOID)this;

    if (NULL != *ppv) {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) 
CImpIPropertyNotifySink::AddRef(
    void
    )
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) 
CImpIPropertyNotifySink::Release (
    void
    )
{
    if (0 != --m_cRef)
        return m_cRef;

    // delete this;
    return 0;
}


STDMETHODIMP 
CImpIPropertyNotifySink::OnChanged (
    IN DISPID   DispId
    )
{
    // Notify font object of change
    m_pOleFont->FontChange(DispId);

    return S_OK;
}

STDMETHODIMP 
CImpIPropertyNotifySink::OnRequestEdit (
    IN DISPID   // DispId
    )
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\browse.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    browse.cpp

Abstract:

    Implements the interaction with the PDH browser dialog.

--*/

#include <assert.h>
#include "polyline.h"
#include "pdhmsg.h"
#include "browser.h"
#include "smonmsg.h"
#include "utils.h"

typedef struct {
    PDH_BROWSE_DLG_CONFIG_H   *pBrowseInfo;
    ENUMPATH_CALLBACK   pCallback;
    LPVOID  lpUserData;
} ENUMCALLBACK_INFO;


static PDH_FUNCTION
BrowseCallback (
    DWORD_PTR lpParam
);


HRESULT
BrowseCounters (
    HLOG    hDataSource,
    DWORD   dwDetailLevel,
    HWND    hwndOwner,
    ENUMPATH_CALLBACK pCallback,
    LPVOID  lpUserData,
    BOOL    bUseInstanceIndex
)
{
    #define CTRBUFLEN 8192

    PDH_BROWSE_DLG_CONFIG_H BrowseInfo;
    ENUMCALLBACK_INFO       CallbackInfo;

    // clear the structure before assigning values 
    memset (&BrowseInfo, 0, sizeof (BrowseInfo));

    BrowseInfo.bIncludeInstanceIndex = (bUseInstanceIndex ? 1 : 0);
    BrowseInfo.bSingleCounterPerAdd = 0;
    BrowseInfo.bSingleCounterPerDialog = 0;
    BrowseInfo.bLocalCountersOnly = 0;
    BrowseInfo.bWildCardInstances = 1;
    BrowseInfo.bHideDetailBox = 1;
    BrowseInfo.bInitializePath = 0;
    BrowseInfo.bDisableMachineSelection = 0;
    BrowseInfo.bReserved = 0;
    BrowseInfo.bIncludeCostlyObjects = 0;
    BrowseInfo.szDialogBoxCaption = ResourceString(IDS_ADDCOUNTERS);

    BrowseInfo.hWndOwner = hwndOwner;
    BrowseInfo.hDataSource = hDataSource;
    BrowseInfo.dwDefaultDetailLevel = dwDetailLevel;

    BrowseInfo.szReturnPathBuffer = (LPTSTR)malloc(CTRBUFLEN * sizeof(TCHAR));
    if (BrowseInfo.szReturnPathBuffer == NULL)
        return E_OUTOFMEMORY;
    BrowseInfo.cchReturnPathLength = CTRBUFLEN;

    CallbackInfo.pBrowseInfo = &BrowseInfo;
    CallbackInfo.pCallback = pCallback;
    CallbackInfo.lpUserData = lpUserData;
    BrowseInfo.dwCallBackArg = (DWORD_PTR)&CallbackInfo;
    BrowseInfo.pCallBack = BrowseCallback;

    //assert( IsWindowUnicode( hWndOwner ) );

    PdhBrowseCountersH (&BrowseInfo);

    if (BrowseInfo.szReturnPathBuffer)
        free(BrowseInfo.szReturnPathBuffer);

    return NO_ERROR;
}



static PDH_FUNCTION
BrowseCallback (
    DWORD_PTR dwParam
    )
{
    #define CTRBUFLIMIT (0x7fffffff)

    HRESULT hr = S_OK;
    BOOLEAN fDuplicate = FALSE;

    ENUMCALLBACK_INFO *pCallbackInfo = (ENUMCALLBACK_INFO*)dwParam;
    PDH_BROWSE_DLG_CONFIG_H *pBrowseInfo = pCallbackInfo->pBrowseInfo;
    LPTSTR  pszCtrPath;

    if (pBrowseInfo->CallBackStatus == ERROR_SUCCESS) {

        // Call callback for each path
        // If wildcard path, EnumExpandedPath will call once for each generated path
        for (pszCtrPath = pBrowseInfo->szReturnPathBuffer;
            *pszCtrPath != 0;
            pszCtrPath += (lstrlen(pszCtrPath) + 1)) {

            hr = EnumExpandedPath(pBrowseInfo->hDataSource, pszCtrPath,
                                    pCallbackInfo->pCallback, pCallbackInfo->lpUserData);
            if (hr == SMON_STATUS_DUPL_COUNTER_PATH)
                fDuplicate = TRUE;
        }

        // Notify user if duplicates encountered
        if (fDuplicate)
            MessageBox(pBrowseInfo->hWndOwner, ResourceString(IDS_DUPL_PATH_ERR), ResourceString(IDS_APP_NAME),
                        MB_OK | MB_ICONWARNING);
    } else if (pBrowseInfo->CallBackStatus == PDH_MORE_DATA 
             &&  pBrowseInfo->cchReturnPathLength < CTRBUFLIMIT) {
        // Malloc no longer limited to 64K
        free(pBrowseInfo->szReturnPathBuffer);

        pBrowseInfo->cchReturnPathLength *= 2;
        pBrowseInfo->szReturnPathBuffer = (TCHAR*)malloc(pBrowseInfo->cchReturnPathLength * sizeof(TCHAR));
        if (pBrowseInfo->szReturnPathBuffer)
            return PDH_RETRY;
    }

    return ERROR_SUCCESS;
}



HRESULT
EnumExpandedPath (
    HLOG    hDataSource,
    LPTSTR  pszCtrPath,
    ENUMPATH_CALLBACK pCallback,
    LPVOID  lpUserData
    )
{
#define INSTBUFLEN  4096

    PDH_STATUS stat = ERROR_SUCCESS;

    ULONG   ulBufLen;
    INT     nInstBufRetry;
    LPTSTR  pszInstBuf = NULL;
    LPTSTR  pszInstance;

    // If no wild card, invoke callback once on path
    if (_tcschr(pszCtrPath, TEXT('*')) == NULL) {
        return pCallback(pszCtrPath, (DWORD_PTR)lpUserData, 0);
    }

    ulBufLen = INSTBUFLEN;
    nInstBufRetry = 10;   // the retry counter
    do {
        if ( NULL != pszInstBuf ) {
            free(pszInstBuf);
            pszInstBuf = NULL;
            ulBufLen *= 2;
        }
        
        pszInstBuf = (TCHAR*) malloc(ulBufLen * sizeof(TCHAR));
        if (pszInstBuf == NULL) {
            stat = E_OUTOFMEMORY;
            break;
        }
            
        stat = PdhExpandWildCardPathH (
            hDataSource,
            pszCtrPath,
            pszInstBuf,
            &ulBufLen,
            0);

        nInstBufRetry--;
    } while ((stat == PDH_MORE_DATA) && (nInstBufRetry));

    if (stat == ERROR_SUCCESS) {
        // For each instance name, generate a path and invoke the callback
        for (pszInstance = pszInstBuf;
            *pszInstance != 0;
            pszInstance += lstrlen(pszInstance) + 1) {

            // Invoke callback
            HRESULT hr = pCallback(pszInstance, (DWORD_PTR)lpUserData, BROWSE_WILDCARD);

            // When expanding a wildcard, don't notify user about duplicate path errors
            if (hr != S_OK && hr != SMON_STATUS_DUPL_COUNTER_PATH)
                stat = hr;
        }
    }

    if (pszInstBuf)
        free(pszInstBuf);

    return stat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\colefont.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    colefont.h

Abstract:

    <abstract>

--*/

#ifndef _COLEFONT_H_
#define _COLEFONT_H_

class COleFont;

class CImpIPropertyNotifySink : public IPropertyNotifySink
{
	public:
		CImpIPropertyNotifySink(COleFont* pOleFont);
        ~CImpIPropertyNotifySink(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

		//Property sink methods
		STDMETHODIMP	OnChanged( DISPID DispId );
		STDMETHODIMP	OnRequestEdit( DISPID );

	private:
		COleFont*       m_pOleFont;
		ULONG			m_cRef;

};

class CSysmonControl;

class COleFont 
{

public:
	COleFont ( CSysmonControl *pCtrl );
	~COleFont( void );

	STDMETHODIMP	Init( void );
	STDMETHODIMP	SetIFont ( LPFONT pIFont );
	STDMETHODIMP	GetFontDisp ( IFontDisp **ppFont );
	STDMETHODIMP	GetHFont ( HFONT *phFont );
	STDMETHODIMP    GetHFontBold ( HFONT *phFont );
	STDMETHODIMP	SaveToStream ( LPSTREAM pIStream, BOOL fClearDirty );
	STDMETHODIMP	LoadFromStream ( LPSTREAM pIStream );
	STDMETHODIMP	SaveToPropertyBag ( IPropertyBag*, BOOL fClearDirty, BOOL fSaveAllProps );
	STDMETHODIMP	LoadFromPropertyBag ( IPropertyBag*, IErrorLog* );
	STDMETHODIMP_(VOID) FontChange ( DISPID DispId );

private:

    void InitDefaultFontDesc ( FONTDESC&, INT&, WCHAR[LF_FACESIZE+1] );

    static const    LPWSTR  m_cwszDefaultFaceName;
    static const    INT     m_iDefaultTmHeight;
    static const    INT     m_iDefaultRiPxlsPerInch;
    static const    SHORT   m_iDefaultTmWeight;

    CSysmonControl	*m_pCtrl;
	IFont			*m_pIFont;
	IFont			*m_pIFontBold;
 	IConnectionPoint *m_pIConnPt;
	CImpIPropertyNotifySink m_NotifySink;
	DWORD	        m_dwCookie;


};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\comcat.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    comcat.h

--*/

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Wed Jun 26 18:29:20 1996
 */
/* Compiler settings for comcat.idl:
    Oi (OptLev=i0), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __comcat_h__
#define __comcat_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEnumGUID_FWD_DEFINED__
#define __IEnumGUID_FWD_DEFINED__
typedef interface IEnumGUID IEnumGUID;
#endif 	/* __IEnumGUID_FWD_DEFINED__ */


#ifndef __IEnumCATEGORYINFO_FWD_DEFINED__
#define __IEnumCATEGORYINFO_FWD_DEFINED__
typedef interface IEnumCATEGORYINFO IEnumCATEGORYINFO;
#endif 	/* __IEnumCATEGORYINFO_FWD_DEFINED__ */


#ifndef __ICatRegister_FWD_DEFINED__
#define __ICatRegister_FWD_DEFINED__
typedef interface ICatRegister ICatRegister;
#endif 	/* __ICatRegister_FWD_DEFINED__ */


#ifndef __ICatInformation_FWD_DEFINED__
#define __ICatInformation_FWD_DEFINED__
typedef interface ICatInformation ICatInformation;
#endif 	/* __ICatInformation_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Wed Jun 26 18:29:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


//=--------------------------------------------------------------------------=
// ComCat.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//=--------------------------------------------------------------------------=
// OLE Componet Categories Interfaces.
//=--------------------------------------------------------------------------=
//




EXTERN_C const CLSID CLSID_StdComponentCategoriesMgr;

////////////////////////////////////////////////////////////////////////////
//  Types
typedef GUID CATID;

typedef REFGUID REFCATID;

#define IID_IEnumCLSID              IID_IEnumGUID
#define IEnumCLSID                  IEnumGUID
#define LPENUMCLSID                 LPENUMGUID
#define CATID_NULL                   GUID_NULL
#define IsEqualCATID(rcatid1, rcatid2)       IsEqualGUID(rcatid1, rcatid2)
#define IID_IEnumCATID       IID_IEnumGUID
#define IEnumCATID           IEnumGUID

////////////////////////////////////////////////////////////////////////////
//  Category IDs (link to uuid3.lib)
EXTERN_C const CATID CATID_Insertable;
EXTERN_C const CATID CATID_Control;
EXTERN_C const CATID CATID_Programmable;
EXTERN_C const CATID CATID_IsShortcut;
EXTERN_C const CATID CATID_NeverShowExt;
EXTERN_C const CATID CATID_DocObject;
EXTERN_C const CATID CATID_Printable;
EXTERN_C const CATID CATID_RequiresDataPathHost;
EXTERN_C const CATID CATID_PersistsToMoniker;
EXTERN_C const CATID CATID_PersistsToStorage;
EXTERN_C const CATID CATID_PersistsToStreamInit;
EXTERN_C const CATID CATID_PersistsToStream;
EXTERN_C const CATID CATID_PersistsToMemory;
EXTERN_C const CATID CATID_PersistsToFile;
EXTERN_C const CATID CATID_PersistsToPropertyBag;
EXTERN_C const CATID CATID_InternetAware;

////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPENUMGUID_DEFINED
#define _LPENUMGUID_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IEnumGUID_INTERFACE_DEFINED__
#define __IEnumGUID_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumGUID
 * at Wed Jun 26 18:29:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumGUID __RPC_FAR *LPENUMGUID;


EXTERN_C const IID IID_IEnumGUID;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumGUID : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumGUIDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumGUID __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumGUID __RPC_FAR * This,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumGUIDVtbl;

    interface IEnumGUID
    {
        CONST_VTBL struct IEnumGUIDVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumGUID_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumGUID_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumGUID_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumGUID_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumGUID_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumGUID_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumGUID_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumGUID_Next_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumGUID_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Skip_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumGUID_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Reset_Proxy( 
    IEnumGUID __RPC_FAR * This);


void __RPC_STUB IEnumGUID_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Clone_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumGUID_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumGUID_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0006
 * at Wed Jun 26 18:29:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPENUMCATEGORYINFO_DEFINED
#define _LPENUMCATEGORYINFO_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0006_v0_0_s_ifspec;

#ifndef __IEnumCATEGORYINFO_INTERFACE_DEFINED__
#define __IEnumCATEGORYINFO_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumCATEGORYINFO
 * at Wed Jun 26 18:29:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumCATEGORYINFO __RPC_FAR *LPENUNCATEGORYINFO;

typedef struct  tagCATEGORYINFO
    {
    CATID catid;
    LCID lcid;
    OLECHAR szDescription[ 128 ];
    }	CATEGORYINFO;

typedef struct tagCATEGORYINFO __RPC_FAR *LPCATEGORYINFO;


EXTERN_C const IID IID_IEnumCATEGORYINFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumCATEGORYINFO : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCATEGORYINFOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumCATEGORYINFOVtbl;

    interface IEnumCATEGORYINFO
    {
        CONST_VTBL struct IEnumCATEGORYINFOVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCATEGORYINFO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCATEGORYINFO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCATEGORYINFO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCATEGORYINFO_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumCATEGORYINFO_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumCATEGORYINFO_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCATEGORYINFO_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumCATEGORYINFO_Next_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumCATEGORYINFO_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCATEGORYINFO_Skip_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumCATEGORYINFO_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCATEGORYINFO_Reset_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This);


void __RPC_STUB IEnumCATEGORYINFO_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCATEGORYINFO_Clone_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumCATEGORYINFO_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCATEGORYINFO_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0007
 * at Wed Jun 26 18:29:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPCATREGISTER_DEFINED
#define _LPCATREGISTER_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0007_v0_0_s_ifspec;

#ifndef __ICatRegister_INTERFACE_DEFINED__
#define __ICatRegister_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatRegister
 * at Wed Jun 26 18:29:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ ICatRegister __RPC_FAR *LPCATREGISTER;


EXTERN_C const IID IID_ICatRegister;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICatRegister : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterCategories( 
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterCategories( 
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterClassImplCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterClassImplCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterClassReqCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterClassReqCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatRegisterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatRegister __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatRegister __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnRegisterCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterClassImplCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnRegisterClassImplCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterClassReqCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnRegisterClassReqCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        END_INTERFACE
    } ICatRegisterVtbl;

    interface ICatRegister
    {
        CONST_VTBL struct ICatRegisterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatRegister_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatRegister_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatRegister_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatRegister_RegisterCategories(This,cCategories,rgCategoryInfo)	\
    (This)->lpVtbl -> RegisterCategories(This,cCategories,rgCategoryInfo)

#define ICatRegister_UnRegisterCategories(This,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterCategories(This,cCategories,rgcatid)

#define ICatRegister_RegisterClassImplCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> RegisterClassImplCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_UnRegisterClassImplCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterClassImplCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_RegisterClassReqCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> RegisterClassReqCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_UnRegisterClassReqCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterClassReqCategories(This,rclsid,cCategories,rgcatid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICatRegister_RegisterCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]);


void __RPC_STUB ICatRegister_RegisterCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_UnRegisterCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_RegisterClassImplCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_RegisterClassImplCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_UnRegisterClassImplCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterClassImplCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_RegisterClassReqCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_RegisterClassReqCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_UnRegisterClassReqCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterClassReqCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatRegister_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0008
 * at Wed Jun 26 18:29:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPCATINFORMATION_DEFINED
#define _LPCATINFORMATION_DEFINED


extern RPC_IF_HANDLE __MIDL__intf_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0008_v0_0_s_ifspec;

#ifndef __ICatInformation_INTERFACE_DEFINED__
#define __ICatInformation_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatInformation
 * at Wed Jun 26 18:29:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ ICatInformation __RPC_FAR *LPCATINFORMATION;


EXTERN_C const IID IID_ICatInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface ICatInformation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumCategories( 
            /* [in] */ LCID lcid,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategoryDesc( 
            /* [in] */ REFCATID rcatid,
            /* [in] */ LCID lcid,
            /* [out] */ LPWSTR __RPC_FAR *pszDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumClassesOfCategories( 
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsClassOfCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumImplCategoriesOfClass( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumReqCategoriesOfClass( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatInformationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatInformation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatInformation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ LCID lcid,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCategoryDesc )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCATID rcatid,
            /* [in] */ LCID lcid,
            /* [out] */ LPWSTR __RPC_FAR *pszDesc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumClassesOfCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsClassOfCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumImplCategoriesOfClass )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumReqCategoriesOfClass )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);
        
        END_INTERFACE
    } ICatInformationVtbl;

    interface ICatInformation
    {
        CONST_VTBL struct ICatInformationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatInformation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatInformation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatInformation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatInformation_EnumCategories(This,lcid,ppenumCategoryInfo)	\
    (This)->lpVtbl -> EnumCategories(This,lcid,ppenumCategoryInfo)

#define ICatInformation_GetCategoryDesc(This,rcatid,lcid,pszDesc)	\
    (This)->lpVtbl -> GetCategoryDesc(This,rcatid,lcid,pszDesc)

#define ICatInformation_EnumClassesOfCategories(This,cImplemented,rgcatidImpl,cRequired,rgcatidReq,ppenumClsid)	\
    (This)->lpVtbl -> EnumClassesOfCategories(This,cImplemented,rgcatidImpl,cRequired,rgcatidReq,ppenumClsid)

#define ICatInformation_IsClassOfCategories(This,rclsid,cImplemented,rgcatidImpl,cRequired,rgcatidReq)	\
    (This)->lpVtbl -> IsClassOfCategories(This,rclsid,cImplemented,rgcatidImpl,cRequired,rgcatidReq)

#define ICatInformation_EnumImplCategoriesOfClass(This,rclsid,ppenumCatid)	\
    (This)->lpVtbl -> EnumImplCategoriesOfClass(This,rclsid,ppenumCatid)

#define ICatInformation_EnumReqCategoriesOfClass(This,rclsid,ppenumCatid)	\
    (This)->lpVtbl -> EnumReqCategoriesOfClass(This,rclsid,ppenumCatid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICatInformation_EnumCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ LCID lcid,
    /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo);


void __RPC_STUB ICatInformation_EnumCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatInformation_GetCategoryDesc_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCATID rcatid,
    /* [in] */ LCID lcid,
    /* [out] */ LPWSTR __RPC_FAR *pszDesc);


void __RPC_STUB ICatInformation_GetCategoryDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatInformation_EnumClassesOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);


void __RPC_STUB ICatInformation_EnumClassesOfCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatInformation_IsClassOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]);


void __RPC_STUB ICatInformation_IsClassOfCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatInformation_EnumImplCategoriesOfClass_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);


void __RPC_STUB ICatInformation_EnumImplCategoriesOfClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatInformation_EnumReqCategoriesOfClass_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);


void __RPC_STUB ICatInformation_EnumReqCategoriesOfClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatInformation_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0009
 * at Wed Jun 26 18:29:20 1996
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


#endif


extern RPC_IF_HANDLE __MIDL__intf_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0009_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\control.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    control.cpp

Abstract:

    Implementation of ISystemMonitor, IOleControl, ISpecifyPP, 
    IProvideClassInfo interfaces.

--*/

#include "polyline.h"
#include "unkhlpr.h"
#include "unihelpr.h"

#include "ctrprop.h"
#include "grphprop.h"
#include "genprop.h"
#include "appearprop.h"
#include "logsrc.h"
#include "srcprop.h"



//----------------------------------------------------------------------------
// CImpISpecifyPP Interface Implementation
//----------------------------------------------------------------------------

// Standard IUnknown for contained interface
IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpISpecifyPP)


STDMETHODIMP
CImpISpecifyPP::GetPages (
    OUT CAUUID *pPages
    )

/*++

Routine Description:

    GetPages returns an allocated array of property page GUIDs for Sysmon graph.
    There are three pages: general, graph, and counter.

Arguments:

    pPages - Pointer to GUID array header filled in by this routine

Return Value:

    HRESULT - NOERROR or OUT_OF_MEMORY

--*/

{
    HRESULT hr = E_POINTER;
    IMalloc *pIMalloc = NULL;
    GUID    *pGUID = NULL;

    if ( NULL != pPages ) {
        pPages->cElems = 0;
        pPages->pElems = NULL;

        // Get Ole Malloc and allocate array
        if ( FAILED(CoGetMalloc(MEMCTX_TASK, &pIMalloc)) )
            return E_OUTOFMEMORY;

        pGUID = (GUID*)pIMalloc->Alloc((CPROPPAGES) * sizeof(GUID));

        if (NULL != pGUID) {

            // Fill the structure
            pGUID[GENERAL_PROPPAGE] = CLSID_GeneralPropPage;
            pGUID[SOURCE_PROPPAGE] = CLSID_SourcePropPage;
            pGUID[COUNTER_PROPPAGE] = CLSID_CounterPropPage;
            pGUID[GRAPH_PROPPAGE] = CLSID_GraphPropPage;
            pGUID[APPEAR_PROPPAGE] = CLSID_AppearPropPage;

            pPages->cElems = CPROPPAGES;
            pPages->pElems = pGUID;
        }

        pIMalloc->Release();

        hr = (NULL != pGUID) ? NOERROR : E_OUTOFMEMORY;
    } 
    return hr;
}


//----------------------------------------------------------------------------
// CImpIProvideClassInfo Interface Implementation
//----------------------------------------------------------------------------

// Standard IUnknown for contained interface
IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpIProvideClassInfo)


STDMETHODIMP
CImpIProvideClassInfo::GetClassInfo (
    OUT LPTYPEINFO *ppTI
    )

/*++

Routine Description:

    GetClassInfo returns an ITypeInfo interface to its type lib information.
    The interface is obtained by querying the contained ITypeLib interface.

Arguments:

    ppTI - Pointer to returned ITypeInfo interface

Return Value:

    HRESULT

--*/

{
    if (NULL == ppTI)
        return E_POINTER;

    *ppTI = NULL;

    return m_pObj->m_pITypeLib->GetTypeInfoOfGuid(CLSID_SystemMonitor, ppTI);
}


//----------------------------------------------------------------------------
//  CImpISystemMonitor Interface Implementation
//----------------------------------------------------------------------------

// Standard IUnknown for contained interface
IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpISystemMonitor)

STDMETHODIMP
CImpISystemMonitor::put_Appearance (
    IN INT iAppearance
    )
{
    HRESULT hr = E_INVALIDARG;
    // 0 = Flat, 1 = 3D
    if ( ( 0 == iAppearance ) || ( 1 == iAppearance ) ) {
        m_pObj->m_pCtrl->put_Appearance( iAppearance, FALSE );
        hr =  NOERROR;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::get_Appearance (
    OUT INT *piAppearance
    )
{
    HRESULT hr = E_POINTER;

    if ( NULL != piAppearance ) {
        *piAppearance = m_pObj->m_Graph.Options.iAppearance;
        if (*piAppearance == NULL_APPEARANCE)
            *piAppearance = m_pObj->m_pCtrl->Appearance();
        hr = NOERROR;
    }
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_BackColor (
    IN OLE_COLOR Color
    )
{
    m_pObj->m_pCtrl->put_BackPlotColor(Color, FALSE);
    return NOERROR;
}

STDMETHODIMP
CImpISystemMonitor::get_BackColor (
    OUT OLE_COLOR *pColor
    )
{
    HRESULT hr = E_POINTER;

    if ( NULL != pColor ) {
        *pColor = m_pObj->m_Graph.Options.clrBackPlot;
        if (*pColor == NULL_COLOR)
            *pColor = m_pObj->m_pCtrl->clrBackPlot();
        hr = NOERROR;
    }
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_BackColorCtl (
    IN OLE_COLOR Color
    )
{
    m_pObj->m_pCtrl->put_BackCtlColor(Color);
    return NOERROR;
}

STDMETHODIMP
CImpISystemMonitor::get_BackColorCtl (
    OUT OLE_COLOR *pColor
    )
{
    HRESULT hr = E_POINTER;

    if ( NULL != pColor ) {
        // NT 5.0 Beta 1 files can be saved with NULL BackColorCtl.
        *pColor = m_pObj->m_Graph.Options.clrBackCtl;
        if (*pColor == NULL_COLOR)
            *pColor = m_pObj->m_pCtrl->clrBackCtl();
        hr = NOERROR;
    }
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_GridColor (
    IN OLE_COLOR Color
    )
{
    m_pObj->m_pCtrl->put_GridColor(Color);
    return NOERROR;
}

STDMETHODIMP
CImpISystemMonitor::get_GridColor (
    OUT OLE_COLOR *pColor
    )
{
    HRESULT hr = E_POINTER;

    if ( NULL != pColor ) {
        *pColor = m_pObj->m_Graph.Options.clrGrid;
        hr = NOERROR;
    }
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_TimeBarColor (
    IN OLE_COLOR Color )
{
    m_pObj->m_pCtrl->put_TimeBarColor(Color);
    return NOERROR;
}

STDMETHODIMP
CImpISystemMonitor::get_TimeBarColor (
    OUT OLE_COLOR *pColor )
{
    HRESULT hr = E_POINTER;

    if ( NULL != pColor ) {
        *pColor = m_pObj->m_Graph.Options.clrTimeBar;
        hr = NOERROR;
    }
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_BorderStyle (
    IN INT iBorderStyle
    )
{    
    HRESULT hr;
    // 0 = none, 1 = single.
    if ( ( 0 == iBorderStyle ) || ( 1 == iBorderStyle ) ) {
        m_pObj->m_pCtrl->put_BorderStyle( iBorderStyle, FALSE );
        hr =  NOERROR;
    } else {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::get_BorderStyle (
    OUT INT *piBorderStyle
    )
{
    HRESULT hr = E_POINTER;

    if ( NULL != piBorderStyle ) {
        *piBorderStyle = m_pObj->m_Graph.Options.iBorderStyle;
        if (*piBorderStyle == NULL_BORDERSTYLE)
            *piBorderStyle = m_pObj->m_pCtrl->BorderStyle();
        hr = NOERROR;
    }
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_ForeColor (
    IN OLE_COLOR Color
    )
{
    m_pObj->m_pCtrl->put_FgndColor(Color, FALSE);
    return NOERROR;
}

STDMETHODIMP
CImpISystemMonitor::get_ForeColor (
    OUT OLE_COLOR *pColor
    )
{
    HRESULT hr = E_POINTER;

    if ( NULL != pColor ) {
        *pColor = m_pObj->m_Graph.Options.clrFore;
        if (*pColor == NULL_COLOR)
            *pColor = m_pObj->m_pCtrl->clrFgnd();
        hr = NOERROR;
    }
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::putref_Font (
    IN IFontDisp *pFontDisp
    )
{
    LPFONT  pIFont;

    HRESULT hr;

    if ( NULL == pFontDisp ) {
        hr = E_POINTER;
    } else {
        hr = pFontDisp->QueryInterface(IID_IFont, (PPVOID)&pIFont);
        if (SUCCEEDED(hr)) {
            hr = m_pObj->m_pCtrl->put_Font ( pIFont, FALSE );
        }
        pIFont->Release();
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::get_Font (
    OUT IFontDisp **ppFont
)
{
    HRESULT hr = E_POINTER;

    if ( NULL != ppFont ) {
        hr = m_pObj->m_pCtrl->m_OleFont.GetFontDisp(ppFont);
    } 
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_ShowVerticalGrid (
    IN VARIANT_BOOL bVisible
    )

/*++

Routine Description:

    Shows/hides the vertical grid.

Arguments:

    bVisible - Visibility  (TRUE = show, FALSE = hide)

Return Value:

    HRESULT

--*/

{
    m_pObj->m_Graph.Options.bVertGridChecked = bVisible;
    m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_PLOT);
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::get_ShowVerticalGrid (
    OUT VARIANT_BOOL *pbState
    )

/*++

Routine Description:

    Gets the vertical grid visibility state.

Arguments:

    pbState - pointer to returned state (TRUE = visible, FALSE = hidden)

Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_POINTER;

    if ( NULL != pbState ) {
        *pbState = (short)m_pObj->m_Graph.Options.bVertGridChecked;
        hr = NOERROR;
    }
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_ShowHorizontalGrid(
    IN VARIANT_BOOL bVisible
    )

/*++

Routine Description:

    Shows/hides the horizontal grid.

Arguments:

    bVisible - Visibility (TRUE = show, FALSE = hide)

Return Value:

    HRESULT

--*/

{
    m_pObj->m_Graph.Options.bHorzGridChecked = bVisible;
    m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_PLOT);
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::get_ShowHorizontalGrid (
    OUT VARIANT_BOOL *pbState
    )
/*++

Routine Description:

    Gets the horizontal grid visibility state.

Arguments:

    pbState - pointer to returned state (TRUE = visible, FALSE = hidden)

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_POINTER;

    if ( NULL != pbState ) {
        *pbState = (short)m_pObj->m_Graph.Options.bHorzGridChecked;
        hr = NOERROR;
    }
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_Highlight(
    IN VARIANT_BOOL bState
    )

/*++

Routine Description:

    Sets the highlight state.  If true, the selected counter is 
    always highlighted in the graph.

Arguments:

    bState - Highlight (TRUE = highlight, FALSE = no highlight)

Return Value:

    HRESULT

--*/

{
    m_pObj->m_pCtrl->put_Highlight(bState);
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::get_Highlight (
    OUT VARIANT_BOOL *pbState
    )
/*++

Routine Description:

    Gets the highlight state.

Arguments:

    pbState - pointer to returned state (TRUE = highlight, FALSE = no highlight)

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_POINTER;

    if ( NULL != pbState ) {
        *pbState = (short)m_pObj->m_Graph.Options.bHighlight;
        hr = NOERROR;
    }
    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_ShowLegend (
    IN VARIANT_BOOL bState
    )

/*++

Routine Description:

    Shows/hides the graph legend.

Arguments:

    bVisible - Visibility (TRUE = show, FALSE = hide)

Return Value:

    HRESULT

--*/

{
    m_pObj->m_Graph.Options.bLegendChecked = bState;
    m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_LAYOUT);
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::get_ShowLegend (
    OUT VARIANT_BOOL *pbState
    )
/*++

Routine Description:

    Gets the legend visibility state.

Arguments:

    pbState - pointer to returned state (TRUE = visible, FALSE = hidden)

Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_POINTER;

    if ( NULL != pbState ) {
        *pbState = (short)m_pObj->m_Graph.Options.bLegendChecked;
        hr = NOERROR;
    }
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_ShowToolbar (
    IN VARIANT_BOOL bState
    )

/*++

Routine Description:

    Shows/hides the graph toolbar

Arguments:

    bState = Visibility (TRUE = show, FALSE = hide)

Return Value:

    HRESULT

--*/

{
    m_pObj->m_Graph.Options.bToolbarChecked = bState;
    m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_LAYOUT);
    return NOERROR;
}

STDMETHODIMP
CImpISystemMonitor::get_ShowToolbar (
    OUT VARIANT_BOOL *pbState
    )
/*++

Routine Description:

    Gets the legend visibility state.

Arguments:

    pbState - pointer to returned state (TRUE = visible, FALSE = hidden)

Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_POINTER;

    if ( NULL != pbState ) {
        *pbState = (short)m_pObj->m_Graph.Options.bToolbarChecked;
        hr = NOERROR;
    }
    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_ShowScaleLabels (
    IN VARIANT_BOOL bState
    )

/*++

Routine Description:

    Shows/hides the vertical scale numbers.

Arguments:

    bVisible - Visibility (TRUE = show, FALSE = hide)

Return Value:

    HRESULT

--*/

{
    m_pObj->m_Graph.Options.bLabelsChecked = bState;
    m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_LAYOUT);
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::get_ShowScaleLabels (
    OUT VARIANT_BOOL *pbState
    )

/*++

Routine Description:

    Gets the visibility state of the vertical scale numbers.

Arguments:

    pbState - pointer to returned state (TRUE = visible, FALSE = hidden)

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_POINTER;

    if ( NULL != pbState ) {
        *pbState = (short)m_pObj->m_Graph.Options.bLabelsChecked;
        hr = NOERROR;
    }
    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_ShowValueBar (
    IN VARIANT_BOOL bState
    )

/*++

Routine Description:

    Shows/hides the graph statistics bar.

Arguments:

    bVisible - Visibility (TRUE = show, FALSE = hide)

Return Value:

    HRESULT

--*/

{
    m_pObj->m_Graph.Options.bValueBarChecked = bState;
    m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_LAYOUT);
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::get_ShowValueBar(
    OUT VARIANT_BOOL *pbState
    )
/*++

Routine Description:

    Gets the statistics bar visibility state.

Arguments:

    pbState - pointer to returned state (TRUE = visible, FALSE = hidden)

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_POINTER;

    if ( NULL != pbState ) {
        *pbState = (short)m_pObj->m_Graph.Options.bValueBarChecked;
        hr = NOERROR;
    }
    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_MaximumScale (
    IN INT iValue
    )

/*++

Routine Description:

    Sets the vertical scale maximum value.

Arguments:

    iValue - Maximum value

Return Value:

    HRESULT

--*/

{

    if ( ( iValue <= MAX_VERTICAL_SCALE ) && (iValue > m_pObj->m_Graph.Options.iVertMin ) ) {
        m_pObj->m_Graph.Options.iVertMax = iValue;
        m_pObj->m_Graph.Scale.SetMaxValue(iValue);
        m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_LAYOUT);
        return NOERROR;
    } else {
        return E_INVALIDARG;
    }
}


STDMETHODIMP
CImpISystemMonitor::get_MaximumScale (
    OUT INT *piValue
    )

/*++

Routine Description:

    Gets the vertical scale's maximum value.

Arguments:

    piValue = pointer to returned value

Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_POINTER;

    if ( NULL != piValue ) {
        *piValue =  m_pObj->m_Graph.Options.iVertMax;
        hr = NOERROR;
    }
    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_MinimumScale (
    IN INT iValue
    )

/*++

Routine Description:

    Sets the vertical scale minimum value.

Arguments:

    iValue - Minimum value

Return Value:

    None.

--*/

{
    if ( ( iValue >= MIN_VERTICAL_SCALE ) && (iValue < m_pObj->m_Graph.Options.iVertMax ) ) {
        m_pObj->m_Graph.Options.iVertMin = iValue;
        m_pObj->m_Graph.Scale.SetMinValue(iValue);
        m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_LAYOUT);
        return NOERROR;
    } else {
        return E_INVALIDARG;
    }
}


STDMETHODIMP
CImpISystemMonitor::get_MinimumScale (
    OUT INT *piValue
    )
/*++

Routine Description:

    Gets the vertical scale's minimum value.

Arguments:

    piValue = pointer to returned value

Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_POINTER;

    if ( NULL != piValue ) {
        *piValue =  m_pObj->m_Graph.Options.iVertMin;
        hr = NOERROR;
    }
    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_UpdateInterval (
    IN FLOAT fValue
    )

/*++

Routine Description:

    Sets the graph sample interval.

Arguments:

    fValue - Update interval in seconds (can be fraction)

Return Value:

    HRESULT

--*/

{
    if ( ( fValue >= MIN_UPDATE_INTERVAL ) && (fValue <= MAX_UPDATE_INTERVAL ) ) {
        m_pObj->m_Graph.Options.fUpdateInterval = fValue;
        m_pObj->m_pCtrl->SetIntervalTimer();
        return NOERROR;
    } else {
        return E_INVALIDARG;
    }
}

STDMETHODIMP
CImpISystemMonitor::get_UpdateInterval (
    OUT FLOAT *pfValue
    )

/*++

Routine Description:

    Gets the graph's sample interval measured in seconds.

Arguments:

    pfValue = pointer to returned value

Return Value:

   HRESULT

--*/

{
    HRESULT hr = E_POINTER;

    if ( NULL != pfValue ) {
        *pfValue = m_pObj->m_Graph.Options.fUpdateInterval;
        hr = NOERROR;
    }
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_DisplayFilter (
    IN INT iValue
    )

/*++

Routine Description:

    Sets the graph display filter - samples per display interval.

Arguments:

    iValue - Update interval in samples 

Return Value:

    HRESULT

--*/

{
    if ( iValue > 0 ) {
        // TodoDisplayFilter:  Support for display filter > sample filter.
        if ( 1 == iValue ) {
            // TodoDisplayFilter:  Display filter units = seconds instead of samples
            m_pObj->m_Graph.Options.iDisplayFilter = iValue;
    //        m_pObj->m_pCtrl->SetIntervalTimer();
            return NOERROR;
        } else {
            return E_INVALIDARG;
        }
    } else {
        return E_INVALIDARG;
    }
}


STDMETHODIMP
CImpISystemMonitor::get_DisplayFilter (
    OUT INT *piValue
    )

/*++

Routine Description:

    Gets the graph's display interval measured in samples.

Arguments:

    piValue = pointer to returned value

Return Value:

   HRESULT

--*/

{
    HRESULT hr = E_POINTER;

    if ( NULL != piValue ) {
        *piValue = m_pObj->m_Graph.Options.iDisplayFilter;
        hr = NOERROR;
    }
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_DisplayType (
    IN eDisplayTypeConstant eDisplayType
    )

/*++

Routine Description:

    Selects display type (1 = line plot, 2 = histogram, 3 = Report)

Arguments:

    eDisplayType - Display type

Return Value:

    HRESULT

--*/

{
    INT iUpdate;

    if (eDisplayType < LINE_GRAPH || eDisplayType > REPORT_GRAPH)
        return E_INVALIDARG;

    if (m_pObj->m_Graph.Options.iDisplayType == REPORT_GRAPH ||
        eDisplayType == REPORT_GRAPH)
        iUpdate = UPDGRPH_VIEW;
    else
        iUpdate = UPDGRPH_PLOT;

    m_pObj->m_Graph.Options.iDisplayType = eDisplayType;
    m_pObj->m_pCtrl->UpdateGraph(iUpdate);
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::get_DisplayType (
    OUT eDisplayTypeConstant *peDisplayType
    )

/*++

Routine Description:

    Get graph display type (1 = line plot, 2 = histogram, 3 = Report)

Arguments:

    peDisplayType = pointer to returned value

Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_POINTER;

    if ( NULL != peDisplayType ) {
        *peDisplayType = (eDisplayTypeConstant)m_pObj->m_Graph.Options.iDisplayType;
        hr = NOERROR;
    }
    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_ManualUpdate (
    IN VARIANT_BOOL bMode
    )

/*++

Routine Description:

    Sets/clears manual update mode. Manual mode suspends periodic updates
    of the graph.

Arguments:

    bMode - Manual mode (TRUE = On, FALSE = Off)

Return Value:

    HRESULT

--*/

{
    m_pObj->m_pCtrl->put_ManualUpdate ( bMode );
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::get_ManualUpdate (
    OUT VARIANT_BOOL *pbState
    )
/*++

Routine Description:

    Gets manual update mode.

Arguments:

    pbState = pointer to returned state (TRUE = On, FALSE = Off)

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_POINTER;

    if ( NULL != pbState ) {
        *pbState = (short)m_pObj->m_Graph.Options.bManualUpdate;
        hr = NOERROR;
    }
    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_GraphTitle (
    IN BSTR bstrTitle
    )

/*++

Routine Description:

    Sets the graph title.

Arguments:

    bstrTitle - Title string

Return Value:

    HRESULT

--*/

{
    LPTSTR  pszTemp;
    LPTSTR  pszTitle;

    USES_CONVERSION

    if ( (bstrTitle == NULL) || (bstrTitle[0] == 0) ) {
        delete m_pObj->m_Graph.Options.pszGraphTitle;
        m_pObj->m_Graph.Options.pszGraphTitle = NULL;
    }
    else {
        pszTemp = W2T(bstrTitle);
        pszTitle = new TCHAR [lstrlen(pszTemp) + 1];

        if (pszTitle) {
            lstrcpy(pszTitle, pszTemp);
            delete m_pObj->m_Graph.Options.pszGraphTitle;
            m_pObj->m_Graph.Options.pszGraphTitle = pszTitle;
        }
        else {
            return E_OUTOFMEMORY;
        }

    }

    m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_LAYOUT);

    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::get_GraphTitle (
    BSTR *pbsTitle
    )

/*++

Routine Description:

    Gets the graph title string. The caller is responsible for releasing the
    string memory.

Arguments:

    pbsTitle - pointer to returned title (BSTR)

Return Value:

    HResult

--*/

{
    HRESULT hr = E_POINTER;

    USES_CONVERSION

    if ( NULL != pbsTitle ) {
        *pbsTitle = NULL;

        if (m_pObj->m_Graph.Options.pszGraphTitle != NULL) {
            *pbsTitle = SysAllocString(T2W(m_pObj->m_Graph.Options.pszGraphTitle));
            if (*pbsTitle == NULL)
                hr = E_OUTOFMEMORY;
        }
        hr = NOERROR;
    }
    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_LogFileName (
    IN BSTR bstrLogFile
    )

/*++

Routine Description:

    Sets the log file name

Arguments:

    bstrLogFile - File name string

Return Value:

    HRESULT

--*/

{
    HRESULT hr = S_OK;
    LPTSTR  pszLogFile = NULL;
    LONG    lCount;

    USES_CONVERSION

    // Ensure that the current log file count is 0 or 1
    lCount = m_pObj->m_pCtrl->NumLogFiles();

    // Get the current data source type

    if ( 0 == lCount || 1 == lCount ) {

        // Reset the data source type to null data source while completing this operation.
        // TodoLogFiles:  Possible to keep the previous put_LogFileName semantics,
        // where new query is opened (successfully) before closing the previous query?
        hr = m_pObj->m_pCtrl->put_DataSourceType ( sysmonNullDataSource );

        if ( SUCCEEDED ( hr ) ) {
            // TodoLogFiles:  What if multiple files exist?  Probably return error re:  not supported.
            if ( 1 == lCount ) {
                hr = m_pObj->m_pCtrl->RemoveSingleLogFile ( m_pObj->m_pCtrl->FirstLogFile() );
            }

            if ( SUCCEEDED ( hr ) ) {
                // Check name
                if (bstrLogFile != NULL && bstrLogFile[0] != 0) {
                    // If non-null name
                    // Convert from BSTR to internal string, then add the item.
                    pszLogFile = W2T(bstrLogFile);
                    hr = m_pObj->m_pCtrl->AddSingleLogFile ( pszLogFile );

                    if ( SUCCEEDED ( hr ) ) {
                        // put_DataSourceType attempts to set the data source type to sysmonCurrentActivity
                        // if sysmonLogFiles fails.
                        hr = m_pObj->m_pCtrl->put_DataSourceType ( sysmonLogFiles );

                    }
                }
            }
        }
    } else {
        hr = E_INVALIDARG;
    }

    return hr;
}


STDMETHODIMP
CImpISystemMonitor::get_LogFileName (
    BSTR *pbsLogFile
    )

/*++

Routine Description:

    Gets the log file name. The caller is responsible for releasing the
    string memory.
    This is an obsolete method supported only for backward compatibility.
    It cannot be used when multiple log files are loaded.

Arguments:

    pbsLogFile - pointer to returned name (BSTR)

Return Value:

    HResult

--*/

{
    HRESULT        hr          = NOERROR;
    LPCTSTR        pszFileName = NULL;
    LPTSTR         pszLogFile  = NULL;
    ULONG          LogFileSize = 0;
    CLogFileItem * pLogFile;
    LPTSTR         pszLogFileCurrent;

    USES_CONVERSION

    if (NULL != pbsLogFile) {
        *pbsLogFile = NULL;

        pLogFile = m_pObj->m_pCtrl->FirstLogFile();
        while (pLogFile) {
            pszFileName  = pLogFile->GetPath();
            LogFileSize += (lstrlen(pszFileName) + 1);
            pLogFile     = pLogFile->Next();
        }
        LogFileSize ++; // for the final NULL character
        pszLogFile = (LPTSTR) malloc(LogFileSize * sizeof(TCHAR));
        if (pszLogFile) {
            pLogFile          = m_pObj->m_pCtrl->FirstLogFile();
            pszLogFileCurrent = pszLogFile;
            while (pLogFile) {
                pszFileName         = pLogFile->GetPath();
                lstrcpy(pszLogFileCurrent, pszFileName);
                pszLogFileCurrent  += lstrlen(pszFileName);
                * pszLogFileCurrent = _T('\0');
                pszLogFileCurrent ++;
                pLogFile            = pLogFile->Next();
            }
            * pszLogFileCurrent = _T('\0');
            * pbsLogFile = SysAllocStringLen(pszLogFile, LogFileSize);
            if (NULL == * pbsLogFile) {
                hr = E_OUTOFMEMORY;
            }
            free(pszLogFile);
        }
        else {
            hr = E_OUTOFMEMORY;
        }
    }
    else {
        hr = E_POINTER;
    }
    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_DataSourceType (
    IN eDataSourceTypeConstant eDataSourceType
    )

/*++

Routine Description:

    Selects data source type (1 = current activity, 2 = log files)

Arguments:

    eDataSourceType - Data source type

Return Value:

    HRESULT

--*/

{
    if ( eDataSourceType != sysmonCurrentActivity  
        && eDataSourceType != sysmonLogFiles
        && sysmonNullDataSource != eDataSourceType
        && eDataSourceType !=  sysmonSqlLog) {
        return E_INVALIDARG;
    }

    return m_pObj->m_pCtrl->put_DataSourceType( eDataSourceType );
}

STDMETHODIMP
CImpISystemMonitor::get_DataSourceType (
    OUT eDataSourceTypeConstant *peDataSourceType
    )

/*++

Routine Description:

    Get data source type (1 = current activity, 2 = log files)

Arguments:

    peDataSourceType = pointer to returned value

Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_POINTER;

    if ( NULL != peDataSourceType ) {
        hr = m_pObj->m_pCtrl->get_DataSourceType ( *peDataSourceType );
    }
    return hr;
}


STDMETHODIMP
CImpISystemMonitor::get_LogFiles (
    ILogFiles **ppILogFiles
    )
{
    HRESULT hr = E_POINTER;
    if ( NULL != ppILogFiles ) {
        *ppILogFiles = m_pObj->m_pImpILogFiles;
        if ( NULL != *ppILogFiles ) {
            (*ppILogFiles)->AddRef();
        }
        hr = NOERROR;
    }
    return hr;
}
STDMETHODIMP
CImpISystemMonitor::put_LogViewStart (
    IN DATE dateStart
    )
{
    LONGLONG llTestStart;
    if ( VariantDateToLLTime(dateStart, &llTestStart ) ) {

        // No error.  If start time is past current stop time, reset it to the current stop time.
        if ( llTestStart <= m_pObj->m_pCtrl->m_DataSourceInfo.llStopDisp ){
            if ( llTestStart >= m_pObj->m_pCtrl->m_DataSourceInfo.llBeginTime ) {
                m_pObj->m_pCtrl->m_DataSourceInfo.llStartDisp = llTestStart;
            } else {
                m_pObj->m_pCtrl->m_DataSourceInfo.llStartDisp = m_pObj->m_pCtrl->m_DataSourceInfo.llBeginTime;
            }
        } else {
            m_pObj->m_pCtrl->m_DataSourceInfo.llStartDisp = m_pObj->m_pCtrl->m_DataSourceInfo.llStopDisp;
        }

        m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_LOGVIEW);
        return NOERROR;
    
    } else {
        return E_FAIL;
    }
}

STDMETHODIMP
CImpISystemMonitor::get_LogViewStart (
    OUT DATE *pdateStart
    )
{
    HRESULT hr = E_POINTER;
    if ( NULL != pdateStart ) {

        if (LLTimeToVariantDate(m_pObj->m_pCtrl->m_DataSourceInfo.llStartDisp, pdateStart))
            hr = NOERROR;
        else
            hr = E_FAIL;
    }
    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_LogViewStop (
    IN DATE dateStop
    )
{
    LONGLONG llTestStop;

    if ( VariantDateToLLTime(dateStop, &llTestStop ) ) {
        // No error.  If requested stop time is earlier than current start time, set it to 
        // the current start time.
        if ( llTestStop >= m_pObj->m_pCtrl->m_DataSourceInfo.llStartDisp ) {
            if ( llTestStop <= m_pObj->m_pCtrl->m_DataSourceInfo.llEndTime ) {
                m_pObj->m_pCtrl->m_DataSourceInfo.llStopDisp = llTestStop;
            } else {
                m_pObj->m_pCtrl->m_DataSourceInfo.llStopDisp = m_pObj->m_pCtrl->m_DataSourceInfo.llEndTime;
            }
        } else {
            m_pObj->m_pCtrl->m_DataSourceInfo.llStopDisp = m_pObj->m_pCtrl->m_DataSourceInfo.llStartDisp;
        }
        m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_LOGVIEW);
        return NOERROR;
    } else {
        return E_FAIL;
    }
}


STDMETHODIMP
CImpISystemMonitor::get_LogViewStop (
    OUT DATE *pdateStop )
{
    HRESULT hr = E_POINTER;

    if ( NULL != pdateStop ) {
        if (LLTimeToVariantDate(m_pObj->m_pCtrl->m_DataSourceInfo.llStopDisp, pdateStop))
            hr = NOERROR;
        else
            hr = E_FAIL;
    }
    return hr;
}


STDMETHODIMP
CImpISystemMonitor::put_YAxisLabel (
    IN BSTR bstrLabel
    )

/*++

Routine Description:

    Sets the Y axis label string.

Arguments:

    bstrLabel - Label string

Return Value:

    HRESULT

--*/

{
    LPTSTR  pszTemp = NULL;
    LPTSTR  pszTitle = NULL;

    USES_CONVERSION

    if ( (bstrLabel == NULL) || (bstrLabel[0] == 0) ) {
        delete m_pObj->m_Graph.Options.pszYaxisTitle;
        m_pObj->m_Graph.Options.pszYaxisTitle = NULL;
    }
    else {
        pszTemp = W2T(bstrLabel);
        pszTitle = new TCHAR [lstrlen(pszTemp) + 1];

        if (pszTitle) {
            lstrcpy(pszTitle, pszTemp);
            delete m_pObj->m_Graph.Options.pszYaxisTitle;
            m_pObj->m_Graph.Options.pszYaxisTitle = pszTitle;
        }
        else {
            return E_OUTOFMEMORY;
        }
    }

    m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_LAYOUT);
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::get_YAxisLabel (
    BSTR *pbsTitle
    )
/*++

Routine Description:

    Gets the Y axis title string. The caller is responsible for releasing the
    string memory.

Arguments:

    pbsTitle -  pointer to returned title (BSTR)

Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_POINTER;

    USES_CONVERSION

    if ( NULL != pbsTitle ) {
        *pbsTitle = NULL;

        if (m_pObj->m_Graph.Options.pszYaxisTitle != NULL) {

            *pbsTitle = SysAllocString(T2W(m_pObj->m_Graph.Options.pszYaxisTitle));
            if (*pbsTitle != NULL) {
                hr = NOERROR;
            } else {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::get_Counters (
    ICounters **ppICounters
    )
{
    HRESULT hr = E_POINTER;

    if ( NULL != ppICounters ) {
        *ppICounters = m_pObj->m_pImpICounters;
        (*ppICounters)->AddRef();
        hr = NOERROR;
    } 
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_ReadOnly (
    IN VARIANT_BOOL bState )
{
    BOOL bStateLocal = FALSE;

    if ( bState ) 
        bStateLocal = TRUE;
    m_pObj->m_Graph.Options.bReadOnly = bStateLocal;
    m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_VIEW);
    return NOERROR;
}

STDMETHODIMP
CImpISystemMonitor::get_ReadOnly (
    OUT VARIANT_BOOL *pbState )
{
    HRESULT hr = E_POINTER;

    if ( NULL != pbState ) {
        *pbState = (short)m_pObj->m_Graph.Options.bReadOnly;
        hr = NOERROR;
    } 
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_ReportValueType (
    IN eReportValueTypeConstant eReportValueType
    )

/*++

Routine Description:

    Selects report value type 
        0 = default value (current for live data, average for log file) 
        1 = current value  
        2 = average over the graph display interval 
        3 = minimum for the graph display interval
        4 = maximum for the graph display interval

Arguments:

    eReportValueType - Report valuex

Return Value:

    HRESULT

--*/

{
    if (eReportValueType < sysmonDefaultValue || eReportValueType > sysmonMaximum )
        return E_INVALIDARG;

    m_pObj->m_Graph.Options.iReportValueType = eReportValueType;

    // Update the graph for both report and histogram views.
    if (m_pObj->m_Graph.Options.iDisplayType != LINE_GRAPH )
        m_pObj->m_pCtrl->UpdateGraph(UPDGRPH_VIEW);

    return NOERROR;
}

STDMETHODIMP
CImpISystemMonitor::get_ReportValueType (
    OUT eReportValueTypeConstant *peReportValueType
    )

/*++

Routine Description:

    Get report value type 
        0 = default value (current for live data, average for log file) 
        1 = current value  
        2 = average over the graph display interval 
        3 = minimum for the graph display interval
        4 = maximum for the graph display interval

Arguments:

    peReportValueType = pointer to returned value

Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_POINTER;

    if ( NULL != peReportValueType ) {
        *peReportValueType = (eReportValueTypeConstant)m_pObj->m_Graph.Options.iReportValueType;
        hr = NOERROR;
    }
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_MonitorDuplicateInstances(
    IN VARIANT_BOOL bState
    )

/*++

Routine Description:

    Allows/disallows monitoring of duplicate counter instances.

Arguments:

    bState -  TRUE = allow, FALSE = disallow)

Return Value:

    HRESULT

--*/

{
    m_pObj->m_Graph.Options.bMonitorDuplicateInstances = bState;
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::get_MonitorDuplicateInstances (
    OUT VARIANT_BOOL *pbState
    )
/*++

Routine Description:

    Gets the state of allowing monitoring of duplicate counter instances.

Arguments:

    pbState - pointer to returned state ( TRUE = allow, FALSE = disallow )

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_POINTER;

    if ( NULL != pbState ) {
        *pbState = (short)m_pObj->m_Graph.Options.bMonitorDuplicateInstances;
        hr = NOERROR;
    }
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_SqlDsnName (
    IN BSTR bsSqlDsnName
    )

/*++

Routine Description:

    Sets the SQL logset DSN name.

Return Value:

    HRESULT

--*/

{
    HRESULT hr           = NOERROR;
    LPTSTR  szTemp       = NULL;
    LPTSTR  szSqlDsnName = NULL;

    USES_CONVERSION

    if ((bsSqlDsnName == NULL) || (bsSqlDsnName[0] == 0)) {
        if (m_pObj->m_pCtrl->m_DataSourceInfo.szSqlDsnName) {
            delete m_pObj->m_pCtrl->m_DataSourceInfo.szSqlDsnName;
            m_pObj->m_pCtrl->m_DataSourceInfo.szSqlDsnName = NULL;
        }
    }
    else {
        szTemp       = W2T(bsSqlDsnName);
        szSqlDsnName = new TCHAR [lstrlen(szTemp) + 1];

        if (szSqlDsnName) {
            lstrcpy(szSqlDsnName, szTemp);
            delete m_pObj->m_pCtrl->m_DataSourceInfo.szSqlDsnName;
            m_pObj->m_pCtrl->m_DataSourceInfo.szSqlDsnName = szSqlDsnName;
        }
        else {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::get_SqlDsnName (
    BSTR * bsSqlDsnName
    )
/*++

Routine Description:

    Gets SQL DSN name string. The caller is responsible for releasing the
    string memory.

Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_POINTER;

    USES_CONVERSION

    if (bsSqlDsnName != NULL) {
        * bsSqlDsnName = NULL;
        if (m_pObj->m_pCtrl->m_DataSourceInfo.szSqlDsnName != NULL) {
            * bsSqlDsnName = SysAllocString(
                    T2W(m_pObj->m_pCtrl->m_DataSourceInfo.szSqlDsnName));
            if (* bsSqlDsnName != NULL) {
                hr = NOERROR;
            }
            else {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::put_SqlLogSetName (
    IN BSTR bsSqlLogSetName
    )

/*++

Routine Description:

    Sets the SQL logset DSN name.

Return Value:

    HRESULT

--*/

{
    HRESULT hr              = NOERROR;
    LPTSTR  szTemp          = NULL;
    LPTSTR  szSqlLogSetName = NULL;

    USES_CONVERSION

    if ((bsSqlLogSetName == NULL) || (bsSqlLogSetName[0] == 0)) {
        if (m_pObj->m_pCtrl->m_DataSourceInfo.szSqlLogSetName) {
            delete m_pObj->m_pCtrl->m_DataSourceInfo.szSqlLogSetName;
            m_pObj->m_pCtrl->m_DataSourceInfo.szSqlLogSetName = NULL;
        }
    }
    else {
        szTemp          = W2T(bsSqlLogSetName);
        szSqlLogSetName = new TCHAR [lstrlen(szTemp) + 1];

        if (szSqlLogSetName) {
            lstrcpy(szSqlLogSetName, szTemp);
            delete m_pObj->m_pCtrl->m_DataSourceInfo.szSqlLogSetName;
            m_pObj->m_pCtrl->m_DataSourceInfo.szSqlLogSetName = szSqlLogSetName;
        }
        else {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::get_SqlLogSetName (
    BSTR * bsSqlLogSetName
    )
/*++

Routine Description:

    Gets SQL DSN name string. The caller is responsible for releasing the
    string memory.

Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_POINTER;

    USES_CONVERSION

    if (bsSqlLogSetName != NULL) {
        * bsSqlLogSetName = NULL;
        if (m_pObj->m_pCtrl->m_DataSourceInfo.szSqlLogSetName != NULL) {
            * bsSqlLogSetName = SysAllocString(
                    T2W(m_pObj->m_pCtrl->m_DataSourceInfo.szSqlLogSetName));
            if (* bsSqlLogSetName != NULL) {
                hr = NOERROR;
            }
            else {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

STDMETHODIMP
CImpISystemMonitor::Counter (
    IN INT iIndex,
    OUT ICounterItem **ppItem
    )

/*++

Routine Description:

    Gets the ICounterItem interface for an indexed counter.
    Index is one-based.

Arguments:

    iIndex - Index of counter (0-based)
    ppItem - pointer to returned interface pointer

Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_POINTER;
    CGraphItem *pGItem;
    INT i;

    if ( NULL != ppItem ) {
        *ppItem = NULL;

        // Check for valid index
        if (iIndex < 0 || iIndex >= m_pObj->m_Graph.CounterTree.NumCounters())
            return E_INVALIDARG;

        // Traverse counter linked list to indexed item
        pGItem = m_pObj->m_Graph.CounterTree.FirstCounter();
        i = 0;

        while (i++ < iIndex && pGItem != NULL) {
            pGItem = pGItem->Next();
        }

        if (pGItem == NULL)
            return E_FAIL;


        pGItem->AddRef();
        *ppItem = pGItem;

        hr = NOERROR;
    }
    return hr;
}


STDMETHODIMP
CImpISystemMonitor::AddCounter (
    IN BSTR bstrPath,
    ICounterItem **ppItem
    )

/*++

Routine Description:

    Add counter specified by pathname to the control.
    This method supports wildcard paths.

Arguments:

    bstrPath - Pathname string
    ppItem - pointer to returned interface pointer

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_POINTER;

    USES_CONVERSION

    if ( NULL != ppItem ) {
        // Delegate to control object
        hr = m_pObj->m_pCtrl->AddCounter(W2T(bstrPath), (CGraphItem**)ppItem);
    } 
    return hr;
}


STDMETHODIMP
CImpISystemMonitor::DeleteCounter (
    IN ICounterItem *pItem
    )
/*++

Routine Description:

    Deletes a counter from the control.

Arguments:

    pItem - Pointer to counter's ICounterItem interface

Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_POINTER;

    USES_CONVERSION

    if ( NULL != pItem ) {
        // Delegate to control object
        hr = m_pObj->m_pCtrl->DeleteCounter((PCGraphItem)pItem, TRUE);
    }
    return hr;
}


STDMETHODIMP
CImpISystemMonitor::UpdateGraph (
    VOID
    )

/*++

Routine Description:

    Apply pending visual changes to control. This routine must be called after
    changing a counter's attributes.

Arguments:

    None.

Return Value:

    HRESULT

--*/
{
    // Delegate to control object
    m_pObj->m_pCtrl->UpdateGraph(0);
    return NOERROR;
}


STDMETHODIMP
CImpISystemMonitor::CollectSample(
    VOID
    )
/*++

Routine Description:

    Take a sample of all the counters assigned to the control.

Arguments:

    None.

Return Value:

    HRESULT.

--*/
{
    // Request control to do a manual counter update
    if (m_pObj->m_pCtrl->UpdateCounterValues(TRUE) == 0)
        return NOERROR;
    else
        return E_FAIL;
}

STDMETHODIMP
CImpISystemMonitor::BrowseCounters(
    VOID
    )
/*++

Routine Description:

    Display the browse counter dialog to allow counters
    to be added.

Arguments:

    None.

Return Value:

    HRESULT.

--*/
{
    // Delegate to control
    return m_pObj->m_pCtrl->AddCounters();
}


STDMETHODIMP
CImpISystemMonitor::DisplayProperties(
    VOID
    )
/*++

Routine Description:

    Display the graph control property pages

Arguments:

    None.

Return Value:

    HRESULT.

--*/
{
    // Delegate to control
    return m_pObj->m_pCtrl->DisplayProperties();
}

STDMETHODIMP
CImpISystemMonitor::Paste ()
/*++

Routine Description:

    Pastes a list of counter paths from the clipboard to the control

Arguments:

    NULL

Return Value:

    HRESULT

--*/

{
    // Delegate to control object
    return m_pObj->m_pCtrl->Paste();
}

STDMETHODIMP
CImpISystemMonitor::Copy ()
/*++

Routine Description:

    Copies a list of counter paths from the control to the clipboard

Arguments:

    NULL

Return Value:

    HRESULT

--*/

{
    // Delegate to control object
    return m_pObj->m_pCtrl->Copy();
}

STDMETHODIMP
CImpISystemMonitor::Reset ()
/*++

Routine Description:

    deletes the current set of counters

Arguments:

    NULL

Return Value:

    HRESULT

--*/
{
    // Delegate to control object
    return m_pObj->m_pCtrl->Reset();
}

void
CImpISystemMonitor::SetLogFileRange (
    LONGLONG llBegin,
    LONGLONG llEnd
    )

/*++

Routine Description:

    Set the log file time range. This routine provides the Source
    property page a way to give range to the control, so that the control
    doesn't have to repeat the length PDH call to get it.


Arguments:

    llBegin     Begin time of the log (FILETIME format)
    llEnd       End time of log (FILETIME format)

Return Value:

    HRESULT.

--*/

{
    m_pObj->m_pCtrl->m_DataSourceInfo.llBeginTime = llBegin;
    m_pObj->m_pCtrl->m_DataSourceInfo.llEndTime = llEnd;
}


void
CImpISystemMonitor::GetLogFileRange (
    LONGLONG *pllBegin,
    LONGLONG *pllEnd
    )

/*++

Routine Description:

    Get the log file time range. This routine provides the Source
    property page a way to get the range from the control, so it doesn't
    have to make the length PDH call to get it.


Arguments:

    pllBegin    ptr to returned begin time of the log (FILETIME format)
    pllEnd      ptr to returned end time of log (FILETIME format)

Return Value:

    HRESULT.

--*/

{
    if ( NULL != pllBegin && NULL != pllEnd ) {
        *pllBegin = m_pObj->m_pCtrl->m_DataSourceInfo.llBeginTime;
        *pllEnd = m_pObj->m_pCtrl->m_DataSourceInfo.llEndTime;
    }
}

/*
 *   The following methods, GetVisuals and SetVisuals, provide a means for the
 *  counter property page to save the user's color settings between invocations.
 */

void
CImpISystemMonitor::GetVisuals (
    OUT OLE_COLOR   *pColor,
    OUT INT         *piColorIndex,
    OUT INT         *piWidthIndex,
    OUT INT         *piStyleIndex
    )
{
    if ( NULL != pColor 
        && NULL != piColorIndex
        && NULL != piWidthIndex
        && NULL != piStyleIndex ) {
        *pColor = m_pObj->m_pCtrl->m_clrCounter;
        *piColorIndex = m_pObj->m_pCtrl->m_iColorIndex;
        *piWidthIndex = m_pObj->m_pCtrl->m_iWidthIndex;
        *piStyleIndex = m_pObj->m_pCtrl->m_iStyleIndex;
    }
}

void
CImpISystemMonitor::SetVisuals (
    IN OLE_COLOR    Color,
    IN INT          iColorIndex,
    IN INT          iWidthIndex,
    IN INT          iStyleIndex
    )
{
    OleTranslateColor( Color, NULL, &m_pObj->m_pCtrl->m_clrCounter );
    m_pObj->m_pCtrl->m_iColorIndex = iColorIndex;
    m_pObj->m_pCtrl->m_iWidthIndex = iWidthIndex;
    m_pObj->m_pCtrl->m_iStyleIndex = iStyleIndex;
}

HRESULT
CImpISystemMonitor::SetLogViewTempRange (
  LONGLONG llStart,
  LONGLONG llStop
    )

/*++

Routine Description:

    Set the log view temporary time range. This routine provides the Source
    property page a way to give range to the control, so that the control
    can draw temporary timeline guides on the line graph.


Arguments:

  llStart     Temporary log view start time (FILETIME format)
  llEnd       Temporary log view end time (FILETIME format)

Return Value:

    HRESULT.

--*/

{
    HRESULT hr;

    DATE        dateStart;
    DATE        dateStop;
    
    LONGLONG    llConvertedStart = MIN_TIME_VALUE;
    LONGLONG    llConvertedStop = MAX_TIME_VALUE;
    BOOL        bContinue = TRUE;

    // Convert times to and from Variant date to strip off milliseconds.
    // This will make them match the start and stop times processed by put_LogView*
    // Special case MAX_TIME_VALUE, because that is the signal to not draw the stop 
    // guide line.
    // Convert start time

    if ( LLTimeToVariantDate ( llStart, &dateStart ) ) {
        bContinue = VariantDateToLLTime (dateStart, &llConvertedStart );
    }
        
    // Convert stop time if not MAX_TIME_VALUE
    if ( bContinue ) {    
        if ( MAX_TIME_VALUE != llStop ) {
            if ( LLTimeToVariantDate ( llStop, &dateStop ) ) {
                bContinue = VariantDateToLLTime ( dateStop, &llConvertedStop );
            }
        } else {
            llConvertedStop = MAX_TIME_VALUE;
        }
    }

                    
    if ( bContinue ) {
        m_pObj->m_pCtrl->SetLogViewTempTimeRange ( llConvertedStart, llConvertedStop );
        hr = NOERROR;
    } else {
        hr = E_FAIL;
    }

    return hr;
}

STDMETHODIMP
CImpISystemMonitor::LogFile (
    IN INT iIndex,
    OUT ILogFileItem **ppItem
    )

/*++

Routine Description:

    Gets the ILogFileItem interface for an indexed log file.
    Index is 0-based.

Arguments:

    iIndex - Index of counter (0-based)
    ppItem - pointer to returned interface pointer

Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_POINTER;
    CLogFileItem *pItem;
    INT i;

    if ( NULL != ppItem ) {
        *ppItem = NULL;

        // Check for valid index
        if (iIndex >= 0 && iIndex < m_pObj->m_pCtrl->NumLogFiles()) {

            // Traverse counter linked list to indexed item
            pItem = m_pObj->m_pCtrl->FirstLogFile();
            
            i = 0;

            while (i++ < iIndex && pItem != NULL) {
                pItem = pItem->Next();
            }

            if (pItem != NULL) {
                pItem->AddRef();
                *ppItem = pItem;
                hr = NOERROR;
            } else {
                 hr = E_FAIL;
            }
        } else {
            hr = E_INVALIDARG;
        }
    }
    return hr;
}


STDMETHODIMP
CImpISystemMonitor::AddLogFile (
    IN BSTR bstrPath,
    ILogFileItem **ppItem
    )

/*++

Routine Description:

    Add log file specified by pathname to the control.
    This method does not support wildcard paths.

Arguments:

    bstrPath - Pathname string
    ppItem - pointer to returned interface pointer

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_POINTER;
    USES_CONVERSION

    if ( NULL != ppItem ) {

        // TodoLogFiles: AddSingleLogFile should check for duplicate file names.  
        // If duplicate, return special status, ala AddCounter
        // Delegate to control object
        hr = m_pObj->m_pCtrl->AddSingleLogFile(W2T(bstrPath), (CLogFileItem**)ppItem);
    } 
    return hr;
}


STDMETHODIMP
CImpISystemMonitor::DeleteLogFile (
    IN ILogFileItem *pItem
    )
/*++

Routine Description:

    Deletes a log file from the control.

Arguments:

    pItem - Pointer to log file's ILogFileItem interface

Return Value:

    HRESULT

--*/

{
    HRESULT hr = E_POINTER;
    USES_CONVERSION

    if ( NULL != pItem ) {
        // Delegate to control object
        hr = m_pObj->m_pCtrl->RemoveSingleLogFile( (PCLogFileItem)pItem );
    }
    return hr;
}

//IOleControl interface implementation

/*
 * CImpIOleControl::CImpIOleControl
 * CImpIOleControl::~CImpIOleControl
 *
 * Parameters (Constructor):
 *  pObj            PCPolyline of the object we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */

CImpIOleControl::CImpIOleControl (
    IN PCPolyline pObj,
    IN LPUNKNOWN pUnkOuter
    )
{
    m_cRef = 0;
    m_pObj = pObj;
    m_pUnkOuter = pUnkOuter;

}

CImpIOleControl::~CImpIOleControl (
    VOID
    )
{
    return;
}


/*
 * CImpIOleControl::QueryInterface
 * CImpIOleControl::AddRef
 * CImpIOleControl::Release
 */

STDMETHODIMP
CImpIOleControl::QueryInterface(
    IN  REFIID riid,
    OUT LPVOID *ppv
    )
{
    return m_pUnkOuter->QueryInterface(riid, ppv);
}

STDMETHODIMP_( ULONG )
CImpIOleControl::AddRef(
    VOID
    )
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImpIOleControl::Release(void)
    {
    --m_cRef;
    return m_pUnkOuter->Release();
    }



/*
 * CImpIOleControl::GetControlInfo
 *
 * Purpose:
 *  Fills a CONTROLINFO structure containing information about
 *  the controls mnemonics and other behavioral aspects.
 *
 * Parameters:
 *  pCI             LPCONTROLINFO to the structure to fill
 */

STDMETHODIMP 
CImpIOleControl::GetControlInfo ( LPCONTROLINFO pCI )
{
    if (NULL==pCI)
        return E_POINTER;

    *pCI=m_pObj->m_ctrlInfo;
    return E_NOTIMPL;
}




/*
 * CImpIOleControl::OnMnemonic
 *
 * Purpose:
 *  Notifies the control that a mnemonic was activated.
 *
 * Parameters:
 *  pMsg            LPMSG containing the message that matches one of
 *                  the control's mnemonics.  The control uses this
 *                  to distinguish which mnemonic was pressed.
 */

STDMETHODIMP CImpIOleControl::OnMnemonic ( LPMSG /* pMsg */ )
{
    //No mnemonics
    return NOERROR;
}





/*
 * CImpIOleControl::OnAmbientPropertyChange
 *
 * Purpose:
 *  Notifies the control that one or more of the container's ambient
 *  properties changed.
 *
 * Parameters:
 *  dispID          DISPID identifying the property, which can
 *                  be DISPID_UNKNOWN indicating that more than
 *                  one changed.
 */

STDMETHODIMP 
CImpIOleControl::OnAmbientPropertyChange(DISPID dispID)
{
    /*
     */
    DWORD dwInitWhich;

    switch (dispID) {

        case DISPID_UNKNOWN:
        {
            dwInitWhich = INITAMBIENT_SHOWHATCHING | INITAMBIENT_UIDEAD
                        | INITAMBIENT_BACKCOLOR | INITAMBIENT_FORECOLOR
                        | INITAMBIENT_APPEARANCE | INITAMBIENT_USERMODE
                        | INITAMBIENT_FONT;

            // Update system colors here until MMC passes on WM_SYSCOLORCHANGE
            m_pObj->m_pCtrl->UpdateNonAmbientSysColors();

            break;
        }

        case DISPID_AMBIENT_SHOWHATCHING:
            dwInitWhich = INITAMBIENT_SHOWHATCHING;
            break;

        case DISPID_AMBIENT_UIDEAD:
            dwInitWhich = INITAMBIENT_UIDEAD;
            break;

        case DISPID_AMBIENT_APPEARANCE:
            dwInitWhich = INITAMBIENT_APPEARANCE;
            break;

        case DISPID_AMBIENT_BACKCOLOR:
            dwInitWhich = INITAMBIENT_BACKCOLOR;
            break;

        case DISPID_AMBIENT_FORECOLOR:
            dwInitWhich = INITAMBIENT_FORECOLOR;
            break;

        case DISPID_AMBIENT_FONT:
            dwInitWhich = INITAMBIENT_FONT;
            break;

        case DISPID_AMBIENT_USERMODE:
            dwInitWhich = INITAMBIENT_USERMODE;
            break;

        default:
            return NOERROR;
    }

    m_pObj->AmbientsInitialize(dwInitWhich);

    return NOERROR;
}




/*
 * CImpIOleControl::FreezeEvents
 *
 * Purpose:
 *  Instructs the control to stop firing events or to continue
 *  firing them.
 *
 * Parameters:
 *  fFreeze         BOOL indicating to freeze (TRUE) or thaw (FALSE)
 *                  events from this control.
 */

STDMETHODIMP 
CImpIOleControl::FreezeEvents(BOOL fFreeze)
{
    m_pObj->m_fFreezeEvents = fFreeze;
    return NOERROR;
}

// Private methods

STDMETHODIMP
CImpISystemMonitor::GetSelectedCounter (
    ICounterItem** ppItem
    )

/*++

Routine Description:

    Gets the ICounterItem interface for the selected counter.

Arguments:

    ppItem - pointer to returned interface pointer

Return Value:

    HResult

--*/

{
    HRESULT hr = E_POINTER;

    if ( NULL != ppItem ) {
        *ppItem = (m_pObj->m_pCtrl->m_pSelectedItem);
        if ( NULL != *ppItem ) {
            m_pObj->m_pCtrl->m_pSelectedItem->AddRef();
        }
        hr = NOERROR;
    }
    return hr;
}

HLOG
CImpISystemMonitor::GetDataSourceHandle ( void )
{
    return m_pObj->m_pCtrl->GetDataSourceHandle(  );
}

// *** TodoMultiLogHandle:  Temporary method.  Remove when trace file post-processing supports multiple
// open files.
HQUERY
CImpISystemMonitor::GetQueryHandle ( void )
{
    return m_pObj->m_pCtrl->TempGetQueryHandle(  );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\ctrprop.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ctrprop.cpp

Abstract:

    This file contains the CCounterPropPage class and other routines
    to implement the counter property page.

--*/

#include <assert.h>
#include <stdio.h>
#include <math.h>
#include <limits.h>
#include "polyline.h"
#include "ctrprop.h"
#include "utils.h"
#include "unihelpr.h"
#include "winhelpr.h"
#include "visuals.h"
#include "strids.h"
#include "winperf.h"
#include "pdhmsg.h"
#include "globals.h"
#include "browser.h"
#include "smonmsg.h"

#define OWNER_DRAWN_ITEM      2
#define OWNER_DRAW_FOCUS      1


VOID static
HandleSelectionState (
    IN LPDRAWITEMSTRUCT lpdis
    )
/*++

Routine Description:

    HandleSelectionState draws or erases a selection rectangle around an item
    in a combo box list.
    
Arguments:

    lpdis - Pointer to DRAWITEMSTRUCT

Return Value:

    None.

--*/
{
    HBRUSH  hbr ;

    if ( NULL != lpdis ) {

        if (lpdis->itemState & ODS_SELECTED)
            hbr = (HBRUSH)GetStockObject(BLACK_BRUSH) ;
        else
            hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW)) ;

        if ( NULL != hbr ) {
            FrameRect(lpdis->hDC, (LPRECT)&lpdis->rcItem, hbr) ;
            DeleteObject (hbr) ;
        }
    }
}


//***************************************************************************
//                                                                          *
//  FUNCTION   : HandleFocusState(LPDRAWITEMSTRUCT)                         *
//                                                                          *
//  PURPOSE    : Handle a change in item focus state. If an item gains the  *
//               input focus, a gray rectangular frame is drawn around that *
//               item; if an item loses the input focus, the gray frame is  *
//               removed.                                                   *
//                                                                          *
//  COMMENT    : The gray focus frame is slightly smaller than the black    *
//               selection frame so they won't paint over each other.       *
//                                                                          *
//***************************************************************************
VOID static
HandleFocusState (
    IN LPDRAWITEMSTRUCT lpdis
    )
/*++

Routine Description:

    HandleFocusState draws or erases a focus rectangle around an item in
    the pulldown list of a combo box. The reactngle is indented to not
    interfere with the selection rectangle.

Arguments:

    lpdis - Pointer to DRAWITEMSTRUCT

Return Value:

    None.

--*/
{
    RECT    rc ;
    HBRUSH  hbr ;

    if ( NULL != lpdis ) {

        // Resize rectangle to place focus frame between the selection
        // frame and the item.
        CopyRect ((LPRECT)&rc, (LPRECT)&lpdis->rcItem) ;
        InflateRect ((LPRECT)&rc, -OWNER_DRAW_FOCUS, -OWNER_DRAW_FOCUS) ;

        // Gray if has focus, background color if not
        if (lpdis->itemState & ODS_FOCUS)
            hbr = (HBRUSH)GetStockObject(GRAY_BRUSH) ;
        else
            hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW)) ;

        if ( NULL != hbr ) {
            FrameRect(lpdis->hDC, (LPRECT)&rc, hbr) ;
            DeleteObject (hbr) ;
        }
    }
}


CCounterPropPage::CCounterPropPage ( void )
:   m_pInfoSel ( NULL ),
    m_pInfoDeleted ( NULL ),
    m_dwMaxHorizListExtent ( 0 ),
    m_bAreModSelectedVisuals ( FALSE ),
    m_fHashTableSetup ( FALSE )
/*++

Routine Description:

    Creation routine for counter property page. Initializes the instance
    variables.

Arguments:

    None.

Return Value:

    None.

--*/
{
    m_uIDDialog = IDD_CTR_PROPP_DLG;
    m_uIDTitle = IDS_CTR_PROPP_TITLE;
    return;
}

CCounterPropPage::~CCounterPropPage (
    VOID
    )
/*++

Routine Description:

    Destructor for counter property page.
Arguments:

    None.

Return Value:

    None.

--*/
{
    ClearCountersHashTable();
    return;
}

void
CCounterPropPage::DeinitControls ( void )
{
    ISystemMonitor  *pObj = NULL;
    CImpISystemMonitor *pPrivObj = NULL;
    HWND    hwndList = NULL;
    INT     iIndex = 0;
    INT     iItemCnt = 0;
    PItemInfo pInfo = NULL;

    // Write the current visuals back to the control
    // Must be at least one control object and only the first is used
    if (m_cObjects != 0) {
        pObj = m_ppISysmon[0];
        if ( NULL != pObj ) {
            pPrivObj = (CImpISystemMonitor*)pObj;
        }
    }

    if ( NULL != pPrivObj ) {
        if ( AreModifiedSelectedVisuals() ) {
            IncrementLocalVisuals();
        }
        pPrivObj->SetVisuals(m_props.rgbColor, m_props.iColorIndex, m_props.iWidthIndex, m_props.iStyleIndex);
    } 

    hwndList = DialogControl(m_hDlg, IDC_CTRLIST);
    if ( NULL != hwndList ) {
        iItemCnt = LBNumItems(hwndList);
        for (iIndex = 0; iIndex < iItemCnt; iIndex++ ) {
            pInfo = (PItemInfo)LBData(hwndList,iIndex);
            if ( NULL != pInfo ) {
                DeleteInfo(pInfo);
            }
        }
    }
    return;
}


INT
CCounterPropPage::SelectMatchingItem (
    INT iColorIndex,
    COLORREF rgbCustomColor,
    INT iWidthIndex,
    INT iStyleIndex)
/*++

Routine Description:

    GetMatchingIndex selects the first counter item that matches the
    specified visual characteristics.

Arguments:

    None.

Return Value:

    Returns the index of the selected item on match.  If none match, then
    returns -1.

--*/
{
    INT iReturn = -1;

    // Get number of items in list box
    HWND hwndList = DialogControl(m_hDlg, IDC_CTRLIST);
    INT iItemCnt = LBNumItems(hwndList);
    INT i;
    bool bMatch = false;

    // For each item
    for (i=0; !bMatch && i<iItemCnt; i++){

        PItemInfo pInfo = (PItemInfo)LBData(hwndList,i);

        LoadItemProps ( pInfo );

        if ( pInfo->Props.iColorIndex == iColorIndex ) {
            if ( NumStandardColorIndices() > iColorIndex ) {
                bMatch = true;
            } else {
                if ( pInfo->Props.rgbColor == rgbCustomColor )
                    bMatch = true;
            }

            if ( bMatch ) {
                if ( ( iWidthIndex != pInfo->Props.iWidthIndex )
                    || ( iStyleIndex != pInfo->Props.iStyleIndex ) ){
                    bMatch = false;
                }
            }
        }
    }

    if ( bMatch ) {
        iReturn = i - 1;

        SelectItem ( iReturn );
    }

    return iReturn;
}


BOOL
CCounterPropPage::GetProperties (
    VOID
    )
/*++

Routine Description:

    GetProperties initializes the dialog box for the property page. It then
    fetches an ICounterItem interface for each counter of the control being
    edited. Each interface pointer is placed in an ItemInfo structure which is
    then added to the dialog list box.
    
    The counter properties are not fetched until they are needed for display.
    The first counter fetched is selected to display its properties in the
    dialog box.

Arguments:

    None.

Return Value:

    Boolean status - TRUE = success

--*/
{
    ISystemMonitor  *pObj = NULL;
    CImpISystemMonitor *pPrivObj = NULL;
    ICounterItem    *pItem;
    ICounterItem    *pSelectedItem = NULL;
    PItemInfo       pInfo;
    INT             nCtr;
    INT             nSelCtr = LB_ERR;
    INT             iIndex;
    INT             nChar;
    BOOL            bStat = TRUE;
    BSTR            bstrPath;
    HRESULT         dwResult;
    PPDH_COUNTER_PATH_ELEMENTS pCounter;

    InitDialog();

    // Must be at least one control object and only the first is used
    if (m_cObjects == 0) {
        bStat = FALSE;
    } else {
        pObj = m_ppISysmon[0];
        if ( NULL != pObj ) {
            pPrivObj = (CImpISystemMonitor*)pObj;
        }
    }

    if ( bStat && NULL != pObj && NULL != pPrivObj ) {

        // Request each counter from the control, stopping on failure
        nCtr = 0;

        pPrivObj->GetSelectedCounter( &pSelectedItem );

        while (SUCCEEDED(pObj->Counter(nCtr, &pItem))) {
            // Create ItemInfo to hold the counter
            pInfo = new ItemInfo;

            if (pInfo == NULL) {
                bStat = FALSE;
                break;
            }
            
            ZeroMemory(pInfo, sizeof(ItemInfo));

            pInfo->pItem = pItem;
            pItem->get_Path( &bstrPath );
        
            if (bstrPath != NULL) {
#if UNICODE
                nChar = lstrlen(bstrPath) + 1;
#else
                nChar = (wcslen(bstrPath) + 1) * 2;
#endif
                pInfo->pszPath = new TCHAR [nChar];

                if (pInfo->pszPath == NULL) {
                    delete pInfo;
                    pInfo = NULL;
                    SysFreeString(bstrPath);
                    bStat = FALSE;
                    break;
                }

#if UNICODE
                lstrcpy(pInfo->pszPath, bstrPath);
#else
                WideCharToMultiByte(CP_ACP, 0, bstrPath, nChar,
                                    pInfo->pszPath, nChar, NULL, NULL);
#endif
                SysFreeString(bstrPath);
            }

            dwResult = InsertCounterToHashTable(pInfo->pszPath, &pCounter); 

            if (dwResult == ERROR_SUCCESS) {
                //
                // Add the counter to the list box
                //
                iIndex = AddItemToList(pInfo);

                if ( LB_ERR == iIndex ) {
                    RemoveCounterFromHashTable(pInfo->pszPath, pCounter);
                    bStat = FALSE;
                    DeleteInfo(pInfo);
                    pInfo = NULL;
                    break;
                } else {
                    pInfo->pCounter = pCounter;
                    if ( pSelectedItem == pItem ) {
                        nSelCtr = iIndex;
                    }
                }   
            }
            else {
                bStat = FALSE;
                DeleteInfo(pInfo);
                pInfo = NULL;
                break;
            }

            nCtr++;
        }

        if ( NULL != pSelectedItem ) {
            pSelectedItem->Release();
        }

        // Get the current visuals fron the control
        // and initialize the property dialog
        pPrivObj->GetVisuals(&m_props.rgbColor, &m_props.iColorIndex, &m_props.iWidthIndex, &m_props.iStyleIndex);

        // If a counter matches the selected counter, select that item.
        // Else if the visuals match an existing item, select that item.
        // Else if there is at least one counter in the control, select the first counter.
        // Otherwise, set the display properties to the first counter to be added.

        if ( LB_ERR != nSelCtr ) {
            SelectItem ( nSelCtr ); 
        } else {
            if ( LB_ERR == SelectMatchingItem (
                            m_props.iColorIndex,
                            m_props.rgbColor,
                            m_props.iWidthIndex,
                            m_props.iStyleIndex ) ) 
            {
                if ( 0 < nCtr ) {
                    SelectItem ( 0 );
                } else {
                    // Init the scale factor to the default
                    m_props.iScaleIndex = 0;

                    // If nothing selected, ensure that the color index is set to
                    // a standard color.
                    if ( m_props.iColorIndex == NumStandardColorIndices() ) {
                        m_props.iColorIndex -= 1;
                    }

                    CBSetSelection(DialogControl(m_hDlg, IDC_LINECOLOR), m_props.iColorIndex);
                    CBSetSelection(DialogControl(m_hDlg, IDC_LINEWIDTH), m_props.iWidthIndex);
                    CBSetSelection(DialogControl(m_hDlg, IDC_LINESTYLE), m_props.iStyleIndex);
                    CBSetSelection(DialogControl(m_hDlg, IDC_LINESCALE), m_props.iScaleIndex);
                    SetStyleComboEnable();
                }
            }
        }
    }
    return bStat;   
}

INT
CCounterPropPage::AddItemToList (
    IN PItemInfo pInfo
    )
/*++

Routine Description:

    AddItemToList adds a counter's path name to the dialog list box and
    attaches a pointer to the counter's ItemInfo structure as item data.
    It also adjusts the horizontal scroll of the list box.

Arguments:

    pInfo - Pointer to counter's ItemInfo structure

Return Value:

    List box index of added counter (LB_ERR on failure)

--*/
{
    INT     iIndex;
    HWND    hwndList = DialogControl(m_hDlg, IDC_CTRLIST);
    DWORD   dwItemExtent = 0;
    HDC     hDC = NULL;

    iIndex = (INT)LBAdd(hwndList, pInfo->pszPath);

    if ( LB_ERR != iIndex && LB_ERRSPACE != iIndex ) {    
        LBSetData(hwndList, iIndex, pInfo);
    
        hDC = GetDC ( hwndList );
        if ( NULL != hDC ) {
            dwItemExtent = (DWORD)TextWidth ( hDC, pInfo->pszPath );
 
            if (dwItemExtent > m_dwMaxHorizListExtent) {
                m_dwMaxHorizListExtent = dwItemExtent;
                LBSetHorzExtent ( hwndList, dwItemExtent ); 
            }
            ReleaseDC (hwndList, hDC) ;
        }
    } else {
        iIndex = LB_ERR ; 
    }
    return iIndex;
}

VOID
CCounterPropPage::LoadItemProps (
    IN PItemInfo pInfo
    )
/*++

Routine Description:

    LoadItemProps loads the properties of the selected counter through the
    counter's interface into the ItemInfo structure, if not already loaded.

Arguments:

    pInfo - pointer to item info

Return Value:

    None.

--*/
{
    // If properties not loaded for this item, get them now
    if (pInfo->pItem && !pInfo->fLoaded) {
        INT iScaleFactor;
        INT iStyle;
        INT iWidth;
        pInfo->pItem->get_Color ( &pInfo->Props.rgbColor );
        pInfo->pItem->get_ScaleFactor ( &iScaleFactor );
        pInfo->pItem->get_Width ( &iWidth );
        pInfo->pItem->get_LineStyle ( &iStyle );
        // Translate to combo box indices
        pInfo->Props.iColorIndex = ColorToIndex ( pInfo->Props.rgbColor );
        pInfo->Props.iStyleIndex = StyleToIndex ( iStyle );
        pInfo->Props.iWidthIndex = WidthToIndex ( iWidth );
        pInfo->Props.iScaleIndex = ScaleFactorToIndex ( iScaleFactor );

        pInfo->fLoaded = TRUE;
    }
    return;
}

VOID
CCounterPropPage::DisplayItemProps (
    IN PItemInfo pInfo
    )
/*++

Routine Description:

    DisplayItemProps displays the properties of the selected counter on the
    property page dialog. If the counter is being displayed for the first time
    the properties are obtained through the counter's interface and are loaded
    into the ItemInfo structure.

Arguments:

    pInfo - pointer to item info

Return Value:

    None.

--*/
{
    // Get number of items in color combo box
    HWND hWndColor = DialogControl(m_hDlg, IDC_LINECOLOR);
    INT iCurrentColorCnt = CBNumItems(hWndColor);

    // If properties not loaded for this item, get them now
    LoadItemProps ( pInfo );

    // Display the properties
    m_props = pInfo->Props;

    // Handle custom color
    if ( iCurrentColorCnt > NumStandardColorIndices() ) {
        // Delete the custom color item.  It is stored at
        // the end of the list.
        CBDelete(hWndColor, iCurrentColorCnt - 1);
    }

    // If new custom color, add it at the end of the list.
    if ( NumStandardColorIndices() == m_props.iColorIndex )
        CBAdd( hWndColor, (INT_PTR)m_props.iColorIndex );

    CBSetSelection(hWndColor, m_props.iColorIndex);
    CBSetSelection(DialogControl(m_hDlg, IDC_LINEWIDTH), m_props.iWidthIndex);
    CBSetSelection(DialogControl(m_hDlg, IDC_LINESTYLE), m_props.iStyleIndex);
    CBSetSelection(DialogControl(m_hDlg, IDC_LINESCALE), m_props.iScaleIndex);

    SetStyleComboEnable();
}

    
BOOL
CCounterPropPage::SetProperties (
    VOID
    )
/*++

Routine Description:

    SetProperties applies the counter changes the user has made. It calls the
    control's AddCounter and DeleteCounter to adjust the counter set. It calls
    the counter's property functions for all new and changed counters.

    The counters to be deleted are in the pInfoDeleted linked list. The other
    counters are obtained from the dialog list box.
    
Arguments:

    None.

Return Value:

    Boolean status - TRUE = success

--*/
{
    HWND    hwndList;
    INT     iItemCnt;
    INT     i;
    PItemInfo pInfo, pInfoNext;
    ISystemMonitor  *pObj;
    CImpISystemMonitor *pPrivObj;

    // Apply changes to first control
    pObj = m_ppISysmon[0];

    if ( NULL != pObj ) {

        // For all items in the delete list
        pInfo = m_pInfoDeleted;
        while (pInfo) {

            // If this counter exists in the control
            if (pInfo->pItem != NULL) {

                // Tell control to remove it
                pObj->DeleteCounter(pInfo->pItem);
            }

            // Delete the Info structure and point to the next one
            pInfoNext = pInfo->pNextInfo;

            DeleteInfo(pInfo);

            pInfo = pInfoNext;
        }

        m_pInfoDeleted = NULL;

        // Get number of items in list box
        hwndList = DialogControl(m_hDlg, IDC_CTRLIST);
        iItemCnt = LBNumItems(hwndList);

        //assert( IsWindowUnicode(hwndList) );

        // For each item
        for (i=0; i<iItemCnt; i++) {
            pInfo = (PItemInfo)LBData(hwndList,i);

            // If new item, create it now
            if (pInfo->pItem == NULL) {
#if UNICODE
                pObj->AddCounter(pInfo->pszPath, &pInfo->pItem);
#else
                INT nChar = lstrlen(pInfo->pszPath);
                LPWSTR pszPathW = new WCHAR [nChar + 1];
                if (pszPathW) {
                    MultiByteToWideChar(CP_ACP, 0, pInfo->pszPath, nChar+1, pszPathW, nChar+1);
                    pObj->AddCounter(pszPathW, &pInfo->pItem);
                    delete pszPathW;
                }
#endif
            }

            // If item has changed, put the new properties
            if (pInfo->pItem != NULL && pInfo->fChanged) {
                // iColorIndex is used to determine standard colors.
                if ( pInfo->Props.iColorIndex < NumStandardColorIndices() ) {
                    pInfo->pItem->put_Color(IndexToStandardColor( pInfo->Props.iColorIndex) );
                } else {
                    pInfo->pItem->put_Color(pInfo->Props.rgbColor);
                }

                pInfo->pItem->put_Width(IndexToWidth(pInfo->Props.iWidthIndex));
                pInfo->pItem->put_LineStyle(IndexToStyle(pInfo->Props.iStyleIndex));
                pInfo->pItem->put_ScaleFactor(IndexToScaleFactor( pInfo->Props.iScaleIndex ) );

                pInfo->fChanged = FALSE;
             }
        }

        // Tell graph to redraw itself
        pObj->UpdateGraph();
    } // else report internal error
    return TRUE;    
}


VOID
CCounterPropPage::InitDialog (
    VOID
    )
/*++

Routine Description:

    InitDialog loads each attribute combo box with its list of choices and
    selects the default choice. The graphical attributes are owner drawn, so
    their list items are just set to numerical indices. The scale attribute
    list is filled with numeric strings representing scale factors plus a
    default selection.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HWND    hWndColors;
    HWND    hWndWidths;
    HWND    hWndStyles;
    HWND    hWndScales;
    INT     i ;
    double  ScaleFactor ;
    TCHAR   tempBuff[30] ;


    if (m_hDlg == NULL)
        return;
    //assert( IsWindowUnicode( m_hDlg ) );

    // Load the colors combobox, select the default color.
    hWndColors = DialogControl (m_hDlg, IDC_LINECOLOR) ;
    for (i = 0 ; i < NumStandardColorIndices () ; i++)
        CBAdd (hWndColors, (INT_PTR)1);      // string pointer is unused.  Fill with
                                        // arbitrary value.

    CBSetSelection (hWndColors, 0) ;

    // Load the widths combo box, select the default width.
    hWndWidths = DialogControl (m_hDlg, IDC_LINEWIDTH) ;
    for (i = 0 ; i < NumWidthIndices () ; i++)
       CBAdd (hWndWidths, (INT_PTR)1) ;

    CBSetSelection (hWndWidths, 0) ;

    // Load the styles combo box, select the default style.
    hWndStyles = DialogControl (m_hDlg, IDC_LINESTYLE) ;
    for (i = 0 ; i < NumStyleIndices () ; i++)
       CBAdd (hWndStyles, (INT_PTR)1) ;

    CBSetSelection (hWndStyles, 0) ;

    // Init the scale combo box.
    hWndScales = DialogControl (m_hDlg, IDC_LINESCALE) ;

    CBAdd (hWndScales, ResourceString(IDS_DEFAULT)) ;

    // Generate power of 10 scale factors
    ScaleFactor = pow (10.0f, (double)PDH_MIN_SCALE);
    for (i = PDH_MIN_SCALE ; i <= PDH_MAX_SCALE ; i++)   {

        FormatNumber (
             ScaleFactor,
             tempBuff,
             30,
             (i <= 0 ? (-1 * i) + 1 : i + 1),
             (i < 0 ? (-1 * i) : 1) );

       CBAdd (hWndScales, tempBuff) ;

       ScaleFactor *= (double) 10.0f ;
    }

    CBSetSelection (hWndScales, 0) ;
    ClearCountersHashTable();
}


void 
CCounterPropPage::IncrementLocalVisuals (
    void
    )
{
    // Increment the visual indices in color, width, style order
    if (++m_props.iColorIndex >= NumStandardColorIndices()) {
        m_props.iColorIndex = 0;

        if (++m_props.iWidthIndex >= NumWidthIndices()) {
            m_props.iWidthIndex = 0;

            if (++m_props.iStyleIndex < NumStyleIndices()) {
                m_props.iStyleIndex = 0;
            }
        }
    }
    SetModifiedSelectedVisuals ( FALSE );
    return;
}

HRESULT
CCounterPropPage::NewItem (
    IN LPTSTR pszPath,
    IN DWORD /* dwFlags */
    )
/*++

Routine Description:

    NewItem adds a new counter to the dialog's counter list box. It first
    creates a new ItemInfo structure and loads it with the counter pathname
    string. Then the ItemInfo is added to the dialog list box.

Arguments:
    
    pszPath - Pointer to counter pathname string
    fGenerated - TRUE if path was generated from a wildcard path

Return Value:

    Index of new item in counter list (-1 if failed to add)

--*/
{
    PItemInfo pInfo;
    INT       i;
    HWND      hwndList = DialogControl(m_hDlg, IDC_CTRLIST);
    HRESULT   dwResult;
    BOOL      bRet;
    PPDH_COUNTER_PATH_ELEMENTS pCounter;

    dwResult = InsertCounterToHashTable(pszPath, &pCounter);
    
    if (dwResult != ERROR_SUCCESS) {
        return dwResult;
    }

    // Allocate ItemInfo structure
    pInfo = NULL;
    pInfo = new ItemInfo;
    if (pInfo == NULL) {
        bRet = RemoveCounterFromHashTable(pszPath, pCounter);

        assert(bRet);
        return E_OUTOFMEMORY;
    }

    // Mark as loaded to prevent requesting attributes from control
    // Mark as changed so sttribute will be written
    pInfo->fLoaded = TRUE;
    pInfo->fChanged = TRUE;

    // Actual counter doesn't exist yet
    pInfo->pItem = NULL;

    // If a counter is selected, we're showing its visuals
    // so increment them for the new counter
    if (m_pInfoSel != NULL) {
        IncrementLocalVisuals();
    }
    else {
        // Point to the new item so the visuals are incremented
        // for the next one
        m_pInfoSel = pInfo;
    }

    // Set default scaling
    m_props.iScaleIndex = 0;

    // Color is non-standard only if user is able to build a color.
    if( m_props.iColorIndex < NumStandardColorIndices() )
        m_props.rgbColor = IndexToStandardColor( m_props.iColorIndex );
    else
        m_props.rgbColor = pInfo->Props.rgbColor;

    // Copy properties to new counter
    pInfo->Props = m_props;

    // Make own copy of path name string
    pInfo->pszPath = new TCHAR [lstrlen(pszPath) + 1];

    if (pInfo->pszPath == NULL)
    {
        bRet = RemoveCounterFromHashTable(pszPath, pCounter);

        assert(bRet);

        delete pInfo;
        return E_OUTOFMEMORY;
    }
    
    lstrcpy(pInfo->pszPath, pszPath);

    // Add to dialog's counter list
    pInfo->pCounter = pCounter;
    m_iAddIndex = AddItemToList(pInfo);

    return S_OK;
}


VOID
CCounterPropPage::SelectItem (
    IN INT iItem
    )
/*++

Routine Description:

    SelectItem selects a specified counter item in the dialog counter list.
    It then displays the selected counter's properties and enables the
    "Delete Counter" button.

    SelectItem can be called with a -1 to deselect all counters and disable
    the delete button.

    The member variable, m_pInfoSel, is updated to point to the selected
    counter info.

Arguments:

    iItem - List index of counter item to select, or -1 to deselect all

Return Value:

    None.

--*/
{
    HWND    hWnd;

    hWnd = DialogControl(m_hDlg, IDC_CTRLIST);

    // Translate index into item pointer
    if (iItem == -1) {
        m_pInfoSel = NULL;
    }
    else {
        m_pInfoSel = (PItemInfo)LBData(hWnd, iItem);

         if ((INT_PTR)m_pInfoSel == LB_ERR)
            m_pInfoSel = NULL;
    }

    // Select the item, display properties, and enable delete button
    if (m_pInfoSel != NULL) {
        LBSetSelection(hWnd, iItem);
        DisplayItemProps(m_pInfoSel);
        DialogEnable(m_hDlg,IDC_DELCTR,1);
    }
    else {
        LBSetSelection(hWnd, (WPARAM)-1);
        DialogEnable(m_hDlg,IDC_DELCTR,0);
    }
}
            

VOID
CCounterPropPage::DeleteItem (
    VOID
    )
/*++

Routine Description:

    DeleteItem removes the currently selected counter from the dialog's counter
    listbox. It adds the item to the deletion list, so the actual counter can
    be deleted from the control when (and if) the changes are applied.

    The routine selects selects the next counter in the listbox if there is one.

Arguments:
    
    None.

Return Value:

    None.

--*/
{
    HWND    hWnd;
    INT     iIndex;
    PItemInfo   pInfo;
    DWORD   dwItemExtent = 0;
    HDC     hDC = NULL;

    // Get selected index
    hWnd = DialogControl(m_hDlg, IDC_CTRLIST);
    iIndex = LBSelection(hWnd);

    if (iIndex == LB_ERR)
        return;

    // Get selected item info
    pInfo = (PItemInfo)LBData(hWnd, iIndex);

    // Move it to the "Deleted" list.
    pInfo->pNextInfo = m_pInfoDeleted;
    m_pInfoDeleted = pInfo;

    // Remove the string from the list box.
    LBDelete(hWnd, iIndex);

    // Remove the counter from hash table
    RemoveCounterFromHashTable(pInfo->pszPath, pInfo->pCounter);


    // Select next item if possible, else the previous
    if (iIndex == LBNumItems(hWnd))
        iIndex--;
    SelectItem(iIndex);

    // Clear the max horizontal extent and recalculate
    m_dwMaxHorizListExtent = 0;
                        
    hDC = GetDC ( hWnd );
    if ( NULL != hDC ) {
        for ( iIndex = 0; iIndex < (INT)LBNumItems ( hWnd ); iIndex++ ) {
            pInfo = (PItemInfo)LBData(hWnd, iIndex);
            dwItemExtent = (DWORD)TextWidth ( hDC, pInfo->pszPath );
            if (dwItemExtent > m_dwMaxHorizListExtent) {
                m_dwMaxHorizListExtent = dwItemExtent;
            }
        }
        ReleaseDC (hWnd, hDC) ;
    }
        
    LBSetHorzExtent ( hWnd, m_dwMaxHorizListExtent ); 

    // Set change flag to enable "Apply" button
    SetChange();
}


static HRESULT
AddCallback (
    LPTSTR  pszPathName,
    DWORD_PTR lpUserData,
    DWORD   dwFlags
    )
{
    CCounterPropPage* pObj = (CCounterPropPage*)lpUserData;

    return pObj->NewItem(pszPathName, dwFlags);
}
    

VOID
CCounterPropPage::AddCounters (
    VOID
    )
/*++

Routine Description:

    AddCounters invokes the counter browser to select new counters.
    The browser calls the AddCallback function for each new counter.
    AddCallback passes the counter path on to the NewItem method.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HRESULT         hr = NOERROR;
    HLOG            hDataSource;
    VARIANT_BOOL    bMonitorDuplicateInstances = FALSE;
    ISystemMonitor  *pObj = m_ppISysmon[0];
    CImpISystemMonitor *pPrivObj;
    eDataSourceTypeConstant eDataSource = sysmonNullDataSource;
    
    USES_CONVERSION

    pPrivObj = (CImpISystemMonitor*)pObj;

    m_iAddIndex = -1;

    // Browse counters (calling AddCallack for each selected counter)
    hr = pObj->get_MonitorDuplicateInstances(&bMonitorDuplicateInstances);

    if (SUCCEEDED(hr)) {
        hr = pObj->get_DataSourceType(& eDataSource);
    }

    if (SUCCEEDED(hr)) {
        // Cannot call pObj->BrowseCounter() because using callback method
        // private to this file.

        if ( sysmonLogFiles == eDataSource 
                || sysmonSqlLog == eDataSource ) {

            hDataSource = pPrivObj->GetDataSourceHandle();
            assert ( NULL != hDataSource );
        } else {
            hDataSource = H_REALTIME_DATASOURCE;
        }

        if (SUCCEEDED(hr)) {
            BrowseCounters(
                    hDataSource,
                    PERF_DETAIL_WIZARD, 
                    m_hDlg, 
                    AddCallback, 
                    (LPVOID) this, 
                    (BOOL) bMonitorDuplicateInstances);
        }
    } else {
        // Todo: Error message 
    }

    // if any items added, select the last one
    if (m_iAddIndex != -1) {

        SelectItem(m_iAddIndex);
        m_iAddIndex = -1;

        // Set change to enable "Apply" button
        SetChange();
    }

    return;
}


VOID
CCounterPropPage::DialogItemChange (
    IN WORD wId,
    IN  WORD wMsg
    )
/*++

Routine Description:

    DialogItemChange processes window messages sent to any of the property
    page dialog controls. When the counter listbox selection changes, it
    selects the new counter item and displays its properties. When a change is
    made to a property combo box, it updates the property for the currently
    selected counter item. When the add or delete counter button is pressed,
    it calls the appropriate property page functions.

Arguments:

    wID - Dialog control ID
    wMsg - Notification code

Return Value:

    None.

--*/

{
    INT     iIndex;
    INT     iNewProp;
    HWND    hWnd;

    // Case on control ID
    switch (wId) {

        case IDC_CTRLIST:

            // If selection changed
            if (wMsg == LBN_SELCHANGE) {
                
                // Get selected index   
                hWnd = DialogControl(m_hDlg, IDC_CTRLIST);
                iIndex = LBSelection(hWnd);

                // Select the counter item
                if (iIndex != LB_ERR) {
                    m_pInfoSel = (PItemInfo)LBData(hWnd, iIndex);
                    DisplayItemProps(m_pInfoSel);
                    DialogEnable(m_hDlg, IDC_DELCTR, 1);
                }
            }
            break;
        
        case IDC_LINECOLOR:
        case IDC_LINEWIDTH:
        case IDC_LINESTYLE:
        case IDC_LINESCALE:

            // If selection changed and a counter is selected
            if (wMsg == CBN_SELCHANGE) {

                hWnd = DialogControl(m_hDlg, wId);
                iNewProp = (INT)CBSelection(hWnd);

                // Store the new property selection
                switch (wId) {

                    case IDC_LINECOLOR:
                         m_props.iColorIndex = iNewProp;
                         // If iColorIndex is for the custom color, the
                         // custom color is already set in the properties.
                         break;

                    case IDC_LINEWIDTH:
                        m_props.iWidthIndex = iNewProp;
                        SetStyleComboEnable();
                        break;

                    case IDC_LINESTYLE:
                        m_props.iStyleIndex = iNewProp;
                        break;

                    case IDC_LINESCALE:
                        m_props.iScaleIndex = iNewProp;
                        break;
                }

                // If counter is selected, update its properties
                if (m_pInfoSel != NULL) {

                    m_pInfoSel->Props = m_props;

                    // mark the counter as changed
                    m_pInfoSel->fChanged = TRUE;
                    SetChange();
                    SetModifiedSelectedVisuals( TRUE );
                }

            }
            break;

        case IDC_ADDCTR:
            // Invoke counter browser to add to counter
            AddCounters();
            break;

        case IDC_DELCTR:
            // Delete the currently selected counter
            DeleteItem();
            break;  
    }
}


VOID
CCounterPropPage::MeasureItem (
    OUT PMEASUREITEMSTRUCT pMI
    )
{
   pMI->CtlType    = ODT_COMBOBOX ;
   pMI->CtlID      = IDC_LINECOLOR ;
   pMI->itemData   = 0 ;
   pMI->itemWidth  = 0 ;
   pMI->itemHeight = 14 ;
}



VOID
CCounterPropPage::DrawItem (
    IN PDRAWITEMSTRUCT pDI
    )
/*++

Routine Description:

    DrawItem draws a specified item in one of the graphical property combo
    boxes. It is called to process WM_DRAWITEM messages.

Arguments:

    pDI - Pointer to DRAWITEMSTRUCT

Return Value:

    None.

--*/
{
    HDC            hDC ;
    PRECT          prect ;
    INT            itemID,
                  CtlID,
                  itemAction ;
    HPEN           hPen;
    COLORREF       rgbBk, rgbOldBk;

    if ( NULL != pDI ) {

        hDC        = pDI->hDC ;
        CtlID      = pDI->CtlID ;
        prect      = &pDI->rcItem ;
        itemID     = pDI->itemID ;
        itemAction = pDI->itemAction ;

        // Case on drawing request
        switch (itemAction) {

            case ODA_SELECT:

                // Draw/erase selection rect
                HandleSelectionState(pDI);
                break;

            case ODA_FOCUS:

                // Draw/erase focus rect
                HandleFocusState (pDI);
                break;

            case ODA_DRAWENTIRE:

                // Leave border space for focus rectangle
                InflateRect (prect, -OWNER_DRAWN_ITEM, -OWNER_DRAWN_ITEM) ;

                // Case on Control ID
                switch (CtlID)  {

                case IDC_LINECOLOR:

                    // Draw filled rect of item's color
                    if ( itemID < NumStandardColorIndices() )
                        Fill(hDC, IndexToStandardColor(itemID), prect);
                    else
                        // Custom color item only exists if the currently
                        // selected item has a custom color defined.
                        Fill(hDC, m_pInfoSel->Props.rgbColor, prect);
                    break ;

                case IDC_LINEWIDTH:
                case IDC_LINESTYLE:

                    // Clear the item's area
                    rgbBk = GetSysColor(COLOR_WINDOW);
                    
                    Fill(hDC, rgbBk, prect);

                    // Draw centered line showing item's width or style
                    if (CtlID == IDC_LINEWIDTH)
                       hPen = CreatePen (PS_SOLID, IndexToWidth(itemID), RGB (0,0,0));
                    else
                       hPen = CreatePen (IndexToStyle(itemID), 1, RGB (0,0,0));

                    if ( NULL != hPen ) {

                        // Set background to insure dashed lines show properly
                        rgbOldBk = SetBkColor (hDC, rgbBk) ;

                        if ( CLR_INVALID != rgbOldBk ) {

                            Line(hDC, (HPEN)hPen, prect->left + 8,
                                                  (prect->top + prect->bottom) / 2,
                                                  prect->right - 8,
                                                  (prect->top + prect->bottom) / 2);

                            SetBkColor (hDC, rgbOldBk) ;
                        }
                        DeleteObject (hPen) ;
                    }
                    break ;
            }

            // Restore original rect and draw focus/select rects
            InflateRect (prect, OWNER_DRAWN_ITEM, OWNER_DRAWN_ITEM) ;
            HandleSelectionState (pDI) ;
            HandleFocusState (pDI) ;        
        }
    }
}

INT
CCounterPropPage::ScaleFactorToIndex (
    IN INT iScaleFactor
    )
/*++

Routine Description:

    ScaleFactorToIndex translates a CounterItem ScaleFactor value to
    the appropriate scale factor combo box index.

Arguments:

    iScaleFactor - CounterItem scale factor integer value.

Return Value:

    Scale factor combo box index.

--*/
{
    INT retValue;

    if ( INT_MAX == iScaleFactor ) {
        retValue = 0;
    } else {
        retValue = iScaleFactor - PDH_MIN_SCALE + 1;
    }

    return retValue;
}

INT
CCounterPropPage::IndexToScaleFactor (
    IN INT iScaleIndex
    )
/*++

Routine Description:

    ScaleFactorToIndex translates a CounterItem ScaleFactor value to
    the appropriate scale factor combo box index.

Arguments:

    iScaleIndex - Scale factor combo box index.

Return Value:

    CounterItem scale factor integer value.

--*/
{
    INT retValue;

    if ( 0 == iScaleIndex ) {
        retValue = INT_MAX;
    } else {
        retValue = iScaleIndex - 1 + PDH_MIN_SCALE;
    }

    return retValue;
}

void
CCounterPropPage::SetStyleComboEnable (
    )
/*++

Routine Description:

    SetStyleComboEnable enables the style combo box if the width is 1,
    disables it otherwise.

Arguments:

Return Value:

    void

--*/
{
    DialogEnable (m_hDlg, IDC_LABEL_LINESTYLE, (0 == m_props.iWidthIndex) );
    DialogEnable (m_hDlg, IDC_LINESTYLE, (0 == m_props.iWidthIndex) );
}

HRESULT 
CCounterPropPage::EditPropertyImpl( DISPID dispID )
{
    HRESULT hr = E_NOTIMPL;

    if ( DISPID_VALUE == dispID ) {
        m_dwEditControl = IDC_ADDCTR;
        hr = S_OK;
    }

    return hr;
}
ULONG 
CCounterPropPage::HashCounter(
    LPTSTR szCounterName
    )
{
    ULONG       h = 0;
    ULONG       a = 31415;  //a, b, k are primes
    const ULONG k = 16381;
    const ULONG b = 27183;
    LPTSTR szThisChar;
    TCHAR Char;

    if (szCounterName) {
        for (szThisChar = szCounterName; * szThisChar; szThisChar ++) {
            Char = * szThisChar;
            if (_istupper(Char) ) {
                Char = _tolower(Char);
            }
            h = (a * h + ((ULONG) Char)) % k;
            a = a * b % (k - 1);
        }
    }
    return (h % eHashTableSize);
}


//++
// Description:
//    Remove a counter path from hash table. One counter
//    path must exactly match the given one in order to be
//    removed, even it is one with wildcard
//
// Parameters:
//    pItemInfo - Pointer to item info to be removed
//
// Return:
//    Return TRUE if the counter path is removed, otherwis return FALSE
//--
BOOL
CCounterPropPage::RemoveCounterFromHashTable(
    LPTSTR pszPath,
    PPDH_COUNTER_PATH_ELEMENTS pCounter
    ) 
{
    ULONG lHashValue;
    PHASH_ENTRY pEntry = NULL;
    PHASH_ENTRY pPrev = NULL;
    BOOL bReturn = FALSE;
    LPTSTR pszFullPath = NULL;

    SetLastError(ERROR_SUCCESS);

    if (pszPath == NULL || pCounter == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto ErrorOut;
    }

    //
    // If the counter path does not have machine name,
    // add the machine name to compose a full path
    //
    if (*pszPath == TEXT('\\') && (*(pszPath+1) == TEXT('\\')) ) {
        lHashValue = HashCounter(pszPath);
    }
    else {
        if (pCounter->szMachineName == NULL) {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto ErrorOut;
        }

        pszFullPath = new TCHAR [ lstrlen(pCounter->szMachineName) + lstrlen(pszPath) + 1 ];

        if (pszFullPath == NULL) {
            SetLastError(ERROR_OUTOFMEMORY);
            goto ErrorOut;
        }
        lstrcpy(pszFullPath, pCounter->szMachineName);
        lstrcat(pszFullPath, pszPath);

        lHashValue = HashCounter(pszFullPath);
    }

    pEntry = m_HashTable[lHashValue];

    //
    // Check if there is a counter path which is exactly the same
    // as the given one
    //
    while (pEntry) {
        if (pEntry->pCounter == pCounter) 
            break;
        pPrev = pEntry;
        pEntry = pEntry->pNext;
    }

    //
    // If we found it, remove it
    //
    if (pEntry) {
        if (pPrev == NULL) {
            m_HashTable[lHashValue] = pEntry->pNext;
        }
        else {
            pPrev->pNext = pEntry->pNext;
        }
        assert (pEntry->pCounter);
        delete(pEntry->pCounter);
        delete(pEntry);

        bReturn = TRUE;
    }

ErrorOut:
    if (pszFullPath != NULL) {
        delete(pszFullPath);
    }

    return bReturn;
}


//++
// Description:
//    Insert a counter path into hash table. 
//
// Parameters:
//    PItemInfo - Pointer to the counter item info
//
// Return:
//    Return the pointer to new inserted PDH_COUNTER_PATH_ELEMENTS structure
//--
DWORD
CCounterPropPage::InsertCounterToHashTable(
    LPTSTR pszPath,
    PPDH_COUNTER_PATH_ELEMENTS* ppCounter
    )
{
    ULONG       lHashValue;
    PHASH_ENTRY pEntry  = NULL;
    PHASH_ENTRY pPrev  = NULL;
    PDH_STATUS  pdhStatus;
    ULONG       ulBufSize;
    PPDH_COUNTER_PATH_ELEMENTS pCounter = NULL;
    LPTSTR      pszFullPath = NULL;
    BOOL        bExisted = FALSE;
    DWORD       dwResult;

    dwResult = ERROR_SUCCESS;

    if (pszPath == NULL || ppCounter == NULL) {
        dwResult = ERROR_INVALID_PARAMETER;
        goto ErrorOut;
    }

    *ppCounter = NULL;
    //
    // Parse the counter path
    //
    ulBufSize = sizeof(PDH_COUNTER_PATH_ELEMENTS) + sizeof(TCHAR) * MAX_PATH * 5;
    pCounter = (PPDH_COUNTER_PATH_ELEMENTS) new char [ ulBufSize ];

    if (pCounter == NULL) {
        dwResult = ERROR_OUTOFMEMORY;
        goto ErrorOut;
    }

    pdhStatus = PdhParseCounterPath( pszPath, pCounter, & ulBufSize, 0);

    if (pdhStatus != ERROR_SUCCESS) {
        dwResult = pdhStatus;
        goto ErrorOut;
    }

    //
    // If the counter path does not have machine name,
    // add the machine name to compose a full path
    //
    if (*pszPath == TEXT('\\') && (*(pszPath+1) == TEXT('\\')) ) {
        lHashValue = HashCounter(pszPath);
    }
    else {
        pszFullPath =  new TCHAR [ lstrlen(pCounter->szMachineName) + lstrlen(pszPath) + 1];

        if (pszFullPath == NULL) {
            dwResult = ERROR_OUTOFMEMORY;
            goto ErrorOut;
        }
        lstrcpy(pszFullPath, pCounter->szMachineName);
        lstrcat(pszFullPath, pszPath);

        lHashValue = HashCounter(pszFullPath);
    }

    //
    // Check if there is a counter path which is exactly the same
    // as the given one
    //
    pEntry = m_HashTable[lHashValue];

    while (pEntry) {
        if ( AreSameCounterPath ( pEntry->pCounter, pCounter ) ) {
            dwResult = SMON_STATUS_DUPL_COUNTER_PATH;
            bExisted = TRUE;
            *ppCounter = pEntry->pCounter;
            break;
        }

        pPrev = pEntry;
        pEntry = pEntry->pNext;
    }

    //
    // Add the new counter path
    //
    if (bExisted == FALSE) {
        pEntry = (PHASH_ENTRY) new HASH_ENTRY;
        if (pEntry == NULL) {
            dwResult = ERROR_OUTOFMEMORY;
            goto ErrorOut;
        }

        pEntry->pCounter = pCounter;
        pEntry->pNext = m_HashTable[lHashValue];
        m_HashTable[lHashValue] = pEntry;
        *ppCounter = pCounter;
    }

    if (pszFullPath != NULL) {
        delete(pszFullPath);
    }
    return dwResult;

ErrorOut:
    if (pszFullPath != NULL) {
        delete(pszFullPath);
    }

    if (pCounter != NULL) {
        delete ((char*) pCounter);
    }

    return dwResult;
}


//++
// Description:
//    The function clears all the entries in hash table
//    and set hash-table-not-set-up flag
//
// Parameters:
//    None
//
// Return:
//    None
//--
void 
CCounterPropPage::ClearCountersHashTable( void )
{
    ULONG       i;
    PHASH_ENTRY pEntry;
    PHASH_ENTRY pNext;

    if (m_fHashTableSetup) {
        for (i = 0; i < eHashTableSize; i ++) {
            pNext = m_HashTable[i];
            while (pNext != NULL) {
                pEntry = pNext;
                pNext  = pEntry->pNext;

                assert( pEntry->pCounter);

                delete pEntry->pCounter; 
                delete (pEntry);
            }
        }
    }
    else {
        memset(&m_HashTable, 0, sizeof(m_HashTable));
    }
    m_fHashTableSetup = FALSE;
}

void CCounterPropPage::DeleteInfo(PItemInfo pInfo)
{
    if (pInfo == NULL) {
        return;
    }

    if (pInfo->pszPath != NULL) {
        delete (pInfo->pszPath);
    }
    if ( pInfo->pItem != NULL ) {
        pInfo->pItem->Release();
    }

    delete pInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\ctrldll.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ctrldll.cpp

Abstract:

    DLL methods, class factory.

--*/

#define INITGUIDS
#define DEFINE_GLOBALS

#include <assert.h>
#include "polyline.h"
#include <servprov.h>
#include <exdisp.h>
#include <shlguid.h>
#include <urlmon.h>
#include "smonctrl.h"   // For version numbers
#include "genprop.h"
#include "ctrprop.h"
#include "grphprop.h"
#include "srcprop.h"
#include "appearprop.h"
#include "unihelpr.h"
#include "unkhlpr.h"
#include "appmema.h"

ITypeLib *g_pITypeLib;
DWORD     g_dwScriptPolicy = URLPOLICY_ALLOW;

BOOL DLLAttach ( HINSTANCE );
VOID DLLDetach ( VOID );

extern HWND CreateFosterWnd( VOID );

BOOL WINAPI 
DllMain (
    IN HINSTANCE hInstance, 
    IN ULONG ulReason,
    IN LPVOID // pvReserved
    )
/*++

Routine Description:

    DllMain is the main entrypoint of the DLL. On a process attach, it calls
    the DLL initialization routine. On process detach, it calls the clean up
    routine.
     
Arguments:

    hInstance - DLL instance handle
    ulReason - Calling reason (DLL_PROCESS_ATTCH, DLL_PROCESS_DETACH, etc.)
    pvReserved - Not used

Return Value:

    Boolean result - TRUE = success, FALSE = failure 

--*/
{
    switch (ulReason) 
    {
        case DLL_PROCESS_ATTACH:
            return DLLAttach(hInstance);

        case DLL_PROCESS_DETACH:
            DLLDetach();
            return TRUE;

        default:
            return TRUE;
    }   
}



BOOL
DLLAttach (
    IN HINSTANCE hInst
    )
/*++

Routine Description:

    DLLAttach initializes global variables and objects, and loads the type library. 
    It saves the DLL instance handle in global variable, g_hInstance.

Arguments:
    
    hInst - DLL instance handle

Return Value:

    Boolean status - TRUE = success

--*/
{
    HRESULT     hr;

    USES_CONVERSION

    g_hInstance = hInst;

    // Initialize general purpose critical section
    InitializeCriticalSection(&g_CriticalSection);

    // Create foster window
    g_hWndFoster = CreateFosterWnd();
    if (g_hWndFoster == NULL)
        return FALSE;

    //assert( IsWindowUnicode( g_hwndFoster ) );

    // Try loading type library from registry info
    hr = LoadRegTypeLib(LIBID_SystemMonitor, SMONCTRL_MAJ_VERSION, SMONCTRL_MIN_VERSION
        , LANG_NEUTRAL, &g_pITypeLib);

    // If failed, try loading our typelib resource
    if (FAILED(hr)) {
        TCHAR   szModule[MAX_PATH];
        PWCHAR  pszTest;

        GetModuleFileName(g_hInstance, szModule, MAX_PATH);
        pszTest = T2W(szModule);
        hr = LoadTypeLib(pszTest, &g_pITypeLib);
    }

    // Initialize the perf counters
    AppPerfOpen(hInst);

    if (FAILED(hr))
        return FALSE;

    return TRUE;
}


VOID 
DLLDetach ( 
    VOID
    )
/*++

Routine Description:

    This routine deletes global variables and objects and unregisters
    all of the window classes.

Arguments:

    None.

Return Value:

    None.

--*/
{
    INT i;

    // Delete the foster window
    if (g_hWndFoster)
        DestroyWindow(g_hWndFoster);

    // Unregister all window classes
    for (i=0; i<MAX_WINDOW_CLASSES; i++) {
        if (pstrRegisteredClasses[i] != NULL) {
            UnregisterClass(pstrRegisteredClasses[i], g_hInstance);
        }
    }

    // Release the typelib 
    if (g_pITypeLib != NULL)
        g_pITypeLib->Release();

    AppPerfClose ((HINSTANCE)NULL);
}


/*
 * DllGetClassObject
 *
 * Purpose:
 *  Provides an IClassFactory for a given CLSID that this DLL is
 *  registered to support.  This DLL is placed under the CLSID
 *  in the registration database as the InProcServer.
 *
 * Parameters:
 *  clsID           REFCLSID that identifies the class factory
 *                  desired.  Since this parameter is passed this
 *                  DLL can handle any number of objects simply
 *                  by returning different class factories here
 *                  for different CLSIDs.
 *
 *  riid            REFIID specifying the interface the caller wants
 *                  on the class object, usually IID_ClassFactory.
 *
 *  ppv             PPVOID in which to return the interface
 *                  pointer.
 *
 * Return Value:
 *  HRESULT         NOERROR on success, otherwise an error code.
 */

HRESULT APIENTRY 
DllGetClassObject (
    IN  REFCLSID rclsid,
    IN  REFIID riid, 
    OUT PPVOID ppv
    )
/*++

Routine Description:

    DllGetClassObject creates a class factory for the specified object class.
    The routine handles the primary control and the property pages.

Arguments:

    rclsid - CLSID of object 
    riid - IID of requested interface (IID_IUNknown or IID_IClassFactory)
    ppv -  Pointer to returned interface pointer

Return Value:

    HRESULT

--*/
{

    // Check for valid interface request
    if (IID_IUnknown != riid && IID_IClassFactory != riid)
        return ResultFromScode(E_NOINTERFACE);

    // Create class factory for request class
    if (CLSID_SystemMonitor == rclsid)
        *ppv = new CPolylineClassFactory;
    else if (CLSID_GeneralPropPage == rclsid)
        *ppv = new CSysmonPropPageFactory(GENERAL_PROPPAGE);
    else if (CLSID_SourcePropPage == rclsid)
        *ppv = new CSysmonPropPageFactory(SOURCE_PROPPAGE);
    else if (CLSID_CounterPropPage == rclsid)
        *ppv = new CSysmonPropPageFactory(COUNTER_PROPPAGE);
    else if (CLSID_GraphPropPage == rclsid)
        *ppv = new CSysmonPropPageFactory(GRAPH_PROPPAGE);
    else if (CLSID_AppearPropPage == rclsid)
        *ppv = new CSysmonPropPageFactory(APPEAR_PROPPAGE);
    else
        return ResultFromScode(E_FAIL);

    if (NULL == *ppv)
        return ResultFromScode(E_OUTOFMEMORY);

    // AddRef the class factory object 
    ((LPUNKNOWN)*ppv)->AddRef();

    return NOERROR;
}


STDAPI 
DllCanUnloadNow (
    VOID
    )
/*++

Routine Description:

    DllCanUnload determines whether the DLL can be unloaded now. The DLL must
    remain active if any objects exist or any class factories are locked.  

Arguments:

    None.

Return Value:

    HRESULT - S_OK if OK to unload, S_FALSE if not

--*/
{
    SCODE   sc;

    // OK to unload if no locks or objects
    sc = (0L == g_cObj && 0L == g_cLock) ? S_OK : S_FALSE;

    return ResultFromScode(sc);
}


VOID 
ObjectDestroyed (
    VOID
    )
/*++

Routine Description:

    ObjectDestroyed decrements the global object count. It is called whenever
    an object is destroyed. The count controls the lifetme of the DLL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    InterlockedDecrement(&g_cObj);
}


//---------------------------------------------------------------------------
// Class factory constructor & destructor
//---------------------------------------------------------------------------

/*
 * CPolylineClassFactory::CPolylineClassFactory
 *
 * Purpose:
 *  Constructor for an object supporting an IClassFactory that
 *  instantiates Polyline objects.
 *
 * Parameters:
 *  None
 */

CPolylineClassFactory::CPolylineClassFactory (
    VOID
    )
{
    m_cRef = 0L;
}


/*
 * CPolylineClassFactory::~CPolylineClassFactory
 *
 * Purpose:
 *  Destructor for a CPolylineClassFactory object.  This will be
 *  called when we Release the object to a zero reference count.
 */

CPolylineClassFactory::~CPolylineClassFactory (
    VOID
    )
{
    return;
}


//---------------------------------------------------------------------------
// Standard IUnknown implementation for class factory
//---------------------------------------------------------------------------

STDMETHODIMP 
CPolylineClassFactory::QueryInterface (
    IN  REFIID riid,
    OUT PPVOID ppv
    )
{
    *ppv = NULL;

    if (IID_IUnknown == riid || IID_IClassFactory == riid)
        *ppv=this;

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) 
CPolylineClassFactory::AddRef (
    VOID
    )
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) 
CPolylineClassFactory::Release (
    VOID
    )
{
    if (0L != --m_cRef)
        return m_cRef;

    delete this;
    return 0L;
}


STDMETHODIMP 
CPolylineClassFactory::CreateInstance (
    IN  LPUNKNOWN pUnkOuter, 
    IN  REFIID riid, 
    OUT PPVOID ppvObj
    )
/*++

Routine Description:

    CreateInstance creates an instance of the control object and returns
    the requested interface to it.

Arguments:

    pUnkOuter - IUnknown of outer controling object
    riid - IID of requested object interface
    ppvObj - Pointer to returned interface pointer

Return Value:

   HRESULT - NOERROR, E_NOINTERFACE, or E_OUTOFMEMORY

--*/
{
    PCPolyline          pObj;
    HRESULT             hr;

    *ppvObj = NULL;
    hr = ResultFromScode(E_OUTOFMEMORY);

    // Verify that a controlling unknown asks for IUnknown
    if (NULL != pUnkOuter && IID_IUnknown != riid)
        return ResultFromScode(E_NOINTERFACE);

    // Create the object instance
    pObj = new CPolyline(pUnkOuter, ObjectDestroyed);
    if (NULL == pObj)
        return hr;

    // Initialize and get the requested interface
    if (pObj->Init())
        hr = pObj->QueryInterface(riid, ppvObj);

    // Delete object if initialization failed
    // Otherwise increment gloabl object count
    if (FAILED(hr))
        delete pObj;
    else
        InterlockedIncrement(&g_cObj);

    return hr;
}



STDMETHODIMP 
CPolylineClassFactory::LockServer (
    IN BOOL fLock
    )
/*++

Routine Description:

    LockServer increments or decrements the DLL lock count. A non-zero lock
    count prevents the DLL from unloading.

Arguments:

    fLock - Lock operation (TRUE = increment, FALSE = decrement)

Return Value:

    HRESULT - Always NOERROR

--*/
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);

    return NOERROR;
}

//
// CImpIObjectSafety interface implmentation
//
IMPLEMENT_CONTAINED_IUNKNOWN(CImpIObjectSafety);


CImpIObjectSafety::CImpIObjectSafety(PCPolyline pObj, LPUNKNOWN pUnkOuter)
    :
    m_cRef(0),
    m_pObj(pObj),
    m_pUnkOuter(pUnkOuter),
    m_fMessageDisplayed(FALSE)
{
}

CImpIObjectSafety::~CImpIObjectSafety()
{
}

STDMETHODIMP 
CImpIObjectSafety::GetInterfaceSafetyOptions(
    REFIID riid, 
    DWORD *pdwSupportedOptions, 
    DWORD *pdwEnabledOptions
    )
/*++

Routine Description:

    Retrieve the safety capability of object

Arguments:

    riid - Interface ID to retrieve

    pdwSupportedOptions - The options the object knows about(might not support)

    pdwEnabledOptions - The options the object supports

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL) {
        return E_POINTER;
    }

    if (riid == IID_IDispatch) {
        //
        // Safe for scripting
        //
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
        *pdwEnabledOptions   = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
    }
    else if (riid == IID_IPersistPropertyBag || riid == IID_IPersistStreamInit) {
        //
        // Safety for initializing
        //
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_DATA;
        *pdwEnabledOptions   = INTERFACESAFE_FOR_UNTRUSTED_DATA;
    }
    else {
        //
        // We don't support interfaces, fail out
        //
        *pdwSupportedOptions = 0;
        *pdwEnabledOptions   = 0;
        hr = E_NOINTERFACE;
    }

    return hr;
}


STDMETHODIMP 
CImpIObjectSafety::SetInterfaceSafetyOptions(
    REFIID riid, 
    DWORD dwOptionSetMask, 
    DWORD dwEnabledOptions
    )
/*++

Routine Description:

    The function is used for container to ask an object if it is safe
    for scripting or safe for initialization

Arguments:

    riid - Interface ID to query

    dwSupportedOptions - The options the object knows about(might not support)

    dwEnabledOptions - The options the object supports

Return Value:

    HRESULT

--*/
{   
    //
    // If we're being asked to set our safe for scripting or
    // safe for initialization options then oblige
    //
    if (0 == dwOptionSetMask && 0 == dwEnabledOptions)
    {
        //
        // the control certainly supports NO requests through the specified interface
        // so it's safe to return S_OK even if the interface isn't supported.
        //
        return S_OK;
    }

    SetupSecurityPolicy();

    if (riid == IID_IDispatch)
    {
        //
        // Client is asking if it is safe to call through IDispatch
        //
        if (INTERFACESAFE_FOR_UNTRUSTED_CALLER == dwOptionSetMask && 
            INTERFACESAFE_FOR_UNTRUSTED_CALLER == dwEnabledOptions)
        {
            return S_OK;
        }
    }
    else if (riid == IID_IPersistPropertyBag || riid == IID_IPersistStreamInit)
    {
        //
        // Client is asking if it's safe to call through IPersistXXX
        //
        if (INTERFACESAFE_FOR_UNTRUSTED_DATA == dwOptionSetMask && 
            INTERFACESAFE_FOR_UNTRUSTED_DATA == dwEnabledOptions)
        {
            return S_OK;
        }
    }

    return E_FAIL;
}


VOID
CImpIObjectSafety::SetupSecurityPolicy()
/*++

Routine Description:

    The function check if we are safe for scripting.

Arguments:

    None

Return Value:

    Return TRUE if we are safe for scripting, othewise return FALSE

--*/
{
    HRESULT hr;
    IServiceProvider* pSrvProvider = NULL;
    IWebBrowser2* pWebBrowser = NULL;
    IInternetSecurityManager* pISM = NULL;
    BSTR bstrURL;
    DWORD dwContext = 0;

    g_dwScriptPolicy = URLPOLICY_ALLOW;

    //
    // Get the service provider
    //
    hr = m_pObj->m_pIOleClientSite->QueryInterface(IID_IServiceProvider, (void **)&pSrvProvider);
    if (SUCCEEDED(hr)) {
        hr = pSrvProvider->QueryService(SID_SWebBrowserApp,
                                        IID_IWebBrowser2,
                                        (void **)&pWebBrowser);
    }

    if (SUCCEEDED(hr)) {
        hr = pSrvProvider->QueryService(SID_SInternetSecurityManager,
                                        IID_IInternetSecurityManager,
                                        (void**)&pISM);
    }

    if (SUCCEEDED(hr)) {
        hr = pWebBrowser->get_LocationURL(&bstrURL);
    }


    //
    // Querying safe for scripting 
    //
    if (SUCCEEDED(hr)) {
        hr = pISM->ProcessUrlAction(bstrURL,
                                URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY,
                                (BYTE*)&g_dwScriptPolicy,
                                sizeof(g_dwScriptPolicy),
                                (BYTE*)&dwContext, 
                                sizeof(dwContext),
                                PUAF_NOUI, 
                                0);
    }

    if (SUCCEEDED(hr)) {
        if (g_dwScriptPolicy == URLPOLICY_QUERY) {
            g_dwScriptPolicy = URLPOLICY_ALLOW;
        }
    }
    
    if (pWebBrowser) {
        pWebBrowser->Release();
    }
    if (pSrvProvider) {
        pSrvProvider->Release();
    }
    if (pISM) {
        pISM->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\ctrprop.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ctrprop.h

Abstract:

    Header file for the counter date property page

--*/

#ifndef _CTRPROP_H_
#define _CTRPROP_H_

#include "smonprop.h"
#include "visuals.h"


// Property Page Dialog IDs
#define IDD_CTR_PROPP_DLG           200
#define IDC_CTRLIST                 201
#define IDC_ADDCTR                  202
#define IDC_DELCTR                  203
#define IDC_ADDCTR_TEXT             204
#define IDC_LINECOLOR               205
#define IDC_LINESCALE               206
#define IDC_LINEWIDTH               207
#define IDC_LINESTYLE               208
#define IDC_LABEL_LINECOLOR         209
#define IDC_LABEL_LINESCALE         210
#define IDC_LABEL_LINEWIDTH         211
#define IDC_LABEL_LINESTYLE         212

typedef struct _ItemProps
{
    // Combo box indices
    INT         iColorIndex;
    INT         iStyleIndex;
    INT         iScaleIndex;
    INT         iWidthIndex;
    // Custom color
    COLORREF    rgbColor;
} ItemProps;

typedef struct _ItemInfo
{
    struct _ItemInfo * pNextInfo;
    ICounterItem *     pItem;
    LPTSTR             pszPath;
    BOOL               fLoaded:1,
                       fChanged:1,
                       fAdded:1;
    ItemProps          Props;
    PPDH_COUNTER_PATH_ELEMENTS pCounter;
} ItemInfo, *PItemInfo;

class CCounterPropPage : public CSysmonPropPage
{
    friend static HRESULT AddCallback (
        LPTSTR  pszPathName,
        DWORD_PTR lpUserData,
        DWORD   dwFlags
    );

    public:
                CCounterPropPage(void);
        virtual ~CCounterPropPage(void);

    protected:
        virtual BOOL GetProperties(void);   //Read current options
        virtual BOOL SetProperties(void);   //Set new options
        virtual void DeinitControls(void);       // Deinitialize dialog controls

        virtual void DialogItemChange(WORD wId, WORD wMsg); // Handle item change
        virtual void MeasureItem(PMEASUREITEMSTRUCT); // Handle user measure req
        virtual void DrawItem(PDRAWITEMSTRUCT);  // Handle user draw req
        virtual HRESULT EditPropertyImpl( DISPID dispID);   // Set focus to control      
    
    private:

        void    DeleteInfo(PItemInfo pInfo);
        void    SetStyleComboEnable();      // Enable/disable based on current width value
        void    InitDialog(void);
        void    AddCounters(void);
        HRESULT NewItem(LPTSTR pszPath, DWORD dwFlags);
        INT     AddItemToList(PItemInfo pInfo);
        void    DeleteItem();
        void    LoadItemProps(PItemInfo pInfo);
        void    DisplayItemProps(PItemInfo pInfo);
        void    SelectItem(INT iItem);
        INT     SelectMatchingItem(INT iColor, COLORREF rgbCustomColor, INT iWidth, INT iStyle);

        INT     ScaleFactorToIndex ( INT iScaleFactor );
        INT     IndexToScaleFactor ( INT iScaleIndex );

		void	IncrementLocalVisuals ( void );
		void	SetModifiedSelectedVisuals ( BOOL bModified = TRUE ) { m_bAreModSelectedVisuals = bModified; };
		BOOL	AreModifiedSelectedVisuals ( void ){ return m_bAreModSelectedVisuals; };


    private:
        PItemInfo   m_pInfoSel;
        PItemInfo   m_pInfoDeleted;
        ItemProps   m_props;
        INT         m_iAddIndex;
        DWORD       m_dwMaxHorizListExtent;     
        BOOL        m_bAreModSelectedVisuals;

        PDH_BROWSE_DLG_CONFIG   m_BrowseInfo;

        enum eValueRange {
            eHashTableSize = 257
        };
        typedef struct _HASH_ENTRY {
            struct _HASH_ENTRY* pNext;
            PPDH_COUNTER_PATH_ELEMENTS pCounter;
        } HASH_ENTRY, *PHASH_ENTRY;

        PHASH_ENTRY  m_HashTable[257];
        BOOL  m_fHashTableSetup;

        ULONG HashCounter ( LPTSTR szCounterName );
public:

    BOOL  RemoveCounterFromHashTable( LPTSTR pszPath, PPDH_COUNTER_PATH_ELEMENTS pCounter);
    void  InitializeHashTable( void );
    void  ClearCountersHashTable ( void );
    DWORD InsertCounterToHashTable ( LPTSTR pszPath, PPDH_COUNTER_PATH_ELEMENTS* ppCounter );

};
typedef CCounterPropPage *PCCounterPropPage;

DEFINE_GUID(CLSID_CounterPropPage,
            0xcf948561, 0xede8, 0x11ce, 0x94, 0x1e, 0x0, 0x80, 0x29, 0x0, 0x43, 0x47);

#endif //_CTRPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\counters.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    counters.h

Abstract:

    Header file for the implementation of the ICounters object.

--*/

#ifndef _COUNTERS_H_
#define _COUNTERS_H_

class CPolyline;

class CImpICounters : public ICounters
{
  protected:
	ULONG		m_cRef;
	CPolyline	*m_pObj;
    LPUNKNOWN   m_pUnkOuter;
			
  public:

	CImpICounters(CPolyline*, LPUNKNOWN);
	~CImpICounters();

    /* IUnknown methods */
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)	(UINT *pctinfo);

    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);

    STDMETHOD(GetIDsOfNames) (REFIID riid, OLECHAR **rgszNames,
     						  UINT cNames, LCID lcid, DISPID *rgdispid);

    STDMETHOD(Invoke) (DISPID dispidMember, REFIID riid, LCID lcid,WORD wFlags,
      				   DISPPARAMS *pdispparams, VARIANT *pvarResult,
      				   EXCEPINFO *pexcepinfo, UINT *puArgErr);

    /* Counters methods */
    STDMETHOD(get_Count) (long *pLong);
    STDMETHOD(get__NewEnum)	(IUnknown **ppIunk);
    STDMETHOD(get_Item) (VARIANT index, DICounterItem **ppI);
    STDMETHOD(Add) (BSTR bstrPath, DICounterItem **ppI);
    STDMETHOD(Remove) (VARIANT index);
};

typedef CImpICounters *PCImpICounters;


// Counter enumerator
class CImpIEnumCounter : public IEnumVARIANT
{
protected:
	DWORD		m_cRef;
	PCGraphItem *m_paGraphItem;
	ULONG		m_cItems;
	ULONG		m_uCurrent;
		
public:
	CImpIEnumCounter (VOID);
	HRESULT Init (PCGraphItem pGraphItem, INT cItems);

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

	// Enum methods
	STDMETHOD(Next) (ULONG cItems, VARIANT *varItems, ULONG *pcReturned);
	STDMETHOD(Skip) (ULONG cSkip);
	STDMETHOD(Reset) (VOID);
	STDMETHOD(Clone) (IEnumVARIANT **pIEnum);
};

#endif //_COUNTERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\ctrlwin.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    ctrlwin.cpp

Abstract:

    Window procedure for the sysmon.ocx drawing window and support
    functions.
--*/

#include "polyline.h"

/*
 * CPolyline::Draw
 *
 * Purpose:
 *  Paints the current line in the polyline window.
 *
 * Parameters:
 *  hDC             HDC to draw on, a metafile or printer DC.
 *  fMetafile       BOOL indicating if hDC is a metafile or not,
 *                  so we can avoid operations that RIP.
 *  fEntire         BOOL indicating if we should draw the entire
 *                  figure or not.
 *  pRect           LPRECT defining the bounds in which to draw.
 *
 * Return Value:
 *  None
 */

void 
CPolyline::Draw(
    HDC hDC,
    HDC hAttribDC,
    BOOL fMetafile, 
    BOOL fEntire,
    LPRECT pRect)
{

    RECT            rc;

    if (!fMetafile && !RectVisible(hDC, pRect))
        return;

    SetMapMode(hDC, MM_ANISOTROPIC);

    //
    // Always set up the window extents to the natural window size
    // so the drawing routines can work in their normal dev coords
    //

    // Use client rect vs. extent rect for Zoom calculation.
    // Zoom factor = prcPos / Extent, so pRect/ClientRect.


    /********* Use the extent rect, not the window rect *********/
    // Using rectExt makes Word printing correct at all zoom levels.
    rc = m_RectExt;
    // GetClientRect(m_pCtrl->Window(), &rc);
    /************************************************************/

    SetWindowOrgEx(hDC, 0, 0, NULL);
    SetWindowExtEx(hDC, rc.right, rc.bottom, NULL);

    SetViewportOrgEx(hDC, pRect->left, pRect->top, NULL);
    SetViewportExtEx(hDC, pRect->right - pRect->left, 
                    pRect->bottom - pRect->top, NULL);

    m_pCtrl->InitView( g_hWndFoster);
    m_pCtrl->Render(hDC, hAttribDC, fMetafile, fEntire, &rc);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\counters.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    counters.cpp

Abstract:

    Implementation of the ICounters interface

--*/

#include "polyline.h"
#include "unkhlpr.h"
#include "unihelpr.h"

extern ITypeLib *g_pITypeLib;

//Standard IUnknown implementation for contained interface
IMPLEMENT_CONTAINED_CONSTRUCTOR(CPolyline, CImpICounters)
IMPLEMENT_CONTAINED_DESTRUCTOR(CImpICounters)
IMPLEMENT_CONTAINED_ADDREF(CImpICounters)
IMPLEMENT_CONTAINED_RELEASE(CImpICounters)


STDMETHODIMP 
CImpICounters::QueryInterface (
    IN  REFIID riid, 
    OUT PPVOID ppv
    )
{
    HRESULT hr = E_POINTER;

    if ( NULL != ppv ) {
        *ppv=NULL;

        if (!(IID_IUnknown == riid || IID_ICounters == riid)) {
            hr = E_NOINTERFACE;
        } else {
            *ppv=(LPVOID)this;
            ((LPUNKNOWN)*ppv)->AddRef();
            hr = NOERROR;
        }
    }
    return hr;
}



STDMETHODIMP 
CImpICounters::GetTypeInfoCount (
    OUT UINT *pctInfo
    )
{
    HRESULT hr = E_POINTER;
    if ( NULL != pctInfo ) {
        *pctInfo = 1;
        hr = NOERROR;
    } 
    return hr;
}


STDMETHODIMP 
CImpICounters::GetTypeInfo (
    IN  UINT itInfo, 
    IN  LCID /* lcid */, 
    OUT ITypeInfo **ppITypeInfo )
{
    HRESULT hr = E_POINTER;
    if (NULL != ppITypeInfo) {
        if (0 == itInfo) {
            *ppITypeInfo = NULL;

            //We ignore the LCID
            hr =  g_pITypeLib->GetTypeInfoOfGuid(IID_ICounters, ppITypeInfo);
        } else {
            return TYPE_E_ELEMENTNOTFOUND;
        }
    } 
    return hr;
}


STDMETHODIMP 
CImpICounters::GetIDsOfNames (
    IN  REFIID riid,
    IN  OLECHAR **rgszNames, 
    IN  UINT cNames,
    IN  LCID /* lcid */,
    OUT DISPID *rgDispID
    )
{
    HRESULT     hr = DISP_E_UNKNOWNINTERFACE;
    ITypeInfo  *pTI = NULL;

    if (IID_NULL == riid) {
        if ( NULL != rgDispID 
                && NULL != rgszNames 
                && NULL != *rgszNames) {
            hr = g_pITypeLib->GetTypeInfoOfGuid(IID_ICounters, &pTI);

            if (SUCCEEDED(hr)) {
                hr = DispGetIDsOfNames(pTI, rgszNames, cNames, rgDispID);
                pTI->Release();
            }
        } else {
            return E_POINTER;
        }
    }
    return hr;
}



/*
 * CImpIDispatch::Invoke
 *
 * Purpose:
 *  Calls a method in the dispatch interface or manipulates a
 *  property.
 *
 * Parameters:
 *  dispID          DISPID of the method or property of interest.
 *  riid            REFIID reserved, must be IID_NULL.
 *  lcid            LCID of the locale.
 *  wFlags          USHORT describing the context of the invocation.
 *  pDispParams     DISPPARAMS * to the array of arguments.
 *  pVarResult      VARIANT * in which to store the result.  Is
 *                  NULL if the caller is not interested.
 *  pExcepInfo      EXCEPINFO * to exception information.
 *  puArgErr        UINT * in which to store the index of an
 *                  invalid parameter if DISP_E_TYPEMISMATCH
 *                  is returned.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */

STDMETHODIMP 
CImpICounters::Invoke ( 
    IN  DISPID dispID, 
    IN  REFIID riid,
    IN  LCID /* lcid */, 
    IN  USHORT wFlags, 
    IN  DISPPARAMS *pDispParams,
    OUT VARIANT *pVarResult, 
    OUT EXCEPINFO *pExcepInfo, 
    OUT UINT *puArgErr
    )
{
    HRESULT     hr = DISP_E_UNKNOWNINTERFACE;
    ITypeInfo  *pTI = NULL;

    if ( IID_NULL == riid ) {
        hr = g_pITypeLib->GetTypeInfoOfGuid(IID_ICounters, &pTI);

        if (SUCCEEDED(hr)) {

            hr = pTI->Invoke(this, dispID, wFlags,
                             pDispParams, pVarResult, pExcepInfo, puArgErr);
            pTI->Release();
        }
    } 

    return hr;
}


STDMETHODIMP
CImpICounters::get_Count (
    OUT LONG *pLong
    )
{
    HRESULT hr = E_POINTER;

    if (pLong != NULL) {
        *pLong = m_pObj->m_Graph.CounterTree.NumCounters();
        hr = NOERROR;
    }
    return hr;
}


STDMETHODIMP
CImpICounters::get__NewEnum (
    IUnknown **ppIunk
    )
{
    HRESULT hr = E_POINTER;
    CImpIEnumCounter *pEnum;

    if ( NULL != ppIunk ) {

        *ppIunk = NULL;

        pEnum = new CImpIEnumCounter;

        if ( NULL != pEnum ) {
            hr = pEnum->Init(
                    m_pObj->m_Graph.CounterTree.FirstCounter(), 
                    m_pObj->m_Graph.CounterTree.NumCounters() );

            if ( SUCCEEDED ( hr ) ) {
                pEnum->AddRef();    
                *ppIunk = pEnum;
                hr = NOERROR;
            } else {
                delete pEnum;
            }
        } else {
            return E_OUTOFMEMORY;
        }
    } 
    return hr;
}


STDMETHODIMP
CImpICounters::get_Item (
    IN  VARIANT varIndex, 
    OUT DICounterItem **ppI
    )
{
    HRESULT hr = E_POINTER;
    VARIANT varLoc;
    INT iIndex = 0;
    INT i;
    CGraphItem *pGItem = NULL;

    if (ppI != NULL) {

        *ppI = NULL;

        // Try coercing index to I4
        VariantInit(&varLoc);
        hr = VariantChangeType(&varLoc, &varIndex, 0, VT_I4);
        if ( SUCCEEDED (hr) ) {
            // Verify index is in range
            iIndex = V_I4(&varLoc);
            if (iIndex < 1 || iIndex > m_pObj->m_Graph.CounterTree.NumCounters())
                hr = DISP_E_BADINDEX;
        }
        if ( SUCCEEDED (hr) ) {                        
            // Traverse counter linked list to indexed item
            pGItem = m_pObj->m_Graph.CounterTree.FirstCounter();
            i = 1;
            while (i++ < iIndex && pGItem != NULL) {
                pGItem = pGItem->Next();
            }

            // Something wrong with linked list!!
            if ( NULL == pGItem )
                hr = E_FAIL;
        }
        if ( SUCCEEDED (hr) ) {                        
            // Return counter's dispatch interface
            hr = pGItem->QueryInterface(DIID_DICounterItem, (PVOID*)ppI);
        }
    } 
    return hr;
}


STDMETHODIMP
CImpICounters::Add (
    IN  BSTR bstrPath,
    OUT DICounterItem **ppI
    )
{
    HRESULT hr = E_POINTER;
    PCGraphItem pGItem;

    USES_CONVERSION

    if ( NULL != ppI ) {
        *ppI = NULL;

        // If non-null counter
        if (bstrPath != NULL && bstrPath[0] != 0) {
            hr = m_pObj->m_pCtrl->AddCounter(W2T(bstrPath), &pGItem);
            if ( SUCCEEDED ( hr ) ) {
                hr = pGItem->QueryInterface(DIID_DICounterItem, (PVOID*)ppI);
                pGItem->Release();
            }
        } else {
            hr = E_INVALIDARG;
        }
    }
    return hr;
}


STDMETHODIMP
CImpICounters::Remove (
    IN  VARIANT varIndex
    )
{
    DICounterItem *pDI = NULL;
    PCGraphItem pGItem;
    HRESULT hr;

    // Get interface to indexed item
    hr = get_Item(varIndex, &pDI);

    if ( SUCCEEDED ( hr ) ) {
        // Exchange Dispatch interface for direct one
        hr = pDI->QueryInterface(IID_ICounterItem, (PVOID*)&pGItem);
        pDI->Release();
        if ( SUCCEEDED ( hr ) ) {
            assert ( NULL != pGItem );

            // Delete the item from the control
            pGItem->Delete(TRUE);

            // Release the temp interface
            pGItem->Release();
        }
    }
    return hr;
}


CImpIEnumCounter::CImpIEnumCounter (
    VOID
    )
{
    m_cItems = 0;
    m_uCurrent = 0;
    m_cRef = 0;
    m_paGraphItem = NULL;
}


HRESULT
CImpIEnumCounter::Init (    
    PCGraphItem pGraphItem,
    INT         cItems
    )
{
    HRESULT hr = NOERROR;
    INT i;

    if ( cItems > 0 ) {
        m_cItems = cItems;
        m_paGraphItem = (PCGraphItem*)malloc(sizeof(PCGraphItem) * cItems);

        if ( NULL != m_paGraphItem ) {
            for (i=0; i<cItems; i++) {
                m_paGraphItem[i] = pGraphItem;
                pGraphItem = pGraphItem->Next();
            }
        } else {
            hr = E_OUTOFMEMORY;
        }
    } // No error if cItems <= 0
    return hr;
}

    

STDMETHODIMP
CImpIEnumCounter::QueryInterface (
    IN  REFIID riid, 
    OUT PVOID *ppv
    )
{
    HRESULT hr = E_POINTER;

    if ( NULL != ppv ) {
        if ((riid == IID_IUnknown) || (riid == IID_IEnumVARIANT)) {
            *ppv = this;
            AddRef();
            hr = NOERROR;
        } else {
            *ppv = NULL;
            hr = E_NOINTERFACE;
        }
    }
    return hr;
}


STDMETHODIMP_(ULONG)
CImpIEnumCounter::AddRef (
    VOID
    )
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG)
CImpIEnumCounter::Release(
    VOID
    )
{
    if (--m_cRef == 0) {

        if (m_paGraphItem != NULL)
            free(m_paGraphItem);

        delete this;
        return 0;
    }

    return m_cRef;
}


STDMETHODIMP
CImpIEnumCounter::Next(
    IN  ULONG cItems,
    OUT VARIANT *varItem,
    OUT ULONG *pcReturned)
{
    HRESULT hr = E_POINTER;
    ULONG i;
    ULONG cRet;

    if ( NULL != varItem ) {
        hr = NOERROR;
        // Clear the return variants
        for (i = 0; i < cItems; i++)
            VariantInit(&varItem[i]);

        // Try to fill the caller's array
        for (cRet = 0; cRet < cItems; cRet++) {

            // No more, return success with false
            if (m_uCurrent == m_cItems) {
                hr = S_FALSE;
                break;
            }

            // Get a dispatch interface for the item
            hr = m_paGraphItem[m_uCurrent]->QueryInterface(DIID_DICounterItem,
                                             (PVOID*)&V_DISPATCH(&varItem[cRet]));
            if (FAILED(hr))
                break;

            V_VT(&varItem[cRet]) = VT_DISPATCH;

            m_uCurrent++;
        }

        // If failed, clear out the variants
        if (FAILED(hr)) {
            for (i = 0; i < cItems; i++)
                VariantClear(&varItem[i]);
            cRet = 0;
        }

        // If desired, return number of items fetched
        if (pcReturned != NULL)
          *pcReturned = cRet;
    }
    return hr;
}


/***
*HRESULT CEnumPoint::Skip(unsigned long)
*Purpose:
*  Attempt to skip over the next 'celt' elements in the enumeration
*  sequence.
*
*Entry:
*  celt = the count of elements to skip
*
*Exit:
*  return value = HRESULT
*    S_OK
*    S_FALSE -  the end of the sequence was reached
*
***********************************************************************/
STDMETHODIMP
CImpIEnumCounter::Skip(
    IN  ULONG   cItems
    )
{
    m_uCurrent += cItems;

    if (m_uCurrent > m_cItems)
        m_uCurrent = m_cItems;

    return (m_uCurrent == m_cItems) ? S_FALSE : S_OK;
}


/***
*HRESULT CEnumPoint::Reset(void)
*Purpose:
*  Reset the enumeration sequence back to the beginning.
*
*Entry:
*  None
*
*Exit:
*  return value = SHRESULT CODE
*    S_OK
*
***********************************************************************/
STDMETHODIMP
CImpIEnumCounter::Reset(
    VOID
    )
{
    m_uCurrent = 0;

    return S_OK; 
}


/***
*HRESULT CEnumPoint::Clone(IEnumVARIANT**)
*Purpose:
*  Retrun a CPoint enumerator with exactly the same state as the
*  current one.
*
*Entry:
*  None
*
*Exit:
*  return value = HRESULT
*    S_OK
*    E_OUTOFMEMORY
*
***********************************************************************/
STDMETHODIMP
CImpIEnumCounter::Clone (
    OUT IEnumVARIANT **ppEnum
    )
{
    HRESULT hr = E_POINTER;
    ULONG   i;
    CImpIEnumCounter *pNewEnum;

    if ( NULL != ppEnum ) {
        *ppEnum = NULL;

        // Create new enumerator
        pNewEnum = new CImpIEnumCounter;
        if ( NULL != pNewEnum ) {
            // Init, copy item list and current position
            pNewEnum->m_cItems = m_cItems;
            pNewEnum->m_uCurrent = m_uCurrent;
            pNewEnum->m_paGraphItem = (PCGraphItem*)malloc(sizeof(PCGraphItem) * m_cItems);

            if ( NULL != pNewEnum->m_paGraphItem ) {
                for (i=0; i<m_cItems; i++) {
                    pNewEnum->m_paGraphItem[i] = m_paGraphItem[i];
                }

                *ppEnum = pNewEnum;
                hr = NOERROR;
            } else {
                delete pNewEnum;
                hr = E_OUTOFMEMORY;
            }
        } else {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\fostrwnd.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    fostrwnd.cpp

Abstract:

    <abstract>

--*/

#include "Polyline.h"

TCHAR   szFosterClassName[] = TEXT("FosterWndClass") ;

LRESULT APIENTRY FosterWndProc(HWND hWnd, UINT iMsg,
                            WPARAM wParam, LPARAM lParam)
{
    return DefWindowProc (hWnd, iMsg, wParam, lParam) ;
}



HWND CreateFosterWnd (
    VOID
    )
{

WNDCLASS    wc ;
HWND        hWnd;

    BEGIN_CRITICAL_SECTION

    if (pstrRegisteredClasses[FOSTER_WNDCLASS] == NULL) {
        wc.style         = 0;
        wc.lpfnWndProc   = (WNDPROC) FosterWndProc ;
        wc.hInstance     = g_hInstance;
        wc.cbClsExtra    = 0 ;
        wc.cbWndExtra    = 0;
        wc.hIcon         = NULL ;
        wc.hCursor       = NULL ;
        wc.hbrBackground = NULL ;
        wc.lpszMenuName  = NULL ;
        wc.lpszClassName = szFosterClassName ;

        if (RegisterClass (&wc)) {
           pstrRegisteredClasses[FOSTER_WNDCLASS] = szFosterClassName;
        }
    }

    END_CRITICAL_SECTION

    hWnd = (HWND)NULL;

    if (pstrRegisteredClasses[FOSTER_WNDCLASS] != NULL)
        {
        hWnd = CreateWindow (szFosterClassName,     // window class
                    NULL,                          // window caption
                    WS_DISABLED | WS_POPUP,        // window style
                    0, 0, 0, 0,                 // window size and pos
                    NULL,                           // parent window
                    NULL,                          // menu
                    g_hInstance,                    // program instance
                    NULL) ;                         // user-supplied data
        }

    return hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\globals.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    globals.h

Abstract:

    <abstract>

--*/

#ifndef _GLOBALS_H_
#define _GLOBALS_H_

#ifdef DEFINE_GLOBALS
  #define GLOBAL   
#else
  #define GLOBAL extern
#endif

GLOBAL  CRITICAL_SECTION	g_CriticalSection;
#define BEGIN_CRITICAL_SECTION	EnterCriticalSection(&g_CriticalSection);
#define END_CRITICAL_SECTION	LeaveCriticalSection(&g_CriticalSection);

GLOBAL  HINSTANCE   g_hInstance;
GLOBAL	LONG		g_cObj;
GLOBAL	LONG		g_cLock;
GLOBAL	 HWND		g_hWndFoster ;
	
enum {
	FOSTER_WNDCLASS = 0,
	HATCH_WNDCLASS,
	SYSMONCTRL_WNDCLASS,
	LEGEND_WNDCLASS,
    REPORT_WNDCLASS,
	INTRVBAR_WNDCLASS,
	TIMERANGE_WNDCLASS
};

#define MAX_WINDOW_CLASSES  7

GLOBAL	 LPTSTR	  pstrRegisteredClasses[MAX_WINDOW_CLASSES];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\graph.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    graph.h

Abstract:

    <abstract>

--*/


#ifndef _GRAPH_H_
#define _GRAPH_H_

#include <pdh.h>
#include "scale.h"
#include "stepper.h"
#include "cntrtree.h"

#define MAX_GRAPH_SAMPLES       100
#define MAX_GRAPH_ITEMS         8

#define LINE_GRAPH          ((DWORD)sysmonLineGraph) 
#define BAR_GRAPH           ((DWORD)sysmonHistogram)
#define REPORT_GRAPH        ((DWORD)sysmonReport)

#define NULL_COLOR          0xffffffff
#define NULL_APPEARANCE     0xffffffff
#define NULL_BORDERSTYLE    0xffffffff
#define NULL_FONT           0xffffffff

typedef struct _graph_options {
    LPTSTR  pszYaxisTitle ;
    LPTSTR  pszGraphTitle ;
    LPTSTR  pszLogFile ;
    INT     iVertMax ;
    INT     iVertMin ;
    INT     iDisplayFilter ;
    INT     iDisplayType ;
    INT     iAppearance;
    INT     iBorderStyle;
    INT     iReportValueType;
    INT     iDataSourceType;
    OLE_COLOR   clrBackCtl ;
    OLE_COLOR   clrFore ;
    OLE_COLOR   clrBackPlot ;
    OLE_COLOR   clrGrid ;
    OLE_COLOR   clrTimeBar ;
    FLOAT   fUpdateInterval ;
    BOOL    bLegendChecked ;
    BOOL    bToolbarChecked;
    BOOL    bLabelsChecked;
    BOOL    bVertGridChecked ;
    BOOL    bHorzGridChecked ;
    BOOL    bValueBarChecked ;
    BOOL    bManualUpdate;
    BOOL    bHighlight;
    BOOL    bReadOnly;
    BOOL    bMonitorDuplicateInstances;
    BOOL    bAmbientFont;
    } GRAPH_OPTIONS, *PGRAPH_OPTIONS;

typedef struct _hist_control {
    BOOL    bLogSource;
    INT     nMaxSamples;
    INT     nSamples;
    INT     iCurrent;
    INT     nBacklog;
    } HIST_CONTROL, *PHIST_CONTROL;

//All graph data
typedef struct _GRAPHDATA {
    GRAPH_OPTIONS   Options;
    HIST_CONTROL    History;
    CStepper        TimeStepper;
    CStepper        LogViewStartStepper;    // Set in smonctrl.cpp, read in grphdsp.cpp
    CStepper        LogViewStopStepper;     // Set in smonctrl.cpp, read in grphdsp.cpp
    LONGLONG        LogViewTempStart;       // MIN_TIME_VALUE means LogViewStartStepper invalid
    LONGLONG        LogViewTempStop;        // MAX_TIME_VALUE means LogViewStopStepper invalid
    CGraphScale     Scale;
    HQUERY          hQuery;
    class CCounterTree  CounterTree;
} GRAPHDATA, *PGRAPHDATA;


void UpdateGraphCounterValues(PGRAPHDATA, BOOL* );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\genprop.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    genprop.h

Abstract:

    Header file for the general property page.

--*/

#ifndef _GENPROP_H_
#define _GENPROP_H_

#include "smonprop.h"

// Dialog Controls
#define IDD_GEN_PROPP_DLG       100
#define IDC_LEGEND              101
#define IDC_VALUEBAR            102
#define IDC_GALLERY_GRAPH       103
#define IDC_GALLERY_HISTOGRAM   (IDC_GALLERY_GRAPH+1)
#define IDC_GALLERY_REPORT      (IDC_GALLERY_HISTOGRAM+1)
#define IDC_PERIODIC_UPDATE     106
#define IDC_UPDATE_INTERVAL     107
#define IDC_INTERVAL_LABEL      108
#define IDC_TOOLBAR             109
#define IDC_APPEARANCE          110
#define IDC_BORDERSTYLE         111
#define IDC_COMBOAPPEARANCE     112
#define IDC_COMBOBORDERSTYLE    113
#define IDC_GROUPUPDATE         114
#define IDC_DUPLICATE_INSTANCE  115
#define IDC_GROUPREPORTVALUE    116
#define IDC_DISPLAY_INTERVAL    117
#define IDC_DISPLAY_INT_LABEL1  118
#define IDC_DISPLAY_INT_LABEL2  119

#define IDC_RPT_VALUE_DEFAULT   120
#define IDC_RPT_VALUE_CURRENT   (IDC_RPT_VALUE_DEFAULT+1)
#define IDC_RPT_VALUE_AVERAGE   (IDC_RPT_VALUE_CURRENT+1)
#define IDC_RPT_VALUE_MINIMUM   (IDC_RPT_VALUE_AVERAGE+1)
#define IDC_RPT_VALUE_MAXIMUM   (IDC_RPT_VALUE_MINIMUM+1)

#define MAX_INTERVAL_DIGITS 7
// MAX_UPDATE_INTERVAL is 45 days (60*60*24*45)
#define MAX_UPDATE_INTERVAL 3888000 
#define MIN_UPDATE_INTERVAL 1

// General property page class
class CGeneralPropPage : public CSysmonPropPage
{
    public:
                CGeneralPropPage(void);
        virtual ~CGeneralPropPage(void);

    protected:

        virtual BOOL GetProperties(void);   //Read current properties
        virtual BOOL SetProperties(void);   //Set new properties
        virtual void DialogItemChange(WORD wId, WORD wMsg); // Handle item change
        virtual BOOL InitControls(void);   // Init dialog controls  

    private:

        // Properties
        VARIANT_BOOL            m_bLegend ;
        VARIANT_BOOL            m_bValueBar ;
        VARIANT_BOOL            m_bToolbar;
        VARIANT_BOOL            m_bManualUpdate;
        VARIANT_BOOL            m_bMonitorDuplicateInstances ;
        INT                     m_iDisplayInterval ;
        INT                     m_iAppearance;
        INT                     m_iBorderStyle;
        DisplayTypeConstants    m_eDisplayType ;
        ReportValueTypeConstants    m_eReportValueType ;
        FLOAT                   m_fSampleInterval ;

        // Property change flags
        BOOL    m_bLegendChg ;
        BOOL    m_bToolbarChg;
        BOOL    m_bValueBarChg ;
        BOOL    m_bManualUpdateChg;
        BOOL    m_bSampleIntervalChg ;
        BOOL    m_bDisplayIntervalChg ;
        BOOL    m_bDisplayTypeChg ;
        BOOL    m_bReportValueTypeChg ;
        BOOL    m_bAppearanceChg;
        BOOL    m_bBorderStyleChg;
        BOOL    m_bMonitorDuplicateInstancesChg;

        // Error flags
        INT     m_iErrSampleInterval;
        INT     m_iErrDisplayInterval;


};
typedef CGeneralPropPage *PCGeneralPropPage;

// {C3E5D3D2-1A03-11cf-942D-008029004347}
DEFINE_GUID(CLSID_GeneralPropPage, 
        0xc3e5d3d2, 0x1a03, 0x11cf, 0x94, 0x2d, 0x0, 0x80, 0x29, 0x0, 0x43, 0x47);

#endif //_GENPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\dispatch.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    dispatch.cpp

Abstract:

    <abstract>

--*/

#include "polyline.h"
#include "unkhlpr.h"

extern ITypeLib    *g_pITypeLib;
extern DWORD        g_dwScriptPolicy;


//IDispatch interface implementation
IMPLEMENT_CONTAINED_INTERFACE(IUnknown, CImpIDispatch)

/*
 * CImpIDispatch::GetTypeInfoCount
 * CImpIDispatch::GetTypeInfo
 * CImpIDispatch::GetIDsOfNames
 *
 * The usual
 */

void CImpIDispatch::SetInterface(REFIID riid, LPUNKNOWN pIUnk)
    {
        m_DIID = riid;
        m_pInterface = pIUnk;
    }

STDMETHODIMP CImpIDispatch::GetTypeInfoCount(UINT *pctInfo)
    {
    //We implement GetTypeInfo so return 1
    *pctInfo=1;
    return NOERROR;
    }


STDMETHODIMP CImpIDispatch::GetTypeInfo(UINT itInfo, LCID /* lcid */
    , ITypeInfo **ppITypeInfo)
    {
    if (0!=itInfo)
        return ResultFromScode(TYPE_E_ELEMENTNOTFOUND);

    if (NULL==ppITypeInfo)
        return ResultFromScode(E_POINTER);

    *ppITypeInfo=NULL;

    //We ignore the LCID
    return g_pITypeLib->GetTypeInfoOfGuid(m_DIID, ppITypeInfo);
    }


STDMETHODIMP CImpIDispatch::GetIDsOfNames(REFIID riid
    , OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)
    {
    HRESULT     hr;
    ITypeInfo  *pTI;

    if (IID_NULL!=riid)
        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

    hr=GetTypeInfo(0, lcid, &pTI);

    if (SUCCEEDED(hr))
        {
        hr = DispGetIDsOfNames(pTI, rgszNames, cNames, rgDispID);
        pTI->Release();
        }

    return hr;
    }



/*
 * CImpIDispatch::Invoke
 *
 * Purpose:
 *  Calls a method in the dispatch interface or manipulates a
 *  property.
 *
 * Parameters:
 *  dispID          DISPID of the method or property of interest.
 *  riid            REFIID reserved, must be IID_NULL.
 *  lcid            LCID of the locale.
 *  wFlags          USHORT describing the context of the invocation.
 *  pDispParams     DISPPARAMS * to the array of arguments.
 *  pVarResult      VARIANT * in which to store the result.  Is
 *                  NULL if the caller is not interested.
 *  pExcepInfo      EXCEPINFO * to exception information.
 *  puArgErr        UINT * in which to store the index of an
 *                  invalid parameter if DISP_E_TYPEMISMATCH
 *                  is returned.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */

STDMETHODIMP CImpIDispatch::Invoke(DISPID dispID, REFIID riid
    , LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams
    , VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
    {
    HRESULT     hr;
    ITypeInfo  *pTI;

    //riid is supposed to be IID_NULL always
    if (IID_NULL != riid)
        return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

    if (g_dwScriptPolicy == URLPOLICY_DISALLOW) {

        if (m_DIID == DIID_DISystemMonitor)
            return E_ACCESSDENIED;
    }

    // if dispatching to the graph control, use our internal interface
    // that is generated from the direct interface (see smonctrl.odl)
    if (m_DIID == DIID_DISystemMonitor)
        hr = g_pITypeLib->GetTypeInfoOfGuid(DIID_DISystemMonitorInternal, &pTI);
    else
        hr = GetTypeInfo(0, lcid, &pTI);

    if (FAILED(hr))
        return hr;

    hr = pTI->Invoke(m_pInterface, dispID, wFlags
        , pDispParams, pVarResult, pExcepInfo, puArgErr);

    pTI->Release();
    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\grphdsp.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    grphdsp.cpp

Abstract:

    <abstract>

--*/

#include "polyline.h"
#include "winhelpr.h"
#include <assert.h>
#include <limits.h>

#define ThreeDPad   1
#define BORDER  ThreeDPad
#define TEXT_MARGIN (ThreeDPad + 2)

static HPEN hPenWhite;
static HPEN hPenBlack;

INT
CGraphDisp::RGBToLightness ( COLORREF clrValue )
{
    INT iLightness;
    INT iRed;
    INT iGreen;
    INT iBlue;
    INT iMax;
    INT iMin;

    // The complete algorithm for computing lightness is:
    // Lightness = (Max(R,G,B)+ Min(R,G,B))/2*225.
    // Only need to compute enought to determine whether to draw black or white highlight.

    iRed = GetRValue( clrValue );
    iGreen = GetGValue (clrValue );
    iBlue = GetBValue (clrValue );

    if ( iRed > iGreen ) {
        iMax = iRed;
        iMin = iGreen;
    } else {
        iMax = iGreen;
        iMin = iRed;
    }

    if ( iBlue > iMax ) {
        iMax = iBlue;
    } else if ( iBlue < iMin ) {
        iMin = iBlue;
    }

    iLightness = iMin + iMax;

    return iLightness;
}

CGraphDisp::CGraphDisp ( void )
:   m_pCtrl ( NULL ),
    m_pGraph ( NULL ),
    m_pHiliteItem ( NULL ),
    m_hFontVertical ( NULL ),
    m_bBarConfigChanged ( TRUE )
{
}

CGraphDisp::~CGraphDisp ( void )
{
    if (m_hFontVertical != NULL)
        DeleteObject(m_hFontVertical);

    if (m_hPenTimeBar != 0) {
        DeleteObject ( m_hPenTimeBar );
        m_hPenTimeBar = 0;
    }

    if (m_hPenGrid != 0) {
        DeleteObject ( m_hPenGrid );
        m_hPenGrid = 0;
    }
}

BOOL 
CGraphDisp::Init (
    CSysmonControl *pCtrl, 
    PGRAPHDATA pGraph  
    )
{
    BOOL bRetStatus = TRUE;

    m_pCtrl = pCtrl;
    m_pGraph = pGraph;

    m_clrCurrentGrid = m_pCtrl->clrGrid();
    m_clrCurrentTimeBar = m_pCtrl->clrTimeBar();

    // Create the highlight, timebar and grid pens.

    m_hPenTimeBar = CreatePen(PS_SOLID, 2, m_clrCurrentTimeBar );

    // if can't do it, use a stock object (this can't fail)
    if (m_hPenTimeBar == NULL)
        m_hPenTimeBar = (HPEN)GetStockObject(BLACK_PEN);

    m_hPenGrid = CreatePen(PS_SOLID, 1, m_clrCurrentGrid );

    // if can't do it, use a stock object (this can't fail)
    if (m_hPenGrid == NULL)
        m_hPenGrid = (HPEN)GetStockObject(BLACK_PEN);
    
    // Highlight pens are shared among all Sysmon instances.
    BEGIN_CRITICAL_SECTION

    if (hPenWhite == 0) { 
        hPenWhite = CreatePen(PS_SOLID, 3, RGB(255,255,255));   
        hPenBlack = CreatePen(PS_SOLID, 3, RGB(0,0,0));
    }

    END_CRITICAL_SECTION

    return bRetStatus;
}

void CGraphDisp::HiliteItem( PCGraphItem pItem )
{
    m_pHiliteItem = pItem;
}


VOID 
CGraphDisp::Draw( 
    HDC hDC,
    HDC hAttribDC,
    BOOL fMetafile, 
    BOOL fEntire,
    PRECT /* prcUpdate */ )
{
    
    RECT    rectFrame;
    RECT    rectTitle;
    CStepper    locStepper;
    DWORD   dwPrevLayout = 0;
    DWORD   dwNewLayout = 0;
 
    if ( ( m_rect.right > m_rect.left ) && ( m_rect.bottom > m_rect.top ) ) {

        if ( NULL != hDC ) {

            dwPrevLayout = GetLayout ( hDC );
            dwNewLayout = dwPrevLayout;

            if ( dwNewLayout & LAYOUT_RTL ) {
                dwNewLayout &= ~LAYOUT_RTL;
                SetLayout (hDC, dwNewLayout);
            }

            // Fill plot area
            Fill(hDC, m_pCtrl->clrBackPlot(), &m_rectPlot);

            rectFrame = m_rectPlot;
            // Draw 3D border around plot area
            if ( eAppear3D == m_pCtrl->Appearance() ) {
                InflateRect(&rectFrame,BORDER,BORDER);
                DrawEdge(hDC, &rectFrame, BDR_SUNKENOUTER, BF_RECT);
            }

            // Select colors for all text
            SetBkMode(hDC, TRANSPARENT);
            SetTextColor(hDC, m_pCtrl->clrFgnd());
    
            // Draw the scale
            if (m_pGraph->Options.bLabelsChecked) {
                SelectFont(hDC, m_pCtrl->Font()) ;
                m_pGraph->Scale.Draw(hDC);
            }

            // Draw the main title
            if (m_pGraph->Options.pszGraphTitle != NULL) {

                SelectFont(hDC, m_pCtrl->Font()) ;
                SetTextAlign(hDC, TA_TOP|TA_CENTER);
 
                rectTitle = rectFrame;
                rectTitle.top = m_rect.top;
                FitTextOut( 
                    hDC,
                    hAttribDC,
                    0,
                    &rectTitle,
                    m_pGraph->Options.pszGraphTitle, 
                    lstrlen(m_pGraph->Options.pszGraphTitle),
                    TA_CENTER,
                    FALSE );
            }

            // Draw the Y axis title
            if (m_pGraph->Options.pszYaxisTitle != NULL && m_hFontVertical != NULL) {
                SelectFont(hDC, m_hFontVertical) ;
                SetTextAlign(hDC, TA_TOP|TA_CENTER);

                rectTitle = rectFrame;
                rectTitle.left = m_rect.left;
                FitTextOut( 
                    hDC, 
                    hAttribDC, 
                    0,
                    &rectTitle,
                    m_pGraph->Options.pszYaxisTitle,
                    lstrlen(m_pGraph->Options.pszYaxisTitle),
                    TA_CENTER,
                    TRUE);
            }

            // setup stepper reset to start
            locStepper = m_pGraph->TimeStepper;
            locStepper.Reset();

            // Set clipping area.  Fill executed above, so bFill= FALSE.
            StartUpdate(hDC, fMetafile, fEntire, 0, (m_rectPlot.right - m_rectPlot.left), FALSE );

            // draw the grid lines
            DrawGrid(hDC, 0, m_rectPlot.right - m_rectPlot.left);

            m_pCtrl->LockCounterData();

            switch (m_pGraph->Options.iDisplayType) {

                case LINE_GRAPH: 

                    // Finish and restart update so that wide lines are cropped at the timeline.
                    FinishUpdate(hDC, fMetafile);

                    StartUpdate(
                        hDC, 
                        fMetafile, 
                        FALSE, 
                        0, 
                        m_pGraph->TimeStepper.Position(),
                        FALSE );
           
                    // Plot points from start of graph to time line 
                    PlotData(hDC, m_pGraph->TimeStepper.StepNum() + m_pGraph->History.nBacklog,
                             m_pGraph->TimeStepper.StepNum(), &locStepper);

                    FinishUpdate(hDC, fMetafile);

                    // Plot points from time line to end of graph
                    locStepper = m_pGraph->TimeStepper;

                    // Restart update. Left-hand ends and internal gaps of wide lines are not cropped.
                    StartUpdate(
                        hDC, 
                        fMetafile, 
                        FALSE, 
                        locStepper.Position(), 
                        m_rectPlot.right - m_rectPlot.left,
                        FALSE );

                    PlotData(hDC, m_pGraph->TimeStepper.StepCount() + m_pGraph->History.nBacklog,  
                             m_pGraph->TimeStepper.StepCount() - m_pGraph->TimeStepper.StepNum(),
                             &locStepper);

                    DrawTimeLine(hDC, m_pGraph->TimeStepper.Position());

                    if ( MIN_TIME_VALUE != m_pGraph->LogViewTempStart ) 
                        DrawStartStopLine(hDC, m_pGraph->LogViewStartStepper.Position());
                    if ( MAX_TIME_VALUE != m_pGraph->LogViewTempStop ) 
                        DrawStartStopLine(hDC, m_pGraph->LogViewStopStepper.Position());
                    break;

                case BAR_GRAPH:
                    PlotBarGraph(hDC, FALSE);
                    break;
            }

            FinishUpdate(hDC, fMetafile);

            if ( dwNewLayout != dwPrevLayout ) {
                SetLayout (hDC, dwPrevLayout);
            }

            m_pCtrl->UnlockCounterData();
        }
    }
}




VOID 
CGraphDisp::UpdateTimeBar( 
    HDC hDC,
    BOOL bPlotData )
{
    INT     nBacklog;
    INT     iUpdateCnt;
    INT     i;
    CStepper    locStepper;

    nBacklog = m_pGraph->History.nBacklog;

    // Work off backlogged sample intervals
    while ( nBacklog > 0) {

        // If we are going to wrap around, update in two steps
        if (nBacklog > m_pGraph->TimeStepper.StepCount() 
                            - m_pGraph->TimeStepper.StepNum()) {
            iUpdateCnt = m_pGraph->TimeStepper.StepCount() 
                            - m_pGraph->TimeStepper.StepNum();
        } else {
            iUpdateCnt = nBacklog;
        }

        // step to position of current data 
        locStepper = m_pGraph->TimeStepper;
        for (i=0; i<iUpdateCnt; i++) 
            m_pGraph->TimeStepper.NextPosition();

        if ( bPlotData ) {
            StartUpdate(
                hDC, 
                FALSE, 
                FALSE, 
                locStepper.Position(), 
                m_pGraph->TimeStepper.Position(),
                TRUE );

            DrawGrid(hDC, locStepper.Position(), m_pGraph->TimeStepper.Position());

            PlotData(hDC, nBacklog, iUpdateCnt, &locStepper);

            FinishUpdate ( hDC, FALSE );
        }

        if (m_pGraph->TimeStepper.StepNum() >= m_pGraph->TimeStepper.StepCount())
            m_pGraph->TimeStepper.Reset();

        nBacklog -= iUpdateCnt;
    }

    if ( bPlotData ) {
        DrawTimeLine(hDC, m_pGraph->TimeStepper.Position());    
    }
    
    m_pGraph->History.nBacklog = 0;
}

VOID 
CGraphDisp::Update( HDC hDC )
{
    DWORD   dwPrevLayout = 0;
    DWORD   dwNewLayout = 0;

    m_pCtrl->LockCounterData();

    if ( NULL != hDC ) {

        dwPrevLayout = GetLayout ( hDC );
        dwNewLayout = dwPrevLayout;

        if ( dwNewLayout & LAYOUT_RTL ) {
            dwNewLayout &= ~LAYOUT_RTL;
            SetLayout (hDC, dwNewLayout);
        }

        if ( ( m_rect.right > m_rect.left ) && ( m_rect.bottom > m_rect.top ) ) {

            switch (m_pGraph->Options.iDisplayType) {

                case LINE_GRAPH: 
                    // Update the line graph and time bar based on history 
                    // backlog.  Reset history backlog to 0, signalling collection
                    // thread to post another WM_GRAPH_UPDATE message.
                    UpdateTimeBar ( hDC, TRUE );
                    break;

                case BAR_GRAPH:
                    PlotBarGraph(hDC, TRUE);
                    break;
            }
        }

        // If updating histogram or report, update thetimebar step based on 
        // history backlog.  Reset history backlog to 0, signalling collection
        // thread to post another WM_GRAPH_UPDATE message.
        UpdateTimeBar ( hDC, FALSE );
        if ( dwNewLayout != dwPrevLayout ) {
            SetLayout (hDC, dwPrevLayout);
        }
    }
    m_pCtrl->UnlockCounterData();
}



void 
CGraphDisp::StartUpdate(     
    HDC  hDC, 
    BOOL fMetafile,
    BOOL fEntire,
    INT  xLeft, 
    INT  xRight,
    BOOL bFill )
{
    RECT    rect;

    // Preserve clipping region

    if ( FALSE == fMetafile ) {
        
        m_rgnClipSave = CreateRectRgn(0,0,0,0);
        
        if (m_rgnClipSave != NULL) {
            if (GetClipRgn(hDC, m_rgnClipSave) != 1) {
                DeleteObject(m_rgnClipSave);
                m_rgnClipSave = NULL;
            }
        }

        xLeft += m_rectPlot.left;
        xRight += m_rectPlot.left;
        IntersectClipRect (
            hDC, 
            max ( m_rectPlot.left, xLeft ), 
            m_rectPlot.top,
            min (m_rectPlot.right, xRight + 1), // Extra pixel for TimeBar
            m_rectPlot.bottom ) ;

    } else if( TRUE == fEntire ){
        m_rgnClipSave = NULL;
        IntersectClipRect (
            hDC, 
            m_rectPlot.left, 
            m_rectPlot.top,
            m_rectPlot.right, 
            m_rectPlot.bottom ) ;
    }


    // Fill performed before this method for metafiles and complete draw.
    if ( !fMetafile && bFill ) {
        SetRect(
            &rect, 
            max ( m_rectPlot.left, xLeft - 1 ), 
            m_rectPlot.top - 1, 
            min (m_rectPlot.right, xRight + 1), 
            m_rectPlot.bottom);

        Fill(hDC, m_pCtrl->clrBackPlot(), &rect);
    }
}


void CGraphDisp::FinishUpdate( HDC hDC, BOOL fMetafile )
{
    // Restore saved clip region
    if ( !fMetafile ) {

        if (m_rgnClipSave != NULL) {
            SelectClipRgn(hDC, m_rgnClipSave);
            DeleteObject(m_rgnClipSave);
            m_rgnClipSave = NULL;
        }
    }
}


void CGraphDisp::DrawGrid(HDC hDC, INT xLeft, INT xRight)
{
    INT xPos;
    INT nTics;
    INT *piScaleTic;
    INT i;


    if ( (m_pGraph->Options.bVertGridChecked)
        || (m_pGraph->Options.bHorzGridChecked) ) {

        if ( m_clrCurrentGrid != m_pCtrl->clrGrid() ) {

            m_clrCurrentGrid = m_pCtrl->clrGrid();

            DeleteObject ( m_hPenGrid );

            m_hPenGrid = CreatePen(PS_SOLID, 1, m_clrCurrentGrid );

            // if can't do it, use a stock object (this can't fail)
            if (m_hPenGrid == NULL)
                m_hPenGrid = (HPEN)GetStockObject(BLACK_PEN);
        }
    }

    if (m_pGraph->Options.bVertGridChecked) {

        SelectObject(hDC, m_hPenGrid);

        m_GridStepper.Reset();
        xPos = m_GridStepper.NextPosition();

        while (xPos < xLeft)
            xPos =m_GridStepper.NextPosition();

        while (xPos < xRight) {
            MoveToEx(hDC, xPos + m_rectPlot.left, m_rectPlot.bottom, NULL);
            LineTo(hDC, xPos + m_rectPlot.left, m_rectPlot.top - 1);
            xPos = m_GridStepper.NextPosition();
        }
    }

    if (m_pGraph->Options.bHorzGridChecked) {
        xLeft += m_rectPlot.left;
        xRight += m_rectPlot.left;

        SelectObject(hDC,m_hPenGrid);

        nTics = m_pGraph->Scale.GetTicPositions(&piScaleTic);

        for (i=1; i<nTics; i++) {
            MoveToEx(hDC, xLeft, m_rectPlot.top + piScaleTic[i], NULL);
            LineTo(hDC, xRight + 1, m_rectPlot.top + piScaleTic[i]);
        }
    }
}
    
BOOL 
CGraphDisp::CalcYPosition (
    PCGraphItem pItem, 
    INT iHistIndex,
    BOOL bLog, 
    INT y[3] )
{
    BOOL        bReturn;    // True = good, False = bad.
    PDH_STATUS  stat;   
    DWORD       dwCtrStat;
    double      dValue[3];
    double      dTemp;
    INT         iVal;
    INT         nVals = bLog ? 3 : 1;

    if (bLog)
        stat = pItem->GetLogEntry(iHistIndex, &dValue[1], &dValue[2], &dValue[0], &dwCtrStat);
    else
        stat = pItem->HistoryValue(iHistIndex, &dValue[0], &dwCtrStat);

    if (ERROR_SUCCESS == stat && IsSuccessSeverity(dwCtrStat)) {

        for (iVal = 0; iVal < nVals; iVal++) {

            dTemp = dValue[iVal] * pItem->Scale();

            if (dTemp > m_dMax)
                dTemp = m_dMax;
            else if (dTemp < m_dMin)
                dTemp = m_dMin;

            // Plot minimum value as 1 pixel above the bottom of the plot area, since
            // clipping and fill regions crop the bottom and right pixels.
            y[iVal] = m_rectPlot.bottom - (INT)((dTemp - m_dMin) * m_dPixelScale);
            if ( y[iVal] == m_rectPlot.bottom ) {
                y[iVal] = m_rectPlot.bottom - 1;
            }
        }
        bReturn = TRUE;
    } else {
        bReturn = FALSE;
    }

    return bReturn;
}

void CGraphDisp::PlotData(HDC hDC, INT iHistIndx, INT nSteps, CStepper *pStepper)
{
    INT         i;
    INT         x;
    INT         y[3];
    PCGraphItem pItem;
    CStepper    locStepper;
    BOOL        bSkip;
    BOOL        bPrevGood;
    BOOL        bLog;
    BOOL        bLogMultiVal;

    if (m_pGraph->Options.iVertMax <= m_pGraph->Options.iVertMin)
        return;

    bSkip = TRUE;

    bLog = m_pCtrl->IsLogSource();
    bLogMultiVal = bLog && !DisplaySingleLogSampleValue();

    // If possible, back up to redraw previous segment
    if (pStepper->StepNum() > 0) {
        iHistIndx++;
        nSteps++;
        pStepper->PrevPosition();
    }

    // Set background color, in case of dashed lines
    SetBkMode(hDC, TRANSPARENT);

    pItem = m_pCtrl->FirstCounter();
    while (pItem != NULL) {
        locStepper = *pStepper;

        // Skip hilited item the first time
        if (!(pItem == m_pHiliteItem && bSkip)) {
            INT     iPolyIndex = 0;
            POINT   arrptDataPoints[MAX_GRAPH_SAMPLES] ;

            if ( pItem == m_pHiliteItem) {
                // Arbitrary 450 (out of 510) chosen as cutoff for white vs. black
                if ( 450 > RGBToLightness( m_pCtrl->clrBackPlot() ) )
                    SelectObject(hDC, hPenWhite);
                else
                    SelectObject(hDC, hPenBlack);
            } else {
                SelectObject(hDC,pItem->Pen());
            }

            bPrevGood = FALSE;

            //  For each GOOD current value:
            //      If the previous value is good, draw line from previous value to current value.  
            //      If the previous value is bad, MoveTo the current value point.
            //
            //      For the first step, the previous value is false by definition, so the first operation
            //      is a MoveTo.

            //
            //  Polyline code:
            //  For each GOOD current value:
            //      Add the current (good) point to the polyline point array.
            //  For each BAD current value:
            //      If the polyline index is > 1 (2 points), draw the polyline and reset the polyline index to 0.
            //  After all values:
            //      If the polyline index is > 1 (2 points), draw the polyline.

            for (i = 0; i <= nSteps; i++) {

                // True = Good current value
                if ( CalcYPosition ( pItem, iHistIndx - i, bLog, y ) ) {

                    x = m_rectPlot.left + locStepper.Position();

                    // Add point to polyline, since the current value is good.
                    arrptDataPoints[iPolyIndex].x = x;
                    arrptDataPoints[iPolyIndex].y = y[0];
                    iPolyIndex++;

                    // No polyline optimization for extra Max and Min log points.
                    if (bLogMultiVal) {
                        MoveToEx(hDC, x, y[1], NULL);
                        LineTo(hDC, x, y[2]);
                        MoveToEx(hDC, x, y[0], NULL);
                    }

                    bPrevGood = TRUE;
                
                } else {
                    // Current value is not good.
                    bPrevGood = FALSE;

                    // Current value is not good, so don't add to polyline point array.
                    if ( iPolyIndex > 1 ) {
                        // Draw polyline for any existing good points.
                        Polyline(hDC, arrptDataPoints, iPolyIndex) ;
                    }
                    // Reset polyline point index to 0.
                    iPolyIndex = 0;
                }

                locStepper.NextPosition();
            }

            // Draw the final line.
            if ( iPolyIndex > 1 ) {
                // Draw polyline
                Polyline(hDC, arrptDataPoints, iPolyIndex) ;
            }

            // Exit loop after plotting hilited item
            if (pItem == m_pHiliteItem)
                break;
            }
  
        pItem = pItem->Next();

        // After last item, go back to highlighted item 
        if (pItem == NULL) {
            pItem = m_pHiliteItem;
            bSkip = FALSE;
        }
    }
}

void CGraphDisp::PlotBarGraph(HDC hDC, BOOL fUpdate)
{

    if ( (m_pGraph->CounterTree.NumCounters() > 0 ) 
        && (m_pGraph->Options.iVertMax > m_pGraph->Options.iVertMin) ) {

        CStepper    BarStepper;
        PCGraphItem pItem;
        RECT        rectBar;
        INT         iValue,iPrevValue;
        HRESULT     hr;
        LONG        lCtrStat;
        double      dValue = 0.0;
        double      dMax;
        double      dMin;
        double      dAvg;
        double      dTemp;
        HRGN        hrgnRedraw,hrgnTemp;
        eReportValueTypeConstant eValueType;            
        BOOL        bLog;
        INT         iNumCounters = m_pGraph->CounterTree.NumCounters();
        BOOL        bSkip = TRUE;
        INT         iHighlightStepNum = 0;
        BOOL        bLocalUpdate;
        HANDLE      hPenSave;

        bLocalUpdate = fUpdate;

        hrgnRedraw = NULL;

        eValueType = m_pCtrl->ReportValueType();
       
        // Todo:  Move DisplaySingleLogSampleValue() to CSystemMonitor.
        bLog = m_pCtrl->IsLogSource();

        // Force total redraw if the number of counters has changed in case 
        // Update is called immediately after. 
        if ( m_bBarConfigChanged ) {
            SetBarConfigChanged ( FALSE );
            if ( bLocalUpdate ) {
                bLocalUpdate = FALSE;
           }
           // Clear and fill the entire plot region.
           hrgnRedraw = CreateRectRgn(
                            m_rectPlot.left, 
                            m_rectPlot.top, 
                            m_rectPlot.right, 
                            m_rectPlot.bottom);

           if (hrgnRedraw) {
                SelectClipRgn(hDC, hrgnRedraw);
                Fill(hDC, m_pCtrl->clrBackPlot(), &m_rectPlot);
                DrawGrid(hDC, 0, (m_rectPlot.right - m_rectPlot.left));
                DeleteObject(hrgnRedraw);
                hrgnRedraw = NULL;
            }
        }

        // Intialize stepper for number of bars to plot
        BarStepper.Init ( ( m_rectPlot.right - m_rectPlot.left), iNumCounters );

        hPenSave = SelectPen ( hDC, GetStockObject(NULL_PEN) );

        // Do for all counters
        pItem = m_pGraph->CounterTree.FirstCounter();
        while ( NULL != pItem ) {

            hr = ERROR_SUCCESS;

            // Skip highlighted item the first time through

            if (!(pItem == m_pHiliteItem && bSkip)) {

                // Get display value
                if ( sysmonDefaultValue == eValueType  ) {
                    if (bLog) {
                        hr = pItem->GetStatistics(&dMax, &dMin, &dAvg, &lCtrStat);
                    } else
                        hr = pItem->GetValue(&dValue, &lCtrStat);
                } else {

                    if ( sysmonCurrentValue == eValueType  ) {
                        hr = pItem->GetValue(&dValue, &lCtrStat);
                    } else {
                        double      dAvg;

                        hr = pItem->GetStatistics(&dMax, &dMin, &dAvg, &lCtrStat);

                        switch ( eValueType ) {
    
                            case sysmonAverage:
                                dValue = dAvg;
                                break;
        
                            case sysmonMinimum:
                                dValue = dMin;
                                break;
        
                            case sysmonMaximum:
                                dValue = dMax;
                                break;

                            default:
                                assert (FALSE);
                        }
                    }
                }

                // Erase bar if the counter value is invalid.
                if (SUCCEEDED(hr) && IsSuccessSeverity(lCtrStat)) {
                    // Convert value to pixel units
                    dTemp = dValue * pItem->Scale();

                    if (dTemp > m_dMax)
                        dTemp = m_dMax;
                    else if (dTemp < m_dMin)
                        dTemp = m_dMin;

                    iValue = m_rectPlot.bottom - (INT)((dTemp - m_dMin) * m_dPixelScale);
                    if ( iValue == m_rectPlot.bottom ) {
                        // Draw single pixel for screen visibility.
                        iValue--;
                    }
                } else {
                    // The current value is 0. Draw single pixel for screen visibility.
                    iValue = m_rectPlot.bottom - 1;
                }

                if ( !bSkip ) {
                    assert ( pItem == m_pHiliteItem );
                    BarStepper.StepTo ( iHighlightStepNum );
                }

                // Setup left and right edges of bar
                rectBar.left = m_rectPlot.left + BarStepper.Position();
                rectBar.right = m_rectPlot.left + BarStepper.NextPosition();

                // If doing an update (never called for log sources) and not drawing the highlighted item
                if ( bLocalUpdate && !( ( pItem == m_pHiliteItem ) && !bSkip) ) {

                    assert ( !m_bBarConfigChanged );

                    // Get previous plot value
                    iPrevValue = 0;
                    hr = pItem->HistoryValue(1, &dValue, (ULONG*)&lCtrStat);
                    if (SUCCEEDED(hr) && IsSuccessSeverity(lCtrStat)) {

                        // Convert value to pixel units
                        dTemp = dValue * pItem->Scale();

                        if (dTemp > m_dMax)
                            dTemp = m_dMax;
                        else if (dTemp < m_dMin)
                            dTemp = m_dMin;

                        iPrevValue = m_rectPlot.bottom - (INT)((dTemp - m_dMin) * m_dPixelScale);
                        if ( iPrevValue == m_rectPlot.bottom ) {
                            // Single pixel was drawn for screen visibility.
                            iPrevValue--;
                        }
                    } else {
                        // The previous value was 0. Single pixel was drawn for screen visibility.
                        iPrevValue = m_rectPlot.bottom - 1;
                    }

                    // If bar has grown (smaller y coord)
                    if (iPrevValue > iValue) {

                        // Draw the new part
                        rectBar.bottom = iPrevValue;
                        rectBar.top = iValue;

                        if ( pItem == m_pHiliteItem) {
                            // Arbitrary 450 (out of 510) chosen as cutoff for white vs. black
                            if ( 450 > RGBToLightness( m_pCtrl->clrBackPlot() ) )
                                SelectBrush(hDC, GetStockObject(WHITE_BRUSH));
                            else
                                SelectBrush(hDC, GetStockObject(BLACK_BRUSH));
                        } else {
                            SelectBrush(hDC, pItem->Brush());
                        }
                        // Bars are drawn with Null pen, so bottom and right are cropped by 1 pixel.
                        // Add 1 pixel to compensate.
                        Rectangle(hDC, rectBar.left, rectBar.top, rectBar.right + 1, rectBar.bottom + 1);
    
                    } else if (iPrevValue < iValue) {
        
                        // Else if bar has shrunk

                        // Add part to be erased to redraw region
                        // Erase to the top of the grid, to eliminate random pixels left over.
                        rectBar.bottom = iValue;
                        rectBar.top = m_rectPlot.top;  // set to stop of grid rather than to prevValue

                        hrgnTemp = CreateRectRgn(rectBar.left, rectBar.top, rectBar.right, rectBar.bottom);
                        if (hrgnRedraw && hrgnTemp) {
                            CombineRgn(hrgnRedraw,hrgnRedraw,hrgnTemp,RGN_OR);
                            DeleteObject(hrgnTemp);
                        } else {
                            hrgnRedraw = hrgnTemp;
                        }
                    }
                } else {
                    // Erase and redraw complete bar

                    // Erase top first
                    // Add part to be erased to redraw region
                    // Erase to the top of the grid, to eliminate random pixels left over.
                    if ( iValue != m_rectPlot.top ) {
                        rectBar.bottom = iValue;
                        rectBar.top = m_rectPlot.top;  // set to stop of grid rather than to prevValue

                        hrgnTemp = CreateRectRgn(rectBar.left, rectBar.top, rectBar.right, rectBar.bottom);
                        if (hrgnRedraw && hrgnTemp) {
                            CombineRgn(hrgnRedraw,hrgnRedraw,hrgnTemp,RGN_OR);
                            DeleteObject(hrgnTemp);
                        } else {
                            hrgnRedraw = hrgnTemp;
                        }
                    }

                    // Then draw the bar.
                    rectBar.bottom = m_rectPlot.bottom;
                    rectBar.top = iValue;

                    if ( pItem == m_pHiliteItem) {
                        // Arbitrary 450 (out of 510) chosen as cutoff for white vs. black
                        if ( 450 > RGBToLightness( m_pCtrl->clrBackPlot() ) )
                            SelectBrush(hDC, GetStockObject(WHITE_BRUSH));
                        else
                            SelectBrush(hDC, GetStockObject(BLACK_BRUSH));
                    } else {
                        SelectBrush(hDC, pItem->Brush());
                    }
                    // Bars are drawn with Null pen, so bottom and right are cropped by 1 pixel.
                    // Add 1 pixel to compensate.
                    Rectangle(hDC, rectBar.left, rectBar.top, rectBar.right + 1, rectBar.bottom + 1);
                } // Update

                // Exit loop after plotting highlighted item
                if (pItem == m_pHiliteItem) 
                    break;

            } else {
                if ( bSkip ) {
                    // Save position of highlighted item the first time through
                    iHighlightStepNum = BarStepper.StepNum();
                }
                BarStepper.NextPosition();
            }

            pItem = pItem->Next();
           
            // After last item, go back to highlighted item 
            if ( NULL == pItem && NULL != m_pHiliteItem ) {
                pItem = m_pHiliteItem;
                bSkip = FALSE;
            }            

        } // Do for all counters

        // If redraw region accumulated, erase and draw grid lines
        if (hrgnRedraw) {
            SelectClipRgn(hDC, hrgnRedraw);
            Fill(hDC, m_pCtrl->clrBackPlot(), &m_rectPlot);
            DrawGrid(hDC, 0, (m_rectPlot.right - m_rectPlot.left));
            DeleteObject(hrgnRedraw);
        }
        SelectObject(hDC, hPenSave);
    }
}

     
void CGraphDisp::SizeComponents(HDC hDC, PRECT pRect)
{
    INT iStepNum;
    INT iScaleWidth;
    INT iTitleHeight;
    INT iAxisTitleWidth;
    RECT rectScale;
    SIZE size;
    INT  iWidth;
    INT  i;

    static INT aiWidthTable[] = {20,50,100,150,300,500,1000000};
    static INT aiTicTable[] = {0,2,4,5,10,20,25};

    m_rect = *pRect;

    // if no space, return
    if (m_rect.right <= m_rect.left || m_rect.bottom - m_rect.top <= 0)
        return;

    // For now use the horizontal font height for both horizontal and vertical text
    // because the GetTextExtentPoint32 is returning the wrong height for vertical text
    SelectFont(hDC, m_pCtrl->Font());
    GetTextExtentPoint32(hDC, TEXT("Sample"), 6, &size);

    if (m_pGraph->Options.pszGraphTitle != NULL) {
        //SelectFont(hDC, m_pCtrl->Font()) ;
        //GetTextExtentPoint32(hDC, m_pGraph->Options.pszGraphTitle, 
        //              lstrlen(m_pGraph->Options.pszGraphTitle), &size);
        iTitleHeight = size.cy + TEXT_MARGIN;
    } else
        iTitleHeight = 0;

    if (m_pGraph->Options.pszYaxisTitle != NULL && m_hFontVertical != NULL) {
        //SelectFont(hDC, m_hFontVertical);
        //GetTextExtentPoint32(hDC, m_pGraph->Options.pszYaxisTitle,
        //                  lstrlen(m_pGraph->Options.pszYaxisTitle), &size);
                        
        iAxisTitleWidth = size.cy + TEXT_MARGIN;
    } else
        iAxisTitleWidth = 0;
             
    if (m_pGraph->Options.bLabelsChecked) {
        //SelectFont(hDC, m_pCtrl->Font());
        iScaleWidth = m_pGraph->Scale.GetWidth(hDC);
    } else
        iScaleWidth = 0;

    SetRect(&rectScale, pRect->left + iAxisTitleWidth, 
                        pRect->top + iTitleHeight, 
                        pRect->left + iAxisTitleWidth + iScaleWidth, 
                        pRect->bottom);

    m_pGraph->Scale.SetRect(&rectScale);        // Just to set grid line positions

    SetRect(&m_rectPlot, pRect->left + iScaleWidth + iAxisTitleWidth + BORDER,
                            pRect->top + iTitleHeight + BORDER,
                            pRect->right - BORDER, 
                            pRect->bottom - BORDER);

    // Reinitialize steppers for new width
    iWidth = m_rectPlot.right - m_rectPlot.left;

    iStepNum = m_pGraph->TimeStepper.StepNum();
    m_pGraph->TimeStepper.Init(iWidth, m_pGraph->History.nMaxSamples - 2);
    m_pGraph->TimeStepper.StepTo(iStepNum);

    iStepNum = m_pGraph->LogViewStartStepper.StepNum();
    m_pGraph->LogViewStartStepper.Init(iWidth, m_pGraph->History.nMaxSamples - 2);
    m_pGraph->LogViewStartStepper.StepTo(iStepNum);

    iStepNum = m_pGraph->LogViewStopStepper.StepNum();
    m_pGraph->LogViewStopStepper.Init(iWidth, m_pGraph->History.nMaxSamples - 2);
    m_pGraph->LogViewStopStepper.StepTo(iStepNum);

    // Find best grid count for this width
    for (i=0; iWidth > aiWidthTable[i]; i++) {};

    m_GridStepper.Init(iWidth, aiTicTable[i]); 

    // Compute conversion factors for plot, hit test.
    m_dMin = (double)m_pGraph->Options.iVertMin;
    m_dMax = (double)m_pGraph->Options.iVertMax;

    m_dPixelScale = (double)(m_rectPlot.bottom - m_rectPlot.top) / (m_dMax - m_dMin);

}


void CGraphDisp::DrawTimeLine(HDC hDC, INT x)
{
    HPEN hPenSave;

    // No time line for log playback
    if (m_pCtrl->IsLogSource())
        return;

    x += m_rectPlot.left + 1;

    if ( m_clrCurrentTimeBar != m_pCtrl->clrTimeBar() ) {
        LOGBRUSH lbrush;

        m_clrCurrentTimeBar = m_pCtrl->clrTimeBar();

        DeleteObject ( m_hPenTimeBar );
    
        // When called from Update(), DrawTimeLine is called after the clipping region 
        // is deactivated. Create a geometric pen in order to specify flat end cap style.
        // This eliminates any extra pixels drawn at the end. 

        lbrush.lbStyle = BS_SOLID;
        lbrush.lbColor = m_clrCurrentTimeBar;
        lbrush.lbHatch = 0;

        m_hPenTimeBar = ExtCreatePen ( 
                            PS_GEOMETRIC | PS_SOLID | PS_ENDCAP_FLAT, 2, &lbrush, 0, NULL );

        // if can't do it, use a stock object (this can't fail)
        if (m_hPenTimeBar == NULL)
            m_hPenTimeBar = (HPEN)GetStockObject(BLACK_PEN);
    }

    hPenSave = SelectPen ( hDC, m_hPenTimeBar );
    MoveToEx ( hDC, x, m_rectPlot.top, NULL );

    // Specify 1 less pixel.  All fills and clip regions clip bottom and 
    // right pixels, so match their behavior.
    LineTo ( hDC, x, m_rectPlot.bottom - 1 );
    
    SelectObject(hDC, hPenSave);
}

void CGraphDisp::DrawStartStopLine(HDC hDC, INT x)
{
    HPEN hPenSave;

    // Log view start/stop lines only for log playback
    if (!m_pCtrl->IsLogSource())
        return;

    if ( x > 0 && x < ( m_rectPlot.right - m_rectPlot.left ) ) {
        x += m_rectPlot.left;

        if ( m_clrCurrentGrid != m_pCtrl->clrGrid() ) {

            m_clrCurrentGrid = m_pCtrl->clrGrid();

            DeleteObject ( m_hPenGrid );

            m_hPenGrid = CreatePen(PS_SOLID, 1, m_clrCurrentGrid );

            // if can't do it, use a stock object (this can't fail)
            if (m_hPenGrid == NULL)
                m_hPenGrid = (HPEN)GetStockObject(BLACK_PEN);
        }

        hPenSave = SelectPen(hDC, m_hPenGrid);
        MoveToEx(hDC, x, m_rectPlot.top, NULL);
        LineTo(hDC, x, m_rectPlot.bottom);
        
        SelectObject(hDC, hPenSave);
    }
}

void CGraphDisp::ChangeFont( HDC hDC )
{
    TEXTMETRIC  TextMetrics, newTextMetrics;
    LOGFONT     LogFont;
    HFONT       hFontOld;

    // Select the new font
    hFontOld = SelectFont(hDC, m_pCtrl->Font());

    // Get attributes
    GetTextMetrics(hDC, &TextMetrics);

    // Create LOGFONT for vertical font with same attributes
    LogFont.lfHeight = TextMetrics.tmHeight;
    LogFont.lfWidth = 0;
    LogFont.lfOrientation = LogFont.lfEscapement = 90*10;
    LogFont.lfWeight = TextMetrics.tmWeight;
    LogFont.lfStrikeOut = TextMetrics.tmStruckOut;
    LogFont.lfUnderline = TextMetrics.tmUnderlined;
    LogFont.lfItalic = TextMetrics.tmItalic;
    LogFont.lfCharSet = TextMetrics.tmCharSet;
    LogFont.lfPitchAndFamily = (BYTE)(TextMetrics.tmPitchAndFamily & 0xF0);

    GetTextFace(hDC, LF_FACESIZE, LogFont.lfFaceName);

    // Force a truetype font, because raster fonts can't rotate
    LogFont.lfOutPrecision = OUT_TT_ONLY_PRECIS;
    LogFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    LogFont.lfQuality = DEFAULT_QUALITY;

    // Release the current font
    if (m_hFontVertical != NULL)
        DeleteObject(m_hFontVertical);

    // Create the font and save handle locally
    m_hFontVertical = CreateFontIndirect(&LogFont);

    SelectFont(hDC, m_hFontVertical);
    GetTextMetrics(hDC, &newTextMetrics);

    SelectFont(hDC, hFontOld);
}

PCGraphItem 
CGraphDisp::GetItemInLineGraph ( SHORT xPos, SHORT yPos )
{
    PCGraphItem pItem = NULL;
    PCGraphItem pReturn = NULL;

    INT iPrevStepNum;
    POINT ptPrev;
    POINT ptNext;
    POINTS ptMouse;
    CStepper    locStepper;

    INT     iHistIndex;
    BOOL    bLog;
    BOOL    bLogMultiVal;
    BOOL    bFound = FALSE;

    INT yPosPrev[3];
    INT yPosNext[3];

    pItem = m_pCtrl->FirstCounter();
    bLog = m_pCtrl->IsLogSource();
    bLogMultiVal = bLog && !DisplaySingleLogSampleValue();

    // Items exist?
    if (pItem != NULL) {

        locStepper = m_pGraph->TimeStepper;
        locStepper.Reset();

        iPrevStepNum = locStepper.PrevStepNum(xPos - m_rectPlot.left);
        locStepper.StepTo(iPrevStepNum);

        ptPrev.x = m_rectPlot.left + locStepper.Position();
        ptNext.x = m_rectPlot.left + locStepper.NextPosition();                            

        ptMouse.x = xPos;
        ptMouse.y = yPos;

        // Item within rectangle?
        if ( iPrevStepNum > -1 ) {
            
            // Determine the history index of the preceding step.

            if ( iPrevStepNum <= m_pGraph->TimeStepper.StepNum() ) {
                iHistIndex = m_pGraph->TimeStepper.StepNum() - iPrevStepNum;
            } else {
                iHistIndex = m_pGraph->TimeStepper.StepNum() 
                                + (m_pGraph->TimeStepper.StepCount() - iPrevStepNum);
            }

            while ( (pItem != NULL) && !bFound ) {

                // Calculate y position of this value to compare against
                // y position of hit point.
                if ( CalcYPosition ( pItem, iHistIndex, bLog, yPosPrev ) ) {
                
                    if ( iPrevStepNum < locStepper.StepCount() ) {

                        if ( CalcYPosition ( pItem, iHistIndex - 1, bLog, yPosNext ) ) {
            
                            ptPrev.y = yPosPrev[0];
                            ptNext.y = yPosNext[0];
                        
                            bFound = HitTestLine( ptPrev, ptNext, ptMouse, eHitRegion );

                            // For log files, also check the vertical line from min to max
                            // for the closest step.
                            if ( !bFound && bLogMultiVal ) {
                                INT iTemp = ptNext.x - ptPrev.x;
                        
                                iTemp = iTemp / 2;

                                if ( ptMouse.x <= ( ptPrev.x + iTemp/2 ) ) {
                        
                                    bFound = (( yPosPrev[2] - eHitRegion < yPos ) 
                                                && ( yPos < yPosPrev[1] + eHitRegion ));
                                } else {

                                    bFound = (( yPosNext[2] - eHitRegion < yPos ) 
                                                && ( yPos < yPosNext[1] + eHitRegion ));
                                }
                            }
                        }
                    } else {

                        // At the end, so just check the final point.

                        if ( !bLogMultiVal ) {
                            bFound = (( yPosPrev[0] - eHitRegion < yPos ) 
                                    && ( yPos < yPosPrev[0] + eHitRegion ));
                        } else {
                            bFound = (( yPosPrev[2] - eHitRegion < yPos ) 
                                        && ( yPos < yPosPrev[1] + eHitRegion ));
                        }
                    }
                }

                if ( bFound ) 
                    pReturn = pItem;
                else
                    pItem = pItem->Next();
            }        
        }
    }
    
    return pReturn;
}

PCGraphItem 
CGraphDisp::GetItemInBarGraph ( SHORT xPos, SHORT /* yPos */ )
{
    PCGraphItem pItem = NULL;

    pItem = m_pCtrl->FirstCounter();

    // Items exist?
    if (pItem != NULL) {

        CStepper    BarStepper;
        INT         iNumCounters = m_pGraph->CounterTree.NumCounters();
        INT         iCount;
        INT         iHitStep;

        // Intialize stepper for number of bars in plot
        BarStepper.Init ( ( m_rectPlot.right - m_rectPlot.left), iNumCounters );
        iHitStep = BarStepper.PrevStepNum ( xPos - m_rectPlot.left );

        assert ( -1 != iHitStep );

        // Find the counter displayed in the hit step.        
        for ( iCount = 0;
            ( iCount < iHitStep ) && ( pItem != NULL );
            iCount++ ) {
            
            pItem = pItem->Next();        
        }
    }
    
    return pItem;
}

PCGraphItem 
CGraphDisp::GetItem( INT xPos, INT yPos )
{
    PCGraphItem pReturn = NULL;

    if ( ( m_pGraph->Options.iVertMax > m_pGraph->Options.iVertMin) 
        && ( yPos >= m_rectPlot.top ) && ( yPos <= m_rectPlot.bottom ) 
        && ( xPos >= m_rectPlot.left ) && ( xPos <= m_rectPlot.right ) ) {

        m_pCtrl->LockCounterData();
        
        if ( LINE_GRAPH == m_pGraph->Options.iDisplayType ) {
            assert ( SHRT_MAX >= xPos ); 
            assert ( SHRT_MAX >= yPos );
            
            pReturn = GetItemInLineGraph( (SHORT)xPos, (SHORT)yPos );
        } else if ( BAR_GRAPH == m_pGraph->Options.iDisplayType ) {
            assert ( SHRT_MAX >= xPos ); 
            assert ( SHRT_MAX >= yPos );
            
            pReturn = GetItemInBarGraph( (SHORT)xPos, (SHORT)yPos );
        }

        m_pCtrl->UnlockCounterData();

    }

    return pReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\genprop.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    genprop.cpp

Abstract:

    <abstract>

--*/

#include <assert.h>
#include <stdio.h>
#include "genprop.h"
#include "utils.h"
#include "strids.h"
#include "smonctrl.h"
#include "winhelpr.h"

CGeneralPropPage::CGeneralPropPage ( void )
/*++

Routine Description:

    Constructor for CGeneralPropPage class. Initializes the member variables.
     
Arguments:

    None.

Return Value:

    None.

--*/
{
    m_uIDDialog = IDD_GEN_PROPP_DLG;
    m_uIDTitle = IDS_GEN_PROPP_TITLE;
    return;
}

CGeneralPropPage::~CGeneralPropPage (
    VOID
    )
/*++

Routine Description:

    Destructor for CGeneralPropPage class. .
     
Arguments:

    None.

Return Value:

    None.

--*/
{
    return;
}

BOOL
CGeneralPropPage::InitControls(
    VOID
    )
{
    HWND    hWndItem = NULL;

    hWndItem = GetDlgItem(m_hDlg, IDC_UPDATE_INTERVAL);
    if ( NULL != hWndItem ) {
        EditSetLimit(hWndItem, MAX_INTERVAL_DIGITS);
        hWndItem = NULL;
    }
    hWndItem = DialogControl (m_hDlg, IDC_COMBOAPPEARANCE) ;
    if ( NULL != hWndItem ) {
        CBAdd (hWndItem, ResourceString(IDS_APPEARANCE_FLAT));
        CBSetData( hWndItem, 0, eAppearFlat );
        CBAdd (hWndItem, ResourceString(IDS_APPEARANCE_3D));
        CBSetData( hWndItem, 1, eAppear3D );
        hWndItem = NULL;
    }    
    hWndItem = DialogControl (m_hDlg, IDC_COMBOBORDERSTYLE) ;
    if ( NULL != hWndItem ) {
        CBAdd (hWndItem, ResourceString(IDS_BORDERSTYLE_NONE));
        CBSetData( hWndItem, 0, eBorderNone );
        CBAdd (hWndItem, ResourceString(IDS_BORDERSTYLE_SINGLE));
        CBSetData( hWndItem, 1, eBorderSingle );
        hWndItem = NULL;
    }

    return TRUE;
    //assert( IsWindowUnicode( m_hDlg ) );
    //assert( IsWindowUnicode( hWndItem ) );
}

BOOL 
CGeneralPropPage::GetProperties(
    VOID
    )
/*++

Routine Description:

    GetProperties fetches the selected graph's properties via the 
    ISystemMonitor interface and loads them into the property page dialog.
    It also clears all the propery change flags.

Arguments:

    None.

Return Value:

    Boolean status - TRUE = success

--*/
{
    TCHAR   szBuff[30];
    ISystemMonitor  *pObj;
    INT iPrecision;
    HWND    hWndItem;

    // Make sure a control is selected
    if (m_cObjects == 0)
        return FALSE;
    
    // Use only the first one   
    pObj = m_ppISysmon[0];
    
    // Load each graph property
    pObj->get_DisplayType(&m_eDisplayType);
    CheckRadioButton(m_hDlg, IDC_GALLERY_GRAPH, IDC_GALLERY_REPORT,
                        IDC_GALLERY_GRAPH + m_eDisplayType - 1);

    pObj->get_ReportValueType(&m_eReportValueType);
    CheckRadioButton(m_hDlg, IDC_RPT_VALUE_DEFAULT, IDC_RPT_VALUE_MAXIMUM,
                        IDC_RPT_VALUE_DEFAULT + m_eReportValueType);

    pObj->get_ShowLegend(&m_bLegend) ;
    CheckDlgButton(m_hDlg, IDC_LEGEND, m_bLegend);
    
    pObj->get_ShowToolbar (&m_bToolbar);
    CheckDlgButton (m_hDlg, IDC_TOOLBAR, m_bToolbar);
    
    pObj->get_ShowValueBar(&m_bValueBar);
    CheckDlgButton(m_hDlg, IDC_VALUEBAR, m_bValueBar) ;

    pObj->get_MonitorDuplicateInstances(&m_bMonitorDuplicateInstances);
    CheckDlgButton(m_hDlg, IDC_DUPLICATE_INSTANCE, m_bMonitorDuplicateInstances) ;

    pObj->get_Appearance(&m_iAppearance);
    hWndItem = DialogControl (m_hDlg, IDC_COMBOAPPEARANCE) ;
    CBSetSelection (hWndItem, m_iAppearance) ;

    pObj->get_BorderStyle(&m_iBorderStyle);
    hWndItem = DialogControl (m_hDlg, IDC_COMBOBORDERSTYLE) ;
    CBSetSelection (hWndItem, m_iBorderStyle) ;

    pObj->get_UpdateInterval(&m_fSampleInterval);

    ((INT)(100 * m_fSampleInterval) != 100 * (INT)m_fSampleInterval) 
        ? iPrecision = 2 : iPrecision = 0;

        FormatNumber (
            m_fSampleInterval,
            szBuff,
            30,
            0,
            iPrecision );

    SetDlgItemText(m_hDlg, IDC_UPDATE_INTERVAL, szBuff) ;

    pObj->get_DisplayFilter(&m_iDisplayInterval);
    _stprintf(szBuff, TEXT("%d"), m_iDisplayInterval) ;
    SetDlgItemText(m_hDlg, IDC_DISPLAY_INTERVAL, szBuff) ;

    pObj->get_ManualUpdate(&m_bManualUpdate);
    CheckDlgButton (m_hDlg, IDC_PERIODIC_UPDATE, !m_bManualUpdate);

    // If manual update, disable sample (update) and display intervals 
    DialogEnable (m_hDlg, IDC_UPDATE_INTERVAL, !m_bManualUpdate) ;
    DialogEnable (m_hDlg, IDC_INTERVAL_LABEL, !m_bManualUpdate) ;
    DialogEnable (m_hDlg, IDC_DISPLAY_INTERVAL, !m_bManualUpdate) ;
    DialogEnable (m_hDlg, IDC_DISPLAY_INT_LABEL1, !m_bManualUpdate) ;
    DialogEnable (m_hDlg, IDC_DISPLAY_INT_LABEL2, !m_bManualUpdate) ;

    // Clear all change flags 
    m_bLegendChg = FALSE;
    m_bValueBarChg = FALSE;
    m_bToolbarChg = FALSE;
    m_bSampleIntervalChg = FALSE;
    m_bDisplayIntervalChg = FALSE;
    m_bDisplayTypeChg = FALSE;
    m_bReportValueTypeChg = FALSE;
    m_bManualUpdateChg = FALSE;
    m_bAppearanceChg = FALSE;
    m_bBorderStyleChg = FALSE;
    m_bMonitorDuplicateInstancesChg = FALSE;

    // Clear error flags
    m_iErrSampleInterval = 0;
    m_iErrDisplayInterval = 0;

    return TRUE;    
}


BOOL 
CGeneralPropPage::SetProperties (
    VOID
    )
/*++

Routine Description:

    SetProperties writes the changed graph properties to the selected control
    via the ISystemMonitor interface. It then resets all the change flags.
     
Arguments:

    None.

Return Value:

    Boolean status - TRUE = success

--*/
{
    ISystemMonitor  *pObj;
    
    // Make sure a control is selected
    if (m_cObjects == 0)
        return FALSE;

    // Use only the first control   
    pObj = m_ppISysmon[0];

    // Check for invalid data

    if ( !m_bManualUpdate ) {
        if ( m_iErrSampleInterval ) {
            MessageBox (m_hDlg, ResourceString(IDS_INTERVAL_ERR), ResourceString(IDS_APP_NAME), MB_OK | MB_ICONEXCLAMATION) ;
            SetFocus ( GetDlgItem ( m_hDlg, IDC_UPDATE_INTERVAL ) );
            return FALSE;
        }
        if ( m_iErrDisplayInterval ) {
            MessageBox (m_hDlg, ResourceString(IDS_DISPLAY_INT_ERR), ResourceString(IDS_APP_NAME), MB_OK | MB_ICONEXCLAMATION) ;
            SetFocus ( GetDlgItem ( m_hDlg, IDC_DISPLAY_INTERVAL ) );
            return FALSE;
        }
    }
    // Write each changed property to the control
    if (m_bLegendChg)
        pObj->put_ShowLegend(m_bLegend);

    if (m_bToolbarChg)
        pObj->put_ShowToolbar(m_bToolbar);

    if (m_bValueBarChg)
        pObj->put_ShowValueBar(m_bValueBar);

    if (m_bSampleIntervalChg)
        pObj->put_UpdateInterval(m_fSampleInterval);

    if (m_bDisplayIntervalChg) {
        pObj->put_DisplayFilter(m_iDisplayInterval);
    }

    if (m_bDisplayTypeChg)
        pObj->put_DisplayType(m_eDisplayType);

    if (m_bReportValueTypeChg)
        pObj->put_ReportValueType(m_eReportValueType);

    if (m_bManualUpdateChg)
        pObj->put_ManualUpdate(m_bManualUpdate);

    if (m_bAppearanceChg)
        pObj->put_Appearance(m_iAppearance);

    if (m_bBorderStyleChg)  
        pObj->put_BorderStyle(m_iBorderStyle);

    if (m_bMonitorDuplicateInstancesChg)
        pObj->put_MonitorDuplicateInstances(m_bMonitorDuplicateInstances);

    // Reset the change flags
    m_bLegendChg = FALSE;
    m_bValueBarChg = FALSE;
    m_bToolbarChg = FALSE;
    m_bSampleIntervalChg = FALSE;
    m_bDisplayIntervalChg = FALSE;
    m_bDisplayTypeChg = FALSE;
    m_bReportValueTypeChg = FALSE;
    m_bManualUpdateChg = FALSE;
    m_bAppearanceChg = FALSE;
    m_bBorderStyleChg = FALSE;
        
    return TRUE;    
}


VOID 
CGeneralPropPage::DialogItemChange (
    IN WORD wID, 
    IN WORD wMsg
    )
/*++

Routine Description:

    DialogItemChange handles changes to the property page dialog items. On
    each change it reads the new property value and set the property's change
    flag. On any change the SetChange routine is called to enable the "Apply"
    button.

Arguments:

    wID - Dialog item ID
    wMsg - Notification code

Return Value:

    None.

--*/
{
    BOOL fChange = FALSE;
    INT  iTemp;
    BOOL bStat = FALSE;
    HWND hWndItem;

    // Case on dialog item ID
    switch(wID) {

        case IDC_UPDATE_INTERVAL:

            // On change, set change flags
            // Wait until focus lost to read final value
            if (wMsg == EN_CHANGE) {

                fChange = TRUE;
                m_bSampleIntervalChg = TRUE;
            }
            else if (wMsg == EN_KILLFOCUS) {

                m_fSampleInterval = DialogFloat(m_hDlg, IDC_UPDATE_INTERVAL, &bStat) ;

                if (bStat && 
                     (m_fSampleInterval <= MAX_UPDATE_INTERVAL 
                        && m_fSampleInterval >= MIN_UPDATE_INTERVAL)) {
                    m_iErrSampleInterval = 0;
                } else {                
                    m_iErrSampleInterval = IDS_INTERVAL_ERR;
                }
            }
            break ;

        case IDC_DISPLAY_INTERVAL:

            // On change, set change flags
            // Wait until focus lost to read final value
            if (wMsg == EN_CHANGE) {
                fChange = TRUE;
                m_bDisplayIntervalChg = TRUE;
            } else if (wMsg == EN_KILLFOCUS) {
                m_iDisplayInterval = GetDlgItemInt(m_hDlg, IDC_DISPLAY_INTERVAL, &bStat, FALSE);
                // TodoDisplayFilter:  Support for display filter > sample filter.
                // TodoDisplayFilter:  Display filter units = seconds instead of samples

                if ( 1 != m_iDisplayInterval ) {
                    TCHAR   szBuff[30];
                    MessageBox (
                        m_hDlg, 
                        L"Display filter > 1 sample not yet implemented.\nDisplay interval in seconds not yet implemented.", 
                        ResourceString(IDS_APP_NAME), MB_OK | MB_ICONEXCLAMATION) ;
                    m_iDisplayInterval = 1;
                    _stprintf(szBuff, TEXT("%d"), m_iDisplayInterval) ;
                    SetDlgItemText(m_hDlg, IDC_DISPLAY_INTERVAL, szBuff) ;
                } else {
                    if ( FALSE == bStat) {
                        m_iErrDisplayInterval = IDS_DISPLAY_INT_ERR;
                    } else {
                        m_iErrDisplayInterval = 0;
                    }
                }
            }
            break ;

        case IDC_PERIODIC_UPDATE:

            if (wMsg == BN_CLICKED) {

                m_bManualUpdate = !m_bManualUpdate;
                m_bManualUpdateChg = TRUE;
                fChange = TRUE;
            
                // Disable sample (update) and display intervals if necessary
                DialogEnable (m_hDlg, IDC_INTERVAL_LABEL, !m_bManualUpdate) ;
                DialogEnable (m_hDlg, IDC_UPDATE_INTERVAL, !m_bManualUpdate) ;
                DialogEnable (m_hDlg, IDC_DISPLAY_INTERVAL, !m_bManualUpdate) ;
                DialogEnable (m_hDlg, IDC_DISPLAY_INT_LABEL1, !m_bManualUpdate) ;
                DialogEnable (m_hDlg, IDC_DISPLAY_INT_LABEL2, !m_bManualUpdate) ;
            }

            break ;

        case IDC_VALUEBAR:

            // If checkbox toggled, set change flags
            if (wMsg == BN_CLICKED) {

                m_bValueBar = !m_bValueBar;
                m_bValueBarChg = TRUE;
                fChange = TRUE;
            }
            break ;

        case IDC_LEGEND:

            // If checkbox toggled, set change flags
            if (wMsg == BN_CLICKED) {

                m_bLegend = !m_bLegend;
                m_bLegendChg = TRUE;
                fChange = TRUE;
            }
            break ;

        case IDC_TOOLBAR:
            if (wMsg == BN_CLICKED) {
                m_bToolbar = !m_bToolbar;
                m_bToolbarChg = TRUE;
                fChange = TRUE;
            }
            break;

        case IDC_COMBOAPPEARANCE:
            if (wMsg == CBN_SELCHANGE) {
                hWndItem = DialogControl(m_hDlg, IDC_COMBOAPPEARANCE);
                iTemp = (INT)CBSelection(hWndItem);

                if ( m_iAppearance != iTemp ) {
                    m_bAppearanceChg = TRUE;
                    fChange = TRUE;
                }

                m_iAppearance = iTemp;
            }
            break ;

        case IDC_COMBOBORDERSTYLE:
            if (wMsg == CBN_SELCHANGE) {
                hWndItem = DialogControl(m_hDlg, IDC_COMBOBORDERSTYLE);
                iTemp = (INT)CBSelection(hWndItem);

                if ( m_iBorderStyle != iTemp ) {
                    m_bBorderStyleChg = TRUE;
                    fChange = TRUE;
                }

                m_iBorderStyle = iTemp;
            }
            break ;

        case IDC_DUPLICATE_INSTANCE:

            // If checkbox toggled, set change flags
            if (wMsg == BN_CLICKED) {

                m_bMonitorDuplicateInstances = !m_bMonitorDuplicateInstances;
                m_bMonitorDuplicateInstancesChg = TRUE;
                fChange = TRUE;
            }
            break ;

        case IDC_GALLERY_GRAPH:
        case IDC_GALLERY_HISTOGRAM:
        case IDC_GALLERY_REPORT: 
            // Check which button is involved
            iTemp = wID - IDC_GALLERY_GRAPH + 1; 

            // If state changed
            if (wMsg == BN_CLICKED && iTemp != m_eDisplayType) {

                // Set change flags and update dialog
                fChange = TRUE;
                m_bDisplayTypeChg = TRUE;
                m_eDisplayType = (DisplayTypeConstants)iTemp;

                CheckRadioButton(m_hDlg, IDC_GALLERY_GRAPH, 
                                    IDC_GALLERY_REPORT, wID);
            }   
            break ;

        case IDC_RPT_VALUE_DEFAULT:
        case IDC_RPT_VALUE_CURRENT:
        case IDC_RPT_VALUE_AVERAGE:
        case IDC_RPT_VALUE_MINIMUM:
        case IDC_RPT_VALUE_MAXIMUM:
            // Check which button is involved
            iTemp = wID - IDC_RPT_VALUE_DEFAULT; 

            // If state changed
            if (wMsg == BN_CLICKED && iTemp != m_eReportValueType) {

                // Set change flags and update dialog
                fChange = TRUE;
                m_bReportValueTypeChg = TRUE;
                m_eReportValueType = (ReportValueTypeConstants)iTemp;

                CheckRadioButton(m_hDlg, IDC_RPT_VALUE_DEFAULT, 
                                    IDC_RPT_VALUE_MAXIMUM, wID);
            }   
            break ;
    }

    // Enable "Apply" button on any change
    if (fChange)
        SetChange();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\grphdsp.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    grphdsp.h

Abstract:

    Header file for the sysmon.ocx graph display.

--*/

#ifndef _GRPHDSP_H_
#define _GRPHDSP_H_


class CSysmonControl;

class CGraphDisp
{
//friend LRESULT APIENTRY GraphDispWndProc (HWND hWnd,
//                                     UINT uiMsg,
//                                     WPARAM wParam,
//                                     LPARAM lParam);

public:
    void ChangeFont     ( HDC );
    static BOOL RegisterWndClass (HINSTANCE hInst) ;
    CGraphDisp          ( void );
    ~CGraphDisp         ( void);
    BOOL Init           ( CSysmonControl *pCtrl, PGRAPHDATA pGraph ) ;

    void Update         ( HDC );
    void Draw           ( HDC, HDC hAttribDC, BOOL fMetafile, BOOL fEntire, PRECT prcUpdate);
    void HiliteItem     ( PCGraphItem pItem );
    void SizeComponents ( HDC hDC, PRECT pRect );
    void GetPlotRect    ( PRECT pRect ) { *pRect = m_rectPlot; } 

    void SetBarConfigChanged ( BOOL bChanged = TRUE ) { m_bBarConfigChanged = bChanged; };

    PCGraphItem GetItem ( INT xPos, INT yPos ); 

private:

    enum eGraphDisplayConstant {
        eHitRegion = 4
    };

    void DrawTimeLine       ( HDC hDC, INT x);
    void DrawStartStopLine  ( HDC hDC, INT x);
    void StartUpdate        ( HDC hDC, BOOL fMetafile, BOOL fEntire, INT xLeft, INT xRight, BOOL bFill = TRUE );
    void FinishUpdate       ( HDC hDC, BOOL fMetafile );
    void DrawGrid           ( HDC hDC, INT iLeft, INT iRight);
    void PlotBarGraph       ( HDC hDC , BOOL fUpdate);
    void PlotData           ( HDC hDC, INT iHistIndx, INT nSteps, CStepper *pStepper );
    void UpdateTimeBar      ( HDC, BOOL bPlotData = TRUE );

    PCGraphItem GetItemInLineGraph  ( SHORT xPos, SHORT yPos ); 
    PCGraphItem GetItemInBarGraph  ( SHORT xPos, SHORT yPos ); 

    INT     RGBToLightness  ( COLORREF );
    BOOL    CalcYPosition  ( PCGraphItem pItem, INT iHistIndex, BOOL bLog, INT y[3] );
 

    PGRAPHDATA      m_pGraph;
    CSysmonControl  *m_pCtrl;
    RECT            m_rect;
    RECT            m_rectPlot;
    CStepper        m_GridStepper;
    HFONT           m_hFontVertical;
    PCGraphItem     m_pHiliteItem;
    HRGN            m_rgnClipSave;
    BOOL            m_bBarConfigChanged;

    // Min, Max and PixelScale are used for plot, hit test.
    double          m_dMin;
    double          m_dMax;
    double          m_dPixelScale;


    COLORREF        m_clrCurrentTimeBar;
    COLORREF        m_clrCurrentGrid;
    HPEN            m_hPenTimeBar;
    HPEN            m_hPenGrid;

};

typedef CGraphDisp *PGRAPHDISP;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\grphitem.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    grphitem.h

Abstract:

    <abstract>

--*/

#ifndef _GRPHITEM_H_
#define _GRPHITEM_H_

#include <inole.h>
#include "isysmon.h"

class CSysmonControl;

//
// Persistant data structure
//

typedef struct
{
    COLORREF    m_rgbColor;
    INT32       m_iWidth;
    INT32       m_iStyle;       
    INT32       m_iScaleFactor;
    INT32       m_nPathLength;
} GRAPHITEM_DATA3;

typedef struct
{
    double      m_dMin;
    double      m_dMax;
    double      m_dAvg;
    FILETIME    m_LastTimeStamp;   
} LOG_ENTRY_DATA, *PLOG_ENTRY_DATA;

//
// Graphitem Class
// 
class CGraphItem : public ICounterItem
{
    public:
        class  CCounterNode*    m_pCounter;
        class  CInstanceNode*   m_pInstance;
        class  CGraphItem*      m_pNextItem;
        PDH_COUNTER_INFO        m_CounterInfo;        
        HCOUNTER                m_hCounter;
        double                  m_dScale;
        PLOG_ENTRY_DATA         m_pLogData;
        BOOLEAN                 m_bUpdateLog;

    public:
        BOOLEAN                 m_fLocalMachine;
        BOOLEAN                 m_fGenerated;

        CGraphItem(CSysmonControl *pCtrl);
        ~CGraphItem(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // ICounterItem methods
        STDMETHODIMP    put_Color(OLE_COLOR);
        STDMETHODIMP    get_Color(OLE_COLOR*);
        STDMETHODIMP    put_Width(INT);
        STDMETHODIMP    get_Width(INT*) ;
        STDMETHODIMP    put_LineStyle(INT) ;
        STDMETHODIMP    get_LineStyle(INT*) ;
        STDMETHODIMP    put_ScaleFactor(INT) ;
        STDMETHODIMP    get_ScaleFactor(INT*) ;
        STDMETHODIMP    get_Path(BSTR*) ;
        STDMETHODIMP    get_Value(double*) ;

        STDMETHODIMP GetValue(double *pdValue,  LONG *plStatus) ;
        STDMETHODIMP GetStatistics(double *pdMax, double *pdMin, double *pdAvg,
                                LONG *plStatus) ;

        // methods not exposed by ICounterItem interface
        static HRESULT NullItemToStream(LPSTREAM pIStream, INT iVersMaj, INT iVersMin);

        HPEN    Pen(void);
        HBRUSH  Brush(void);
        double  Scale(void) { return m_dScale; }
        HCOUNTER Handle(void) { return m_hCounter; }

        CInstanceNode *Instance(void) { return m_pInstance; }
        CCounterNode  *Counter(void) { return m_pCounter; }
        CObjectNode  *Object(void) { return m_pInstance->m_pObject; }
        CMachineNode *Machine(void) { return m_pInstance->m_pObject->m_pMachine; }
        CCounterTree *Tree(void) { return m_pInstance->m_pObject->m_pMachine->m_pCounterTree; }
        CGraphItem *Next(void);
        
        void    Delete(BOOL bPropagateUp);

        BOOL    IsRateCounter ( void );

        HRESULT LoadFromPropertyBag ( 
                    IPropertyBag*,
                    IErrorLog*,
                    INT iIndex,
                    INT iVersMaj, 
                    INT iVersMin,
                    INT iSampleCount );
        
        HRESULT SaveToPropertyBag ( 
                    IPropertyBag*,
                    INT iIndex,
                    BOOL bUserMode,
                    INT iVersMaj, 
                    INT iVersMin );

        HRESULT SaveToStream(LPSTREAM pIStream, BOOL fWildCard, INT iVersMaj, INT iVersMin);

        HRESULT AddToQuery(HQUERY hQuery);
        HRESULT RemoveFromQuery();

        void        ClearHistory( void );

        void        UpdateHistory(BOOL bValidSample);
        PDH_STATUS  HistoryValue(INT iIndex, double *pdValue, DWORD *pdwStatus);
        PDH_STATUS  GetLogEntry( const INT iIndex, double *dMin, double *dMax, double *dAvg, 
                                DWORD *pdwStatus);
        PDH_STATUS  GetLogEntryTimeStamp (
                                const INT iIndex, 
                                LONGLONG& rLastTimeStamp,
                                DWORD *pdwStatus);

        void  SetLogEntry( 
                const INT iIndex, 
                const double dMin, 
                const double dMax, 
                const double dAvg);

        void  SetLogEntryTimeStamp( const INT iIndex, const FILETIME& rLastTimeStamp );

        void  SetLogStats(double dMin, double dMax, double dAvg)
                    { m_dLogMin = dMin; m_dLogMax = dMax; m_dLogAvg = dAvg; }


    private:

        CSysmonControl  *m_pCtrl;
        void    InvalidatePen(void);
        void    InvalidateBrush(void);
        void    FormPath(LPTSTR pszPath, BOOL fWildCard);

        // Used by LoadFromPropertyBag
        void    SetStatistics ( double dMax, double dMin, double dAvg, LONG lStatus );
        void    SetHistoryValue ( INT iIndex, double dValue );
      
        HRESULT GetNextValue ( TCHAR*& pszNext, double& dValue );
        
        ULONG   m_cRef;
        HPEN    m_hPen;
        HBRUSH  m_hBrush;

        COLORREF    m_rgbColor;
        INT         m_iWidth;
        INT         m_iStyle;       // No change in implementation
        INT         m_iScaleFactor;

        double  m_dLogMin;
        double  m_dLogMax;
        double  m_dLogAvg;
        PCImpIDispatch  m_pImpIDispatch;
        PPDH_RAW_COUNTER      m_pRawCtr;

        // Used by LoadFromPropertyBag
        double* m_pFmtCtr;
        double  m_dFmtMin;
        double  m_dFmtMax;
        double  m_dFmtAvg;
        long    m_lFmtStatus;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\grphprop.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    grphprop.h

Abstract:

    Header file for the graph property page class.

--*/

#ifndef _GRPHPROP_H_
#define _GRPHPROP_H_

#include "smonprop.h"

// Dialog Controls
#define IDD_GRAPH_PROPP_DLG     300
#define IDC_VERTICAL_GRID       101
#define IDC_HORIZONTAL_GRID     102
#define IDC_VERTICAL_LABELS     103
#define IDC_VERTICAL_MAX        104
#define IDC_VERTICAL_MIN        105
#define IDC_YAXIS_TITLE         106             
#define IDC_GRAPH_TITLE         107

#define MAX_SCALE_DIGITS    9
#define MAX_VERTICAL_SCALE  999999999
#define MIN_VERTICAL_SCALE  0

#define MAX_TITLE_CHARS     128

// Graph property page class
class CGraphPropPage : public CSysmonPropPage
{
    public:
                CGraphPropPage(void);
        virtual ~CGraphPropPage(void);

    protected:

        virtual BOOL GetProperties(void);   //Read current properties
        virtual BOOL SetProperties(void);   //Set new properties
        virtual void DialogItemChange(WORD wId, WORD wMsg); // Handle item change
        virtual BOOL InitControls(void);   //Initialize dialog controls
    
    private:

        // Properties 
        VARIANT_BOOL    m_bLabels;
        VARIANT_BOOL    m_bVertGrid;
        VARIANT_BOOL    m_bHorzGrid;
        INT     m_iVertMax;
        INT     m_iVertMin;
        LPTSTR  m_pszYaxisTitle;
        LPTSTR  m_pszGraphTitle;

        // Property change flags
        VARIANT_BOOL    m_bLabelsChg;
        VARIANT_BOOL    m_bVertGridChg;
        VARIANT_BOOL    m_bHorzGridChg;
        VARIANT_BOOL    m_bVertMaxChg;
        VARIANT_BOOL    m_bVertMinChg;
        VARIANT_BOOL    m_bYaxisTitleChg;
        VARIANT_BOOL    m_bGraphTitleChg;

        // Error flags
        INT m_iErrVertMin;
        INT m_iErrVertMax;

};
typedef CGraphPropPage *PCGraphPropPage;

// {C3E5D3D3-1A03-11cf-942D-008029004347}
DEFINE_GUID(CLSID_GraphPropPage, 
        0xc3e5d3d3, 0x1a03, 0x11cf, 0x94, 0x2d, 0x0, 0x80, 0x29, 0x0, 0x43, 0x47);

#endif //_GRPHPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\hatchwnd.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    hatchwnd.h

Abstract:

    Header file for the CHatchWin class.  CHatchWin when used 
    as a parent window creates a thin hatch border around 
    the child window.

--*/

#ifndef _HATCHWND_H_
#define _HATCHWND_H_

//Window extra bytes and offsets
#define CBHATCHWNDEXTRA                 (sizeof(LONG_PTR))
#define HWWL_STRUCTURE                  0

//Notification codes for WM_COMMAND messages
#define HWN_BORDERDOUBLECLICKED         1
#define HWN_RESIZEREQUESTED             2


// Drag modes
#define DRAG_IDLE       0
#define DRAG_PENDING    1
#define DRAG_ACTIVE     2

class CHatchWin
    {
    friend LRESULT APIENTRY HatchWndProc(HWND, UINT, WPARAM, LPARAM);

    protected:
        HWND        m_hWnd;
        HWND        m_hWndParent;       //Parent's window
        UINT        m_uDragMode;
        UINT        m_uHdlCode;
        RECT        m_rectNew;
        POINT       m_ptDown;
        POINT       m_ptHatchOrg;
        HRGN        m_hRgnDrag;
        BOOLEAN     m_bResizeInProgress;

    private:
        void        OnMouseMove(INT x, INT y);
        void        OnLeftDown(INT x, INT y);
        void        OnLeftUp(void);
        void        StartTracking(void);
        void        OnTimer(void);
        void        OnPaint(void);

    public:
        INT         m_iBorder;
        UINT        m_uID;
        HWND        m_hWndKid;
        HWND        m_hWndAssociate;
        RECT        m_rcPos;
        RECT        m_rcClip;

    public:

        CHatchWin(void);
        ~CHatchWin(void);

        BOOL        Init(HWND, UINT, HWND);

        HWND        Window(void);

        HWND        HwndAssociateSet(HWND);
        HWND        HwndAssociateGet(void);

        void        RectsSet(LPRECT, LPRECT);
        void        ChildSet(HWND);
        void        ShowHatch(BOOL);
    };

typedef CHatchWin *PCHatchWin;

#endif //_HATCHWND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\grphprop.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    grphprop.cpp

Abstract:

    Implementation of the graph property page class.

--*/


#include <assert.h>
#include <stdio.h>
#include "grphprop.h"
#include "utils.h"
#include "strids.h"
#include "unihelpr.h"
#include "winhelpr.h"

CGraphPropPage::CGraphPropPage()
{

    m_uIDDialog = IDD_GRAPH_PROPP_DLG;
    m_uIDTitle = IDS_GRAPH_PROPP_TITLE;

    m_pszYaxisTitle = NULL;
    m_pszGraphTitle = NULL;

}

CGraphPropPage::~CGraphPropPage()
{
     delete m_pszYaxisTitle;
     delete m_pszGraphTitle;
}

BOOL CGraphPropPage::InitControls()
{
    HWND  hwndItem = NULL;

    hwndItem = GetDlgItem(m_hDlg, IDC_VERTICAL_MAX);
    if ( NULL != hwndItem ) {
        EditSetLimit(hwndItem, MAX_SCALE_DIGITS);
        hwndItem = NULL;
    }
    hwndItem = GetDlgItem(m_hDlg, IDC_VERTICAL_MIN);
    if ( NULL != hwndItem ) {
        EditSetLimit(hwndItem, MAX_SCALE_DIGITS);
        hwndItem = NULL;
    }
    hwndItem = GetDlgItem(m_hDlg, IDC_GRAPH_TITLE);
    if ( NULL != hwndItem ) {
        EditSetLimit(hwndItem, MAX_TITLE_CHARS);
        hwndItem = NULL;
    }
    hwndItem = GetDlgItem(m_hDlg, IDC_YAXIS_TITLE);
    if ( NULL != hwndItem ) {
        EditSetLimit(hwndItem, MAX_TITLE_CHARS);
        hwndItem = NULL;
    }
    return TRUE;
}

/*
 * CGraphPropPage::GetProperties
 * 
 */

BOOL CGraphPropPage::GetProperties(void)
{
    TCHAR   szBuff[MAX_SCALE_DIGITS+1];
    ISystemMonitor  *pObj;
    BSTR    bstrTemp;
    LPTSTR  pszTemp;

    USES_CONVERSION

    if (m_cObjects == 0)
        return FALSE;
        
    pObj = m_ppISysmon[0];
        
    pObj->get_ShowScaleLabels(&m_bLabels);      
    CheckDlgButton(m_hDlg, IDC_VERTICAL_LABELS, m_bLabels) ;

    pObj->get_ShowVerticalGrid(&m_bVertGrid);
    CheckDlgButton(m_hDlg, IDC_VERTICAL_GRID, m_bVertGrid) ;

    pObj->get_ShowHorizontalGrid(&m_bHorzGrid);
    CheckDlgButton(m_hDlg, IDC_HORIZONTAL_GRID, m_bHorzGrid) ;

    pObj->get_MaximumScale(&m_iVertMax);
    _stprintf(szBuff, TEXT("%d"), m_iVertMax) ;
    SetDlgItemText(m_hDlg, IDC_VERTICAL_MAX, szBuff) ;

    pObj->get_MinimumScale(&m_iVertMin);
    _stprintf(szBuff, TEXT("%d"), m_iVertMin) ;
    SetDlgItemText(m_hDlg, IDC_VERTICAL_MIN, szBuff) ;

    pObj->get_YAxisLabel(&bstrTemp);
    if (bstrTemp != NULL) {
        pszTemp = W2T(bstrTemp);
        m_pszYaxisTitle = new TCHAR[lstrlen(pszTemp)+1];
        if (m_pszYaxisTitle) {
            lstrcpy(m_pszYaxisTitle, pszTemp);
            SetDlgItemText(m_hDlg, IDC_YAXIS_TITLE, m_pszYaxisTitle);
        }
        SysFreeString(bstrTemp);
    }
        
    pObj->get_GraphTitle(&bstrTemp);
    if (bstrTemp != NULL) {
        pszTemp = W2T(bstrTemp);
        m_pszGraphTitle = new TCHAR[lstrlen(pszTemp)+1];
        if (m_pszGraphTitle) {
            lstrcpy(m_pszGraphTitle, pszTemp);
            SetDlgItemText(m_hDlg, IDC_GRAPH_TITLE, m_pszGraphTitle);
        }
        SysFreeString(bstrTemp);
    }

    // Clear change flags
    m_bLabelsChg = FALSE;
    m_bVertGridChg = FALSE;
    m_bHorzGridChg = FALSE;
    m_bVertMinChg = FALSE;
    m_bYaxisTitleChg = FALSE;
    m_bGraphTitleChg = FALSE;

    // Clear error flags
    m_iErrVertMax = 0;
    m_iErrVertMin = 0;


    return TRUE;          
}


/*
 * CGraphPropPage::SetProperties
 * 
 */

BOOL CGraphPropPage::SetProperties(void)
{
    ISystemMonitor  *pObj;
    INT iMsgId = 0;

    USES_CONVERSION

    // Get first object
    if (m_cObjects == 0)
        return FALSE;
        
    pObj = m_ppISysmon[0];

    // Check for invalid data
    if (m_iErrVertMax) {
        SetFocus(GetDlgItem(m_hDlg, IDC_VERTICAL_MAX));
        iMsgId = m_iErrVertMax;
    } else if (m_iErrVertMin) {
        SetFocus(GetDlgItem(m_hDlg, IDC_VERTICAL_MIN));
        iMsgId = m_iErrVertMin;
    } else if (m_iVertMax <= m_iVertMin) {
        SetFocus(GetDlgItem(m_hDlg, IDC_VERTICAL_MAX));
        iMsgId = IDS_SCALE_ERR;
    }

    // on error, alert user and exit
    if (iMsgId) {
        MessageBox(m_hDlg, ResourceString(iMsgId), ResourceString(IDS_APP_NAME), MB_OK | MB_ICONEXCLAMATION);
        return FALSE;
    }

    // Set all changed properties
    if (m_bLabelsChg)
        pObj->put_ShowScaleLabels(m_bLabels);

    if (m_bVertGridChg)
        pObj->put_ShowVerticalGrid(m_bVertGrid);

    if (m_bHorzGridChg)
        pObj->put_ShowHorizontalGrid(m_bHorzGrid);

    if (m_bVertMaxChg)
        pObj->put_MaximumScale(m_iVertMax);

    if (m_bVertMinChg)
        pObj->put_MinimumScale(m_iVertMin);

    if (m_bYaxisTitleChg)
        pObj->put_YAxisLabel(T2W(m_pszYaxisTitle));

    if (m_bGraphTitleChg)
        pObj->put_GraphTitle(T2W(m_pszGraphTitle));

    // Clear change flags
    m_bLabelsChg = FALSE;
    m_bVertGridChg = FALSE;
    m_bHorzGridChg = FALSE;
    m_bVertMinChg = FALSE;
    m_bYaxisTitleChg = FALSE;
    m_bGraphTitleChg = FALSE;

    return TRUE;    
}



void CGraphPropPage::DialogItemChange(WORD wID, WORD wMsg)
{

    TCHAR   szTitleBuf[MAX_TITLE_CHARS+1];
    INT     iTitleLen;
    LPTSTR  pszTemp;
    BOOL fChange = FALSE;
    BOOL    fResult;

    switch(wID) {
        case IDC_VERTICAL_MAX:
            if (wMsg == EN_CHANGE) {
                fChange = TRUE;
                m_bVertMaxChg = TRUE;
            } else if ((wMsg == EN_KILLFOCUS) && m_bVertMaxChg) {
                m_iVertMax = GetDlgItemInt(m_hDlg, IDC_VERTICAL_MAX, &fResult, FALSE);
                if (!fResult) {
                    m_iErrVertMax = IDS_VERTMAX_ERR;
                } else {
                    m_iErrVertMax = 0;
                }
            }
            break ;

        case IDC_VERTICAL_MIN:
            if (wMsg == EN_CHANGE) {
                fChange = TRUE;
                m_bVertMinChg = TRUE;
            } else if ((wMsg == EN_KILLFOCUS) && m_bVertMinChg) {
                m_iVertMin =  GetDlgItemInt(m_hDlg, IDC_VERTICAL_MIN, &fResult, FALSE);
                if (!fResult) {
                    m_iErrVertMin = IDS_VERTMIN_ERR;
                } else {
                    m_iErrVertMin = 0;
                }
            }
            break ;

        case IDC_VERTICAL_LABELS:
            if (wMsg == BN_CLICKED)
                {
                m_bLabels = !m_bLabels;
                m_bLabelsChg = TRUE;
                fChange = TRUE;
                }
            break ;

        case IDC_VERTICAL_GRID:
            if (wMsg == BN_CLICKED)
                {
                m_bVertGrid = !m_bVertGrid;
                m_bVertGridChg = TRUE;
                fChange = TRUE;
                }
            break ;

        case IDC_HORIZONTAL_GRID:
            if (wMsg == BN_CLICKED)
                {
                m_bHorzGrid = !m_bHorzGrid;
                m_bHorzGridChg = TRUE;
                fChange = TRUE;
                }
           break ;

        case IDC_YAXIS_TITLE:
            if (wMsg == EN_CHANGE) {
                fChange = TRUE;
                m_bYaxisTitleChg = TRUE;
            }
            else if ((wMsg == EN_KILLFOCUS) && m_bYaxisTitleChg) {

                iTitleLen = DialogText(m_hDlg, IDC_YAXIS_TITLE, szTitleBuf);

                if (iTitleLen == 0) {
                    delete m_pszYaxisTitle;
                    m_pszYaxisTitle = NULL;
                }
                else {
                    pszTemp = new TCHAR[iTitleLen+1];
                    if (pszTemp) {
                        delete m_pszYaxisTitle;
                        m_pszYaxisTitle = pszTemp;
                        lstrcpy(m_pszYaxisTitle, szTitleBuf);
                    }
                }
            }                   
            break ;

        case IDC_GRAPH_TITLE:
            if (wMsg == EN_CHANGE) {
                fChange = TRUE;
                m_bGraphTitleChg = TRUE;
            }
            else if ((wMsg == EN_KILLFOCUS) && m_bGraphTitleChg) {

                iTitleLen = DialogText(m_hDlg, IDC_GRAPH_TITLE, szTitleBuf);

                if (iTitleLen == 0) {
                    delete m_pszGraphTitle;
                    m_pszGraphTitle = NULL;
                }
                else {
                    pszTemp = new TCHAR[iTitleLen+1];
                    if (pszTemp) {
                        delete m_pszGraphTitle;
                        m_pszGraphTitle = pszTemp;
                        lstrcpy(m_pszGraphTitle, szTitleBuf);
                    }
                }                   
            }                   
            break ;
        }

    if (fChange)
        SetChange();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\grphitem.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    grphitem.cpp

Abstract:

    <abstract>

--*/


#ifndef _LOG_INCLUDE_DATA 
#define _LOG_INCLUDE_DATA 0
#endif

#include <math.h>
#include <limits.h>     // for INT_MAX 
#include <pdhp.h>
#include "polyline.h"
#include "visuals.h"
#include "grphitem.h"
#include "unihelpr.h"
#include "utils.h"
#include "pdhmsg.h"

#define MAX_DOUBLE_TEXT_SIZE (64)

// Construction/Destruction
CGraphItem::CGraphItem (
    CSysmonControl  *pCtrl )
:   m_cRef ( 0 ),
    m_pCtrl ( pCtrl ),
    m_hCounter ( NULL ),
    m_hPen ( NULL ),
    m_hBrush ( NULL ),
    m_pCounter ( NULL ),
    m_pInstance ( NULL),
    m_pRawCtr ( NULL ),
    m_pFmtCtr ( NULL ),
    m_dFmtMax ( 0 ),
    m_dFmtMin ( 0 ),
    m_dFmtAvg ( 0 ),
    m_lFmtStatus ( 0 ),

    m_pLogData ( NULL ),
    m_pImpIDispatch ( NULL ),

    m_rgbColor ( RGB(0,0,0) ),
    m_iWidth ( 1 ),
    m_iStyle ( 0 ),      
    m_iScaleFactor ( INT_MAX ),
    m_dScale ( (double)1.0 ),

    m_pNextItem ( NULL ),
    m_bUpdateLog ( TRUE ),
    m_fGenerated ( FALSE )
/*++

Routine Description:

    Constructor for the CGraphItem class. It initializes the member variables.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ZeroMemory ( &m_CounterInfo, sizeof (m_CounterInfo ) );
    m_CounterInfo.CStatus = PDH_CSTATUS_INVALID_DATA;
    
    return;
}


CGraphItem::~CGraphItem (
    VOID
    )
/*++

Routine Description:

    Destructor for the CGraphItem class. It frees any objects, storage, and
    interfaces that were created. If the item is part of a query it is removed
    from the query.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (m_hCounter != NULL)
        RemoveFromQuery();

    if (m_hPen != NULL)
        DeleteObject(m_hPen);

    if (m_hBrush != NULL)
        DeleteObject(m_hBrush);

    if (m_pImpIDispatch != NULL)
        delete m_pImpIDispatch;
}

HRESULT
CGraphItem::SaveToStream (
    IN LPSTREAM pIStream,
    IN BOOL fWildCard,
    IN INT iVersMaj, 
    IN INT // iVersMin 
    )
/*++

Routine Description:

    SaveToStream writes the graph item's properties to the provided stream.

Arguments:

    pIStream - Pointer to stream interface
    pszPath - Path name to save item under

Return Value:

    HRESULT - S_OK or stream error

--*/
{
    LPWSTR  pszWidePath;
    TCHAR   szPath[MAX_PATH];
    LPTSTR  szEnglishBuf = NULL;
    DWORD   dwEnglishBufSize = 0;
    LPTSTR  pNewBuf;
    DWORD   dwBufSize;
    LPTSTR  pszPath;
    HRESULT hr = S_OK;
    PDH_STATUS pdhStatus; 
    

    USES_CONVERSION

    // Get Ansi path name
    FormPath(szPath, fWildCard );
    
    pszPath = szPath;
    //
    // Initialize the locale path buffer
    //
    if (dwEnglishBufSize == 0) {
        dwEnglishBufSize = (MAX_PATH + 1) * sizeof(TCHAR);

        szEnglishBuf = (LPTSTR) malloc(dwEnglishBufSize);
        if (szEnglishBuf == NULL) {
            dwEnglishBufSize = 0;
        }
    }

    if (szEnglishBuf != NULL) {
        //
        // Translate counter name from Localization into English
        //
        dwBufSize = dwEnglishBufSize;

        pdhStatus = PdhTranslate009Counter(
                        szPath,
                        szEnglishBuf,
                        &dwBufSize);

        if (pdhStatus == PDH_MORE_DATA) {
            pNewBuf = (LPTSTR)realloc(szEnglishBuf, dwBufSize);
            if (pNewBuf != NULL) {
                szEnglishBuf = pNewBuf;
                dwEnglishBufSize = dwBufSize;

                pdhStatus = PdhTranslate009Counter(
                                szPath,
                                szEnglishBuf,
                                &dwBufSize);
            }
        }

        if (pdhStatus == ERROR_SUCCESS) {
            pszPath = szEnglishBuf;
        }
    }

    pszWidePath = T2W(pszPath);

    if ( SMONCTRL_MAJ_VERSION == iVersMaj ) {
        GRAPHITEM_DATA3 ItemData;

        // Move properties to storage structure
        ItemData.m_rgbColor = m_rgbColor;
        ItemData.m_iWidth = m_iWidth;
        ItemData.m_iStyle = m_iStyle;
        ItemData.m_iScaleFactor = m_iScaleFactor;
 
        assert( 0 < lstrlen(pszWidePath ) );
        
        ItemData.m_nPathLength = lstrlen(pszWidePath);
        
        // Write structure to stream
        hr = pIStream->Write(&ItemData, sizeof(ItemData), NULL);
        if (FAILED(hr)) {
            goto ErrorOut;
        }

        // Write path name to stream
        hr = pIStream->Write(pszWidePath, ItemData.m_nPathLength*sizeof(WCHAR), NULL);
        if (FAILED(hr)) {
            goto ErrorOut;
        }
    }

ErrorOut:
    if (szEnglishBuf != NULL) {
        free(szEnglishBuf);
    }
    return hr;
}

HRESULT
CGraphItem::NullItemToStream (
    IN LPSTREAM pIStream,
    IN INT,// iVersMaj, 
    IN INT // iVersMin
    )
/*++

Routine Description:

    NulItemToStream writes a graph item structiure with a null path name
    to the stream. This is used to marked the end of the counter data in
    the control's saved state.

Arguments:

    pIStream - Pointer to stream interface

Return Value:

    HRESULT - S_OK or stream error

--*/
{
    GRAPHITEM_DATA3 ItemData;

    // Zero path length, other fields needn't be initialized
    ItemData.m_nPathLength = 0;

    // Write structure to stream
    return pIStream->Write(&ItemData, sizeof(ItemData), NULL);
}

HRESULT
CGraphItem::SaveToPropertyBag (
    IN IPropertyBag* pIPropBag,
    IN INT iIndex,
    IN BOOL bUserMode,
    IN INT, // iVersMaj, 
    IN INT // iVersMin 
    )
/*++

Routine Description:

    SaveToPropertyBag writes the graph item's properties to the provided property bag
    interface.  The history data is saved as part of the properties.

Arguments:

    pIPropBag - Pointer to property bag interface
    fWildCard
    iVersMaj
    iVersMin

Return Value:

    HRESULT - S_OK or property bag error

--*/
{
    HRESULT hr = S_OK;

    TCHAR   szPath[MAX_PATH];
    PHIST_CONTROL pHistCtrl;
    VARIANT vValue;
    TCHAR   szCounterName[16];
    TCHAR   szPropertyName[16+16];
    DWORD   dwCounterNameBytes;
    DWORD   dwCounterNameLength;
    LPTSTR  pszNext;
    LPTSTR  szEnglishBuf = NULL;
    DWORD   dwEnglishBufSize = 0;
    LPTSTR  pszPath;
    DWORD   dwBufSize;
    LPTSTR  pNewBuf;
    PDH_STATUS pdhStatus;

    USES_CONVERSION

    // Write properties

    // Write path name

    _stprintf ( szCounterName, _T("%s%05d."), _T("Counter"), iIndex );
    dwCounterNameLength = lstrlen (szCounterName); 
    dwCounterNameBytes = dwCounterNameLength * sizeof (TCHAR); 

    //
    // Generate full path name. (machine\object\instance\counter format)
    //
    FormPath(szPath, FALSE);

    pszPath = szPath;
    //
    // Initialize the locale path buffer
    //
    if (dwEnglishBufSize == 0) {
        dwEnglishBufSize = (MAX_PATH + 1) * sizeof(TCHAR);

        szEnglishBuf = (LPTSTR) malloc(dwEnglishBufSize);
        if (szEnglishBuf == NULL) {
            dwEnglishBufSize = 0;
        }
    }

    if (szEnglishBuf != NULL) {
        //
        // Translate counter name from Localization into English
        //
        dwBufSize = dwEnglishBufSize;

        pdhStatus = PdhTranslate009Counter(
                        szPath,
                        szEnglishBuf,
                        &dwBufSize);

        if (pdhStatus == PDH_MORE_DATA) {
            pNewBuf = (LPTSTR)realloc(szEnglishBuf, dwBufSize);
            if (pNewBuf != NULL) {
                szEnglishBuf = pNewBuf;
                dwEnglishBufSize = dwBufSize;

                pdhStatus = PdhTranslate009Counter(
                                szPath,
                                szEnglishBuf,
                                &dwBufSize);
            }
        }

        if (pdhStatus == ERROR_SUCCESS) {
            pszPath = szEnglishBuf;
        }
    }

    //
    // Save the counter path into property bag
    //
    memcpy ( szPropertyName, szCounterName, dwCounterNameBytes );
    pszNext = szPropertyName + dwCounterNameLength;
    lstrcpy ( pszNext, _T("Path") );
    
    hr = StringToPropertyBag (
            pIPropBag,
            szPropertyName,
            pszPath );


    if (szEnglishBuf != NULL) {
        free(szEnglishBuf);
    }

    // Write visual properties

    if ( SUCCEEDED( hr ) ){
        lstrcpy ( pszNext, _T("Color") );

        hr = IntegerToPropertyBag ( pIPropBag, szPropertyName, m_rgbColor );
    }

    if ( SUCCEEDED( hr ) ){
        lstrcpy ( pszNext, _T("Width") );

        hr = IntegerToPropertyBag ( pIPropBag, szPropertyName, m_iWidth );
    }

    if ( SUCCEEDED( hr ) ){
        lstrcpy ( pszNext, _T("LineStyle") );

        hr = IntegerToPropertyBag ( pIPropBag, szPropertyName, m_iStyle );
    }

    if ( SUCCEEDED( hr ) ){
        INT iLocalFactor = m_iScaleFactor;
        
        lstrcpy ( pszNext, _T("ScaleFactor") );
        
        if ( INT_MAX == iLocalFactor ) {
            // Save actual scale factor in case the counter cannot be 
            // validated when the property bag file is opened.
            // lDefaultScale is 0 if never initialized.
            iLocalFactor = m_CounterInfo.lDefaultScale;
        }
                    
        hr = IntegerToPropertyBag ( pIPropBag, szPropertyName, iLocalFactor );
    }

    // Write history data only if live display, data exists and not in design mode.  
    // Log data is rebuilt from the log file.  
    pHistCtrl = m_pCtrl->HistoryControl();

    if ( ( pHistCtrl->nSamples > 0) 
#if !_LOG_INCLUDE_DATA 
        && ( !pHistCtrl->bLogSource )
#endif
        && bUserMode ) {
        LPTSTR pszData = NULL;
        DWORD dwMaxStrLen = ( pHistCtrl->nMaxSamples * MAX_DOUBLE_TEXT_SIZE ) + 1;
        
        pszData = new TCHAR[ dwMaxStrLen ];      
        
        if  ( NULL == pszData ) {
            hr = E_OUTOFMEMORY;
        }

        // Write the current statistics.
        if ( SUCCEEDED(hr) ) {

            double dMin;
            double dMax;
            double dAvg;
            LONG lStatus;

            hr = GetStatistics ( &dMax, &dMin, &dAvg, &lStatus );

            if (SUCCEEDED(hr) && IsSuccessSeverity(lStatus)) {
                lstrcpy ( pszNext, _T("Minimum") );

                hr = DoubleToPropertyBag ( pIPropBag, szPropertyName, dMin );

                if ( SUCCEEDED(hr) ) {
                    lstrcpy ( pszNext, _T("Maximum") );

                    hr = DoubleToPropertyBag ( pIPropBag, szPropertyName, dMax );
                }
                if ( SUCCEEDED(hr) ) {
                    lstrcpy ( pszNext, _T("Average") );

                    hr = DoubleToPropertyBag ( pIPropBag, szPropertyName, dAvg );
                }
                if ( SUCCEEDED(hr) ) {
                    lstrcpy ( pszNext, _T("StatisticStatus") );

                    hr = IntegerToPropertyBag ( pIPropBag, szPropertyName, lStatus );
                }
            }
        }
        
        if ( SUCCEEDED(hr) ) {

            INT i;
            LPTSTR  pszTemp;
            HRESULT hrConvert = S_OK;
            double  dblValue;
            DWORD   dwTmpStat;
            DWORD   dwCurrentDataLength;
            DWORD   dwTempLength;
            LPTSTR  pszDataNext;

            lstrcpy ( pszData, _T("") );
            dwCurrentDataLength = 0;
            pszDataNext = pszData;

            for ( i = 0; 
                  ( S_OK == hrConvert ) && ( i < pHistCtrl->nSamples ); 
                  i++ ) {
                
                if ( ERROR_SUCCESS != HistoryValue(i, &dblValue, &dwTmpStat) ) {
                    dblValue = -1.0;
                } else if (!IsSuccessSeverity(dwTmpStat)) {
                    dblValue = -1.0;
                }


                VariantInit( &vValue );
                vValue.vt = VT_R8;
                vValue.dblVal = dblValue;

                hrConvert = VariantChangeTypeEx( &vValue, &vValue, LCID_SCRIPT, VARIANT_NOUSEROVERRIDE, VT_BSTR );
    
                pszTemp = W2T( vValue.bstrVal);
                dwTempLength = lstrlen ( pszTemp );
    
                // Extra TCHAR for NULL terminator
                if ( dwTempLength + dwCurrentDataLength + sizeof(TCHAR) > dwMaxStrLen ) {
                    TCHAR* pszNewData;
                    dwMaxStrLen *= 2;
                    // Allocate a new buffer
                    pszNewData = new TCHAR[ dwMaxStrLen ];      
        
                    if  ( NULL != pszNewData ) {
                        memcpy ( pszNewData, pszData, dwCurrentDataLength * sizeof (TCHAR) );
                        delete pszData;
                        pszData = pszNewData;
                        pszDataNext = pszData;
                    } else {
                        hr = E_OUTOFMEMORY;
                    }
                }

                if ( SUCCEEDED(hr)) {
                    if ( i > 0 ) {
                        lstrcpy ( pszDataNext, _T("\t") );
                        dwCurrentDataLength += 1;       // char count for _T("\t");
                        pszDataNext += 1;
                    }
                    memcpy ( pszDataNext, pszTemp, dwTempLength * sizeof(TCHAR) );
                    dwCurrentDataLength += dwTempLength;
                    pszDataNext += dwTempLength;
                }

                VariantClear( &vValue );
            }
            lstrcpy ( pszDataNext, _T("") );
        }

        lstrcpy ( pszNext, _T("Data") );

        hr = StringToPropertyBag (
                pIPropBag,
                szPropertyName,
                pszData );
                    
        if ( NULL != pszData ) {
            delete ( pszData );
        }
    }

    return hr;
}

HRESULT
CGraphItem::LoadFromPropertyBag (
    IN IPropertyBag* pIPropBag,
    IN IErrorLog*   pIErrorLog,
    IN INT iIndex,
    IN INT, // iVersMaj, 
    IN INT, // iVersMin 
    IN INT  iSampleCount
    )
/*++

Routine Description:

    LoadFromPropertyBag loads the graph item's properties from the provided property bag
    interface.  
Arguments:

    pIPropBag - Pointer to property bag interface
    iVersMaj
    iVersMin

Return Value:

    HRESULT - S_OK or property bag error

--*/
{
    HRESULT hr = S_OK;

    TCHAR   szCounterName[16];
    TCHAR   szPropertyName[16+16];
    OLE_COLOR clrValue;
    INT     iValue;
    LPTSTR  pszData = NULL;
    int     iBufSizeCurrent = 0;
    int     iBufSize;

    USES_CONVERSION

    _stprintf ( szCounterName, _T("%s%05d."), _T("Counter"), iIndex );

    // Read visual properties

    lstrcpy ( szPropertyName, szCounterName );
    lstrcat ( szPropertyName, _T("Color") );
    hr = OleColorFromPropertyBag ( pIPropBag, pIErrorLog, szPropertyName, clrValue );
    if ( SUCCEEDED(hr) ) {
        hr = put_Color ( clrValue );
    }

    lstrcpy ( szPropertyName, szCounterName );
    lstrcat ( szPropertyName, _T("Width") );
    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, szPropertyName, iValue );
    if ( SUCCEEDED(hr) ) {
        hr = put_Width ( iValue );
    }

    lstrcpy ( szPropertyName, szCounterName );
    lstrcat ( szPropertyName, _T("LineStyle") );
    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, szPropertyName, iValue );
    if ( SUCCEEDED(hr) ) {
        hr = put_LineStyle ( iValue );
    }
    
    lstrcpy ( szPropertyName, szCounterName );
    lstrcat ( szPropertyName, _T("ScaleFactor") );
    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, szPropertyName, iValue );
    if ( SUCCEEDED(hr) ) {
        hr = put_ScaleFactor ( iValue );
    }

    if ( 0 < iSampleCount ) {
                
        if ( NULL != m_pFmtCtr )
            delete m_pFmtCtr;

        m_pFmtCtr = new double[MAX_GRAPH_SAMPLES];      
    
        if ( NULL == m_pFmtCtr ) {
            hr = E_OUTOFMEMORY;
        } else {
            INT iFmtIndex;
            for (iFmtIndex = 0; iFmtIndex < MAX_GRAPH_SAMPLES; iFmtIndex++ ) {
                m_pFmtCtr[iFmtIndex] = -1.0;
            }
        }

        if ( SUCCEEDED(hr) ) {
            lstrcpy ( szPropertyName, szCounterName );
            lstrcat ( szPropertyName, _T("Data") );

            iBufSize = iBufSizeCurrent;

            hr = StringFromPropertyBag (
                    pIPropBag,
                    pIErrorLog,
                    szPropertyName,
                    pszData,
                    iBufSize );

            if ( SUCCEEDED(hr) && 
                 iBufSize > iBufSizeCurrent ) {
                if ( NULL != pszData ) {
                    delete pszData;
                }
                pszData = new TCHAR[ iBufSize ]; 

                if ( NULL == pszData ) {
                    hr = E_OUTOFMEMORY;
                } else {
                    lstrcpy ( pszData, _T("") );
                    
                    iBufSizeCurrent = iBufSize;

                    hr = StringFromPropertyBag (
                            pIPropBag,
                            pIErrorLog,
                            szPropertyName,
                            pszData,
                            iBufSize );
                }
            }
        }        

        // Read the samples in buffer order.
        if ( NULL != pszData && SUCCEEDED ( hr ) ) {
            INT iDataIndex;
            double dValue = 0;
            TCHAR* pNextData;
            TCHAR* pDataEnd;
            
            pNextData = pszData;
            pDataEnd = pszData + lstrlen(pszData);

            for ( iDataIndex = 0; iDataIndex < iSampleCount; iDataIndex++ ) {
                if ( pNextData < pDataEnd ) {
                    hr = GetNextValue ( pNextData, dValue );
                } else {
                    hr = E_FAIL;
                }

                if ( SUCCEEDED(hr) ) {
                    SetHistoryValue ( iDataIndex, dValue );                    
                } else {
                    SetHistoryValue ( iDataIndex, -1.0 );                    
                    // iSampleCount = 0;
                    // Control loaded fine, just no data.
                    hr = NOERROR;
                }
            }        
        }
        
        if ( NULL != pszData ) {
            delete pszData;
        }
        
        // Read the current statistics.
        lstrcpy ( szPropertyName, szCounterName );
        lstrcat ( szPropertyName, _T("Maximum") );
        hr = DoubleFromPropertyBag ( pIPropBag, pIErrorLog, szPropertyName, m_dFmtMax );

        lstrcpy ( szPropertyName, szCounterName );
        lstrcat ( szPropertyName, _T("Minimum") );            
        hr = DoubleFromPropertyBag ( pIPropBag, pIErrorLog, szPropertyName, m_dFmtMin );

        lstrcpy ( szPropertyName, szCounterName );
        lstrcat ( szPropertyName, _T("Average") );
        hr = DoubleFromPropertyBag ( pIPropBag, pIErrorLog, szPropertyName, m_dFmtAvg );

        lstrcpy ( szPropertyName, szCounterName );
        lstrcat ( szPropertyName, _T("StatisticStatus") );
        hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, szPropertyName, (INT&)m_lFmtStatus );
    }

    return hr;
}

HRESULT
CGraphItem::AddToQuery (
    IN HQUERY hQuery
    )
/*++

Routine Description:

    AddToQuery adds a counter to the provided query based on the item's
    pathname. It also allocates an array of raw counter value structures for
    holding the counter's sample history.

Arguments:

    hQuery - Handle to query

Return Value:

    Boolean status - TRUE = success

--*/
{
    HCOUNTER    hCounter;
    INT         i;
    HRESULT     hr;
    TCHAR       achPath[MAX_PATH];
    PDH_COUNTER_INFO    ci;
    DWORD       size;

    PHIST_CONTROL pHistCtrl = m_pCtrl->HistoryControl();

    // Can't add if already in query
    if (m_hCounter != NULL)
        return E_FAIL;

    // Allocate memory for maximum sample count
    if (pHistCtrl->nMaxSamples > 0) {

        // if log data
        if (pHistCtrl->bLogSource) {

            // allocate space for formatted values
            m_pLogData =  new LOG_ENTRY_DATA[pHistCtrl->nMaxSamples];
            if (m_pLogData == NULL)
                return E_OUTOFMEMORY;

            // Clear the statistics
            m_dLogMax = 0.0;
            m_dLogMin = 0.0;
            m_dLogAvg = 0.0;
        }
        else {
            // else allocate raw value space
            m_pRawCtr = new PDH_RAW_COUNTER[pHistCtrl->nMaxSamples];
            if ( NULL == m_pRawCtr )
                return E_OUTOFMEMORY;

            // Clear all status flags
            for (i=0; i < pHistCtrl->nMaxSamples; i++)
                m_pRawCtr[i].CStatus = PDH_CSTATUS_INVALID_DATA;
        }
    }

    // Create the counter object
    FormPath(achPath, FALSE);
    hr = PdhAddCounter(hQuery, achPath, 0, &hCounter);
    if (IsErrorSeverity(hr)) {
        delete m_pRawCtr;
        m_pRawCtr = NULL;
        return hr;
    }

    size = sizeof(ci);
    hr = PdhGetCounterInfo (
        hCounter,
        FALSE,
        &size,
        &ci);

    if (hr == ERROR_SUCCESS)  {
        m_CounterInfo = ci;
        if ( INT_MAX == m_iScaleFactor ) {
            m_dScale = pow ((double)10.0f, (double)ci.lDefaultScale);
        }
    }

    m_hCounter = hCounter;

    return NOERROR;
}


HRESULT
CGraphItem::RemoveFromQuery (
    VOID
    )
/*++

Routine Description:

    RemoveFromQuery deletes the item's counter and releases its history array.

Arguments:

    None.

Return Value:

    Boolean status - TRUE = success

--*/
{
    // If no counter handle, not attached to query
    if (m_hCounter == NULL)
        return S_FALSE;

    // Delete the counter
    PdhRemoveCounter(m_hCounter);
    m_hCounter = NULL;

    // Free the buffers
    if (m_pLogData) {
        delete m_pLogData;
        m_pLogData = NULL;
    }

    if (m_pRawCtr) {
        delete m_pRawCtr;
        m_pRawCtr = NULL;
    }

    if (m_pFmtCtr) {
        delete m_pFmtCtr;
        m_pFmtCtr = NULL;
    }

    return NOERROR;
}

void
CGraphItem::ClearHistory ( void )
/*++

Routine Description:

    ClearHistory resets the raw counter buffer values to Invalid.

Arguments:
    None.

Return Value:
    None.
--*/
{
    INT i;

    // Clear all status flags
    if ( NULL != m_pRawCtr ) {
        for (i=0; i < m_pCtrl->HistoryControl()->nMaxSamples; i++) {
            m_pRawCtr[i].CStatus = PDH_CSTATUS_INVALID_DATA;
        }
    }
}

VOID
CGraphItem::UpdateHistory (
    IN BOOL bValidSample
    )
/*++

Routine Description:

    UpdateHistory reads the raw value for the counter and stores it in the
    history slot specified by the history control.

Arguments:

    bValidSample - True if raw value is available, False if missed sample

Return Value:

    None.

--*/
{
    DWORD   dwCtrType;

    // Make sure there is a counter handle
    if (m_hCounter == NULL)
        return;

    if (bValidSample) {
        // Read the raw value
        if ( NULL != m_pRawCtr ) {
            PdhGetRawCounterValue(m_hCounter, &dwCtrType,
                                &m_pRawCtr[m_pCtrl->HistoryControl()->iCurrent]);
        }
    } else {
        // Mark value failed
        if ( NULL != m_pRawCtr ) {
            m_pRawCtr[m_pCtrl->HistoryControl()->iCurrent].CStatus = PDH_CSTATUS_INVALID_DATA;
        }
    }
}

PDH_STATUS
CGraphItem::HistoryValue (
    IN  INT iIndex,
    OUT double *pdValue,
    OUT DWORD *pdwStatus
    )
/*++

Routine Description:

    HistoryValue computes a formated sample value from the selected raw history
    sample. The calculation is actually based on the the specified sample plus
    the preceding sample.

Arguments:
    iIndex - Index of desired sample (0 = current, 1 = previous, ...)
    pdValue - Pointer to return value
    pdwStatus - Pointer to return counter status (PDH_CSTATUS_...)

Return Value:

    Error status

--*/
{
    PDH_STATUS  stat = ERROR_INVALID_PARAMETER;
    INT     iPrevIndex;
    INT     iCurrIndex;
    PDH_FMT_COUNTERVALUE    FmtValue;
    PHIST_CONTROL   pHistCtrl = m_pCtrl->HistoryControl();


    // Check for negative index
    if ( iIndex >= 0 ) {
        // If sample not available from cache or data, return invalid data status
        if ( NULL == m_pFmtCtr 
                && ( m_hCounter == NULL || iIndex + 1 >= pHistCtrl->nSamples ) )
        {
            *pdwStatus = PDH_CSTATUS_INVALID_DATA;
            *pdValue = 0.0;
            stat = ERROR_SUCCESS;
        } else {
        
            // if log source, index back from last sample
            if (m_pCtrl->IsLogSource()) {
                *pdValue = m_pLogData[pHistCtrl->nSamples - iIndex - 1].m_dAvg;
                *pdwStatus = (*pdValue >= 0.0) ? PDH_CSTATUS_VALID_DATA : PDH_CSTATUS_INVALID_DATA;
                stat = ERROR_SUCCESS;
            } else {
                // Determine history array index of sample
                iCurrIndex = pHistCtrl->iCurrent - iIndex;
                if (iCurrIndex < 0)
                    iCurrIndex += pHistCtrl->nMaxSamples;

                // Check to determine if loading from property bag
                if ( NULL == m_pFmtCtr ) {
                    // Need previous sample as well
                    if (iCurrIndex > 0)
                        iPrevIndex = iCurrIndex - 1;
                    else
                        iPrevIndex = pHistCtrl->nMaxSamples - 1;

                    // Compute the formatted value
                    if ( NULL != m_pRawCtr ) {
                        stat = PdhCalculateCounterFromRawValue(m_hCounter, PDH_FMT_DOUBLE | PDH_FMT_NOCAP100,
                                                &m_pRawCtr[iCurrIndex], &m_pRawCtr[iPrevIndex],
                                                &FmtValue);
                        // Return value and status
                        *pdValue = FmtValue.doubleValue;
                        *pdwStatus = FmtValue.CStatus;
                    } else {
                        stat = ERROR_GEN_FAILURE;       // Todo:  More specific error
                    }
                } else {
                    // Loading from property bag
                    *pdValue = m_pFmtCtr[iCurrIndex];
                    if ( 0 <= m_pFmtCtr[iCurrIndex] ) {
                        *pdwStatus = ERROR_SUCCESS;
                    } else {
                        *pdwStatus = PDH_CSTATUS_INVALID_DATA;
                    }
                    stat = ERROR_SUCCESS;
                }
            }
        }
    }
    return stat;
}

void
CGraphItem::SetHistoryValue (
    IN  INT iIndex,
    OUT double dValue
    )
/*++

Routine Description:

    SetHistoryValue loads a formated sample value for the specified sample index.
    This method is used when loading the control from a property bag.

Arguments:
    iIndex - Index of desired sample (0 = current, 1 = previous, ...)
    dValue - Value

Return Value:

    Error status

--*/
{
    PHIST_CONTROL   pHistCtrl = m_pCtrl->HistoryControl();
    INT iRealIndex;

    // Check for negative index
    if ( (iIndex < 0) || ( iIndex >= pHistCtrl->nMaxSamples) ) {
        return;
    }

    if ( NULL == m_pFmtCtr ) {
        return;
    }
 
    // if log source, index back from last sample
    if (m_pCtrl->IsLogSource()) {
        return;
    } else {
        // Determine history array index of sample
        iRealIndex = pHistCtrl->iCurrent - iIndex;
        if (iRealIndex < 0)
            iRealIndex += pHistCtrl->nSamples;

        m_pFmtCtr[iRealIndex] = dValue;
    }

    return;
}

PDH_STATUS
CGraphItem::GetLogEntry(
    const INT iIndex,
    double *dMin,
    double *dMax,
    double *dAvg,
    DWORD   *pdwStatus
    )
{
    INT iLocIndex = iIndex;

    *dMin = -1.0;
    *dMax = -1.0;
    *dAvg = -1.0;
    *pdwStatus = PDH_CSTATUS_INVALID_DATA;

    if (m_pLogData == NULL)
        return PDH_NO_DATA;

    if (iLocIndex < 0 || iLocIndex >= m_pCtrl->HistoryControl()->nMaxSamples)
        return PDH_INVALID_ARGUMENT;

    // Subtract 1 because array is zero-based
    // Subtract another 1 because ??
    iLocIndex = ( m_pCtrl->HistoryControl()->nMaxSamples - 2 ) - iIndex;

    if (m_pLogData[iLocIndex].m_dMax < 0.0) {
        *pdwStatus = PDH_CSTATUS_INVALID_DATA;
    } else {
        *dMin = m_pLogData[iLocIndex].m_dMin;
        *dMax = m_pLogData[iLocIndex].m_dMax;
        *dAvg = m_pLogData[iLocIndex].m_dAvg;
        *pdwStatus = PDH_CSTATUS_VALID_DATA;
    }

    return ERROR_SUCCESS;
}

PDH_STATUS
CGraphItem::GetLogEntryTimeStamp(
    const INT   iIndex,
    LONGLONG&   rLastTimeStamp,
    DWORD       *pdwStatus
    )
{
    INT iLocIndex = iIndex;

    rLastTimeStamp = 0;
    *pdwStatus = PDH_CSTATUS_INVALID_DATA;

    if (m_pLogData == NULL)
        return PDH_NO_DATA;

    if (iIndex < 0 || iIndex >= m_pCtrl->HistoryControl()->nMaxSamples)
        return PDH_INVALID_ARGUMENT;

    if ( ( MIN_TIME_VALUE == *((LONGLONG*)&m_pLogData[iLocIndex].m_LastTimeStamp) )
            || ( 0 > *((LONGLONG*)&m_pLogData[iLocIndex].m_dMax) ) ) {
        *pdwStatus = PDH_CSTATUS_INVALID_DATA;
    } else {            
        *pdwStatus = PDH_CSTATUS_VALID_DATA;
    }

    rLastTimeStamp = *((LONGLONG*)&m_pLogData[iLocIndex].m_LastTimeStamp);

    return ERROR_SUCCESS;
}

void
CGraphItem::SetLogEntry(
    const INT iIndex,
    const double dMin,
    const double dMax,
    const double dAvg )
{  
    if (m_pLogData) {
        m_pLogData[iIndex].m_dMin = dMin;
        m_pLogData[iIndex].m_dMax = dMax;                         
        m_pLogData[iIndex].m_dAvg = dAvg;
    }
}

void
CGraphItem::SetLogEntryTimeStamp (
    const INT iIndex,
    const FILETIME& rLastTimeStamp )
{  
    if (m_pLogData) {
        m_pLogData[iIndex].m_LastTimeStamp.dwLowDateTime = rLastTimeStamp.dwLowDateTime;
        m_pLogData[iIndex].m_LastTimeStamp.dwHighDateTime = rLastTimeStamp.dwHighDateTime;
    }
}


HRESULT
CGraphItem::GetValue(
    OUT double *pdValue,
    OUT long *plStat
    )
/*++

Routine Description:

    get_Value returns the most recent sample value for the counter.

Arguments:
    pdValue - Pointer to returned value
    dlStatus - Pointer to returned counter status (PDH_CSTATUS_...)

Return Value:

    HRESULT

--*/
{
    DWORD   dwTmpStat;

    // Convert PDH status to HRESULT
    if (HistoryValue(0, pdValue, &dwTmpStat) != 0)
        return E_FAIL;

    *plStat = dwTmpStat;
    return NOERROR;
}


HRESULT
CGraphItem::GetStatistics (
    OUT double *pdMax,
    OUT double *pdMin,
    OUT double *pdAvg,
    OUT LONG  *plStatus
    )
/*++

Routine Description:

    GetStatistics computes the max, min, and average values for the sample
    history.

Arguments:

    pdMax - Pointer to returned max value
    pdMax - Pointer to returned min value
    pdMax - Pointer to returned average value
    plStatus - Pointer to return counter status (PDH_CSTATUS_...)

Return Value:

    HRESULT

--*/
{
    HRESULT hr = NOERROR;
    PDH_STATUS  stat = ERROR_SUCCESS;
    PDH_STATISTICS  StatData;
    INT     iFirst;
    PHIST_CONTROL pHistCtrl;

    // If no data collected, return invalid data status
    if ( NULL == m_hCounter ) {
        *plStatus = PDH_CSTATUS_INVALID_DATA;
    } else {
        if (m_pCtrl->IsLogSource()) {

            if (m_pLogData) {
                *pdMax = m_dLogMax;
                *pdMin = m_dLogMin;
                *pdAvg = m_dLogAvg;

                *plStatus = PDH_CSTATUS_VALID_DATA;
            } else {
                *plStatus = PDH_CSTATUS_INVALID_DATA;
            }
        } else {

            if ( NULL == m_pFmtCtr ) {
                pHistCtrl = m_pCtrl->HistoryControl();

                ZeroMemory ( &StatData, sizeof ( PDH_STATISTICS ) );

                // Determine index of oldest sample
                if (pHistCtrl->iCurrent < pHistCtrl->nSamples - 1) {
                    iFirst = pHistCtrl->iCurrent + 1;
                } else {
                    iFirst = 0;
                }

                // Compute statistics over all samples
                //  Note that max sample count is passed (i.e., buffer length)
                //  not the number of actual samples
                if ( NULL != m_pRawCtr ) {
                    stat = PdhComputeCounterStatistics (m_hCounter, PDH_FMT_DOUBLE | PDH_FMT_NOCAP100,
                            iFirst, pHistCtrl->nMaxSamples, m_pRawCtr, &StatData );
                    if ( 0 != stat )
                        hr = E_FAIL;
                } else {
                    hr = E_FAIL;
                }
                
                if ( SUCCEEDED ( hr ) ) {
                    *plStatus = StatData.mean.CStatus;
                    *pdMin = StatData.min.doubleValue;
                    *pdMax = StatData.max.doubleValue;
                    *pdAvg = StatData.mean.doubleValue;
                }
            } else {
                // Data is cached from property bag.
                *pdMax = m_dFmtMax;
                *pdMin = m_dFmtMin;
                *pdAvg = m_dFmtAvg;
                *plStatus = m_lFmtStatus;
            }
        }
    }

    return hr;
}

void
CGraphItem::SetStatistics (
    IN double dMax,
    IN double dMin,
    IN double dAvg,
    IN LONG   lStatus
    )
/*++

Routine Description:

    SetStatistics sets the max, min, and average values for the sample
    history.  It is used by LoadFromPropertyBag only.

Arguments:

    dMax - max value
    dMin - min value
    dAvg - average value
    lStatus - counter status (PDH_CSTATUS_...)

Return Value:

    HRESULT

--*/
{
    if (!m_pCtrl->IsLogSource()) {
        m_dFmtMax = dMax;
        m_dFmtMin = dMin;
        m_dFmtAvg = dAvg;
        m_lFmtStatus = lStatus;
    }
}


/*
 * CGraphItem::QueryInterface
 * CGraphItem::AddRef
 * CGraphItem::Release
 */

STDMETHODIMP CGraphItem::QueryInterface(REFIID riid
    , LPVOID *ppv)
    {

    *ppv = NULL;

    if (riid == IID_ICounterItem || riid == IID_IUnknown)
        {
        *ppv = this;
        }
    else if (riid == DIID_DICounterItem)
        {
        if (m_pImpIDispatch == NULL)
            {
            m_pImpIDispatch = new CImpIDispatch(this, this);
            if (m_pImpIDispatch == NULL)
                return E_OUTOFMEMORY;

            m_pImpIDispatch->SetInterface(DIID_DICounterItem, this);
            *ppv = m_pImpIDispatch;
            }
        else
            {
            *ppv = m_pImpIDispatch;
            }
        }
    else
        {
        return E_NOINTERFACE;
        }

    ((LPUNKNOWN)*ppv)->AddRef();
    return NOERROR;
    }

STDMETHODIMP_(ULONG) CGraphItem::AddRef(void)
    {
    return ++m_cRef;
    }

STDMETHODIMP_(ULONG) CGraphItem::Release(void)
    {
    if (--m_cRef == 0)
        {
        delete this;
        return 0;
        }

    return m_cRef;
    }

// Get/Put Color
STDMETHODIMP CGraphItem::put_Color (
    IN OLE_COLOR Color
    )
{
    COLORREF rgbColor;
    HRESULT hReturn;

    hReturn = OleTranslateColor(Color, NULL, &rgbColor);    

    if ( S_OK == hReturn ) {
        m_rgbColor = rgbColor;

        InvalidatePen();
        InvalidateBrush();
    }

    return hReturn;
}

STDMETHODIMP CGraphItem::get_Color (
    OUT OLE_COLOR *pColor
    )
{
    *pColor = m_rgbColor;
    return NOERROR;
}

// Get/Put Width
STDMETHODIMP CGraphItem::put_Width (
    IN INT iWidthInPixels)
{
    if ( ( iWidthInPixels > 0 ) && (iWidthInPixels <= NumWidthIndices() ) ) {
        m_iWidth = iWidthInPixels;
        
        InvalidatePen();
        return NOERROR;
    } else {
        return E_INVALIDARG;
    }
}

STDMETHODIMP CGraphItem::get_Width (
    OUT INT* piWidthInPixels
    )
{
    *piWidthInPixels = m_iWidth;
    return NOERROR;
}

// Get/Put Line Style
STDMETHODIMP CGraphItem::put_LineStyle (
    IN INT iLineStyle
    )
{
    if ( ( iLineStyle >= 0 ) && (iLineStyle < NumStyleIndices() ) ) {
        m_iStyle = iLineStyle;
        InvalidatePen();
        return NOERROR;
    } else {
        return E_INVALIDARG;
    }
}

STDMETHODIMP CGraphItem::get_LineStyle (
    OUT INT* piLineStyle
    )
{
    *piLineStyle = m_iStyle;
    return NOERROR;
}

// Get/Put Scale
STDMETHODIMP CGraphItem::put_ScaleFactor (
    IN INT iScaleFactor
    )
{
    HRESULT hr = NOERROR;

    if ( ( INT_MAX == iScaleFactor ) 
        || ( ( iScaleFactor >= PDH_MIN_SCALE ) && (iScaleFactor <= PDH_MAX_SCALE) ) ) {
        PDH_COUNTER_INFO    ci;
        DWORD       size;

        m_iScaleFactor = iScaleFactor;

        if ( INT_MAX == iScaleFactor  )
        {
            if ( NULL != Handle() ) {
                size = sizeof(ci);
                hr = PdhGetCounterInfo (
                    Handle(),
                    FALSE,
                    &size,
                    &ci);

                if (hr == ERROR_SUCCESS)  {
                    m_dScale = pow ((double)10.0f, (double)ci.lDefaultScale);
                    m_CounterInfo = ci;
    
                }
            } else {
                // m_dScale remains at previous value (default=1)
                hr = PDH_INVALID_HANDLE;
            }
        }
        else
        {
            m_dScale = pow ((double)10.0, (double)iScaleFactor);
            hr = NOERROR;
        }
    } else {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CGraphItem::get_ScaleFactor (
    OUT INT* piScaleFactor
    )
{
    *piScaleFactor = m_iScaleFactor;
    return NOERROR;
}


STDMETHODIMP CGraphItem::get_Path (
    OUT BSTR* pstrPath
    )
{
    TCHAR achPath[MAX_PATH];

    USES_CONVERSION

    FormPath(achPath, FALSE);
    *pstrPath = SysAllocString(T2W(achPath));

    if ( NULL == *pstrPath ) {
        return E_OUTOFMEMORY;
    } else {
        return NOERROR;
    }
}

STDMETHODIMP CGraphItem::get_Value (
    OUT double* pdValue
    )
{
    DWORD   dwTmpStat;
    double  dValue;

    // Convert PDH status to HRESULT
    if (HistoryValue(0, &dValue, &dwTmpStat) != 0) {
        dValue = -1.0;
    }
    else
        if (!IsSuccessSeverity(dwTmpStat)) {
        dValue = -1.0;
    }

    *pdValue = dValue;

    return NOERROR;
}

HPEN CGraphItem::Pen(void)
{
    // if pen not valid
    if (m_hPen == NULL)
    {
        // create a new one based on current attributes
        m_hPen = CreatePen(m_iStyle, m_iWidth, m_rgbColor);

        // if can't do it, use a stock object (this can't fail)
        if (m_hPen == NULL)
            m_hPen = (HPEN)GetStockObject(BLACK_PEN);
    }

    return m_hPen;
}

HBRUSH CGraphItem::Brush(void)
{
    // if brush is not valid
    if (m_hBrush == NULL)
    {
        m_hBrush = CreateSolidBrush(m_rgbColor);

        if (m_hBrush == NULL)
            m_hBrush = (HBRUSH)GetStockObject(BLACK_BRUSH);
    }

    return m_hBrush;
}

void CGraphItem::InvalidatePen(void)
{
    if (m_hPen != NULL)
    {
        DeleteObject(m_hPen);
        m_hPen = NULL;
    }
}

void CGraphItem::InvalidateBrush(void)
{
    if (m_hBrush != NULL)
    {
        DeleteObject(m_hBrush);
        m_hBrush = NULL;
    }
}


CGraphItem*
CGraphItem::Next (
    void
    )
{
    PCInstanceNode pInstance;
    PCObjectNode   pObject;
    PCMachineNode  pMachine;

    if (m_pNextItem)
        return m_pNextItem;
    else if ( NULL != m_pInstance->Next()) {
        pInstance = m_pInstance->Next();
        return pInstance->FirstItem();
    } else if ( NULL != m_pInstance->m_pObject->Next()) {
        pObject = m_pInstance->m_pObject->Next();
        return pObject->FirstInstance()->FirstItem();
    } else if ( NULL != m_pInstance->m_pObject->m_pMachine->Next()) {
        pMachine = m_pInstance->m_pObject->m_pMachine->Next();
        return pMachine->FirstObject()->FirstInstance()->FirstItem();
    } else {
        return NULL;
    }
}


void
CGraphItem::FormPath (
    LPTSTR  pszPath,
    BOOL    fWildCard
    )
{
    LPTSTR pszNext = pszPath;

    if ( m_fLocalMachine )
        pszPath[0] = 0;
    else
        lstrcpy ( pszPath, Machine()->Name() );
    
    pszNext = pszNext + lstrlen ( pszPath );

    lstrcpy ( pszNext, _T("\\") );
    pszNext += 1;                // Length of _T("\\");

    lstrcpy ( pszNext, Object()->Name() );
    pszNext += lstrlen ( Object()->Name() );

    if (fWildCard) {
        lstrcpy ( pszNext,_T("(*)") );
        pszNext += 3;           // Length of _T("(*)");
    }
    else if ( Instance()->Name()[0] ) {
        lstrcpy ( pszNext,_T("("));
        pszNext += 1;                // Length of _T("(");

        lstrcpy ( pszNext,Instance()->Name() );
        pszNext += lstrlen ( Instance()->Name() );

        lstrcpy ( pszNext,_T(")") );
        pszNext += 1;                // Length of _T("(");
    }

    lstrcpy ( pszNext, _T("\\") );
    pszNext += 1;                // Length of _T("\\");

    lstrcpy ( pszNext,Counter()->Name() );
}


void
CGraphItem::Delete (
    BOOL bPropogateUp
    )
//
// This method just provides a convenient access to the DeleteCounter method
// of the control when you only have a pointer to the graph item.
//
{
    m_pCtrl->DeleteCounter(this, bPropogateUp);
}



HRESULT
CGraphItem::GetNextValue (
    TCHAR*& pszNext,
    double& rdValue )
{
    HRESULT hr = NOERROR;
    TCHAR szValue[MAX_DOUBLE_TEXT_SIZE + 1];
    INT iDataLen;
    INT iLen;

    VARIANT vValue;
    
    rdValue = -1.0;

    iDataLen = wcscspn (pszNext, L"\t");

    iLen = min ( iDataLen, MAX_DOUBLE_TEXT_SIZE );

    lstrcpyn ( szValue, pszNext, iLen + 1 );

    szValue[iLen] = L'\0';

    VariantInit( &vValue );
    vValue.vt = VT_BSTR;

    vValue.bstrVal = SysAllocString ( szValue );
    hr = VariantChangeTypeEx( &vValue, &vValue, LCID_SCRIPT, VARIANT_NOUSEROVERRIDE, VT_R8 );

    if ( SUCCEEDED(hr) ) {
        rdValue = vValue.dblVal;
    }

    pszNext += iDataLen + 1  ;
    VariantClear( &vValue );

    return hr;

}

BOOL
CGraphItem::IsRateCounter ( void )
{
    BOOL bReturn = FALSE;
    DWORD   dwRateMask = PERF_TYPE_COUNTER | PERF_COUNTER_RATE;
    DWORD   dwFractionMask = PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION;

    if ( dwRateMask == ( m_CounterInfo.dwType & dwRateMask ) ) {
        bReturn = TRUE;
    }
    else if ( dwFractionMask == ( m_CounterInfo.dwType & dwFractionMask ) ) {
        bReturn = TRUE;
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\hatchwnd.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    hatchwnd.h

Abstract:

    Implementation of the CHatchWin class.  CHatchWin when used 
    as a parent window creates a thin hatch border around 
    the child window.

--*/


#include <windows.h>
#include <oleidl.h>
#include "hatchwnd.h"
#include "resource.h"
#include "globals.h"

// Hit codes for computing handle code (Y_CODE + 3 * X_CODE)
#define Y_TOP       0
#define Y_MIDDLE    1
#define Y_BOTTOM    2
#define X_LEFT      0
#define X_MIDDLE    1
#define X_RIGHT     2
#define NO_HIT     -1

// Sizing flags
#define SIZING_TOP       0x0001
#define SIZING_BOTTOM    0x0002
#define SIZING_LEFT      0x0004
#define SIZING_RIGHT     0x0008
#define SIZING_ALL       0x0010

// Sizing flags lookup (indexed by handle code)
static UINT uSizingTable[9] = {
    SIZING_LEFT | SIZING_TOP,    SIZING_TOP,    SIZING_RIGHT | SIZING_TOP,
    SIZING_LEFT,                 SIZING_ALL,    SIZING_RIGHT,
    SIZING_LEFT | SIZING_BOTTOM, SIZING_BOTTOM, SIZING_BOTTOM | SIZING_RIGHT };

// Cursor ID lookup (indexed by handle code)
static UINT uCursIDTable[9] = {
    IDC_CURS_NWSE, IDC_CURS_NS,     IDC_CURS_NESW,
    IDC_CURS_WE,   IDC_CURS_MOVE,   IDC_CURS_WE,
    IDC_CURS_NESW, IDC_CURS_NS,     IDC_CURS_NWSE };

// Cursors (indexed by cursor ID)
static HCURSOR hCursTable[IDC_CURS_MAX - IDC_CURS_MIN + 1];

#define IDTIMER_DEBOUNCE 1
#define MIN_SIZE 8
        
// Brush patterns
static WORD wHatchBmp[]={0x11, 0x22, 0x44, 0x88, 0x11, 0x22, 0x44, 0x88};
static WORD wGrayBmp[]={0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa};

static HBRUSH   hBrHatch;
static HBRUSH   hBrGray;

// System parameters
static INT iBorder;
static INT iDragMinDist;
static INT iDragDelay;

static INT fLocalInit = FALSE;

// Forward refs
void DrawShading(HDC, LPRECT);
void DrawHandles (HDC, LPRECT);
void DrawDragRgn (HWND, HRGN);
HRGN CreateDragRgn(LPRECT);

TCHAR   szHatchWinClassName[] = TEXT("Hatchwin") ;

/*
 * CHatchWin:CHatchWin
 * CHatchWin::~CHatchWin
 *
 * Constructor Parameters:
 *  hInst           HINSTANCE of the application we're in.
 */

CHatchWin::CHatchWin(
    VOID
    )
{
    m_hWnd = NULL;
    m_hWndParent = NULL;
    m_hWndKid = NULL;
    m_hWndAssociate = NULL;
    m_hRgnDrag = NULL;

    m_iBorder = 0;
    m_uID = 0;
    m_uDragMode = DRAG_IDLE;
    m_bResizeInProgress = FALSE;
    SetRect(&m_rcPos, 0, 0, 0, 0);
    SetRect(&m_rcClip, 0, 0, 0, 0);

    return;
    }


CHatchWin::~CHatchWin(void)
    {

    if (NULL != m_hWnd)
        DestroyWindow(m_hWnd);

    return;
    }

/*
 * CHatchWin::Init
 *
 * Purpose:
 *  Instantiates a hatch window within a given parent with a
 *  default rectangle.  This is not initially visible.
 *
 * Parameters:
 *  hWndParent      HWND of the parent of this window
 *  uID             UINT identifier for this window (send in
 *                  notifications to associate window).
 *  hWndAssoc       HWND of the initial associate.
 *
 * Return Value:
 *  BOOL            TRUE if the function succeeded, FALSE otherwise.
 */

BOOL CHatchWin::Init(HWND hWndParent, UINT uID, HWND hWndAssoc)
    {
    INT i;
    HBITMAP     hBM;
    WNDCLASS    wc;
    LONG_PTR    lptrID = 0;

    BEGIN_CRITICAL_SECTION

    // If first time through
    if (pstrRegisteredClasses[HATCH_WNDCLASS] == NULL) {

        // Register the hatch window class
        wc.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
        wc.hInstance     = g_hInstance;
        wc.cbClsExtra    = 0;
        wc.lpfnWndProc   = (WNDPROC)HatchWndProc;
        wc.cbWndExtra    = CBHATCHWNDEXTRA;
        wc.hIcon         = NULL;
        wc.hCursor       = NULL;
        wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
        wc.lpszMenuName  = NULL;
        wc.lpszClassName = szHatchWinClassName;

        if (RegisterClass(&wc)) {

            // Save class name for later unregistering
            pstrRegisteredClasses[HATCH_WNDCLASS] = szHatchWinClassName;

            // Get system metrics
            iBorder = GetProfileInt(TEXT("windows"),
                                    TEXT("OleInPlaceBorderWidth"), 4);
            iDragMinDist = GetProfileInt(TEXT("windows"),
                                        TEXT("DragMinDist"), DD_DEFDRAGMINDIST);
            iDragDelay = GetProfileInt(TEXT("windows"),
                                        TEXT("DragDelay"), DD_DEFDRAGDELAY);

            // Load the arrow cursors
            for (i = IDC_CURS_MIN; i <= IDC_CURS_MAX; i++) {
                hCursTable[i - IDC_CURS_MIN] = LoadCursor(g_hInstance, MAKEINTRESOURCE(i));
            }

            // Create brushes for hatching and drag region
            hBM = CreateBitmap(8, 8, 1, 1, wHatchBmp);
            if ( NULL != hBM ) {
                hBrHatch = CreatePatternBrush(hBM);
                DeleteObject(hBM);
            }

            hBM = CreateBitmap(8, 8, 1, 1, wGrayBmp);
            if ( NULL != hBM ) {
                hBrGray = CreatePatternBrush(hBM);
                DeleteObject(hBM);
            }
        }
    }
    
    END_CRITICAL_SECTION

    if (pstrRegisteredClasses[HATCH_WNDCLASS] == NULL)
        return FALSE;

    lptrID = uID;

    m_hWnd = CreateWindowEx(
                WS_EX_NOPARENTNOTIFY, 
                szHatchWinClassName,
                szHatchWinClassName, 
                WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
                0, 
                0, 
                100, 
                100, 
                hWndParent, 
                (HMENU)lptrID, 
                g_hInstance, 
                this);

    m_uID = uID;
    m_hWndAssociate = hWndAssoc;
    m_hWndParent = hWndParent;


    return (NULL != m_hWnd);
}

/*
 * CHatchWin::HwndAssociateSet
 * CHatchWin::HwndAssociateGet
 *
 * Purpose:
 *  Sets (Set) or retrieves (Get) the associate window of the
 *  hatch window.
 *
 * Parameters: (Set only)
 *  hWndAssoc       HWND to set as the associate.
 *
 * Return Value:
 *  HWND            Previous (Set) or current (Get) associate
 *                  window.
 */

HWND CHatchWin::HwndAssociateSet(HWND hWndAssoc)
    {
    HWND hWndT = m_hWndAssociate;

    m_hWndAssociate = hWndAssoc;
    return hWndT;
    }

HWND CHatchWin::HwndAssociateGet(void)
    {
    return m_hWndAssociate;
    }


/*
 * CHatchWin::RectsSet
 *
 * Purpose:
 *  Changes the size and position of the hatch window and the child
 *  window within it using a position rectangle for the child and
 *  a clipping rectangle for the hatch window and child.  The hatch
 *  window occupies prcPos expanded by the hatch border and clipped
 *  by prcClip.  The child window is fit to prcPos to give the
 *  proper scaling, but it clipped to the hatch window which
 *  therefore clips it to prcClip without affecting the scaling.
 *
 * Parameters:
 *  prcPos          LPRECT providing the position rectangle.
 *  prcClip         LPRECT providing the clipping rectangle.
 *
 * Return Value:
 *  None
 */

void CHatchWin::RectsSet(LPRECT prcPos, LPRECT prcClip)
    {
    RECT    rc;
    RECT    rcPos;
    UINT    uPosFlags = SWP_NOZORDER | SWP_NOACTIVATE;
    BOOL    bChanged = TRUE;

    // If new rectangles, save them
    if (prcPos != NULL) {

        bChanged = !EqualRect ( prcPos, &m_rcPos );

        m_rcPos = *prcPos;

        // If clipping rect supplied, use it
        // else just use the position rect again
        if (prcClip != NULL) {
            if ( !bChanged ) 
                bChanged = !EqualRect ( prcClip, &m_rcClip );
            m_rcClip = *prcClip;
        } else {
            m_rcClip = m_rcPos;
        }
    }

    if ( bChanged ) {

        // Expand position rect to include hatch border
        rcPos = m_rcPos;
        InflateRect(&rcPos, m_iBorder, m_iBorder);                             

        // Clip with clipping rect to get actual window rect
        IntersectRect(&rc, &rcPos, &m_rcClip);

        // Save hatch wnd origin relative to clipped window
        m_ptHatchOrg.x = rcPos.left - rc.left;
        m_ptHatchOrg.y = rcPos.top - rc.top;

        // Set flag to avoid reentrant call from window proc
        m_bResizeInProgress = TRUE;

        // Offset child window from hatch rect by border width
        // (maintaining its original size)
        SetWindowPos(m_hWndKid, NULL, m_ptHatchOrg.x + m_iBorder, m_ptHatchOrg.y + m_iBorder, 
                     m_rcPos.right - m_rcPos.left, m_rcPos.bottom - m_rcPos.top, uPosFlags);

        // Position the hatch window
        SetWindowPos(m_hWnd, NULL, rc.left, rc.top, rc.right - rc.left,
                     rc.bottom - rc.top,  uPosFlags);

        m_bResizeInProgress = FALSE;
    }

    // This is here to ensure that the control background gets redrawn
    // On a UI deactivate, the VC test container erases the control window
    // between the WM_ERASEBKGND and WM_PAINT, so the background ends up
    // the container color instead of the control color
    if (m_iBorder == 0)
        InvalidateRect(m_hWndKid, NULL, TRUE);

    return;
    }



/*
 * CHatchWin::ChildSet
 *
 * Purpose:
 *  Assigns a child window to this hatch window.
 *
 * Parameters:
 *  hWndKid         HWND of the child window.
 *
 * Return Value:
 *  None
 */

void CHatchWin::ChildSet(HWND hWndKid)
    {
    m_hWndKid = hWndKid;

    if (NULL != hWndKid)
        {
        SetParent(hWndKid, m_hWnd);

        //Insure this is visible when the hatch window becomes visible.
        ShowWindow(hWndKid, SW_SHOW);
        }

    return;
    }


void CHatchWin::OnLeftDown(INT x, INT y)
{
    m_ptDown.x = x;
    m_ptDown.y = y;

    SetCapture(m_hWnd);

    m_uDragMode = DRAG_PENDING;

    SetTimer(m_hWnd, IDTIMER_DEBOUNCE, iDragDelay, NULL);
}


void CHatchWin::OnLeftUp(void)
{
    switch (m_uDragMode) {

    case DRAG_PENDING:

        KillTimer(m_hWnd, IDTIMER_DEBOUNCE);
        ReleaseCapture();
        break;

    case DRAG_ACTIVE:

        // Erase and release drag region
        if ( NULL != m_hRgnDrag ) {
            DrawDragRgn(m_hWndParent, m_hRgnDrag);
            DeleteObject(m_hRgnDrag);
            m_hRgnDrag = NULL;
        }

        ReleaseCapture();

        // Inform associated window of change
        if ( !EqualRect(&m_rectNew, &m_rcPos) ) {
            SendMessage(m_hWndAssociate, WM_COMMAND, 
                        MAKEWPARAM(m_uID, HWN_RESIZEREQUESTED),
                        (LPARAM)&m_rectNew);
        }
        break;
    }

    m_uDragMode = DRAG_IDLE; 
}


void CHatchWin::OnMouseMove(INT x, INT y)
{
    INT     dx, dy;
    HRGN    hRgnNew, hRgnDiff;
    UINT    uResizeFlags;
    
    INT     iWidth, iHeight;
    INT     xHit, yHit;

    static INT  xPrev, yPrev;


    if (x == xPrev && y == yPrev)
        return;

    xPrev = x;
    yPrev = y;

    switch (m_uDragMode)
    {

    case DRAG_IDLE:

        // Adjust to hatch window coordinates
        x -= m_ptHatchOrg.x;
        y -= m_ptHatchOrg.y;

        iWidth = m_rcPos.right - m_rcPos.left + 2 * m_iBorder;
        iHeight = m_rcPos.bottom - m_rcPos.top + 2 * m_iBorder;

        // Determine if x is within a handle
        if (x <= m_iBorder)
            xHit = X_LEFT;
        else if (x >= iWidth - m_iBorder)
            xHit = X_RIGHT;
        else if (x >= (iWidth - m_iBorder)/2 && x <= (iWidth + m_iBorder)/2)
            xHit = X_MIDDLE;
        else 
            xHit = NO_HIT;

        // Determine is y within a handle
        if (y <= m_iBorder)
            yHit = Y_TOP;
        else if (y >= iHeight - m_iBorder)
            yHit = Y_BOTTOM;
        else if (y > (iHeight - m_iBorder)/2 && y < (iHeight + m_iBorder)/2)
            yHit = Y_MIDDLE;
        else
            yHit = NO_HIT;

        // Compute handle code
        // if no handle hit, set to 4 (drag full object)
        if (xHit != NO_HIT && yHit != NO_HIT)
            m_uHdlCode = xHit + 3 * yHit;
        else
            m_uHdlCode = 4;

        // Set cursor to match handle
        SetCursor(hCursTable[uCursIDTable[m_uHdlCode] - IDC_CURS_MIN]);
        break;

    case DRAG_PENDING:
     
        // Start resize if movement threshold exceeded
        dx = (x >= m_ptDown.x) ? (x - m_ptDown.x) : (m_ptDown.x - x);
        dy = (y >= m_ptDown.y) ? (y - m_ptDown.y) : (m_ptDown.y - y);

        if (dx > iDragMinDist || dy > iDragMinDist) {
            KillTimer(m_hWnd, IDTIMER_DEBOUNCE);

            // Create and display initial drag region
            m_hRgnDrag = CreateDragRgn(&m_rcPos);

            if ( NULL != m_hRgnDrag ) {
                DrawDragRgn(m_hWndParent, m_hRgnDrag);

                // Initialize new rect
                m_rectNew = m_rcPos;

                m_uDragMode = DRAG_ACTIVE;
            }
        }
        break;

    case DRAG_ACTIVE:
        
        dx = x - m_ptDown.x;
        dy = y - m_ptDown.y;

        // Compute new rect by applying deltas to selected edges
        // of original position rect 
        uResizeFlags = uSizingTable[m_uHdlCode];

        if (uResizeFlags & SIZING_ALL) {
            m_rectNew.left = m_rcPos.left + dx;
            m_rectNew.top = m_rcPos.top + dy;
            m_rectNew.right = m_rcPos.right + dx;
            m_rectNew.bottom = m_rcPos.bottom + dy;
        } else {
            if (uResizeFlags & SIZING_TOP) {
                m_rectNew.top = m_rcPos.top + dy;

                if (m_rectNew.bottom - m_rectNew.top < MIN_SIZE)
                    m_rectNew.top = m_rectNew.bottom - MIN_SIZE;
            }

            if (uResizeFlags & SIZING_BOTTOM) {
                m_rectNew.bottom = m_rcPos.bottom + dy;

                if (m_rectNew.bottom - m_rectNew.top < MIN_SIZE)
                    m_rectNew.bottom = m_rectNew.top + MIN_SIZE;
            }
                
            if (uResizeFlags & SIZING_LEFT) {
                m_rectNew.left = m_rcPos.left + dx;

                if (m_rectNew.right - m_rectNew.left < MIN_SIZE)
                    m_rectNew.left = m_rectNew.right - MIN_SIZE;
            }
        
            if (uResizeFlags & SIZING_RIGHT) {
                m_rectNew.right = m_rcPos.right + dx;

                if (m_rectNew.right - m_rectNew.left < MIN_SIZE)
                    m_rectNew.right = m_rectNew.left + MIN_SIZE;
            }
        }
        
        // Compute new drag region
        hRgnNew = CreateDragRgn(&m_rectNew);

        if ( NULL != hRgnNew ) {
            // Repaint difference between old and new regions (No Flicker!)
            hRgnDiff = CreateRectRgn(0,0,0,0);
            if ( NULL != m_hRgnDrag 
                    && NULL != hRgnDiff ) {
                CombineRgn(hRgnDiff, m_hRgnDrag, hRgnNew, RGN_XOR);
                DrawDragRgn(m_hWndParent, hRgnDiff);
            } else {
                DrawDragRgn(m_hWndParent, hRgnNew);
            }

            if ( NULL != hRgnDiff ) {
                DeleteObject ( hRgnDiff );
            }
            // Update current region
            if ( NULL != m_hRgnDrag ) {
                DeleteObject(m_hRgnDrag);
            }
            m_hRgnDrag = hRgnNew;
        }
    }

}

void CHatchWin::OnTimer()
{
    if ( DRAG_PENDING == m_uDragMode ) {
        KillTimer(m_hWnd, IDTIMER_DEBOUNCE); 
        // Create and display initial drag region
        m_hRgnDrag = CreateDragRgn(&m_rcPos);

        if ( NULL != m_hRgnDrag ) {
            DrawDragRgn(m_hWndParent, m_hRgnDrag);
            // Initialize new rect
            m_rectNew = m_rcPos;

            m_uDragMode = DRAG_ACTIVE;

        }
    }
}

void CHatchWin::OnPaint()
{
    HDC     hDC;
    RECT    rc;
    PAINTSTRUCT ps;
    INT     iWidth, iHeight;

    hDC = BeginPaint(m_hWnd, &ps);

    // setup hatch rect in window's coord system
    iWidth = m_rcPos.right - m_rcPos.left + 2 * m_iBorder;
    iHeight = m_rcPos.bottom - m_rcPos.top + 2 * m_iBorder;

    SetRect(&rc, m_ptHatchOrg.x, m_ptHatchOrg.y,
                 m_ptHatchOrg.x + iWidth,
                 m_ptHatchOrg.y + iHeight);

    DrawShading(hDC, &rc);
    DrawHandles(hDC, &rc);

    EndPaint(m_hWnd, &ps);
}
    
/*
 * CHatchWin::ShowHatch
 *
 * Purpose:
 *  Turns hatching on and off; turning the hatching off changes
 *  the size of the window to be exactly that of the child, leaving
 *  everything else the same.  The result is that we don't have
 *  to turn off drawing because our own WM_PAINT will never be
 *  called.
 *
 * Parameters:
 *  fHatch          BOOL indicating to show (TRUE) or hide (FALSE)
                    the hatching.
 *
 * Return Value:
 *  None
 */

void CHatchWin::ShowHatch(BOOL fHatch)
{
    /*
     * All we have to do is set the border to zero and
     * call SetRects again with the last rectangles the
     * child sent to us.
    */

    m_iBorder = fHatch ? iBorder : 0;
    RectsSet(NULL, NULL);

    return;
}


/*
 * CHatchWin::Window
 *
 * Purpose:
 *  Returns the window handle associated with this object.
 *
 * Return Value:
 *  HWND            Window handle for this object
 */

HWND CHatchWin::Window(void)
    {
    return m_hWnd;
    }

/*
 * HatchWndProc
 *
 * Purpose:
 *  Standard window procedure for the Hatch Window
 */

LRESULT APIENTRY HatchWndProc(HWND hWnd, UINT iMsg
    , WPARAM wParam, LPARAM lParam)
    {
    PCHatchWin  phw;
    
    phw = (PCHatchWin)GetWindowLongPtr(hWnd, HWWL_STRUCTURE);

    switch (iMsg)
        {
        case WM_CREATE:
            phw = (PCHatchWin)((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetWindowLongPtr(hWnd, HWWL_STRUCTURE, (INT_PTR)phw);
            break;

        case WM_DESTROY:
            phw->m_hWnd = NULL;
            break;

        case WM_PAINT:
            phw->OnPaint();
            break;

        case WM_SIZE:
            // If this resize is not due to RectsSet then forward it
            // to adjust our internal control window
            if (!phw->m_bResizeInProgress)
            {
                RECT rc;
                POINT pt;

                // Get new rect in container coords
                GetWindowRect(hWnd, &rc);

                // Convert to parent client coords
                pt.x = pt.y = 0;
                ClientToScreen(GetParent(hWnd), &pt);
                OffsetRect(&rc,-pt.x, -pt.y);

                // Resize control
                phw->RectsSet(&rc, NULL);
            }
            break;

        case WM_MOUSEMOVE:
            phw->OnMouseMove((short)LOWORD(lParam),(short)HIWORD(lParam));
            break;

        case WM_LBUTTONDOWN:
            phw->OnLeftDown((short)LOWORD(lParam),(short)HIWORD(lParam));
            break;

        case WM_LBUTTONUP:
            phw->OnLeftUp();
            break;

        case WM_TIMER:
            phw->OnTimer();
            break;

        case WM_SETFOCUS:
            //We need this since the container will SetFocus to us.
            if (NULL != phw->m_hWndKid)
                SetFocus(phw->m_hWndKid);
            break;

        case WM_LBUTTONDBLCLK:
            /*
             * If the double click was within m_dBorder of an
             * edge, send the HWN_BORDERDOUBLECLICKED notification.
             *
             * Because we're always sized just larger than our child
             * window by the border width, we can only *get* this
             * message when the mouse is on the border.  So we can
             * just send the notification.
             */

            if (NULL!=phw->m_hWndAssociate)
                {
                SendMessage(phw->m_hWndAssociate, WM_COMMAND, 
                            MAKEWPARAM(phw->m_uID,HWN_BORDERDOUBLECLICKED),
                            (LPARAM)hWnd);
                }

            break;

        default:
            return DefWindowProc(hWnd, iMsg, wParam, lParam);
        }
    
    return 0L;
    }


HRGN CreateDragRgn(LPRECT pRect)
{
    HRGN    hRgnIn;
    HRGN    hRgnOut;
    HRGN    hRgnRet = NULL;

    if ( NULL != pRect ) {
  
        hRgnRet = CreateRectRgn(0,0,0,0);

        hRgnIn = CreateRectRgn(pRect->left, pRect->top,pRect->right, pRect->bottom);
        hRgnOut = CreateRectRgn(pRect->left - iBorder, pRect->top - iBorder,
                                pRect->right + iBorder, pRect->bottom + iBorder);

        if ( NULL != hRgnOut 
                && NULL != hRgnIn
                && NULL != hRgnRet ) {
            CombineRgn(hRgnRet, hRgnOut, hRgnIn, RGN_DIFF);
        }
        if ( NULL != hRgnIn ) {
            DeleteObject(hRgnIn);
        }
        if ( NULL != hRgnOut ) {
            DeleteObject(hRgnOut);
        }
    }
    return hRgnRet;
}


void DrawDragRgn(HWND hWnd, HRGN hRgn)
{
    LONG    lWndStyle;
    INT     iMapMode;
    HDC     hDC;
    RECT    rc;
    HBRUSH  hBr;
    COLORREF    crText;

    // Turn off clipping by children
    lWndStyle = GetWindowLong(hWnd, GWL_STYLE);
    SetWindowLong(hWnd, GWL_STYLE, lWndStyle & ~WS_CLIPCHILDREN);

    // Prepare DC
    hDC = GetDC(hWnd);

    if ( NULL != hDC ) {
        iMapMode = SetMapMode(hDC, MM_TEXT);
        hBr = (HBRUSH)SelectObject(hDC, hBrGray);
        crText = SetTextColor(hDC, RGB(255, 255, 255));

        SelectClipRgn(hDC, hRgn);
        GetClipBox(hDC, &rc);

        PatBlt(hDC, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, PATINVERT);

        // Restore DC
        SelectObject(hDC, hBr);
        SetTextColor(hDC, crText);
        SetMapMode(hDC, iMapMode);
        SelectClipRgn(hDC, NULL);
        ReleaseDC(hWnd, hDC);
    }

    SetWindowLong(hWnd, GWL_STYLE, lWndStyle);
}


/*
 * DrawShading
 *
 * Purpose:
 *  Draw a hatch border ourside the rectable given.
 *
 * Parameters:
 *  prc             LPRECT containing the rectangle.
 *  hDC             HDC on which to draw.
 *  cWidth          UINT width of the border to draw.  Ignored
 *                  if dwFlags has UI_SHADE_FULLRECT.
 *
 * Return Value:
 *  None
 */

void DrawShading(HDC hDC, LPRECT prc)
{
    HBRUSH      hBROld;
    RECT        rc;
    UINT        cx, cy;
    COLORREF    crText;
    COLORREF    crBk;
    const DWORD dwROP = 0x00A000C9L;  //DPa

    if (NULL==prc || NULL==hDC)
        return;

    hBROld = (HBRUSH)SelectObject(hDC, hBrHatch);

    rc = *prc;
    cx = rc.right - rc.left;
    cy = rc.bottom - rc.top;

    crText = SetTextColor(hDC, RGB(255, 255, 255));
    crBk = SetBkColor(hDC, RGB(0, 0, 0));

    PatBlt(hDC, rc.left, rc.top, cx, iBorder, dwROP);
    PatBlt(hDC, rc.left, rc.top, iBorder, cy, dwROP);
    PatBlt(hDC, rc.right-iBorder, rc.top, iBorder, cy, dwROP);
    PatBlt(hDC, rc.left, rc.bottom-iBorder, cx, iBorder, dwROP);

    SetTextColor(hDC, crText);
    SetBkColor(hDC, crBk);
    SelectObject(hDC, hBROld);

    return;
}

void DrawHandles (HDC hDC, LPRECT prc)
{
    HPEN    hPenOld;
    HBRUSH  hBROld;
    INT     left,right,top,bottom;

#define DrawHandle(x,y) Rectangle(hDC, x, y, (x) + iBorder + 1, (y) + iBorder + 1)

    hPenOld = (HPEN)SelectObject(hDC, (HPEN)GetStockObject(BLACK_PEN));
    hBROld = (HBRUSH)SelectObject(hDC, (HBRUSH)GetStockObject(BLACK_BRUSH));

    left = prc->left;
    right = prc->right - iBorder;
    top = prc->top;
    bottom = prc->bottom - iBorder;
     
    DrawHandle(left, top);
    DrawHandle(left, (top + bottom)/2);
    DrawHandle(left, bottom);

    DrawHandle(right, top);
    DrawHandle(right, (top + bottom)/2);
    DrawHandle(right, bottom);

    DrawHandle((left + right)/2, top);
    DrawHandle((left + right)/2, bottom);

    SelectObject(hDC, hPenOld);
    SelectObject(hDC, hBROld);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\iconnpt.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    iconnpt.cpp

Abstract:

    Implementation of CImpIConnectionPoint for the Polyline object
    as well as CConnectionPoint.

--*/

#include "polyline.h"
#include "iconnpt.h"
#include "unkhlpr.h"


static const IID *apIIDConnectPt [CONNECTION_POINT_CNT] = {
                &IID_ISystemMonitorEvents,  
                &DIID_DISystemMonitorEvents
                };

// CImpIConnPt interface implementation
    IMPLEMENT_CONTAINED_IUNKNOWN(CImpIConnPtCont)

/*
 * CImpIConnPtCont::CImpIConnPtCont
 *
 * Purpose:
 *  Constructor.
 *
 * Return Value:
 */

CImpIConnPtCont::CImpIConnPtCont ( PCPolyline pObj, LPUNKNOWN pUnkOuter)
    :   m_cRef(0),
        m_pObj(pObj),
        m_pUnkOuter(pUnkOuter)
{
    return; 
}

/*
 * CImpIConnPtCont::~CImpIConnPtCont
 *
 * Purpose:
 *  Destructor.
 *
 * Return Value:
 */

CImpIConnPtCont::~CImpIConnPtCont( void ) 
{   
    return; 
}

/*
 * CImpIConnPtCont::EnumConnectionPoints
 *
 * Purpose:
 *  Not implemented.
 *
 * Return Value:
 *  HRESULT         E_NOTIMPL
 */

STDMETHODIMP 
CImpIConnPtCont::EnumConnectionPoints (
    OUT LPENUMCONNECTIONPOINTS *ppIEnum
    )
{
    CImpIEnumConnPt *pEnum;

    if (ppIEnum == NULL)
        return E_POINTER;

    *ppIEnum = NULL;

    pEnum = new CImpIEnumConnPt(this, apIIDConnectPt, CONNECTION_POINT_CNT);
    if (pEnum == NULL)
        return E_OUTOFMEMORY;

    return pEnum->QueryInterface(IID_IEnumConnectionPoints, (PPVOID)ppIEnum);   
}



/*
 * CImpIConnPtCont::FindConnectionPoint
 *
 * Purpose:
 *  Returns a pointer to the IConnectionPoint for a given
 *  outgoing IID.
 *
 * Parameters:
 *  riid            REFIID of the outgoing interface for which
 *                  a connection point is desired.
 *  ppCP            IConnectionPoint ** in which to return
 *                  the pointer after calling AddRef.
 *
 * Return Value:
 *  HRESULT         NOERROR if the connection point is found,
 *                  E_NOINTERFACE if it's not supported.
 */

STDMETHODIMP 
CImpIConnPtCont::FindConnectionPoint (
    IN  REFIID riid,
    OUT IConnectionPoint **ppCP
    )
{

    PCImpIConnectionPoint pConnPt;
    
    *ppCP=NULL;

    // if request matches one of our connection IDs
    if (IID_ISystemMonitorEvents == riid)
        pConnPt = &m_pObj->m_ConnectionPoint[eConnectionPointDirect];
    else if (DIID_DISystemMonitorEvents == riid)
        pConnPt = &m_pObj->m_ConnectionPoint[eConnectionPointDispatch];
    else
        return ResultFromScode(E_NOINTERFACE);

    // Return the IConnectionPoint interface
    return pConnPt->QueryInterface(IID_IConnectionPoint, (PPVOID)ppCP); 
}


/*
 * CImpIConnectionPoint constructor
 */
CImpIConnectionPoint::CImpIConnectionPoint (
    void
    )
    :   m_cRef(0),
        m_pObj(NULL),
        m_pUnkOuter(NULL),
        m_hEventEventSink(NULL),
        m_lSendEventRefCount(0),
        m_lUnadviseRefCount(0)
{
    m_Connection.pIDirect = NULL;
    m_Connection.pIDispatch = NULL;
}


/*
 * CImpIConnectionPoint destructor
 */
CImpIConnectionPoint::~CImpIConnectionPoint (
    void
    )
{
    DeinitEventSinkLock();
}

/*
 * CImpIConnectionPoint::QueryInterface
 * CImpIConnectionPoint::AddRef
 * CCImpIonnectionPoint::Release
 *
 */

STDMETHODIMP 
CImpIConnectionPoint::QueryInterface ( 
    IN  REFIID riid,
    OUT LPVOID *ppv
    )
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IConnectionPoint==riid)
        *ppv=(LPVOID)this;

    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) 
CImpIConnectionPoint::AddRef(
    void
    )
{   
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}



STDMETHODIMP_(ULONG) 
CImpIConnectionPoint::Release (
    void
    )
{
    --m_cRef;
    return m_pUnkOuter->Release();
}



/*
 * CImpIConnectionPoint::Init
 *
 * Purpose:
 * Set back-pointers and connection type.
 *
 * Paramters:
 *  pObj            Containing Object
 *  pUnkOuter       Controlling Object
 *  iConnectType    Connection point type
 */
void
CImpIConnectionPoint::Init (
    IN PCPolyline   pObj,
    IN LPUNKNOWN    pUnkOuter,
    IN INT          iConnPtType
    )
{
    DWORD dwStat = 0;

    m_pObj = pObj;
    m_pUnkOuter = pUnkOuter;
    m_iConnPtType = iConnPtType;

    dwStat = InitEventSinkLock();
}


/*
 * CImpIConnectionPoint::GetConnectionInterface
 *
 * Purpose:
 *  Returns the IID of the outgoing interface supported through
 *  this connection point.
 *
 * Parameters:
 *  pIID            IID * in which to store the IID.
 */

STDMETHODIMP 
CImpIConnectionPoint::GetConnectionInterface (
    OUT IID *pIID
    )
{
    if (NULL == pIID)
        return ResultFromScode(E_POINTER);

    *pIID = *apIIDConnectPt[m_iConnPtType];

    return NOERROR;
}



/*
 * CImpIConnectionPoint::GetConnectionPointContainer
 *
 * Purpose:
 *  Returns a pointer to the IConnectionPointContainer that
 *  is manageing this connection point.
 *
 * Parameters:
 *  ppCPC           IConnectionPointContainer ** in which to return
 *                  the pointer after calling AddRef.
 */

STDMETHODIMP 
CImpIConnectionPoint::GetConnectionPointContainer (
    OUT IConnectionPointContainer **ppCPC
    )
{
    return m_pObj->QueryInterface(IID_IConnectionPointContainer, (void **)ppCPC);
}



/*
 * CImpIConnectionPoint::Advise
 *
 * Purpose:
 *  Provides this connection point with a notification sink to
 *  call whenever the appropriate outgoing function/event occurs.
 *
 * Parameters:
 *  pUnkSink        LPUNKNOWN to the sink to notify.  The connection
 *                  point must QueryInterface on this pointer to obtain
 *                  the proper interface to call.  The connection
 *                  point must also insure that any pointer held has
 *                  a reference count (QueryInterface will do it).
 *  pdwCookie       DWORD * in which to store the connection key for
 *                  later calls to Unadvise.
 */

STDMETHODIMP 
CImpIConnectionPoint::Advise (
    IN  LPUNKNOWN pUnkSink,
    OUT DWORD *pdwCookie )
{
    HRESULT hr;

    *pdwCookie = 0;

    // Can only support one connection
    if (NULL != m_Connection.pIDirect) {
        hr = ResultFromScode(CONNECT_E_ADVISELIMIT);
    } else {
        // Get interface from sink
        if (FAILED(pUnkSink->QueryInterface(*apIIDConnectPt[m_iConnPtType], (PPVOID)&m_Connection)))
            hr = ResultFromScode(CONNECT_E_CANNOTCONNECT);
        else {
        // Return our cookie
            *pdwCookie = eAdviseKey;
            hr = NOERROR;
        }
    }
    
    return hr;
}



/*
 * CImpIConnectionPoint::SendEvent
 *
 * Purpose:
 *  Sends an event to the attached event sink
 *
 * Parameters:
 *  uEventType     Event code
 *  dwParam        Parameter to send with event
 *
 */
void
CImpIConnectionPoint::SendEvent (
    IN UINT uEventType,
    IN DWORD dwParam
    )
{

    // If not connected, just return.

    if ( EnterSendEvent() ) {
        if (m_Connection.pIDirect != NULL) {

            // For direct connection, call the method
            if (m_iConnPtType == eConnectionPointDirect) {

                switch (uEventType) {

                case eEventOnCounterSelected:
                    m_Connection.pIDirect->OnCounterSelected((INT)dwParam);
                    break;

                case eEventOnCounterAdded:
                    m_Connection.pIDirect->OnCounterAdded((INT)dwParam);
                    break;

                case eEventOnCounterDeleted:
                    m_Connection.pIDirect->OnCounterDeleted((INT)dwParam);
                    break;

                case eEventOnSampleCollected:
                    m_Connection.pIDirect->OnSampleCollected();
                    break;

                case eEventOnDblClick:
                    m_Connection.pIDirect->OnDblClick((INT)dwParam);
                    break;
                }
            }
            // for dispatch connection, call Invoke
            else if ( m_iConnPtType == eConnectionPointDispatch ) {
                if ( NULL != m_Connection.pIDispatch ) {

                    DISPPARAMS  dp;
                    VARIANT     vaRet;
                    VARIANTARG  varg;

                    VariantInit(&vaRet);

                    if ( uEventType == eEventOnSampleCollected ) {
                        SETNOPARAMS(dp)
                    } else { 
                        VariantInit(&varg);
                        V_VT(&varg) = VT_I4;
                        V_I4(&varg) = (INT)dwParam;
                    
                        SETDISPPARAMS(dp, 1, &varg, 0, NULL)
                    }

                    m_Connection.pIDispatch->Invoke(uEventType, IID_NULL
                    , LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dp
                    , &vaRet, NULL, NULL);
                }
            }
        }
    }

    ExitSendEvent();
    
    return;
}

/*
 * CImpIConnectionPoint::Unadvise
 *
 * Purpose:
 *  Terminates the connection to the notification sink identified
 *  with dwCookie (that was returned from Advise).  The connection
 *  point has to Release any held pointers for that sink.
 *
 * Parameters:
 *  dwCookie        DWORD connection key from Advise.
 */

STDMETHODIMP 
CImpIConnectionPoint::Unadvise ( 
    IN  DWORD dwCookie )
{
    if (eAdviseKey != dwCookie)
        return ResultFromScode(CONNECT_E_NOCONNECTION);

    EnterUnadvise();

    m_Connection.pIDirect = NULL;

    ExitUnadvise();

    return NOERROR;
}



/*
 * CImpIConnectionPoint::EnumConnections
 *
 * Purpose:
 *  Not implemented because only one conection is allowed
 */

STDMETHODIMP 
CImpIConnectionPoint::EnumConnections ( 
    OUT LPENUMCONNECTIONS *ppEnum
    )
{
    if (ppEnum == NULL)
        return E_POINTER;

    *ppEnum = NULL;

    return ResultFromScode(E_NOTIMPL);
}

/*
 *  Locks for the event sink.
 */

DWORD 
CImpIConnectionPoint::InitEventSinkLock ( void )
{
    DWORD dwStat = 0;
    
    m_lUnadviseRefCount = 0;
    m_lSendEventRefCount = 0;

    if ( NULL == ( m_hEventEventSink = CreateEvent ( NULL, TRUE, TRUE, NULL ) ) )
        dwStat = GetLastError();

    return dwStat;
}

void 
CImpIConnectionPoint::DeinitEventSinkLock ( void )
{
    // Release the event sink lock
    if ( NULL != m_hEventEventSink ) {
        CloseHandle ( m_hEventEventSink );
        m_hEventEventSink = NULL;
    }
    m_lSendEventRefCount = 0;
    m_lUnadviseRefCount = 0;

}

BOOL
CImpIConnectionPoint::EnterSendEvent ( void )
{
    // Return value indicates whether lock is granted.
    // If lock is not granted, must still call ExitSendEvent.

    // Increment the SendEvent reference count when SendEvent is active.
    InterlockedIncrement( &m_lSendEventRefCount );

    // Grant the lock unless the event sink pointer is being modified in Unadvise. 
    return ( 0 == m_lUnadviseRefCount );
}

void
CImpIConnectionPoint::ExitSendEvent ( void )
{
    LONG lTemp;

    // Decrement the SendEvent reference count. 
    lTemp = InterlockedDecrement( &m_lSendEventRefCount );

    // Signal the event sink if SendEvent count decremented to 0.
    // lTemp is the value previous to decrement.
    if ( 0 == lTemp )
        SetEvent( m_hEventEventSink );
}


void
CImpIConnectionPoint::EnterUnadvise ( void )
{
    BOOL bStatus;

    bStatus = ResetEvent( m_hEventEventSink );

    // Increment the Unadvise reference count whenever Unadvise is active.
    // Whenever this is > 0, events are not fired.
    InterlockedIncrement( &m_lUnadviseRefCount );

    // Wait until SendEvent is no longer active.
    while ( m_lSendEventRefCount > 0 ) {
        WaitForSingleObject( m_hEventEventSink, eEventSinkWaitInterval );
        bStatus = ResetEvent( m_hEventEventSink );
    }
}

void
CImpIConnectionPoint::ExitUnadvise ( void )
{
    // Decrement the Unadvise reference count. 
    InterlockedDecrement( &m_lUnadviseRefCount );
}


CImpIEnumConnPt::CImpIEnumConnPt (
    IN  CImpIConnPtCont  *pConnPtCont,
    IN  const IID **ppIID,
    IN  ULONG cItems
    )
{
    m_pConnPtCont = pConnPtCont;
    m_apIID = ppIID;
    m_cItems = cItems;

    m_uCurrent = 0;
    m_cRef = 0;
}


STDMETHODIMP
CImpIEnumConnPt::QueryInterface (
    IN  REFIID riid, 
    OUT PVOID *ppv
    )
{
    if ((riid == IID_IUnknown) || (riid == IID_IEnumConnectionPoints)) {
        *ppv = this;
        AddRef();
        return NOERROR;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG)
CImpIEnumConnPt::AddRef (
    VOID
    )
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG)
CImpIEnumConnPt::Release(
    VOID
    )
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}


STDMETHODIMP
CImpIEnumConnPt::Next(
    IN  ULONG cItems,
    OUT IConnectionPoint **apConnPt,
    OUT ULONG *pcReturned)
{
    ULONG i;
    ULONG cRet;
    HRESULT hr;

    hr = NOERROR;

    // Clear the return values
    for (i = 0; i < cItems; i++)
        apConnPt[i] = NULL;

    // Try to fill the caller's array
    for (cRet = 0; cRet < cItems; cRet++) {

        // No more, return success with false
        if (m_uCurrent == m_cItems) {
            hr = S_FALSE;
            break;
        }

        // Ask connection point container for next connection point
        hr = m_pConnPtCont->FindConnectionPoint(*m_apIID[m_uCurrent], &apConnPt[cRet]);

        if (FAILED(hr))
            break;

        m_uCurrent++;
    }

    // If failed, free the accumulated interfaces
    if (FAILED(hr)) {
        for (i = 0; i < cRet; i++)
            ReleaseInterface(apConnPt[i]);
        cRet = 0;
    }

    // If desired, return number of items fetched
    if (pcReturned != NULL)
      *pcReturned = cRet;

    return hr;
}


/***
*HRESULT CImpIEnumConnPt::Skip(unsigned long)
*Purpose:
*  Attempt to skip over the next 'celt' elements in the enumeration
*  sequence.
*
*Entry:
*  celt = the count of elements to skip
*
*Exit:
*  return value = HRESULT
*    S_OK
*    S_FALSE -  the end of the sequence was reached
*
***********************************************************************/
STDMETHODIMP
CImpIEnumConnPt::Skip(
    IN  ULONG   cItems
    )
{
    m_uCurrent += cItems;

    if (m_uCurrent > m_cItems)
        m_uCurrent = m_cItems;

    return (m_uCurrent == m_cItems) ? S_FALSE : S_OK;
}


/***
*HRESULT CImpIEnumConnPt::Reset(void)
*Purpose:
*  Reset the enumeration sequence back to the beginning.
*
*Entry:
*  None
*
*Exit:
*  return value = SHRESULT CODE
*    S_OK
*
***********************************************************************/
STDMETHODIMP
CImpIEnumConnPt::Reset(
    VOID
    )
{
    m_uCurrent = 0;

    return S_OK; 
}


/***
*HRESULT CImpIEnumConnPt::Clone(IEnumVARIANT**)
*Purpose:
*  Retrun a CPoint enumerator with exactly the same state as the
*  current one.
*
*Entry:
*  None
*
*Exit:
*  return value = HRESULT
*    S_OK
*    E_OUTOFMEMORY
*
***********************************************************************/
STDMETHODIMP
CImpIEnumConnPt::Clone (
    OUT IEnumConnectionPoints **ppEnum
    )
{
    CImpIEnumConnPt *pNewEnum;

    *ppEnum = NULL;

    // Create new enumerator
    pNewEnum = new CImpIEnumConnPt(m_pConnPtCont, m_apIID, m_cItems);
    if (pNewEnum == NULL)
        return E_OUTOFMEMORY;

    // Copy current position
    pNewEnum->m_uCurrent = m_uCurrent;

    *ppEnum = pNewEnum;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\iconnpt.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    iconnpt.h

Abstract:

    Header file for connection points.

--*/

#ifndef _ICONNPT_H_
#define _ICONNPT_H_


// Event types
// These values match the ID's in smonctrl.odl
enum {
    eEventOnCounterSelected=1,
    eEventOnCounterAdded=2,
    eEventOnCounterDeleted=3,
    eEventOnSampleCollected=4,
    eEventOnDblClick=5
};

// Connection Point Types
enum {
    eConnectionPointDirect=0,
    eConnectionPointDispatch=1
    };
#define CONNECTION_POINT_CNT 2


// Connection Point Class
class CImpIConnectionPoint : public IConnectionPoint {

    public:
        CImpIConnectionPoint(void);
        ~CImpIConnectionPoint(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IConnectionPoint members
        STDMETHODIMP GetConnectionInterface(IID *);
        STDMETHODIMP GetConnectionPointContainer (IConnectionPointContainer **);
        STDMETHODIMP Advise(LPUNKNOWN, DWORD *);
        STDMETHODIMP Unadvise(DWORD);
        STDMETHODIMP EnumConnections(IEnumConnections **);

        //Members not exposed by IConnectionPoint
        void Init(PCPolyline pObj, LPUNKNOWN PUnkOuter, INT iConnPtType);
        void SendEvent(UINT uEventType, DWORD dwParam); // Send event to sink 

    private:

        enum IConnPtConstant {
            eAdviseKey = 1234,
            eEventSinkWaitInterval = 2000
        };

        DWORD   InitEventSinkLock ( void );
        void    DeinitEventSinkLock ( void );
        BOOL    EnterSendEvent ( void );
        void    ExitSendEvent ( void );
        void    EnterUnadvise ( void );
        void    ExitUnadvise ( void );

        ULONG           m_cRef;        //Object reference count
        LPUNKNOWN       m_pUnkOuter;   //Controlling unknown
        PCPolyline      m_pObj;        //Containing object
        INT             m_iConnPtType; // Direct or dispatch connection 
        HANDLE          m_hEventEventSink;
        LONG            m_lUnadviseRefCount;
        LONG            m_lSendEventRefCount;

        union {
            IDispatch               *pIDispatch; // Outgoing interface
            ISystemMonitorEvents    *pIDirect;
        } m_Connection;

};

typedef CImpIConnectionPoint *PCImpIConnectionPoint;



// Connection Point Container Class
class CImpIConnPtCont : public IConnectionPointContainer
    {
    public:
        CImpIConnPtCont(PCPolyline, LPUNKNOWN);
        ~CImpIConnPtCont(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(DWORD) AddRef(void);
        STDMETHODIMP_(DWORD) Release(void);

        //IConnectionPointContainer members
        STDMETHODIMP EnumConnectionPoints(IEnumConnectionPoints **);
        STDMETHODIMP FindConnectionPoint(REFIID, IConnectionPoint **);

    private:

        ULONG               m_cRef;      //Interface ref count
        PCPolyline          m_pObj;      //Back pointer to object
        LPUNKNOWN           m_pUnkOuter; //Controlling unknown

    };

typedef CImpIConnPtCont *PCImpIConnPtCont;


// Connection Point Enumerator Class
class CImpIEnumConnPt : public IEnumConnectionPoints
{
protected:
    CImpIConnPtCont *m_pConnPtCont;
    DWORD       m_cRef;
    ULONG       m_cItems;
    ULONG       m_uCurrent;
    const IID   **m_apIID;
    
public:

    CImpIEnumConnPt (CImpIConnPtCont *pConnPtCont, const IID **apIID, ULONG cItems);

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

    // Enum methods
    STDMETHOD(Next) (ULONG cItems, IConnectionPoint **apConnPt, ULONG *pcReturned);
    STDMETHOD(Skip) (ULONG cSkip);
    STDMETHOD(Reset) (VOID);
    STDMETHOD(Clone) (IEnumConnectionPoints **pIEnum);
};


#endif //_ICONNPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\iextconn.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    iextconn.cpp

Abstract:

    Implementation of IExternalConnection as required for an
    in-process object that supports linking to embedding.
    Specifically, this will call IOleObject::Close when there
    are no more strong locks on the object.

--*/

#include "polyline.h"
#include "unkhlpr.h"

// CImpIExternalConnection interface implementation
CImpIExternalConnection::CImpIExternalConnection(PCPolyline pObj
    , LPUNKNOWN pUnkOuter)
    {
    m_cRef=0;
    m_pObj=pObj;
    m_pUnkOuter=pUnkOuter;
    m_cLockStrong=0L;
    return;
    }

IMPLEMENT_CONTAINED_DESTRUCTOR(CImpIExternalConnection)
IMPLEMENT_CONTAINED_IUNKNOWN(CImpIExternalConnection)


/*
 * CImpIExternalConnection::AddConnection
 *
 * Purpose:
 *  Informs the object that a strong connection has been made to it.
 *
 * Parameters:
 *  dwConn          DWORD identifying the type of connection, taken
 *                  from the EXTCONN enumeration.
 *  dwReserved      DWORD reserved.  This is used inside OLE and
 *                  should not be validated.
 *
 * Return Value:
 *  DWORD           The number of connection counts on the
 *                  object, used for debugging purposes only.
 */

STDMETHODIMP_(DWORD) CImpIExternalConnection::AddConnection
    (DWORD dwConn, DWORD /* dwReserved */)
    {
    if (EXTCONN_STRONG & dwConn)
        return ++m_cLockStrong;

    return 0;
    }

/*
 * CImpIExternalConnection::ReleaseConnection
 *
 * Purpose:
 *  Informs an object that a connection has been taken away from
 *  it in which case the object may need to shut down.
 *
 * Parameters:
 *  dwConn              DWORD identifying the type of connection,
 *                      taken from the EXTCONN enumeration.
 *  dwReserved          DWORD reserved.  This is used inside OLE and
 *                      should not be validated.
 *  dwRerved            DWORD reserved
 *  fLastReleaseCloses  BOOL indicating if the last call to this
 *                      function should close the object.
 *
 * Return Value:
 *  DWORD           The number of remaining connection counts on
 *                  the object, used for debugging purposes only.
 */

STDMETHODIMP_(DWORD) CImpIExternalConnection::ReleaseConnection
    (DWORD dwConn, DWORD /* dwReserved */, BOOL fLastReleaseCloses)
    {
    if (EXTCONN_STRONG==dwConn)
        {
        if (0==--m_cLockStrong && fLastReleaseCloses)
            m_pObj->m_pImpIOleObject->Close(OLECLOSE_SAVEIFDIRTY);

        return m_cLockStrong;
        }

    return 0L;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\iipaobj.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    iipaobj.cpp

Abstract:

    IOleInPlaceActiveObject interface implementation for Polyline

--*/

#include "polyline.h"
#include "unkhlpr.h"
#include "unihelpr.h"
#include "utils.h"

/*
 * CImpIOleInPlaceActiveObject::CImpIOleInPlaceActiveObject
 * CImpIOleInPlaceActiveObject::~CImpIOleInPlaceActiveObject
 *
 * Parameters (Constructor):
 *  pObj            PCPolyline of the object we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */
IMPLEMENT_CONTAINED_CONSTRUCTOR(CPolyline, CImpIOleInPlaceActiveObject)
IMPLEMENT_CONTAINED_DESTRUCTOR(CImpIOleInPlaceActiveObject)

IMPLEMENT_CONTAINED_ADDREF(CImpIOleInPlaceActiveObject)
IMPLEMENT_CONTAINED_RELEASE(CImpIOleInPlaceActiveObject)


// CImpIOleInPlaceActiveObject::QueryInterface
STDMETHODIMP CImpIOleInPlaceActiveObject::QueryInterface(REFIID riid
    , PPVOID ppv)
    {
    /*
     * This interface should be stand-alone on an object such that a
     * container cannot QueryInterface for it through any other
     * object interface, relying instead of calls to SetActiveObject
     * for it.  By implementing QueryInterface here ourselves, we
     * prevent such abuses.  Note that reference counting still uses
     * CFigure.
     */

    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IOleWindow==riid
        || IID_IOleInPlaceActiveObject==riid)
        *ppv=this;

    //AddRef any interface we'll return.
    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
    }




/*
 * CImpIOleInPlaceActiveObject::GetWindow
 *
 * Purpose:
 *  Retrieves the handle of the window associated with the object on
 *  which this interface is implemented.
 *
 * Parameters:
 *  phWnd           HWND * in which to store the window handle.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, E_FAIL if there is no
 *                  window.
 */

STDMETHODIMP CImpIOleInPlaceActiveObject::GetWindow(HWND *phWnd)
    {
    *phWnd=m_pObj->m_pHW->Window();;
    return NOERROR;
    }




/*
 * CImpIOleInPlaceActiveObject::ContextSensitiveHelp
 *
 * Purpose:
 *  Instructs the object on which this interface is implemented to
 *  enter or leave a context-sensitive help mode.
 *
 * Parameters:
 *  fEnterMode      BOOL TRUE to enter the mode, FALSE otherwise.
 *
 * Return Value:
 *  HRESULT         NOERROR or an error code.
 */

STDMETHODIMP CImpIOleInPlaceActiveObject::ContextSensitiveHelp (
    BOOL /* fEnterMode */ )
{
    return ResultFromScode(E_NOTIMPL);
}




/*
 * CImpIOleInPlaceActiveObject::TranslateAccelerator
 *
 * Purpose:
 *  Requests that the active in-place object translate the message
 *  given in pMSG if appropriate.  This is only called for DLL
 *  servers where the container's message loop is running.  EXE
 *  servers have control of the message loop so this will not be
 *  called in such cases.
 *
 * Parameters:
 *  pMSG            LPMSG to the message to translate.
 *
 * Return Value:
 *  HRESULT         NOERROR if translates, S_FALSE if not.
 */

STDMETHODIMP CImpIOleInPlaceActiveObject::TranslateAccelerator
    (LPMSG pMSG)
{
    // Don't handle keys unless we are UI active
    if (!m_pObj->m_fUIActive)
        return S_FALSE;

    // Delegate to the control class
    return m_pObj->m_pCtrl->TranslateAccelerators(pMSG);
}




/*
 * CImpIOleInPlaceActiveObject::OnFrameWindowActivate
 *
 * Purpose:
 *  Informs the in-place object that the container's frame window
 *  was either activated or deactivated.  Not currently used.
 *
 * Parameters:
 *  fActivate       BOOL TRUE if the frame is active,
 *                  FALSE otherwise
 *
 * Return Value:
 *  HRESULT         NOERROR or an error code.
 */

STDMETHODIMP CImpIOleInPlaceActiveObject::OnFrameWindowActivate (
    BOOL /* fActivate */)
{
    return ResultFromScode(E_NOTIMPL);
}




/*
 * CImpIOleInPlaceActiveObject::OnDocWindowActivate
 *
 * Purpose:
 *  Informs the in-place object that the document window in the
 *  container is either becoming active or deactive.  On this call
 *  the object must either add or remove frame-level tools,
 *  including the mixed menu, depending on fActivate.
 *
 * Parameters:
 *  fActivate       BOOL TRUE if the document is active,
 *                  FALSE otherwise
 *
 * Return Value:
 *  HRESULT         NOERROR or an error code.
 */

STDMETHODIMP CImpIOleInPlaceActiveObject::OnDocWindowActivate (BOOL fActivate)
    {

    USES_CONVERSION

    if (NULL==m_pObj->m_pIOleIPFrame)
        return NOERROR;

    if (fActivate)
        {
        m_pObj->m_pIOleIPFrame->SetActiveObject(this, T2W(ResourceString(IDS_USERTYPE)));

        m_pObj->m_pIOleIPFrame->SetMenu(m_pObj->m_hMenuShared
            , m_pObj->m_hOLEMenu, m_pObj->m_pCtrl->Window());

        }
    else
        {
        m_pObj->m_pIOleIPFrame->SetActiveObject(NULL, NULL);
        }

    return NOERROR;
    }




/*
 * CImpIOleInPlaceActiveObject::ResizeBorder
 *
 * Purpose:
 *  Informs the object that the frame or document size changed in
 *  which case the object may need to resize any of its frame or
 *  document-level tools to match.
 *
 * Parameters:
 *  pRect           LPCRECT indicating the new size of the window
 *                  of interest.
 *  pIUIWindow      LPOLEINPLACEUIWINDOW pointing to an
 *                  IOleInPlaceUIWindow interface on the container
 *                  object of interest.  We use this to do
 *                  border-space negotiation.
 *
 *  fFrame          BOOL indicating if the frame was resized (TRUE)
 *                  or the document (FALSE)
 *
 * Return Value:
 *  HRESULT         NOERROR or an error code.
 */

STDMETHODIMP CImpIOleInPlaceActiveObject::ResizeBorder (
    LPCRECT,  /* pRect */
    LPOLEINPLACEUIWINDOW,  /* pIUIWindow */
    BOOL /* fFrame */ )
{
    return ResultFromScode(E_NOTIMPL);
}




/*
 * CImpIOleInPlaceActiveObject::EnableModeless
 *
 * Purpose:
 *  Instructs the object to show or hide any modeless popup windows
 *  that it may be using when activated in-place.
 *
 * Parameters:
 *  fEnable         BOOL indicating to enable/show the windows
 *                  (TRUE) or to hide them (FALSE).
 *
 * Return Value:
 *  HRESULT         NOERROR or an error code.
 */

STDMETHODIMP CImpIOleInPlaceActiveObject::EnableModeless ( 
    BOOL /* fActivate */ )
{
    return ResultFromScode(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\intrvbar.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    intrvbar.h

Abstract:

    Definition of the interval bar class used by the CTimeRange class.

--*/

#ifndef _INTRVBAR_H_
#define _INTRVBAR_H_

class CIntervalBar {

    friend LRESULT APIENTRY IntervalBarWndProc (
        HWND hWnd,
        UINT uiMsg,
        WPARAM wParam,
        LPARAM lParam
        );

    private:
        enum {
        ModeNone,
        ModeLeft,
        ModeRight,
        ModeCenter
        };

       HWND           m_hWnd ;
       INT            m_iBeginValue ;        // user-supplied lowest range
       INT            m_iEndValue ;          // user-supplied highest range
       INT            m_iStartValue ;        // current start of selected interval
       INT            m_iStopValue ;         // current end of selected interval

       RECT           m_rectBorder ;
       RECT           m_rectLeftBk ;
       RECT           m_rectLeftGrab ;
       RECT           m_rectCenterGrab ;
       RECT           m_rectRightGrab ;
       RECT           m_rectRightBk ;

       HBRUSH         m_hBrushBk ;

       POINTS         m_ptsMouse ;
       INT            m_iMode ;              // who is being tracked?

       void NotifyChange ( void );
       BOOL GrabRect ( LPRECT lpRect );
       void DrawGrab (HDC hDC, LPRECT lprectGrab, BOOL bDown );
       INT  ValueToPixel ( INT iValue );
       INT  PixelToValue ( INT xPixel );
       void CalcPositions ( void );
       void Draw ( HDC hDC, LPRECT lprectUpdate );
       void MoveLeftRight ( BOOL bStart, BOOL bLeft, INT iMoveAmt );
       void StartGrab ( void );
       void EndGrab ( void );
       void Update ( void );

       BOOL OnKeyDown ( WPARAM wParam );
       void OnLButtonDown ( POINTS ptsMouse );
       void OnLButtonUp ( void );
       void OnMouseMove ( POINTS ptsMouse );

       
    public:
        CIntervalBar ( void );
        ~CIntervalBar ( void );
        BOOL Init ( HWND hWndParent );
        HWND Window ( void ) { return m_hWnd; }

        void SetRange ( INT iBegin, INT iEnd );
        void SetStart ( INT iStart );
        void SetStop  ( INT iStop );

        INT  Start ( void ) { return m_iStartValue; }
        INT  Stop  ( void ) { return m_iStopValue; }
        INT  XStart ( void ) { return m_rectLeftGrab.left; }
        INT  XStop  ( void ) { return m_rectRightGrab.right; }

};

typedef CIntervalBar *PCIntervalBar ;


//==========================================================================//
//                                  Constants                               //
//==========================================================================//

#define ILN_SELCHANGED        (WM_USER + 0x200)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\idataobj.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    idataobj.cpp

Abstract:

    Implementation of the IDataObject interface.

--*/

#include "polyline.h"
#include "unkhlpr.h"

// CImpIDataObject interface implmentation
IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpIDataObject)


/*
 * CImpIDataObject::GetData
 *
 * Purpose:
 *  Retrieves data described by a specific FormatEtc into a StgMedium
 *  allocated by this function.  Used like GetClipboardData.
 *
 * Parameters:
 *  pFE             LPFORMATETC describing the desired data.
 *  pSTM            LPSTGMEDIUM in which to return the data.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP 
CImpIDataObject::GetData(
    LPFORMATETC pFE, 
    LPSTGMEDIUM pSTM)
{
    CLIPFORMAT      cf=pFE->cfFormat;
    IStream         *pIStream;
    HRESULT         hr;
    HDC             hDevDC = NULL;

    //Check the aspects we support.
    if (!(DVASPECT_CONTENT & pFE->dwAspect))
        return ResultFromScode(DATA_E_FORMATETC);

    pSTM->pUnkForRelease=NULL;

    //Run creates the window to use as a basis for extents
    m_pObj->m_pImpIRunnableObject->Run(NULL);

    //Go render the appropriate data for the format.
    switch (cf)
        {
        case CF_METAFILEPICT:
            pSTM->tymed=TYMED_MFPICT;
            hDevDC = CreateTargetDC (NULL, pFE->ptd );
            if (hDevDC) {
                hr = m_pObj->RenderMetafilePict(&pSTM->hGlobal, hDevDC);
                ::DeleteDC(hDevDC);
            }
            else {
                hr = ResultFromScode(E_FAIL);
            }
            return hr;

        case CF_BITMAP:
            pSTM->tymed=TYMED_GDI;
            hDevDC = CreateTargetDC (NULL, pFE->ptd );
            if (hDevDC) {
                hr = m_pObj->RenderBitmap((HBITMAP *)&pSTM->hGlobal, hDevDC);
                ::DeleteDC(hDevDC);
            }
            else {
                hr = ResultFromScode(E_FAIL);
            }
            return hr;

        default:
            if (cf == m_pObj->m_cf)
                {
                hr = CreateStreamOnHGlobal(NULL, TRUE, &pIStream);
                if (FAILED(hr))
                    return ResultFromScode(E_OUTOFMEMORY);

                hr = m_pObj->m_pCtrl->SaveToStream(pIStream);

                if (FAILED(hr))
                    {
                    pIStream->Release();
                    return hr;
                    }

                pSTM->tymed = TYMED_ISTREAM;
                pSTM->pstm = pIStream;
                return NOERROR;
                }

            break;
        }

    return ResultFromScode(DATA_E_FORMATETC);
    }




/*
 * CImpIDataObject::GetDataHere
 *
 * Purpose:
 *  Renders the specific FormatEtc into caller-allocated medium
 *  provided in pSTM.
 *
 * Parameters:
 *  pFE             LPFORMATETC describing the desired data.
 *  pSTM            LPSTGMEDIUM providing the medium into which
 *                  wer render the data.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIDataObject::GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSTM) 
{
    CLIPFORMAT  cf;
    HRESULT     hr;

    /*
     * The only reasonable time this is called is for
     * CFSTR_EMBEDSOURCE and TYMED_ISTORAGE (and later for
     * CFSTR_LINKSOURCE).  This means the same as
     * IPersistStorage::Save.
     */

    cf=(CLIPFORMAT)RegisterClipboardFormat(CFSTR_EMBEDSOURCE);

    //Aspect is unimportant to us here, as is lindex and ptd.
    if (cf == pFE->cfFormat && (TYMED_ISTORAGE & pFE->tymed))
    {
        //We have an IStorage we can write into.
        pSTM->tymed=TYMED_ISTORAGE;
        pSTM->pUnkForRelease=NULL;

        hr = m_pObj->m_pImpIPersistStorage->Save(pSTM->pstg, FALSE);
        m_pObj->m_pImpIPersistStorage->SaveCompleted(NULL);
        return hr;
    }

    return ResultFromScode(DATA_E_FORMATETC);
}



/*
 * CImpIDataObject::QueryGetData
 *
 * Purpose:
 *  Tests if a call to GetData with this FormatEtc will provide
 *  any rendering; used like IsClipboardFormatAvailable.
 *
 * Parameters:
 *  pFE             LPFORMATETC describing the desired data.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIDataObject::QueryGetData(LPFORMATETC pFE) 
{
    CLIPFORMAT  cf=pFE->cfFormat;
    BOOL        fRet=FALSE;

    //Check the aspects we support.
    if (!(DVASPECT_CONTENT & pFE->dwAspect))
        return ResultFromScode(DATA_E_FORMATETC);

    switch (cf)
    {
        case CF_METAFILEPICT:
            fRet=(BOOL)(pFE->tymed & TYMED_MFPICT);
            break;

        case CF_BITMAP:
            fRet=(BOOL)(pFE->tymed & TYMED_GDI);
            break;

        default:
            //Check our own format.
            fRet=((cf==m_pObj->m_cf)
                && (BOOL)(pFE->tymed & (TYMED_ISTREAM) ));
            break;
    }

    return fRet ? NOERROR : ResultFromScode(DATA_E_FORMATETC);
}


/*
 * CImpIDataObject::GetCanonicalFormatEtc
 *
 * Purpose:
 *  Provides the caller with an equivalent FormatEtc to the one
 *  provided when different FormatEtcs will produce exactly the
 *  same renderings.
 *
 * Parameters:
 *  pFEIn            LPFORMATETC of the first description.
 *  pFEOut           LPFORMATETC of the equal description.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIDataObject::GetCanonicalFormatEtc
    (LPFORMATETC /* pFEIn */, LPFORMATETC pFEOut)
{
    if (NULL==pFEOut)
        return ResultFromScode(E_INVALIDARG);

    pFEOut->ptd=NULL;
    return ResultFromScode(DATA_S_SAMEFORMATETC);
}



/*
 * CImpIDataObject::SetData
 *
 * Purpose:
 *  Places data described by a FormatEtc and living in a StgMedium
 *  into the object.  The object may be responsible to clean up the
 *  StgMedium before exiting.
 *
 * Parameters:
 *  pFE             LPFORMATETC describing the data to set.
 *  pSTM            LPSTGMEDIUM containing the data.
 *  fRelease        BOOL indicating if this function is responsible
 *                  for freeing the data.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIDataObject::SetData(
    LPFORMATETC pFE , 
    LPSTGMEDIUM pSTM, 
    BOOL fRelease
    )
{
    CLIPFORMAT  cf=pFE->cfFormat;
    HRESULT     hr;

    //Check for our own clipboard format and DVASPECT_CONTENT
    if ((cf!=m_pObj->m_cf) || !(DVASPECT_CONTENT & pFE->dwAspect))
        return ResultFromScode(DATA_E_FORMATETC);

    // The medium must be a stream
    if (TYMED_ISTREAM != pSTM->tymed)
        return ResultFromScode(DATA_E_FORMATETC);

    hr = m_pObj->m_pCtrl->LoadFromStream(pSTM->pstm);

    if (fRelease)
        ReleaseStgMedium(pSTM);

    return hr;
}


/*
 * CImpIDataObject::EnumFormatEtc
 *
 * Purpose:
 *  Returns an IEnumFORMATETC object through which the caller can
 *  iterate to learn about all the data formats this object can
 *  provide through either GetData[Here] or SetData.
 *
 * Parameters:
 *  dwDir           DWORD describing a data direction, either
 *                  DATADIR_SET or DATADIR_GET.
 *  ppEnum          LPENUMFORMATETC * in which to return the
 *                  pointer to the enumerator.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIDataObject::EnumFormatEtc(
    DWORD dwDir, 
    LPENUMFORMATETC *ppEnum
    )
{
    return m_pObj->m_pDefIDataObject->EnumFormatEtc(dwDir, ppEnum);
}




/*
 * CImpIDataObject::DAdvise
 * CImpIDataObject::DUnadvise
 * CImpIDataObject::EnumDAdvise
 */

STDMETHODIMP CImpIDataObject::DAdvise(
    LPFORMATETC pFE, 
    DWORD dwFlags, 
    LPADVISESINK pIAdviseSink, 
    LPDWORD pdwConn
    )
{
    HRESULT  hr;

    // Check if requested format is supported
    hr = QueryGetData(pFE);
    if (FAILED(hr))
        return hr;

    if (NULL == m_pObj->m_pIDataAdviseHolder)
    {
        hr = CreateDataAdviseHolder(&m_pObj->m_pIDataAdviseHolder);

        if (FAILED(hr))
            return ResultFromScode(E_OUTOFMEMORY);
    }

    hr = m_pObj->m_pIDataAdviseHolder->Advise(this, 
                                              pFE, 
                                              dwFlags, 
                                              pIAdviseSink, 
                                              pdwConn);

    return hr;
}


STDMETHODIMP CImpIDataObject::DUnadvise(DWORD dwConn)
{
    HRESULT  hr;

    if (NULL==m_pObj->m_pIDataAdviseHolder)
        return ResultFromScode(E_FAIL);

    hr=m_pObj->m_pIDataAdviseHolder->Unadvise(dwConn);

    return hr;
}



STDMETHODIMP CImpIDataObject::EnumDAdvise(LPENUMSTATDATA *ppEnum)
{
    HRESULT  hr;

    if (NULL==m_pObj->m_pIDataAdviseHolder)
        return ResultFromScode(E_FAIL);

    hr=m_pObj->m_pIDataAdviseHolder->EnumAdvise(ppEnum);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\iipobj.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    iipobj.cpp

Abstract:

    IOleInPlaceObject interface implementation for Polyline

--*/

#include "polyline.h"
#include "unkhlpr.h"

/*
 *  CImpIOleInPlaceObject interface implementation
 */

IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpIOleInPlaceObject)


/*
 * CImpIOleInPlaceObject::GetWindow
 *
 * Purpose:
 *  Retrieves the handle of the window associated with the object
 *  on which this interface is implemented.
 *
 * Parameters:
 *  phWnd           HWND * in which to store the window handle.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, E_FAIL if there is no
 *                  window.
 */

STDMETHODIMP CImpIOleInPlaceObject::GetWindow(HWND *phWnd)
    {
    if (NULL!=m_pObj->m_pHW)
        *phWnd=m_pObj->m_pHW->Window();
    else
        *phWnd=m_pObj->m_pCtrl->Window();

    return NOERROR;
    }




/*
 * CImpIOleInPlaceObject::ContextSensitiveHelp
 *
 * Purpose:
 *  Instructs the object on which this interface is implemented to
 *  enter or leave a context-sensitive help mode.
 *
 * Parameters:
 *  fEnterMode      BOOL TRUE to enter the mode, FALSE otherwise.
 *
 * Return Value:
 *  HRESULT         NOERROR or an error code
 */

STDMETHODIMP CImpIOleInPlaceObject::ContextSensitiveHelp (
    BOOL /* fEnterMode */)
{
    return ResultFromScode(E_NOTIMPL);
}




/*
 * CImpIOleInPlaceObject::InPlaceDeactivate
 *
 * Purpose:
 *  Instructs the object to deactivate itself from an in-place state
 *  and to discard any Undo state.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or an error code
 */

STDMETHODIMP CImpIOleInPlaceObject::InPlaceDeactivate(void)
    {
    m_pObj->InPlaceDeactivate();
    return NOERROR;
    }




/*
 * CImpIOleInPlaceObject::UIDeactivate
 *
 * Purpose:
 *  Instructs the object to just remove any in-place user interface
 *  but to do no other deactivation.  The object should just hide
 *  the UI components but not destroy them until InPlaceDeactivate
 *  is called.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or an error code
 */

STDMETHODIMP CImpIOleInPlaceObject::UIDeactivate(void)
    {
    m_pObj->UIDeactivate();
    return NOERROR;
    }




/*
 * CImpIOleInPlaceObject::SetObjectRects
 *
 * Purpose:
 *  Provides the object with rectangles describing the position of
 *  the object in the container window as well as its visible area.
 *
 * Parameters:
 *  prcPos          LPCRECT providing the object's full rectangle
 *                  relative to the continer's document.  The object
 *                  should scale to this rectangle.
 *  prcClip         LPCRECT describing the visible area of the object
 *                  which should not draw outside these areas.
 *
 * Return Value:
 *  HRESULT         NOERROR or an error code
 */

STDMETHODIMP CImpIOleInPlaceObject::SetObjectRects(LPCRECT prcPos
    , LPCRECT prcClip)
    {
    if (NULL!=m_pObj->m_pHW)
        m_pObj->m_pHW->RectsSet((LPRECT)prcPos, (LPRECT)prcClip);

    return NOERROR;
    }




/*
 * CImpIOleInPlaceObject::ReactivateAndUndo
 *
 * Purpose:
 *  Instructs the object to reactivate itself in-place and perform
 *  whatever Undo means for it.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or an error code
 */

STDMETHODIMP CImpIOleInPlaceObject::ReactivateAndUndo(void)
    {
    return m_pObj->InPlaceActivate(m_pObj->m_pIOleClientSite, TRUE);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\inole.h ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    inole.h

Abstract:

    Master header file for all Inside OLE samples.

--*/

#ifndef _INOLE_H_
#define _INOLE_H_

#define INC_OLE2
#include <windows.h>
#include <ole2.h>
#include <ole2ver.h>

#ifdef INITGUIDS
#include <initguid.h>
#endif

#include <oleauto.h>
#include <olectl.h>



//Types that OLE2.H et. al. leave out

#ifndef PPVOID
typedef LPVOID * PPVOID;
#endif  //PPVOID


#ifdef _OLE2_H_   //May not include ole2.h at all times.

#ifndef PPOINTL
typedef POINTL * PPOINTL;
#endif  //PPOINTL


#ifndef _WIN32
#ifndef OLECHAR
typedef char OLECHAR;
typedef OLECHAR FAR* LPOLESTR;
typedef const OLECHAR FAR* LPCOLESTR;
#endif //OLECHAR
#endif //_WIN32

#include <tchar.h>

//Useful macros.
#define SETFormatEtc(fe, cf, asp, td, med, li)   \
    {\
    (fe).cfFormat=cf;\
    (fe).dwAspect=asp;\
    (fe).ptd=td;\
    (fe).tymed=med;\
    (fe).lindex=li;\
    }

#define SETDefFormatEtc(fe, cf, med)   \
    {\
    (fe).cfFormat=cf;\
    (fe).dwAspect=DVASPECT_CONTENT;\
    (fe).ptd=NULL;\
    (fe).tymed=med;\
    (fe).lindex=-1;\
    }


#define SETRECTL(rcl, l, t, r, b) \
    {\
    (rcl).left=l;\
    (rcl).top=t;\
    (rcl).right=r;\
    (rcl).bottom=b;\
    }

#define SETSIZEL(szl, h, v) \
    {\
    (szl).cx=h;\
    (szl).cy=v;\
    }


#define RECTLFROMRECT(rcl, rc)\
    {\
    (rcl).left=(long)(rc).left;\
    (rcl).top=(long)(rc).top;\
    (rcl).right=(long)(rc).right;\
    (rcl).bottom=(long)(rc).bottom;\
    }


#define RECTFROMRECTL(rc, rcl)\
    {\
    (rc).left=(int)(rcl).left;\
    (rc).top=(int)(rcl).top;\
    (rc).right=(int)(rcl).right;\
    (rc).bottom=(int)(rcl).bottom;\
    }


#define POINTLFROMPOINT(ptl, pt) \
    { \
    (ptl).x=(long)(pt).x; \
    (ptl).y=(long)(pt).y; \
    }


#define POINTFROMPOINTL(pt, ptl) \
    { \
    (pt).x=(int)(ptl).x; \
    (pt).y=(int)(ptl).y; \
    }

//Here's one that should be in windows.h
#define SETPOINT(pt, h, v) \
    {\
    (pt).x=h;\
    (pt).y=v;\
    }

#define SETPOINTL(ptl, h, v) \
    {\
    (ptl).x=h;\
    (ptl).y=v;\
    }

#endif  //_OLE2_H_

//Macros for setting DISPPARAMS structures
#define SETDISPPARAMS(dp, numArgs, pvArgs, numNamed, pNamed) \
    {\
    (dp).cArgs=numArgs;\
    (dp).rgvarg=pvArgs;\
    (dp).cNamedArgs=numNamed;\
    (dp).rgdispidNamedArgs=pNamed;\
    }

#define SETNOPARAMS(dp) SETDISPPARAMS(dp, 0, NULL, 0, NULL)

//Macros for setting EXCEPINFO structures
#define SETEXCEPINFO(ei, excode, src, desc, file, ctx, func, scd) \
    {\
    (ei).wCode=excode;\
    (ei).wReserved=0;\
    (ei).bstrSource=src;\
    (ei).bstrDescription=desc;\
    (ei).bstrHelpFile=file;\
    (ei).dwHelpContext=ctx;\
    (ei).pvReserved=NULL;\
    (ei).pfnDeferredFillIn=func;\
    (ei).scode=scd;\
    }


#define INITEXCEPINFO(ei) \
        SETEXCEPINFO(ei,0,NULL,NULL,NULL,0L,NULL,S_OK)


/*
 * State flags for IPersistStorage implementations.  These
 * are kept here to avoid repeating the code in all samples.
 */

typedef enum
    {
    PSSTATE_UNINIT,     //Uninitialized
    PSSTATE_SCRIBBLE,   //Scribble
    PSSTATE_ZOMBIE,     //No scribble
    PSSTATE_HANDSOFF    //Hand-off
    } PSSTATE;


/*
 * Identifers to describe which persistence model an object
 * is using, along with a union type that holds on the the
 * appropriate pointers that a client may need.
 */
typedef enum
    {
    PERSIST_UNKNOWN=0,
    PERSIST_STORAGE,
    PERSIST_STREAM,
    PERSIST_STREAMINIT,
    PERSIST_FILE
    } PERSIST_MODEL;

typedef struct
    {
    PERSIST_MODEL   psModel;
    union
        {
        IPersistStorage    *pIPersistStorage;
        IPersistStream     *pIPersistStream;
        IPersistStreamInit *pIPersistStreamInit;
        IPersistFile       *pIPersistFile;
        } pIP;

    } PERSISTPOINTER, *PPERSISTPOINTER;


//To identify a storage in which to save, load, or create.
typedef struct
    {
    PERSIST_MODEL   psModel;
    union
        {
        IStorage    *pIStorage;
        IStream     *pIStream;
        } pIS;

    } STGPOINTER, *PSTGPOINTER;



//Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);


//DeleteInterfaceImp calls 'delete' and NULLs the pointer
#define DeleteInterfaceImp(p)\
            {\
            if (NULL!=p)\
                {\
                delete p;\
                p=NULL;\
                }\
            }


//ReleaseInterface calls 'Release' and NULLs the pointer
#define ReleaseInterface(p)\
            {\
            if (NULL!=p)\
                {\
                p->Release();\
                p=NULL;\
                }\
            }


//OLE Documents Clipboard Formats

#define CFSTR_EMBEDSOURCE       TEXT("Embed Source")
#define CFSTR_EMBEDDEDOBJECT    TEXT("Embedded Object")
#define CFSTR_LINKSOURCE        TEXT("Link Source")
#define CFSTR_CUSTOMLINKSOURCE  TEXT("Custom Link Source")
#define CFSTR_OBJECTDESCRIPTOR  TEXT("Object Descriptor")
#define CFSTR_LINKSRCDESCRIPTOR TEXT("Link Source Descriptor")


#endif //_INOLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\ioleobj.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    ioleobj.cpp

Abstract:

    Implementation of the IOleObject interface for Polyline.  Some of
    these just pass through to the default handler which does default
    implementations.

--*/

#include "polyline.h"
#include "unkhlpr.h"
#include "utils.h"
#include "unihelpr.h"

void RegisterAsRunning(IUnknown *pUnk, IMoniker *pmk, 
                    DWORD dwFlags, LPDWORD pdwReg);

/*
 * CImpIOleObject interface implementation
 */

IMPLEMENT_CONTAINED_CONSTRUCTOR(CPolyline, CImpIOleObject)
IMPLEMENT_CONTAINED_DESTRUCTOR(CImpIOleObject)

IMPLEMENT_CONTAINED_QUERYINTERFACE(CImpIOleObject)
IMPLEMENT_CONTAINED_ADDREF(CImpIOleObject)


STDMETHODIMP_(ULONG) CImpIOleObject::Release(
    void
    )
{
    --m_cRef;

#if 0
    // Release cached site related interfaces
    if (m_cRef == 0) {
        ReleaseInterface(m_pObj->m_pIOleClientSite);
        ReleaseInterface(m_pObj->m_pIOleControlSite);
        ReleaseInterface(m_pObj->m_pIDispatchAmbients);
    }
#endif

    return m_pUnkOuter->Release();
}

/*
 * CImpIOleObject::SetClientSite
 * CImpIOleObject::GetClientSite
 *
 * Purpose:
 *  Manages the IOleClientSite pointer of our container.
 */

STDMETHODIMP CImpIOleObject::SetClientSite (LPOLECLIENTSITE pIOleClientSite)
{
    ReleaseInterface(m_pObj->m_pIOleClientSite);
    ReleaseInterface(m_pObj->m_pIOleControlSite);
    ReleaseInterface(m_pObj->m_pIDispatchAmbients);

    m_pObj->m_pIOleClientSite = pIOleClientSite;

    if (NULL != m_pObj->m_pIOleClientSite) {
        HRESULT         hr;
        LPMONIKER       pmk;
        LPOLECONTAINER  pIOleCont;

        m_pObj->m_pIOleClientSite->AddRef();

        /*
         * Within IRunnableObject::Run we're supposed to register
         * ourselves as running...however, the moniker has to come
         * from the container's IOleClientSite::GetMoniker.  But
         * Run is called before SetClientSite here, so we have to
         * register now that we do have the client site as well
         * as lock the container.
         */

        hr = m_pObj->m_pIOleClientSite->GetMoniker
            (OLEGETMONIKER_ONLYIFTHERE, OLEWHICHMK_OBJFULL, &pmk);

        if (SUCCEEDED(hr)) {
            RegisterAsRunning(m_pUnkOuter, pmk, 0, &m_pObj->m_dwRegROT);
            pmk->Release();
        }

        hr = m_pObj->m_pIOleClientSite->GetContainer(&pIOleCont);

        if (SUCCEEDED(hr)) {
            m_pObj->m_fLockContainer=TRUE;
            pIOleCont->LockContainer(TRUE);
            pIOleCont->Release();
        }

        /*
         * Go get the container's IDispatch for ambient
         * properties if it has one, and initilize ourself
         * with those properties.
         */
        hr = m_pObj->m_pIOleClientSite->QueryInterface(IID_IDispatch
            , (void **)&m_pObj->m_pIDispatchAmbients);

        if (SUCCEEDED(hr))
            m_pObj->AmbientsInitialize((ULONG)INITAMBIENT_ALL);
        /*
         * Get the control site
         */
        hr = m_pObj->m_pIOleClientSite->QueryInterface(IID_IOleControlSite, (void **)&m_pObj->m_pIOleControlSite);

    }

    return NOERROR;
}

STDMETHODIMP CImpIOleObject::GetClientSite(LPOLECLIENTSITE *ppSite)
{
    //Be sure to AddRef the new pointer you are giving away.
    *ppSite=m_pObj->m_pIOleClientSite;
    m_pObj->m_pIOleClientSite->AddRef();

    return NOERROR;
}





/*
 * CImpIOleObject::SetHostNames
 *
 * Purpose:
 *  Provides the object with names of the container application and
 *  the object in the container to use in object user interface.
 *
 * Parameters:
 *  pszApp          LPCOLESTR of the container application.
 *  pszObj          LPCOLESTR of some name that is useful in window
 *                  titles.
 *
 * Return Value:
 *  HRESULT         NOERROR
 */

STDMETHODIMP CImpIOleObject::SetHostNames(LPCOLESTR /* pszApp */
    , LPCOLESTR /* pszObj */)
{
    return NOERROR;
}





/*
 * CImpIOleObject::Close
 *
 * Purpose:
 *  Forces the object to close down its user interface and unload.
 *
 * Parameters:
 *  dwSaveOption    DWORD describing the circumstances under which
 *                  the object is being saved and closed.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIOleObject::Close(DWORD dwSaveOption)
{
    BOOL fSave=FALSE;

    //If object is dirty and we're asked to save, save it and close.
    if (OLECLOSE_SAVEIFDIRTY==dwSaveOption && m_pObj->m_fDirty)
        fSave=TRUE;

    /*
     * If asked to prompt, only do so if dirty, then if we get a
     * YES, save as usual and close.  On NO, just close.  On
     * CANCEL return OLE_E_PROMPTSAVECANCELLED.
     */
    if (OLECLOSE_PROMPTSAVE==dwSaveOption && m_pObj->m_fDirty) {
        UINT uRet;

        uRet = MessageBox(NULL, ResourceString(IDS_CLOSEPROMPT),
                          ResourceString(IDS_CLOSECAPTION), MB_YESNOCANCEL);

        if (IDCANCEL==uRet)
            return ResultFromScode(OLE_E_PROMPTSAVECANCELLED);

        if (IDYES==uRet)
            fSave=TRUE;
    }

    if (fSave) {
        m_pObj->SendAdvise(OBJECTCODE_SAVEOBJECT);
        m_pObj->SendAdvise(OBJECTCODE_SAVED);
    }

    //We get directly here on OLECLOSE_NOSAVE.
    if ( m_pObj->m_fLockContainer && ( NULL != m_pObj->m_pIOleClientSite ) ) {

        //Match LockContainer call from SetClientSite
        LPOLECONTAINER  pIOleCont;

        if (SUCCEEDED(m_pObj->m_pIOleClientSite->GetContainer(&pIOleCont))) {
            pIOleCont->LockContainer(FALSE);
            pIOleCont->Release();
        }
    }
    
    // Deactivate
    m_pObj->InPlaceDeactivate();

    // Revoke registration in ROT
    if (m_pObj->m_dwRegROT != 0) {

        IRunningObjectTable    *pROT;

        if (!FAILED(GetRunningObjectTable(0, &pROT))) {
            pROT->Revoke(m_pObj->m_dwRegROT);   
            pROT->Release();
            m_pObj->m_dwRegROT = 0;
        }
    }

    return NOERROR;
}




/*
 * CImpIOleObject::DoVerb
 *
 * Purpose:
 *  Executes an object-defined action.
 *
 * Parameters:
 *  iVerb           LONG index of the verb to execute.
 *  pMSG            LPMSG describing the event causing the
 *                  activation.
 *  pActiveSite     LPOLECLIENTSITE to the site involved.
 *  lIndex          LONG the piece on which execution is happening.
 *  hWndParent      HWND of the window in which the object can play
 *                  in-place.
 *  pRectPos        LPRECT of the object in hWndParent where the
 *                  object can play in-place if desired.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIOleObject::DoVerb(LONG iVerb, LPMSG /* pMSG */
    , LPOLECLIENTSITE pActiveSite, LONG /* lIndex */, HWND /* hWndParent */
    , LPCRECT /* pRectPos */)
{
    HRESULT     hr;
    CAUUID      caGUID;

    USES_CONVERSION

    switch (iVerb)
    {
        case OLEIVERB_HIDE:
            if (NULL != m_pObj->m_pIOleIPSite) {
                m_pObj->UIDeactivate();
                ShowWindow(m_pObj->m_pHW->Window(), SW_HIDE);
            }
            else {

                ShowWindow(m_pObj->m_pHW->Window(), SW_HIDE);
                m_pObj->SendAdvise(OBJECTCODE_HIDEWINDOW);
            }
            break;

        case OLEIVERB_PRIMARY:
        case OLEIVERB_SHOW:
            if (NULL != m_pObj->m_pIOleIPSite) {
                ShowWindow(m_pObj->m_pHW->Window(), SW_SHOW);
                return NOERROR; //Already active
            }

            if (m_pObj->m_fAllowInPlace) {
                return m_pObj->InPlaceActivate(pActiveSite ,TRUE);
            }

            return ResultFromScode(OLEOBJ_S_INVALIDVERB); 
            break;

        case OLEIVERB_INPLACEACTIVATE:
            if (NULL != m_pObj->m_pHW) {
                HWND hWndHW=m_pObj->m_pHW->Window();

                ShowWindow(hWndHW, SW_SHOW);
                SetFocus(hWndHW);

                return NOERROR;
            }

            /*
             * Only inside-out supporting containers will use
             * this verb.
             */
            m_pObj->m_fContainerKnowsInsideOut=TRUE;
            m_pObj->InPlaceActivate(pActiveSite, FALSE);
            break;

        case OLEIVERB_UIACTIVATE:
            m_pObj->InPlaceActivate(pActiveSite, TRUE);
            break;

        case OLEIVERB_PROPERTIES:
        case POLYLINEVERB_PROPERTIES:

            /*
             * Let the container try first if there are
             * extended controls.  Otherwise we'll display
             * our own pages.
             */
            if (NULL!=m_pObj->m_pIOleControlSite) {
                hr=m_pObj->m_pIOleControlSite->ShowPropertyFrame();

                if (NOERROR==hr)
                    break;      //All done
            }


            //Put up our property pages.
            hr=m_pObj->m_pImpISpecifyPP->GetPages(&caGUID);

            if (FAILED(hr))
                return FALSE;

            hr=OleCreatePropertyFrame(m_pObj->m_pCtrl->Window(), 10, 10
                , T2W(ResourceString(IDS_PROPFRM_TITLE)), 1, (IUnknown **)&m_pObj
                , caGUID.cElems, caGUID.pElems
                , LOCALE_USER_DEFAULT, 0L, NULL);

            //Free the GUIDs
            CoTaskMemFree((void *)caGUID.pElems);
            break;

        default:
            return ResultFromScode(OLEOBJ_S_INVALIDVERB);
    }

    return NOERROR;
}






/*
 * CImpIOleObject::GetUserClassID
 *
 * Purpose:
 *  Used for linked objects, this returns the class ID of what end
 *  users think they are editing.
 *
 * Parameters:
 *  pClsID          LPCLSID in which to store the CLSID.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIOleObject::GetUserClassID(LPCLSID pClsID)
{
    /*
     * If you are not registered to handle data other than yourself,
     * then you can just return your class ID here.  If you are
     * registered as usable from Treat-As dialogs, then you need to
     * return the CLSID of what you are really editing.
     */

    *pClsID=CLSID_SystemMonitor;
    return NOERROR;
}





/*
 * CImpIOleObject::SetExtent
 *
 * Purpose:
 *  Sets the size of the object in HIMETRIC units.
 *
 * Parameters:
 *  dwAspect        DWORD of the aspect affected.
 *  pszl            LPSIZEL containing the new size.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIOleObject::SetExtent(
    DWORD dwAspect,
    LPSIZEL pszl )
{

    RECT rectExt;

    if (dwAspect == DVASPECT_CONTENT) {
        // convert from HIMETRIC to device coord
        SetRect(&rectExt, 0, 0, pszl->cx, pszl->cy);
        m_pObj->RectConvertMappings(&rectExt,TRUE);

        // If changed and non-zero, store as new extent

        if ( !EqualRect ( &m_pObj->m_RectExt, &rectExt )
                && !IsRectEmpty( &rectExt ) ) {
            m_pObj->m_RectExt = rectExt;

            m_pObj->m_pImpIPolyline->SizeSet(&rectExt, TRUE);
            // Notify container of change to force metafile update
            //m_pObj->SendAdvise(OBJECTCODE_DATACHANGED);
        }
    }

    return NOERROR;
}

/*
 * CImpIOleObject::GetExtent
 *
 * Purpose:
 *  Retrieves the size of the object in HIMETRIC units.
 *
 * Parameters:
 *  dwAspect        DWORD of the aspect requested
 *  pszl            LPSIZEL into which to store the size.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIOleObject::GetExtent(DWORD dwAspect, LPSIZEL pszl)
{
    //Delegate directly to IViewObject2::GetExtent
    return m_pObj->m_pImpIViewObject->GetExtent(dwAspect, -1
        , NULL, pszl);
}





/*
 * CImpIOleObject::Advise
 * CImpIOleObject::Unadvise
 * CImpIOleObject::EnumAdvise
 *
 * Purpose:
 *  Advisory connection functions.
 */

STDMETHODIMP CImpIOleObject::Advise(
    LPADVISESINK pIAdviseSink, 
    LPDWORD pdwConn
    )
{
    if (NULL==m_pObj->m_pIOleAdviseHolder)
    {
        HRESULT     hr;

        hr=CreateOleAdviseHolder(&m_pObj->m_pIOleAdviseHolder);

        if (FAILED(hr))
            return hr;
    }

    return m_pObj->m_pIOleAdviseHolder->Advise(pIAdviseSink, pdwConn);
}


STDMETHODIMP CImpIOleObject::Unadvise(DWORD dwConn)
{
    if (NULL!=m_pObj->m_pIOleAdviseHolder)
        return m_pObj->m_pIOleAdviseHolder->Unadvise(dwConn);

    return ResultFromScode(E_FAIL);
}


STDMETHODIMP CImpIOleObject::EnumAdvise(LPENUMSTATDATA *ppEnum)
{
    if (NULL!=m_pObj->m_pIOleAdviseHolder)
        return m_pObj->m_pIOleAdviseHolder->EnumAdvise(ppEnum);

    return ResultFromScode(E_FAIL);
}



/*
 * CImpIOleObject::SetMoniker
 *
 * Purpose:
 *  Informs the object of its moniker or its container's moniker
 *  depending on dwWhich.
 *
 * Parameters:
 *  dwWhich         DWORD describing whether the moniker is the
 *                  object's or the container's.
 *  pmk             LPMONIKER with the name.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIOleObject::SetMoniker(DWORD /* dwWhich */
    , LPMONIKER /* pmk */)
{
    LPMONIKER  pmkFull;
    HRESULT    hr = ResultFromScode(E_FAIL);
    HRESULT    hrTmp;
    LPBC       pbc;

    if (NULL!=m_pObj->m_pIOleClientSite) {
        hr = m_pObj->m_pIOleClientSite->GetMoniker
                (OLEGETMONIKER_ONLYIFTHERE, OLEWHICHMK_OBJFULL
                , &pmkFull);

        if (SUCCEEDED(hr)) {
            hrTmp = CreateBindCtx(0,&pbc);

            if (SUCCEEDED(hrTmp)) {
                hrTmp = pmkFull->IsRunning(pbc, NULL, NULL);
                pbc->Release();

                if (hrTmp == NOERROR) {
                    pmkFull->Release();
                    return NOERROR;
                }
            }

            //This will revoke the old one if m_dwRegROT is nonzero.
            RegisterAsRunning(m_pUnkOuter, pmkFull, 0, &m_pObj->m_dwRegROT);

            //Inform clients of the new moniker
            if (NULL!=m_pObj->m_pIOleAdviseHolder)
                m_pObj->m_pIOleAdviseHolder->SendOnRename(pmkFull);

            pmkFull->Release();
        }
    }   
    return hr;
}



/*
 * CImpIOleObject::GetMoniker
 *
 * Purpose:
 *  Asks the object for a moniker that can later be used to
 *  reconnect to it.
 *
 * Parameters:
 *  dwAssign        DWORD determining how to assign the moniker to
 *                  to the object.
 *  dwWhich         DWORD describing which moniker the caller wants.
 *  ppmk            LPMONIKER * into which to store the moniker.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIOleObject::GetMoniker(DWORD /* dwAssign */
    , DWORD /* dwWhich */, LPMONIKER *ppmk)
{
    HRESULT         hr=ResultFromScode(E_FAIL);

    *ppmk=NULL;

    /*
     * Since we only support embedded objects, our moniker
     * is always the full moniker from the contianer.
     */

    if (NULL!=m_pObj->m_pIOleClientSite)
    {
        hr=m_pObj->m_pIOleClientSite->GetMoniker
            (OLEGETMONIKER_ONLYIFTHERE, OLEWHICHMK_OBJFULL, ppmk);
    }

    return (NULL!=*ppmk) ? NOERROR : hr;
}



//Methods not implemented or trivial
STDMETHODIMP CImpIOleObject::InitFromData(
    LPDATAOBJECT /* pIDataObject */
    , BOOL /* fCreation */, DWORD /* dw */)
{
    return ResultFromScode(E_NOTIMPL);
}

STDMETHODIMP CImpIOleObject::GetClipboardData(DWORD /* dwReserved */
    , LPDATAOBJECT * /* ppIDataObj */)
{
    return ResultFromScode(E_NOTIMPL);
}

STDMETHODIMP CImpIOleObject::Update(void)
{
    return NOERROR;
}

STDMETHODIMP CImpIOleObject::IsUpToDate(void)
{
    return NOERROR;
}

STDMETHODIMP CImpIOleObject::SetColorScheme(LPLOGPALETTE /* pLP */)
{
    return ResultFromScode(E_NOTIMPL);
}



//Methods implemented using registry helper functions in OLE.

STDMETHODIMP CImpIOleObject::EnumVerbs(LPENUMOLEVERB *ppEnum)
{
    return OleRegEnumVerbs(m_pObj->m_clsID, ppEnum);
}

STDMETHODIMP CImpIOleObject::GetUserType(
    DWORD dwForm, 
    LPOLESTR *ppszType
    )
{
    return OleRegGetUserType(m_pObj->m_clsID, dwForm, ppszType);
}

STDMETHODIMP CImpIOleObject::GetMiscStatus(
    DWORD dwAspect, 
    LPDWORD pdwStatus
    )
{
    return OleRegGetMiscStatus(m_pObj->m_clsID, dwAspect, pdwStatus);
}


void RegisterAsRunning(
    IUnknown *pUnk, 
    IMoniker *pmk, 
    DWORD dwFlags, 
    LPDWORD pdwReg
    )
{
    IRunningObjectTable    *pROT;
    HRESULT                 hr;
    DWORD                   dwReg = *pdwReg;

    dwReg=*pdwReg;

    if (FAILED(GetRunningObjectTable(0, &pROT)))
        return;

    hr = pROT->Register(dwFlags, pUnk, pmk, pdwReg);

    if (MK_S_MONIKERALREADYREGISTERED == GetScode(hr))
        {
        if (0 != dwReg)
            pROT->Revoke(dwReg);
        }

    pROT->Release();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\intrvbar.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    intrvbar.cpp

Abstract:

    Implementation of the interval bar control.

--*/


//==========================================================================//
//                                  Includes                                //
//==========================================================================//
#include <windows.h>
#include <assert.h>
#include <limits.h>
#include "globals.h"
#include "winhelpr.h"
#include "utils.h"
#include "intrvbar.h"


//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#define dwILineClassStyle     (CS_HREDRAW | CS_VREDRAW)
#define dwILineWindowStyle    (WS_CHILD | WS_VISIBLE) 

#define TO_THE_END            0x7FFFFFFFL

#define szILineClass          TEXT("IntervalBar")



//==========================================================================//
//                                   Macros                                 //
//==========================================================================//


// Width of the start and stob grab bars
#define ILGrabWidth()      \
   (10)

#define ILGrabMinimumWidth()      \
   (6)

// A rectangle is "drawable" if it has both nonzero height and minimum width
#define PRectDrawable(lpRect)           \
   ((lpRect->right - lpRect->left) >= ILGrabMinimumWidth()) &&  \
    (lpRect->bottom - lpRect->top)

#define RectDrawable(Rect)           \
   ((Rect.right - Rect.left) >= ILGrabMinimumWidth()) &&  \
    (Rect.bottom - Rect.top)

//==========================================================================//
//                              Local Functions                             //
//==========================================================================//
void 
CIntervalBar::NotifyChange (
    void
    )
{
   HWND     hWndParent ;

   hWndParent = WindowParent (m_hWnd) ;

   if (hWndParent)
      SendMessage (hWndParent, WM_COMMAND, 
                   (WPARAM) WindowID (m_hWnd),
                   (LPARAM) m_hWnd) ;
}


BOOL
CIntervalBar::GrabRect (
    OUT LPRECT lpRect
    )
{
   switch (m_iMode) {
       
      case ModeLeft:
         *lpRect = m_rectLeftGrab ;
         return (TRUE) ;
         break ;

      case ModeRight:
         *lpRect = m_rectRightGrab ;
         return (TRUE) ;
         break ;

      case ModeCenter:
         *lpRect = m_rectCenterGrab ;
         return (TRUE) ;
         break ;

      case ModeNone:
         lpRect->left = 0 ;
         lpRect->top = 0 ;
         lpRect->right = 0 ;
         lpRect->bottom = 0 ;
         return (FALSE) ;
         break ;

      default:
          return (FALSE);
    }
}




void
CIntervalBar::DrawGrab (
    HDC hDC,
    LPRECT lpRectGrab,
    BOOL bDown
    )
{
   if (!PRectDrawable(lpRectGrab))
      return ;

   Fill(hDC, GetSysColor(COLOR_3DFACE), lpRectGrab);
   DrawEdge (hDC, lpRectGrab, (bDown ? EDGE_SUNKEN:EDGE_RAISED), BF_RECT);
}


INT 
CIntervalBar::ValueToPixel (
    INT iValue
    )
{
   INT  xPixel ;

   if (m_iEndValue > m_iBeginValue)
      xPixel = MulDiv (iValue, m_rectBorder.right, (m_iEndValue - m_iBeginValue)) ;
   else
      xPixel = 0 ;

   return (PinExclusive (xPixel, 0, m_rectBorder.right)) ;
}


INT 
CIntervalBar::PixelToValue (
    INT xPixel
    )
{
   INT  iValue ;

   if (m_rectBorder.right)
      iValue = MulDiv (xPixel, (m_iEndValue - m_iBeginValue), m_rectBorder.right) ;
   else
      iValue = 0 ;

   return (PinInclusive (iValue, m_iBeginValue, m_iEndValue)) ;
   }


void 
CIntervalBar::CalcPositions (
    void
    )

/*
   Effect:        Determine and set all of the physical rectangles of ILine,
                  based on the current size of the ILine window and the 
                  current logical Start, Stop, Begin, and End values.
*/
{
    INT   xStart, xStop ;
    INT   yHeight ;

    GetClientRect (m_hWnd, &m_rectBorder) ;
    yHeight = m_rectBorder.bottom ;

    xStart = ValueToPixel (m_iStartValue) ;
    xStop = ValueToPixel (m_iStopValue) ;

    m_rectLeftBk.left = 1 ;
    m_rectLeftBk.top = 1 ;
    m_rectLeftBk.right = xStart ;
    m_rectLeftBk.bottom = yHeight - 1 ;

    m_rectLeftGrab.left = xStart ;
    m_rectLeftGrab.top = 1 ;
    m_rectLeftGrab.right = xStart + ILGrabWidth () ;
    m_rectLeftGrab.bottom = yHeight - 1 ;

    m_rectRightBk.left = xStop ;
    m_rectRightBk.top = 1 ;
    m_rectRightBk.right = m_rectBorder.right - 1 ;
    m_rectRightBk.bottom = yHeight - 1 ;

    m_rectRightGrab.left = xStop - ILGrabWidth () ;
    m_rectRightGrab.top = 1 ;
    m_rectRightGrab.right = xStop ;
    m_rectRightGrab.bottom = yHeight - 1 ;

    m_rectCenterGrab.left = m_rectLeftGrab.right ;
    m_rectCenterGrab.top = 1 ;
    m_rectCenterGrab.right = m_rectRightGrab.left ;
    m_rectCenterGrab.bottom = yHeight - 1 ;

    if (m_rectLeftGrab.right > m_rectRightGrab.left) {
        m_rectLeftGrab.right = m_rectLeftGrab.left + (xStop - xStart) / 2 ;
        m_rectRightGrab.left = m_rectLeftGrab.right ;
        m_rectCenterGrab.left = 0 ;
        m_rectCenterGrab.right = 0 ;

        // Ensure that at least one grab bar is visible when End > Begin and the total is 
        // wide enough.  ILGrabMinimumWidth + 2 is the minimum.
        // If on the left edge, make the Right grab visible. 
        // If on the right edge, make the Left grab visible.  
        // If in the middle, make them both visible.
        if ( !RectDrawable(m_rectLeftGrab) 
           || !RectDrawable(m_rectRightGrab) ) {
            
            INT iWidth = ILGrabMinimumWidth();

            if ( !RectDrawable(m_rectRightBk) ) {
                // Make the Left grab visible.
                m_rectRightGrab.left = m_rectRightGrab.right;
                m_rectLeftGrab.right = m_rectRightGrab.right;
                m_rectLeftGrab.left = m_rectLeftGrab.right - iWidth;
            } else if (!RectDrawable(m_rectLeftBk) ) {
                // Make the Right grab visible.
                m_rectLeftGrab.right = m_rectLeftGrab.left;
                m_rectRightGrab.left = m_rectLeftGrab.left;
                m_rectRightGrab.right = m_rectRightGrab.left + iWidth;
            } else {
                // Make them both visible.
                m_rectLeftGrab.left -= iWidth;
                m_rectRightGrab.right += iWidth;
            }
        }
   }
}


void
CIntervalBar::Draw (
    HDC hDC,     
    LPRECT // lpRectUpdate
    )
/*
   Effect:        Draw the image of pILine on hDC.  Draw at least the 
                  portions within rectUpdate.

   Called By:     OnPaint, OnMouseMove.
*/
{
    if (IsWindowEnabled(m_hWnd)) {
       FillRect (hDC, &m_rectLeftBk, m_hBrushBk) ;
       FillRect (hDC, &m_rectRightBk, m_hBrushBk) ;
   
       //DrawEdge (hDC, &m_rectBorder, BDR_SUNKENINNER, BF_RECT) ;
       DrawEdge (hDC, &m_rectBorder, EDGE_SUNKEN, BF_RECT) ;

       DrawGrab (hDC, &m_rectLeftGrab, m_iMode == ModeLeft) ;
       DrawGrab (hDC, &m_rectRightGrab, m_iMode == ModeRight) ;
       DrawGrab (hDC, &m_rectCenterGrab, m_iMode == ModeCenter) ;
    }
    else {
        Fill(hDC, GetSysColor(COLOR_3DFACE), &m_rectBorder);
        DrawEdge (hDC, &m_rectBorder, EDGE_SUNKEN, BF_RECT) ;
    }
}


void
CIntervalBar::MoveLeftRight (
    BOOL bStart,
    BOOL bLeft,
    INT  iMoveAmt
    )
{
   INT      iStart, iStop, iMove ;

   iStart = m_iStartValue;
   iStop = m_iStopValue;
   iMove = iMoveAmt ;

   if (bLeft)
      iMove = -iMove ;

   if (bStart)
      {
      if (iMoveAmt == TO_THE_END) {
         iStart = m_iBeginValue ;
      }
      else {
         iStart += iMove ;
         if (iStart >= iStop) {
            return;
         }
      }

      SetStart (iStart) ;
   }
   else {
      if (iMoveAmt == TO_THE_END) {
         iStop = m_iEndValue ;
      }
      else {
         iStop += iMove ;
         if (iStart >= iStop) {
            return;
         }
      }

      SetStop (iStop) ;
   }

   NotifyChange () ;
}


BOOL 
CIntervalBar::OnKeyDown (
    WPARAM wParam
    )
{
   BOOL bHandle = TRUE ;
   BOOL bStart ;
   BOOL bLeftDirection ;
   BOOL bShiftKeyDown ;

   if (wParam == VK_LEFT || wParam == VK_RIGHT) {
      bShiftKeyDown = (GetKeyState (VK_SHIFT) < 0) ;

      if (!bShiftKeyDown) {
         if (wParam == VK_LEFT) {
            // Left Arrow --> move Start Edge Left
            bStart = TRUE ;
            bLeftDirection = TRUE ;
         }
         else {
            // Right Arrow --> move Stop Edge Right
            bStart = FALSE ;
            bLeftDirection = FALSE ;
         }
      }
      else {
         if (wParam == VK_LEFT) {
            // Shift Left Arrow --> move Stop Edge Left
            bStart = FALSE ;
            bLeftDirection = TRUE ;
         }
         else {
            // Shift Right Arrow --> move Start Edge Right
            bStart = TRUE ;
            bLeftDirection = FALSE ;
         }
      }

      MoveLeftRight (bStart, bLeftDirection, 1) ;
   }
   else if (wParam == VK_HOME) {
      // move iStart all the way the Left
      MoveLeftRight (TRUE, TRUE, TO_THE_END) ;
   }
   else if (wParam == VK_END) {
      // move iStop all the way the right
      MoveLeftRight (FALSE, FALSE, TO_THE_END) ;
   }
   else {
      bHandle = FALSE ;
   }

   return (bHandle) ;
}


void 
CIntervalBar::StartGrab (
    void
    )
{
   RECT           rectUpdate ;

   SetCapture (m_hWnd) ;
   GrabRect (&rectUpdate) ;

   Update();
}


void 
CIntervalBar::EndGrab (
    void
    )
/*
   Internals:     Set the mode to null after getting the grab rectangle
                  so ILGrabRect knows which grab bar to get.
*/
{
   RECT           rectUpdate ;

   ReleaseCapture () ;

   GrabRect (&rectUpdate) ;
   m_iMode = ModeNone ;

   Update();
}

   
//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


CIntervalBar::CIntervalBar (
    void
    )
{

   m_hWnd = NULL;
   m_iBeginValue = 0;
   m_iEndValue = 100;
   m_iStartValue = 0;
   m_iStopValue = 100;
   m_iMode = ModeNone;
   m_hBrushBk = NULL;

}


CIntervalBar::~CIntervalBar (
    void
    )
{
    if (m_hWnd)
        DestroyWindow(m_hWnd);

    if (m_hBrushBk)
        DeleteBrush (m_hBrushBk);
}


BOOL
CIntervalBar::Init (
    HWND   hWndParent
    )
{

#define dwIntervalBarClassStyle     (CS_HREDRAW | CS_VREDRAW)
#define dwIntervalBarStyle          (WS_CHILD | WS_VISIBLE) 
#define szIntervalBarClass          TEXT("IntervalBar")

    // Register window class once
    if (pstrRegisteredClasses[INTRVBAR_WNDCLASS] == NULL) {

       WNDCLASS  wc ;

       wc.style =           dwILineClassStyle ;
       wc.lpfnWndProc =     (WNDPROC)IntervalBarWndProc ;
       wc.cbClsExtra =      0 ;
       wc.cbWndExtra =      sizeof(PCIntervalBar) ;
       wc.hInstance =       g_hInstance ;
       wc.hIcon =           NULL ;
       wc.hCursor =         LoadCursor (NULL, IDC_ARROW) ;
       wc.hbrBackground =   NULL ;
       wc.lpszMenuName =    NULL ;
       wc.lpszClassName =   szIntervalBarClass ;
    
        if (RegisterClass (&wc)) {
            pstrRegisteredClasses[INTRVBAR_WNDCLASS] = szIntervalBarClass;
        }
        else {
            return FALSE;
        }
    }

    // Create our window
    m_hWnd = CreateWindow (szIntervalBarClass,      // class
                         NULL,                     // caption
                         dwIntervalBarStyle,       // window style
                         0, 0,                     // position
                         0, 0,                     // size
                         hWndParent,               // parent window
                         NULL,                     // menu
                         g_hInstance,              // program instance
                         (LPVOID) this );          // user-supplied data

    if (m_hWnd == NULL) {
       return FALSE;
    }

   m_hBrushBk = CreateSolidBrush (GetSysColor(COLOR_SCROLLBAR)) ;
   CalcPositions () ;

   return TRUE;
}





void
CIntervalBar::OnLButtonUp (
    void
    )
{
   if (m_iMode == ModeNone)
      return ;

   EndGrab () ;
}


void
CIntervalBar::OnMouseMove (
    POINTS ptsMouse
    )
/*
   Effect:        Handle any actions needed when the mouse moves in the
                  ILine hWnd's client area or while the mouse is captured.
                  In particular, if we are tracking one of the grab bars, 
                  determine if the mouse movement represents a logical value 
                  change and move the grab bar accordingly.

   Called By:     ILineWndProc, in response to a WM_MOUSEMOVE message.

   See Also:      OnLButtonDown, OnLButtonUp.

   Note:          This function has multiple return points.

   Note:          Since we have captured the mouse, we receive mouse msgs
                  even when the mouse is outside our client area, but still
                  in client coordinates. Thus we can have negative mouse
                  coordinates. That is why we convert the lParam of the
                  mouse msg into a POINTS structure rather than 2 WORDS.
                  
                   
   Internals:     Remember that an IntervalLine can only take on integral
                  values in the user-supplied range. Therefore we do our
                  movement calculation in user values, not pixels. We
                  determine what the logical value would be for the previous
                  (last mouse move) and current mouse position. If these
                  LOGICAL values differ, we attempt an adjustment of the
                  grab bar by that logical amount.  This way the grab 
                  values assume on integral positions and the calculations
                  are simplified. 

                  If we calculated by pixel movement, and then shifted the 
                  bar into the nearest integal position, we would encounter 
                  rounding problems. In particular, when tracking the center 
                  grab bar, if we moved both start and stop by the same 
                  amount of PIXELS, then converted to LOGICAL values, we 
                  might find our center bar shrinking and growing while
                  the bar moves.
*/
{
    INT     iMousePrevious, iMouseCurrent ;
    INT     iMouseMove ;


   // Are we tracking?
   if (m_iMode == ModeNone)
      return ;


   // Calc LOGICAL mouse movement
   assert ( USHRT_MAX >= m_rectBorder.left );
   assert ( USHRT_MAX >= m_rectBorder.right );

   ptsMouse.x = PinInclusive (ptsMouse.x, 
                              (SHORT)m_rectBorder.left, 
                              (SHORT)m_rectBorder.right) ;

   iMousePrevious = PixelToValue (m_ptsMouse.x) ;
   iMouseCurrent = PixelToValue (ptsMouse.x) ;

   iMouseMove = iMouseCurrent - iMousePrevious ;
   if (!iMouseMove)   
      return ;


   // Move grab bar positions
   switch (m_iMode) {
       
      case ModeLeft:
         m_iStartValue += iMouseMove ;
         m_iStartValue = min (m_iStartValue, m_iStopValue - 1) ;
         break ;

      case ModeCenter:
         // Before we slide the center grab bar we need to see if the 
         // desired movement amount would send either end out of bounds,
         // and reduce the movement accordingly.

         if (m_iStartValue + iMouseMove < m_iBeginValue)
            iMouseMove = m_iBeginValue - m_iStartValue ;

         if (m_iStopValue + iMouseMove > m_iEndValue)
            iMouseMove = m_iEndValue - m_iStopValue ;

         m_iStartValue += iMouseMove ;
         m_iStopValue += iMouseMove ;
         break ;

      case ModeRight:
         m_iStopValue += iMouseMove ;
         m_iStopValue = max (m_iStartValue + 1, m_iStopValue) ;
         break ;
   }


   m_iStartValue = PinInclusive (m_iStartValue, m_iBeginValue, m_iEndValue) ;
   m_iStopValue = PinInclusive (m_iStopValue, m_iBeginValue, m_iEndValue) ;

   Update();

   m_ptsMouse = ptsMouse ;
   NotifyChange () ;
 }


void
CIntervalBar::OnLButtonDown (
    POINTS ptsMouse
    )
{
   POINT ptMouse ;

   m_ptsMouse = ptsMouse ;
   ptMouse.x = ptsMouse.x ;
   ptMouse.y = ptsMouse.y ;

   if (PtInRect (&m_rectLeftGrab, ptMouse) ||
       PtInRect (&m_rectLeftBk, ptMouse)) {
      m_iMode = ModeLeft ;
   }
   else if (PtInRect (&m_rectRightGrab, ptMouse) ||
            PtInRect (&m_rectRightBk, ptMouse)) {
      m_iMode = ModeRight ;
   }
   else if (PtInRect (&m_rectCenterGrab, ptMouse)) {
      m_iMode = ModeCenter ;
   }

   if (m_iMode != ModeNone)
       StartGrab();
}

void
CIntervalBar::Update (
    void
    )
{
    HDC hDC;
    // Determine pixel pos, draw
    CalcPositions () ;

    hDC = GetDC (m_hWnd) ;
    if ( NULL != hDC ) {
        Draw (hDC, &m_rectBorder) ;
        ReleaseDC (m_hWnd, hDC) ;
    }
}

//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


LRESULT APIENTRY IntervalBarWndProc (
    HWND hWnd,
    UINT uiMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*
   Note:          This function must be declared in the application's
                  linker-definition file, perfmon.def file.
*/
{
   PCIntervalBar  pIntrvBar;
   BOOL           bCallDefWindowProc ;
   POINTS         ptsMouse ;
   LRESULT        lrsltReturnValue ;

   bCallDefWindowProc = FALSE ;
   lrsltReturnValue = 0L ;

   if (uiMsg == WM_CREATE) {
       pIntrvBar = (PCIntervalBar)((CREATESTRUCT*)lParam)->lpCreateParams;
   } else {
       pIntrvBar = (PCIntervalBar)GetWindowLongPtr (hWnd, 0);
   }

   switch (uiMsg) {

      case WM_CREATE:
         SetWindowLongPtr(hWnd, 0, (INT_PTR)pIntrvBar);
         break ;

      case WM_LBUTTONDOWN:
         // See the note in OnMouseMove for why we are using POINTS
         SetFocus (hWnd) ;
         ptsMouse = MAKEPOINTS (lParam) ;
         pIntrvBar->OnLButtonDown (ptsMouse) ;
         break ;

      case WM_LBUTTONUP:
         pIntrvBar->OnLButtonUp () ;
         break ;

      case WM_SETFOCUS:
      case WM_KILLFOCUS:

         pIntrvBar->NotifyChange () ;
         return 0 ;

      case WM_ENABLE:
          pIntrvBar->Update();
          break;

      case WM_MOUSEMOVE:
         // See the note in OnMouseMove for why we are using POINTS
         ptsMouse = MAKEPOINTS (lParam) ;
         pIntrvBar->OnMouseMove (ptsMouse) ;
         break ;

      case WM_KEYDOWN:
         if (!pIntrvBar->OnKeyDown (wParam)) {
            bCallDefWindowProc = TRUE ;
         }
         break ;
  
      case WM_GETDLGCODE:
         // We want to handle Arrow keys input.  If we don't specify this
         // the dialog will not pass arrow keys to us.
         return (DLGC_WANTARROWS) ;
         break ;

      case WM_PAINT:
         {
            PAINTSTRUCT    ps ;
            HDC hDC;
            
            hDC = BeginPaint (hWnd, &ps) ;
            pIntrvBar->Draw (hDC, &ps.rcPaint) ;
            EndPaint (hWnd, &ps) ;
         }
         break ;

      case WM_SIZE:
         pIntrvBar->CalcPositions () ;
         break;

      default:
         bCallDefWindowProc = TRUE ;
      }

   if (bCallDefWindowProc)
      lrsltReturnValue = DefWindowProc (hWnd, uiMsg, wParam, lParam) ;

   return (lrsltReturnValue) ;
}


void 
CIntervalBar::SetRange (
    INT iBegin, 
    INT iEnd
    )
{ 

   m_iBeginValue = iBegin;
   m_iEndValue = iEnd;

    Update();
}


void
CIntervalBar::SetStart (
    INT iStart
    )
{
   m_iStartValue = PinInclusive (iStart, m_iBeginValue, m_iEndValue) ;

   Update();
}


void
CIntervalBar::SetStop (
    INT iStop
    )
{
   m_iStopValue = PinInclusive (iStop, m_iBeginValue, m_iEndValue) ;

   Update();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\iperpbag.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    iperpbag.cpp

Abstract:

    Implementation of the IPersistPropertyBag interface exposed on the
    Polyline object.

--*/

#include "polyline.h"
#include "unkhlpr.h"

/*
 * CImpIPersistPropertyBag interface implementation
 */

IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpIPersistPropertyBag)

/*
 * CImpIPersistPropertyBag::GetClassID
 *
 * Purpose:
 *  Returns the CLSID of the object represented by this interface.
 *
 * Parameters:
 *  pClsID          LPCLSID in which to store our CLSID.
 */

STDMETHODIMP 
CImpIPersistPropertyBag::GetClassID(LPCLSID pClsID)
{
    *pClsID=m_pObj->m_clsID;
    return NOERROR;
}

/*
 * CImpIPersistPropertyBag::InitNew
 *
 * Purpose:
 *  Informs the object that it is being created new instead of
 *  loaded from a persistent state.  This will be called in lieu
 *  of IPersistStreamInit::Load.
 *
 * Parameters:
 *  None
 */

STDMETHODIMP 
CImpIPersistPropertyBag::InitNew(void)
{
    //Nothing for us to do
    return NOERROR;
}

/*
 * CImpIPersistPropertyBag::Load
 *
 * Purpose:
 *  Instructs the object to load itself from a previously saved
 *  IPropertyBag that was handled by Save in another object lifetime.
 *  This function should not hold on to pIPropertyBag.
 *
 *  This function is called in lieu of IPersistStreamInit::InitNew
 *  when the object already has a persistent state.
 *
 * Parameters:
 *  pIPropBag   IPropertyBag* from which to load our data.
 *  pIError     IErrorLog* for storing errors.  NULL if caller not interested in errors.
 */

STDMETHODIMP CImpIPersistPropertyBag::Load (
    IPropertyBag*  pIPropBag,
    IErrorLog*     pIError )
{
    HRESULT     hr = S_OK;

    if (NULL==pIPropBag)
        return ResultFromScode(E_POINTER);

    //Read all the data into the control structure.
    hr = m_pObj->m_pCtrl->LoadFromPropertyBag ( pIPropBag, pIError );
    
    return hr;
}

/*
 * CImpIPersistPropertyBag::Save
 *
 * Purpose:
 *  Saves the data for this object to an IPropertyBag.  
 *
 * Parameters:
 *  pIPropBag       IPropertyBag* in which to save our data.
 *  fClearDirty     BOOL indicating if this call should clear
 *                  the object's dirty flag (TRUE) or leave it
 *                  unchanged (FALSE).
 *  fSaveAllProps   BOOL indicating if this call should save all properties.
 */

STDMETHODIMP 
CImpIPersistPropertyBag::Save (
    IPropertyBag*  pIPropBag,
    BOOL fClearDirty,
    BOOL fSaveAllProps )
{
    HRESULT         hr = S_OK;

    if (NULL==pIPropBag)
        return ResultFromScode(E_POINTER);

    hr = m_pObj->m_pCtrl->SaveToPropertyBag ( pIPropBag, fSaveAllProps );

    if (FAILED(hr))
        return hr;
    
    if (fClearDirty)
        m_pObj->m_fDirty=FALSE;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\iperstmi.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    iperstmi.cpp

Abstract:

    Implementation of the IPersistStreamInit interface exposed on the
    Polyline object.

--*/

#include "polyline.h"
#include "unkhlpr.h"

/*
 * CImpIPersistStreamInit interface implementation
 */

IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpIPersistStreamInit)

/*
 * CImpIPersistStreamInit::GetClassID
 *
 * Purpose:
 *  Returns the CLSID of the object represented by this interface.
 *
 * Parameters:
 *  pClsID          LPCLSID in which to store our CLSID.
 */

STDMETHODIMP CImpIPersistStreamInit::GetClassID(LPCLSID pClsID)
    {
    *pClsID=m_pObj->m_clsID;
    return NOERROR;
    }





/*
 * CImpIPersistStreamInit::IsDirty
 *
 * Purpose:
 *  Tells the caller if we have made changes to this object since
 *  it was loaded or initialized new.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         Contains S_OK if we ARE dirty, S_FALSE if
 *                  NOT dirty.
 */

STDMETHODIMP CImpIPersistStreamInit::IsDirty(void)
    {
    return ResultFromScode(m_pObj->m_fDirty ? S_OK : S_FALSE);
    }







/*
 * CImpIPersistStreamInit::Load
 *
 * Purpose:
 *  Instructs the object to load itself from a previously saved
 *  IStreamInit that was handled by Save in another object lifetime.
 *  The seek pointer in this stream will be exactly the same as
 *  it was when Save was called, and this function must leave
 *  the seek pointer the same as it was on exit from Save, regardless
 *  of success or failure.  This function should not hold on to
 *  pIStream.
 *
 *  This function is called in lieu of IPersistStreamInit::InitNew
 *  when the object already has a persistent state.
 *
 * Parameters:
 *  pIStream        LPSTREAM from which to load.
 */

STDMETHODIMP CImpIPersistStreamInit::Load(LPSTREAM pIStream)
    {
    HRESULT         hr;

    if (NULL==pIStream)
        return ResultFromScode(E_POINTER);

    //Read all the data into the control structure.
    hr = m_pObj->m_pCtrl->LoadFromStream(pIStream);

    return hr;
    }





/*
 * CImpIPersistStreamInit::Save
 *
 * Purpose:
 *  Saves the data for this object to an IStreamInit.  Be sure not
 *  to change the position of the seek pointer on entry to this
 *  function: the caller will assume that you write from the
 *  current offset.  Leave the stream's seek pointer at the end
 *  of the data written on exit.
 *
 * Parameters:
 *  pIStream        LPSTREAM in which to save our data.
 *  fClearDirty     BOOL indicating if this call should clear
 *                  the object's dirty flag (TRUE) or leave it
 *                  unchanged (FALSE).
 */

STDMETHODIMP CImpIPersistStreamInit::Save(LPSTREAM pIStream
    , BOOL fClearDirty)
    {
    HRESULT         hr;

    if (NULL==pIStream)
        return ResultFromScode(E_POINTER);

    hr = m_pObj->m_pCtrl->SaveToStream(pIStream);

    if (FAILED(hr))
        return hr;

    if (fClearDirty)
        m_pObj->m_fDirty=FALSE;

    return NOERROR;
    }




/*
 * CImpIPersistStreamInit::GetSizeMax
 *
 * Purpose:
 *  Returns the size of the data we would write if Save was
 *  called right now.
 *
 * Parameters:
 *  pcbSize         ULARGE_INTEGER * in which to save the size
 *                  of the stream an immediate call to Save would
 *                  write.
 */

STDMETHODIMP CImpIPersistStreamInit::GetSizeMax(ULARGE_INTEGER
    *pcbSize)
    {

    if (NULL==pcbSize)
        return ResultFromScode(E_POINTER);

    return ResultFromScode(E_UNEXPECTED);

    }




/*
 * CImpIPersistStreamInit::InitNew
 *
 * Purpose:
 *  Informs the object that it is being created new instead of
 *  loaded from a persistent state.  This will be called in lieu
 *  of IPersistStreamInit::Load.
 *
 * Parameters:
 *  None
 */

STDMETHODIMP CImpIPersistStreamInit::InitNew(void)
    {
    //Nothing for us to do
    return NOERROR;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\ipoly10.h ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    ipoly10.h

Abstract:

    Definition of an IPolyline interface for a Polyline object.

--*/

#ifndef _IPOLY10_H_
#define _IPOLY10_H_

#define SZSYSMONCLIPFORMAT  TEXT("SYSTEM_MONITOR_CONFIGURATION")

#ifndef OMIT_POLYLINESINK

#undef  INTERFACE
#define INTERFACE IPolylineAdviseSink10


/*
 * When someone initializes a polyline and is interested in receiving
 * notifications on events, then they provide one of these objects.
 */

DECLARE_INTERFACE_(IPolylineAdviseSink10, IUnknown)
    {
    //IUnknown members
    STDMETHOD(QueryInterface) (THIS_ REFIID, PPVOID) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    //Advise members.
    STDMETHOD_(void,OnPointChange)     (THIS) PURE;
    STDMETHOD_(void,OnSizeChange)      (THIS) PURE;
    STDMETHOD_(void,OnColorChange)     (THIS) PURE;
    STDMETHOD_(void,OnLineStyleChange) (THIS) PURE;
    //OnDataChange replaced with IAdviseSink
    };

typedef IPolylineAdviseSink10 *PPOLYLINEADVISESINK;

#endif //OMIT_POLYLINESINK


#undef  INTERFACE
#define INTERFACE IPolyline10

DECLARE_INTERFACE_(IPolyline10, IUnknown)
    {
    //IUnknown members
    STDMETHOD(QueryInterface) (THIS_ REFIID, PPVOID) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    //IPolyline members

    //File-related members use IPersistStorage, IPersistStreamInit
    //Data transfer members use IDataObject

    //Manipulation members:
    STDMETHOD(Init)   (THIS_ HWND, LPRECT, DWORD, UINT) PURE;
    STDMETHOD(New)    (THIS) PURE;
    STDMETHOD(Undo)   (THIS) PURE;
    STDMETHOD(Window) (THIS_ HWND *) PURE;

    STDMETHOD(RectGet) (THIS_ LPRECT) PURE;
    STDMETHOD(SizeGet) (THIS_ LPRECT) PURE;
    STDMETHOD(RectSet) (THIS_ LPRECT, BOOL) PURE;
    STDMETHOD(SizeSet) (THIS_ LPRECT, BOOL) PURE;

    };

typedef IPolyline10 *PPOLYLINE;


//Error values for data transfer functions
#define POLYLINE_E_INVALIDPOINTER   \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 1)
#define POLYLINE_E_READFAILURE      \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 2)
#define POLYLINE_E_WRITEFAILURE     \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 3)

#endif //_IPOLY10_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\iperstor.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    iperstor.cpp

Abstract:

    Implementation of the IPersistStorage interface exposed on the
    Polyline object.

--*/

#include "polyline.h"
#include "unkhlpr.h"
#include "unihelpr.h"
#include "utils.h"

/*
 * CImpIPersistStorage interface implementation
 */

CImpIPersistStorage::CImpIPersistStorage(PCPolyline pObj
    , LPUNKNOWN pUnkOuter)
    {
    m_cRef=0;
    m_pObj=pObj;
    m_pUnkOuter=pUnkOuter;
    m_psState=PSSTATE_UNINIT;
    return;
    }

CImpIPersistStorage::~CImpIPersistStorage(void)
    {
    return;
    }

IMPLEMENT_CONTAINED_IUNKNOWN(CImpIPersistStorage)

/*
 * CImpIPersistStorage::GetClassID
 *
 * Purpose:
 *  Returns the CLSID of the object represented by this interface.
 *
 * Parameters:
 *  pClsID          LPCLSID in which to store our CLSID.
 *
 * Return Value:
 *  HRESULT         NOERROR on success, error code otherwise.
 */

STDMETHODIMP CImpIPersistStorage::GetClassID(LPCLSID pClsID)
 {
    //----------------------------------------------------------------
    //   THE OLECONT.EXE test container call this in the UNINIT state!
    //   Go ahead and return the ClsID.
    //-----------------------------------------------------------------
    //   if (PSSTATE_UNINIT==m_psState)
    //       return ResultFromScode(E_UNEXPECTED);

    *pClsID=m_pObj->m_clsID;
    return NOERROR;
}





/*
 * CImpIPersistStorage::IsDirty
 *
 * Purpose:
 *  Tells the caller if we have made changes to this object since
 *  it was loaded or initialized new.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         Contains S_OK if we ARE dirty, S_FALSE if
 *                  NOT dirty.
 *
 */

STDMETHODIMP CImpIPersistStorage::IsDirty(void)
    {
    if (PSSTATE_UNINIT==m_psState)
        return ResultFromScode(E_UNEXPECTED);

    return ResultFromScode(m_pObj->m_fDirty ? S_OK : S_FALSE);
    }







/*
 * CImpIPersistStorage::InitNew
 *
 * Purpose:
 *  Provides the object with the IStorage to hold on to while the
 *  object is running.  Here we initialize the structure of the
 *  storage and AddRef it for incremental access. This function will
 *  only be called once in the object's lifetime in lieu of Load.
 *
 * Parameters:
 *  pIStorage       LPSTORAGE for the object.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIPersistStorage::InitNew(LPSTORAGE pIStorage)
    {
    HRESULT     hr;

    USES_CONVERSION

    if (PSSTATE_UNINIT!=m_psState)
        return ResultFromScode(E_UNEXPECTED);

    if (NULL==pIStorage)
        return ResultFromScode(E_POINTER);

    /*
     * The rules of IPersistStorage mean we hold onto the IStorage
     * and pre-create anything we'd need in Save(...,TRUE) for
     * low-memory situations.  For us this means creating our
     * "CONTENTS" stream and holding onto that IStream as
     * well as the IStorage here (requiring an AddRef call).
     */

    hr=pIStorage->CreateStream(SZSTREAM, STGM_DIRECT
        | STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE
        , 0, 0, &m_pObj->m_pIStream);

    if (FAILED(hr))
        return hr;

    //We expect that the client has called WriteClassStg    
    WriteFmtUserTypeStg(pIStorage, m_pObj->m_cf, T2W(ResourceString(IDS_USERTYPE)));

    m_pObj->m_pIStorage=pIStorage;
    pIStorage->AddRef();

    m_psState=PSSTATE_SCRIBBLE;

    //Initialize the cache as needed.
    m_pObj->m_pDefIPersistStorage->InitNew(pIStorage);
    return NOERROR;
    }

/*
 * CImpIPersistStorage::Load
 *
 * Purpose:
 *  Instructs the object to load itself from a previously saved
 *  IStorage that was handled by Save in another object lifetime.
 *  This function will only be called once in the object's lifetime
 *  in lieu of InitNew. The object should hold on to pIStorage here
 *  for incremental access and low-memory saves in Save.
 *
 * Parameters:
 *  pIStorage       LPSTORAGE from which to load.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIPersistStorage::Load(LPSTORAGE pIStorage)
{
    LPSTREAM        pIStream;
    HRESULT         hr;

    if (PSSTATE_UNINIT!=m_psState)
        return ResultFromScode(E_UNEXPECTED);

    if (NULL==pIStorage)
        return ResultFromScode(E_POINTER);

    //We don't check CLSID to remain compatible with other chapters.

    hr=pIStorage->OpenStream(SZSTREAM, 0, STGM_DIRECT
        | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &pIStream);

    if (FAILED(hr))
        return ResultFromScode(STG_E_READFAULT);

    // Load graph data from stream
    hr = m_pObj->m_pCtrl->LoadFromStream(pIStream);

    if (FAILED(hr))
        {
        pIStream->Release();
        return hr;
        }

    /*
     * We don't call pIStream->Release here because we may need
     * it for a low-memory save in Save.  We also need to
     * hold onto a copy of pIStorage, meaning AddRef.
     */
    m_pObj->m_pIStream = pIStream;

    m_pObj->m_pIStorage = pIStorage;
    pIStorage->AddRef();

    m_psState=PSSTATE_SCRIBBLE;

    //We also need to tell the cache to load cached graphics
    m_pObj->m_pDefIPersistStorage->Load(pIStorage);
    return NOERROR;
    }





/*
 * CImpIPersistStorage::Save
 *
 * Purpose:
 *  Saves the data for this object to an IStorage which may
 *  or may not be the same as the one previously passed to
 *  Load, indicated with fSameAsLoad.  After this call we may
 *  not write into the storage again until SaveCompleted is
 *  called, although we may still read.
 *
 * Parameters:
 *  pIStorage       LPSTORAGE in which to save our data.
 *  fSameAsLoad     BOOL indicating if this is the same pIStorage
 *                  that was passed to Load.  If TRUE, then the
 *                  object should write whatever it has *without
 *                  *using any extra memory* as this may be a low
 *                  memory save attempt.  That means that you must
 *                  not try to open or create streams.  If FALSE
 *                  you need to regenerate your whole storage
 *                  structure, being sure to also release any
 *                  pointers held from InitNew and Load.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIPersistStorage::Save(LPSTORAGE pIStorage
    , BOOL fSameAsLoad)
 {
    LPSTREAM        pIStream;
    HRESULT         hr;

    USES_CONVERSION

    // Permit call in UNINIT state, if not SameAsLoad
    if (PSSTATE_UNINIT == m_psState && fSameAsLoad)
        return ResultFromScode(E_POINTER);

    //Must have an IStorage if we're not in SameAsLoad
    if (NULL==pIStorage && !fSameAsLoad)
        return ResultFromScode(E_POINTER);

    /*
     * If we're saving to a new storage, create a new stream.
     * If fSameAsLoad it TRUE, then we write to the
     * stream we already allocated.  We should NOT depends on
     * pIStorage with fSameAsLoad is TRUE.
     */
    if (fSameAsLoad)
        {
        LARGE_INTEGER   li;

        /*
         * Use pre-allocated streams to avoid failures due
         * to low-memory conditions.  Be sure to reset the
         * stream pointer if you used this stream before!!
         */
        pIStream=m_pObj->m_pIStream;
        LISet32(li, 0);
        pIStream->Seek(li, STREAM_SEEK_SET, NULL);

        //This matches the Release below.
        pIStream->AddRef();
        }
    else
        {
        hr=pIStorage->CreateStream(SZSTREAM, STGM_DIRECT
            | STGM_CREATE | STGM_WRITE | STGM_SHARE_EXCLUSIVE
            , 0, 0, &pIStream);

        if (FAILED(hr))
            return hr;

        //Only do this with new storages.
        WriteFmtUserTypeStg(pIStorage, m_pObj->m_cf, T2W(ResourceString(IDS_USERTYPE)));
        }

    // Write graph info to stream
    hr = m_pObj->m_pCtrl->SaveToStream(pIStream);
    pIStream->Release();

    if (FAILED(hr))
        return hr;

    m_psState=PSSTATE_ZOMBIE;

    // Clear the dirty flag if storage is the same.
    if (fSameAsLoad)
        m_pObj->m_fDirty = FALSE;

    //We also need to tell the cache to save cached graphics
    m_pObj->m_pDefIPersistStorage->Save(pIStorage, fSameAsLoad);
    return NOERROR;
    }








/*
 * CImpIPersistStorage::SaveCompleted
 *
 * Purpose:
 *  Notifies the object that the storage in pIStorage has been
 *  completely saved now.  This is called when the user of this
 *  object wants to save us in a completely new storage, and if
 *  we normally hang on to the storage we have to reinitialize
 *  ourselves here for this new one that is now complete.
 *
 * Parameters:
 *  pIStorage       LPSTORAGE of the new storage in which we live.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIPersistStorage::SaveCompleted(LPSTORAGE pIStorage)
    {
    HRESULT     hr;
    LPSTREAM    pIStream;

    //Must be called in no-scribble or hands-off state
    if (!(PSSTATE_ZOMBIE==m_psState || PSSTATE_HANDSOFF==m_psState))
        return ResultFromScode(E_UNEXPECTED);

    //If we're coming from Hands-Off, we'd better get a storage
    if (NULL==pIStorage && PSSTATE_HANDSOFF==m_psState)
        return ResultFromScode(E_UNEXPECTED);

    /*
     * If pIStorage is NULL, then we don't need to do anything
     * since we already have all the pointers we need for Save.
     * Otherwise we have to release any held pointers and
     * reinitialize them from pIStorage.
     */

    if (NULL!=pIStorage)
        {
        hr=pIStorage->OpenStream(SZSTREAM, 0, STGM_DIRECT
            | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0
            , &pIStream);

        if (FAILED(hr))
            return hr;

        if (NULL!=m_pObj->m_pIStream)
            m_pObj->m_pIStream->Release();

        m_pObj->m_pIStream=pIStream;

        if (NULL!=m_pObj->m_pIStorage)
            m_pObj->m_pIStorage->Release();

        m_pObj->m_pIStorage=pIStorage;
        m_pObj->m_pIStorage->AddRef();
        }

    //Change state back to scribble.
    m_psState=PSSTATE_SCRIBBLE;

    m_pObj->m_pDefIPersistStorage->SaveCompleted(pIStorage);
    return NOERROR;
    }





/*
 * CImpIPersistStorage::HandsOffStorage
 *
 * Purpose:
 *  Instructs the object that another agent is interested in having
 *  total access to the storage we might be hanging on to from
 *  InitNew or SaveCompleted.  In this case we must release our hold
 *  and await another call to SaveCompleted before we have a hold
 *  again.  Therefore we cannot read or write after this call until
 *  SaveCompleted.
 *
 *  Situations where this might happen arise in compound document
 *  scenarios where this object might be in-place active but the
 *  application wants to rename and commit the root storage.
 *  Therefore we are asked to close our hold, let the container
 *  party on the storage, then call us again later to tell us the
 *  new storage we can hold.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIPersistStorage::HandsOffStorage(void)
    {
    /*
     * Must come from scribble or no-scribble.  A repeated call
     * to HandsOffStorage is an unexpected error (bug in client).
     */
    if (PSSTATE_UNINIT==m_psState || PSSTATE_HANDSOFF==m_psState)
        return ResultFromScode(E_UNEXPECTED);


    //Release held pointers
    if (NULL!=m_pObj->m_pIStream)
        {
        m_pObj->m_pIStream->Release();
        m_pObj->m_pIStream=NULL;
        }

    if (NULL!=m_pObj->m_pIStorage)
        {
        m_pObj->m_pIStorage->Release();
        m_pObj->m_pIStorage=NULL;
        }

    m_psState=PSSTATE_HANDSOFF;

    m_pObj->m_pDefIPersistStorage->HandsOffStorage();
    return NOERROR;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\ipolylin.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    ipolylin.cpp

Abstract:

    Implementation of the IPolyline10 interface exposed on the
    CPolyline object.

--*/

#include "polyline.h"
#include "unkhlpr.h"

/*
 * CImpIPolyline interface implementation
 */

IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpIPolyline)


/*
 * CImpIPolyline::Init
 *
 * Purpose:
 *  Instantiates a polyline window within a given parent.  The
 *  parent may be a main application window, could be an MDI child
 *  window. We really do not care.
 *
 * Parameters:
 *  hWndParent      HWND of the parent of this window
 *  pRect           LPRECT that this window should occupy
 *  dwStyle         DWORD containing the window's style flags
 *  uID             UINT ID to associate with this window
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, otherwise E_OUTOFMEMORY
 */

STDMETHODIMP CImpIPolyline::Init(HWND hWndParent, LPRECT /* pRect */
    , DWORD /* dwStyle */, UINT /* uID */)
    {
    SCODE           sc;
    BOOL            stat;

    stat = m_pObj->m_pCtrl->Init(hWndParent);

    sc = (stat == TRUE) ? S_OK : E_OUTOFMEMORY;
    return ResultFromScode(sc);
    }


/*
 * CImpIPolyline::New
 *
 * Purpose:
 *  Cleans out and reinitializes the data to defaults.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR always
 */

STDMETHODIMP CImpIPolyline::New(void)
    {
    RECT            rc;
    HWND            hWnd;

    hWnd = m_pObj->m_pCtrl->Window();

    //Our rectangle is the size of our window's client area.
    if (hWnd)
        {
        GetClientRect(hWnd, &rc);
        //RECTTORECTS(rc, ppl->rc);
        }
    else
        {
        SetRect(&rc, 0, 0, 300, 200);       //Something reasonable
        //RECTTORECTS(rc, ppl->rc);
        }

    //This is now conditional since we may not yet have a window.
    if (hWnd)
        {
        InvalidateRect(hWnd, NULL, TRUE);
        UpdateWindow(hWnd);
        m_pObj->m_fDirty=TRUE;
        }

    m_pObj->SendAdvise(OBJECTCODE_DATACHANGED);
    return NOERROR;
    }


/*
 * CImpIPolyline::Undo
 *
 * Purpose:
 *  Reverses previous actions in a Polyline.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         S_OK if we can Undo more, S_FALSE otherwise.
 */

STDMETHODIMP CImpIPolyline::Undo(void)
    {
    return ResultFromScode(S_FALSE);
    }


/*
 * CImpIPolyline::Window
 *
 * Purpose:
 *  Returns the window handle associated with this polyline.
 *
 * Parameters:
 *  phWnd           HWND * in which to return the window handle.
 *
 * Return Value:
 *  HRESULT         NOERROR always.
 */

STDMETHODIMP CImpIPolyline::Window(HWND *phWnd)
    {
    *phWnd = m_pObj->m_pCtrl->Window();
    return NOERROR;
    }


/*
 * CImpIPolyline::RectGet
 *
 * Purpose:
 *  Returns the rectangle of the Polyline in parent coordinates.
 *
 * Parameters:
 *  pRect           LPRECT in which to return the rectangle.
 *
 * Return Value:
 *  HRESULT         NOERROR always
 */

STDMETHODIMP CImpIPolyline::RectGet(LPRECT pRect)
    {
 //   RECT            rc;
 //   POINT           pt;

    // I know this seems wrong, but it works. 
    // Always return the last extent that the container gave us.
    // Then it will set our window to the correct size.

    *pRect = m_pObj->m_RectExt; // Return extent rect
    return NOERROR;

/***********
    if (NULL==m_pObj->m_hWnd)
        {
        }

    //Retrieve the size of our rectangle in parent coordinates.
    GetWindowRect(m_pObj->m_hWnd, &rc);
    pt.x=rc.left;
    pt.y=rc.top;
    ScreenToClient(GetParent(m_pObj->m_hWnd), &pt);

    SetRect(pRect, pt.x, pt.y, pt.x+(rc.right-rc.left)
        , pt.y+(rc.bottom-rc.top));

    return NOERROR;
**********/

    }


/*
 * CImpIPolyline::SizeGet
 *
 * Purpose:
 *  Retrieves the size of the Polyline in parent coordinates.
 *
 * Parameters:
 *  pRect           LPRECT in which to return the size.  The right
 *                  and bottom fields will contain the dimensions.
 *
 * Return Value:
 *  HRESULT         NOERROR always
 */

STDMETHODIMP CImpIPolyline::SizeGet(LPRECT pRect)
    {
    RectGet(pRect);
    return NOERROR;
    }


/*
 * CImpIPolyline::RectSet
 *
 * Purpose:
 *  Sets a new rectangle for the Polyline which sizes to fit.
 *
 * Parameters:
 *  pRect           LPRECT containing the new rectangle.
 *  fNotify         BOOL indicating if we're to notify anyone of
 *                  the change.
 *
 * Return Value:
 *  HRESULT         NOERROR always
 */

STDMETHODIMP CImpIPolyline::RectSet(LPRECT pRect, BOOL fNotify)
    {
    UINT            cx, cy;
    RECT            rc;
    HWND            hWnd;

    //Scale the points from our current size to the new size
    cx = pRect->right - pRect->left;
    cy = pRect->bottom - pRect->top;

    SetRect(&rc, 0, 0, cx, cy);

    hWnd = m_pObj->m_pCtrl->Window();
    if ( NULL != hWnd ) {

        SetWindowPos(hWnd, NULL, pRect->left, pRect->top, cx, cy, SWP_NOZORDER);
        InvalidateRect(hWnd, NULL, TRUE);
    }

    if (fNotify)
        m_pObj->m_fDirty = TRUE;

    return NOERROR;
    }



/*
 * CImpIPolyline::SizeSet
 *
 * Purpose:
 *  Sets a new size for the Polyline which sizes to fit.
 *
 * Parameters:
 *  pRect           LPRECT containing the new rectangle.
 *  fNotify         BOOL indicating if we're to notify anyone of
 *                  the change.
 *
 * Return Value:
 *  HRESULT         NOERROR always
 */

STDMETHODIMP CImpIPolyline::SizeSet(LPRECT pRect, BOOL fNotify)
    {
    UINT            cx, cy;
    HWND            hWnd;

    //Scale the points from our current size to the new size
    cx=pRect->right-pRect->left;
    cy=pRect->bottom-pRect->top;

    hWnd = m_pObj->m_pCtrl->Window();

    if ( NULL != hWnd ) {

        SetWindowPos(hWnd, NULL, 0, 0, (UINT)cx, (UINT)cy, SWP_NOMOVE | SWP_NOZORDER);
        InvalidateRect(hWnd, NULL, TRUE);
    }

    if (fNotify)
        m_pObj->m_fDirty=TRUE;

    return NOERROR;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\ipropbag.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    ipropbag.h

Abstract:

    <abstract>

--*/

#ifndef _IPROPBAG_H_
#define _IPROPBAG_H_

#include "inole.h"
        
// Property Bag Class
class CImpIPropertyBag : public IPropertyBag {

    public:
                CImpIPropertyBag( LPUNKNOWN = NULL );
        virtual ~CImpIPropertyBag(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IConnectionPoint members
        STDMETHODIMP Read(LPCOLESTR, VARIANT*, IErrorLog* );
        STDMETHODIMP Write(LPCOLESTR, VARIANT* );

        //Members not exposed by IPropertyBag
        LPTSTR  GetData ( void );
        HRESULT LoadData ( LPTSTR pszData );

    private:

        typedef struct _param_data {
            _param_data*    pNextParam; 
            TCHAR           pszPropertyName[MAX_PATH];
            VARIANT         vValue;
        } PARAM_DATA, *PPARAM_DATA;

        enum eConstants {
            eDefaultBufferLength = 0x010000      // 64K
        };

        PPARAM_DATA FindProperty ( LPCTSTR pszPropName );
        void        DataListAddHead ( PPARAM_DATA );
        PPARAM_DATA DataListRemoveHead ( void );

        ULONG           m_cRef;        //Object reference count
        LPUNKNOWN       m_pUnkOuter;   //Controlling unknown
//        PCPolyline      m_pObj;        //Containing object - assume NULL for this object
        LPTSTR          m_pszData;
        DWORD           m_dwCurrentDataLength;
        PPARAM_DATA     m_plistData;
};

typedef CImpIPropertyBag *PCImpIPropertyBag;

#endif // _IPROPBAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\iprpbrws.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    iprpbrws.cpp

Abstract:

    Implementation of the IPerPropertyBrowsingg interface exposed on the
	Polyline object.

--*/

#include "polyline.h"
#include "unkhlpr.h"
#include "smonid.h"
#include "ctrprop.h"
#include "srcprop.h"
#include "genprop.h"

/*
 * CImpIPerPropertyBrowsing interface implementation
 */

IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpIPerPropertyBrowsing)

/*
 * CImpIPerPropertyBrowsing::GetClassID
 *
 * Purpose:
 *  Returns the CLSID of the object represented by this interface.
 *
 * Parameters:
 *  pClsID          LPCLSID in which to store our CLSID.
 */

STDMETHODIMP 
CImpIPerPropertyBrowsing::GetClassID(LPCLSID pClsID)
{
    *pClsID=m_pObj->m_clsID;
    return NOERROR;
}

/*
 * CImpIPerPropertyBrowsing::GetDisplayString
 *
 * Purpose:
 *  Returns a text string describing the property identified with DispID.
 *
 * Parameters:
 *  dispID      Dispatch identifier for the property.
 *  pBstr       Receives a pointer to the display string describing the property
*/

STDMETHODIMP CImpIPerPropertyBrowsing::GetDisplayString (
    DISPID  /* dispID */,
    BSTR*   /* pBstr */ )
{
/*
    HRESULT     hr = S_OK;
    
    VARIANT     vValue;

    if (NULL==pIPropBag)
        return ResultFromScode(E_POINTER);

    //Read all the data into the control structure.
	hr = m_pObj->m_pCtrl->LoadFromPropertyBag ( pIPropBag, pIError );
    return hr;
*/
    return E_NOTIMPL;
}

/*
 * CImpIPerPropertyBrowsing::GetPredefinedStrings
 *
 * Purpose:
 *  Returns a counted array of strings, each corresponding to a value that the
 *  property specified by dispID can accept.
 *
 * Parameters:
 *  dispID          Dispatch identifier for the property.
 *  pcaStringsOut   Receives a pointer to an array of strings
 *  pcaCookiesOut   Receives a pointer to an array of DWORDs
 */

STDMETHODIMP CImpIPerPropertyBrowsing::GetPredefinedStrings (
    DISPID  /* dispID */,
    CALPOLESTR* /* pcaStringsOut */,
    CADWORD*    /* pcaCookiesOut */ )
{
    return E_NOTIMPL;
}

/*
 * CImpIPerPropertyBrowsing::GetPredefinedValue
 *
 * Purpose:
 *  Returns a variant containing the value of the property specified by dispID.
 *
 * Parameters:
 *  dispID      Dispatch identifier for the property.
 *  dwCookie    Token returned by GetPredefinedStrings
 *  pVarOut     Receives a pointer to a VARIANT value for the property.
 */

STDMETHODIMP CImpIPerPropertyBrowsing::GetPredefinedValue (
    DISPID  /* dispID */,
    DWORD   /* dwCookie */,
    VARIANT*    /* pVarOut */ )
{
    return E_NOTIMPL;
}

/*
 * CImpIPerPropertyBrowsing::MapPropertyToPage
 *
 * Purpose:
 *  Returns the CLSID of the property page associated with 
 *  the property specified by dispID.
 *
 * Parameters:
 *  dispID  Dispatch identifier for the property.
 *  pClsid  Receives a pointer to the CLSID of the property page.
 */

STDMETHODIMP CImpIPerPropertyBrowsing::MapPropertyToPage (
    DISPID  dispID,
    LPCLSID pClsid  )
{
    HRESULT hr = E_POINTER;

    if ( NULL != pClsid ) {
        hr = S_OK;
    
        if ( DISPID_VALUE == dispID ) {
            // Data page
            *pClsid = CLSID_CounterPropPage;
        } else if ( DISPID_SYSMON_DATASOURCETYPE == dispID ) {
            // Source page
            *pClsid = CLSID_SourcePropPage;
        } else {
            // General page is default
            *pClsid = CLSID_GeneralPropPage;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\ipropbag.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    IPropBag.cpp

Abstract:

    Implementation of the private IPropertyBag interface used by
    the System Monitor control.

--*/

#include <assert.h>
#include "polyline.h"
#include "unkhlpr.h"
#include "unihelpr.h"
#include "utils.h"
#include "strids.h"
#include "globals.h"
#include "smonmsg.h"
#include "ipropbag.h"

#define MAX_GUID_STRING_LENGTH 39

/*
 * CImpIPropertyBag interface implementation
 */

IMPLEMENT_CONTAINED_IUNKNOWN(CImpIPropertyBag)

/*
 * CImpIPropertyBag::CImpIPropertyBag
 *
 * Purpose:
 *  Constructor.
 *
 * Return Value:
 */

CImpIPropertyBag::CImpIPropertyBag ( LPUNKNOWN pUnkOuter)
:   m_cRef ( 0 ),
    m_pUnkOuter ( pUnkOuter ),
    m_pszData ( NULL ),
    m_dwCurrentDataLength ( 0 ),
    m_plistData ( NULL )
{
    return; 
}

/*
 * CImpIPropertyBag::~CImpIPropertyBag
 *
 * Purpose:
 *  Destructor.
 *
 * Return Value:
 */

CImpIPropertyBag::~CImpIPropertyBag ( void ) 
{   
    if ( NULL != m_pszData ) {
        delete m_pszData;
    }

    while ( NULL != m_plistData ) {
        PPARAM_DATA pData = DataListRemoveHead();
        VariantClear ( &pData->vValue ); 
        delete pData;
    }

    return; 
}


/*
 * CImpIPropertyBag::Read
 *
 * Purpose:
 *
 *  This function is called to read a property from the property bag.
 *
 * Parameters:
 *  pszPropName     Pointer to name of property to be read
 *  pVar            Pointer to the VARIANT to receive the property value
 *  pIErrorLog      Pointer to the caller's error log
 */

STDMETHODIMP 
CImpIPropertyBag::Read (
    LPCOLESTR pszPropName,  //Pointer to the property to be read
    VARIANT* pVar,          //Pointer to the VARIANT to receive the 
                            //property value
    IErrorLog* pIErrorLog ) //Pointer to the caller's error log    // can be null
{
    HRESULT     hr = S_OK;
    PPARAM_DATA pData;

    if (NULL==pszPropName)
        return ResultFromScode(E_POINTER);

    if (NULL==pVar)
        return ResultFromScode(E_POINTER);

    // Currently don't handle error log.
    assert ( NULL == pIErrorLog );
    pIErrorLog;                         // Eliminate compiler warning.

    //Read the specified data into the passed variant.
    pData = FindProperty ( pszPropName );

    if ( NULL != pData ) {
        //VARTYPE vtTarget = vValue.vt;
        if( pVar->vt != VT_BSTR ){
            hr = VariantChangeTypeEx( pVar, &pData->vValue, LCID_SCRIPT, VARIANT_NOUSEROVERRIDE, pVar->vt );
        }else{
            hr = VariantChangeType ( pVar, &pData->vValue, NULL, pVar->vt );    
        }
    } else {
        hr = E_INVALIDARG;
    }

    return hr;
}

/*
 * CImpIPropertyBag::Write
 *
 * Purpose:
 *
 *  This function is called to write a property to the property bag.
 *
 * Parameters:
 *  pszPropName     Pointer to name of property to be written
 *  pVar            Pointer to the VARIANT containing the property value
 */

STDMETHODIMP 
CImpIPropertyBag::Write (
    LPCOLESTR pszPropName,  //Pointer to the property to be written
    VARIANT* pVar )         //Pointer to the VARIANT containing the  
                            //property value and type
{
    HRESULT     hr = S_OK;
    VARIANT     vValueBstr;
    DWORD       dwNameLength;
    DWORD       dwDataLength;
    static DWORD dwDelimiterLength = 0;
    static DWORD dwParamNameLength = 0;
    static DWORD dwEolTagLength = 0;
    static DWORD dwValueTagLength = 0;
    static TCHAR szParamTag[128];
    static TCHAR szValueTag[128];
    static TCHAR szEolTag[128];
    HRESULT     hrConvert;
    LPTSTR      pszNextField = m_pszData;
    DWORD       dwCurrentDataUsedLength;

    if (NULL==pszPropName)
        return ResultFromScode(E_POINTER);

    if (NULL==pVar)
        return ResultFromScode(E_POINTER);

    VariantInit ( &vValueBstr );

    if( pVar->vt != VT_BSTR ){
        hrConvert = VariantChangeTypeEx( &vValueBstr, pVar, LCID_SCRIPT, VARIANT_NOUSEROVERRIDE, VT_BSTR );
    }else{
        hrConvert = VariantChangeType ( &vValueBstr, pVar, NULL, VT_BSTR );
    }
    // All length values calculated number of TCHARs.

    if ( 0 == dwDelimiterLength ) {
        // Initialize static values

        if (LoadString(g_hInstance, IDS_HTML_PARAM_TAG, szParamTag, 128)) {
            if (LoadString(g_hInstance, IDS_HTML_VALUE_TAG, szValueTag, 128)) {
                if (LoadString(g_hInstance, IDS_HTML_VALUE_EOL_TAG, szEolTag, 128)) {                           
                    dwParamNameLength = lstrlen (szParamTag);
                    dwValueTagLength = lstrlen ( szValueTag );
                    dwEolTagLength = lstrlen ( szEolTag );
        
                    dwDelimiterLength = dwParamNameLength + dwValueTagLength + dwEolTagLength;  
                } else {
                    hr = E_OUTOFMEMORY;
                }
            } else {
                hr = E_OUTOFMEMORY;
            }
        } else {
            hr = E_OUTOFMEMORY;
        }
    }

    if ( SUCCEEDED ( hr ) ) {
        dwNameLength = lstrlen ( pszPropName );
        dwDataLength = lstrlen ( W2T ( vValueBstr.bstrVal ) );
        dwCurrentDataUsedLength = lstrlen ( m_pszData );

        // Add 1 to size calculation for NULL buffer terminator.
        if ( m_dwCurrentDataLength 
            < dwCurrentDataUsedLength + dwNameLength + dwDataLength + dwDelimiterLength + 1 ) { 

            LPTSTR pszNewBuffer;
        
            if ( 0 == m_dwCurrentDataLength ) {
                m_dwCurrentDataLength += eDefaultBufferLength;
            } else {
                m_dwCurrentDataLength *= 2;
            }
            pszNewBuffer = new TCHAR[m_dwCurrentDataLength];

            if ( NULL == pszNewBuffer )
                return E_OUTOFMEMORY;

            if ( NULL != m_pszData ) {
                memcpy ( pszNewBuffer, m_pszData, dwCurrentDataUsedLength * sizeof(TCHAR) );
                delete m_pszData;
            }
            m_pszData = pszNewBuffer;
        }

        // Build the new string and add it to the current data.

        pszNextField = m_pszData + dwCurrentDataUsedLength;
        memcpy ( pszNextField, szParamTag, dwParamNameLength * sizeof(TCHAR) );

        pszNextField += dwParamNameLength;
        memcpy ( pszNextField, pszPropName, dwNameLength * sizeof(TCHAR) );

        pszNextField += dwNameLength;
        memcpy ( pszNextField, szValueTag, dwValueTagLength * sizeof(TCHAR) );

        pszNextField += dwValueTagLength;
        memcpy ( pszNextField, W2T(vValueBstr.bstrVal), dwDataLength * sizeof(TCHAR) );

        pszNextField += dwDataLength;
        memcpy ( pszNextField, szEolTag, dwEolTagLength * sizeof(TCHAR) );

        pszNextField += dwEolTagLength;
        lstrcpy ( pszNextField, _T("") );
    }
    return hr;
}

/*
 * CImpIPropertyBag::GetData
 *
 * Purpose:
 *  Return pointer to the data buffer.
 *
 * Return Value:
 *  Pointer to the data buffer.
 */

LPTSTR
CImpIPropertyBag::GetData ( void ) 
{   
    return m_pszData;
}

/*
 * CImpIPropertyBag::LoadData
 *
 * Purpose:
 *  Load data from the supplied buffer into internal data structures.
 *
 * Return Value:
 *  Status.
 */

HRESULT
CImpIPropertyBag::LoadData ( LPTSTR pszData ) 
{   
    HRESULT hr = S_OK;
    LPWSTR  pszDataAllocW = NULL;
    LPWSTR  pszCurrentPos = NULL;
    LPWSTR  pszParamTag;
    LPWSTR  pszValueTag;
    LPWSTR  pszEooTag;
    LPSTR   pszGuidA = NULL;
    LPSTR   pszCurrentPosA = NULL;
    LPSTR   pszDataA = NULL;
    OLECHAR szGuidW[MAX_GUID_STRING_LENGTH];
    LPWSTR  pszGuidW = NULL;
    INT     iStatus;
    INT     iBufLen;

    USES_CONVERSION;
    
    if ( NULL == pszData ) {
        assert ( FALSE );
        hr = E_POINTER;
    } else {

        assert ( sizeof(TCHAR) == sizeof(WCHAR) );

        pszParamTag = ResourceString ( IDS_HTML_PARAM_SEARCH_TAG );
        pszValueTag = ResourceString ( IDS_HTML_VALUE_SEARCH_TAG );
        pszEooTag = ResourceString ( IDS_HTML_OBJECT_FOOTER );
        
        if ( NULL == pszParamTag
                || NULL == pszValueTag
                || NULL == pszEooTag ) {
            hr = E_UNEXPECTED;
        } else {

            // Unicode search:  Begin the search after the first instance 
            // of the System Monitor class id.
            iStatus = StringFromGUID2(CLSID_SystemMonitor, szGuidW, sizeof(szGuidW)/sizeof(OLECHAR));
        
            if ( 0 < iStatus ) {
                pszGuidW = wcstok ( szGuidW, L"{} " );

                if ( NULL != pszGuidW ) {
                    pszCurrentPos = wcsstr(pszData, pszGuidW );

                    // Handle wide vs ansi.
                    if ( NULL == pszCurrentPos ) {
                        // Check for ANSI version:             
                        pszDataA = (CHAR*) pszData;
                        pszGuidA = W2A( pszGuidW );

                        if ( NULL != pszGuidA ) {
                            pszCurrentPosA = strstr ( pszDataA, pszGuidA );

                            if ( NULL != pszCurrentPosA ) {

                                iBufLen = lstrlenA (pszDataA) + 1;

                                pszDataAllocW = new WCHAR [iBufLen * sizeof(WCHAR)];
                                if ( NULL != pszDataAllocW ) {
                                    _MbToWide ( pszDataAllocW, pszDataA, iBufLen ); 
                                    pszCurrentPos = wcsstr(pszDataAllocW, pszGuidW );
                                } else {
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                        }
                    }
                }
            } else {
                hr = E_UNEXPECTED;
            }
        }

        if ( NULL != pszCurrentPos ) {
            WCHAR   szQuote[2];
            LPWSTR  pszEoo;

            wcscpy ( szQuote, _T("\"") );
            
            // End of object is the first object footer tag after the first sysmon
            // class id found. If multiple objects in the data block, only parse the first sysmon.
            pszEoo = wcsstr(pszCurrentPos, pszEooTag );

            if ( NULL != pszEoo ) {

                // Find first parameter tag.
                pszCurrentPos = wcsstr(pszCurrentPos, pszParamTag );

                while ( NULL != pszCurrentPos && pszCurrentPos < pszEoo ) {
    
                    LPWSTR      pszNextPos;
                    INT         lStrLength;
                    PPARAM_DATA pParamData;
                    LPWSTR      pszTemp;

                    // Store parameter/property name.
                    // Find one past first quote.
                    pszCurrentPos = wcsstr(pszCurrentPos, szQuote ) + 1;

                    // The param name is between first and second quote.
                    pszNextPos = wcsstr(pszCurrentPos, szQuote );

                    lStrLength = ( (INT)((UINT_PTR)pszNextPos - (UINT_PTR)pszCurrentPos) ) / sizeof ( WCHAR ) ;

                    pParamData = new PARAM_DATA;

                    if ( NULL != pParamData ) {
                        pParamData->pNextParam = NULL;
                        VariantInit ( &pParamData->vValue );
                        pParamData->vValue.vt = VT_BSTR;
                    } else {
                        hr = E_OUTOFMEMORY;
                        break;
                    }

                    wcsncpy ( pParamData->pszPropertyName, pszCurrentPos, lStrLength );
                    pParamData->pszPropertyName[lStrLength] = TEXT ('\0');

                    // Find value tag and store parameter/property value.
                    // Find value tag and store parameter/property value.
                    // Find value tag
                    pszCurrentPos = wcsstr ( pszCurrentPos, pszValueTag );
                    // Find one past first quote
                    pszCurrentPos = wcsstr ( pszCurrentPos, szQuote ) + 1;
                    // The value is between first and second quote.
                    pszNextPos = wcsstr ( pszCurrentPos, szQuote );
            
                    lStrLength = ( (INT)((UINT_PTR)pszNextPos - (UINT_PTR)pszCurrentPos) ) / sizeof ( WCHAR );

                    pszTemp = new TCHAR[lStrLength+1];
                    if (pszTemp != NULL) {
                        wcsncpy ( pszTemp, pszCurrentPos, lStrLength );
                        pszTemp[lStrLength] = TEXT('\0');

                        pParamData->vValue.bstrVal = 
                                    SysAllocString ( pszTemp );

                        delete pszTemp;
                        DataListAddHead ( pParamData );
                        // Find next parameter/property tag.
                        pszCurrentPos = wcsstr(pszCurrentPos, pszParamTag );
                    } else {
                        delete pParamData;
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                } // While parameter tags exist for a single object.
            } else {
                hr = SMON_STATUS_NO_SYSMON_OBJECT;
            }
        } else {
            hr = SMON_STATUS_NO_SYSMON_OBJECT;
        }
    }

    if ( NULL != pszDataAllocW ) {
        delete pszDataAllocW;
    }

    return hr;
}

void
CImpIPropertyBag::DataListAddHead ( PPARAM_DATA pData ) 
{
    pData->pNextParam = m_plistData;
    m_plistData = pData;
    return;
}

CImpIPropertyBag::PPARAM_DATA
CImpIPropertyBag::DataListRemoveHead ( ) 
{
    PPARAM_DATA pReturnData;

    pReturnData = m_plistData;
    
    if ( NULL != m_plistData )
        m_plistData = m_plistData->pNextParam;
    
    return pReturnData;
}


CImpIPropertyBag::PPARAM_DATA
CImpIPropertyBag::FindProperty ( LPCTSTR pszPropName ) 
{
    PPARAM_DATA pReturnData;

    pReturnData = m_plistData;
    
    while ( NULL != pReturnData ) {
        if ( 0 == lstrcmpi ( pszPropName, pReturnData->pszPropertyName ) )
            break;
        pReturnData = pReturnData->pNextParam;
    }

    return pReturnData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\legend.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    legend.h

Abstract:

    Header file for the legend control.

--*/

#ifndef _LEGEND_H_
#define _LEGEND_H_

#include <commctrl.h>
#include "toolbar.h"    // include here to define _WIN32_IE

#define iLabelLen       30
#define iLegendNumCols  7   

#define LEGEND_DATA_VERSION     2

class CSysmonControl;

 
typedef struct LEGENDCOLSTRUCT {
    INT32   xWidth ;
    INT32   xPos ;
    INT32   iOrientation ;
} LEGENDCOL ;

typedef LEGENDCOL *PLEGENDCOL ;

typedef struct {
    INT32   xColWidth[iLegendNumCols]; 
    INT32   iSortCol;
    INT32   iSortDir;
} LEGEND_DATA;


class CLegend
{
friend LRESULT APIENTRY GraphLegendWndProc (HWND hWnd,
                                     UINT uiMsg,
                                     WPARAM wParam,
                                     LPARAM lParam);
friend LRESULT APIENTRY HdrWndProc (HWND hWnd,
                                     UINT uiMsg,
                                     WPARAM wParam,
                                     LPARAM lParam);
private:
    CSysmonControl *m_pCtrl;
    HWND            m_hWnd;
    RECT            m_Rect;
    HWND            m_hWndItems ;
    HWND            m_hWndHeader ;
    WNDPROC         m_DefaultWndProc;
    HFONT           m_hFontItems ;
    HFONT           m_hFontLabels ;
    INT             m_xMinWidth ;
    INT             m_yHeaderHeight ;
    INT             m_yItemHeight ;
    INT             m_iNumItemsVisible ;
    INT             m_xEllipses;
    INT             m_iSortCol;
    INT             m_iSortDir;
    BOOL            m_fLoaded;
    LEGENDCOL       m_aCols [iLegendNumCols] ;
    DOUBLE*         m_parrColWidthFraction ;
    class CGraphItem    *m_pCurrentItem ;

    BOOL            m_fMetafile;  

    void DrawLabels ( HDC hDC ) ;
    void DrawColorCol ( PCGraphItem pItem, INT iCol, HDC hDC, HDC hAttribDC, INT yPos) ;
    void DrawCol ( INT iCol, HDC hDC, HDC hAttribDC, INT yPos, LPCTSTR lpszValue) ;
    void DrawItem ( PCGraphItem pItem, INT yPos, HDC hDC, HDC hAttribDC) ;
    void DrawColHeader ( 
            INT iCol, 
            HDC hDC, 
            HDC hAttribDC, 
            RECT& rRect, 
            BOOL bItemState ) ;

    void DrawHeader ( HDC hDC, HDC hAttribDC, RECT& rRect ) ;

    void OnPaint        ( void );
    void OnDrawItem     ( LPDRAWITEMSTRUCT lpDI ) ;
    void OnDrawHeader   ( LPDRAWITEMSTRUCT lpDI ) ;
    void OnMeasureItem  ( LPMEASUREITEMSTRUCT lpMI ) ;
    void OnDblClick     ( void ) ;
    void OnSelectionChanged ( void ) ;
    void OnColumnWidthChanged ( HD_NOTIFY *phdn );
    void OnColumnClicked( HD_NOTIFY *phdn );

    void AdjustColumnWidths ( INT iCol = 0 );

    INT GetItemIndex    ( PCGraphItem pItem ) ;
    LPCTSTR GetSortKey  ( PCGraphItem pItem ) ;
    HRESULT GetNextValue ( TCHAR*& pszNext, DOUBLE& rdValue );

public:
    CLegend         ( void );
    ~CLegend        ( void );

    HRESULT LoadFromStream  ( LPSTREAM pIStream ); 
    HRESULT SaveToStream    ( LPSTREAM pIStream );
	HRESULT	SaveToPropertyBag ( IPropertyBag*, BOOL fClearDirty, BOOL fSaveAllProps );
	HRESULT	LoadFromPropertyBag ( IPropertyBag*, IErrorLog* );

    void Render             ( HDC hDC, HDC hAttribDC, BOOL fMetafile, BOOL fEntire, LPRECT pRect );

    void ChangeFont ( HDC hDC );
    BOOL Init       ( CSysmonControl *pCtrl, HWND hWndParent ) ;
    INT MinHeight   ( INT yMaxHeight ) ;
    INT Height      ( INT yMaxHeight ) ;
    INT MinWidth    ( void ) ;
    void SizeComponents ( LPRECT pRect);

    BOOL AddItem    ( PCGraphItem pItem ) ;
    void DeleteItem ( PCGraphItem pItem ) ;
    BOOL SelectItem ( PCGraphItem pItem );
    void Clear      ( void ) ;

    PCGraphItem CurrentItem ( void ) ;
    HWND  Window    ( void ) ;

};

typedef CLegend *PLEGEND;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\irunobj.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    irunobj.cpp

Abstract:

    Implementation of the IRunnableObject interface which allows
    the control to enter the "running" state which means Sysmon's 
    dialog box is created, but not visible.  This is necessary so 
    that containers can ask for our extents before calling DoVerb.

--*/

#include "polyline.h"
#include "unkhlpr.h"

/*
 * CImpIRunnableObject interface implementation
 */

IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpIRunnableObject)

/*
 * CImpIRunnableObject::GetRunningClass
 *
 * Purpose:
 *  Returns the CLSID of the object.
 *
 * Parameters:
 *  pClsID          LPCLSID in which to store the CLSID.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIRunnableObject::GetRunningClass(LPCLSID pClsID)
    {
    *pClsID=m_pObj->m_clsID;
    return NOERROR;
    }


/*
 * CImpIRunnableObject::Run
 *
 * Purpose:
 *  Run an object in the given bind context, that is, put the object
 *  into the running state.
 *
 * Parameters:
 *  pBindCtx        LPBINDCTX of the bind context to use.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIRunnableObject::Run(LPBINDCTX /* pBindCtx */)
{
    /*
     * Registration of the object as running happens in
     * IOleObject::SetClientSite since we need a moniker from
     * the container and we don't have a client site pointer yet.
     */

    RECT rc;
    HRESULT hr = NOERROR;


    if (!m_pObj->m_bIsRunning) {
        SetRect(&rc,0,0,150,150);
        hr = m_pObj->m_pImpIPolyline->Init(g_hWndFoster, &rc, WS_CHILD | WS_VISIBLE,
                                            ID_POLYLINE);
        if ( SUCCEEDED ( hr ) ) {
            m_pObj->m_bIsRunning = TRUE;
        } 
    }

    return hr;
}


/*
 * CImpIRunnableObject::IsRunning
 *
 * Purpose:
 *  Answers whether an object is currently in the running state.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  BOOL            Indicates the running state of the object.
 */

STDMETHODIMP_(BOOL) CImpIRunnableObject::IsRunning(void)
    {
    return m_pObj->m_bIsRunning;
    }






/*
 * CImpIRunnableObject::LockRunning
 *
 * Purpose:
 *  Locks an already running object into the running state or unlocks
 *  it from such a state.
 *
 * Parameters:
 *  fLock               BOOL indicating lock (TRUE) or unlock
 *                      (FALSE)
 *  fLastUnlockCloses   BOOL indicating if the last call to this
 *                      function with fLock==FALSE closes the
 *                      object.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIRunnableObject::LockRunning(BOOL fLock
    , BOOL fLastUnlockCloses)
    {
    //Calling CoLockObjectExternal is all we have to do here.
    return CoLockObjectExternal(this, fLock, fLastUnlockCloses);
    }






/*
 * CImpIRunnableObject::SetContainedObject
 *
 * Purpose:
 *  Informs the object (embedded object) that it is inside a
 *  compound document container.
 *
 * Parameters:
 *  fContained      BOOL indicating if the object is now contained.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIRunnableObject::SetContainedObject(BOOL /* fContained */)
    {
    //We can ignore this.
    return NOERROR;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\legend.cpp ===
/*++

Copyright (C) 1992-1999 Microsoft Corporation

Module Name:

    legend.cpp

Abstract:

    This file contains code creating the legend window, which is
    a child of the graph windows. The legend window displays a
    legend line for each line in the associated graph. It also 
    includes an area called the label, which are headers for those
    lines.

--*/

//==========================================================================//
//                                  Includes                                //
//==========================================================================//


#include "polyline.h"
#include "utils.h"
#include <stdio.h>      // for sprintf
#include <uxtheme.h>
#include "winhelpr.h"
#include "owndraw.h"
#include "unihelpr.h"

#define eScaleValueSpace     TEXT(">9999999999.0")
#define szGraphLegendClass   TEXT("PerfLegend")
#define szGraphLegendClassA  "PerfLegend"

#define MAX_COL_CHARS (64)

LRESULT APIENTRY HdrWndProc (HWND, UINT, WPARAM, LPARAM);
 
//==========================================================================//
//                                  Constants                               //
//==========================================================================//
enum Orientation 
    {
    LEFTORIENTATION = TA_LEFT,
    CENTERORIENTATION = TA_CENTER,
    RIGHTORIENTATION = TA_RIGHT
    };

enum ColumnType 
    {
    eLegendColorCol = 0,
    eLegendScaleCol = 1,
    eLegendCounterCol = 2,
    eLegendInstanceCol = 3,
    eLegendParentCol = 4,
    eLegendObjectCol = 5,
    eLegendSystemCol = 6,
    eLegendExtraCol = 7     // If control wider than combined columns
    };

enum SortType
    {
    NO_SORT,
    INCREASING_SORT,
    DECREASING_SORT
    };

enum WindowType
    {
    LIST_WND = 1000,
    HDR_WND
    };

#define NULL_WIDTH      -1

#define dwGraphLegendClassStyle     (CS_HREDRAW | CS_VREDRAW)
#define iGraphLegendClassExtra      (0)
#define iGraphLegendWindowExtra     (sizeof (PLEGEND))
#define dwGraphLegendWindowStyle    (WS_CHILD | WS_VISIBLE) 

#define ThreeDPad           2
#define iMaxVisibleItems    8

#define dwGraphLegendItemsWindowClass  TEXT("ListBox")
#define dwGraphLegendItemsWindowStyle           \
   (LBS_NOTIFY | LBS_NOINTEGRALHEIGHT | LBS_OWNERDRAWFIXED | \
    WS_VISIBLE | WS_CHILD | WS_VSCROLL)

#define WM_DELAYED_SELECT   WM_USER + 100

#define LegendBottomMargin()  (ThreeDPad)
#define LegendLeftMargin()    (ThreeDPad)
#define LegendHorzMargin()    (10)

typedef struct {
    PCGraphItem pGItem;
    LPCTSTR  pszKey;
} SORT_ITEM, *PSORT_ITEM;

//==========================================================================//
//                              Local Variables                             //
//==========================================================================//
static INT  xBorderWidth = GetSystemMetrics(SM_CXBORDER);
static INT  yBorderHeight = GetSystemMetrics(SM_CYBORDER);

#define MAX_COL_HEADER_LEN 32
static TCHAR aszColHeader[iLegendNumCols][MAX_COL_HEADER_LEN];

//
// Sorting function
//
INT __cdecl 
LegendSortFunc(
    const void *elem1, 
    const void *elem2 
    )
{
    return lstrcmp(((PSORT_ITEM)elem1)->pszKey, ((PSORT_ITEM)elem2)->pszKey);
}


//
// Constructor
//
CLegend::CLegend ( void )
:   m_pCtrl ( NULL ),
    m_hWnd ( NULL ),
    m_hWndHeader ( NULL ),
    m_DefaultWndProc ( NULL ),
    m_hWndItems ( NULL ),
    m_hFontItems ( NULL ),
    m_hFontLabels ( NULL ),
    m_iNumItemsVisible ( 0 ),
    m_pCurrentItem ( NULL ),
    m_iSortDir ( NO_SORT ),
    m_parrColWidthFraction( NULL )
{

    m_fMetafile = FALSE; 

    m_aCols[0].xWidth = -1;
}

//
// Destructor
//
CLegend::~CLegend (void )
{
    // Restore default window proc
    // so we don't get called post-mortum
    if (m_hWndHeader != NULL) {
        SetWindowLongPtr(m_hWndHeader, GWLP_WNDPROC, (INT_PTR)m_DefaultWndProc);
    }

    if (m_hWnd != NULL) {
        DestroyWindow(m_hWnd);
    }

    if ( NULL != m_parrColWidthFraction ) {
        delete m_parrColWidthFraction;
    }
}

//
// Initialization
//
BOOL CLegend::Init ( PSYSMONCTRL pCtrl, HWND hWndParent )
   {
   INT     iCol ;
   HD_ITEM hdi;
   HDC      hDC;
   BOOL     fComputeWidths;
   WNDCLASS wc ;
   LONG     lExStyles;
    // Save pointer to parent control
    m_pCtrl = pCtrl;

    BEGIN_CRITICAL_SECTION

    // Register window class once
    if (pstrRegisteredClasses[LEGEND_WNDCLASS] == NULL) {
    
        wc.style          = dwGraphLegendClassStyle ;
        wc.lpfnWndProc    = (WNDPROC) GraphLegendWndProc ;
        wc.hInstance      = g_hInstance ;
        wc.cbClsExtra     = iGraphLegendClassExtra ;
        wc.cbWndExtra     = iGraphLegendWindowExtra ;
        wc.hIcon          = NULL ;
        wc.hCursor        = LoadCursor (NULL, IDC_ARROW) ;
        wc.hbrBackground  = NULL ;
        wc.lpszMenuName   = NULL ;
        wc.lpszClassName  = szGraphLegendClass ;

        if (RegisterClass (&wc)) {
            pstrRegisteredClasses[LEGEND_WNDCLASS] = szGraphLegendClass;
        }

        // Ensure controls are initialized 
        InitCommonControls(); 

        // Load the column header strings just once also
        for (iCol=0; iCol<iLegendNumCols; iCol++) {

            LoadString(g_hInstance, (IDS_LEGEND_BASE + iCol), aszColHeader[iCol], MAX_COL_HEADER_LEN);
        }
    }

    END_CRITICAL_SECTION

    if (pstrRegisteredClasses[LEGEND_WNDCLASS] == NULL)
        return FALSE;

    // Create our window
    m_hWnd = CreateWindow (szGraphLegendClass,      // class
                         NULL,                     // caption
                         dwGraphLegendWindowStyle, // window style
                         0, 0,                     // position
                         0, 0,                     // size
                         hWndParent,               // parent window
                         NULL,                     // menu
                         g_hInstance,              // program instance
                         (LPVOID) this );          // user-supplied data

    if (m_hWnd == NULL)
        return FALSE;

    // Turn off layout mirroring if it is enabled
    lExStyles = GetWindowLong(m_hWnd, GWL_EXSTYLE); 

    if ( 0 != ( lExStyles & WS_EX_LAYOUTRTL ) ) {
        lExStyles &= ~WS_EX_LAYOUTRTL;
        SetWindowLong(m_hWnd, GWL_EXSTYLE, lExStyles);
    }
    
    // Turn off XP window theme for the owner drawn list header and cells.
    SetWindowTheme (m_hWnd, TEXT (" "), TEXT (" "));

    m_hWndHeader = CreateWindow(WC_HEADER,
                        NULL, 
                        WS_CHILD | WS_BORDER | HDS_BUTTONS | HDS_HORZ, 
                        0, 0, 0, 0, 
                        m_hWnd, 
                        (HMENU)HDR_WND, 
                        g_hInstance, 
                        (LPVOID) NULL);
        
    if (m_hWndHeader == NULL)
        return FALSE;

    // Turn off XP window theme for the owner drawn list header and cells.
    SetWindowTheme (m_hWndHeader, TEXT (" "), TEXT (" "));

    // Insert our own window procedure for special processing                
    m_DefaultWndProc = (WNDPROC)SetWindowLongPtr(m_hWndHeader, GWLP_WNDPROC, (INT_PTR)HdrWndProc);

    // Create Legend Items Listbox
    m_hWndItems = CreateWindow (TEXT("ListBox"),   // window class
                    NULL,                          // window caption
                    dwGraphLegendItemsWindowStyle, // window style
                    0, 0, 0, 0,                    // window size and pos
                    m_hWnd,                        // parent window
                    (HMENU)LIST_WND,               // child ID
                    g_hInstance,                   // program instance
                    (LPVOID) TRUE) ;               // user-supplied data

    if (m_hWndItems == NULL)
      return FALSE;

    // Turn off XP window theme for the owner drawn list header and cells.
    SetWindowTheme (m_hWndItems, TEXT (" "), TEXT (" "));

    // Set up DC for text measurements
    hDC = GetDC (m_hWndHeader);
    if ( NULL != hDC ) {
        // Compute initial sizes based on font
        ChangeFont(hDC);
    }

    // Set column widths and header labels
    m_aCols[0].xPos = 0;

    fComputeWidths = (m_aCols[0].xWidth == -1);

    for (iCol = 0; iCol < iLegendNumCols; iCol++)
      {
        // If width not loaded, calculate one based on label
        if ( fComputeWidths && NULL != hDC ) {
            m_aCols[iCol].xWidth = TextWidth (hDC, aszColHeader[iCol]) +  2 * LegendHorzMargin () ;
        }

        m_aCols[iCol].iOrientation = LEFTORIENTATION;

        if (iCol > 0) {
            m_aCols[iCol].xPos = m_aCols[iCol-1].xPos + m_aCols[iCol-1].xWidth;
        }

        hdi.mask = HDI_FORMAT | HDI_WIDTH; 
        hdi.pszText = NULL;
        hdi.cxy = m_aCols[iCol].xWidth;
        hdi.fmt = HDF_OWNERDRAW | HDF_LEFT; 
 
        Header_InsertItem(m_hWndHeader, iCol, &hdi); 
    } 

    if ( NULL != hDC ) {
        ReleaseDC ( m_hWndHeader, hDC );
    }

    return TRUE;
}  
 
  
HRESULT CLegend::LoadFromStream(LPSTREAM pIStream)
{
    HRESULT hr;
    ULONG   bc;
    INT     iCol;
    LEGEND_DATA  LegendData;
    HD_ITEM hdi;


    hr = pIStream->Read(&LegendData, sizeof(LegendData), &bc);
    if (FAILED(hr))
        return hr;
        
    if (bc != sizeof(LegendData))
        return E_FAIL;

    hdi.mask = HDI_WIDTH; 

    for (iCol=0; iCol<iLegendNumCols; iCol++) {
        m_aCols[iCol].xWidth = LegendData.xColWidth[iCol];

        if (iCol > 0) {
            m_aCols[iCol].xPos = m_aCols[iCol-1].xPos + m_aCols[iCol-1].xWidth;
        }

        hdi.cxy = m_aCols[iCol].xWidth;
        Header_SetItem(m_hWndHeader, iCol, &hdi);                
    }

    m_iSortCol = LegendData.iSortCol;
    m_iSortDir = LegendData.iSortDir;

    return NOERROR;
}


HRESULT 
CLegend::SaveToStream(LPSTREAM pIStream)
{
    HRESULT hr;
    INT     iCol;
    LEGEND_DATA  LegendData;

    for (iCol=0; iCol<iLegendNumCols; iCol++) {
        LegendData.xColWidth[iCol] = m_aCols[iCol].xWidth;
    }

    LegendData.iSortCol = m_iSortCol;
    LegendData.iSortDir = m_iSortDir;

    hr = pIStream->Write(&LegendData, sizeof(LegendData), NULL);
    if (FAILED(hr))
        return hr;

    return NOERROR;
}

HRESULT 
CLegend::LoadFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog* pIErrorLog )
{
    HRESULT     hr = S_OK;
    LPTSTR pszData = NULL;
    int iBufSizeCurrent = 0;
    int iBufSize;
    
    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, L"LegendSortDirection", m_iSortDir );
    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, L"LegendSortColumn", m_iSortCol );

    iBufSize = iBufSizeCurrent;

    hr = StringFromPropertyBag (
            pIPropBag,
            pIErrorLog,
            L"LegendColumnWidths",
            pszData,
            iBufSize );

    if ( SUCCEEDED(hr) && 
            iBufSize > iBufSizeCurrent ) {
        // Width data exists.
        if ( NULL != pszData ) {
            delete pszData;
            pszData = NULL;
        }

        pszData = new TCHAR[ iBufSize ]; 
        
        if ( NULL == pszData ) {
            hr = E_OUTOFMEMORY;
        } else {
            lstrcpy ( pszData, _T("") );
            
            iBufSizeCurrent = iBufSize;

            hr = StringFromPropertyBag (
                    pIPropBag,
                    pIErrorLog,
                    L"LegendColumnWidths",
                    pszData,
                    iBufSize );
        }

        if ( SUCCEEDED(hr) ) {
            m_parrColWidthFraction = new DOUBLE[iLegendNumCols];

            if ( NULL == m_parrColWidthFraction )
                hr = E_OUTOFMEMORY;
        }

        if ( SUCCEEDED(hr) ) {
            INT iDataIndex;
            DOUBLE  dValue = 0;
            TCHAR* pNextData;
            TCHAR* pDataEnd;
        
            pNextData = pszData;
            pDataEnd = pszData + lstrlen(pszData);

            for ( iDataIndex = 0; SUCCEEDED(hr) && iDataIndex < iLegendNumCols; iDataIndex++ ) { 
                if ( pNextData < pDataEnd ) {
                    hr = GetNextValue ( pNextData, dValue );
                    if ( SUCCEEDED(hr) ) {
                        m_parrColWidthFraction[iDataIndex] = dValue;                    
                    } else {
                        hr = S_OK;
                    }                
                } else {
                    hr = E_FAIL;
                }
            }
        }
    }
    if (pszData != NULL) {
        delete pszData;
    }

    return NOERROR;
}

HRESULT 
CLegend::SaveToPropertyBag (
    IPropertyBag* pIPropBag,
    BOOL /* fClearDirty */,
    BOOL /* fSaveAllProps */ )
{
    HRESULT hr = NOERROR;
    TCHAR   szData[MAX_COL_CHARS*iLegendNumCols + 1];
    TCHAR*  pszTemp;
    INT iIndex;
    VARIANT vValue;
    INT   xWidth;

    xWidth = m_Rect.right - m_Rect.left - 2 * LegendLeftMargin();

    // Continue even if error, using defaults in those cases.
    lstrcpy ( szData,L"" );

    for ( iIndex = 0; SUCCEEDED(hr) && iIndex < iLegendNumCols; iIndex++ ) { 

        DOUBLE  dFractionWidth;
        dFractionWidth = ( (DOUBLE)m_aCols[iIndex].xWidth ) / xWidth;
        
        if ( iIndex > 0 ) {
            lstrcat ( szData, L"\t" );
        }
        
        VariantInit( &vValue );
        vValue.vt = VT_R8;
        vValue.dblVal = dFractionWidth;
        hr = VariantChangeTypeEx( &vValue, &vValue, LCID_SCRIPT, VARIANT_NOUSEROVERRIDE, VT_BSTR );
        
        pszTemp = W2T( vValue.bstrVal);
    
        lstrcat ( szData, pszTemp );
        
        VariantClear( &vValue );
    }

    if ( SUCCEEDED( hr ) ){
        hr = StringToPropertyBag ( pIPropBag, L"LegendColumnWidths", szData );
    }

    hr = IntegerToPropertyBag ( pIPropBag, L"LegendSortDirection", m_iSortCol );

    hr = IntegerToPropertyBag ( pIPropBag, L"LegendSortColumn", m_iSortDir );

    return NOERROR;
}


//
// Get list index of item
//
INT CLegend::GetItemIndex(PCGraphItem pGItem)
{
    INT nItems;
    INT i;

    nItems = LBNumItems(m_hWndItems);

    for (i=0; i<nItems; i++)
        {
          if (pGItem == (PCGraphItem)LBData(m_hWndItems, i))
            return i;
        }

    return LB_ERR;
}

//
// Select list item
//          
BOOL CLegend::SelectItem(PCGraphItem pGItem) 
{
    INT iIndex;

    // Don't reselect the current selection
    // This is our parent echoing the change
    if (pGItem == m_pCurrentItem)
        return TRUE;

    iIndex = GetItemIndex(pGItem);

    if (iIndex == LB_ERR)
        return FALSE;

    LBSetSelection (m_hWndItems, iIndex) ;
    m_pCurrentItem = pGItem;

    return TRUE;
}

//
// Add new item to legend
//
BOOL CLegend::AddItem (PCGraphItem pItem)
{
    INT     iHigh,iLow,iMid;
    INT     iComp;
    LPCTSTR pszItemKey;
    LPCTSTR pszItemKey2;
    PCGraphItem pListItem;
    BOOL    bSorted = TRUE;
    
    if (m_iSortDir == NO_SORT) {
        bSorted = FALSE;
    }
    else {

        //
        // If we need to sort, we must sort based upon a sortable
        // column. So check to make sure we have a sortable column.
        // If we don't have a sortable column, just add the item 
        //
        pszItemKey = GetSortKey(pItem);

        if (pszItemKey == NULL) {
            bSorted = FALSE;
        }
    }

    if (bSorted == TRUE) {
        //
        // Binary search search for insertion point
        //
        iLow = 0;
        iHigh = LBNumItems(m_hWndItems);
        iMid = (iHigh + iLow) / 2;

        while (iLow < iHigh) {

            pListItem = (PCGraphItem)LBData(m_hWndItems, iMid);

            pszItemKey2 = GetSortKey(pListItem);
            //
            // pszItemKey2 should not be NULL if we come this point.
            // But if somehow it is NULL, then add the item
            //
            if (pszItemKey2 == NULL) {
                bSorted = FALSE;
                break;
            }

            iComp = lstrcmp(pszItemKey, pszItemKey2);
            if (m_iSortDir == DECREASING_SORT) {
                iComp = -iComp;
            }

            if (iComp > 0) {
                iLow = iMid + 1;
            }
            else {
                iHigh = iMid;
            }

            iMid = (iHigh + iLow) / 2;
        }
    }

    if (bSorted == TRUE) {
        LBInsert (m_hWndItems, iMid, pItem) ;
    }
    else {
        LBAdd(m_hWndItems, pItem);
    }

    return TRUE;
}


//
// Delete item from legend
//
void CLegend::DeleteItem (PCGraphItem pItem)
{
    INT iIndex ;        

    // Calling procedure checks for NULL pItem
    assert ( NULL != pItem );
    iIndex = GetItemIndex (pItem) ;

    if (iIndex != LB_ERR) {

        LBDelete (m_hWndItems, iIndex) ;

        // If deleted the current item
        // select the next one (or prev if no next)
        if (pItem == m_pCurrentItem) {

            if (iIndex == LBNumItems(m_hWndItems))
                iIndex--;

            if (iIndex >= 0)
                m_pCurrentItem = (PCGraphItem)LBData(m_hWndItems, iIndex);
            else
                m_pCurrentItem = NULL;

            LBSetSelection (m_hWndItems, iIndex) ;
            m_pCtrl->SelectCounter(m_pCurrentItem);
        }
    }
}


//
// Clear all items from legend
//
void CLegend::Clear ( void )
{
   LBReset (m_hWndItems) ;
   m_pCurrentItem = NULL ;
}

//
// Get currently selected item
//
PCGraphItem CLegend::CurrentItem ( void )
{
   return (m_pCurrentItem) ;
}

//
// Get legend window
//
HWND CLegend::Window ( void )
{
    return m_hWnd;
}

//
// Draw the header for a column
//

void 
CLegend::DrawColHeader(
    INT iCol, 
    HDC hDC, 
    HDC hAttribDC, 
    RECT& rRect, 
    BOOL bItemState )
{
    HFONT   hFontPrev;
    INT     xBorderWidth, yBorderHeight;
    RECT    rc = rRect;
    
    xBorderWidth = GetSystemMetrics(SM_CXBORDER);
    yBorderHeight = GetSystemMetrics(SM_CYBORDER);

    if ( m_fMetafile ) {
        if ( eAppear3D == m_pCtrl->Appearance() ) {
            DrawEdge(hDC, &rc, EDGE_RAISED, BF_RECT);
        } else {
            Rectangle (hDC, rc.left, rc.top, 
               rc.right, rc.bottom );
        }
    }


    if ( iCol < iLegendNumCols ) {

        rc.top += yBorderHeight + 1;    // Extra pixel so that tops of letters don't get clipped.
        rc.bottom -= yBorderHeight;
        rc.left += 6 * xBorderWidth;
        rc.right -= 6 * xBorderWidth;

        if ( bItemState )
           OffsetRect(&rc, xBorderWidth, yBorderHeight);

        SetTextColor (hDC, m_pCtrl->clrFgnd()) ;
        SetBkColor(hDC, m_pCtrl->clrBackCtl()) ;
        SetTextAlign (hDC, m_aCols[iCol].iOrientation) ;
        hFontPrev = (HFONT)SelectFont(hDC, m_pCtrl->Font());

        FitTextOut (
            hDC, 
            hAttribDC, 
            0, 
            &rc, 
            aszColHeader[iCol], 
            lstrlen(aszColHeader[iCol]),
            m_aCols[iCol].iOrientation, FALSE );

        SelectFont (hDC, hFontPrev);
    }
}


//
// Draw the headers for all columns
//
void 
CLegend::DrawHeader(
    HDC hDC, 
    HDC hAttribDC, 
    RECT& /* rUpdateRect */ )
{
    INT iCol;
    RECT rectCol;
    INT iSumColWidths;     

    iSumColWidths = 0;

    for ( iCol = 0; iCol < iLegendNumCols; iCol++ ) {
        INT iColWidth;

        Header_GetItemRect( m_hWndHeader, iCol, &rectCol );
        
        iColWidth = rectCol.right - rectCol.left;
        
        if ( 0 < iColWidth ) {

            iSumColWidths += iColWidth;

            OffsetRect ( &rectCol, m_Rect.left, m_Rect.top );
        
            // Don't draw past the legend bounds.
            if ( rectCol.bottom > m_Rect.bottom ) {
                break;
            } else if ( rectCol.left >= m_Rect.right ) {
                break;
            } else if ( m_Rect.right < rectCol.right ) {
                rectCol.right = m_Rect.right;
            }

            DrawColHeader( iCol, hDC, hAttribDC, rectCol, FALSE );
        }
    }

    // Handle extra width past last column

    if ( iSumColWidths < ( m_Rect.right - m_Rect.left ) ) {
        rectCol.left = m_Rect.left + iSumColWidths;
        rectCol.right = m_Rect.right;

        DrawColHeader( iLegendNumCols, hDC, hAttribDC, rectCol, FALSE );    
    }
}


//
// Draw the color column for a legend item
//
void 
CLegend::DrawColorCol ( 
    PCGraphItem pItem, 
    INT iCol, 
    HDC hDC, 
    HDC hAttribDC, 
    INT yPos)
{   
    RECT    rect ;
    HRGN    hRgnOld;
    INT     iRgn;
    INT     yMiddle;

    if ( 0 < m_aCols[iCol].xWidth ) {

        rect.left = m_aCols[iCol].xPos + LegendLeftMargin () ;
        rect.top = yPos + 1 ;
        rect.right = rect.left + m_aCols[iCol].xWidth - 2 * LegendLeftMargin () ;
        rect.bottom = yPos + m_yItemHeight - 1 ;

        if( m_fMetafile ) {
            OffsetRect ( &rect, m_Rect.left, m_Rect.top );

            // Handle clipping.
            if ( rect.bottom > m_Rect.bottom ) {
                return;
            } else if ( rect.left >= m_Rect.right ) {
                return;
            } else if ( m_Rect.right < rect.right ) {
                rect.right = m_Rect.right;
            }
        }

        yMiddle = (rect.top + rect.bottom) / 2;

        if ( m_fMetafile ) {
            Line (hDC, pItem->Pen(), 
                   rect.left + 1, yMiddle, rect.right - 1, yMiddle) ;
        } else {
            if ( NULL != hAttribDC && NULL != hDC ) {
                hRgnOld = CreateRectRgn(0,0,0,0);    
                if ( NULL != hRgnOld ) {
                    iRgn = GetClipRgn(hAttribDC, hRgnOld);
                    if ( -1 != iRgn ) {
                        if ( ERROR != IntersectClipRect (hDC, rect.left + 1, rect.top + 1,
                                rect.right - 1, rect.bottom - 1) ) {
                            Line (hDC, pItem->Pen(), 
                               rect.left + 1, yMiddle, rect.right - 1, yMiddle) ;
                        }
                        // Old clip region is for the ListBox item window, so can't
                        // use this for printing.
                        if ( 1 == iRgn ) {
                            SelectClipRgn(hDC, hRgnOld);
                        }
                    }
                    DeleteObject(hRgnOld);
                }
            }
        }
    }
}


void 
CLegend::DrawCol (
    INT iCol, 
    HDC hDC, 
    HDC hAttribDC,
    INT yPos, 
    LPCTSTR lpszValue)
/*
   Effect:        Draw the value lpszValue for the column iCol on hDC.

   Assert:        The foreground and background text colors of hDC are
                  properly set.
*/
{
    static TCHAR    szMissing[4] = TEXT("---");
    
    RECT    rect ;
    INT     xPos ;
    BOOL    bNeedEllipses = FALSE;
    INT     cChars = 0;
    TCHAR   achBuf[MAX_COL_CHARS + sizeof(ELLIPSES)/sizeof(TCHAR) + 1];

    if ( 0 < m_aCols[iCol].xWidth ) {
        rect.left = m_aCols[iCol].xPos + LegendLeftMargin() ;
        rect.top = yPos ;
        rect.right = rect.left + m_aCols[iCol].xWidth - 3 * LegendLeftMargin() ;
        rect.bottom = yPos + m_yItemHeight ;
  
        if( m_fMetafile ) {
            OffsetRect ( &rect, m_Rect.left, m_Rect.top );

            // Don't draw past the legend bounds.

            if ( rect.bottom > m_Rect.bottom ) {
                return;
            } else if ( rect.left >= m_Rect.right ) {
                return;
            } else if ( m_Rect.right < rect.right ) {
                rect.right = m_Rect.right;
            }

            DrawEdge(hDC, &rect, BDR_SUNKENOUTER, BF_RECT);
        }

        switch (m_aCols[iCol].iOrientation)
        {  // switch
            case LEFTORIENTATION:
                SetTextAlign (hDC, TA_LEFT) ;
                xPos = rect.left ;
                break ;

            case CENTERORIENTATION:
                SetTextAlign (hDC, TA_CENTER) ;
                xPos = (rect.left + rect.right) / 2 ;
                break ;

            case RIGHTORIENTATION:
                SetTextAlign (hDC, TA_RIGHT) ;
                xPos = rect.right ;
                break ;

            default:
                xPos = rect.left ;
                break ;
        }  // switch

        if (lpszValue[0] == 0)
            lpszValue = szMissing;

        bNeedEllipses = NeedEllipses (
                            hAttribDC, 
                            lpszValue, 
                            lstrlen(lpszValue), 
                            rect.right - rect.left, 
                            m_xEllipses, 
                            &cChars ); 
        

        if ( bNeedEllipses ) {
            cChars = min(cChars,MAX_COL_CHARS);
            memcpy(achBuf,lpszValue,cChars * sizeof(TCHAR));
            lstrcpy(&achBuf[cChars],ELLIPSES);
            lpszValue = achBuf;
            cChars += ELLIPSES_CNT;
        }

        ExtTextOut (hDC, xPos, rect.top + yBorderHeight, ETO_OPAQUE | ETO_CLIPPED,
                   &rect, lpszValue, cChars, NULL) ;
    }
}

//
// Draw one legend line
//
void 
CLegend::DrawItem (
    PCGraphItem pItem, 
    INT yPos, 
    HDC hDC, 
    HDC hAttribDC)
{

    TCHAR   szName[MAX_PATH];
    INT     iMinWidth = 3;
    INT     iPrecision = 3;

    // Draw Color
    DrawColorCol (pItem, eLegendColorCol, hDC, hAttribDC, yPos) ;

    // Draw Scale

#if PDH_MIN_SCALE != -7
// display a message if the scale format string gets out of sync with
// the PDH limits
#pragma message ("\nLEGEND.CPP: the scale format statement does not match the PDH\n")
#endif        

    if ( pItem->Scale() < (FLOAT) 1.0 ) {
        iMinWidth = 7; 
        iPrecision = 7;
    } else {
        iMinWidth = 3;
        iPrecision = 3;
    }


    FormatNumber (
        pItem->Scale(),
        szName,
        MAX_PATH,
        iMinWidth,
        iPrecision );

    SetTextAlign (hDC, TA_TOP) ;   
    DrawCol ( eLegendScaleCol, hDC, hAttribDC, yPos, szName) ;

    // Draw Counter
    DrawCol ( eLegendCounterCol, hDC, hAttribDC, yPos, pItem->Counter()->Name()) ;
 
    // Draw Instance
    pItem->Instance()->GetInstanceName(szName);
    DrawCol ( eLegendInstanceCol, hDC, hAttribDC, yPos, szName) ;

    // Draw Parent
    pItem->Instance()->GetParentName(szName);
    DrawCol (eLegendParentCol, hDC, hAttribDC, yPos, szName) ;

    // Draw Object
    DrawCol (eLegendObjectCol, hDC, hAttribDC, yPos, pItem->Object()->Name()) ;

    // Draw System
    DrawCol (eLegendSystemCol, hDC, hAttribDC, yPos, pItem->Machine()->Name()) ;
}

//
// Resize parts of legend
//
void CLegend::SizeComponents (LPRECT pRect)
{
    INT xWidth;
    INT yHeight;

    m_Rect = *pRect;

    xWidth = pRect->right - pRect->left;
    yHeight = pRect->bottom - pRect->top;

    // If no space, hide window and leave
    if (xWidth == 0 || yHeight == 0) {
        WindowShow(m_hWnd, FALSE);
        return;
    }
    
    // If loaded from property bag, set column sizes.
    if ( NULL != m_parrColWidthFraction ) {
        INT iColTotalWidth;
        INT iCol;
        HD_ITEM hdi;

        hdi.mask = HDI_WIDTH; 

        iColTotalWidth = xWidth - 2 * LegendLeftMargin();

        for ( iCol = 0; iCol < iLegendNumCols; iCol++ ) { 
            m_aCols[iCol].xWidth = (INT)(m_parrColWidthFraction[iCol] * iColTotalWidth);
            hdi.cxy = m_aCols[iCol].xWidth;
            Header_SetItem(m_hWndHeader, iCol, &hdi);                
        }

        AdjustColumnWidths ();

        delete m_parrColWidthFraction;
        m_parrColWidthFraction = NULL;
    }

    // Show window to assigned position
    MoveWindow(m_hWnd, pRect->left, pRect->top, xWidth, yHeight, FALSE);
    WindowShow(m_hWnd, TRUE);
 
    // Set the size, position, and visibility of the header control. 
    SetWindowPos(m_hWndHeader, HWND_TOP, 0, 0, xWidth, m_yHeaderHeight, SWP_SHOWWINDOW); 

    // Resize legend items window
    MoveWindow (m_hWndItems, 
               LegendLeftMargin (), m_yHeaderHeight + ThreeDPad,
               xWidth - 2 * LegendLeftMargin (),
               yHeight - m_yHeaderHeight - ThreeDPad - LegendBottomMargin(),
               TRUE) ;
}

//
// Repaint legend area
//

void CLegend::OnPaint ( void )
   {  // OnPaint
    HDC             hDC ;
    RECT            rectFrame;
    PAINTSTRUCT     ps ;

    hDC = BeginPaint (m_hWnd, &ps) ;

    if ( eAppear3D == m_pCtrl->Appearance() ) {
        // Draw 3D border
        GetClientRect(m_hWnd, &rectFrame);
        //rectFrame.bottom -= ThreeDPad;
        //rectFrame.right -= ThreeDPad;
        DrawEdge(hDC, &rectFrame, BDR_SUNKENOUTER, BF_RECT);
    }

    if (LBNumItems (m_hWndItems) == 0) {
        WindowInvalidate(m_hWndItems) ;
    }


   EndPaint (m_hWnd, &ps) ;
   }  // OnPaint

//
// Handle user drawn header
//

void CLegend::OnDrawHeader(LPDRAWITEMSTRUCT lpDI)
{
    INT iCol = DIIndex(lpDI);
    HDC hDC = lpDI->hDC;
    RECT    rc = lpDI->rcItem;
    BOOL    bItemState = lpDI->itemState;

    // The screen DC is used for the attribute DC.
    DrawColHeader( iCol, hDC, hDC, rc, bItemState );
}

//
// Handle user drawn item message
//
void CLegend::OnDrawItem (LPDRAWITEMSTRUCT lpDI)
{
    HFONT          hFontPrevious ;
    HDC            hDC ;
    PCGraphItem    pItem ;
    INT            iLBIndex ;
    COLORREF       preBkColor = m_pCtrl->clrBackCtl();
    COLORREF       preTextColor = m_pCtrl->clrFgnd();
    BOOL           ResetColor = FALSE ;

    hDC = lpDI->hDC ;
    iLBIndex = DIIndex (lpDI) ;

    if (iLBIndex == -1)
        pItem = NULL ;
    else
        pItem = (PCGraphItem) LBData (m_hWndItems, iLBIndex) ;

    // If only a focus change, flip focus rect and leave
    if (lpDI->itemAction == ODA_FOCUS) {
        DrawFocusRect (hDC, &(lpDI->rcItem)) ;
        return;
    }
       
    // If item is selected use highlight colors
    if (DISelected (lpDI) || pItem == NULL) {      
        preTextColor = SetTextColor (hDC, GetSysColor (COLOR_HIGHLIGHTTEXT)) ;
        preBkColor = SetBkColor (hDC, GetSysColor (COLOR_HIGHLIGHT)) ;
        ResetColor = TRUE;
    } // Else set BkColor to BackColorLegend selected by the user.

    // Clear area
    ExtTextOut (hDC, lpDI->rcItem.left, lpDI->rcItem.top,
    ETO_OPAQUE, &(lpDI->rcItem), NULL, 0, NULL ) ;
   
    // Draw Legend Item
    if (pItem) {
        hFontPrevious = SelectFont (hDC, m_pCtrl->Font()) ;
        // The screen DC is used as the attribute DC
        DrawItem (pItem, lpDI->rcItem.top, hDC, hDC) ;
        SelectFont (hDC, hFontPrevious) ;
    }

    // Draw Focus rect
    if (DIFocus (lpDI))
        DrawFocusRect (hDC, &(lpDI->rcItem)) ;

    // Restore original colors
    if (ResetColor == TRUE) {
        SetTextColor (hDC, preTextColor) ;
        SetBkColor (hDC, preBkColor) ;
    }
}

void CLegend::OnMeasureItem (LPMEASUREITEMSTRUCT lpMI) {  
    lpMI->itemHeight = m_yItemHeight ;
}  // OnMeasureItem



void CLegend::OnDblClick ( void )
{
    m_pCtrl->DblClickCounter ( m_pCurrentItem );
}


//
// Handle selection change message
//

void CLegend::OnSelectionChanged ( void )
{
    INT             iIndex ;
    PCGraphItem     pGItem;

    // Get the new selection
    iIndex = LBSelection (m_hWndItems) ;
    pGItem = (PCGraphItem) LBData (m_hWndItems, iIndex) ;

    // if it's bad, reselect the current one
    // else request parent control to select new item
    if (pGItem == (PCGraphItem)LB_ERR) {
        SelectItem(m_pCurrentItem);
    }
    else {
        m_pCurrentItem = pGItem;
        m_pCtrl->SelectCounter(pGItem);
    }
}

void CLegend::AdjustColumnWidths (
    INT iCol
    )
{
    INT i;

    // Adjust positions of following columns
    for (i=iCol+1; i < iLegendNumCols; i++) {
        m_aCols[i].xPos = m_aCols[i - 1].xPos + m_aCols[i - 1].xWidth ;
    }
}

void CLegend::OnColumnWidthChanged (
    HD_NOTIFY *phdn
    )
{
    INT iCol = phdn->iItem;
    INT xWidth = phdn->pitem->cxy;

    // Update column width
    m_aCols[iCol].xWidth = xWidth;

    AdjustColumnWidths ( iCol );
    
    // Force update
    WindowInvalidate(m_hWndItems) ;
}


LPCTSTR CLegend::GetSortKey (
    PCGraphItem  pItem
    )
{
static  TCHAR   chNullName = 0;

    switch (m_iSortCol) {

    case eLegendCounterCol: 
        return pItem->Counter()->Name(); 

    case eLegendInstanceCol:
        if (pItem->Instance()->HasParent()) 
            return _tcschr(pItem->Instance()->Name(), TEXT('/')) + 1;
        else
            return pItem->Instance()->Name(); 

    case eLegendParentCol:
        if (pItem->Instance()->HasParent())
            return pItem->Instance()->Name(); 
        else
            return &chNullName;

    case eLegendObjectCol:
        return pItem->Object()->Name(); 

    case eLegendSystemCol:
        return pItem->Machine()->Name(); 
    }

    return NULL;
}


void 
CLegend::OnColumnClicked (
    HD_NOTIFY *phdn
    )
{
    INT         i;
    INT         iCol = phdn->iItem;
    INT         nItems = LBNumItems (m_hWndItems);
    PSORT_ITEM  pSortItem;
    PSORT_ITEM  pSortItems;
    BOOL        bResort = FALSE;

    if (nItems <= 0)
        return;

    // Can't sort on color or scale factor
    if (iCol == eLegendColorCol || iCol == eLegendScaleCol) {
        m_iSortDir = NO_SORT;
        return;
    }

    // If repeat click, reverse sort direction
    if (iCol == m_iSortCol) {
        bResort = TRUE;
        m_iSortDir = (m_iSortDir == INCREASING_SORT) ?
                        DECREASING_SORT : INCREASING_SORT;
    } else {
        m_iSortCol = iCol;
        m_iSortDir = INCREASING_SORT;
    }

    // Allocate array for sorting
    pSortItems = new SORT_ITEM [nItems];
    if (pSortItems == NULL) {
        return;     
    }

    // Build array of GraphItem/Key pairs
    pSortItem = pSortItems;
    for (i=0; i<nItems; i++,pSortItem++) {
        
        pSortItem->pGItem = (PCGraphItem)LBData(m_hWndItems, i);
        pSortItem->pszKey = GetSortKey(pSortItem->pGItem);
    }

    // For resort, just reload in reverse order.
    if ( !bResort ) {
        // Sort by key value
        qsort( (PVOID)pSortItems, nItems, sizeof(SORT_ITEM), &LegendSortFunc );
    }

    // Disable drawing while rebuilding list
    LBSetRedraw(m_hWndItems, FALSE);

    // Clear list box
    LBReset (m_hWndItems) ;

    // Reload in sorted order
    if ( !bResort && m_iSortDir == INCREASING_SORT) {
        for (i=0; i<nItems; i++) {
            LBAdd (m_hWndItems, pSortItems[i].pGItem);
        }
    } else {
        for (i=nItems - 1; i>=0; i--) {
            LBAdd (m_hWndItems, pSortItems[i].pGItem);
        }
    }

    LBSetRedraw(m_hWndItems, TRUE);

    delete pSortItems;
}

//
// Window procedure
//
LRESULT APIENTRY GraphLegendWndProc (HWND hWnd, UINT uiMsg, WPARAM wParam,
                                     LPARAM lParam)
{
   CLegend        *pLegend;
   BOOL           bCallDefProc ;
   LRESULT        lReturnValue ;
   RECT           rect;

   pLegend = (PLEGEND)GetWindowLongPtr(hWnd,0);

   bCallDefProc = FALSE ;
   lReturnValue = 0L ;

   switch (uiMsg)
      {
      case WM_CREATE:
            pLegend = (PLEGEND)((CREATESTRUCT*)lParam)->lpCreateParams;
            SetWindowLongPtr(hWnd,0,(INT_PTR)pLegend);
            break;

      case WM_DESTROY:
    pLegend->m_hWnd = NULL;
         break ;

      case WM_LBUTTONDBLCLK:
      case WM_LBUTTONDOWN:
            SendMessage(GetParent(hWnd), uiMsg, wParam, lParam);
            break;

      case WM_COMMAND:
         switch (HIWORD (wParam))
            {  // switch
            case LBN_DBLCLK:
               pLegend->OnDblClick () ;
               break ;

            case LBN_SELCHANGE:
               pLegend->OnSelectionChanged () ;
               break ;

            case LBN_SETFOCUS:
                pLegend->m_pCtrl->Activate();
                break;

            default:
               bCallDefProc = TRUE ;
            }  // switch
         break ;
                                          
      case WM_NOTIFY:
          switch (((LPNMHDR)lParam)->code)
            {
            case HDN_ENDTRACK:
                pLegend->OnColumnWidthChanged((HD_NOTIFY*) lParam);
                break;

            case HDN_ITEMCLICK:
                pLegend->OnColumnClicked((HD_NOTIFY*) lParam);
                pLegend->m_pCtrl->Activate();
                break;
            }

            return FALSE;
            break;

      case WM_DRAWITEM:
          switch (((LPDRAWITEMSTRUCT)lParam)->CtlID) {

          case LIST_WND:
                pLegend->OnDrawItem((LPDRAWITEMSTRUCT) lParam) ;
                break;

          case HDR_WND:
                pLegend->OnDrawHeader((LPDRAWITEMSTRUCT) lParam) ;
                break;
          }

         break ;

      case WM_MEASUREITEM:
         pLegend->OnMeasureItem ((LPMEASUREITEMSTRUCT) lParam) ;
         break ;

      case WM_DELETEITEM:
         break ;

      case WM_ERASEBKGND:
        GetClientRect(hWnd, &rect);
        Fill((HDC)wParam, pLegend->m_pCtrl->clrBackCtl(), &rect);
        return TRUE; 

      case WM_PAINT:
         pLegend->OnPaint () ;
         break ;

      case WM_SETFOCUS:
         SetFocus(pLegend->m_hWndItems);
         break ;

      default:
         bCallDefProc = TRUE ;
      }


   if (bCallDefProc)
      lReturnValue = DefWindowProc (hWnd, uiMsg, wParam, lParam) ;

   return (lReturnValue);
}

LRESULT APIENTRY 
HdrWndProc (
    HWND hWnd,
    UINT uiMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    RECT    rect;
    CLegend *pLegend;
    
    // Parent window carries the Legend object pointer
    pLegend = (PLEGEND)GetWindowLongPtr(GetParent(hWnd),0);

    if (uiMsg == WM_ERASEBKGND) {
        GetClientRect(hWnd, &rect);
        Fill((HDC)wParam, pLegend->m_pCtrl->clrBackCtl(), &rect);
        return TRUE;
    }

    // Do the default processing
#ifdef STRICT
    return CallWindowProc(pLegend->m_DefaultWndProc, hWnd, uiMsg, wParam, lParam);
#else
    return CallWindowProc((FARPROC)pLegend->m_DefaultWndProc, hWnd, uiMsg, wParam, lParam);
#endif
}


//
// Compute minimum width of legend
//
INT CLegend::MinWidth ( void )
{
    return 0 ;
}

//
// Compute minimum height of legend
//
INT CLegend::MinHeight ( INT yMaxHeight )
{
    INT yHeight = m_yHeaderHeight + m_yItemHeight + 2*ThreeDPad 
                    + LegendBottomMargin();

    return (yMaxHeight >= yHeight) ? yHeight : 0;
}


//
// Compute prefered height of legend
//
INT CLegend::Height (INT yMaxHeight)
{
    INT nItems;
    INT nPrefItems;
    
    // Determine preferred number of items to show
    nPrefItems = PinInclusive(LBNumItems(m_hWndItems), 1, iMaxVisibleItems);

    // Determine number of items that will fit
    nItems = (yMaxHeight - m_yHeaderHeight - 2*ThreeDPad - LegendBottomMargin())
                 / m_yItemHeight;
    
    // Use smaller number
    nItems = min(nItems, nPrefItems);

    // If no items will fit, return zero
    if (nItems == 0)
        return 0;

    // Return height of legend with nItems
    return m_yHeaderHeight + 2*ThreeDPad + nItems * m_yItemHeight 
                + LegendBottomMargin();
}



#ifdef KEEP_PRINT

void CLegend::Print (HDC hDC, RECT rectLegend)
   {
   INT            yItemHeight ;
   HFONT          hFontItems ;
   PCGraphItem    pItem ;
   INT            iIndex ;
   INT            iIndexNum ;

   yItemHeight = m_yItemHeight ;
   hFontItems = m_hFontItems ;

   m_hFontItems = hFontPrinterScales ;
   SelectFont (hDC, m_hFontItems) ;

   m_yItemHeight = FontHeight (hDC, TRUE) ;

   iIndexNum = LBNumItems (m_hWndItems);
   for (iIndex = 0; iIndex < iIndexNum; iIndex++)
      {
      pItem = (PCGraphItem) LBData (m_hWndItems, iIndex) ;
      DrawItem (pItem, iIndex * m_yItemHeight, hDC) ;
      }

   m_hFontItems = hFontItems ;
   m_yItemHeight = yItemHeight ;

   SelectBrush (hDC, GetStockObject (HOLLOW_BRUSH)) ;
   SelectPen (hDC, GetStockObject (BLACK_PEN)) ;
   Rectangle (hDC, 0, 0, 
              rectLegend.right - rectLegend.left,
              rectLegend.bottom - rectLegend.top) ;
   }
#endif


void 
CLegend::ChangeFont( 
    HDC hDC 
    )
{   
    HD_LAYOUT   hdl;
    WINDOWPOS   wp;
    RECT        rectLayout;

    // Assign font to header
    SetFont(m_hWndHeader, m_pCtrl->Font());

    // Get prefered height of header control
    // (use arbitrary rect for allowed area)
    rectLayout.left = 0;
    rectLayout.top = 0;
    rectLayout.right = 32000;
    rectLayout.bottom = 32000;

    wp.cy = 0;
    hdl.prc = &rectLayout; 
    hdl.pwpos = &wp; 
    Header_Layout(m_hWndHeader, &hdl);
    m_yHeaderHeight = wp.cy + 2 * yBorderHeight;   

    // Set up DC for font measurements
    SelectFont (hDC, m_pCtrl->Font()) ;
    
    // Compute height of legend line 
    SelectFont (hDC, m_hFontItems) ;
    m_yItemHeight = FontHeight (hDC, TRUE) + 2 * yBorderHeight;

    LBSetItemHeight(m_hWndItems, m_yItemHeight);

    // Compute width of "..."
    m_xEllipses = TextWidth (hDC, ELLIPSES) ;
}



void 
CLegend::Render(
    HDC hDC,
    HDC hAttribDC, 
    BOOL /*fMetafile*/,
    BOOL /*fEntire*/,
    LPRECT prcUpdate )
{
    PCGraphItem pItem ;
    INT         iIndex ;
    INT         iIndexNum ;
    RECT        rectPaint;
    HFONT       hFontPrevious;

    // if no space assigned, return
    if (m_Rect.top == m_Rect.bottom)
        return;

    // if no painting needed, return
    if (!IntersectRect(&rectPaint, &m_Rect, prcUpdate))
        return;

    m_fMetafile = TRUE;

    hFontPrevious = SelectFont (hDC, m_pCtrl->Font()) ;

    DrawHeader ( hDC, hAttribDC, rectPaint );

    SelectFont (hDC, hFontPrevious) ;    

    iIndexNum = LBNumItems (m_hWndItems);

    hFontPrevious = SelectFont (hDC, m_pCtrl->Font()) ;

    for (iIndex = 0; iIndex < iIndexNum; iIndex++) {
      pItem = (PCGraphItem) LBData (m_hWndItems, iIndex) ;
      DrawItem (
          pItem, 
          m_yHeaderHeight + ( iIndex * m_yItemHeight ), 
          hDC,
          hAttribDC) ;
    }

    SelectFont (hDC, hFontPrevious) ;    

    m_fMetafile = FALSE;


    SelectBrush (hDC, GetStockObject (HOLLOW_BRUSH)) ;
    SelectPen (hDC, GetStockObject (BLACK_PEN)) ;

    if ( eAppear3D == m_pCtrl->Appearance() ) {
        // Draw 3D border
        DrawEdge(hDC, &m_Rect, BDR_SUNKENOUTER, BF_RECT);
    }
}

HRESULT
CLegend::GetNextValue (
    TCHAR*& pszNext,
    DOUBLE& rdValue )
{
    HRESULT hr = NOERROR;
    TCHAR   szValue[MAX_PATH];
    INT     iDataLen;
    INT     iLen;

    VARIANT vValue;
    
    rdValue = -1;

    iDataLen = wcscspn (pszNext, L"\t");

    iLen = min ( iDataLen, MAX_COL_CHARS );

    lstrcpyn ( szValue, pszNext, iLen + 1 );

    szValue[iLen] = L'\0';

    VariantInit( &vValue );
    vValue.vt = VT_BSTR;

    vValue.bstrVal = SysAllocString ( szValue );
    hr = VariantChangeTypeEx( &vValue, &vValue, LCID_SCRIPT, VARIANT_NOUSEROVERRIDE, VT_R8 );

    if ( SUCCEEDED(hr) ) {
        rdValue = vValue.dblVal;
    }

    pszNext += iDataLen + 1  ;
    VariantClear( &vValue );

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\iviewobj.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    iviewobj.cpp

Abstract:

    Implementation of the IViewObject interface.

--*/

#include "polyline.h"
#include "unihelpr.h"
#include "unkhlpr.h"

/*
 * CImpIViewObject interface implementation
 */

 IMPLEMENT_CONTAINED_INTERFACE(CPolyline, CImpIViewObject)

/*
 * CImpIViewObject::Draw
 *
 * Purpose:
 *  Draws the object on the given hDC specifically for the requested
 *  aspect, device, and within the appropriate bounds.
 *
 * Parameters:
 *  dwAspect        DWORD aspect to draw.
 *  lindex          LONG index of the piece to draw.
 *  pvAspect        LPVOID for extra information, always NULL.
 *  ptd             DVTARGETDEVICE * containing device
 *                  information.
 *  hICDev          HDC containing the IC for the device.
 *  hDC             HDC on which to draw.
 *  pRectBounds     LPCRECTL describing the rectangle in which
 *                  to draw.
 *  pRectWBounds    LPCRECTL describing the placement rectangle
 *                  if part of what you draw is another metafile.
 *  pfnContinue     Function to call periodically during
 *                  long repaints.
 *  dwContinue      DWORD extra information to pass to the
 *                  pfnContinue.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIViewObject::Draw(
    DWORD dwAspect, 
    LONG lindex, 
    LPVOID pvAspect, 
    DVTARGETDEVICE *ptd, 
    HDC hICDev, 
    HDC hDC, 
    LPCRECTL pRectBounds, 
    LPCRECTL pRectWBounds, 
    BOOL (CALLBACK *pfnContinue) (DWORD_PTR), 
    DWORD_PTR dwContinue )
{
    HRESULT hr = NOERROR;
    RECT    rc;
    RECTL   rectBoundsDP;
    BOOL    bMetafile = FALSE;
    BOOL    bDeleteDC = FALSE;
    HDC     hLocalICDev;

    //Delegate iconic and printed representations.
    if (!((DVASPECT_CONTENT | DVASPECT_THUMBNAIL) & dwAspect)) {
        hr = m_pObj->m_pDefIViewObject->Draw(dwAspect, lindex
            , pvAspect, ptd, hICDev, hDC, pRectBounds, pRectWBounds
            , pfnContinue, dwContinue);
    } else {

        if ( NULL == hDC ) {
            hr = E_INVALIDARG;
        } else if ( NULL == pRectBounds ) {
            hr = E_POINTER;
        } else {
            if (hICDev == NULL) {
                hLocalICDev = CreateTargetDC(hDC, ptd);
                bDeleteDC = (hLocalICDev != hDC );
            } else {
                hLocalICDev = hICDev;
            }
            if ( NULL == hLocalICDev ) {
                hr = E_UNEXPECTED;
            } else {

                rectBoundsDP = *pRectBounds;
                bMetafile = GetDeviceCaps(hDC, TECHNOLOGY) == DT_METAFILE;
    
                if (!bMetafile) {
                    ::LPtoDP ( hLocalICDev, (LPPOINT)&rectBoundsDP, 2);
                    SaveDC ( hDC );
                }

                RECTFROMRECTL(rc, rectBoundsDP);
    
                m_pObj->Draw(hDC, hLocalICDev, FALSE, TRUE, &rc);

                if (bDeleteDC)
                    ::DeleteDC(hLocalICDev);
                if (!bMetafile)
                    RestoreDC(hDC, -1);
    
                hr = NOERROR;
            }
        }
    }
    return hr;
}




/*
 * CImpIViewObject::GetColorSet
 *
 * Purpose:
 *  Retrieves the color palette used by the object.
 *
 * Parameters:
 *  dwAspect        DWORD aspect of interest.
 *  lindex          LONG piece of interest.
 *  pvAspect        LPVOID with extra information, always NULL.
 *  ptd             DVTARGETDEVICE * containing device info.
 *  hICDev          HDC containing the IC for the device.
 *  ppColorSet      LPLOGPALETTE * into which to return the
 *                  pointer to the palette in this color set.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIViewObject::GetColorSet(
    DWORD, // dwDrawAspect
    LONG, // lindex 
    LPVOID, // pvAspect, 
    DVTARGETDEVICE *, // ptd
    HDC,  // hICDev, 
    LPLOGPALETTE * /* ppColorSet */) {
    return ResultFromScode(E_NOTIMPL);
    }


/*
 * CImpIViewObject::Freeze
 *
 * Purpose:
 *  Freezes the view of a particular aspect such that data
 *  changes do not affect the view.
 *
 * Parameters:
 *  dwAspect        DWORD aspect to freeze.
 *  lindex          LONG piece index under consideration.
 *  pvAspect        LPVOID for further information, always NULL.
 *  pdwFreeze       LPDWORD in which to return the key.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIViewObject::Freeze(DWORD dwAspect, LONG lindex
    , LPVOID pvAspect, LPDWORD pdwFreeze)
    {
    //Delegate anything for ICON or DOCPRINT aspects
    if (!((DVASPECT_CONTENT | DVASPECT_THUMBNAIL) & dwAspect))
        {
        return m_pObj->m_pDefIViewObject->Freeze(dwAspect, lindex
            , pvAspect, pdwFreeze);
        }

    if (dwAspect & m_pObj->m_dwFrozenAspects)
        {
        *pdwFreeze=dwAspect + FREEZE_KEY_OFFSET;
        return ResultFromScode(VIEW_S_ALREADY_FROZEN);
        }

    m_pObj->m_dwFrozenAspects |= dwAspect;

    if (NULL!=pdwFreeze)
        *pdwFreeze=dwAspect + FREEZE_KEY_OFFSET;

    return NOERROR;
    }



/*
 * CImpIViewObject::Unfreeze
 *
 * Purpose:
 *  Thaws an aspect frozen in ::Freeze.  We expect that a container
 *  will redraw us after freezing if necessary, so we don't send
 *  any sort of notification here.
 *
 * Parameters:
 *  dwFreeze        DWORD key returned from ::Freeze.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIViewObject::Unfreeze(DWORD dwFreeze)
    {
    DWORD       dwAspect=dwFreeze - FREEZE_KEY_OFFSET;

    //Delegate anything for ICON or DOCPRINT aspects
    if (!((DVASPECT_CONTENT | DVASPECT_THUMBNAIL) & dwAspect))
        m_pObj->m_pDefIViewObject->Unfreeze(dwFreeze);

    //The aspect to unfreeze is in the key.
    m_pObj->m_dwFrozenAspects &= ~(dwAspect);

    /*
     * Since we always kept our current data up to date, we don't
     * have to do anything thing here like requesting data again.
     * Because we removed dwAspect from m_dwFrozenAspects, Draw
     * will again use the current data.
     */

    return NOERROR;
    }


    
/*
 * CImpIViewObject::SetAdvise
 *
 * Purpose:
 *  Provides an advise sink to the view object enabling
 *  notifications for a specific aspect.
 *
 * Parameters:
 *  dwAspects       DWORD describing the aspects of interest.
 *  dwAdvf          DWORD containing advise flags.
 *  pIAdviseSink    LPADVISESINK to notify.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIViewObject::SetAdvise(DWORD dwAspects, DWORD dwAdvf
    , LPADVISESINK pIAdviseSink)
    {
    //Pass anything with DVASPECT_ICON or _DOCPRINT to the handler.
    if (!((DVASPECT_CONTENT | DVASPECT_THUMBNAIL) & dwAspects))
        {
        m_pObj->m_pDefIViewObject->SetAdvise(dwAspects, dwAdvf
            , pIAdviseSink);
        }

    //We continue because dwAspects may have more than one in it.
    if (NULL!=m_pObj->m_pIAdviseSink)
        m_pObj->m_pIAdviseSink->Release();

    m_pObj->m_pIAdviseSink=pIAdviseSink;
    m_pObj->m_dwAdviseAspects=dwAspects;
    m_pObj->m_dwAdviseFlags=dwAdvf;

    if (NULL!=m_pObj->m_pIAdviseSink)
        m_pObj->m_pIAdviseSink->AddRef();

    return NOERROR;
    }




/*
 * CImpIViewObject::GetAdvise
 *
 * Purpose:
 *  Returns the last known IAdviseSink seen by ::SetAdvise.
 *
 * Parameters:
 *  pdwAspects      LPDWORD in which to store the last
 *                  requested aspects.
 *  pdwAdvf         LPDWORD in which to store the last
 *                  requested flags.
 *  ppIAdvSink      LPADVISESINK * in which to store the
 *                  IAdviseSink.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIViewObject::GetAdvise(LPDWORD pdwAspects
    , LPDWORD pdwAdvf, LPADVISESINK *ppAdvSink)
    {
    if (NULL != ppAdvSink) {

        *ppAdvSink = m_pObj->m_pIAdviseSink;

        if (m_pObj->m_pIAdviseSink != NULL)
            m_pObj->m_pIAdviseSink->AddRef();
    }

    if (NULL != pdwAspects)
        *pdwAspects = m_pObj->m_dwAdviseAspects;

    if (NULL != pdwAdvf)
        *pdwAdvf = m_pObj->m_dwAdviseFlags;

    return NOERROR;
    }




/*
 * CImpIViewObject::GetExtent
 *
 * Purpose:
 *  Retrieves the extents of the object's display.
 *
 * Parameters:
 *  dwAspect        DWORD of the aspect of interest.
 *  lindex          LONG index of the piece of interest.
 *  ptd             DVTARGETDEVICE * with device information.
 *  pszl            LPSIZEL to the structure in which to return
 *                  the extents.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error value.
 */

STDMETHODIMP CImpIViewObject::GetExtent(DWORD dwAspect, LONG lindex
    , DVTARGETDEVICE *ptd, LPSIZEL pszl)
    {
    RECT            rc;

    if (!(DVASPECT_CONTENT & dwAspect))
        {
        return m_pObj->m_pDefIViewObject->GetExtent(dwAspect
            , lindex, ptd, pszl);
        }

    m_pObj->m_pImpIPolyline->RectGet(&rc);
    m_pObj->RectConvertMappings(&rc, FALSE);

    pszl->cx=rc.right-rc.left;
    pszl->cy=rc.bottom-rc.top;

    return NOERROR;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\logfiles.h ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    logfiles.h

Abstract:

    Header file for the implementation of the CImpILogFiles 
    and CImpIEnumLogFile objects.

--*/

#ifndef _LOGFILES_H_
#define _LOGFILES_H_

class CPolyline;
class CLogFileItem;

class CImpILogFiles : public ILogFiles
{
  public:

	CImpILogFiles(CPolyline*, LPUNKNOWN);
	~CImpILogFiles();

    /* IUnknown methods */
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)	(UINT *pctinfo);

    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);

    STDMETHOD(GetIDsOfNames) (REFIID riid, OLECHAR **rgszNames,
     						  UINT cNames, LCID lcid, DISPID *rgdispid);

    STDMETHOD(Invoke) (DISPID dispidMember, REFIID riid, LCID lcid,WORD wFlags,
      				   DISPPARAMS *pdispparams, VARIANT *pvarResult,
      				   EXCEPINFO *pexcepinfo, UINT *puArgErr);

    /* LogFiles methods */
    STDMETHOD(get_Count) (long *pLong);
    STDMETHOD(get__NewEnum)	(IUnknown **ppIunk);
    STDMETHOD(get_Item) (VARIANT index, DILogFileItem **ppI);
    STDMETHOD(Add) (BSTR bstrLogFilePath, DILogFileItem **ppI);
    STDMETHOD(Remove) (VARIANT index);

protected:
	ULONG		m_cRef;
	CPolyline*	m_pObj;
    LPUNKNOWN   m_pUnkOuter;
    ULONG       m_uiItemCount;			
};

typedef CImpILogFiles *PCImpILogFiles;

// LogFile enumerator
class CImpIEnumLogFile : public IEnumVARIANT
{
public:
	CImpIEnumLogFile (VOID);
	HRESULT Init (CLogFileItem* pItem, INT cItems);

    // IUnknown methods
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

	// Enum methods
	STDMETHOD(Next) (ULONG cItems, VARIANT *varItems, ULONG *pcReturned);
	STDMETHOD(Skip) (ULONG cSkip);
	STDMETHOD(Reset) (VOID);
	STDMETHOD(Clone) (IEnumVARIANT **pIEnum);

private:
	DWORD		    m_cRef;
	CLogFileItem**  m_paLogFileItem;
	ULONG		    m_cItems;
	ULONG		    m_uCurrent;	
};

#endif //_LOGFILES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\logsrc.h ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    logsrc.h

Abstract:

    <abstract>

--*/

#ifndef _LOGSRC_H_
#define _LOGSRC_H_

#include <inole.h>
#include "isysmon.h"

//
// Persistant data structure
//

typedef struct {
    INT   m_nPathLength;
} LOGFILE_DATA;

class CSysmonControl;
class CImpIDispatch;

//
// LogFileItem Class
// 
class CLogFileItem : public ILogFileItem
{

public:
                CLogFileItem ( CSysmonControl *pCtrl );
        virtual ~CLogFileItem ( void );

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // ILogFileItem methods
        STDMETHODIMP    get_Path ( BSTR* ) ;

        // methods not exposed by ILogFileItem interface
        static HRESULT NullItemToStream(LPSTREAM pIStream, INT iVersMaj, INT iVersMin);

        HRESULT Initialize ( LPCTSTR pszPath, CLogFileItem** ppListHead );
        
        HRESULT SaveToPropertyBag ( 
                    IPropertyBag*,
                    INT iIndex,
                    INT iVersMaj, 
                    INT iVersMin );

        HRESULT SaveToStream(LPSTREAM pIStream, BOOL fWildCard, INT iVersMaj, INT iVersMin);
        CLogFileItem*   Next ( void );
        void            SetNext ( CLogFileItem* );

        LPCWSTR         GetPath ( void );

    private:
        
        class  CLogFileItem*    m_pNextItem;
        CSysmonControl* m_pCtrl;
        ULONG           m_cRef;
        CImpIDispatch*  m_pImpIDispatch;

        LPWSTR          m_szPath; 

};

typedef CLogFileItem* PCLogFileItem;

#endif // _LOGSRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\namenode.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    namenode.h

Abstract:

    <abstract>

--*/

#ifndef _NAMENODE_H_
#define _NAMENODE_H_

class CNamedNode
{
	friend class CNamedNodeList;

	protected:
		CNamedNode	*m_pnodeNext;

	public:
		CNamedNode() { m_pnodeNext = NULL; }
};

typedef CNamedNode *PCNamedNode;


//
// Class CNamedNodeList
//
class CNamedNodeList
{
	private:
		PCNamedNode	m_pnodeFirst;
		PCNamedNode m_pnodeLast;

	public:

		CNamedNodeList( void ) { m_pnodeFirst = m_pnodeLast = NULL; }

		BOOL FindByName ( LPCTSTR pszName, INT iNameOffset, PCNamedNode *ppnodeRet );
		void Add ( PCNamedNode pnodeNew, PCNamedNode pnodePos );
		void Remove ( PCNamedNode pnode );
		BOOL IsEmpty( void ) { return m_pnodeFirst == NULL; }
		CNamedNode *First ( void ) { return m_pnodeFirst; }
};

#endif //_NAMENODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\logfiles.cpp ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    logfiles.cpp

Abstract:

    Implementation of the ILogFiles interface

--*/

#include "polyline.h"
#include "unkhlpr.h"
#include "unihelpr.h"
#include "smonmsg.h"
#include "logsrc.h"
#include "logfiles.h"

extern ITypeLib *g_pITypeLib;

//Standard IUnknown implementation for contained interface
IMPLEMENT_CONTAINED_CONSTRUCTOR(CPolyline, CImpILogFiles)
IMPLEMENT_CONTAINED_DESTRUCTOR(CImpILogFiles)
IMPLEMENT_CONTAINED_ADDREF(CImpILogFiles)
IMPLEMENT_CONTAINED_RELEASE(CImpILogFiles)

STDMETHODIMP 
CImpILogFiles::QueryInterface (
    IN  REFIID riid, 
    OUT PPVOID ppv
    )
{
    HRESULT hr = E_POINTER;

    if ( NULL != ppv ) {
        *ppv=NULL;

        if (!(IID_IUnknown == riid || IID_ILogFiles == riid)) {
            hr = E_NOINTERFACE;
        } else {
            *ppv=(LPVOID)this;
            ((LPUNKNOWN)*ppv)->AddRef();

            hr = NOERROR;
        }
    }
    return hr;
}



STDMETHODIMP 
CImpILogFiles::GetTypeInfoCount (
    OUT UINT *pctInfo
    )
{
    HRESULT hr = E_POINTER;
    if ( NULL != pctInfo ) {

        *pctInfo = 1;
        hr = NOERROR;
    } 
    return hr;
}


STDMETHODIMP 
CImpILogFiles::GetTypeInfo (
    IN  UINT itInfo, 
    IN  LCID /* lcid */, 
    OUT ITypeInfo** ppITypeInfo
    )
{
    if (0 != itInfo)
        return TYPE_E_ELEMENTNOTFOUND;

    if (NULL == ppITypeInfo)
        return E_POINTER;

    *ppITypeInfo = NULL;

    //We ignore the LCID
    return g_pITypeLib->GetTypeInfoOfGuid(IID_ILogFiles, ppITypeInfo);
}


STDMETHODIMP 
CImpILogFiles::GetIDsOfNames (
    IN  REFIID riid,
    IN  OLECHAR **rgszNames, 
    IN  UINT cNames,
    IN  LCID /* lcid */,
    OUT DISPID *rgDispID
    )
{
    HRESULT     hr = E_POINTER;
    ITypeInfo  *pTI;

    if ( NULL != rgDispID 
            && NULL != rgszNames 
            && NULL != *rgszNames) {
        if (IID_NULL == riid) {
            hr = g_pITypeLib->GetTypeInfoOfGuid(IID_ILogFiles, &pTI);

            if ( SUCCEEDED ( hr ) ) {
                hr = DispGetIDsOfNames(pTI, rgszNames, cNames, rgDispID);
                pTI->Release();
            }
        } else {
            hr = DISP_E_UNKNOWNINTERFACE;
        }
    }
    return hr;
}



/*
 * CImpIDispatch::Invoke
 *
 * Purpose:
 *  Calls a method in the dispatch interface or manipulates a
 *  property.
 *
 * Parameters:
 *  dispID          DISPID of the method or property of interest.
 *  riid            REFIID reserved, must be IID_NULL.
 *  lcid            LCID of the locale.
 *  wFlags          USHORT describing the context of the invocation.
 *  pDispParams     DISPPARAMS * to the array of arguments.
 *  pVarResult      VARIANT * in which to store the result.  Is
 *                  NULL if the caller is not interested.
 *  pExcepInfo      EXCEPINFO * to exception information.
 *  puArgErr        UINT * in which to store the index of an
 *                  invalid parameter if DISP_E_TYPEMISMATCH
 *                  is returned.
 *
 * Return Value:
 *  HRESULT         NOERROR or a general error code.
 */

STDMETHODIMP 
CImpILogFiles::Invoke ( 
    IN  DISPID dispID, 
    IN  REFIID riid,
    IN  LCID /* lcid */, 
    IN  USHORT wFlags, 
    IN  DISPPARAMS *pDispParams,
    OUT VARIANT *pVarResult, 
    OUT EXCEPINFO *pExcepInfo, 
    OUT UINT *puArgErr
    )
{
    HRESULT     hr = DISP_E_UNKNOWNINTERFACE;
    ITypeInfo  *pTI = NULL;

    if ( IID_NULL == riid ) {

        hr = g_pITypeLib->GetTypeInfoOfGuid(IID_ILogFiles, &pTI);

        if (SUCCEEDED(hr)) {

            hr = pTI->Invoke(this, dispID, wFlags,
                             pDispParams, pVarResult, pExcepInfo, puArgErr);
            pTI->Release();
        }
    }
    return hr;
}


STDMETHODIMP
CImpILogFiles::get_Count (
    OUT LONG*   pLong )
{
    HRESULT hr = E_POINTER;

    if (pLong != NULL) {
        *pLong = m_pObj->m_pCtrl->NumLogFiles();
        hr = NOERROR;
    } 
    return hr;
}


STDMETHODIMP
CImpILogFiles::get__NewEnum (
    IUnknown **ppIunk
    )
{
    HRESULT hr = E_POINTER;
    CImpIEnumLogFile *pEnum;

    if ( NULL != ppIunk ) {
        *ppIunk = NULL;

        pEnum = new CImpIEnumLogFile;
        if ( NULL != pEnum ) {
            hr = pEnum->Init (
                    m_pObj->m_pCtrl->FirstLogFile(),
                    m_pObj->m_pCtrl->NumLogFiles() );
            if ( SUCCEEDED ( hr ) ) {
                pEnum->AddRef();    
                *ppIunk = pEnum;
                hr = NOERROR;
            } else {
                delete pEnum;
            }
        } else {
            return E_OUTOFMEMORY;
        }
    } 
    return hr;
}


STDMETHODIMP
CImpILogFiles::get_Item (
    IN  VARIANT varIndex, 
    OUT DILogFileItem **ppI
    )
{
    HRESULT hr = E_POINTER;
    VARIANT varLoc;
    INT iIndex = 0;
    INT i;
    CLogFileItem *pItem = NULL;

    if (ppI != NULL) {

        *ppI = NULL;

        // Try coercing index to I4
        VariantInit(&varLoc);
        hr = VariantChangeType(&varLoc, &varIndex, 0, VT_I4);
        if ( SUCCEEDED (hr) ) {
            // Verify index is in range
            iIndex = V_I4(&varLoc);
            if (iIndex < 1 || iIndex > m_pObj->m_pCtrl->NumLogFiles() ) {
                hr = DISP_E_BADINDEX;
            } else {
                // Traverse log file linked list to indexed item
                pItem = m_pObj->m_pCtrl->FirstLogFile (); 
                i = 1;
                while (i++ < iIndex && NULL != pItem ) {
                    pItem = pItem->Next();
                }

                // Something wrong with linked list!!
                if ( NULL == pItem )
                    hr = E_FAIL;
            }
        }    
        if ( SUCCEEDED (hr) ) {                        
            // Return counter's dispatch interface
            hr = pItem->QueryInterface(DIID_DILogFileItem, (PVOID*)ppI);
        }
    }
    return hr;
}


STDMETHODIMP
CImpILogFiles::Add (
    IN  BSTR bstrPath,
    OUT DILogFileItem **ppI
    )
{
    HRESULT hr = E_POINTER;
    eDataSourceTypeConstant eDataSourceType = sysmonCurrentActivity;
    PCLogFileItem pItem = NULL;

    USES_CONVERSION

    // Check data source type.  Only add log files 
    // when the data source is not sysmonLogFiles
    hr = m_pObj->m_pCtrl->get_DataSourceType ( eDataSourceType );
    
    if ( SUCCEEDED ( hr ) ) {
        if ( sysmonLogFiles != eDataSourceType ) {
            if ( NULL != ppI ) {
                *ppI = NULL;
                // If non-null log file path
                if ( NULL != bstrPath && 0 != bstrPath[0] ) {
                    hr = m_pObj->m_pCtrl->AddSingleLogFile(W2T(bstrPath), &pItem);
                    if ( SUCCEEDED ( hr ) ) {
                        hr = pItem->QueryInterface(DIID_DILogFileItem, (PVOID*)ppI);
                        pItem->Release();
                    }
                } else {
                    hr = E_INVALIDARG;
                }
            }
        } else {
            hr = SMON_STATUS_LOG_FILE_DATA_SOURCE;
        }
    }
    return hr;
}


STDMETHODIMP
CImpILogFiles::Remove (
    IN  VARIANT varIndex
    )
{
    HRESULT hr;
    eDataSourceTypeConstant eDataSourceType = sysmonCurrentActivity;
    DILogFileItem*  pDI = NULL;
    PCLogFileItem   pItem = NULL;

    // Check data source type.  Only remove log files 
    // when the data source is not sysmonLogFiles
    hr = m_pObj->m_pCtrl->get_DataSourceType ( eDataSourceType );
    
    if ( SUCCEEDED ( hr ) ) {
        if ( sysmonLogFiles != eDataSourceType ) {
            // Get interface to indexed item
            hr = get_Item(varIndex, &pDI);

            if ( SUCCEEDED ( hr ) ) {

                // Exchange Dispatch interface for direct one
                hr = pDI->QueryInterface(IID_ILogFileItem, (PVOID*)&pItem);
                pDI->Release();
                if ( SUCCEEDED ( hr ) ) {
                    assert ( NULL != pItem );

                    // Remove the item from the control's list.
                    m_pObj->m_pCtrl->RemoveSingleLogFile ( pItem );
            
                    // Release the temp interface
                    pItem->Release();
                }        
            } else {
                hr = SMON_STATUS_LOG_FILE_DATA_SOURCE;
            }
        }
    }
    return hr;
}


CImpIEnumLogFile::CImpIEnumLogFile (
    void )
    :   m_cItems ( 0 ),
        m_uCurrent ( 0 ),
        m_cRef ( 0 ),
        m_paLogFileItem ( NULL )
{
    return;
}


HRESULT
CImpIEnumLogFile::Init (    
    PCLogFileItem   pLogFileItem,
    INT             cItems )
{
    HRESULT hr = NOERROR;
    INT i;

    if ( cItems > 0 ) {
        m_cItems = cItems;
        m_paLogFileItem = (PCLogFileItem*)malloc(sizeof(PCLogFileItem) * cItems);

        if ( NULL != m_paLogFileItem  ) {
            for (i=0; i<cItems; i++) {
                m_paLogFileItem[i] = pLogFileItem;
                pLogFileItem = pLogFileItem->Next();
            }
        } else {
            hr = E_OUTOFMEMORY;
        }
    } // No error if cItems <= 0
    return hr;
}

    

STDMETHODIMP
CImpIEnumLogFile::QueryInterface (
    IN  REFIID riid, 
    OUT PVOID *ppv
    )
{
    HRESULT hr = E_POINTER;

    if ( NULL != ppv ) {
        if ((riid == IID_IUnknown) || (riid == IID_IEnumVARIANT)) {
            *ppv = this;
            AddRef();
            hr = NOERROR;
        } else {
            *ppv = NULL;
            hr = E_NOINTERFACE;
        }
    }
    return hr;
}


STDMETHODIMP_(ULONG)
CImpIEnumLogFile::AddRef (
    VOID
    )
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG)
CImpIEnumLogFile::Release(
    VOID
    )
{
    if (--m_cRef == 0) {

        if (m_paLogFileItem != NULL)
            free(m_paLogFileItem);

        delete this;
        return 0;
    }

    return m_cRef;
}


STDMETHODIMP
CImpIEnumLogFile::Next(
    IN  ULONG cItems,
    OUT VARIANT *varItem,
    OUT ULONG *pcReturned)
{
    HRESULT hr = E_POINTER;

    ULONG i;
    ULONG cRet;

    if ( NULL != varItem ) {
        hr = NOERROR;

        // Clear the return variants
        for (i = 0; i < cItems; i++)
            VariantInit(&varItem[i]);

        // Try to fill the caller's array
        for (cRet = 0; cRet < cItems; cRet++) {

            // No more, return success with false
            if (m_uCurrent == m_cItems) {
                hr = S_FALSE;
                break;
            }

            // Get a dispatch interface for the item
            hr = m_paLogFileItem[m_uCurrent]->QueryInterface(DIID_DILogFileItem,
                                             (PVOID*)&V_DISPATCH(&varItem[cRet]));
            if (FAILED(hr))
                break;

            V_VT(&varItem[cRet]) = VT_DISPATCH;

            m_uCurrent++;
        }

        // If failed, clear out the variants
        if (FAILED(hr)) {
            for (i = 0; i < cItems; i++)
                VariantClear(&varItem[i]);
            cRet = 0;
        }

        // If desired, return number of items fetched
        if (pcReturned != NULL)
          *pcReturned = cRet;
    }
    return hr;
}


/***
*HRESULT CEnumPoint::Skip(unsigned long)
*Purpose:
*  Attempt to skip over the next 'celt' elements in the enumeration
*  sequence.
*
*Entry:
*  celt = the count of elements to skip
*
*Exit:
*  return value = HRESULT
*    S_OK
*    S_FALSE -  the end of the sequence was reached
*
***********************************************************************/
STDMETHODIMP
CImpIEnumLogFile::Skip(
    IN  ULONG   cItems
    )
{
    m_uCurrent += cItems;

    if (m_uCurrent > m_cItems)
        m_uCurrent = m_cItems;

    return (m_uCurrent == m_cItems) ? S_FALSE : S_OK;
}


/***
*HRESULT CEnumPoint::Reset(void)
*Purpose:
*  Reset the enumeration sequence back to the beginning.
*
*Entry:
*  None
*
*Exit:
*  return value = SHRESULT CODE
*    S_OK
*
***********************************************************************/
STDMETHODIMP
CImpIEnumLogFile::Reset(
    VOID
    )
{
    m_uCurrent = 0;

    return S_OK; 
}


/***
*HRESULT CEnumPoint::Clone(IEnumVARIANT**)
*Purpose:
*  Retrun a CPoint enumerator with exactly the same state as the
*  current one.
*
*Entry:
*  None
*
*Exit:
*  return value = HRESULT
*    S_OK
*    E_OUTOFMEMORY
*
***********************************************************************/
STDMETHODIMP
CImpIEnumLogFile::Clone (
    OUT IEnumVARIANT **ppEnum
    )
{
    HRESULT hr = E_POINTER;
    ULONG   i;
    CImpIEnumLogFile *pNewEnum;

    if ( NULL != ppEnum ) {
        *ppEnum = NULL;

        // Create new enumerator
        pNewEnum = new CImpIEnumLogFile;
        if ( NULL != pNewEnum ) {
            // Init, copy item list and current position
            pNewEnum->m_cItems = m_cItems;
            pNewEnum->m_uCurrent = m_uCurrent;
            pNewEnum->m_paLogFileItem = (PCLogFileItem*)malloc(sizeof(PCLogFileItem) * m_cItems);

            if ( NULL != pNewEnum->m_paLogFileItem ) {
                for (i=0; i<m_cItems; i++) {
                    pNewEnum->m_paLogFileItem[i] = m_paLogFileItem[i];
                }

                *ppEnum = pNewEnum;

                hr = NOERROR;
            } else {
                delete pNewEnum;
                hr = E_OUTOFMEMORY;
            }
        } else {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\owndraw.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    owndraw.h

Abstract:

    Helper macros for owner draw controls.

--*/

#define DIWindow(lpDI)              \
   (lpDI->hwndItem)

#define DIIndex(lpDI)               \
   (lpDI->itemID)

#define DIEntire(lpDI)              \
   (lpDI->itemAction & ODA_DRAWENTIRE)

#define DIFocusChanged(lpDI)        \
   (lpDI->itemAction & ODA_FOCUS)

#define DISelectionChanged(lpDI)    \
   (lpDI->itemAction & ODA_SELECT)

#define DISelected(lpDI)            \
   (lpDI->itemState & ODS_SELECTED)

#define DIDisabled(lpDI)            \
   (lpDI->itemState & ODS_DISABLED)

#define DIFocus(lpDI)               \
   (lpDI->itemState & ODS_FOCUS)




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\logsrc.cpp ===
/*++

Copyright (C) 1996-2000 Microsoft Corporation

Module Name:

    logsrc.cpp

Abstract:

    <abstract>

--*/

#include "polyline.h"
#include "unihelpr.h"
#include "logsrc.h"

// Construction/Destruction
CLogFileItem::CLogFileItem (
    CSysmonControl  *pCtrl )
:   m_cRef ( 0 ),
    m_pCtrl ( pCtrl ),
    m_pImpIDispatch ( NULL ),
    m_pNextItem ( NULL ),
    m_szPath ( NULL )
/*++

Routine Description:

    Constructor for the CLogFileItem class. It initializes the member variables.

Arguments:

    None.

Return Value:

    None.

--*/
{
    return;
}


CLogFileItem::~CLogFileItem (
    VOID
)
/*++

Routine Description:

    Destructor for the CLogFileItem class. It frees any objects, storage, and
    interfaces that were created. If the item is part of a query it is removed
    from the query.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if ( NULL != m_szPath ) 
        delete m_szPath;
    
    if ( NULL != m_pImpIDispatch )
        delete m_pImpIDispatch;
}


HRESULT
CLogFileItem::Initialize (
    LPCTSTR pszPath,
    CLogFileItem** pListHead )
{
    HRESULT hr = E_POINTER;
    WCHAR*  pszNewPath = NULL;

    USES_CONVERSION

    if ( NULL != pszPath ) {
        if ( _T('\0') != (TCHAR)(*pszPath) ) {
            pszNewPath = new WCHAR [lstrlen(pszPath) + 1];
            if ( NULL != pszNewPath ) {
                lstrcpyW ( pszNewPath, T2W(pszPath) );
                m_szPath = pszNewPath;
                hr = S_OK;
            } else {
                hr =  E_OUTOFMEMORY;
            }
        } else {
            hr = E_INVALIDARG;
        }
    } 

    if ( SUCCEEDED ( hr ) ) {
        m_pNextItem = *pListHead;
        *pListHead = this;
    }
    return hr;
}
HRESULT
CLogFileItem::SaveToStream (
    IN LPSTREAM pIStream,
    IN BOOL, // fWildCard,
    IN INT      iVersMaj, 
    IN INT // iVersMin 
    )
/*++

Routine Description:

    SaveToStream writes the log source's properties to the provided stream.

Arguments:

    pIStream - Pointer to stream interface

Return Value:

    HRESULT - S_OK or stream error

--*/
{
    HRESULT hr = NOERROR;

    // TodoLogFiles: Wildcard support
    
    if ( SMONCTRL_MAJ_VERSION == iVersMaj ) {
        LOGFILE_DATA ItemData;

        // Move properties to storage structure

        ItemData.m_nPathLength = lstrlen(m_szPath);
        assert ( 0 < ItemData.m_nPathLength );
        
        // Write structure to stream
        hr = pIStream->Write(&ItemData, sizeof(ItemData), NULL);
        if (FAILED(hr))
            return hr;

        // Write path name to stream
        hr = pIStream->Write(m_szPath, ItemData.m_nPathLength*sizeof(WCHAR), NULL);
        if (FAILED(hr))
            return hr;
    }    
    return S_OK;
}

HRESULT
CLogFileItem::NullItemToStream (
    IN LPSTREAM pIStream,
    IN INT,// iVersMaj, 
    IN INT // iVersMin
    )
/*++

Routine Description:

    NulItemToStream writes a log file item structiure with a 0 path length
    to the stream. This is used to marked the end of the log file data in
    the control's saved state.

Arguments:

    pIStream - Pointer to stream interface

Return Value:

    HRESULT - S_OK or stream error

--*/
{
    LOGFILE_DATA ItemData;

    // Zero path length, other fields needn't be initialized
    ItemData.m_nPathLength = 0;

    // Write structure to stream
    return pIStream->Write(&ItemData, sizeof(ItemData), NULL);
}

HRESULT
CLogFileItem::SaveToPropertyBag (
    IN IPropertyBag* pIPropBag,
    IN INT iIndex,
    IN INT, // iVersMaj, 
    IN INT // iVersMin 
    )
/*++

Routine Description:

    SaveToPropertyBag writes the log file item's properties to the provided
    property bag interface. 

Arguments:

    pIPropBag - Pointer to property bag interface
    fWildCard
    iVersMaj
    iVersMin

Return Value:

    HRESULT - S_OK or property bag error

--*/
{
    HRESULT hr = S_OK;
    TCHAR   szPropertyName[20];
    DWORD   dwPropertyNameLength;
    LPTSTR  pszNext;

    USES_CONVERSION

    // TodoLogFiles: Wildcard support

    // Write properties

    // Write path name

    _stprintf ( szPropertyName, _T("%s%05d."), _T("LogFile"), iIndex );
    dwPropertyNameLength = lstrlen (szPropertyName); 

    pszNext = szPropertyName + dwPropertyNameLength;
    lstrcpy ( pszNext, _T("Path") );
    
    hr = StringToPropertyBag (
            pIPropBag,
            szPropertyName,
            m_szPath );

    return hr;
}


/*
 * CLogFileItem::QueryInterface
 * CLogFileItem::AddRef
 * CLogFileItem::Release
 */

STDMETHODIMP CLogFileItem::QueryInterface(REFIID riid
    , LPVOID *ppv)
{
    HRESULT hr = NOERROR;

    if ( NULL != ppv ) {
        *ppv = NULL;
        if (riid == IID_ILogFileItem || riid == IID_IUnknown) {
            *ppv = this;
        } else if (riid == DIID_DILogFileItem) {
            if (m_pImpIDispatch == NULL) {
                m_pImpIDispatch = new CImpIDispatch(this, this);
                if ( NULL != m_pImpIDispatch ) {
                    m_pImpIDispatch->SetInterface(DIID_DILogFileItem, this);
                    *ppv = m_pImpIDispatch;
                } else {
                    hr = E_OUTOFMEMORY;
                }
            } else {
                *ppv = m_pImpIDispatch;
            }
        } else {
            hr = E_NOINTERFACE;
        }

        if ( SUCCEEDED ( hr ) ) {
            ((LPUNKNOWN)*ppv)->AddRef();
        }
    } else {
        hr = E_POINTER;
    }
    return hr;
}

STDMETHODIMP_(ULONG) CLogFileItem::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CLogFileItem::Release(void)
{
    if ( 0 == --m_cRef ) {
        delete this;
        return 0;
    }

    return m_cRef;
}



STDMETHODIMP CLogFileItem::get_Path (
    OUT BSTR* pstrPath
    )
{
    HRESULT hr = E_POINTER;

    if ( NULL != pstrPath ) {
        *pstrPath = SysAllocString ( m_szPath );

        if ( NULL == *pstrPath ) {
            hr = E_OUTOFMEMORY;
        } else {
            hr = NOERROR;
        }
    }
    return hr;
}

CLogFileItem*
CLogFileItem::Next (
    void )
{
    return m_pNextItem;
}

void 
CLogFileItem::SetNext (
    CLogFileItem* pNext )
{
    m_pNextItem = pNext;
}

LPCWSTR 
CLogFileItem::GetPath (
    void )
{
    return m_szPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\namenode.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    namenode.cpp

Abstract:

    Implements the named data node list.

--*/

#include "wtypes.h"
#include "namenode.h"

BOOL
CNamedNodeList::FindByName (
    IN  LPCTSTR      pszName,
    IN  INT          iNameOffset,
    OUT PCNamedNode *ppnodeRet 
    )
{
    PCNamedNode pnodePrev = NULL;
    PCNamedNode pnode = m_pnodeFirst;
    INT iStat = 1;

    // search til match or insertion position found
    while (pnode != NULL && (iStat = lstrcmpi(pszName, (LPCTSTR)((CHAR*)pnode + iNameOffset))) > 0) {
        pnodePrev = pnode;
        pnode = pnode->m_pnodeNext;
    }

    // if match, return matched node
    if (iStat == 0) {
        *ppnodeRet = pnode;
        return TRUE;
    }
    // else return insertion point
    else {
        *ppnodeRet = pnodePrev;
        return FALSE;
    }
}

void
CNamedNodeList::Add (
    IN PCNamedNode pnodeNew,
    IN PCNamedNode pnodePos
    )
{
    // if position specified, insert after it
    if (pnodePos != NULL) {
        pnodeNew->m_pnodeNext = pnodePos->m_pnodeNext;
        pnodePos->m_pnodeNext = pnodeNew;
        if (pnodePos == m_pnodeLast)
            m_pnodeLast = pnodeNew;
    }
    // else place first in list
    else if (m_pnodeFirst != NULL) {
        pnodeNew->m_pnodeNext = m_pnodeFirst;
        m_pnodeFirst = pnodeNew;
    }
    else {
        m_pnodeFirst = pnodeNew;
        m_pnodeLast = pnodeNew;
    }
}


void
CNamedNodeList::Remove (
    IN PCNamedNode pnode
    )
{
    PCNamedNode pnodePrev = NULL;
    PCNamedNode pnodeTemp = m_pnodeFirst;

    while (pnodeTemp != NULL && pnodeTemp != pnode) {
        pnodePrev = pnodeTemp;
        pnodeTemp = pnodeTemp->m_pnodeNext;
    }

    if (pnodeTemp == NULL)
        return;

    if (pnodePrev)
        pnodePrev->m_pnodeNext  = pnode->m_pnodeNext;
    else
        m_pnodeFirst = pnode->m_pnodeNext;

    if (pnode == m_pnodeLast)
        m_pnodeLast = pnodePrev;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\polyline.h ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    polyline.h

Abstract:

    Definitions and function prototypes

--*/

#ifndef _POLYLINE_H_
#define _POLYLINE_H_

#define GUIDS_FROM_TYPELIB

#include "inole.h"
#include "isysmon.h"  //From MKTYPLIB
// *** TodoMultiLogHandle:  Temporary pdh.h include.  Remove when trace file post-processing supports multiple
// open files.
#include <pdh.h>
#include <objsafe.h>

//Prevent duplicate definition of IPolylineAdviseSink10 in ipoly10.h
#define OMIT_POLYLINESINK
#include "ipoly10.h"


//Forward class references
class CImpIPolyline;
typedef class CImpIPolyline *PCImpIPolyline;

class CPolyline;
typedef class CPolyline *PCPolyline;

class CImpIObjectSafety;
typedef class CImpIObjectSafety* PCImpIObjectSafety;

class CImpIPersistStorage;
typedef class CImpIPersistStorage *PCImpIPersistStorage;

class CImpIPersistStreamInit;
typedef class CImpIPersistStreamInit *PCImpIPersistStreamInit;

class CImpIPersistPropertyBag;
typedef class CImpIPersistPropertyBag *PCImpIPersistPropertyBag;

class CImpIPerPropertyBrowsing;
typedef class CImpIPerPropertyBrowsing *PCImpIPerPropertyBrowsing;

class CImpIDataObject;
typedef class CImpIDataObject *PCImpIDataObject;

class CImpIOleObject;
typedef class CImpIOleObject *PCImpIOleObject;

class CImpIViewObject;
typedef class CImpIViewObject *PCImpIViewObject;

class CImpIRunnableObject;
typedef class CImpIRunnableObject *PCImpIRunnableObject;

class CImpIExternalConnection;
typedef class CImpIExternalConnection *PCImpIExternalConnection;

class CImpIOleInPlaceObject;
typedef class CImpIOleInPlaceObject *PCImpIOleInPlaceObject;

class CImpIOleInPlaceActiveObject;
typedef class CImpIOleInPlaceActiveObject *PCImpIOleInPlaceActiveObject;

class CImpISpecifyPP;
typedef CImpISpecifyPP *PCImpISpecifyPP;

class CImpIProvideClassInfo;
typedef CImpIProvideClassInfo *PCImpIProvideClassInfo;

class CImpIDispatch;
typedef CImpIDispatch *PCImpIDispatch;

class CImpISystemMonitor;
typedef CImpISystemMonitor *PCImpISystemMonitor;

class CImpIOleControl;
typedef CImpIOleControl *PCImpIOleControl;

class CAdviseRouter;
typedef CAdviseRouter *PCAdviseRouter;

class CGraphItem;
typedef CGraphItem *PCGraphItem;

#include "resource.h"
#include "cntrtree.h"
#include "iconnpt.h"

#include "stepper.h"
#include "graph.h"
#include "scale.h"
#include "grphitem.h"

#include "report.h"
#include "grphdsp.h"
#include "legend.h"
#include "smonctrl.h"

#include "globals.h"
#include "winhelpr.h"
#include "utils.h"
#include "strids.h"
#include "hatchwnd.h"
#include "logfiles.h"
#include "counters.h"

#define LCID_SCRIPT   0x0409

//Stream Name that holds the data
#define SZSTREAM                    OLESTR("CONTENTS")

//Magic number to add to aspects returned from IViewObject::Freeze
#define FREEZE_KEY_OFFSET           0x0723

#define HIMETRIC_PER_INCH           2540

#define ID_HATCHWINDOW              2000

//DLLPOLY.CPP
INT PASCAL LibMain(HINSTANCE, WORD, WORD, LPSTR);
     
//This class factory object creates Polyline objects.

class CPolylineClassFactory : public IClassFactory
    {
    protected:
        ULONG           m_cRef;

    public:
        CPolylineClassFactory(void);
        virtual ~CPolylineClassFactory(void);

        //IUnknown members
        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

typedef CPolylineClassFactory *PCPolylineClassFactory;


//POLYWIN.CPP
LRESULT APIENTRY PolylineWndProc(HWND, UINT, WPARAM, LPARAM);


#ifdef WIN32
#define PROP_POINTER    TEXT("Pointer")
#else
#define PROP_SELECTOR   "Selector"
#define PROP_OFFSET     "Offset"
#endif

 // Polyline Class
class CPolyline : public IUnknown
{
//    friend LRESULT APIENTRY PolylineWndProc(HWND, UINT, WPARAM, LPARAM);
//    friend BOOL APIENTRY PolyDlgProc(HWND, UINT, WPARAM, LPARAM);
//  friend LRESULT APIENTRY GraphDispWndProc (HWND, UINT, WPARAM, LPARAM );
    friend LRESULT APIENTRY SysmonCtrlWndProc (HWND, UINT, WPARAM, LPARAM);

    friend class CImpIObjectSafety;
    friend class CImpIPolyline;
    friend class CImpIConnPtCont;
    friend class CImpIConnectionPoint;
    friend class CImpIPersistStorage;
    friend class CImpIPersistStreamInit;
    friend class CImpIPersistPropertyBag;
    friend class CImpIPerPropertyBrowsing;
    friend class CImpIDataObject;

    friend class CImpIOleObject;
    friend class CImpIViewObject;
    friend class CImpIRunnableObject;
    friend class CImpIExternalConnection;
    friend class CImpIOleInPlaceObject;
    friend class CImpIOleInPlaceActiveObject;
    friend class CSysmonControl;
    friend class CSysmonToolbar;
    friend class CGraphDisp;
    friend class CImpICounters;
    friend class CImpILogFiles;
    friend class CImpISpecifyPP;
    friend class CImpIProvideClassInfo;
    friend class CImpIDispatch;
    friend class CImpISystemMonitor;
    friend class CImpIOleControl;
    friend class CAdviseRouter;

    protected:
        ULONG           m_cRef;         //Object reference count
        LPUNKNOWN       m_pUnkOuter;    //Controlling Unknown
        PFNDESTROYED    m_pfnDestroy;   //Function called on closure
        BOOL            m_fDirty;       //Have we changed?
        GRAPHDATA       m_Graph;        //Graph data
        PSYSMONCTRL     m_pCtrl;        //Sysmon Control object
        RECT            m_RectExt;      //Extent rectangle

        //Contained interfaces
        PCImpIPolyline              m_pImpIPolyline;
        PCImpIConnPtCont            m_pImpIConnPtCont;
        PCImpIPersistStorage        m_pImpIPersistStorage;
        PCImpIPersistStreamInit     m_pImpIPersistStreamInit;
        PCImpIPersistPropertyBag    m_pImpIPersistPropertyBag;
        PCImpIPerPropertyBrowsing   m_pImpIPerPropertyBrowsing;
        PCImpIDataObject            m_pImpIDataObject;

        // Connection point holders (direct & dispatch)
        CImpIConnectionPoint    m_ConnectionPoint[CONNECTION_POINT_CNT]; 

        CLIPFORMAT      m_cf;           //Object clipboard format
        CLSID           m_clsID;        //Current CLSID

        //We have to hold these for IPersistStorage::Save
        LPSTORAGE       m_pIStorage;
        LPSTREAM        m_pIStream;

        LPDATAADVISEHOLDER  m_pIDataAdviseHolder;

        //These are default handler interfaces we use
        LPUNKNOWN           m_pDefIUnknown;
        LPVIEWOBJECT2       m_pDefIViewObject;
        LPPERSISTSTORAGE    m_pDefIPersistStorage;
        LPDATAOBJECT        m_pDefIDataObject;

        //Implemented and used interfaces
        PCImpIObjectSafety  m_pImpIObjectSafety;
        PCImpIOleObject     m_pImpIOleObject;       //Implemented
        LPOLEADVISEHOLDER   m_pIOleAdviseHolder;    //Used

        LPOLECLIENTSITE     m_pIOleClientSite;      //Used

        PCImpIViewObject    m_pImpIViewObject;      //Implemented
        LPADVISESINK        m_pIAdviseSink;         //Used
        DWORD               m_dwFrozenAspects;      //Freeze
        DWORD               m_dwAdviseAspects;      //SetAdvise
        DWORD               m_dwAdviseFlags;        //SetAdvise

        PCImpIRunnableObject m_pImpIRunnableObject; //Implemented
        BOOL                m_bIsRunning;           // Running?
        HWND                m_hDlg;                 //Editing window

        PCImpIExternalConnection m_pImpIExternalConnection; //Implemented
        BOOL                     m_fLockContainer;
        DWORD                    m_dwRegROT;


        LPOLEINPLACESITE            m_pIOleIPSite;
        LPOLEINPLACEFRAME           m_pIOleIPFrame;
        LPOLEINPLACEUIWINDOW        m_pIOleIPUIWindow;

        PCImpIOleInPlaceObject       m_pImpIOleIPObject;
        PCImpIOleInPlaceActiveObject m_pImpIOleIPActiveObject;

        HMENU                       m_hMenuShared;
        HOLEMENU                    m_hOLEMenu;

        PCHatchWin                  m_pHW;
        BOOL                        m_fAllowInPlace;
        BOOL                        m_fUIActive;
        BOOL                        m_fContainerKnowsInsideOut;

        PCImpISpecifyPP             m_pImpISpecifyPP;
        PCImpIProvideClassInfo      m_pImpIProvideClassInfo;
        PCImpIDispatch              m_pImpIDispatch;
        PCImpISystemMonitor         m_pImpISystemMonitor;
        PCImpIOleControl            m_pImpIOleControl;
        PCImpICounters              m_pImpICounters;
        PCImpILogFiles              m_pImpILogFiles;

        //Our own type lib for the object
        ITypeLib                   *m_pITypeLib;

        //From the container;
        IOleControlSite            *m_pIOleControlSite;
        IDispatch                  *m_pIDispatchAmbients;
        BOOL                        m_fFreezeEvents;
        CONTROLINFO                 m_ctrlInfo;

        //Other ambients
        BOOL                        m_fHatch;

    protected:
        void      PointScale(LPRECT, LPPOINTS, BOOL);
        void      Draw(HDC, HDC, BOOL, BOOL, LPRECT);
        void      SendAdvise(UINT);
        void      SendEvent(UINT, DWORD);
        void      RectConvertMappings(LPRECT, BOOL);

        /*
         * These members pulled from IPolyline now serve as a
         * central store for this functionality to be used from
         * other interfaces like IPersistStorage and IDataObject.
         * Other interfaces later may also use them.
         */
        STDMETHODIMP RenderBitmap(HBITMAP *, HDC hAttribDC);
        STDMETHODIMP RenderMetafilePict(HGLOBAL *, HDC hAttribDC);


    public:
        static RegisterWndClass(HINSTANCE hInst);

        CPolyline(LPUNKNOWN, PFNDESTROYED);
        virtual ~CPolyline(void);

        BOOL      Init(void);

        //Non-delegating object IUnknown
        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        HRESULT  InPlaceActivate(LPOLECLIENTSITE, BOOL);
        void     InPlaceDeactivate(void);
        HRESULT  UIActivate(void);
        void     UIDeactivate(void);


        BOOL     AmbientGet(DISPID, VARIANT *);
        void     AmbientsInitialize(DWORD);
    };

typedef CPolyline *PCPolyline;


//Codes for CPolyline::SendAdvise
//......Code.....................Method called in CPolyline::SendAdvise
#define OBJECTCODE_SAVED       0 //IOleAdviseHolder::SendOnSave
#define OBJECTCODE_CLOSED      1 //IOleAdviseHolder::SendOnClose
#define OBJECTCODE_RENAMED     2 //IOleAdviseHolder::SendOnRename
#define OBJECTCODE_SAVEOBJECT  3 //IOleClientSite::SaveObject
#define OBJECTCODE_DATACHANGED 4 //IDataAdviseHolder::SendOnDataChange
#define OBJECTCODE_SHOWWINDOW  5 //IOleClientSite::OnShowWindow(TRUE)
#define OBJECTCODE_HIDEWINDOW  6 //IOleClientSite::OnShowWindow(FALSE)
#define OBJECTCODE_SHOWOBJECT  7 //IOleClientSite::ShowObject


//Flags for AmbientsInitialize
enum
    {
    INITAMBIENT_SHOWHATCHING = 0x00000001,
    INITAMBIENT_UIDEAD       = 0x00000002,
    INITAMBIENT_BACKCOLOR    = 0x00000004,
    INITAMBIENT_FORECOLOR    = 0x00000008,
    INITAMBIENT_FONT         = 0x00000010,
    INITAMBIENT_APPEARANCE   = 0x00000020,
    INITAMBIENT_USERMODE     = 0x00000040,
    INITAMBIENT_ALL          = 0xFFFFFFFF
    };


//Interface implementation contained in the Polyline.

class CImpIPolyline : public IPolyline10
    {
    protected:
        ULONG               m_cRef;      //Interface reference count
        PCPolyline          m_pObj;      //Back pointer to object
        LPUNKNOWN           m_pUnkOuter; //Controlling unknown

    public:
        CImpIPolyline(PCPolyline, LPUNKNOWN);
        virtual ~CImpIPolyline(void);

        //IUnknown members.
        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //Manipulation members:
        STDMETHODIMP Init(HWND, LPRECT, DWORD, UINT);
        STDMETHODIMP New(void);
        STDMETHODIMP Undo(void);
        STDMETHODIMP Window(HWND *);

        STDMETHODIMP RectGet(LPRECT);
        STDMETHODIMP SizeGet(LPRECT);
        STDMETHODIMP RectSet(LPRECT, BOOL);
        STDMETHODIMP SizeSet(LPRECT, BOOL);
    };


class CImpIObjectSafety : public IObjectSafety
{
protected:
    ULONG        m_cRef;      //Interface reference count
    PCPolyline   m_pObj;      //Back pointer to object
    LPUNKNOWN    m_pUnkOuter; //Controlling unknown

private:
    BOOL         m_fMessageDisplayed;

    VOID SetupSecurityPolicy();
public:
    CImpIObjectSafety(PCPolyline, LPUNKNOWN);
    virtual ~CImpIObjectSafety(void);

    STDMETHODIMP QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP GetInterfaceSafetyOptions(REFIID riid,
                                           DWORD* pdwSupportedOptions,
                                           DWORD* pdwEnabledOptions);
    STDMETHODIMP SetInterfaceSafetyOptions(REFIID riid,
                                      DWORD dwOptionSetMask,
                                      DWORD dwEnabledOptions);
};

class CImpIPersistStorage : public IPersistStorage
    {
    protected:
        ULONG               m_cRef;      //Interface reference count
        PCPolyline          m_pObj;      //Back pointer to object
        LPUNKNOWN           m_pUnkOuter; //Controlling unknown
        PSSTATE             m_psState;   //Storage state

    public:
        CImpIPersistStorage(PCPolyline, LPUNKNOWN);
        virtual ~CImpIPersistStorage(void);

        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetClassID(LPCLSID);

        STDMETHODIMP IsDirty(void);
        STDMETHODIMP InitNew(LPSTORAGE);
        STDMETHODIMP Load(LPSTORAGE);
        STDMETHODIMP Save(LPSTORAGE, BOOL);
        STDMETHODIMP SaveCompleted(LPSTORAGE);
        STDMETHODIMP HandsOffStorage(void);
    };


//IPERSTMI.CPP
class CImpIPersistStreamInit : public IPersistStreamInit
    {
    protected:
        ULONG               m_cRef;      //Interface reference count
        PCPolyline          m_pObj;      //Back pointer to object
        LPUNKNOWN           m_pUnkOuter; //Controlling unknown

    public:
        CImpIPersistStreamInit(PCPolyline, LPUNKNOWN);
        virtual ~CImpIPersistStreamInit(void);

        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetClassID(LPCLSID);

        STDMETHODIMP IsDirty(void);
        STDMETHODIMP Load(LPSTREAM);
        STDMETHODIMP Save(LPSTREAM, BOOL);
        STDMETHODIMP GetSizeMax(ULARGE_INTEGER *);
        STDMETHODIMP InitNew(void);
    };

//IPERPBAG.CPP
class CImpIPersistPropertyBag : public IPersistPropertyBag
    {
    protected:
        ULONG               m_cRef;      //Interface reference count
        PCPolyline          m_pObj;      //Back pointer to object
        LPUNKNOWN           m_pUnkOuter; //Controlling unknown

    public:
        CImpIPersistPropertyBag(PCPolyline, LPUNKNOWN);
        virtual ~CImpIPersistPropertyBag(void);

        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetClassID(LPCLSID);

        STDMETHODIMP InitNew(void);
        STDMETHODIMP Load(IPropertyBag*, IErrorLog*);
        STDMETHODIMP Save(IPropertyBag*, BOOL, BOOL);
    };

//IPRPBRWS.CPP
class CImpIPerPropertyBrowsing : public IPerPropertyBrowsing
    {
    protected:
        ULONG               m_cRef;      //Interface reference count
        PCPolyline          m_pObj;      //Back pointer to object
        LPUNKNOWN           m_pUnkOuter; //Controlling unknown

    public:
        CImpIPerPropertyBrowsing(PCPolyline, LPUNKNOWN);
        virtual ~CImpIPerPropertyBrowsing(void);

        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetClassID(LPCLSID);

        STDMETHODIMP GetDisplayString( DISPID, BSTR* );
        STDMETHODIMP GetPredefinedStrings( DISPID, CALPOLESTR*, CADWORD* );
        STDMETHODIMP GetPredefinedValue( DISPID, DWORD, VARIANT* );
        STDMETHODIMP MapPropertyToPage( DISPID, CLSID* );
    };

//IDATAOBJ.CPP
class CImpIDataObject : public IDataObject
    {
    private:
        ULONG               m_cRef;      //Interface reference count
        PCPolyline          m_pObj;      //Back pointer to object
        LPUNKNOWN           m_pUnkOuter; //Controlling unknown

    public:
        CImpIDataObject(PCPolyline, LPUNKNOWN);
        virtual ~CImpIDataObject(void);

        //IUnknown members that delegate to m_pUnkOuter.
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IDataObject members
        STDMETHODIMP GetData(LPFORMATETC, LPSTGMEDIUM);
        STDMETHODIMP GetDataHere(LPFORMATETC, LPSTGMEDIUM);
        STDMETHODIMP QueryGetData(LPFORMATETC);
        STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC,LPFORMATETC);
        STDMETHODIMP SetData(LPFORMATETC, LPSTGMEDIUM, BOOL);
        STDMETHODIMP EnumFormatEtc(DWORD, LPENUMFORMATETC *);
        STDMETHODIMP DAdvise(LPFORMATETC, DWORD, LPADVISESINK
            , DWORD *);
        STDMETHODIMP DUnadvise(DWORD);
        STDMETHODIMP EnumDAdvise(LPENUMSTATDATA *);
    };



//IENUMFE.CPP
class CEnumFormatEtc : public IEnumFORMATETC
    {
    private:
        ULONG           m_cRef;
        LPUNKNOWN       m_pUnkRef;
        ULONG           m_iCur;
        ULONG           m_cfe;
        LPFORMATETC     m_prgfe;

    public:
        CEnumFormatEtc(LPUNKNOWN, ULONG, LPFORMATETC);
        virtual ~CEnumFormatEtc(void);

        //IUnknown members that delegate to m_pUnkRef.
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IEnumFORMATETC members
        STDMETHODIMP Next(ULONG, LPFORMATETC, ULONG *);
        STDMETHODIMP Skip(ULONG);
        STDMETHODIMP Reset(void);
        STDMETHODIMP Clone(IEnumFORMATETC **);
    };


typedef CEnumFormatEtc *PCEnumFormatEtc;


//Our own properties verb
#define POLYLINEVERB_PROPERTIES     1

class CImpIOleObject : public IOleObject
    {
    private:
        ULONG           m_cRef;
        PCPolyline      m_pObj;
        LPUNKNOWN       m_pUnkOuter;

    public:
        CImpIOleObject(PCPolyline, LPUNKNOWN);
        virtual ~CImpIOleObject(void);

        //IUnknown members that delegate to m_pUnkOuter.
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IOleObject members
        STDMETHODIMP SetClientSite(LPOLECLIENTSITE);
        STDMETHODIMP GetClientSite(LPOLECLIENTSITE *);
        STDMETHODIMP SetHostNames(LPCOLESTR, LPCOLESTR);
        STDMETHODIMP Close(DWORD);
        STDMETHODIMP SetMoniker(DWORD, LPMONIKER);
        STDMETHODIMP GetMoniker(DWORD, DWORD, LPMONIKER *);
        STDMETHODIMP InitFromData(LPDATAOBJECT, BOOL, DWORD);
        STDMETHODIMP GetClipboardData(DWORD, LPDATAOBJECT *);
        STDMETHODIMP DoVerb(LONG, LPMSG, LPOLECLIENTSITE, LONG
                         , HWND, LPCRECT);
        STDMETHODIMP EnumVerbs(LPENUMOLEVERB *);
        STDMETHODIMP Update(void);
        STDMETHODIMP IsUpToDate(void);
        STDMETHODIMP GetUserClassID(CLSID *);
        STDMETHODIMP GetUserType(DWORD, LPOLESTR *);
        STDMETHODIMP SetExtent(DWORD, LPSIZEL);
        STDMETHODIMP GetExtent(DWORD, LPSIZEL);
        STDMETHODIMP Advise(LPADVISESINK, DWORD *);
        STDMETHODIMP Unadvise(DWORD);
        STDMETHODIMP EnumAdvise(LPENUMSTATDATA *);
        STDMETHODIMP GetMiscStatus(DWORD, DWORD *);
        STDMETHODIMP SetColorScheme(LPLOGPALETTE);
    };


//IVIEWOBJ.CPP
class CImpIViewObject : public IViewObject2
    {
    private:
        ULONG           m_cRef;
        PCPolyline      m_pObj;
        LPUNKNOWN       m_pUnkOuter;

    public:
        CImpIViewObject(PCPolyline, LPUNKNOWN);
        virtual ~CImpIViewObject(void);

        //IUnknown members that delegate to m_pUnkOuter.
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IViewObject members
        STDMETHODIMP Draw(
            DWORD, 
            LONG, 
            LPVOID, 
            DVTARGETDEVICE *, 
            HDC, 
            HDC, 
            LPCRECTL, 
            LPCRECTL, 
            BOOL (CALLBACK *)(DWORD_PTR), 
            DWORD_PTR );

        STDMETHODIMP GetColorSet(DWORD, LONG, LPVOID
            , DVTARGETDEVICE *, HDC, LPLOGPALETTE *);
        STDMETHODIMP Freeze(DWORD, LONG, LPVOID, LPDWORD);
        STDMETHODIMP Unfreeze(DWORD);
        STDMETHODIMP SetAdvise(DWORD, DWORD, LPADVISESINK);
        STDMETHODIMP GetAdvise(LPDWORD, LPDWORD, LPADVISESINK *);
        STDMETHODIMP GetExtent(DWORD, LONG, DVTARGETDEVICE *
            , LPSIZEL);
    };


class CImpIRunnableObject : public IRunnableObject
    {
    protected:
        ULONG           m_cRef;
        PCPolyline      m_pObj;
        LPUNKNOWN       m_pUnkOuter;

    public:
        CImpIRunnableObject(PCPolyline, LPUNKNOWN);
        virtual ~CImpIRunnableObject(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetRunningClass(LPCLSID);
        STDMETHODIMP Run(LPBINDCTX);
        STDMETHODIMP_(BOOL) IsRunning(void);
        STDMETHODIMP LockRunning(BOOL, BOOL);
        STDMETHODIMP SetContainedObject(BOOL);
    };


class CImpIExternalConnection : public IExternalConnection
    {
    protected:
        ULONG           m_cRef;
        PCPolyline      m_pObj;
        LPUNKNOWN       m_pUnkOuter;
        DWORD           m_cLockStrong;

    public:
        CImpIExternalConnection(PCPolyline, LPUNKNOWN);
        virtual ~CImpIExternalConnection(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP_(DWORD) AddConnection(DWORD, DWORD);
        STDMETHODIMP_(DWORD) ReleaseConnection(DWORD, DWORD, BOOL);
    };



class CImpIOleInPlaceObject : public IOleInPlaceObject
    {
    protected:
        ULONG               m_cRef;
        PCPolyline          m_pObj;
        LPUNKNOWN           m_pUnkOuter;

    public:
        CImpIOleInPlaceObject(PCPolyline, LPUNKNOWN);
        virtual ~CImpIOleInPlaceObject(void);

        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetWindow(HWND *);
        STDMETHODIMP ContextSensitiveHelp(BOOL);
        STDMETHODIMP InPlaceDeactivate(void);
        STDMETHODIMP UIDeactivate(void);
        STDMETHODIMP SetObjectRects(LPCRECT, LPCRECT);
        STDMETHODIMP ReactivateAndUndo(void);
    };



class CImpIOleInPlaceActiveObject
    : public IOleInPlaceActiveObject
    {
    protected:
        ULONG               m_cRef;
        PCPolyline          m_pObj;
        LPUNKNOWN           m_pUnkOuter;

    public:
        CImpIOleInPlaceActiveObject(PCPolyline, LPUNKNOWN);
        virtual ~CImpIOleInPlaceActiveObject(void);

        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetWindow(HWND *);
        STDMETHODIMP ContextSensitiveHelp(BOOL);
        STDMETHODIMP TranslateAccelerator(LPMSG);
        STDMETHODIMP OnFrameWindowActivate(BOOL);
        STDMETHODIMP OnDocWindowActivate(BOOL);
        STDMETHODIMP ResizeBorder(LPCRECT, LPOLEINPLACEUIWINDOW
                         , BOOL);
        STDMETHODIMP EnableModeless(BOOL);
    };



class CImpISpecifyPP : public ISpecifyPropertyPages
    {
    protected:
        ULONG           m_cRef;      //Interface reference count
        PCPolyline      m_pObj;      //Backpointer to the object
        LPUNKNOWN       m_pUnkOuter; //For delegation

    public:
        CImpISpecifyPP(PCPolyline, LPUNKNOWN);
        virtual ~CImpISpecifyPP(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetPages(CAUUID *);
    };



class CImpIProvideClassInfo : public IProvideClassInfo
    {
    protected:
        ULONG           m_cRef;      //Interface reference count
        PCPolyline      m_pObj;      //Backpointer to the object
        LPUNKNOWN       m_pUnkOuter; //For delegation

    public:
        CImpIProvideClassInfo(PCPolyline, LPUNKNOWN);
        virtual ~CImpIProvideClassInfo(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetClassInfo(LPTYPEINFO *);
    };



class CImpIDispatch : public IDispatch
    {
    public:

    private:
        ULONG           m_cRef;     //For debugging
        LPUNKNOWN       m_pObj;
        LPUNKNOWN       m_pUnkOuter;
        LPUNKNOWN       m_pInterface;
        IID             m_DIID;
        ITypeInfo      *m_pITI;     //Type information

    public:
        CImpIDispatch(LPUNKNOWN, LPUNKNOWN);
        virtual ~CImpIDispatch(void);

        void SetInterface(REFIID, LPUNKNOWN);

        //IUnknown members that delegate to m_pUnkOuter.
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IDispatch members
        STDMETHODIMP GetTypeInfoCount(UINT *);
        STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **);
        STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID
            , DISPID *);
        STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD
            , DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);
    };


class CImpISystemMonitor : public ISystemMonitor
    {
    protected:
        ULONG               m_cRef;      //Interface reference count
        PCPolyline          m_pObj;      //Back pointer to object
        LPUNKNOWN           m_pUnkOuter; //Controlling unknown

    public:
        CImpISystemMonitor(PCPolyline, LPUNKNOWN);
        virtual ~CImpISystemMonitor(void);

        //IUnknown members.
        STDMETHODIMP QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //Manipulation members:
        STDMETHODIMP        put_Appearance(INT);
        STDMETHODIMP        get_Appearance(INT*);

        STDMETHODIMP        put_BackColor(OLE_COLOR);
        STDMETHODIMP        get_BackColor(OLE_COLOR*);

        STDMETHODIMP        put_BorderStyle(INT);
        STDMETHODIMP        get_BorderStyle(INT*);

        STDMETHODIMP        put_ForeColor(OLE_COLOR);
        STDMETHODIMP        get_ForeColor(OLE_COLOR*);

        STDMETHODIMP        put_BackColorCtl(OLE_COLOR);
        STDMETHODIMP        get_BackColorCtl(OLE_COLOR*);

        STDMETHODIMP        put_GridColor(OLE_COLOR);
        STDMETHODIMP        get_GridColor(OLE_COLOR*);

        STDMETHODIMP        put_TimeBarColor(OLE_COLOR);
        STDMETHODIMP        get_TimeBarColor(OLE_COLOR*);

        STDMETHODIMP        putref_Font(IFontDisp *pFont);
        STDMETHODIMP        get_Font(IFontDisp **ppFont);

        STDMETHODIMP        put_ShowVerticalGrid(VARIANT_BOOL);
        STDMETHODIMP        get_ShowVerticalGrid(VARIANT_BOOL*);

        STDMETHODIMP        put_ShowHorizontalGrid(VARIANT_BOOL);
        STDMETHODIMP        get_ShowHorizontalGrid(VARIANT_BOOL*);

        STDMETHODIMP        put_ShowLegend(VARIANT_BOOL);
        STDMETHODIMP        get_ShowLegend(VARIANT_BOOL*);

        STDMETHODIMP        put_ShowToolbar(VARIANT_BOOL);
        STDMETHODIMP        get_ShowToolbar(VARIANT_BOOL*);

        STDMETHODIMP        put_ShowValueBar(VARIANT_BOOL);
        STDMETHODIMP        get_ShowValueBar(VARIANT_BOOL*);

        STDMETHODIMP        put_ShowScaleLabels(VARIANT_BOOL);
        STDMETHODIMP        get_ShowScaleLabels(VARIANT_BOOL*);

        STDMETHODIMP        put_MaximumScale(INT);
        STDMETHODIMP        get_MaximumScale(INT*);

        STDMETHODIMP        put_MinimumScale(INT);
        STDMETHODIMP        get_MinimumScale(INT*);

        STDMETHODIMP        put_UpdateInterval(FLOAT);
        STDMETHODIMP        get_UpdateInterval(FLOAT*);

        STDMETHODIMP        put_DisplayFilter(INT);
        STDMETHODIMP        get_DisplayFilter(INT*);

        STDMETHODIMP        put_DisplayType(DisplayTypeConstants);
        STDMETHODIMP        get_DisplayType(DisplayTypeConstants*);

        STDMETHODIMP        put_ManualUpdate(VARIANT_BOOL);
        STDMETHODIMP        get_ManualUpdate(VARIANT_BOOL*);

        STDMETHODIMP        put_YAxisLabel(BSTR);
        STDMETHODIMP        get_YAxisLabel(BSTR*);

        STDMETHODIMP        put_GraphTitle(BSTR);
        STDMETHODIMP        get_GraphTitle(BSTR*);

        STDMETHODIMP        put_SqlDsnName(BSTR);
        STDMETHODIMP        get_SqlDsnName(BSTR*);
        STDMETHODIMP        put_SqlLogSetName(BSTR);
        STDMETHODIMP        get_SqlLogSetName(BSTR*);

        STDMETHODIMP        put_LogFileName(BSTR);
        STDMETHODIMP        get_LogFileName(BSTR*);

        STDMETHODIMP        get_LogFiles(ILogFiles**);

        STDMETHODIMP        put_DataSourceType(DataSourceTypeConstants);
        STDMETHODIMP        get_DataSourceType(DataSourceTypeConstants*);

        STDMETHODIMP        put_LogViewStart(DATE);
        STDMETHODIMP        get_LogViewStart(DATE*);

        STDMETHODIMP        put_LogViewStop(DATE);
        STDMETHODIMP        get_LogViewStop(DATE*);
        
        STDMETHODIMP        put_Highlight(VARIANT_BOOL);
        STDMETHODIMP        get_Highlight(VARIANT_BOOL*);

        STDMETHODIMP        put_ReadOnly(VARIANT_BOOL);
        STDMETHODIMP        get_ReadOnly(VARIANT_BOOL*);

        STDMETHODIMP        put_ReportValueType(ReportValueTypeConstants);
        STDMETHODIMP        get_ReportValueType(ReportValueTypeConstants*);

        STDMETHODIMP        put_MonitorDuplicateInstances(VARIANT_BOOL);
        STDMETHODIMP        get_MonitorDuplicateInstances(VARIANT_BOOL*);

        STDMETHODIMP        get_Counters(ICounters**);

        STDMETHODIMP        CollectSample(void);
        STDMETHODIMP        BrowseCounters(void);
        STDMETHODIMP        DisplayProperties(void);

        STDMETHODIMP        Counter(INT iIndex, ICounterItem**);
        STDMETHODIMP        AddCounter(BSTR bsPath, ICounterItem**);
        STDMETHODIMP        DeleteCounter(ICounterItem *pItem);

        STDMETHODIMP        LogFile ( INT iIndex, ILogFileItem** );
        STDMETHODIMP        AddLogFile ( BSTR bsPath, ILogFileItem** );
        STDMETHODIMP        DeleteLogFile ( ILogFileItem *pItem );

        STDMETHODIMP        UpdateGraph(void);
        STDMETHODIMP        Paste(void);
        STDMETHODIMP        Copy(void);
        STDMETHODIMP        Reset(void);

        // methods not exposed by ISystemMonitor
        void                SetLogFileRange(LONGLONG llBegin, LONGLONG LLEnd);
        void                GetLogFileRange(LONGLONG *pllBegin, LONGLONG *pLLEnd);

        HRESULT             SetLogViewTempRange(LONGLONG llStart, LONGLONG llStop);
        
        void                GetVisuals(
                                OLE_COLOR   *prgbColor,
                                INT         *piColorIndex, 
                                INT         *piWidthIndex, 
                                INT         *piStyleIndex);
        void                SetVisuals(
                                OLE_COLOR   rgbColor,
                                INT         iColorIndex, 
                                INT         iWidthIndex, 
                                INT         iStyleIndex);

        STDMETHODIMP        GetSelectedCounter(ICounterItem**);

    HLOG    GetDataSourceHandle ( void );

    // *** TodoMultiLogHandle:  Temporary private method.  Remove when trace file 
    // post-processing supports multiple open files.
    HQUERY  GetQueryHandle ( void );

    };


class CImpIOleControl : public IOleControl
    {
    protected:
        ULONG           m_cRef;      //Interface reference count
        PCPolyline      m_pObj;      //Backpointer to the object
        LPUNKNOWN       m_pUnkOuter; //For delegation

    public:
        CImpIOleControl(PCPolyline, LPUNKNOWN);
        virtual ~CImpIOleControl(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetControlInfo(LPCONTROLINFO);
        STDMETHODIMP OnMnemonic(LPMSG);
        STDMETHODIMP OnAmbientPropertyChange(DISPID);
        STDMETHODIMP FreezeEvents(BOOL);
    };


/*****************************************
class CAdviseRouter : public ISystemMonitorEvents
    {
    private:
        ULONG       m_cRef;
        PCPolyline  m_pObj;
        IDispatch  *m_pIDispatch;

    public:
        CAdviseRouter(IDispatch *, PCPolyline);
        virtual ~CAdviseRouter(void);

        void Invoke(DISPID dispId, INT iParam);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //Advise members.
        STDMETHODIMP_(void) OnCounterSelected(INT iIndex);
        STDMETHODIMP_(void) OnCounterAdded(INT iIndex);
        STDMETHODIMP_(void) OnCounterDeleted(INT iIndex);
    };

//These values match the ID's in smonctrl.odl
enum
    {
    EVENT_ONCOUNTERSELECTED=1,
    EVENT_ONCOUNTERADDED=2,
    EVENT_ONCOUNTERDELETED=3,
    };
***************************************/

#endif  //_POLYLINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\polyline.cpp ===
/*++

Copyright (C) 1993-1999 Microsoft Corporation

Module Name:

    polyline.cpp

Abstract:

    Implementation of the CPolyline class that is exposed as a
    component object.

--*/

#include "polyline.h"
#include "smonctrl.h"
#include "unihelpr.h"
#include "utils.h"

/*
 * CPolyline:CPolyline
 * CPolyline::~CPolyline
 *
 * Constructor Parameters:
 *  pUnkOuter       LPUNKNOWN of the controlling unknown.
 *  pfnDestroy      PFNDESTROYED to call when an object is
 *                  destroyed.
 *  hInst           HINSTANCE of the application we're in.
 */

CPolyline::CPolyline (
    LPUNKNOWN pUnkOuter, 
    PFNDESTROYED pfnDestroy )
    :   m_cRef ( 0 ),
        m_pUnkOuter ( pUnkOuter ),
        m_pfnDestroy ( pfnDestroy ),
        m_fDirty ( FALSE ),
        m_pImpIPolyline ( NULL ),
        m_pImpIConnPtCont ( NULL ),
        m_cf    ( 0 ),
        m_clsID ( CLSID_SystemMonitor ),
        m_pIStorage ( NULL ),
        m_pIStream  ( NULL ),
        m_pImpIPersistStorage ( NULL ),
        m_pImpIPersistStreamInit ( NULL ),
        m_pImpIPersistPropertyBag ( NULL ),
        m_pImpIPerPropertyBrowsing ( NULL ),
        m_pImpIDataObject    ( NULL ),
        m_pImpIObjectSafety ( NULL ),
        m_pIDataAdviseHolder ( NULL ),
        m_pDefIUnknown        ( NULL ),
        m_pDefIDataObject     ( NULL ),
        m_pDefIViewObject     ( NULL ),
        m_pDefIPersistStorage ( NULL ),
        m_pIOleAdviseHolder  ( NULL ),
        m_pImpIOleObject     ( NULL ),
        m_pIOleClientSite    ( NULL ),
        m_pImpIViewObject    ( NULL ),
        m_pIAdviseSink       ( NULL ),
        m_dwFrozenAspects    ( 0 ),
        m_dwAdviseAspects    ( 0 ),
        m_dwAdviseFlags      ( 0 ),
        m_pImpIRunnableObject ( NULL ),
        m_bIsRunning  (  FALSE ),
        m_pImpIExternalConnection ( NULL ),
        m_fLockContainer ( FALSE ),
        m_dwRegROT ( 0L ),
        m_pIOleIPSite ( NULL ),
        m_pIOleIPFrame ( NULL ),
        m_pIOleIPUIWindow ( NULL ),
        m_pImpIOleIPObject ( NULL ),
        m_pImpIOleIPActiveObject ( NULL ),
        m_hMenuShared ( NULL ),
        m_hOLEMenu ( NULL ),
        m_pHW ( NULL ),
        m_fAllowInPlace ( TRUE ),
        m_fUIActive ( FALSE ),
        m_fContainerKnowsInsideOut ( FALSE ),
        m_pImpISpecifyPP ( NULL ),
        m_pImpIProvideClassInfo ( NULL ),
        m_pImpIDispatch ( NULL ),
        m_pImpISystemMonitor ( NULL ),
        m_pImpIOleControl ( NULL ),
        m_pImpICounters ( NULL ),
        m_pImpILogFiles ( NULL ),
        m_pITypeLib ( NULL ),
        m_pIOleControlSite ( NULL ),
        m_pIDispatchAmbients ( NULL ),
        m_fFreezeEvents ( FALSE ),
        m_fHatch ( TRUE ),
        m_pCtrl ( NULL )
{
    // Set default extents
    SetRect(&m_RectExt, 0, 0, 300, 200);
    
    return;
}


CPolyline::~CPolyline(void)
    {
    LPUNKNOWN       pIUnknown=this;

    if (NULL!=m_pUnkOuter)
        pIUnknown=m_pUnkOuter;

    if (NULL!=m_pHW) {
        delete m_pHW;
        m_pHW = NULL;
    }

    if (NULL != m_pCtrl) {
        delete m_pCtrl;
        m_pCtrl = NULL;
    }
    /*
     * In aggregation, release cached pointers but
     * AddRef the controlling unknown first.
     */

    pIUnknown->AddRef();
    pIUnknown->AddRef();
    pIUnknown->AddRef();

    ReleaseInterface(m_pDefIViewObject);
    ReleaseInterface(m_pDefIDataObject);
    ReleaseInterface(m_pDefIPersistStorage);

    //Cached pointer rules do not apply to IUnknown
    ReleaseInterface(m_pDefIUnknown);

    ReleaseInterface(m_pIAdviseSink);
    ReleaseInterface(m_pIOleClientSite);
    ReleaseInterface(m_pIOleAdviseHolder);

    DeleteInterfaceImp(m_pImpIOleObject);
    DeleteInterfaceImp(m_pImpIViewObject);
    DeleteInterfaceImp(m_pImpIRunnableObject);

    //Other in-place interfaces released in deactivation.
    DeleteInterfaceImp(m_pImpIOleIPObject);
    DeleteInterfaceImp(m_pImpIOleIPActiveObject);

    ReleaseInterface(m_pIDispatchAmbients);
    ReleaseInterface(m_pIOleControlSite);
    ReleaseInterface(m_pITypeLib);

    DeleteInterfaceImp(m_pImpISpecifyPP);
    DeleteInterfaceImp(m_pImpIProvideClassInfo);
    DeleteInterfaceImp(m_pImpIDispatch);
    DeleteInterfaceImp(m_pImpISystemMonitor);
    DeleteInterfaceImp(m_pImpIOleControl);
    DeleteInterfaceImp(m_pImpICounters);
    DeleteInterfaceImp(m_pImpILogFiles);

    //Anything we might have registered in IRunnableObject::Run
    if (m_dwRegROT != 0)
        {
        IRunningObjectTable    *pROT;

        if (!FAILED(GetRunningObjectTable(0, &pROT)))
            {
            pROT->Revoke(m_dwRegROT);   
            pROT->Release();
            }
        }

    DeleteInterfaceImp(m_pImpIExternalConnection);
    ReleaseInterface(m_pIDataAdviseHolder);
    DeleteInterfaceImp(m_pImpIDataObject);
    DeleteInterfaceImp(m_pImpIObjectSafety);

    DeleteInterfaceImp(m_pImpIPersistStreamInit);
    DeleteInterfaceImp(m_pImpIPersistStorage);
    DeleteInterfaceImp(m_pImpIPersistPropertyBag);
    DeleteInterfaceImp(m_pImpIPerPropertyBrowsing);
    ReleaseInterface(m_pIStream);
    ReleaseInterface(m_pIStorage);

    DeleteInterfaceImp(m_pImpIConnPtCont);
    DeleteInterfaceImp(m_pImpIPolyline);

    return;
    }




/*
 * CPolyline::Init
 *
 * Purpose:
 *  Performs any intiailization of a CPolyline that's prone to
 *  failure that we also use internally before exposing the
 *  object outside this DLL.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  BOOL            TRUE if the function is successful,
 *                  FALSE otherwise.
 */

BOOL CPolyline::Init(void)
    {
    LPUNKNOWN       pIUnknown=this;
    HRESULT         hr;
    INT             i;

    if (NULL!=m_pUnkOuter)
        pIUnknown=m_pUnkOuter;

    m_cf=(CLIPFORMAT)RegisterClipboardFormat(SZSYSMONCLIPFORMAT);

    m_pImpIPersistStorage=new CImpIPersistStorage(this, pIUnknown);

    if (NULL==m_pImpIPersistStorage)
        return FALSE;

    m_pImpIPersistStreamInit=new CImpIPersistStreamInit(this, pIUnknown);

    if (NULL==m_pImpIPersistStreamInit)
        return FALSE;

    m_pImpIPersistPropertyBag=new CImpIPersistPropertyBag(this, pIUnknown);

    if (NULL==m_pImpIPersistPropertyBag)
        return FALSE;

    m_pImpIPerPropertyBrowsing=new CImpIPerPropertyBrowsing(this, pIUnknown);

    if (NULL==m_pImpIPerPropertyBrowsing)
        return FALSE;

    m_pImpIPolyline=new CImpIPolyline(this, pIUnknown);

    if (NULL==m_pImpIPolyline)
        return FALSE;

    m_pImpIConnPtCont=new CImpIConnPtCont(this, pIUnknown);

    if (NULL==m_pImpIConnPtCont)
        return FALSE;

    for (i=0; i<CONNECTION_POINT_CNT; i++) {
        m_ConnectionPoint[i].Init(this, pIUnknown, i);
    }

    m_pImpIDataObject=new CImpIDataObject(this, pIUnknown);

    if (NULL==m_pImpIDataObject)
        return FALSE;

    m_pImpIOleObject=new CImpIOleObject(this, pIUnknown);

    if (NULL==m_pImpIOleObject)
        return FALSE;

    m_pImpIViewObject=new CImpIViewObject(this, pIUnknown);

    if (NULL==m_pImpIViewObject)
        return FALSE;

    m_pImpIRunnableObject=new CImpIRunnableObject(this, pIUnknown);

    if (NULL==m_pImpIRunnableObject)
        return FALSE;

/***********************************
    m_pImpIExternalConnection=new CImpIExternalConnection(this
        , pIUnknown);

    if (NULL==m_pImpIExternalConnection)
        return FALSE;
************************************/

    m_pImpIOleIPObject=new CImpIOleInPlaceObject(this, pIUnknown);

    if (NULL==m_pImpIOleIPObject)
        return FALSE;

    m_pImpIOleIPActiveObject=new CImpIOleInPlaceActiveObject(this
        , pIUnknown);

    if (NULL==m_pImpIOleIPActiveObject)
        return FALSE;

    m_pImpISpecifyPP=new CImpISpecifyPP(this, pIUnknown);

    if (NULL==m_pImpISpecifyPP)
        return FALSE;

    m_pImpIProvideClassInfo=new CImpIProvideClassInfo(this, pIUnknown);

    if (NULL==m_pImpIProvideClassInfo)
        return FALSE;

    m_pImpISystemMonitor=new CImpISystemMonitor(this, pIUnknown);

    if (NULL==m_pImpISystemMonitor)
        return FALSE;

    m_pImpICounters = new CImpICounters(this, pIUnknown);

    if (NULL==m_pImpICounters)
        return FALSE;

    m_pImpILogFiles = new CImpILogFiles(this, pIUnknown);

    if (NULL==m_pImpILogFiles)
        return FALSE;

    m_pImpIDispatch=new CImpIDispatch(this, pIUnknown);

    if (NULL==m_pImpIDispatch)
        return FALSE;

    m_pImpIDispatch->SetInterface(DIID_DISystemMonitor, m_pImpISystemMonitor);

    m_pImpIOleControl=new CImpIOleControl(this, pIUnknown);

    if (NULL==m_pImpIOleControl)
        return FALSE;

    m_pImpIObjectSafety = new CImpIObjectSafety(this, pIUnknown);
    if (NULL == m_pImpIObjectSafety) {
        return FALSE;
    }

    m_pCtrl = new CSysmonControl(this);
    if (NULL==m_pCtrl)
        return FALSE;
    if ( !m_pCtrl->AllocateSubcomponents() )
        return FALSE;

    /*
     * We're sitting at ref count 0 and the next call will AddRef a
     * few times and Release a few times.  This insures we don't
     * delete ourselves prematurely.
     */
    m_cRef++;

    //Aggregate OLE's cache for IOleCache* interfaces.
    hr=CreateDataCache(pIUnknown, CLSID_SystemMonitor
        , IID_IUnknown, (PPVOID)&m_pDefIUnknown);

    if (FAILED(hr))
        return FALSE;

    /*
     * NOTE:  The spec specifically states that any interfaces
     * besides IUnknown that we obtain on an aggregated object
     * should be Released immediately after we QueryInterface for
     * them because the QueryInterface will AddRef us, and since
     * we would not release these interfaces until we were
     * destroyed, we'd never go away because we'd never get a zero
     * ref count.
     */

    //Now try to get other interfaces to which we delegate
    hr=m_pDefIUnknown->QueryInterface(IID_IViewObject2
        , (PPVOID)&m_pDefIViewObject);

    if (FAILED(hr))
        return FALSE;

    pIUnknown->Release();

    hr=m_pDefIUnknown->QueryInterface(IID_IDataObject
        , (PPVOID)&m_pDefIDataObject);

    if (FAILED(hr))
        return FALSE;

    pIUnknown->Release();

    hr=m_pDefIUnknown->QueryInterface(IID_IPersistStorage
        , (PPVOID)&m_pDefIPersistStorage);

    if (FAILED(hr))
        return FALSE;

    pIUnknown->Release();

    m_cRef--;
    m_pImpIPolyline->New();

    /*
     * Go load our own type information and save its ITypeLib
     * pointer that will be used be CImpIDispatch and
     * CImpIProvideClassInfo.
     */

    hr=LoadRegTypeLib(LIBID_SystemMonitor, SMONCTRL_MAJ_VERSION, SMONCTRL_MIN_VERSION
        , LANG_NEUTRAL, &m_pITypeLib);

    if (FAILED(hr))
        hr=LoadTypeLib(OLESTR("SYSMON.TLB"), &m_pITypeLib);

    if (FAILED(hr))
        return FALSE;

    //Set up our CONTROLINFO structure (we have two mnemonics)
    m_ctrlInfo.cb=sizeof(CONTROLINFO);
    m_ctrlInfo.dwFlags=0;
    m_ctrlInfo.hAccel=NULL;
    m_ctrlInfo.cAccel=0;

    /*
     * Note:  we cannot initialize ambients until we get
     * a container interface pointer in IOleObject::SetClientSite.
     */

    return TRUE;
    }



/*
 * CPolyline::QueryInterface
 * CPolyline::AddRef
 * CPolyline::Release
 *
 * Purpose:
 *  IUnknown members for CPolyline object.
 */

STDMETHODIMP CPolyline::QueryInterface(REFIID riid, PPVOID ppv)
    {
    *ppv=NULL;

    if (IID_IUnknown==riid)
        *ppv=this;

    else if (IID_IConnectionPointContainer==riid)
        *ppv=m_pImpIConnPtCont;

    else if (IID_IPersistStorage==riid)
        *ppv=m_pImpIPersistStorage;

    else if (IID_IPersist==riid || IID_IPersistStream==riid
        || IID_IPersistStreamInit==riid)
        *ppv=m_pImpIPersistStreamInit;

    else if (IID_IPersistPropertyBag==riid )
        *ppv=m_pImpIPersistPropertyBag;

    else if (IID_IPerPropertyBrowsing==riid )
        *ppv=m_pImpIPerPropertyBrowsing;

    else if (IID_IDataObject==riid)
        *ppv=m_pImpIDataObject;

    else if (IID_IOleObject==riid)
        *ppv=m_pImpIOleObject;

    else if (IID_IViewObject==riid || IID_IViewObject2==riid)
        *ppv=m_pImpIViewObject;

    else if (IID_IRunnableObject==riid)
    //  *ppv=m_pImpIRunnableObject;
         return E_NOINTERFACE;

    else if (IID_IExternalConnection==riid)
       *ppv=m_pImpIExternalConnection;

    //IOleWindow will be the InPlaceObject
    else if (IID_IOleWindow==riid || IID_IOleInPlaceObject==riid)
        *ppv=m_pImpIOleIPObject;

    // The OLE rule state that InPlaceActiveObject should not be
    // provided in response to a query, but the current MFC (4.0)
    // won't work if we don't do it.
    else if (IID_IOleInPlaceActiveObject==riid)
        *ppv=m_pImpIOleIPActiveObject;

    else if (IID_ISpecifyPropertyPages==riid)
        *ppv=m_pImpISpecifyPP;

    else if (IID_IProvideClassInfo==riid)
        *ppv=m_pImpIProvideClassInfo;

    else if (IID_IDispatch==riid || DIID_DISystemMonitor==riid)
        *ppv=m_pImpIDispatch;

    else if (IID_ISystemMonitor==riid)
        *ppv=m_pImpISystemMonitor;

    else if (IID_IOleControl==riid)
        *ppv=m_pImpIOleControl;

    //Use the default handler's cache.
    else if (IID_IOleCache==riid || IID_IOleCache2==riid)
        return m_pDefIUnknown->QueryInterface(riid, ppv);
    else if (IID_IObjectSafety == riid) {
         *ppv = m_pImpIObjectSafety;
    }

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return E_NOINTERFACE;
    }


STDMETHODIMP_(ULONG) CPolyline::AddRef(void)
    {
    return ++m_cRef;
    
    }


STDMETHODIMP_(ULONG) CPolyline::Release(void)
    {
    if (0L!=--m_cRef)
        return m_cRef;

    // Prevent reentrant call
    m_cRef++;

    if (NULL!=m_pfnDestroy)
        (*m_pfnDestroy)();

    delete this;
    return 0L;
    }

/*
 * CPolyline::RectConvertMappings
 *
 * Purpose:
 *  Converts the contents of a rectangle from device (MM_TEXT) or
 *  HIMETRIC to the other.
 *
 * Parameters:
 *  pRect           LPRECT containing the rectangle to convert.
 *  fToDevice       BOOL TRUE to convert from HIMETRIC to device,
 *                  FALSE to convert device to HIMETRIC.
 *
 * Return Value:
 *  None
 */

void
CPolyline::RectConvertMappings(LPRECT pRect, BOOL fToDevice)
{
    HDC      hDC = NULL;
    INT      iLpx, iLpy;

    if ( NULL != pRect ) {

        hDC=GetDC(NULL);

        if ( NULL != hDC ) {
            iLpx=GetDeviceCaps(hDC, LOGPIXELSX);
            iLpy=GetDeviceCaps(hDC, LOGPIXELSY);
            
            ReleaseDC(NULL, hDC);

            if (fToDevice) {
                pRect->left=MulDiv(iLpx, pRect->left, HIMETRIC_PER_INCH);
                pRect->top =MulDiv(iLpy, pRect->top , HIMETRIC_PER_INCH);

                pRect->right =MulDiv(iLpx, pRect->right, HIMETRIC_PER_INCH);
                pRect->bottom=MulDiv(iLpy, pRect->bottom,HIMETRIC_PER_INCH);
            } else {
                if ( 0 != iLpx && 0 != iLpy ) {
                    pRect->left=MulDiv(pRect->left, HIMETRIC_PER_INCH, iLpx);
                    pRect->top =MulDiv(pRect->top , HIMETRIC_PER_INCH, iLpy);

                    pRect->right =MulDiv(pRect->right, HIMETRIC_PER_INCH, iLpx);
                    pRect->bottom=MulDiv(pRect->bottom,HIMETRIC_PER_INCH, iLpy);
                }
            }
        }
    }
    return;
}


/*
 * CPolyline::RenderBitmap
 *
 * Purpose:
 *  Creates a bitmap image of the current Polyline.
 *
 * Parameters:
 *  phBmp           HBITMAP * in which to return the bitmap.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, otherwise a
 *                  POLYLINE_E_ value.
 */

STDMETHODIMP 
CPolyline::RenderBitmap(
    HBITMAP *phBmp,
    HDC     hAttribDC )
{
    //HDC             hDC;
    HRESULT         hr = NOERROR;
    HDC             hMemDC;
    HBITMAP         hBmp = NULL;
    RECT            rc;
    HGDIOBJ         hObj;
    HWND            hWnd;

    if (NULL==phBmp) {
        hr = POLYLINE_E_INVALIDPOINTER;
    } else if ( NULL == hAttribDC ) {
        hr = E_INVALIDARG;
    } else {
        hWnd = m_pCtrl->Window();

        if ( NULL != hWnd ) {

            //Render a bitmap the size of the current rectangle.
        
            hMemDC = CreateCompatibleDC(hAttribDC);

            if ( NULL != hMemDC ) {
                GetClientRect(hWnd, &rc);
                hBmp = CreateCompatibleBitmap(hAttribDC, rc.right, rc.bottom);

                if (NULL!=hBmp) {
                    //Draw the control into the bitmap.
                    hObj = SelectObject(hMemDC, hBmp);
                    Draw(hMemDC, hAttribDC, FALSE, TRUE, &rc);
                    SelectObject(hMemDC, hObj);
                }

                DeleteDC(hMemDC);
                // ReleaseDC(hWnd, hDC);
            }
            *phBmp=hBmp;
            hr = NOERROR;
        } else {
            hr =  E_UNEXPECTED;
        }
    }
    return hr;
}



/*
 * CPolyline::RenderMetafilePict
 *
 * Purpose:
 *  Renders the current Polyline into a METAFILEPICT structure in
 *  global memory.
 *
 * Parameters:
 *  phMem           HGLOBAL * in which to return the
 *                  METAFILEPICT.
 *
 * Return Value:
 *  HRESULT         NOERROR if successful, otherwise a
 *                  POLYLINE_E_ value.
 */

STDMETHODIMP 
CPolyline::RenderMetafilePict(
    HGLOBAL *phMem,
    HDC hAttribDC )
{
    HGLOBAL         hMem;
    HMETAFILE       hMF;
    LPMETAFILEPICT  pMF;
    RECT            rc;
    HDC             hDC;

    if (NULL==phMem)
        return POLYLINE_E_INVALIDPOINTER;

    //Create a memory metafile and return its handle.
    hDC=(HDC)CreateMetaFile(NULL);

    if (NULL==hDC)
        return STG_E_MEDIUMFULL;

    SetMapMode(hDC, MM_ANISOTROPIC);

    //
    // Always set up the window extents to the real window size
    // so the drawing routines can work in their normal dev coords
    //
    /********* Use the extent rect, not the window rect *********/
    rc = m_RectExt;
    // GetClientRect(m_pCtrl->Window(), &rc);
    /************************************************************/

    Draw( hDC, hAttribDC, TRUE, TRUE, &rc );
  
    hMF=CloseMetaFile(hDC);

    if (NULL==hMF)
        return STG_E_MEDIUMFULL;

    //Allocate the METAFILEPICT structure.
    hMem=GlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE
        , sizeof(METAFILEPICT));

    if (NULL==hMem)
        {
        DeleteMetaFile(hMF);
        return E_FAIL;
        }

    /*
     * Global lock only fails in PMODE if the selector is invalid
     * (like it was discarded) or references a 0 length segment,
     * neither of which can happen here.
     */
    pMF=(LPMETAFILEPICT)GlobalLock(hMem);

    pMF->hMF=hMF;
    pMF->mm=MM_ANISOTROPIC;

    //Insert the extents in MM_HIMETRIC units.

    /********* Use the extent rect, not the window rect *********/
    rc = m_RectExt;
    // GetClientRect(m_pCtrl->Window(), &rc);
    /************************************************************/

    RectConvertMappings(&rc, FALSE);
    pMF->xExt=rc.right;
    pMF->yExt=rc.bottom;

    GlobalUnlock(hMem);

    *phMem=hMem;
    return NOERROR;
    }


/*
 * CPolyline::SendAdvise
 *
 * Purpose:
 *  Calls the appropriate IOleClientSite or IAdviseSink member
 *  function for various events such as closure, renaming, etc.
 *
 * Parameters:
 *  uCode           UINT OBJECTCODE_* identifying the notification.
 *
 * Return Value:
 *  None
 */

void CPolyline::SendAdvise(UINT uCode)
    {
    DWORD       dwAspect=DVASPECT_CONTENT | DVASPECT_THUMBNAIL;

    switch (uCode)
        {
        case OBJECTCODE_SAVED:
            if (NULL!=m_pIOleAdviseHolder)
                m_pIOleAdviseHolder->SendOnSave();
            break;

        case OBJECTCODE_CLOSED:
            if (NULL!=m_pIOleAdviseHolder)
                m_pIOleAdviseHolder->SendOnClose();

            break;

        case OBJECTCODE_RENAMED:
            //Call IOleAdviseHolder::SendOnRename (later)
            break;

        case OBJECTCODE_SAVEOBJECT:
            if (m_fDirty && NULL!=m_pIOleClientSite)
                m_pIOleClientSite->SaveObject();

            m_fDirty=FALSE;
            break;

        case OBJECTCODE_DATACHANGED:
            m_fDirty=TRUE;

            //No flags are necessary here.
            if (NULL!=m_pIDataAdviseHolder)
                {
                m_pIDataAdviseHolder->SendOnDataChange
                    (m_pImpIDataObject, 0, 0);
                }

            if ( ( NULL!=m_pIAdviseSink )
                & (dwAspect & m_dwAdviseAspects))
                {
                m_pIAdviseSink->OnViewChange(dwAspect
                    & m_dwAdviseAspects, 0);
                }

            break;

        case OBJECTCODE_SHOWWINDOW:
            if (NULL!=m_pIOleClientSite)
                m_pIOleClientSite->OnShowWindow(TRUE);

            break;

        case OBJECTCODE_HIDEWINDOW:
            if (NULL!=m_pIOleClientSite)
                m_pIOleClientSite->OnShowWindow(FALSE);

            break;

        case OBJECTCODE_SHOWOBJECT:
            if (NULL!=m_pIOleClientSite)
                m_pIOleClientSite->ShowObject();

            break;
        }

    return;
    }


/*
 * CPolyline::SendEvent
 *
 * Purpose:
 *  Send an event to all connection points.
 * 
 *
 * Parameters:
 *  uEventType      Event Type
 *  dwParam         Parameter to send with event.
 *
 * Return Value:
 *  None
 */

void CPolyline::SendEvent (
    IN UINT uEventType, 
    IN DWORD dwParam
    )
{
    INT i;

    // Don't send if container has frozen events
    if (m_fFreezeEvents)
        return;

    // Pass event to each connection point
    for (i=0; i<CONNECTION_POINT_CNT; i++) {
        m_ConnectionPoint[i].SendEvent(uEventType, dwParam);
    }
}


/*
 * CPolyline::InPlaceActivate
 *
 * Purpose:
 *  Goes through all the steps of activating the Polyline as an
 *  in-place object.
 *
 * Parameters:
 *  pActiveSite     LPOLECLIENTSITE of the active site we show in.
 *  fIncludeUI      BOOL controls whether we call UIActivate too.
 *
 * Return Value:
 *  HRESULT         Whatever error code is appropriate.
 */

HRESULT CPolyline::InPlaceActivate(LPOLECLIENTSITE pActiveSite
    , BOOL fIncludeUI)
    {
    HRESULT                 hr;
    HWND                    hWndSite;
    HWND                    hWndHW;
    HWND                    hWndCtrl;
    RECT                    rcPos;
    RECT                    rcClip;
    OLEINPLACEFRAMEINFO     frameInfo;

    if (NULL==pActiveSite)
        return E_POINTER;

    // If we already have a site, just handle UI 
    if (NULL != m_pIOleIPSite)
        {
        if (fIncludeUI) {
            UIActivate();
            SetFocus(m_pCtrl->Window());
        }

        return NOERROR;
        }


    // Initialization, obtaining interfaces, OnInPlaceActivate.
    hr=pActiveSite->QueryInterface(IID_IOleInPlaceSite
        , (PPVOID)&m_pIOleIPSite);

    if (FAILED(hr))
        return hr;

    hr=m_pIOleIPSite->CanInPlaceActivate();

    if (NOERROR!=hr)
        {
        m_pIOleIPSite->Release();
        m_pIOleIPSite=NULL;
        return E_FAIL;
        }

    m_pIOleIPSite->OnInPlaceActivate();


    // Get the window context and create a window.
    m_pIOleIPSite->GetWindow(&hWndSite);
    frameInfo.cb=sizeof(OLEINPLACEFRAMEINFO);

    m_pIOleIPSite->GetWindowContext(&m_pIOleIPFrame
        , &m_pIOleIPUIWindow, &rcPos, &rcClip, &frameInfo);


    /*
     * Create the hatch window after we get a parent window.  We
     * could not create the hatch window sooner because had nothing
     * to use for the parent.
     */
    m_pHW=new CHatchWin();

    if (NULL==m_pHW)
        {
        InPlaceDeactivate();
        return E_OUTOFMEMORY;
        }

    if (!m_pHW->Init(hWndSite, ID_HATCHWINDOW, NULL))
        {
        InPlaceDeactivate();
        return E_OUTOFMEMORY;
        }

     hr=m_pImpIRunnableObject->Run(NULL);

    // Move the hatch window to the container window.
    hWndHW = m_pHW->Window();
    SetParent(hWndHW, hWndSite);


    // Move the Polyline window from the hidden dialog to hatch window
    hWndCtrl = m_pCtrl->Window();

    m_pHW->HwndAssociateSet(hWndCtrl);
    m_pHW->ChildSet(hWndCtrl);
    m_pHW->RectsSet(&rcPos, &rcClip);   //Positions polyline

    ShowWindow(hWndHW, SW_SHOW);
    SendAdvise(OBJECTCODE_SHOWOBJECT);

    // Critical for accelerators to work initially.
    SetFocus(hWndCtrl);

    if (fIncludeUI)
        hr =  UIActivate();
    else
        hr = NOERROR;

    /*
     * Since we don't have an Undo while in-place, tell the continer
     * to free it's undo state immediately.
     */
    m_pIOleIPSite->DiscardUndoState();

    return hr;

    }


/*
 * CPolyline::InPlaceDeactivate
 *
 * Purpose:
 *  Reverses all the activation steps from InPlaceActivate.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  None
 */

void CPolyline::InPlaceDeactivate(void)
    {
    UIDeactivate();

    if (NULL!=m_pHW)
        {
        ShowWindow(m_pHW->Window(), SW_HIDE);

        // Move the window to its foster home
        if (m_pCtrl->Window()) {
            SetParent(m_pCtrl->Window(), g_hWndFoster);
        }

        m_pHW->ChildSet(NULL);

        delete m_pHW;
        m_pHW=NULL;
        }

    ReleaseInterface(m_pIOleIPFrame);
    ReleaseInterface(m_pIOleIPUIWindow)

    if (NULL!=m_pIOleIPSite)
        {
        m_pIOleIPSite->OnInPlaceDeactivate();
        ReleaseInterface(m_pIOleIPSite);
        }

    return;
    }


/*
 * CPolyline::UIActivate
 *
 * Purpose:
 *  Goes through all the steps of activating the user interface of
 *  Polyline as an in-place object.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or error code.
 */

HRESULT CPolyline::UIActivate(void)
    {
    LPWSTR  szUserType;

    USES_CONVERSION

    // If already UI active, just return
    if (m_fUIActive)
        return NOERROR;

    m_fUIActive = TRUE;

    // Show hatched border only if enabled
    if (m_fHatch)
        m_pHW->ShowHatch(TRUE);

    // Call IOleInPlaceSite::UIActivate
    if (NULL!=m_pIOleIPSite)
        m_pIOleIPSite->OnUIActivate();

    // Set the active object
    szUserType = T2W(ResourceString(IDS_USERTYPE));

    if (NULL != m_pIOleIPFrame)
        m_pIOleIPFrame->SetActiveObject(m_pImpIOleIPActiveObject, szUserType);

    if (NULL != m_pIOleIPUIWindow)
        m_pIOleIPUIWindow->SetActiveObject(m_pImpIOleIPActiveObject, szUserType);

    // Negotiate border space.  None needed.
    if (NULL != m_pIOleIPFrame)
        m_pIOleIPFrame->SetBorderSpace(NULL);

    if (NULL != m_pIOleIPUIWindow)
        m_pIOleIPUIWindow->SetBorderSpace(NULL);

    // Create the shared menu.  No items added.
    if (NULL != m_pIOleIPFrame)
        m_pIOleIPFrame->SetMenu(NULL, NULL, m_pCtrl->Window());

    return NOERROR;
    }


/*
 * CPolyline::UIDeactivate
 *
 * Purpose:
 *  Reverses all the user interface activation steps from
 *  UIActivate.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  None
 */

void CPolyline::UIDeactivate(void)
{
    if (!m_fUIActive){
        return;
    }

    m_fUIActive=FALSE;

    // Hide hatched border if enabled
    if (m_fHatch && NULL != m_pHW ){
        m_pHW->ShowHatch(FALSE);
    }

    // Tell frame and UI Window we aren't active
    if (NULL!=m_pIOleIPFrame){
        m_pIOleIPFrame->SetActiveObject(NULL, NULL);
    }

    if (NULL!=m_pIOleIPUIWindow){
        m_pIOleIPUIWindow->SetActiveObject(NULL, NULL);
    }

    //We don't have any shared menu or tools to clean up.
    if (NULL!=m_pIOleIPSite){
        m_pIOleIPSite->OnUIDeactivate(FALSE);
    }
}


/*
 * AmbientGet
 *
 * Purpose:
 *  Retrieves a specific ambient property into a VARIANT.
 *
 * Parameters:
 *  dispID          DISPID of the property to retrieve.
 *  pva             VARIANT * to fill with the new value.
 *
 * Return value
 *  BOOL            TRUE if the ambient was retrieved, FALSE
 *                  otherwise.
 */

BOOL CPolyline::AmbientGet(DISPID dispID, VARIANT *pva)
    {
    HRESULT         hr;
    DISPPARAMS      dp;

    if (NULL==pva)
        return FALSE;

    if (NULL==m_pIDispatchAmbients)
        return FALSE;

    SETNOPARAMS(dp);
    hr=m_pIDispatchAmbients->Invoke(dispID, IID_NULL
        , LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET
        , &dp, pva, NULL, NULL);

    return SUCCEEDED(hr);
    }


/*
 * AmbientsInitialize
 *
 * Purpose:
 *  Attempts to retrieve the container's ambient properties
 *  and initialize (or reinitialize) Polyline accordingly.
 *
 * Parameters:
 *  dwWhich         DWORD containing INITAMBIENT_... flags
 *                  describing which ambients to initialize.
 *                  This can be any combination.
 *
 * Return Value:
 *  None
 */

void CPolyline::AmbientsInitialize(DWORD dwWhich)
    {
    VARIANT     va;
    LPFONT      pIFont,pIFontClone;
    LPFONTDISP  pIFontDisp;

    if (NULL == m_pIDispatchAmbients)
        return;

    /*
     * We need to retrieve these ambients into these variables:
     *
     *  Ambient Property:               Variable:
     *  -----------------------------------------------
     *  DISPID_AMBIENT_SHOWHATCHING     m_fHatch
     *  DISPID_AMBIENT_UIDEAD           m_fUIDead
     *  DISPID_AMBIENT_BACKCOLOR        m_pCtrl...
     *  DISPID_AMBIENT_FONT .....       m_pCtrl...
     *  DISPID_AMBIENT_FORECOLOR        m_pCtrl...
     *  DISPID_AMBIENT_APPEARANCE       m_pCtrl...
     *  DISPID_AMBIENT_USERMODE         m_pCtrl...
     */

    VariantInit(&va);

    if ((INITAMBIENT_SHOWHATCHING & dwWhich)
         &&AmbientGet(DISPID_AMBIENT_SHOWHATCHING, &va)) {

        m_fHatch=V_BOOL(&va);

        if (NULL != m_pHW)
            m_pHW->ShowHatch(m_fHatch && m_fUIActive);
    }

    if ((INITAMBIENT_UIDEAD & dwWhich)
         && AmbientGet(DISPID_AMBIENT_UIDEAD, &va)) {

        m_pCtrl->m_fUIDead = (BOOLEAN)V_BOOL(&va);
    }

    if ((INITAMBIENT_USERMODE & dwWhich)
         && AmbientGet(DISPID_AMBIENT_USERMODE, &va))   {

        m_pCtrl->m_fUserMode = (BOOLEAN)V_BOOL(&va);
    }

    if ((INITAMBIENT_APPEARANCE & dwWhich)
        && AmbientGet(DISPID_AMBIENT_APPEARANCE, &va)) {

        m_pCtrl->put_Appearance(V_I4(&va), TRUE);   
    }

    if ((INITAMBIENT_BACKCOLOR & dwWhich)
        && AmbientGet(DISPID_AMBIENT_BACKCOLOR, &va)) {

        m_pCtrl->put_BackPlotColor(V_I4(&va), TRUE);    
    }

    if ((INITAMBIENT_FORECOLOR & dwWhich)
        && AmbientGet(DISPID_AMBIENT_FORECOLOR, &va)) {

        m_pCtrl->put_FgndColor(V_I4(&va), TRUE);
    }

    if ((INITAMBIENT_FONT & dwWhich)
        && AmbientGet(DISPID_AMBIENT_FONT, &va)) {

        pIFontDisp = (LPFONTDISP)V_DISPATCH(&va);

        if (pIFontDisp != NULL) {

            if (SUCCEEDED(pIFontDisp->QueryInterface(IID_IFont, (PPVOID)&pIFont))) {

                if (SUCCEEDED(pIFont->Clone(&pIFontClone))) {
                    m_pCtrl->put_Font(pIFontClone, TRUE);
                    pIFontClone->Release();
                }
                pIFont->Release();
            }

            pIFontDisp->Release();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\resource.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Resource ID definitions.

--*/

#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#define IDR_ICON            1
#define IDD_EDITDIALOG      1

#define ID_UNDO             100
#define ID_COLORBACK        101
#define ID_COLORLINE        102
#define ID_GROUPCOLORS      103
#define ID_GROUPPREVIEW     104
#define ID_GROUPSTYLES      105
#define ID_GROUPFIGURE      106
#define ID_POLYLINERECT     107
#define ID_POLYLINE         108

#define ID_LINEMIN          200
#define ID_LINESOLID        200     //(ID_LINEMIN+PS_SOLID)
#define ID_LINEDASH         201     //(ID_LINEMIN+PS_DASH)
#define ID_LINEDOT          202     //(ID_LINEMIN+PS_DOT)
#define ID_LINEDASHDOT      203     //(ID_LINEMIN+PS_DASHDOT)
#define ID_LINEDASHDOTDOT   204     //(ID_LINEMIN+PS_DASHDOTDOT)

#define ID_SMONACCEL        1
#define IDM_CONTEXT         1       // Context menu items
#define IDM_PROPERTIES      2
#define IDM_ADDCOUNTERS     3
#define IDM_SAVEAS          4
#define IDM_SAVEDATA        5

#define IDM_REPORT_COPY     5       // Report context menu items
#define IDM_REPORT_COPYALL  6
#define IDM_REPORT_DELETE   7

#define IDM_HIGHLITE        10      // Accelerator Keys
#define IDM_UPDATE          11
#define IDM_DELETE          12

#define IDC_SNAPBTN         1       // Snapshot button 
#define IDB_SNAPBTN         1       // SnapShot button bitmap
#define IDB_TOOLBAR         2       // toolbar bitmap
 
#define IDC_CURS_NS         1000
#define IDC_CURS_WE         1001
#define IDC_CURS_NWSE       1002
#define IDC_CURS_NESW       1003        
#define IDC_CURS_MOVE       1004

#define IDC_CURS_MIN        1000
#define IDC_CURS_MAX        1004
#define IDC_STATIC          1005        

//Message to close the dialog
#define POLYM_CLOSE         (WM_USER+1000)

// toolbar id's
#define IDM_TOOLBAR         20
#define IDM_TB_NEW          21
#define IDM_TB_CLEAR        22
#define IDM_TB_REALTIME     23
#define IDM_TB_LOGFILE      24
#define IDM_TB_CHART        25
#define IDM_TB_HISTOGRAM    26
#define IDM_TB_REPORT       27
#define IDM_TB_ADD          28
#define IDM_TB_DELETE       29
#define IDM_TB_HIGHLIGHT    30
#define IDM_TB_COPY         31
#define IDM_TB_PASTE        32
#define IDM_TB_PROPERTIES   33
#define IDM_TB_FREEZE       34
#define IDM_TB_UPDATE       35
#define IDM_TB_HELP         36

#define IDD_SAVEDATA_DLG    8000
#define IDC_SAVEDATA_EDIT   8001

#define TB_NUM_BITMAPS      (DWORD)((IDM_TB_HELP - IDM_TB_NEW) + 1)

#include "strids.h"

#endif //_RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\report.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    report.cpp

Abstract:

    Implements the report view.

--*/

//==========================================================================//
//                                  Includes                                //
//==========================================================================//

#include <assert.h>
#include <stdio.h>      // for sprintf
#include <pdhmsg.h>
#include "polyline.h"
#include "commctrl.h"
#include "winhelpr.h"

#define eScaleValueSpace        _T(">9999999999.0")
#define szReportClass           _T("SysmonReport")
#define szReportClassA          "SysmonReport"
#define HEXMASK                 (0x00030C00)
static INT  xBorderWidth = GetSystemMetrics(SM_CXBORDER);
static INT  yBorderHeight = GetSystemMetrics(SM_CYBORDER);
static INT  xColumnMargin = 10;
static INT  xCounterMargin = 50;
static INT  xObjectMargin = 25;

static TCHAR   LineEndStr[] = TEXT("\n") ;
static TCHAR   TabStr[] = TEXT("\t");

LRESULT APIENTRY HdrWndProc (HWND, WORD, WPARAM, LONG);
 
//==========================================================================//
//                                  Constants                               //
//==========================================================================//

#define dwReportClassStyle     (CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS)
#define iReportWindowExtra     (sizeof (PREPORT))
#define dwReportWindowStyle    (WS_CHILD | WS_HSCROLL | WS_VSCROLL) 

#define szValuePlaceholder          TEXT("-999,999,999.999")
#define szValueLargeHexPlaceholder  TEXT(" xBBBBBBBBDDDDDDDD")

#define dLargeValueMax              ((double) 999999999.0)
#define szDashLine                  TEXT("---")

CReport::CReport (
    void
    )
{
    m_pCtrl = NULL;
    m_hWnd = NULL;
    m_yLineHeight = 0;
    m_xReportWidth = 0;
    m_yReportHeight = 0;
    m_pSelect = NULL;
}

//
// Destructor
//
CReport::~CReport (void )
{
    if (m_hWnd != NULL && IsWindow(m_hWnd))
        DestroyWindow(m_hWnd);
}

//
// Initialization
//
BOOL CReport::Init ( PSYSMONCTRL pCtrl, HWND hWndParent )
   {
   WNDCLASS       wc ;
   LONG     lExStyles;

    // Save pointer to parent control
    m_pCtrl = pCtrl;

    BEGIN_CRITICAL_SECTION

    // Register window class once
    if (pstrRegisteredClasses[REPORT_WNDCLASS] == NULL) {
    
        wc.style          = dwReportClassStyle ;
        wc.lpfnWndProc    = (WNDPROC) ReportWndProc ;
        wc.hInstance      = g_hInstance ;
        wc.cbClsExtra     = 0;
        wc.cbWndExtra     = iReportWindowExtra ;
        wc.hIcon          = NULL ;
        wc.hCursor        = LoadCursor (NULL, IDC_ARROW) ;
        wc.hbrBackground  = NULL ;
        wc.lpszMenuName   = NULL ;
        wc.lpszClassName  = szReportClass ;

        if (RegisterClass (&wc)) {
            pstrRegisteredClasses[REPORT_WNDCLASS] = szReportClass;
        }

        // Ensure controls are initialized 
        InitCommonControls(); 
    }

    END_CRITICAL_SECTION

    if (pstrRegisteredClasses[REPORT_WNDCLASS] == NULL)
        return FALSE;

    // Create our window
    m_hWnd = CreateWindow (szReportClass,          // class
                         NULL,                     // caption
                         dwReportWindowStyle,      // window style
                         0, 0,                     // position
                         0, 0,                     // size
                         hWndParent,               // parent window
                         NULL,                     // menu
                         g_hInstance,              // program instance
                         (LPVOID) this );          // user-supplied data

    if (m_hWnd == NULL)
        return FALSE;

    // Turn off layout mirroring if it is enabled
    lExStyles = GetWindowLong(m_hWnd, GWL_EXSTYLE); 

    if ( 0 != ( lExStyles & WS_EX_LAYOUTRTL ) ) {
        lExStyles &= ~WS_EX_LAYOUTRTL;
        SetWindowLong(m_hWnd, GWL_EXSTYLE, lExStyles);
    }

    return TRUE;
}  


void CReport::ChangeFont (
    void
    )
{
    if (!m_bFontChange) {

        m_bFontChange = TRUE;

        if (!m_bConfigChange) {
            m_bConfigChange = TRUE;
            WindowInvalidate(m_hWnd);
        }
    }
}


void 
CReport::SizeComponents (
    LPRECT pRect )
{
   INT            xWidth;
   INT            yHeight;

    m_rect = *pRect;

    xWidth = pRect->right - pRect->left;
    yHeight = pRect->bottom - pRect->top;

    // If no space, hide window and leave
    if (xWidth == 0 || yHeight == 0) {
        WindowShow(m_hWnd, FALSE);
        return;
    }

    // Show window to assigned position
    MoveWindow(m_hWnd, pRect->left, pRect->top, xWidth, yHeight, FALSE);
    WindowShow(m_hWnd, TRUE);
    WindowInvalidate(m_hWnd);

    SetScrollRanges();
}

INT 
CReport::SetCounterPositions (
    PCObjectNode pObject,
    HDC hDC )
{
   PCCounterNode  pCounter;
   INT            yPos;

   yPos = pObject->m_yPos + m_yLineHeight;

   for (pCounter = pObject->FirstCounter();
        pCounter;
        pCounter = pCounter->Next()) {
   
      if (m_bFontChange || pCounter->m_xWidth == -1) {
          pCounter->m_xWidth = TextWidth(hDC, pCounter->Name());
      }

      if (pCounter->m_xWidth > m_xMaxCounterWidth)
          m_xMaxCounterWidth = pCounter->m_xWidth;

      pCounter->m_yPos = yPos;
      yPos += m_yLineHeight;
   }

   return yPos;
}


INT 
CReport::SetInstancePositions (
    PCObjectNode  pObject,
    HDC hDC )
{
    INT   xPos ;
    PCInstanceNode   pInstance;
    TCHAR    szParent[MAX_PATH];
    TCHAR    szInstance[MAX_PATH];

    szParent[0] = _T('\0');
    szInstance[0] = _T('\0');
    xPos = 0;

    for (pInstance = pObject->FirstInstance();
        pInstance;
        pInstance = pInstance->Next()) {
  
        if (m_bFontChange || pInstance->m_xWidth == -1) {

            if (pInstance->HasParent()) {
                pInstance->GetParentName(szParent);
                pInstance->GetInstanceName(szInstance);
                pInstance->m_xWidth = max(TextWidth(hDC, szParent), TextWidth(hDC, szInstance));
            } else {
              pInstance->m_xWidth = TextWidth(hDC, pInstance->Name());
            }
        }

        pInstance->m_xPos = xPos + max(pInstance->m_xWidth, m_xValueWidth);
        xPos = pInstance->m_xPos + xColumnMargin;
    }

    if (xPos > m_xMaxInstancePos)
         m_xMaxInstancePos = xPos;

    return xPos;
}


INT
CReport::SetObjectPositions (
    PCMachineNode pMachine,
    HDC  hDC
    )
{
   PCObjectNode  pObject;
   INT yPos;
   INT xPos;

   yPos = pMachine->m_yPos + m_yLineHeight;

   for (pObject = pMachine->FirstObject();
        pObject ;
        pObject = pObject->Next()) {
 
      if (m_bFontChange || pObject->m_xWidth == -1) {
          pObject->m_xWidth = TextWidth(hDC, pObject->Name());
      }

      if (!pObject->FirstInstance()->HasParent())
        pObject->m_yPos = yPos;
      else
        pObject->m_yPos = yPos + m_yLineHeight;

      yPos = SetCounterPositions (pObject, hDC) ;

      xPos = SetInstancePositions(pObject, hDC);

      yPos += m_yLineHeight;
   }

   return yPos;
}


INT 
CReport::SetMachinePositions (
    PCCounterTree pTree,
    HDC hDC
    )
{
   PCMachineNode   pMachine ;
   INT            yPos ;

   yPos = m_yLineHeight;

   for (pMachine = pTree->FirstMachine() ;
        pMachine ;
        pMachine = pMachine->Next())  {
   
      if (m_bFontChange || pMachine->m_xWidth == -1) {
          pMachine->m_xWidth = TextWidth(hDC, pMachine->Name());
      }

      pMachine->m_yPos = yPos;   
      yPos = SetObjectPositions (pMachine, hDC);
   }

   m_yReportHeight = yPos + yBorderHeight;

   return yPos;
}


void
CReport::DrawSelectRect (
    HDC     hDC,
    BOOL    bState
    )
{
    BOOL    bSuccess = TRUE;
    RECT    rect = {0,0,0,0};
    HBRUSH  hbrush;

    if ( NULL != m_pSelect && NULL != hDC ) {

        switch ( m_nSelectType ) {

            case MACHINE_NODE:
                rect.left = xColumnMargin;
                rect.top = ((PCMachineNode)m_pSelect)->m_yPos;
                rect.right = rect.left + ((PCMachineNode)m_pSelect)->m_xWidth;
                rect.bottom = rect.top + m_yLineHeight;
                break;

            case OBJECT_NODE:
                rect.left = xObjectMargin;
                rect.top = ((PCObjectNode)m_pSelect)->m_yPos;
                rect.right = rect.left + ((PCObjectNode)m_pSelect)->m_xWidth;
                rect.bottom = rect.top + m_yLineHeight;
                break;

            case INSTANCE_NODE:
                rect.right = m_xInstanceMargin + ((PCInstanceNode)m_pSelect)->m_xPos;
                rect.bottom = ((PCInstanceNode)m_pSelect)->m_pObject->m_yPos + m_yLineHeight;
                rect.left = rect.right - ((PCInstanceNode)m_pSelect)->m_xWidth;
                rect.top = rect.bottom - 
                             (((PCInstanceNode)m_pSelect)->HasParent() ? (2*m_yLineHeight) : m_yLineHeight);
                break;

            case COUNTER_NODE:
                rect.left = xCounterMargin;
                rect.top = ((PCCounterNode)m_pSelect)->m_yPos;
                rect.right = rect.left + ((PCCounterNode)m_pSelect)->m_xWidth;
                rect.bottom = rect.top + m_yLineHeight;
                break;

            case ITEM_NODE:
                rect.right = m_xInstanceMargin + ((PCGraphItem)m_pSelect)->m_pInstance->m_xPos;
                rect.top = ((PCGraphItem)m_pSelect)->m_pCounter->m_yPos;
                rect.left = rect.right - m_xValueWidth;
                rect.bottom = rect.top + m_yLineHeight;
                break;

            default:
                bSuccess = FALSE;
        }

        if ( bSuccess ) {
            rect.left -= 1;
            rect.right += 1;

            hbrush = CreateSolidBrush(bState ? m_pCtrl->clrFgnd() : m_pCtrl->clrBackPlot());
            if ( NULL != hbrush ) {
                FrameRect(hDC, &rect, hbrush);
                DeleteObject(hbrush);
            }
        }
    }
    return;
}

BOOL         
CReport::LargeHexValueExists ( void )
{
    PCMachineNode   pMachine = NULL;
    PCObjectNode    pObject = NULL;
    PCInstanceNode  pInstance = NULL;
    PCCounterNode   pCounter = NULL;
    PCGraphItem     pItem = NULL;
    BOOL            bLargeHexValueExists = FALSE;
            
    for (pMachine = m_pCtrl->CounterTree()->FirstMachine();
         pMachine && !bLargeHexValueExists;
         pMachine = pMachine->Next()) {

        for (pObject = pMachine->FirstObject();
             pObject && !bLargeHexValueExists;
             pObject = pObject->Next()) {
            
            for (pInstance = pObject->FirstInstance();
                 pInstance && !bLargeHexValueExists;
                 pInstance = pInstance->Next()) {
                
                pItem = pInstance->FirstItem();
    
                for (pCounter = pObject->FirstCounter();
                     pCounter && !bLargeHexValueExists;
                     pCounter = pCounter->Next()) {
                     
                    PCGraphItem pCheckItem = NULL;

                    if (pItem && pItem->m_pCounter == pCounter) {
                        pCheckItem = pItem;
                        pItem = pItem->m_pNextItem;
                    }

                    if ( pCheckItem ) {
                        if ( !( pCheckItem->m_CounterInfo.dwType & HEXMASK ) ) {
                            bLargeHexValueExists = pCheckItem->m_CounterInfo.dwType & PERF_SIZE_LARGE;
                            if ( bLargeHexValueExists ) {
                                break;
                            }
                        }
                    }
                }
            }        
        }
    }

    return bLargeHexValueExists;
}

void
CReport::DrawReportValue (
    HDC hDC,
    PCGraphItem pItem, 
    INT xPos, 
    INT yPos )
{

    TCHAR       szValue [20] = TEXT("_") ;
    double      dMax;
    double      dMin;
    double      dValue = -1.0;
    HRESULT     hr;
    long        lCtrStat;
    RECT        rect ;
    INT         iPrecision;

    if ( NULL != pItem && NULL != hDC ) {

        eReportValueTypeConstant eValueType;            
        eValueType = m_pCtrl->ReportValueType();

        if ( sysmonDefaultValue == eValueType  ) {
            // if log source display the average value
            // else display the current value
            if (m_pCtrl->IsLogSource()) {
                hr = pItem->GetStatistics(&dMax, &dMin, &dValue, &lCtrStat);
            } else {               
                hr = pItem->GetValue(&dValue, &lCtrStat);
            }               
        } else {

            if ( sysmonCurrentValue == eValueType  ) {

                hr = pItem->GetValue(&dValue, &lCtrStat);
            } else {
                double      dAvg;

                hr = pItem->GetStatistics(&dMax, &dMin, &dAvg, &lCtrStat);

                switch ( eValueType ) {
                
                    case sysmonAverage:
                        dValue = dAvg;
                        break;
                    
                    case sysmonMinimum:
                        dValue = dMin;
                        break;
                    
                    case sysmonMaximum:
                        dValue = dMax;
                        break;

                    default:
                        assert (FALSE);
                }
            }
        }

        if (SUCCEEDED(hr) && IsSuccessSeverity(lCtrStat)) {

            assert ( 0 <= dValue );

            if ( ( pItem->m_CounterInfo.dwType & ( PERF_TYPE_COUNTER | PERF_TYPE_TEXT ) ) ) {
                (dValue > dLargeValueMax) ? iPrecision = 0 : iPrecision = 3;
            } else {
                // for Numbers, no decimal places
                iPrecision = 0;
            }

            if(PDH_CSTATUS_INVALID_DATA != pItem->m_CounterInfo.CStatus ) {
                // Check for Hex values
                if ( !(pItem->m_CounterInfo.dwType & HEXMASK) ) {   
                    BOOL bLarge = pItem->m_CounterInfo.dwType & PERF_SIZE_LARGE;
                
                    FormatHex (
                        dValue,
                        szValue,
                        bLarge);
                    
                } else {
                    FormatNumber (
                            dValue,
                            szValue,
                            20,
                            12,
                            iPrecision );                   
                }   
            }
        }
        else {
            lstrcpy(szValue, szDashLine);
        }
    }
    else {
        lstrcpy(szValue, szDashLine);
    }

    rect.right = xPos - 1;
    rect.left = xPos - m_xValueWidth + 1;
    rect.top = yPos;
    rect.bottom = yPos + m_yLineHeight;

    ExtTextOut (hDC, rect.right, rect.top, ETO_CLIPPED | ETO_OPAQUE,
               &rect, szValue, lstrlen (szValue), NULL) ;
}


void 
CReport::DrawReportValues (
    HDC hDC )
{
    PCMachineNode   pMachine;
    PCObjectNode    pObject;
    PCInstanceNode  pInstance;
    PCCounterNode   pCounter;
    PCGraphItem     pItem;
    PCGraphItem     pDrawItem;

    if ( NULL != hDC ) {    

        SelectFont (hDC, m_pCtrl->Font());
        SetTextAlign (hDC, TA_RIGHT|TA_TOP);

        for (pMachine = m_pCtrl->CounterTree()->FirstMachine();
            pMachine;
            pMachine = pMachine->Next()) {

            for (pObject = pMachine->FirstObject();
                pObject;
                pObject = pObject->Next()) {

                for (pInstance = pObject->FirstInstance();
                    pInstance;
                    pInstance = pInstance->Next()) {

                    pItem = pInstance->FirstItem();
                    
                    for ( pCounter = pObject->FirstCounter();
                          pCounter;
                          pCounter = pCounter->Next()) {

                        if (pItem && pItem->m_pCounter == pCounter) {
                            pDrawItem = pItem;
                            pItem = pItem->m_pNextItem;
                        } else {
                            pDrawItem = NULL;
                        }
                        
                        DrawReportValue (
                            hDC, 
                            pDrawItem, 
                            m_xInstanceMargin + pInstance->m_xPos, 
                            pCounter->m_yPos);
                    }
                }
            }  
        }
    }
}

BOOL 
CReport::WriteFileReport ( HANDLE hFile ) 
{
    PCMachineNode   pMachine;
    PCObjectNode    pObject;
    PCInstanceNode  pInstance;
    PCCounterNode   pCounter;
    TCHAR           szName[MAX_PATH];
    TCHAR           pszTemp[2*MAX_PATH];
    PCGraphItem     pItem;
    BOOL            bStatus = TRUE;
    TCHAR           szValue[20];

    for (pMachine = m_pCtrl->CounterTree()->FirstMachine() ;
            pMachine && TRUE == bStatus;
            pMachine = pMachine->Next()) {

        lstrcpy(pszTemp,LineEndStr);   
        lstrcat(pszTemp,LineEndStr);
        lstrcat(pszTemp,ResourceString(IDS_COMPUTER));
        lstrcat(pszTemp,pMachine->Name());
        lstrcat(pszTemp,LineEndStr);
        
        bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(TCHAR) ); 

        for (pObject = pMachine->FirstObject() ;
                pObject && TRUE == bStatus;
                pObject = pObject->Next()) {

            // Write the object name line.
            
            lstrcpy(pszTemp,LineEndStr);
            lstrcat(pszTemp,ResourceString(IDS_OBJECT_NAME));
            lstrcat(pszTemp,pObject->Name());
            lstrcat(pszTemp,LineEndStr);
            // Add first tab char for instance names.
            lstrcat(pszTemp,TabStr);
       
            bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(TCHAR) );
            if (!bStatus) 
                break;
            
            // Write the first line of instance (parent) names.
            for (pInstance = pObject->FirstInstance();
                    pInstance && TRUE == bStatus;
                    pInstance = pInstance->Next()) {
                    
                // If instance has no parent, then the parent name is null, so a tab is written.
                pInstance->GetParentName(szName);

                lstrcpy(pszTemp,TabStr);
                lstrcat(pszTemp,szName);
                bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(TCHAR) );
            }
            
            if ( !bStatus )
                break;
            
            lstrcpy(pszTemp,LineEndStr);
            // Include first tab of second instance line.
            lstrcat(pszTemp,TabStr);
                
            bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(TCHAR) );

            // Write the second line of instance names.
            for (pInstance = pObject->FirstInstance();
                    pInstance && TRUE == bStatus;
                    pInstance = pInstance->Next()) {

                pInstance->GetInstanceName(szName);
                lstrcpy(pszTemp,TabStr);
                lstrcat(pszTemp,szName);

                bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(TCHAR) );
            }
            
            if (!bStatus) 
                break;

            lstrcpy(pszTemp,LineEndStr);

            bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(TCHAR) );

            for (pCounter = pObject->FirstCounter();
                    pCounter && TRUE == bStatus;
                    pCounter = pCounter->Next()) {

                // Write counter name
                lstrcpy(pszTemp,TabStr);
                lstrcat(pszTemp,pCounter->Name());

                bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(TCHAR) );

                // Write values, looping on instances                
                for ( pInstance = pObject->FirstInstance();
                        pInstance && TRUE == bStatus;
                        pInstance = pInstance->Next()) {
                    // Loop on items to find the item that matches the counter.
                    for ( pItem = pInstance->FirstItem();
                            pItem && TRUE == bStatus;
                            pItem = pItem->m_pNextItem) {
                        if ( pItem->m_pCounter == pCounter && pInstance) {
                            GetReportItemValue(pItem,szValue );
                            lstrcpy(pszTemp,TabStr);
                            lstrcat (pszTemp,szValue);

                            bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(TCHAR) );
                        }
                    }
                }
                if (!bStatus) 
                    break;
                lstrcpy(pszTemp,LineEndStr);

                bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(TCHAR) );
            }
        }
    }

    return bStatus;    
}

void 
CReport::GetReportItemValue(PCGraphItem pItem, LPTSTR szValue){

    double      dMax;
    double      dMin;
    double      dValue = -1.0;
    HRESULT     hr;
    long        lCtrStat;
    INT         iPrecision;

    if (pItem) {

        eReportValueTypeConstant eValueType;            
        eValueType = m_pCtrl->ReportValueType();

        if ( sysmonDefaultValue == eValueType  ) {
            // if log source display the average value
            // else display the current value
            if (m_pCtrl->IsLogSource()) {
                hr = pItem->GetStatistics(&dMax, &dMin, &dValue, &lCtrStat);
            } else {               
                hr = pItem->GetValue(&dValue, &lCtrStat);
            }               
        } else {

            if ( sysmonCurrentValue == eValueType  ) {

                hr = pItem->GetValue(&dValue, &lCtrStat);
            } else {
                double      dAvg;

                hr = pItem->GetStatistics(&dMax, &dMin, &dAvg, &lCtrStat);

                switch ( eValueType ) {
                
                    case sysmonAverage:
                        dValue = dAvg;
                        break;
                    
                    case sysmonMinimum:
                        dValue = dMin;
                        break;
                    
                    case sysmonMaximum:
                        dValue = dMax;
                        break;

                    default:
                        assert (FALSE);
                }
            }
        }

        if (SUCCEEDED(hr) && IsSuccessSeverity(lCtrStat)) {

            assert ( 0 <= dValue );
            (dValue > dLargeValueMax) ? iPrecision = 0 : iPrecision = 3;
            if(PDH_CSTATUS_INVALID_DATA != pItem->m_CounterInfo.CStatus ) {
                // Check for Hex values
                if ( !(pItem->m_CounterInfo.dwType & HEXMASK) ) {   
                    BOOL bLarge = pItem->m_CounterInfo.dwType & PERF_SIZE_LARGE;
                
                    FormatHex (
                        dValue,
                        szValue,
                        bLarge);
                    
                } else {
                    FormatNumber (
                            dValue,
                            szValue,
                            20,
                            12,
                            iPrecision );                   
                }   
            }
        } else {
            lstrcpy(szValue, szDashLine);
        }
    } else {
        lstrcpy(szValue, szDashLine);
    }
    return;
}

void 
CReport::DrawReportHeaders (
    HDC hDC )
{
    PCMachineNode   pMachine;
    PCObjectNode    pObject;
    PCInstanceNode  pInstance;
    PCCounterNode   pCounter;
    TCHAR           szName[MAX_PATH];
    INT             cName;
    RECT            rectMachine;
    RECT            rectObject;
    RECT            rectInstance;
    RECT            rectCounter;

    if ( NULL != hDC ) {

        SetTextAlign(hDC, TA_LEFT|TA_TOP) ;

        rectMachine.left = xColumnMargin;
        rectObject.left = xObjectMargin;
        rectCounter.left = xCounterMargin;

        for ( pMachine = m_pCtrl->CounterTree()->FirstMachine() ;
                pMachine;
                pMachine = pMachine->Next()) {
    
            rectMachine.right = rectMachine.left + pMachine->m_xWidth;
            rectMachine.top = pMachine->m_yPos;
            rectMachine.bottom = pMachine->m_yPos + m_yLineHeight;

            ExtTextOut (
                hDC, 
                xColumnMargin,
                pMachine->m_yPos, 
                ETO_OPAQUE,
                &rectMachine,
                pMachine->Name(), 
                lstrlen(pMachine->Name()),
                NULL );

            for ( pObject = pMachine->FirstObject() ;
                    pObject ;
                    pObject = pObject->Next()) {

                rectObject.right = rectObject.left + pObject->m_xWidth;
                rectObject.top = pObject->m_yPos;
                rectObject.bottom = pObject->m_yPos + m_yLineHeight;

                ExtTextOut (
                    hDC, 
                    xObjectMargin, 
                    pObject->m_yPos, 
                    ETO_OPAQUE,
                    &rectObject,
                    pObject->Name(), 
                    lstrlen (pObject->Name()),
                    NULL);

                SetTextAlign (hDC, TA_RIGHT) ;

                for ( pInstance = pObject->FirstInstance();
                        pInstance;
                        pInstance = pInstance->Next()) {
        
                    rectInstance.left = m_xInstanceMargin + pInstance->m_xPos;
                    rectInstance.right = rectInstance.left + max(pInstance->m_xWidth, m_xValueWidth);

                    if ( pInstance->HasParent() ) {

                        cName = pInstance->GetParentName(szName);
                        rectInstance.top = pObject->m_yPos - m_yLineHeight;
                        rectInstance.bottom = rectInstance.top + m_yLineHeight;
                    
                        ExtTextOut (
                            hDC, 
                            m_xInstanceMargin + pInstance->m_xPos, 
                            pObject->m_yPos - m_yLineHeight, 
                            ETO_OPAQUE,
                            &rectInstance,
                            szName, 
                            cName,
                            NULL);

                        rectInstance.top = pObject->m_yPos;
                        rectInstance.bottom = rectInstance.top + m_yLineHeight;

                        cName = pInstance->GetInstanceName(szName);
                        ExtTextOut (
                            hDC, 
                            m_xInstanceMargin + pInstance->m_xPos, 
                            pObject->m_yPos,
                            ETO_OPAQUE,
                            &rectInstance,
                            szName, 
                            cName,
                            NULL );
                    } else {
                    
                        rectInstance.top = pObject->m_yPos;
                        rectInstance.bottom = rectInstance.top + m_yLineHeight;

                        ExtTextOut (
                            hDC, 
                            m_xInstanceMargin + pInstance->m_xPos, 
                            pObject->m_yPos, 
                            ETO_OPAQUE,
                            &rectInstance,
                            pInstance->Name(),
                            lstrlen(pInstance->Name()),
                            NULL );
                    }
                }

                SetTextAlign (hDC, TA_LEFT) ;

                for (pCounter = pObject->FirstCounter();
                        pCounter ;
                        pCounter = pCounter->Next()) {

                    rectCounter.right = rectCounter.left + pCounter->m_xWidth;
                    rectCounter.top = pCounter->m_yPos;
                    rectCounter.bottom = pCounter->m_yPos + m_yLineHeight;
                
                    ExtTextOut (
                        hDC, 
                        xCounterMargin, 
                        pCounter->m_yPos, 
                        ETO_OPAQUE,
                        &rectCounter,
                        pCounter->Name(), 
                        lstrlen (pCounter->Name()),
                        NULL);
                }
            }
        }
        
        DrawSelectRect(hDC, TRUE);
    }
}


void
CReport::ApplyChanges (
    HDC hDC )
{
    if (m_bConfigChange && NULL != hDC ) {

        // Selected the Bold font for font change , counter add, and counter delete.
        // This is used for recalculating text width.
        SelectFont (hDC, m_pCtrl->BoldFont());
        m_yLineHeight = FontHeight (hDC, TRUE);  

        if ( LargeHexValueExists ( ) ) {
            m_xValueWidth = TextWidth(hDC, szValueLargeHexPlaceholder);
        } else {
            m_xValueWidth = TextWidth(hDC, szValuePlaceholder);
        }

        m_xMaxCounterWidth = 0;
        m_xMaxInstancePos = 0;

        SetMachinePositions (m_pCtrl->CounterTree(), hDC);

        m_xInstanceMargin = xCounterMargin + m_xMaxCounterWidth + xColumnMargin;
        m_xReportWidth = m_xInstanceMargin + m_xMaxInstancePos;

        SetScrollRanges();

        m_bConfigChange = FALSE;
        m_bFontChange = FALSE;
    }
}

void 
CReport::Render (
    HDC hDC,
    HDC hAttribDC,
    BOOL /*fMetafile*/,
    BOOL /*fEntire*/,
    LPRECT prcUpdate )
{
    ApplyChanges(hAttribDC);

    if ( NULL != hDC ) {
        SetBkColor(hDC, m_pCtrl->clrBackPlot());
        ClearRect(hDC, prcUpdate);
    
        Draw( hDC );
    }
}


void 
CReport::Draw (
    HDC hDC )
{
    // if no space assigned, return
    if (m_rect.top != m_rect.bottom) {

        if ( NULL != hDC ) {
            SetTextColor (hDC, m_pCtrl->clrFgnd());
            SetBkColor(hDC, m_pCtrl->clrBackPlot());

            SelectFont(hDC, m_pCtrl->BoldFont());
            DrawReportHeaders (hDC);

            SelectFont (hDC, m_pCtrl->Font());
            DrawReportValues (hDC);

            m_pCtrl->DrawBorder ( hDC );
        }
    }
}

void 
CReport::AddItem (
    PCGraphItem /* pItem */ )
{
    if (!m_bConfigChange) {
        m_bConfigChange = TRUE;
        WindowInvalidate(m_hWnd);
    }
}


void
CReport::DeleteItem (
    PCGraphItem pItem )
{
    // Calling procedure checks for NULL pItem
    assert ( NULL != pItem );
    if ( NULL != m_pSelect ) {
        if ( SelectionDeleted ( pItem ) ) {
            m_pSelect = NULL;
        }
    }

    if (!m_bConfigChange) {
        m_bConfigChange = TRUE;
        WindowInvalidate(m_hWnd);
    }
}


void
CReport::DeleteSelection (
    VOID )
{
    if (m_pSelect == NULL)
        return;

    switch (m_nSelectType) {

    case MACHINE_NODE:
        ((PCMachineNode)m_pSelect)->DeleteNode(TRUE);
        break;

    case OBJECT_NODE:
        ((PCObjectNode)m_pSelect)->DeleteNode(TRUE);
        break;

    case INSTANCE_NODE:
        ((PCInstanceNode)m_pSelect)->DeleteNode(TRUE);  
        break;

    case COUNTER_NODE:
        ((PCCounterNode)m_pSelect)->DeleteNode(TRUE);
        break;

    case ITEM_NODE:
        ((PCGraphItem)m_pSelect)->Delete(TRUE);
        break;

    default:
        return;
    }

    // DeleteItem sets m_pSelect to NULL and invalidates the window.
    assert ( NULL == m_pSelect );
}


BOOL
CReport::OnContextMenu (
    INT x,
    INT y )
{
    HMENU   hMenu;
    HMENU   hMenuPopup;
    RECT    clntRect;
    int     xPos=0,yPos=0;

    GetWindowRect(m_hWnd,&clntRect);
    if (x==0){
        xPos = ((clntRect.right - clntRect.left)/2) ;
    }else{
        xPos = x - clntRect.left;
    }
    if (y==0){
        yPos = ((clntRect.bottom - clntRect.top)/2) ;
    }else{
        yPos = y - clntRect.top;
    }

    x = clntRect.left + xPos ;
    y = clntRect.top  + yPos ;

    // if nothing is selected, let main window handle the menu
    if (m_pSelect == NULL)
        return FALSE;

    if ( m_pCtrl->ConfirmSampleDataOverwrite() ) {
        if ( !m_pCtrl->IsReadOnly() ) {
            // Get the menu for the pop-up menu from the resource file.
            hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDM_CONTEXT));
            if (!hMenu)
            return TRUE;

            // Get the first submenu in it for TrackPopupMenu. 
            hMenuPopup = GetSubMenu(hMenu, 0);

            // Draw and track the "floating" pop-up menu. 
            TrackPopupMenu(hMenuPopup, TPM_RIGHTBUTTON, x, y, 0, m_hWnd, NULL);

            // Destroy the menu.
            DestroyMenu(hMenu);
        }
    }
    return TRUE;
}


void 
CReport::Update (
    void )
{
    HDC     hDC;

    hDC = GetDC(m_hWnd);

    if ( NULL != hDC ) {

        ApplyChanges(hDC);

        SetWindowOrgEx (hDC, 
                       GetScrollPos (m_hWnd, SB_HORZ), 
                       GetScrollPos (m_hWnd, SB_VERT),
                       NULL) ;

        if ( m_rect.bottom != m_rect.top ) {
            SelectFont (hDC, m_pCtrl->Font());
            SetTextColor (hDC, m_pCtrl->clrFgnd());
            SetBkColor(hDC, m_pCtrl->clrBackPlot());

            DrawReportValues(hDC);
        }

        ReleaseDC(m_hWnd,hDC);
    }
}


void
CReport::OnPaint (
    void
)
{
    HDC             hDC ;
    PAINTSTRUCT     ps ;

    if ( m_pCtrl->DisplayMissedSampleMessage() ) {
        MessageBox(m_hWnd, ResourceString(IDS_SAMPLE_DATA_MISSING), ResourceString(IDS_APP_NAME),
                    MB_OK | MB_ICONINFORMATION);
    }

    hDC = BeginPaint (m_hWnd, &ps) ;

    if ( NULL != hDC ) {
        SelectFont (hDC, m_pCtrl->Font()) ;

        SetWindowOrgEx (
            hDC, 
            GetScrollPos (m_hWnd, SB_HORZ), 
            GetScrollPos (m_hWnd, SB_VERT),
            NULL );


        SetTextColor (hDC, m_pCtrl->clrFgnd());
        SetBkColor(hDC, m_pCtrl->clrBackPlot());

        ApplyChanges(hDC);

        Draw(hDC);

        EndPaint (m_hWnd, &ps) ;
    }
}


void
CReport::SetScrollRanges (
    void )
{
   RECT           rectClient ;
   INT            xWidth, yHeight ;

   GetClientRect (m_hWnd, &rectClient) ;
   xWidth = rectClient.right - rectClient.left ;
   yHeight = rectClient.bottom - rectClient.top ;

   SetScrollRange (m_hWnd, SB_VERT, 0, max (0, m_yReportHeight - yHeight), TRUE) ;
   SetScrollRange (m_hWnd, SB_HORZ,0, max (0, m_xReportWidth - xWidth), TRUE) ;
}

BOOL
CReport::SelectName (
    INT     xPos,
    INT     yPos,
    void**  ppSelected,
    INT*    piSelectType )
{
    POINT           pt;
    PCMachineNode   pMachine;
    PCObjectNode    pObject;
    PCCounterNode   pCounter;
    PCInstanceNode  pInstance;
    PCGraphItem     pItem;

    // Programming error if either of these two pointers is NULL.
    assert ( NULL != ppSelected );
    assert ( NULL != piSelectType );

    // Adjust coordinates by scroll offset  
    pt.x = xPos + GetScrollPos(m_hWnd, SB_HORZ);
    pt.y = yPos + GetScrollPos(m_hWnd, SB_VERT);

    for (pMachine = m_pCtrl->CounterTree()->FirstMachine() ;
        pMachine;
        pMachine = pMachine->Next()) {
            
        if (PtInName(pt, xColumnMargin, pMachine->m_yPos, pMachine->m_xWidth)) {
            *ppSelected = pMachine;
            *piSelectType = MACHINE_NODE; 
            return TRUE;
        }

        for (pObject = pMachine->FirstObject() ;
             pObject ;
             pObject = pObject->Next()) {

             if (PtInName(pt, xObjectMargin, pObject->m_yPos, pObject->m_xWidth)) {
                *ppSelected = pObject;
                *piSelectType = OBJECT_NODE; 
                return TRUE;
            }

            for (pCounter = pObject->FirstCounter();
                 pCounter ;
                 pCounter = pCounter->Next()) {

                 if (PtInName(pt, xCounterMargin, pCounter->m_yPos, pCounter->m_xWidth)) {
                    *ppSelected = pCounter;
                    *piSelectType = COUNTER_NODE; 
                    return TRUE;
                 }
            }

            for (pInstance = pObject->FirstInstance();
                 pInstance ;
                 pInstance = pInstance->Next()) {

                INT xInstancePos = m_xInstanceMargin + pInstance->m_xPos;

                if (PtInName(pt, xInstancePos - pInstance->m_xWidth, pObject->m_yPos, pInstance->m_xWidth) ||
                    (pInstance->HasParent() &&
                     PtInName(pt, xInstancePos - pInstance->m_xWidth, pObject->m_yPos - m_yLineHeight, pInstance->m_xWidth))) {
                    *ppSelected = pInstance;
                    *piSelectType = INSTANCE_NODE; 
                    return TRUE;
                 }

                if (pt.x > xInstancePos || pt.x < xInstancePos - m_xValueWidth)
                    continue;

                for (pItem = pInstance->FirstItem();
                     pItem;
                     pItem = pItem->m_pNextItem) {

                     if (pt.y > pItem->m_pCounter->m_yPos && pt.y < pItem->m_pCounter->m_yPos + m_yLineHeight) {
                         *ppSelected = pItem;
                         *piSelectType = ITEM_NODE;
                         return TRUE;
                     }
                }
             }
        }           
    }

    *ppSelected = NULL;
    return FALSE;
 }         

PCGraphItem
CReport::GetItem (
    void  *pSelected,
    INT   nSelectType ) 
{
    PCMachineNode   pMachine;
    PCObjectNode    pObject;
    PCCounterNode   pCounter;
    PCInstanceNode  pInstance;
    PCGraphItem pItem;
    PCGraphItem pReturn = NULL;
    
    if ( NULL != pSelected ) {

        switch (nSelectType) {

            case MACHINE_NODE:
                pMachine = (PCMachineNode)pSelected;
                pObject = pMachine->FirstObject();
                if ( NULL != pObject ) {
                    pInstance = pObject->FirstInstance();
                    if ( NULL != pInstance ) {
                        pReturn = pInstance->FirstItem();
                    }
                }
                break;

            case OBJECT_NODE:
                pObject = (PCObjectNode)pSelected;
                pInstance = pObject->FirstInstance();
                if ( NULL != pInstance ) {
                    pReturn = pInstance->FirstItem();
                }
                break;

            case INSTANCE_NODE:
                pInstance = (PCInstanceNode)pSelected;
                pReturn = pInstance->FirstItem();
                break;

            case COUNTER_NODE:
                pCounter = (PCCounterNode)pSelected;
                pObject = pCounter->m_pObject;
            
                for (pInstance = pObject->FirstInstance();
                     ((NULL != pInstance) && (NULL == pReturn));
                     pInstance = pInstance->Next()) {

                    for (pItem = pInstance->FirstItem();
                         ((NULL != pItem) && (NULL == pReturn));
                         pItem = pItem->m_pNextItem) {
                   
                        if (pItem && pItem->m_pCounter == pCounter) {                         
                            pReturn = pItem;
                        }
                    }
                }
                break;

            case ITEM_NODE:
                pReturn = (PCGraphItem)pSelected;
                break;

            default:
                break;
        }
    }
    return pReturn;
}
    
BOOL
CReport::SelectionDeleted (
    PCGraphItem pDeletedItem )
{
    BOOL            bSelectionDeleted = FALSE;
    INT             iItemCount = 0;
    PCMachineNode   pMachine;
    PCObjectNode    pObject;
    PCCounterNode   pCounter;
    PCInstanceNode  pInstance;
    PCGraphItem     pItem;

    if ( NULL == m_pSelect ) 
        return FALSE;

    // Delete the selection if this is the last remaining
    // item for the selection object.
    
    switch (m_nSelectType) {

        case MACHINE_NODE:
            // Check for  multiple items for this machine.            
            pMachine = (PCMachineNode)m_pSelect;

            for ( pObject = pMachine->FirstObject();
                  ( NULL != pObject ) && ( 2 > iItemCount );
                  pObject = pObject->Next()) {

                for ( pInstance = pObject->FirstInstance();
                      ( NULL != pInstance ) && ( 2 > iItemCount );
                      pInstance = pInstance->Next()) {
                    
                    for ( pItem = pInstance->FirstItem();
                          ( NULL != pItem ) && ( 2 > iItemCount );
                          pItem = pItem->m_pNextItem) {
           
                        iItemCount++;
                    }
                }
            }
            bSelectionDeleted = ( iItemCount < 2 );
            break;

        case OBJECT_NODE:
            // Check for  multiple items for this object.
            pObject = (PCObjectNode)m_pSelect;

            for ( pInstance = pObject->FirstInstance();
                  ( NULL != pInstance ) && ( 2 > iItemCount );
                  pInstance = pInstance->Next()) {
                for ( pItem = pInstance->FirstItem();
                     ( NULL != pItem ) && ( 2 > iItemCount );
                     pItem = pItem->m_pNextItem) {
           
                    iItemCount++;
                }
            }
            bSelectionDeleted = ( iItemCount < 2 );
            break;

        case INSTANCE_NODE:
            // Check for  multiple items (counters) for this instance.
            pInstance = (PCInstanceNode)m_pSelect;
            iItemCount = 0;

            for ( pItem = pInstance->FirstItem();
                  ( NULL != pItem ) && ( 2 > iItemCount );
                  pItem = pItem->m_pNextItem) {
           
                iItemCount++;
            }
            bSelectionDeleted = ( iItemCount < 2 );
            break;

        case COUNTER_NODE:

            // Check for multiple items (instances) for this counter.
            pCounter = (PCCounterNode)m_pSelect;
            pObject = pCounter->m_pObject;

            for ( pInstance = pObject->FirstInstance();
                  ( NULL != pInstance ) && ( 2 > iItemCount );
                  pInstance = pInstance->Next()) {

                for ( pItem = pInstance->FirstItem();
                      ( NULL != pItem ) && ( 2 > iItemCount );
                      pItem = pItem->m_pNextItem) {
               
                    if (pItem && pItem->m_pCounter == pCounter) {                         
                        iItemCount++;
                        break;
                    }
                }
            }
            bSelectionDeleted = ( iItemCount < 2 );
            break;

        case ITEM_NODE:
            // Selection matches the deleted item.
            bSelectionDeleted = ( pDeletedItem == (PCGraphItem)m_pSelect );
            break;

        default:
            break;
    }

    return bSelectionDeleted;
}         

void 
CReport::OnLButtonDown (
    INT xPos,
    INT yPos )
{
    PCGraphItem pItem;
    HDC hDC = GetDC(m_hWnd);

    if ( NULL != hDC ) {
        SetWindowOrgEx (
            hDC, 
            GetScrollPos (m_hWnd, SB_HORZ), 
            GetScrollPos (m_hWnd, SB_VERT),
            NULL) ;

        DrawSelectRect(hDC, FALSE);

        if ( SelectName(xPos, yPos, &m_pSelect, &m_nSelectType) )
            DrawSelectRect(hDC, TRUE);

        ReleaseDC(m_hWnd, hDC);

        pItem = GetItem(m_pSelect, m_nSelectType);
        m_pCtrl->SelectCounter(pItem);
    }
    return;
}

void 
CReport:: OnDblClick (
    INT, // xPos,
    INT // yPos
    )
{
    PCGraphItem pItem;

    pItem = GetItem ( m_pSelect, m_nSelectType );

    m_pCtrl->DblClickCounter ( pItem );
}

void
CReport::OnHScroll (
    INT iScrollCode,
    INT iScrollNewPos )
{
   INT            iScrollAmt, iScrollPos, iScrollRange ;
   INT            iScrollLo ;
   RECT           rectClient ;
   INT            xWidth ;

   GetClientRect (m_hWnd, &rectClient) ;
   xWidth = rectClient.right - rectClient.left ;

   if (m_xReportWidth <= xWidth)
      return ;

   iScrollPos = GetScrollPos (m_hWnd, SB_HORZ) ;
   GetScrollRange (m_hWnd, SB_HORZ, &iScrollLo, &iScrollRange) ;

   switch (iScrollCode)
      {
      case SB_LINEUP:
           iScrollAmt = - m_yLineHeight ;
           break ;

      case SB_LINEDOWN:
           iScrollAmt = m_yLineHeight ;
           break ;

      case SB_PAGEUP:
           iScrollAmt = - (rectClient.right - rectClient.left) / 2 ;
           break ;

      case SB_PAGEDOWN:
           iScrollAmt = (rectClient.right - rectClient.left) / 2 ;
           break ;

      case SB_THUMBPOSITION:
           iScrollAmt = iScrollNewPos - iScrollPos ;
           break ;

      default:
           iScrollAmt = 0 ;
      }

     iScrollAmt = PinInclusive (iScrollAmt,
                                -iScrollPos,
                                iScrollRange - iScrollPos) ;
     if (iScrollAmt) {
        iScrollPos += iScrollAmt ;
        ScrollWindow (m_hWnd, -iScrollAmt, 0, NULL, NULL) ;
        SetScrollPos (m_hWnd, SB_HORZ, iScrollPos, TRUE) ;
        UpdateWindow (m_hWnd) ;
       }
}

void
CReport::OnVScroll (
    INT iScrollCode,
    INT iScrollNewPos
    )
{
   INT            iScrollAmt, iScrollPos, iScrollRange ;
   INT            iScrollLo ;
   RECT           rectClient ;

   iScrollPos = GetScrollPos (m_hWnd, SB_VERT) ;
   GetScrollRange (m_hWnd, SB_VERT, &iScrollLo, &iScrollRange) ;
   GetClientRect (m_hWnd, &rectClient) ;

   switch (iScrollCode) {
      case SB_LINEUP:
           iScrollAmt = - m_yLineHeight ;
           break ;

      case SB_LINEDOWN:
           iScrollAmt = m_yLineHeight ;
           break ;

      case SB_PAGEUP:
           iScrollAmt = - (rectClient.bottom - rectClient.top) / 2 ;
           break ;

      case SB_PAGEDOWN:
           iScrollAmt = (rectClient.bottom - rectClient.top) / 2 ;
           break ;

      case SB_THUMBPOSITION:
           iScrollAmt = iScrollNewPos - iScrollPos ;
           break ;

      default:
           iScrollAmt = 0 ;
  }

  iScrollAmt = PinInclusive (iScrollAmt, -iScrollPos, iScrollRange - iScrollPos) ;
  if (iScrollAmt) {
        iScrollPos += iScrollAmt ;
        ScrollWindow (m_hWnd, 0, -iScrollAmt, NULL, NULL) ;
        SetScrollPos (m_hWnd, SB_VERT, iScrollPos, TRUE) ;

        UpdateWindow (m_hWnd) ;
   }
}

 
//
// Window procedure
//
LRESULT APIENTRY 
ReportWndProc (
    HWND hWnd, 
    UINT uiMsg, 
    WPARAM wParam,
    LPARAM lParam )
{
    PREPORT pReport = NULL;
    BOOL    bCallDefProc = TRUE;
    LRESULT lReturnValue = 0L;
    RECT    rect;
    
    // hWnd is used to dispatch to window procedure, so major error if it is NULL.
    assert ( NULL != hWnd );

    pReport = (PREPORT)GetWindowLongPtr(hWnd,0);

    if ( NULL == pReport ) {
        if ( WM_CREATE == uiMsg && NULL != lParam ) {
            pReport = (PREPORT)((CREATESTRUCT*)lParam)->lpCreateParams;
            SetWindowLongPtr(hWnd,0,(INT_PTR)pReport);
        } else {
            // Programming error
            assert ( FALSE );
        }

    } else {
    
        bCallDefProc = FALSE ;

        switch (uiMsg) {

            case WM_DESTROY:
                break ;

            case WM_LBUTTONDOWN:
                if (!pReport->m_pCtrl->IsUIDead()) { 

    //                pReport->m_pCtrl->Activate();
    //                pReport->m_pCtrl->AssignFocus();

                    pReport->OnLButtonDown(LOWORD (lParam), HIWORD (lParam));
                }
                break;

            case WM_CONTEXTMENU:
                if (!pReport->m_pCtrl->IsUIDead()) {

    //                pReport->m_pCtrl->Activate();
    //                pReport->m_pCtrl->AssignFocus();

                      // *** DefWindowProc is not Smonctrl, so context menu not happening.              
                    if (LOWORD(lParam)!= 0xffff || HIWORD(lParam) != 0xffff){
                        // Always call the default procedure, to handle the case where the
                        // context menu is activated from within a select rectangle.
                        bCallDefProc = TRUE;
                    }else {
                        if (!pReport->OnContextMenu(0,0))
                            bCallDefProc = TRUE;
                    }
                }
                break;

            case WM_LBUTTONDBLCLK:

                if (!pReport->m_pCtrl->IsUIDead()) { 

    //                pReport->m_pCtrl->Activate();
    //                pReport->m_pCtrl->AssignFocus();

                    pReport->OnDblClick(LOWORD (lParam), HIWORD (lParam));            
                }
        
                break;

            case WM_ERASEBKGND:
                GetClientRect(hWnd, &rect);
                SetBkColor((HDC)wParam, pReport->m_pCtrl->clrBackPlot());
                ClearRect((HDC)wParam, &rect);
                lReturnValue = TRUE; 
                break;

            case WM_PAINT:
                pReport->OnPaint () ;
                break ;

            case WM_HSCROLL:
                pReport->OnHScroll (LOWORD (wParam), HIWORD (wParam)) ;
                break ;

            case WM_VSCROLL:
                pReport->OnVScroll (LOWORD (wParam), HIWORD (wParam)) ;
                break ;

            case WM_COMMAND:
                if (pReport->m_pCtrl->IsUIDead())
                    break;

                switch (LOWORD(wParam)) {

                    case IDM_REPORT_COPY:
                    case IDM_REPORT_COPYALL:
                        break;

                    case IDM_REPORT_DELETE:
                        pReport->DeleteSelection();
                        break;

                    case IDM_PROPERTIES:
                        pReport->m_pCtrl->DisplayProperties();
                        break;

                    case IDM_ADDCOUNTERS:
                        pReport->m_pCtrl->AddCounters();
                        break;

                    case IDM_SAVEAS:
                        pReport->m_pCtrl->SaveAs();
                        break;

                    default:
                        bCallDefProc = TRUE;
               }
               break;

            default:
                bCallDefProc = TRUE ;
        }
    }

    if (bCallDefProc)
        lReturnValue = DefWindowProc (hWnd, uiMsg, wParam, lParam) ;

    return (lReturnValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\register.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    register.cpp

Abstract:

    Routines for registering and unregistering control

--*/

#include "polyline.h"
#include "genprop.h"
#include "ctrprop.h"
#include "grphprop.h"
#include "srcprop.h"
#include "appearprop.h"
#include "unihelpr.h"
#include "cathelp.h"
#include "smonctrl.h"   // Version information
#include <stdio.h>

void RegisterPropPage(const CLSID &clsid, LPTSTR szName, LPTSTR szModule);
void UnregisterPropPage(const CLSID &clsid);

BOOL CreateKeyAndValue(HKEY hKeyParent, LPTSTR pszKey, LPTSTR pszValue, HKEY* phKeyReturn);
LONG RegDeleteKeyTree(HKEY hStartKey, LPTSTR pKeyName);


#define MAX_KEY_LENGTH  256
#define MAX_GUID_STRING_LENGTH 39
#define VERSION_STRING_LENGTH  22
#define MISC_STATUS_VALUE TEXT("131473")    // 131473 = 0x20191 = RECOMPOSEONRESIZE | CANTLINKINSIDE | INSIDEOUT
                                            //                     | ACTIVEWHENVISIBLE | SETCLIENTSITEFIRST

/*
 * DllRegisterServer
 *
 * Purpose:
 *  Entry point to register the controls and prop pages
 */
// __declspec(dllexport)
STDAPI DllRegisterServer( VOID )
    {
    OLECHAR     szGUIDW[MAX_GUID_STRING_LENGTH];
    TCHAR       szCLSID[MAX_KEY_LENGTH];
    TCHAR       szModule[MAX_PATH];
    LPTSTR      pszGUID;
    HKEY        hKey,hSubkey;
    TCHAR       szVersion[VERSION_STRING_LENGTH + 1];
    TCHAR       szSysmonVer[MAX_PATH];

    USES_CONVERSION

    // Get name of this module
    GetModuleFileName(g_hInstance, szModule, MAX_PATH);

    // Create Control CLSID string
    StringFromGUID2(CLSID_SystemMonitor, szGUIDW, sizeof(szGUIDW)/sizeof(OLECHAR));
    pszGUID = W2T(szGUIDW);

    // Create ProgID keys
    _stprintf ( szSysmonVer, TEXT("Sysmon.%d"), SMONCTRL_MAJ_VERSION );    

    if (CreateKeyAndValue(HKEY_CLASSES_ROOT, szSysmonVer, TEXT("System Monitor Control"), &hKey)) {

        CreateKeyAndValue(hKey, TEXT("CLSID"),      pszGUID,    NULL);
        CreateKeyAndValue(hKey, TEXT("Insertable"), NULL,       NULL);
        RegCloseKey(hKey);
    }

    // Create VersionIndependentProgID keys
    if (CreateKeyAndValue(HKEY_CLASSES_ROOT, TEXT("Sysmon"), TEXT("System Monitor Control"), &hKey)) {

        CreateKeyAndValue(hKey, TEXT("CurVer"), szSysmonVer,   NULL);
        CreateKeyAndValue(hKey, TEXT("CLSID"),  pszGUID,            NULL);
        RegCloseKey(hKey);
    }

    // Create entries under CLSID
    _stprintf ( szVersion, TEXT("%d.%d"), SMONCTRL_MAJ_VERSION, SMONCTRL_MIN_VERSION );    

    lstrcpy(szCLSID, TEXT("CLSID\\"));
    lstrcat(szCLSID, pszGUID);
    if (CreateKeyAndValue(HKEY_CLASSES_ROOT, szCLSID, TEXT("System Monitor Control"), &hKey)) {

        CreateKeyAndValue(hKey, TEXT("ProgID"),                     szSysmonVer,   NULL);
        CreateKeyAndValue(hKey, TEXT("VersionIndependentProgID"),   TEXT("Sysmon"),     NULL);
        CreateKeyAndValue(hKey, TEXT("Insertable"),                 NULL,               NULL);
        CreateKeyAndValue(hKey, TEXT("Control"),                    NULL,               NULL);
        CreateKeyAndValue(hKey, TEXT("MiscStatus\\1"),              MISC_STATUS_VALUE,  NULL);
        CreateKeyAndValue(hKey, TEXT("Version"),                    szVersion,          NULL);

        // Create InprocServer32 key and add ThreadingModel value
        if (CreateKeyAndValue(hKey, TEXT("InprocServer32"), szModule, &hSubkey)) {
            RegSetValueEx(hSubkey, TEXT("ThreadingModel"), 0, REG_SZ, (BYTE *)TEXT("Apartment"), 
                          sizeof(TEXT("Apartment")));
            RegCloseKey(hSubkey);
        }       

        // Create Typelib entry
        StringFromGUID2(LIBID_SystemMonitor, szGUIDW, sizeof(szGUIDW)/sizeof(OLECHAR));
        pszGUID = W2T(szGUIDW);
        CreateKeyAndValue(hKey, TEXT("TypeLib"), pszGUID, NULL);

        RegCloseKey(hKey);
    }

    // Create type library entries under Typelib
    lstrcpy(szCLSID, TEXT("TypeLib\\"));
    lstrcat(szCLSID, pszGUID);
    lstrcat(szCLSID, TEXT("\\"));
    lstrcat(szCLSID, szVersion );

    if (CreateKeyAndValue(HKEY_CLASSES_ROOT, szCLSID, TEXT("System Monitor Control"), &hKey)) {

        CreateKeyAndValue(hKey, TEXT("0\\win32"), szModule, NULL);
        RegCloseKey(hKey);
    }

    // Register property pages
    RegisterPropPage(CLSID_CounterPropPage,
                     TEXT("System Monitor Data Properties"), szModule);
                     
    RegisterPropPage(CLSID_GeneralPropPage,
                     TEXT("System Monitor General Properties"), szModule);

    RegisterPropPage(CLSID_AppearPropPage,
                     TEXT("System Monitor Appearance Properties"), szModule);

    RegisterPropPage(CLSID_GraphPropPage,
                     TEXT("System Monitor Graph Properties"), szModule);

    RegisterPropPage(CLSID_SourcePropPage,
                     TEXT("System Monitor Source Properties"), szModule);
    //
    // Delete component categories if they are there
    //
    UnRegisterCLSIDInCategory(CLSID_SystemMonitor, CATID_SafeForScripting);
    UnRegisterCLSIDInCategory(CLSID_SystemMonitor, CATID_SafeForInitializing);


    return NOERROR;
}



/* 
    RegisterPropPage - Create registry entries for property page 
*/
void RegisterPropPage(const CLSID &clsid, LPTSTR szName, LPTSTR szModule)
{
    OLECHAR     szIDW[MAX_GUID_STRING_LENGTH];
    TCHAR       szKey[MAX_KEY_LENGTH];
    LPTSTR      pszID;
    HKEY        hKey,hSubkey;

    USES_CONVERSION

    //Create Counter Property page CLSID string
    StringFromGUID2(clsid, szIDW, sizeof(szIDW)/sizeof(OLECHAR));
    pszID = W2T(szIDW);

    lstrcpy(szKey, TEXT("CLSID\\"));
    lstrcat(szKey, pszID);

    // Create entries under CLSID
    if (CreateKeyAndValue(HKEY_CLASSES_ROOT, szKey, szName, &hKey)) {

        // Create InprocServer32 key and add ThreadingModel value
        if (CreateKeyAndValue(hKey, TEXT("InprocServer32"), szModule, &hSubkey)) {
            RegSetValueEx(hSubkey, TEXT("ThreadingModel"), 0, REG_SZ, (BYTE *)TEXT("Apartment"), 
                          sizeof(TEXT("Apartment")));
            RegCloseKey(hSubkey);
        }
        
        RegCloseKey(hKey);
    }
}


/*
 * DllUnregisterServer
 *
 * Purpose:
 *  Entry point to unregister controls and prop pages 
 */
// __declspec(dllexport)  
STDAPI DllUnregisterServer(VOID)
{
    OLECHAR     szGUIDW[MAX_GUID_STRING_LENGTH];
    TCHAR       szCLSID[MAX_KEY_LENGTH];
    TCHAR       szSysmonVer[MAX_PATH];
    LPTSTR      pszGUID;

    USES_CONVERSION

    // Create graph CLSID
    StringFromGUID2(CLSID_SystemMonitor, szGUIDW, sizeof(szGUIDW)/sizeof(OLECHAR));
    pszGUID = W2T(szGUIDW);
    lstrcpy(szCLSID, TEXT("CLSID\\"));
    lstrcat(szCLSID, pszGUID);

    // Delete component categories 
    UnRegisterCLSIDInCategory(CLSID_SystemMonitor, CATID_SafeForScripting);
    UnRegisterCLSIDInCategory(CLSID_SystemMonitor, CATID_SafeForInitializing);

    // Delete ProgID and VersionIndependentProgID keys and subkeys
    _stprintf ( szSysmonVer, TEXT("Sysmon.%d"), SMONCTRL_MAJ_VERSION );    
    RegDeleteKeyTree(HKEY_CLASSES_ROOT, TEXT("Sysmon"));
    RegDeleteKeyTree(HKEY_CLASSES_ROOT, szSysmonVer);
    // Delete Program ID of Beta 3 control.
    RegDeleteKeyTree(HKEY_CLASSES_ROOT, TEXT("Sysmon.2"));

    // Delete entries under CLSID
    RegDeleteKeyTree(HKEY_CLASSES_ROOT, szCLSID);

    // Delete entries under TypeLib
    StringFromGUID2(LIBID_SystemMonitor, szGUIDW, sizeof(szGUIDW)/sizeof(OLECHAR));
    pszGUID = W2T(szGUIDW);
    lstrcpy(szCLSID, TEXT("TypeLib\\"));
    lstrcat(szCLSID, pszGUID);

    RegDeleteKeyTree(HKEY_CLASSES_ROOT, szCLSID);
    
    // Delete property page entries
    UnregisterPropPage(CLSID_CounterPropPage);
    UnregisterPropPage(CLSID_GraphPropPage);
    UnregisterPropPage(CLSID_AppearPropPage);
    UnregisterPropPage(CLSID_GeneralPropPage);
    UnregisterPropPage(CLSID_SourcePropPage);

    return NOERROR;
}


/* 
    UnregisterPropPage - Delete registry entries for property page 
*/
void UnregisterPropPage(const CLSID &clsid)
{
    OLECHAR     szIDW[MAX_GUID_STRING_LENGTH];
    TCHAR       szCLSID[MAX_KEY_LENGTH];
    LPTSTR      pszID;

    USES_CONVERSION

     // Create Counter Property page CLSID string
    StringFromGUID2(clsid, szIDW, sizeof(szIDW)/sizeof(OLECHAR));
    pszID = W2T(szIDW);
    lstrcpy(szCLSID, TEXT("CLSID\\"));
    lstrcat(szCLSID, pszID);

    // Delete entries under CLSID
    RegDeleteKeyTree(HKEY_CLASSES_ROOT, szCLSID);
}


/*
 * CreateKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates a key
 *  and optionally sets a value. The caller may request the return of
 *  the key handle, or have it automatically closed
 *
 * Parameters:
 *  hKeyParent      HKEY of parent for the new key
 *  pszSubkey       LPTSTR to the name of the key
 *  pszValue        LPTSTR to the value to store (or NULL)
 *  hKeyReturn      Pointer to returned key handle (or NULL to close key)
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 */

BOOL CreateKeyAndValue(HKEY hKeyParent, LPTSTR pszKey, LPTSTR pszValue, HKEY *phKeyReturn)
    {
    HKEY      hKey;

    if (ERROR_SUCCESS != RegCreateKeyEx(hKeyParent, pszKey, 0, NULL,REG_OPTION_NON_VOLATILE, 
                                         KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL != pszValue) {
        RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE *)pszValue
            , (lstrlen(pszValue)+1) * sizeof(TCHAR));
    }

    if (phKeyReturn == NULL)
        RegCloseKey(hKey);
    else
        *phKeyReturn = hKey;

    return TRUE;
}


/*
 * RegDeleteKeyTree
 *
 * Purpose:
 *  This function recursively deletes all the subkeys of a registry key
 *  then deletes the key itself.
 *
 * Parameters:
 *  hStartKey       Handle to key containing key to delete
 *  pszSubkey       Name of root of key tree to delete
 *
 * Return Value:
 *  DWORD            Error code
 */


LONG 
RegDeleteKeyTree( 
    HKEY hStartKey, 
    LPTSTR pKeyName 
    )
{
   DWORD   lRtn, dwSubKeyLength;
   TCHAR   szSubKey[MAX_KEY_LENGTH];
   HKEY    hKey;
 
   if (pKeyName != NULL && pKeyName[0] != 0) {
       if ( (lRtn = RegOpenKeyEx(hStartKey, pKeyName,
             0, KEY_ENUMERATE_SUB_KEYS | DELETE, &hKey )) == ERROR_SUCCESS) {

            while (lRtn == ERROR_SUCCESS) {

                dwSubKeyLength = MAX_KEY_LENGTH;
                lRtn = RegEnumKeyEx(
                               hKey,
                               0,       // always index zero
                               szSubKey,
                               &dwSubKeyLength,
                               NULL,
                               NULL,
                               NULL,
                               NULL
                             );
 
                if (lRtn == ERROR_NO_MORE_ITEMS) {
                   lRtn = RegDeleteKey(hStartKey, pKeyName);
                   break;
                }
                else if (lRtn == ERROR_SUCCESS) {
                   lRtn = RegDeleteKeyTree(hKey, szSubKey);
                }
             }

             RegCloseKey(hKey);
       }
   }
   else {
       lRtn = ERROR_BADKEY;
   }

   return lRtn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\report.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    report.h

Abstract:

    Header file for the report view.

--*/

#ifndef _REPORT_H_
#define _REPORT_H_

#include "commctrl.h"

class CSysmonControl;
 
class CReport
{
friend LRESULT APIENTRY ReportWndProc (HWND hWnd,
                                       UINT uiMsg,
                                       WPARAM wParam,
                                       LPARAM lParam);

private:

    CSysmonControl *m_pCtrl;
    HWND             m_hWnd;
    RECT             m_rect;
    INT              m_xValueWidth;
    INT              m_xReportWidth;
    INT              m_yReportHeight;
    INT              m_yLineHeight;
    INT              m_xMaxCounterWidth;
    INT              m_xMaxInstancePos;
    INT              m_xInstanceMargin;
    void             *m_pSelect;
    INT              m_nSelectType;
    BOOL             m_bConfigChange;
    BOOL             m_bFontChange;

    void OnPaint        ( void );
    void SetScrollRanges ( void );
    void OnHScroll ( INT iScrollCode, INT iScrollNewPos );
    void OnVScroll ( INT iScrollCode, INT iScrollNewPos );
    void OnLButtonDown ( INT xPos, INT yPos );
    BOOL OnContextMenu ( INT xPos, INT yPos );
    void OnDblClick ( INT xPos, INT yPos );

    INT SetCounterPositions ( PCObjectNode pObject, HDC hDC );
    INT SetInstancePositions ( PCObjectNode pObject, HDC hDC );
    INT SetObjectPositions ( PCMachineNode pMachine, HDC hDC );
    INT SetMachinePositions ( PCCounterTree pTree, HDC hDC );
    
    void DrawReportHeaders ( HDC hDC );
    void DrawReportValues ( HDC hDC );
    void DrawReportValue ( HDC hDC, PCGraphItem pItem, INT xPos, INT yPos );
    void DrawSelectRect ( HDC hDC, BOOL bState );
    void Draw ( HDC hDC );
    void ApplyChanges ( HDC hDC );

    BOOL SelectName ( INT xPos, INT yPos, void **ppSelected, INT *nSelectType );
    BOOL PtInName ( POINT pt, INT x, INT y, INT xWidth )
        { return (pt.x > x && pt.x < (x + xWidth) && pt.y > y && pt.y < (y + m_yLineHeight)); } 
    PCGraphItem GetItem ( void *pSelected, INT nSelectType );
    BOOL        SelectionDeleted ( PCGraphItem pItem );
    BOOL        LargeHexValueExists ( void );
    void        GetReportItemValue(PCGraphItem pItem, LPTSTR szValue);
public:
    CReport         ( void );
    ~CReport        ( void );

    BOOL  Init ( CSysmonControl *pCtrl, HWND hWndParent ) ;
    void  AddItem ( PCGraphItem pItem );
    void  DeleteItem ( PCGraphItem pItem );
    void  DeleteSelection ( VOID );
    void  SizeComponents ( LPRECT pRect );
    void  ChangeFont ( void );
    HWND  Window ( void ) { return m_hWnd; }
    void  Update ( void );
    void  Render ( HDC hDC, HDC hAttribDC, BOOL fMetafile, BOOL fEntire, LPRECT pRect );
    BOOL  WriteFileReport(HANDLE hFile);
};

typedef CReport *PREPORT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\scale.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    scale.cpp

Abstract:

    Implements display of the scale numbers on the graph y-axis.

--*/

#include "polyline.h"
#include <stdio.h>

#define SCALE_MARGIN 10

CGraphScale::CGraphScale( void )
:   m_iMaxValue(100),
    m_iMinValue(0),
    m_nTics(0),
    m_iTextHeight(0)
{
}

CGraphScale::~CGraphScale( void )
{
}

void CGraphScale::SetRect( PRECT pRect )
 {
    m_Rect = *pRect;
    SetTicPositions();
 }

 void CGraphScale::SetMaxValue( INT iMaxValue )
 {
    m_iMaxValue = iMaxValue;
    SetTicPositions();
}

 void CGraphScale::SetMinValue( INT iMinValue )
 {
    m_iMinValue = iMinValue;
    SetTicPositions();
}

  void CGraphScale::SetTicPositions( void )
 {
    INT iHeight;
    INT nMaxTics;
    INT i;
    CStepper  stepper;
    static INT aiTicTable[] = {25,20,10,5,4,2,1,0};

    iHeight = m_Rect.bottom - m_Rect.top;

    if (!(iHeight > 0 && m_iTextHeight > 0)) {
        m_nTics = 0;
        return;
    }

    // Determine number of labels that will fit
    nMaxTics = iHeight / (m_iTextHeight + m_iTextHeight/2);
    for (i=0; nMaxTics < aiTicTable[i]; i++) {};
    m_nTics = aiTicTable[i];

    // Don't have more labels than values
    if (m_iMaxValue - m_iMinValue < m_nTics)
        m_nTics = m_iMaxValue - m_iMinValue;

    // Locate equally spaced tic marks
    if (m_nTics > 0)
        {
        m_aiTicPos[0] = 0;
        stepper.Init(iHeight,m_nTics);

        for (i = 1; i <= m_nTics; i++)
            {
            m_aiTicPos[i] = stepper.NextPosition();
            }
        }
   }

INT CGraphScale::GetTicPositions( INT **piTics )
{
    *piTics = m_aiTicPos;
    return m_nTics;
}

INT CGraphScale::GetWidth (HDC hDC)
{
    TCHAR   szMaxValue [20] ;
    SIZE    Size;
    INT     iWidth;

    // compute size of largest possible numerical label plus space
    if ( 0 != FormatNumber ( 
                (double)m_iMaxValue, 
                szMaxValue, 
                20, 
                eMinimumWidth, 
                eFloatPrecision) ) {
   
        GetTextExtentPoint32(hDC, szMaxValue, lstrlen(szMaxValue), &Size);

        // Save Text height for tic calculations
        m_iTextHeight = Size.cy;

        iWidth = Size.cx + SCALE_MARGIN;
    } else {
        iWidth = 0;
    }

    return iWidth;
}


void CGraphScale::Draw (HDC hDC)
{
    TCHAR   szScale [20] ;

    INT     iRetChars,
            i,
            iUnitsPerLine ;
    INT    iRange;

    FLOAT   ePercentOfTotal  ;
    FLOAT   eDiff ;
    BOOL    bUseFloatingPt = FALSE ;
    RECT    rectClip;

    // nTicks may be zero if the screen size if getting too small
    if (m_nTics < 1 || m_iMaxValue <= m_iMinValue)
        return;

    iRange = m_iMaxValue - m_iMinValue;

    // Calculate what percentage of the total each line represents.
    ePercentOfTotal = ((FLOAT) 1.0) / ((FLOAT) m_nTics)  ;

    // Calculate the amount (number of units) of the Vertical max each
    // each line in the graph represents.
    iUnitsPerLine = (INT) ((FLOAT) iRange * ePercentOfTotal) ;
    ePercentOfTotal *= (FLOAT) iRange;
    eDiff = (FLOAT)iUnitsPerLine - ePercentOfTotal ;
    if (eDiff < (FLOAT) 0.0)
        eDiff = -eDiff ;

    if ( (iUnitsPerLine < 100) 
        && (eDiff > (FLOAT) 0.1) ) {
        bUseFloatingPt = TRUE ;
    }

    SetTextAlign (hDC, TA_TOP | TA_RIGHT) ;

    rectClip.left = m_Rect.left;
    rectClip.right = m_Rect.right - SCALE_MARGIN;

    // Now Output each string.
    for (i = 0; i < m_nTics; i++) {
        if (bUseFloatingPt) {

            FLOAT fValue = (FLOAT)m_iMaxValue - ((FLOAT)i * ePercentOfTotal);

            iRetChars = FormatNumber ( 
                            (double)fValue, 
                            szScale, 
                            20, 
                            eMinimumWidth, 
                            eFloatPrecision); 

        } else {
            iRetChars = _stprintf (szScale, TEXT("%d"), 
                    m_iMaxValue - (i * iUnitsPerLine)) ;
        }

        rectClip.top = m_aiTicPos[i] + m_Rect.top - m_iTextHeight/2;
        rectClip.bottom = rectClip.top + m_iTextHeight;
        
        ExtTextOut (
            hDC,
            rectClip.right,
            rectClip.top,
            0,
            &rectClip,
            szScale,
            lstrlen(szScale),
            NULL );
    }

    // Make sure the last value is the specified Minimum.
    if (bUseFloatingPt) {

        iRetChars = FormatNumber ( 
                        (double)m_iMinValue, 
                        szScale, 
                        20, 
                        eMinimumWidth, 
                        eFloatPrecision);

    } else {
        iRetChars = _stprintf (szScale, TEXT("%d"), m_iMinValue) ;
    }

    rectClip.top = m_aiTicPos[i] + m_Rect.top - m_iTextHeight/2;
    rectClip.bottom = rectClip.top + m_iTextHeight;

    ExtTextOut (
        hDC,
        rectClip.right,
        rectClip.top,
        0,
        &rectClip,
        szScale,
        lstrlen(szScale),
        NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\scale.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    scale.h

Abstract:

    <abstract>

--*/

#ifndef _GRAPHSCALE_H_
#define _GRAPHSCALE_H_

#define MAX_SCALE_TICS  25

class CGraphScale
{
    RECT    m_Rect;             // Scale boundary rect
    INT     m_iMaxValue;        // Upper scale limit
    INT     m_iMinValue;        // Lower scale limit
    INT     m_iTextHeight;      // Height of font
    INT     m_nTics;            // Number of tic marks
    INT     m_aiTicPos[MAX_SCALE_TICS + 1];  // Tic positions

    void SetTicPositions( void );

    enum eScaleFormat {
        eMinimumWidth = 1,
        eFloatPrecision = 1,
        eIntegerPrecision = 0
    };


public:
            CGraphScale( void );
    virtual ~CGraphScale( void );
    
    void SetMaxValue( INT iMaxValue );
    void SetMinValue( INT iMinValue );
    void SetRect( PRECT pRect );

    void Draw( HDC hDC );
    INT  GetWidth( HDC hDC );
    INT  GetTicPositions( INT **piTicPos );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\smonprop.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    smonprop.h

Abstract:

    Header file for the sysmon property page base class.

--*/

#ifndef _SMONPROP_H_
#define _SMONPROP_H_

#define GUIDS_FROM_TYPELIB

#include "inole.h"
#include <pdh.h>

#define WM_SETPAGEFOCUS     (WM_USER+1000)

//Get definitions for the object we work with
#include "isysmon.h"

// Property page indices
enum {
    GENERAL_PROPPAGE,
    SOURCE_PROPPAGE,
    COUNTER_PROPPAGE,
    GRAPH_PROPPAGE,
    APPEAR_PROPPAGE,       
    CPROPPAGES
    };

#define CCHSTRINGMAX        40
                
// Class factory for all property pages
class CSysmonPropPageFactory : public IClassFactory
    {
    protected:
        ULONG       m_cRef;
        INT         m_nPageID;

    public:
        CSysmonPropPageFactory(INT nPageID);
        ~CSysmonPropPageFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassPPFactory members
        STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, PPVOID);
        STDMETHODIMP     LockServer(BOOL);
    };

typedef CSysmonPropPageFactory *PCSysmonPropPageFactory;


// Dialog proc for proprty pages
BOOL APIENTRY SysmonPropPageProc(HWND, UINT, WPARAM, LPARAM);

// Base property page class
class CSysmonPropPage : public IPropertyPage2
{
    friend BOOL APIENTRY SysmonPropPageProc(HWND, UINT, WPARAM, LPARAM);
    protected:
        ULONG           m_cRef;         //Reference count
        UINT            m_uIDDialog;    //Dialog ID
        UINT            m_uIDTitle;     //Page Title ID
        HWND            m_hDlg;         //Dialog handle

        ULONG           m_cx;           //Dialog size
        ULONG           m_cy;
        UINT            m_cObjects;     //Number of objects
        LCID            m_lcid;         //Current locale
        BOOL            m_fActive;      //Page is fully active
        BOOL            m_fDirty;       //Page dirty?

        INT             m_dwEditControl; // Focus if specified by EditProperty

        ISystemMonitor **m_ppISysmon;    //Objects to notify
        IPropertyPageSite *m_pIPropertyPageSite;  //Frame's site

        void SetChange(void);                   //Mark page changed
        virtual BOOL GetProperties(void) = 0;   //Get object properties
        virtual BOOL SetProperties(void) = 0;   //Put object properties

        virtual void DialogItemChange(WORD wId, WORD wMsg) = 0; // Handle item change
        virtual void MeasureItem(PMEASUREITEMSTRUCT) {}; // Handle user measure req
        virtual void DrawItem(PDRAWITEMSTRUCT) {};  // Handle user draw req
        virtual BOOL InitControls(void)        // Initialize dialog controls
                        { return TRUE; }
        virtual void DeinitControls(void) {};       // Deinitialize dialog controls
        virtual HRESULT EditPropertyImpl( DISPID ) { return E_NOTIMPL; }; // Set focus control      

        virtual BOOL WndProc(UINT uMsg, WPARAM wParam, LPARAM lParam); // Special msg processing 
         
    public:
                CSysmonPropPage(void);
        virtual ~CSysmonPropPage(void);

        virtual BOOL Init(void);
        void FreeAllObjects(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP SetPageSite(LPPROPERTYPAGESITE);
        STDMETHODIMP Activate(HWND, LPCRECT, BOOL);
        STDMETHODIMP Deactivate(void);
        STDMETHODIMP GetPageInfo(LPPROPPAGEINFO);
        STDMETHODIMP SetObjects(ULONG, LPUNKNOWN *);
        STDMETHODIMP Show(UINT);
        STDMETHODIMP Move(LPCRECT);
        STDMETHODIMP IsPageDirty(void);
        STDMETHODIMP Apply(void);
        STDMETHODIMP Help(LPCOLESTR);
        STDMETHODIMP TranslateAccelerator(LPMSG);
        STDMETHODIMP EditProperty(DISPID);
    };
typedef CSysmonPropPage *PCSysmonPropPage;

#endif //_SMONPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\smonprop.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    smonprop.cpp

Abstract:

    Sysmon property page base class.

--*/

#include <stdio.h>
#include "smonprop.h"
#include "genprop.h"
#include "ctrprop.h"
#include "grphprop.h"
#include "srcprop.h"
#include "appearprop.h"
#include "unihelpr.h"
#include "utils.h"
#include "smonhelp.h"
#include "globals.h"

static ULONG
aulControlIdToHelpIdMap[] =
{
    IDC_CTRLIST,            IDH_CTRLIST,                // Data
    IDC_ADDCTR,             IDH_ADDCTR,
    IDC_DELCTR,             IDH_DELCTR,
    IDC_LINECOLOR,          IDH_LINECOLOR,
    IDC_LINEWIDTH,          IDH_LINEWIDTH,
    IDC_LINESTYLE,          IDH_LINESTYLE,
    IDC_LINESCALE,          IDH_LINESCALE,
    IDC_GALLERY_REPORT,     IDH_GALLERY_REPORT,         // General
    IDC_GALLERY_GRAPH,      IDH_GALLERY_GRAPH,
    IDC_GALLERY_HISTOGRAM,  IDH_GALLERY_HISTOGRAM,
    IDC_VALUEBAR,           IDH_VALUEBAR,
    IDC_TOOLBAR,            IDH_TOOLBAR,
    IDC_LEGEND,             IDH_LEGEND,
    IDC_RPT_VALUE_DEFAULT,  IDH_RPT_VALUE_DEFAULT,
    IDC_RPT_VALUE_MINIMUM,  IDH_RPT_VALUE_MINIMUM,
    IDC_RPT_VALUE_MAXIMUM,  IDH_RPT_VALUE_MAXIMUM,
    IDC_RPT_VALUE_AVERAGE,  IDH_RPT_VALUE_AVERAGE,
    IDC_RPT_VALUE_CURRENT,  IDH_RPT_VALUE_CURRENT,
    IDC_COMBOAPPEARANCE,    IDH_COMBOAPPEARANCE,
    IDC_COMBOBORDERSTYLE,   IDH_COMBOBORDERSTYLE,
    IDC_PERIODIC_UPDATE,    IDH_PERIODIC_UPDATE,
    IDC_DISPLAY_INTERVAL,   IDH_DISPLAY_INTERVAL,
    IDC_UPDATE_INTERVAL,    IDH_UPDATE_INTERVAL,
    IDC_DUPLICATE_INSTANCE, IDH_DUPLICATE_INSTANCE,
    IDC_GRAPH_TITLE,        IDH_GRAPH_TITLE,            // Graph
    IDC_YAXIS_TITLE,        IDH_YAXIS_TITLE,
    IDC_VERTICAL_GRID,      IDH_VERTICAL_GRID,
    IDC_HORIZONTAL_GRID,    IDH_HORIZONTAL_GRID,
    IDC_VERTICAL_LABELS,    IDH_VERTICAL_LABELS,
    IDC_VERTICAL_MAX,       IDH_VERTICAL_MAX,
    IDC_VERTICAL_MIN,       IDH_VERTICAL_MIN,
    IDC_SRC_REALTIME,       IDH_SRC_REALTIME,           // Source
    IDC_SRC_LOGFILE,        IDH_SRC_LOGFILE,
    IDC_SRC_SQL,            IDH_SRC_SQL,
    IDC_ADDFILE,            IDH_ADDFILE,
    IDC_REMOVEFILE,         IDH_REMOVEFILE,
    IDC_LOGSET_COMBO,       IDH_LOGSET_COMBO,
    IDC_DSN_COMBO,          IDH_DSN_COMBO,
    IDC_TIMESELECTBTN,      IDH_TIMESELECTBTN,
    IDC_TIMERANGE,          IDH_TIMERANGE,
    IDC_COLOROBJECTS,       IDH_COLOROBJECTS,
    IDC_FONTBUTTON,         IDH_FONTBUTTON,
    IDC_COLORBUTTON,        IDH_COLORBUTTON,
    IDC_COLORSAMPLE,        IDH_COLORSAMPLE,
    IDC_FONTSAMPLE,         IDH_FONTSAMPLE,
    0,0
};

/*
 * CSysmonPropPageFactory::CSysmonPropPageFactory
 * CSysmonPropPageFactory::~CSysmonPropPageFactory
 * CSysmonPropPageFactory::QueryInterface
 * CSysmonPropPageFactory::AddRef
 * CSysmonPropPageFactory::Release
 */

CSysmonPropPageFactory::CSysmonPropPageFactory(INT nPageID)
    {
    m_cRef=0L;
    m_nPageID = nPageID;
    return;
    }

CSysmonPropPageFactory::~CSysmonPropPageFactory(void)
    {
    return;
    }

STDMETHODIMP CSysmonPropPageFactory::QueryInterface(REFIID riid, PPVOID ppv)
    {
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
    }


STDMETHODIMP_(ULONG) CSysmonPropPageFactory::AddRef(void)
    {
    return ++m_cRef;
    }


STDMETHODIMP_(ULONG) CSysmonPropPageFactory::Release(void)
    {
    if (0!=--m_cRef)
        return m_cRef;

    delete this;
    return 0;
    }



/*
 * CSysmonPropPageFactory::CreateInstance
 * CSysmonPropPageFactory::LockServer
 */

STDMETHODIMP CSysmonPropPageFactory::CreateInstance(LPUNKNOWN pUnkOuter
    , REFIID riid, PPVOID ppvObj)
    {
    PCSysmonPropPage    pObj;
    HRESULT             hr = NOERROR;

    *ppvObj = NULL;

    //No aggregation supported
    if (NULL != pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    switch (m_nPageID) {
    case GENERAL_PROPPAGE:
        pObj = new CGeneralPropPage();
        break;
    case SOURCE_PROPPAGE:
        pObj = new CSourcePropPage();
        break;
    case COUNTER_PROPPAGE:
        pObj = new CCounterPropPage();
        break;
    case GRAPH_PROPPAGE:
        pObj = new CGraphPropPage();
        break;
    case APPEAR_PROPPAGE:
        pObj = new CAppearPropPage();
        break;
    default:
        pObj = NULL;
    }

    if (NULL == pObj)
        return E_OUTOFMEMORY;

    if (pObj->Init())
        hr = pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if (FAILED(hr))
        delete pObj;
    else
        InterlockedIncrement(&g_cObj);

    return hr;
    }


STDMETHODIMP CSysmonPropPageFactory::LockServer(BOOL fLock)
    {
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);

    return NOERROR;
    }



/***
 *** CSysmonPropPage implementation
 ***/

CSysmonPropPage::CSysmonPropPage(void)
:   m_cRef ( 0 ),
    m_hDlg ( NULL ),
    m_pIPropertyPageSite ( NULL ),
    m_ppISysmon ( NULL ),
    m_cObjects ( 0 ),
    m_cx ( 300 ),   // Default width
    m_cy ( 100 ),   // Default height
    m_fDirty ( FALSE ),
    m_fActive ( FALSE ),
    m_lcid ( LOCALE_USER_DEFAULT ),
    m_dwEditControl ( 0 )
{
    return;
}

CSysmonPropPage::~CSysmonPropPage(void)
    {
    if (NULL != m_hDlg)
        DestroyWindow(m_hDlg);

    FreeAllObjects();
    ReleaseInterface(m_pIPropertyPageSite);
    return;
    }


/*
 * CSysmonPropPage::QueryInterface
 * CSysmonPropPage::AddRef
 * CSysmonPropPage::Release
 */

STDMETHODIMP CSysmonPropPage::QueryInterface(REFIID riid, PPVOID ppv)
    {
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IPropertyPage==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
    }


STDMETHODIMP_(ULONG) CSysmonPropPage::AddRef(void)
    {
    return ++m_cRef;
    }


STDMETHODIMP_(ULONG) CSysmonPropPage::Release(void)
    {
    if (0 != --m_cRef)
        return m_cRef;

    InterlockedDecrement(&g_cObj);
    delete this;
    return 0;
    }


/*
 * CSysmonPropPage::Init
 *
 * Purpose:
 *  Performs initialization operations that might fail.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  BOOL            TRUE if initialization successful, FALSE
 *                  otherwise.
 */

BOOL CSysmonPropPage::Init(void)
    {
    //Nothing to do
    return TRUE;
    }


/*
 * CSysmonPropPage::FreeAllObjects
 *
 * Purpose:
 *  Releases all the objects from IPropertyPage::SetObjects
 *
 * Parameters:
 *  None
 */

void CSysmonPropPage::FreeAllObjects(void)
    {
    UINT        i;

    if (NULL==m_ppISysmon)
        return;

    for (i=0; i < m_cObjects; i++)
        ReleaseInterface(m_ppISysmon[i]);

    delete [] m_ppISysmon;
    m_ppISysmon  =NULL;
    m_cObjects = 0;
    return;
    }

/*
 * CSysmonPropPage::SetChange
 *
 * Purpose:
 *  Set the page dirty flag to indicate a change
 *  If page site is active, send status change to it.
 *
 * Parameters:
 *  None
 */

void CSysmonPropPage::SetChange(void)
    {
    if (m_fActive)
        {
        m_fDirty=TRUE;

        if (NULL != m_pIPropertyPageSite)
            {
            m_pIPropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
            }
        }
    }


/*
 * CSysmonPropPage::SetPageSite
 *
 * Purpose:
 *  Provides the property page with the IPropertyPageSite
 *  that contains it.  SetPageSite(NULL) will be called as
 *  part of the close sequence.
 *
 * Parameters:
 *  pPageSite       LPPROPERTYPAGESITE pointer to the site.
 */

STDMETHODIMP CSysmonPropPage::SetPageSite
    (LPPROPERTYPAGESITE pPageSite)
    {
    if (NULL==pPageSite)
        ReleaseInterface(m_pIPropertyPageSite)
    else
        {
        HWND        hDlg;
        RECT        rc;
        LCID        lcid;

        m_pIPropertyPageSite=pPageSite;
        m_pIPropertyPageSite->AddRef();

        if (SUCCEEDED(m_pIPropertyPageSite->GetLocaleID(&lcid)))
            m_lcid=lcid;

        /*
         * Load the dialog and determine the size it will be to
         * return through GetPageSize.  We just create the dialog
         * here and destroy it again to retrieve the size,
         * leaving Activate to create it for real.
         */

        hDlg=CreateDialogParam(g_hInstance
            , MAKEINTRESOURCE(m_uIDDialog), GetDesktopWindow()
            , (DLGPROC)SysmonPropPageProc, 0L);

        //If creation fails, use default values set in constructor
        if (NULL!=hDlg)
            {
            GetWindowRect(hDlg, &rc);
            m_cx=rc.right-rc.left;
            m_cy=rc.bottom-rc.top;

            DestroyWindow(hDlg);
            }
        }

    return NOERROR;
    }



/*
 * CSysmonPropPage::Activate
 *
 * Purpose:
 *  Instructs the property page to create a window in which to
 *  display its contents, using the given parent window and
 *  rectangle.  The window should be initially visible.
 *
 * Parameters:
 *  hWndParent      HWND of the parent window.
 *  prc             LPCRECT of the rectangle to use.
 *  fModal          BOOL indicating whether the frame is modal.
 */

STDMETHODIMP CSysmonPropPage::Activate(HWND hWndParent
    , LPCRECT prc, BOOL /* fModal */)
    {

    if (NULL!=m_hDlg)
        return ResultFromScode(E_UNEXPECTED);

    m_hDlg=CreateDialogParam(g_hInstance, MAKEINTRESOURCE(m_uIDDialog)
        , hWndParent, (DLGPROC)SysmonPropPageProc, (LPARAM)this);

    if (NULL==m_hDlg)
        return E_OUTOFMEMORY;

    if (!InitControls())
        return E_OUTOFMEMORY;

    if (!GetProperties())
        return E_OUTOFMEMORY;

    //Move the page into position and show it.
//    SetWindowPos(m_hDlg, NULL, prc->left, prc->top, prc->right-prc->left, prc->bottom-prc->top, 0);
    SetWindowPos(m_hDlg, NULL, prc->left, prc->top, 0, 0, SWP_NOSIZE );

    m_fActive = TRUE;
    return NOERROR;
    }

/*
 * CSysmonPropPage::Deactivate
 *
 * Purpose:
 *  Instructs the property page to destroy its window that was
 *  created in Activate.
 *
 * Parameters:
 *  None
 */

STDMETHODIMP CSysmonPropPage::Deactivate(void)
    {
    if (NULL==m_hDlg)
        return ResultFromScode(E_UNEXPECTED);

    DeinitControls();

    DestroyWindow(m_hDlg);
    m_hDlg=NULL;
    m_fActive = FALSE;
    return NOERROR;
    }



/*
 * CSysmonPropPage::GetPageInfo
 *
 * Purpose:
 *  Fills a PROPPAGEINFO structure describing the page's size,
 *  contents, and help information.
 *
 * Parameters:
 *  pPageInfo       LPPROPPAGEINFO to the structure to fill.
 */

STDMETHODIMP CSysmonPropPage::GetPageInfo(LPPROPPAGEINFO pPageInfo)
    {
    IMalloc     *pIMalloc;

    if (FAILED(CoGetMalloc(MEMCTX_TASK, &pIMalloc)))
        return ResultFromScode(E_FAIL);

    pPageInfo->pszTitle=(LPOLESTR)pIMalloc->Alloc(CCHSTRINGMAX * sizeof(TCHAR));

    if (NULL != pPageInfo->pszTitle) {
 
     #ifndef UNICODE
        MultiByteToWideChar(CP_ACP, 0, ResourceString(m_uIDTitle), -1
           , pPageInfo->pszTitle, CCHSTRINGMAX);
     #else
        lstrcpy(pPageInfo->pszTitle, ResourceString(m_uIDTitle));
     #endif
    }

    pIMalloc->Release();

    pPageInfo->size.cx      = m_cx;
    pPageInfo->size.cy      = m_cy;
    pPageInfo->pszDocString = NULL;
    pPageInfo->pszHelpFile  = NULL;
    pPageInfo->dwHelpContext= 0;
    return NOERROR;
    }



/*
 * CSysmonPropPage::SetObjects
 *
 * Purpose:
 *  Identifies the objects that are being affected by this property
 *  page (and all other pages in the frame).  These are the object
 *  to which to send new property values in the Apply member.
 *
 * Parameters:
 *  cObjects        ULONG number of objects
 *  ppUnk           IUnknown ** to the array of objects being
 *                  passed to the page.
 */

STDMETHODIMP CSysmonPropPage::SetObjects(ULONG cObjects
    , IUnknown **ppUnk)
    {
    BOOL        fRet=TRUE;

    FreeAllObjects();

    if (0!=cObjects)
        {
        UINT        i;
        HRESULT     hr;

        m_ppISysmon = new ISystemMonitor * [(UINT)cObjects];
        if (m_ppISysmon == NULL)
            return E_OUTOFMEMORY;

        for (i=0; i < cObjects; i++)
            {
            hr=ppUnk[i]->QueryInterface(IID_ISystemMonitor
                , (void **)&m_ppISysmon[i]);

            if (FAILED(hr))
                fRet=FALSE;
            }
        }

    //If we didn't get one of our objects, fail this call.
    if (!fRet)
        return ResultFromScode(E_FAIL);

    m_cObjects=cObjects;
    return NOERROR;
    }



/*
 * CSysmonPropPage::Show
 *
 * Purpose:
 *  Instructs the page to show or hide its window created in
 *  Activate.
 *
 * Parameters:
 *  nCmdShow        UINT to pass to ShowWindow.
 */

STDMETHODIMP CSysmonPropPage::Show(UINT nCmdShow)
    {
    if (NULL==m_hDlg)
        ResultFromScode(E_UNEXPECTED);

    ShowWindow(m_hDlg, nCmdShow);

    // If showing page
    if (SW_SHOWNORMAL==nCmdShow || SW_SHOW==nCmdShow) {

        // Take the focus
        // (Have to delay so it isn't taken back)
        PostMessage(m_hDlg,WM_SETPAGEFOCUS,0,0);
    }
    
    return NOERROR;
    }

/*
 * CSysmonPropPage::Move
 *
 * Purpose:
 *  Instructs the property page to change its position.
 *
 * Parameters:
 *  prc             LPCRECT containing the new position.
 */

STDMETHODIMP CSysmonPropPage::Move(LPCRECT prc)
    {
//    SetWindowPos(m_hDlg, NULL, prc->left, prc->top, prc->right-prc->left, prc->bottom-prc->top, 0);
    SetWindowPos(m_hDlg, NULL, prc->left, prc->top, 0, 0, SWP_NOSIZE );

    return NOERROR;
    }



/*
 * CSysmonPropPage::IsPageDirty
 *
 * Purpose:
 *  Asks the page if anything's changed in it, that is, if the
 *  property values in the page are out of sync with the objects
 *  under consideration.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if dirty, S_FALSE if not.
 */

STDMETHODIMP CSysmonPropPage::IsPageDirty(void)
    {
    return ResultFromScode(m_fDirty ? S_OK : S_FALSE);
    }


/*
 * CSysmonPropPage::Apply
 *
 * Purpose:
 *  Instructs the page to send changes in its page to whatever
 *  objects it knows about through SetObjects.  This is the only
 *  time the page should change the objects' properties, and not
 *  when the value is changed on the page.
 *
 * Parameters:
 *  None
 */

STDMETHODIMP CSysmonPropPage::Apply(void)
{
    HRESULT hr = NOERROR;

    if ( 0 != m_cObjects ) {

        // Kill the focus in case a text field has it. This will trigger
        // the entry processing code.
        SetFocus(NULL);

        { 
            CWaitCursor cursorWait;

            if (SetProperties()) {
                m_fDirty = FALSE;
            } else {
                hr = E_FAIL;
            }
        }
    }
    return hr;
}

/*
 * CSysmonPropPage::Help
 *
 * Purpose:
 *  Invokes help for this property page when the user presses
 *  the Help button.  If you return NULLs for the help file
 *  in GetPageInfo, the button will be grayed.  Otherwise the
 *  page can perform its own help here.
 *
 * Parameters:
 *  pszHelpDir      LPCOLESTR identifying the default location of
 *                  the help information
 *
 * Return Value:
 *  HRESULT         NOERROR to tell the frame that we've done our
 *                  own help.  Returning an error code or S_FALSE
 *                  causes the frame to use any help information
 *                  in PROPPAGEINFO.
 */

STDMETHODIMP CSysmonPropPage::Help(LPCOLESTR /* pszHelpDir */ )
{
    /*
     * We can either provide help ourselves, or rely on the
     * information in PROPPAGEINFO.
     */
    return ResultFromScode(S_FALSE);
}


/*
 * CSysmonPropPage::TranslateAccelerator
 *
 * Purpose:
 *  Provides the page with the messages that occur in the frame.
 *  This gives the page to do whatever it wants with the message,
 *  such as handle keyboard mnemonics.
 *
 * Parameters:
 *  pMsg            LPMSG containing the keyboard message.
 */

STDMETHODIMP CSysmonPropPage::TranslateAccelerator(LPMSG lpMsg)
{
    BOOL fTakeIt = TRUE;
    BOOL fHandled = FALSE;
    HRESULT hr;

    HWND hwnd;
    
    if (lpMsg == NULL)
        return E_POINTER;
    
    
    
    // If TAB key
    if (lpMsg->message == WM_KEYDOWN 
        && lpMsg->wParam == VK_TAB 
        && GetKeyState(VK_CONTROL) >= 0) {

        UINT uDir = GetKeyState(VK_SHIFT) >= 0 ? GW_HWNDNEXT : GW_HWNDPREV;

        hwnd = GetFocus();

        if (IsChild(m_hDlg, hwnd)) {

            // Get top level child for controls with children, like combo.
            while (GetParent(hwnd) != m_hDlg) hwnd = GetParent(hwnd);

            // If this control is the last enabled tab stop, don't steal the TAB key
            do {
                hwnd = GetWindow(hwnd, uDir);
                if ( NULL == hwnd ) {
                    fTakeIt = FALSE;
                    break;
                }
            }
            while ((GetWindowLong(hwnd, GWL_STYLE) & (WS_DISABLED | WS_TABSTOP)) != WS_TABSTOP);
        }
    }

/*
    fTakeIt is already TRUE.
    // else if Arrow key
    else if ( lpMsg->message == WM_KEYDOWN && 
             ( lpMsg->wParam == VK_LEFT || lpMsg->wParam == VK_UP
                || lpMsg->wParam == VK_RIGHT || lpMsg->wParam == VK_DOWN ) ) {
        
        fTakeIt = TRUE;
    }
*/        

    // else if Return or Escape key
    else if ((lpMsg->message == WM_KEYDOWN && 
             (lpMsg->wParam == VK_RETURN || lpMsg->wParam == VK_ESCAPE)) ) {

        fTakeIt = (lpMsg->wParam == VK_RETURN);             

        if ( fTakeIt ) {

            hwnd = GetFocus(); 

            if ( NULL == hwnd ) {
                fTakeIt = FALSE;
            } else {
                fTakeIt = IsChild(m_hDlg, hwnd);
                
                if ( fTakeIt ) {
                    fTakeIt = (BOOL) SendMessage(hwnd, WM_GETDLGCODE, 0, 0) & DLGC_DEFPUSHBUTTON;
                }
            } 
        }
    }

    
    // if we should process the key
    if (fTakeIt) {

        // if the target is not one of our controls, change it so IsDialogMessage works
        if (!IsChild(m_hDlg, lpMsg->hwnd)) {
            hwnd = lpMsg->hwnd;
            lpMsg->hwnd = GetWindow(m_hDlg, GW_CHILD);
            fHandled = IsDialogMessage(m_hDlg, lpMsg);
            lpMsg->hwnd = hwnd;
        }
        else {
            fHandled = IsDialogMessage(m_hDlg, lpMsg);
        }
    }

    if (fHandled){
        return S_OK;
    } else{
        hr = m_pIPropertyPageSite->TranslateAccelerator(lpMsg);
    }

    return hr;
}
/*
 * CSysmonPropPage::EditProperty
 *
 * Purpose:
 *  Sets focus to the control corresponding to the supplied DISPID.
 *
 * Parameters:
 *  dispID            DISPID of the property
 */

STDMETHODIMP CSysmonPropPage::EditProperty(DISPID dispID)
{
    HRESULT hr;

    hr = EditPropertyImpl ( dispID );

    if ( S_OK == hr ) {
        SetFocus ( GetDlgItem ( m_hDlg, m_dwEditControl ) );
        m_dwEditControl = 0;
    }
    
    return hr;
}

/*
 * CSysmonPropPage::WndProc
 *
 * Purpose:
 *  This is a default message processor that can be overriden by 
 *  a subclass to provide special message handling.
 *
 * Parameters:
 *  pMsg            LPMSG containing the keyboard message.
 */
BOOL 
CSysmonPropPage::WndProc (
    UINT, // uMsg, 
    WPARAM, // wParam,
    LPARAM // lParam
    )
{
    return FALSE;
}


/*
 * SysmonPropPageProc
 *
 * Purpose:
 *  Dialog procedure for the Sysmon Property Page.
 */
BOOL APIENTRY 
SysmonPropPageProc(
    HWND hDlg, 
    UINT iMsg,
    WPARAM wParam, 
    LPARAM lParam)
{
    static TCHAR       szObj[] = TEXT("Object");

    PCSysmonPropPage    pObj = NULL;
    PMEASUREITEMSTRUCT  pMI;
    HWND hwndTabCtrl;
    HWND hwndPropSheet;
    INT  iCtrlID;
    TCHAR pszHelpFilePath[MAX_PATH * 2];
    LPHELPINFO pInfo;
    UINT nLen;
    BOOL bReturn = FALSE;

    if ( NULL != hDlg ) {
        pObj = (PCSysmonPropPage)GetProp(hDlg, szObj);
    }

    switch (iMsg) {
        case WM_INITDIALOG:

            pObj=(PCSysmonPropPage)lParam;

            if ( NULL != pObj && NULL != hDlg ) {
                SetProp(hDlg, szObj, (HANDLE)lParam);
                hwndTabCtrl = ::GetParent(hDlg);
                hwndPropSheet = ::GetParent(hwndTabCtrl);
                SetWindowLongPtr(hwndPropSheet,GWL_EXSTYLE,GetWindowLongPtr(hwndPropSheet,GWL_EXSTYLE)|WS_EX_CONTEXTHELP);    
            }
            bReturn = TRUE;
            break;

        case WM_DESTROY:
            if ( NULL != hDlg ) {
                RemoveProp(hDlg, szObj);
            }
            bReturn = TRUE;
            break;

        case WM_MEASUREITEM:
            pMI = (PMEASUREITEMSTRUCT)lParam;
            if ( NULL != pMI ) {
                pMI->itemWidth  = 0 ;
                pMI->itemHeight = 16;
            }
            bReturn = TRUE;
            break;
 
        case WM_DRAWITEM:
            if ( NULL != pObj ) {
                pObj->DrawItem ((PDRAWITEMSTRUCT) lParam) ;
            }
            bReturn = TRUE;
            break;

        case WM_COMMAND:
            if ( NULL != pObj ) {
                pObj->DialogItemChange(LOWORD(wParam), HIWORD(wParam));
            }
            bReturn = FALSE;
            break;
        
        case WM_SETPAGEFOCUS:
            if ( NULL != hDlg ) {
                SetFocus(hDlg);            
                bReturn = TRUE;
            }
            break;

        case WM_CONTEXTMENU:

            if ( NULL != (HWND) wParam ) {
                iCtrlID = GetDlgCtrlID ( (HWND) wParam );

                if ( 0 != iCtrlID ) {

                    nLen = ::GetWindowsDirectory(pszHelpFilePath, 2*MAX_PATH);
                
                    if ( 0 < nLen ) {
                        lstrcpy(&pszHelpFilePath[nLen], L"\\help\\sysmon.hlp" );


                        bReturn = WinHelp(
                                    (HWND) wParam,
                                    pszHelpFilePath,
                                    HELP_CONTEXTMENU,
                                    (DWORD_PTR) aulControlIdToHelpIdMap);
                    }
                }
            }
            // bReturn is FALSE by default
            break;

        case WM_HELP:
                  
            if ( NULL != hDlg ) {
                pInfo = (LPHELPINFO)lParam;

                if ( NULL != pInfo ) {
                    // Only display help for known context IDs.
                    if ( 0 != pInfo->dwContextId ) {

                        nLen = ::GetWindowsDirectory(pszHelpFilePath, 2*MAX_PATH);
                        if ( 0 < nLen ) {
                            lstrcpy(&pszHelpFilePath[nLen], L"\\help\\sysmon.hlp" );
                            bReturn = WinHelp ( 
                                        hDlg, 
                                        pszHelpFilePath, 
                                        HELP_CONTEXTPOPUP, 
                                        pInfo->dwContextId );
                        }
                    }
                }
            }
            // bReturn is FALSE by default
            break;

        default:
            if ( NULL != pObj ) {
                bReturn = pObj->WndProc(iMsg, wParam, lParam);
            }
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\snapbar.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    snapbar.h

Abstract:

    <abstract>

--*/

#ifndef _SNAPBAR_H_
#define _SNAPBAR_H_

class CSysmonControl;
 
class CSnapBar
{
    friend LRESULT CALLBACK SnapBarWndProc (HWND, UINT, WPARAM, LPARAM);

    private:
        CSysmonControl *m_pCtrl;
        HBITMAP     m_hBitmap;
        HWND        m_hWnd;
        WNDPROC     m_WndProc;

    public:
        CSnapBar (void);
        ~CSnapBar (void);

     BOOL Init(CSysmonControl *pCtrl, HWND hWndParent);
     VOID SizeComponents(LPRECT pRect);
     INT  Height (INT iMaxHeight);
};

typedef CSnapBar *PSNAPBAR;

#endif // _SNAPBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\smonhelp.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    smonhelp.h

Abstract:

    Help IDs for the System Monitor control.

--*/

//Property pages
#define IDH_PG_SYSMON_GENERAL   1000100
#define IDH_PG_SYSMON_GRAPH     1000101
#define IDH_PG_SYSMON_DATA      1000102
#define IDH_PG_SYSMON_SOURCE    1000103

//General
#define IDH_GALLERY_GRAPH       1000001 
#define IDH_GALLERY_HISTOGRAM   1000002
#define IDH_GALLERY_REPORT      1000003
#define IDH_LEGEND              1000004
#define IDH_VALUEBAR            1000005
#define IDH_TOOLBAR             1000006
#define IDH_COMBOAPPEARANCE     1000007     // new name for IDH_APPEARANCE
#define IDH_COMBOBORDERSTYLE    1000008     // new name for IDH_BORDERSTYLE
#define IDH_PERIODIC_UPDATE     1000009
#define IDH_DISPLAY_INTERVAL	2000001     // added for Whistler
//#define IDH_MANUAL_UPDATE       1000010   // remove
#define IDH_UPDATE_INTERVAL     1000011
#define IDH_RPT_VALUE_DEFAULT   1000012
#define IDH_RPT_VALUE_CURRENT   1000013
#define IDH_RPT_VALUE_AVERAGE   1000014
#define IDH_RPT_VALUE_MINIMUM   1000015
#define IDH_RPT_VALUE_MAXIMUM   1000016
#define IDH_DUPLICATE_INSTANCE  1000017

//Graph
#define IDH_GRAPH_TITLE         1000020
#define IDH_YAXIS_TITLE         1000021
#define IDH_VERTICAL_GRID       1000022
#define IDH_HORIZONTAL_GRID     1000023
#define IDH_VERTICAL_MAX        1000024
#define IDH_VERTICAL_MIN        1000025
#define IDH_VERTICAL_LABELS     1000026

//Data
#define IDH_CTRLIST             1000030
#define IDH_LINECOLOR           1000031
#define IDH_LINESCALE           1000032
#define IDH_LINEWIDTH           1000033
#define IDH_LINESTYLE           1000034 
#define IDH_ADDCTR              1000035
#define IDH_DELCTR              1000036

//Source
#define IDH_LOGFILENAME         1000041
#define IDH_SRC_LOGFILE         1000044
#define IDH_SRC_REALTIME	    2000002     // added for Whistler
#define IDH_LIST_LOGFILENAME	2000003     // added for Whistler
#define IDH_ADDFILE             2000004     // added for Whistler
#define IDH_REMOVEFILE          2000005     // added for Whistler
#define IDH_SRC_SQL             2000006     // added for Whistler
#define IDH_DSN_COMBO           2000007     // added for Whistler
#define IDH_LOGSET_COMBO        2000008     // added for Whistler
#define IDH_TIMESELECTBTN       2000009     // added for Whistler
#define IDH_TIMERANGE           2000010     // added for Whistler
#define IDH_BROWSEFILE          1000045

// Appearance
#define IDH_COLOROBJECTS        2000011
#define IDH_COLORBUTTON         2000012
#define IDH_FONTBUTTON          2000013
#define IDH_FONTSAMPLE          2000014
#define IDH_COLORSAMPLE         2000015

//Browse Dialog
#define IDH_USE_LOCAL_MACHINE   1000090
#define IDH_SELECT_MACHINE      1000091
#define IDH_MACHINE_COMBO       1000092
#define IDH_OBJECT_COMBO        1000093
#define IDH_COUNTER_LIST        1000094
#define IDH_ALL_INSTANCES       1000095
#define IDH_USE_INSTANCE_LIST   1000096
#define IDH_INSTANCE_LIST       1000097
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\smonctrl.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    smonctrl.h

Abstract:

    <abstract>

--*/

#ifndef _SMONCTRL_H_
#define _SMONCTRL_H_

#pragma warning ( disable : 4201)

#include <pdh.h>
#include "colefont.h"
#include "graph.h"

#define SMONCTRL_MAJ_VERSION    3
#define SMONCTRL_MIN_VERSION    6

#define WM_GRAPH_UPDATE (WM_USER + 1)

#define UPDGRPH_COLOR    1
#define UPDGRPH_FONT     2
#define UPDGRPH_LAYOUT   3
#define UPDGRPH_ADDCNTR  4
#define UPDGRPH_DELCNTR  5
#define UPDGRPH_PLOT     6
#define UPDGRPH_VIEW     7
#define UPDGRPH_LOGVIEW  8

#define SLQ_COUNTER_LOG     0
#define SLQ_TRACE_LOG       1
#define SLQ_ALERT_LOG       2
#define SMON_CTRL_LOG       3

#define LODWORD(ll) ((DWORD)((LONGLONG)ll & 0x00000000FFFFFFFF))
#define HIDWORD(ll) ((DWORD)(((LONGLONG)ll >> 32) & 0x00000000FFFFFFFF))
#define MAKELONGLONG(low, high) \
        ((LONGLONG) (((DWORD) (low)) | ((LONGLONG) ((DWORD) (high))) << 32))

typedef union {                        
    struct {
        SHORT      iMajor;     
        SHORT      iMinor;     
    }; 
    DWORD          dwVersion;      
} SMONCTRL_VERSION_DATA;
    
typedef struct
{
    INT32       iWidth;
    INT32       iHeight;
    INT32       nSamples;
    INT32       iScaleMax;
    INT32       iScaleMin;
    BOOL        bLegend;            // Each BOOL is 4 bytes
    BOOL        bLabels;
    BOOL        bHorzGrid;
    BOOL        bVertGrid;
    BOOL        bValueBar;
    BOOL        bManualUpdate;
    FLOAT       fUpdateInterval;
    INT32       iDisplayType;
    INT32       nGraphTitleLen;
    INT32       nYaxisTitleLen;
    OLE_COLOR   clrBackCtl;
    OLE_COLOR   clrFore;
    OLE_COLOR   clrBackPlot;
    INT32       nFileNameLen;
    INT32       iReserved1;         // Spare for future use
    LONGLONG    llStartDisp;        // On 8-byte boundary
    LONGLONG    llStopDisp;
    INT32       iAppearance;
    INT32       iBorderStyle;
    OLE_COLOR   clrGrid;    
    OLE_COLOR   clrTimeBar;    
    BOOL        bHighlight;
    BOOL        bToolbar;
    INT32       iReportValueType;
    BOOL        bReadOnly;
    BOOL        bMonitorDuplicateInstances;
    BOOL        bAmbientFont;
    INT32       iDisplayFilter;
    INT32       iDataSourceType;
    INT32       iSqlDsnLen;
    INT32       iSqlLogSetNameLen;
    INT32       iColorIndex;
    INT32       iWidthIndex;
    INT32       iStyleIndex;
    LONG32      arrlReserved[22];   // Spare, fill out to 256 bytes
} GRAPHCTRL_DATA3;


enum COLLECT_MODE {
    COLLECT_ACTIVE = 1,
    COLLECT_SUSPEND,
    COLLECT_QUIT
};

enum eBorderStyle {
    eBorderFirst = 0,
    eBorderNone = eBorderFirst,
    eBorderSingle = 1,
    eBorderCount
};

enum eAppearance {
    eAppearFirst = 0,
    eAppearFlat = eAppearFirst,
    eAppear3D = 1,
    eAppearCount
};

typedef struct {
    HANDLE      hEvent;
    HANDLE      hThread;
    DWORD       dwInterval;
    DWORD       dwSampleTime;
    COLLECT_MODE iMode;
} COLLECT_PROC_INFO;

class CLogFileItem;
class CGraphItem;
class CCounterTree;
class CStatsBar;
class CSnapBar;
class CSysmonToolbar;
class CReport;
class CLegend;
class CGraphDisp;

typedef struct {
    LPTSTR      pszFileName;
} LOG_FILE_INFO;

typedef struct {
    HLOG           hDataSource;
    LPTSTR         szSqlDsnName;
    LPTSTR         szSqlLogSetName;
    CLogFileItem * pFirstLogFile;
    INT32          nSamples;       
    LONGLONG       llBeginTime;
    LONGLONG       llEndTime;
    LONGLONG       llStartDisp;
    LONGLONG       llStopDisp;
    LONGLONG       llInterval;         
    LONG           lLogFileCount;
} DATA_SOURCE_INFO;


class CSysmonControl
{

friend class CPolyline;
friend class CImpISystemMonitor;
friend class CSysmonToolbar;
friend LRESULT APIENTRY SysmonCtrlWndProc (HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);
friend  DWORD WINAPI CollectProc(CSysmonControl *pCtrl);

public:

            CSysmonControl          ( CPolyline *pObj );
    virtual ~CSysmonControl         ( void );

    void    put_BackCtlColor ( OLE_COLOR color );
    void    put_FgndColor ( OLE_COLOR color, BOOL fAmbient );
    void    put_BackPlotColor ( OLE_COLOR color, BOOL fAmbient );
    void    put_GridColor ( OLE_COLOR color );
    void    put_TimeBarColor ( OLE_COLOR color );

    HRESULT put_Font( LPFONT pIFont, BOOL fAmbient );
    HRESULT get_DataSourceType( eDataSourceTypeConstant& eDataSourceType );
    HRESULT put_DataSourceType( INT iDataSourceType );

    HRESULT AddSingleLogFile ( LPCTSTR pPath, CLogFileItem** ppLogFile = NULL );
    HRESULT RemoveSingleLogFile ( CLogFileItem* pLogFile );
    // TodoLogFiles:  Move FirstLogFile, NumLogFiles, to Graph.h?
    CLogFileItem* FirstLogFile ( void ) { return m_DataSourceInfo.pFirstLogFile; };
    INT           NumLogFiles ( void ){ return m_DataSourceInfo.lLogFileCount; };

    void    put_Appearance( INT iApp, BOOL fAmbient );
    void    put_BorderStyle( INT iStyle, BOOL fAmbient );  
    void    put_Highlight ( BOOL bState );

    void    put_ManualUpdate ( BOOL bManual );

    static BOOL RegisterWndClass( void );

    COLORREF clrBackCtl ( void ) { return m_clrBackCtl; }
    COLORREF clrFgnd ( void ) { return m_clrFgnd; }
    COLORREF clrBackPlot ( void ) { return m_clrBackPlot; }
    COLORREF clrGrid ( void ) { return m_clrGrid; }
    COLORREF clrTimeBar ( void ) { return m_clrTimeBar; }

    INT Appearance( void ) { return m_iAppearance; } 
    INT BorderStyle( void ) { return m_iBorderStyle; } 

    eReportValueTypeConstant ReportValueType ( void );

    HFONT    Font    ( void ) { HFONT hFont; m_OleFont.GetHFont(&hFont); return hFont; }
    HFONT    BoldFont( void ) { HFONT hFont; m_OleFont.GetHFontBold(&hFont); return hFont; }
    void     FontChanged ( void );
    void     IncrementVisuals ( void );

    BOOL Init               ( HWND hWndParent );
    void DeInit             ( void );
    BOOL AllocateSubcomponents  ( void );       
    void UpdateNonAmbientSysColors ( void );
    HRESULT LoadFromStream  ( LPSTREAM pIStream );
    HRESULT SaveToStream    ( LPSTREAM pIStream );

    HRESULT LoadFromPropertyBag ( IPropertyBag*, IErrorLog* );
    HRESULT SaveToPropertyBag   ( IPropertyBag*, BOOL fSaveAllProps );
    HRESULT LoadCountersFromPropertyBag ( IPropertyBag*, IErrorLog*, BOOL bLoadData=TRUE );
    HRESULT LoadLogFilesFromPropertyBag ( IPropertyBag*, IErrorLog* );
    HRESULT LoadLogFilesFromMultiSz ( LPCWSTR  szLogFileList );


    void Render             ( HDC hDC, HDC hAttribDC, BOOL fMetafile, BOOL fEntire, LPRECT pRect );

    void UpdateGraph        ( INT nUpdateType );
    void SetIntervalTimer   ( void );
    PDH_STATUS UpdateCounterValues( BOOL bManual );

    HRESULT AddCounter      ( LPTSTR pPath, CGraphItem* *ppCtr );
    HRESULT AddSingleCounter ( LPTSTR pPath, CGraphItem* *ppCtr );
    HRESULT DeleteCounter   ( CGraphItem* pCtr, BOOL bPropagate );
    HRESULT Paste           ( void );
    HRESULT Copy            ( void );
    HRESULT Reset           ( void );

    void    SelectCounter   ( CGraphItem* pCtr );
    void    DblClickCounter ( CGraphItem* pCtr );

    CGraphItem* FirstCounter ( void );
    CGraphItem* LastCounter  ( void );
    CCounterTree* CounterTree ( void );
    INT CounterIndex ( CGraphItem* pCtr );

    HWND Window             ( void );
    HRESULT TranslateAccelerators( LPMSG pMsg );

    INT     ConfirmSampleDataOverwrite ( void );
    HRESULT DisplayProperties   ( DISPID dispID = DISPID_UNKNOWN );
    HRESULT AddCounters ( void );
    HRESULT SaveAs ( void );
    HRESULT SaveData ( void );
    void    Activate ( void );
    BOOL    IsUIDead ( void ) { return m_fUIDead; }
    BOOL    IsUserMode ( void ) { return m_fUserMode; }
    BOOL    IsReadOnly ( void );
    BOOL    DisplayHelp ( HWND hWndSelf );

    void LockCounterData ( void ) { EnterCriticalSection(&m_CounterDataLock); }
    void UnlockCounterData ( void ) { LeaveCriticalSection(&m_CounterDataLock); }

    BOOL IsLogSource ( void );
    PHIST_CONTROL   HistoryControl( void ) { return m_pHistCtrl; }

    BOOL    DisplayMissedSampleMessage( void );
    void    SetMissedSample ( void );

    void    SetLogViewTempTimeRange(LONGLONG llStart, LONGLONG LLStop);
    void    ResetLogViewTempTimeRange( void );

    double  GetZoomFactor ( void ) { return m_dZoomFactor; };
    void    CalcZoomFactor ( void );

    LONG    GetSaveDataFilter ( void ) { return m_lSaveDataToLogFilterValue; };
    BOOL    SetSaveDataFilter ( long lFilter ) 
    { 
        if (lFilter) {
            m_lSaveDataToLogFilterValue = lFilter; 
            return TRUE; 
        }
        return FALSE;
    };

    void DrawBorder ( HDC hDC );
    BOOL WriteFileReportHeader(HANDLE hFile);

    // *** TodoMultiLogHandle:  Temporary method.  Remove when trace file post-processing supports multiple
    // open files.
    HQUERY  TempGetQueryHandle ( void ){ return m_hQuery; };

private:

    void ApplyChanges ( HDC hDC );
    void Paint ( void );
    void OnDblClick ( INT xPos, INT yPos );
    void OnDropFile ( WPARAM wParam );
    void DisplayContextMenu ( short x, short y );
    void UpdateGraphData ( void );
    void SizeComponents  ( HDC hDC );
    void AssignFocus( VOID );
    BOOL InitView ( HWND hWndParent );
    
    PRECT   GetNewClientRect ( void );
    PRECT   GetCurrentClientRect ( void );
    void    SetCurrentClientRect ( PRECT );    

    HRESULT ProcessDataSourceType( LPCTSTR pszDataSourceName, INT iDataSourceType );
    LPCTSTR GetDataSourceName ( void );
    HLOG    GetDataSourceHandle(void) { return m_DataSourceInfo.hDataSource; }

    HRESULT CopyToBuffer ( LPTSTR& rpszData, DWORD& rdwBufferSize );
    HRESULT PasteFromBuffer ( LPTSTR pszData, BOOL bAllSettings = FALSE );

    DWORD   InitializeQuery ( void );
    DWORD   ActivateQuery ( void );
    void    CloseQuery ( void );

    HRESULT InitLogFileIntervals( void );
    void    SampleLogFile ( BOOL bViewChange );

    void  Clear( void );

    void  FindNextValidStepNum(
            BOOL bDecrease, 
            CGraphItem* pItem, 
            LONGLONG llNewTime, 
            INT& riNewStepNum, 
            DWORD& rdwStatus );

    void  GetNewLogViewStepNum(LONGLONG llNewTime, INT& riNewStepNum);

    DWORD ProcessCommandLine( void );

    HRESULT LoadFromFile( LPTSTR pszFileName, BOOL bAllData );

    DWORD   RelogLogData ( 
        LPCTSTR szOutputFile,
        DWORD   dwOutputLogType,
        PDH_TIME_INFO   pdhTimeInfo,
        DWORD   dwFilterCount);

    HRESULT GetSelectedCounter ( CGraphItem** ppCtr );

    DWORD   BuildLogFileList (
                LPWSTR  szLogFileList,
                BOOL    bIsCommaDelimited,
                ULONG*  pulBufLen );

    DWORD   AddToErrorPathList ( LPCWSTR szPath );
    LPCWSTR GetErrorPathList ( DWORD* pdwListLen );
    void    ClearErrorPathList ( void );
    
    DWORD   AddToErrorLogFileList ( LPCWSTR szPath );
    LPCWSTR GetErrorLogFileList ( DWORD* pdwListLen );
    void    ClearErrorLogFileList ( void );
    
    SMONCTRL_VERSION_DATA m_LoadedVersion;
    BOOL        m_fInitialized;
    BOOL        m_fViewInitialized;
    HWND        m_hWnd;
    CLegend*    m_pLegend;
    CGraphDisp* m_pGraphDisp;
    CStatsBar*  m_pStatsBar;
    CSnapBar*   m_pSnapBar;
    CReport*    m_pReport;
    CSysmonToolbar*  m_pToolbar;
    CPolyline  *m_pObj;
    PHIST_CONTROL m_pHistCtrl;
    HQUERY      m_hQuery;
    UINT        m_TimerID;
    BOOLEAN     m_fPendingUpdate;
    BOOLEAN     m_fPendingSizeChg;
    BOOLEAN     m_fPendingFontChg;
    BOOLEAN     m_fPendingLogViewChg;
    BOOLEAN     m_fPendingLogCntrChg;
    BOOLEAN     m_fUIDead;
    BOOLEAN     m_fUserMode;
    BOOLEAN     m_fDuplicate;
    COLORREF    m_clrBackCtl;
    COLORREF    m_clrFgnd;
    COLORREF    m_clrBackPlot;
    COLORREF    m_clrGrid;
    COLORREF    m_clrTimeBar;
    INT         m_iAppearance;
    INT         m_iBorderStyle;
    eDisplayTypeConstant    m_eDisplayType;
    BOOL        m_bLogFileSource;
    BOOL        m_bSampleDataLoaded;
    double      m_dZoomFactor;
    BOOL        m_bLoadingCounters;
    BOOL        m_bMissedSample;
    BOOL        m_bDisplayedMissedSampleMessage;
    BOOL        m_bSettingsLoaded;
    LONG        m_lSaveDataToLogFilterValue;
    LCID        m_lcidCurrent;

    // Item properties, for saving and loading counters.
    COLORREF    m_clrCounter;
    INT         m_iColorIndex;
    INT         m_iWidthIndex;
    INT         m_iStyleIndex;
    INT         m_iScaleFactor;

    HFONT       m_hFont;
    COleFont    m_OleFont;
    PDH_BROWSE_DLG_CONFIG   m_BrowseInfo;
    CGraphItem* m_pSelectedItem;
    HACCEL      m_hAccel;
    DATA_SOURCE_INFO    m_DataSourceInfo;
    COLLECT_PROC_INFO   m_CollectInfo;
    CRITICAL_SECTION    m_CounterDataLock;
    RECT        m_rectCurrentClient;

    LPWSTR      m_szErrorPathList;
    DWORD       m_dwErrorPathListLen;
    DWORD       m_dwErrorPathBufLen;

};

typedef CSysmonControl *PSYSMONCTRL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\snapbar.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    snapbar.cpp

Abstract:

    Implementation of the snapshot icon.

--*/

#include <windows.h>
#include "snapbar.h"
#include "resource.h"

#define SNAPBTN_HEIGHT 24
#define SNAPBTN_WIDTH  32
#define SNAPBTN_VMARGIN 1
#define SNAPBTN_HMARGIN 8

#define SNAPBAR_HEIGHT (SNAPBTN_HEIGHT + 2 * SNAPBTN_VMARGIN)
#define SNAPBAR_WIDTH (SNAPBTN_WIDTH + SNAPBTN_HMARGIN)

CSnapBar::CSnapBar (
    VOID
    )
{
    m_hWnd = NULL;
    m_hBitmap = NULL;
}

CSnapBar::~CSnapBar (
    VOID
    )
{
    if (m_hWnd != NULL && IsWindow(m_hWnd))
        DestroyWindow(m_hWnd);

    if (m_hBitmap != NULL)
        DeleteObject(m_hBitmap);
}

BOOL
CSnapBar::Init (
    IN CSysmonControl *pCtrl,
    IN HWND hWndParent
    )
{
    HINSTANCE hInst;
    
    m_pCtrl = pCtrl;

    hInst = (HINSTANCE) GetWindowLongPtr(hWndParent, GWLP_HINSTANCE);

    // Create the button window
    m_hWnd = CreateWindow(TEXT("BUTTON"), NULL,
                          WS_VISIBLE| WS_CHILD| BS_BITMAP| BS_PUSHBUTTON,
                          0, 0, SNAPBTN_WIDTH, SNAPBTN_HEIGHT,
                          hWndParent,
                          (HMENU)IDC_SNAPBTN,
                          hInst,
                          NULL);
    if (m_hWnd == NULL)
        return FALSE;

    // Point back to object
    //SetWindowLongPtr(m_hWnd, 0, (INT_PTR)this);

    // Insert our own window procedure for special processing
    //m_WndProc = (WNDPROC)SetWindowLongPtr(hWndParent, GWLP_WNDPROC, (INT_PTR)SnapBarWndProc);
     
    // Load the bitmap
    m_hBitmap = LoadBitmap(hInst, MAKEINTRESOURCE(IDB_SNAPBTN));

    if (m_hBitmap == NULL)
        return FALSE;
    
    // Assign it to the button
    SendMessage(m_hWnd, BM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)m_hBitmap);

    return TRUE;
}


INT
CSnapBar::Height (
    IN INT iMaxHeight
    )
{
    return (iMaxHeight >= SNAPBAR_HEIGHT) ? SNAPBAR_HEIGHT : 0;
}


VOID
CSnapBar::SizeComponents (
    IN LPRECT pRect
    )
{
    // If room for the button
    if ((pRect->bottom - pRect->top) >= SNAPBAR_HEIGHT &&
        (pRect->right - pRect->left) >= SNAPBAR_WIDTH ) {

        // Position it in top right corner of space
        MoveWindow(m_hWnd, pRect->right - SNAPBAR_WIDTH, 
                    pRect->top + SNAPBTN_VMARGIN, SNAPBTN_WIDTH, SNAPBTN_HEIGHT, 
                    FALSE); 
        ShowWindow(m_hWnd, TRUE);
    }
    else {
        ShowWindow(m_hWnd, FALSE);
    }
}


LRESULT CALLBACK 
SnapBarWndProc (
    HWND hWnd,
    UINT uiMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PSNAPBAR pObj = (PSNAPBAR)GetWindowLongPtr(hWnd,0);
    // Give up focus after mouse activation
    if (uiMsg == WM_CAPTURECHANGED)
        SetFocus(GetParent(hWnd));

    // Do normal processing
#ifdef STRICT
    return CallWindowProc(pObj->m_WndProc, hWnd, uiMsg, wParam, lParam);
#else
    return CallWindowProc((FARPROC)pObj->m_WndProc, hWnd, uiMsg, wParam, lParam);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\smonid.h ===
// Copyright (C) Microsoft Corporation, 2000-20001
//
// DISPID values for Sysmon.ocx
//
// Just follow the template when adding either DISPIDs or new interfaces.
//

#ifndef __SYSMONDISPID_H__
#define __SYSMONDISPID_H__

#define DISPID_COUNTERITEM_COLOR                                0x0001
#define DISPID_COUNTERITEM_WIDTH                                0x0002
#define DISPID_COUNTERITEM_LINESTYLE                            0x0003
#define DISPID_COUNTERITEM_SCALEFACTOR                          0x0004
#define DISPID_COUNTERITEM_PATH                                 0x0005

#define DISPID_SYSMON_VERTICALGRID                              0x0001
#define DISPID_SYSMON_HORIZONTALGRID                            0x0002
#define DISPID_SYSMON_LEGEND                                    0x0003
#define DISPID_SYSMON_SCALELABELS                               0x0004
#define DISPID_SYSMON_VALUEBAR                                  0x0005
#define DISPID_SYSMON_MAXIMUMSCALE                              0x0006
#define DISPID_SYSMON_MINIMUMSCALE                              0x0007
#define DISPID_SYSMON_UPDATEINTERVAL                            0x0008
#define DISPID_SYSMON_DISPLAYTYPE                               0x0009
#define DISPID_SYSMON_MANUALUPDATE                              0x0010
#define DISPID_SYSMON_GRAPHTITLE                                0x0011
#define DISPID_SYSMON_YAXISLABEL                                0x0012
// Win2K Beta 1: Counter collection = 13
#define DISPID_SYSMON_COLLECTSAMPLE                             0x0014
#define DISPID_SYSMON_UPDATEGRAPH                               0x0015
#define DISPID_SYSMON_BROWSECOUNTERS                            0x0016
#define DISPID_SYSMON_DISPLAYPROPERTIES                         0x0017
#define DISPID_SYSMON_COUNTER                                   0x0018
#define DISPID_SYSMON_ADDCOUNTER                                0x0019
#define DISPID_SYSMON_DELETECOUNTER                             0x0020
#define DISPID_SYSMON_BACKCOLORCTL                              0x0021
#define DISPID_SYSMON_LOGFILENAME                               0x0022
#define DISPID_SYSMON_LOGVIEWSTART                              0x0023
#define DISPID_SYSMON_LOGVIEWSTOP                               0x0024
#define DISPID_SYSMON_GRIDCOLOR                                 0x0025
#define DISPID_SYSMON_TIMEBARCOLOR                              0x0026
#define DISPID_SYSMON_HIGHLIGHT                                 0x0027
#define DISPID_SYSMON_TOOLBAR                                   0x0028
#define DISPID_SYSMON_PASTE                                     0x0029
#define DISPID_SYSMON_COPY                                      0x0030
#define DISPID_SYSMON_RESET                                     0x0031
#define DISPID_SYSMON_READONLY                                  0x0032
#define DISPID_SYSMON_REPORTVALUETUPE                           0x0033
#define DISPID_SYSMON_MONITORDUPLICATEINSTANCES                 0x0034
#define DISPID_SYSMON_DISPLAYFILTER                             0x0035
#define DISPID_SYSMON_LOGFILES                                  0x0036
#define DISPID_SYSMON_DATASOURCETYPE                            0x0037
#define DISPID_SYSMON_SQLDSNNAME                                0x0038
#define DISPID_SYSMON_SQLLOGSETNAME                             0x0039

#define DISPID_SMONEVENT_COUNTERSELECTED                        0x0001
#define DISPID_SMONEVENT_COUNTERADDED                           0x0002
#define DISPID_SMONEVENT_COUNTERDELETED                         0x0003
#define DISPID_SMONEVENT_SAMPLECOLLECTED                        0x0004
#define DISPID_SMONEVENT_DBLCLICK                               0x0005

#endif  //__SYSMONDISPID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\smonctrl.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    smonctrl.cpp

Abstract:

    This module handles the graphing window.

--*/

#pragma warning ( disable : 4127 )

#ifndef _LOG_INCLUDE_DATA 
#define _LOG_INCLUDE_DATA 0
#endif

//==========================================================================//
//                                  Includes                                //
//==========================================================================//

#include <limits.h>     // for INT_MAX
#include <assert.h>

#include <windows.h>    // for Common controls below
#ifdef _WIN32_IE
#if      _WIN32_IE < 0x0400
#undef     _WIN32_IE
#define    _WIN32_IE 0x0400 // for NMTBCUSTOMDRAW 
#endif // < 0x0400
#endif // defined
#include <commctrl.h>
#include <htmlhelp.h>
#include <shellapi.h>
#include <pdhp.h>
#include "polyline.h"
#include "cntrtree.h"
#include "utils.h"
#include "commdlg.h"
#include "unihelpr.h"
#include "winperf.h"
#include "pdhmsg.h"
#include "smonmsg.h"
#include "visuals.h"
#include "statbar.h"
#include "snapbar.h"
#include "legend.h"
#include "toolbar.h"    
#include "grphdsp.h"
#include "report.h"
#include "browser.h"
#include "appmema.h"
#include "ipropbag.h"
#include "logsrc.h"
#include "smonmsg.h"
#include "smonid.h"
#include "smonctrl.h"
#include "strnoloc.h"


//==========================================================================//
//                                  Constants                               //
//==========================================================================//
extern CCounterTree g_tree;
extern DWORD        g_dwScriptPolicy;

#define     DBG_SHOW_STATUS_PRINTS  1

//=============================//
// Graph Class                 //
//=============================//

static DWORD   dwDbgPrintLevel = 0;

static TCHAR   szSysmonCtrlWndClass[] = TEXT("SysmonCtrl") ;

static TCHAR   LineEndStr[] = TEXT("\n") ;
static TCHAR   SpaceStr[] = TEXT(" ");

typedef struct {
    CSysmonControl  *pCtrl;
    PCGraphItem     pFirstItem;
} ENUM_ADD_COUNTER_CALLBACK_INFO;


BOOL
APIENTRY
SaveDataDlgHookProc (
    HWND hDlg,
    UINT iMessage,
    WPARAM wParam,
    LPARAM lParam
)
{
    BOOL           bHandled ;
    CSysmonControl *pCtrl;
    LONG           lFilterValue;
    BOOL           bGoodNumber = FALSE;

    UNREFERENCED_PARAMETER (wParam);
    // lparam = CSysmonControl class pointer

    bHandled = TRUE ;

    switch (iMessage) {
        case WM_INITDIALOG:
            // initialize the filter edit control with the current value
            OPENFILENAME    *pOfn;

            pOfn= (OPENFILENAME *)lParam;

            // get the control class pointer from the OPENFILENAME struct
            pCtrl = (CSysmonControl  *)pOfn->lCustData;
            
            // save the pointer to the control class as a DLG data word
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR)pCtrl);
            lFilterValue = pCtrl->GetSaveDataFilter();
            SetDlgItemInt (hDlg, IDC_SAVEDATA_EDIT, (UINT)lFilterValue, FALSE);
            // limit reduction to 1/9999  records
            SendDlgItemMessage (hDlg, IDC_SAVEDATA_EDIT, EM_LIMITTEXT, (WPARAM)4, (LPARAM)0);
            
            bHandled = TRUE ;
            break ;

        case WM_DESTROY:
            // the user has closed the dialog box so get the relog filter value
            // (note: this should be ignored if the user cancels the dialog)
            pCtrl = (CSysmonControl *)GetWindowLongPtr (hDlg, DWLP_USER);
            lFilterValue = GetDlgItemInt (hDlg, IDC_SAVEDATA_EDIT, &bGoodNumber, FALSE);
            if (bGoodNumber) {
                pCtrl->SetSaveDataFilter( lFilterValue );
            }
            bHandled = TRUE ;
            break ;

#if 0
        TODO. Tempoarily commented out the warning message code, after RC2,
              Enable this piece of code 
        case WM_COMMAND:
            if ( (LOWORD(wParam) == IDC_SAVEDATA_EDIT) && (HIWORD(wParam) == EN_CHANGE) ) 
            {
                lFilterValue = GetDlgItemInt (hDlg, IDC_SAVEDATA_EDIT, &bGoodNumber, FALSE);
                if (bGoodNumber && lFilterValue == 0) {

                    pCtrl = (CSysmonControl *)GetWindowLongPtr (hDlg, DWLP_USER);
 
                    MessageBox(hDlg,
                              ResourceString(IDS_BAD_INPUT_ERR), 
                              ResourceString(IDS_APP_NAME), 
                              MB_OK | MB_ICONSTOP);
 
                    lFilterValue = pCtrl->GetSaveDataFilter();
                    SetDlgItemInt (hDlg, IDC_SAVEDATA_EDIT, (UINT)lFilterValue, FALSE);
                    bHandled = TRUE;
                }
            }
#endif

        default:
            bHandled = FALSE ;
            break;
    }

    return (bHandled) ;
}

HRESULT
AddCounterCallback (
    LPTSTR      pszPathName,
    DWORD_PTR   lpUserData,          
    DWORD       dwFlags
    )
{
    ENUM_ADD_COUNTER_CALLBACK_INFO *pInfo = (ENUM_ADD_COUNTER_CALLBACK_INFO*)lpUserData;                        
    CSysmonControl *pCtrl = pInfo->pCtrl;                       
    PCGraphItem pGraphItem;
    HRESULT hr;

    hr = pCtrl->AddSingleCounter(pszPathName, &pGraphItem);

    if (SUCCEEDED(hr)) {

        if (dwFlags & BROWSE_WILDCARD) 
            pGraphItem->m_fGenerated = TRUE;

        if ( NULL == pInfo->pFirstItem ) {
            // Keep the reference count if returning the pointer.
           pInfo->pFirstItem = pGraphItem;
        } else {
            pGraphItem->Release();
        }
    }

    return hr;
}


#pragma warning( disable : 4355 ) // "this" use in initializer list

CSysmonControl::CSysmonControl( 
    PCPolyline pObj )
    :   m_OleFont(this),
        m_pObj(pObj),               // Pointer back to owner.
        m_fInitialized(FALSE),
        m_fViewInitialized(FALSE),
        m_hWnd(NULL),
        m_pLegend(NULL),
        m_pGraphDisp(NULL),
        m_pStatsBar(NULL),
        m_pSnapBar(NULL),
        m_pReport(NULL),
        m_pToolbar(NULL),        
        m_hQuery(NULL),
        m_TimerID(0),
        m_fPendingUpdate(FALSE),
        m_fPendingSizeChg(FALSE),   
        m_fPendingFontChg(FALSE),
        m_fPendingLogViewChg(FALSE),
        m_fPendingLogCntrChg(FALSE),
        m_pSelectedItem(NULL),
        m_fUIDead(FALSE),
        m_fUserMode(FALSE),
        m_hAccel(NULL),
        m_bLogFileSource(FALSE),
        m_bSampleDataLoaded(FALSE),
        m_bLoadingCounters(FALSE),
        m_bMissedSample(FALSE),
        m_bDisplayedMissedSampleMessage(FALSE),
        m_bSettingsLoaded(FALSE),
        m_szErrorPathList ( NULL ),
        m_dwErrorPathListLen ( 0 ),
        m_dwErrorPathBufLen ( 0 ),
        // Default attributes
        m_iColorIndex(0),
        m_iWidthIndex(0),
        m_iStyleIndex(0),
        m_iScaleFactor(INT_MAX),
        m_iAppearance(eAppear3D),
        m_iBorderStyle(eBorderNone),
        m_dZoomFactor(1.0),
        m_lcidCurrent ( LOCALE_USER_DEFAULT ) 
{
    PGRAPH_OPTIONS  pOptions;

    m_LoadedVersion.iMajor = SMONCTRL_MAJ_VERSION;
    m_LoadedVersion.iMinor = SMONCTRL_MIN_VERSION;

    m_clrBackCtl = GetSysColor(COLOR_BTNFACE);
    m_clrFgnd = GetSysColor(COLOR_BTNTEXT);
    m_clrBackPlot = GetSysColor(COLOR_WINDOW);

    m_clrGrid = RGB(128,128,128);   // Medium gray
    m_clrTimeBar = RGB(255,0,0);    // Red

    m_lSaveDataToLogFilterValue = 1;    // default save data to log filter is 1
    // Init graph parameters
    pOptions = &pObj->m_Graph.Options;

    pOptions->bLegendChecked = TRUE;
    pOptions->bToolbarChecked = TRUE;
    pOptions->bLabelsChecked = TRUE;
    pOptions->bVertGridChecked = FALSE;
    pOptions->bHorzGridChecked = FALSE;
    pOptions->bValueBarChecked = TRUE;
    pOptions->bManualUpdate = FALSE;
    pOptions->bHighlight = FALSE;    
    pOptions->bReadOnly = FALSE;
    pOptions->bMonitorDuplicateInstances = TRUE;
    pOptions->bAmbientFont = TRUE;
    pOptions->iVertMax = 100;
    pOptions->iVertMin = 0;
    pOptions->fUpdateInterval = (float)1.0;
    pOptions->iDisplayFilter = 1;
    pOptions->iDisplayType = sysmonLineGraph;
    pOptions->iReportValueType = sysmonDefaultValue;
    pOptions->pszGraphTitle = NULL;
    pOptions->pszYaxisTitle = NULL;
    pOptions->clrBackCtl = ( 0x80000000 | COLOR_BTNFACE );
    pOptions->clrGrid = m_clrGrid;
    pOptions->clrTimeBar = m_clrTimeBar;
    pOptions->clrFore = NULL_COLOR; 
    pOptions->clrBackPlot = NULL_COLOR; 
    pOptions->iAppearance = NULL_APPEARANCE;    
    pOptions->iBorderStyle = eBorderNone;
    pOptions->iDataSourceType = sysmonCurrentActivity;

    // Init data source info
    memset ( &m_DataSourceInfo, 0, sizeof ( m_DataSourceInfo ) );
    m_DataSourceInfo.llStartDisp = MIN_TIME_VALUE;
    m_DataSourceInfo.llStopDisp = MAX_TIME_VALUE;

    // Init collection thread info
    m_CollectInfo.hThread = NULL;
    m_CollectInfo.hEvent = NULL;
    m_CollectInfo.iMode = COLLECT_SUSPEND;
    InitializeCriticalSection(&m_CounterDataLock);

    // Cache pointer to object's history control
    m_pHistCtrl = &pObj->m_Graph.History;

    assert ( NULL != pObj );

    pObj->m_Graph.LogViewTempStart = MIN_TIME_VALUE;
    pObj->m_Graph.LogViewTempStop = MAX_TIME_VALUE;

    // Init the log view and time steppers.  They might be used before
    // SizeComponents is called, for example when a property bag is loaded.  
    // The width has not been calculated yet, is initialized here 
    // to an arbitrary number.

    pObj->m_Graph.TimeStepper.Init( MAX_GRAPH_SAMPLES, MAX_GRAPH_SAMPLES - 2 );
    pObj->m_Graph.LogViewStartStepper.Init( MAX_GRAPH_SAMPLES, MAX_GRAPH_SAMPLES - 2 );
    pObj->m_Graph.LogViewStopStepper.Init( MAX_GRAPH_SAMPLES, MAX_GRAPH_SAMPLES - 2 );        
    
    m_pHistCtrl->bLogSource = FALSE;
    m_pHistCtrl->nMaxSamples = MAX_GRAPH_SAMPLES;
    m_pHistCtrl->iCurrent = 0;
    m_pHistCtrl->nSamples = 0;
    m_pHistCtrl->nBacklog = 0;

    // Keep record of current size to avoide unnecessary calls to SizeComponents
    SetRect ( &m_rectCurrentClient,0,0,0,0 );
}

BOOL
CSysmonControl::AllocateSubcomponents( void )
{
    BOOL bResult = TRUE;
    m_pLegend = new CLegend;
    m_pGraphDisp = new CGraphDisp;
    m_pStatsBar = new CStatsBar;
    m_pSnapBar = new CSnapBar;
    m_pReport = new CReport;
    m_pToolbar = new CSysmonToolbar;

    if (!m_pLegend)
        bResult = FALSE;
    if (!m_pGraphDisp)
        bResult = FALSE;
    if (!m_pStatsBar)
        bResult = FALSE;
    if (!m_pSnapBar)
        bResult = FALSE;
    if (!m_pReport)
        bResult = FALSE;
    if (!m_pToolbar)
        bResult = FALSE;
    if (!bResult) {
        DeInit();
        return bResult;
    }

    if ( FAILED(m_OleFont.Init()) )
        bResult = FALSE;

    return bResult;

}




CSysmonControl::~CSysmonControl( void )
{
    PCGraphItem     pItem; 
    PCGraphItem     pNext;
    PCLogFileItem   pLogFile; 
    PCLogFileItem   pNextLogFile;

    CloseQuery();

    DeInit();

    DeleteCriticalSection(&m_CounterDataLock);

    // Release all graph items
    pItem = FirstCounter();
    while ( NULL != pItem ) {
        pNext = pItem->Next();
        pItem->Release();
        pItem = pNext;
    }

    // Release all log file items
    pLogFile = FirstLogFile();
    while ( NULL != pLogFile ) {
        pNextLogFile = pLogFile->Next();
        pLogFile->Release();
        pLogFile = pNextLogFile;
    }

    if (m_DataSourceInfo.szSqlDsnName != NULL) {
        delete(m_DataSourceInfo.szSqlDsnName);
        m_DataSourceInfo.szSqlDsnName = NULL;
    }

    if (m_DataSourceInfo.szSqlLogSetName != NULL) {
        delete(m_DataSourceInfo.szSqlLogSetName);
        m_DataSourceInfo.szSqlLogSetName = NULL;
    }

    if (m_hWnd != NULL)
         DestroyWindow(m_hWnd);

    if (m_pObj->m_Graph.Options.pszGraphTitle != NULL)
        delete(m_pObj->m_Graph.Options.pszGraphTitle);

    if (m_pObj->m_Graph.Options.pszYaxisTitle != NULL)
        delete(m_pObj->m_Graph.Options.pszYaxisTitle);

    ClearErrorPathList();
}

void CSysmonControl::DeInit( void )
{
    if (m_pLegend) {
        delete m_pLegend;
        m_pLegend = NULL;
    }
    if (m_pGraphDisp) {
        delete m_pGraphDisp;
        m_pGraphDisp = NULL;
    }
    if (m_pStatsBar) {
        delete m_pStatsBar;
        m_pStatsBar = NULL;
    }
    if (m_pSnapBar) {
        delete m_pSnapBar;
        m_pSnapBar = NULL;
    }
    if (m_pReport) {
        delete m_pReport;
        m_pReport = NULL;
    }
    if (m_pToolbar) {
        delete m_pToolbar;
        m_pToolbar = NULL;
    }
    ClearErrorPathList();
}

void CSysmonControl::ApplyChanges( HDC hAttribDC )
{
    if ( m_fPendingUpdate ) {

        // Clear the master update flag
        m_fPendingUpdate = FALSE;

        // set the toolbar state
        m_pToolbar->ShowToolbar(m_pObj->m_Graph.Options.bToolbarChecked);

        // If log view changed or counters added
        // we need to resample the log file
        if (m_fPendingLogViewChg || m_fPendingLogCntrChg) {

             SampleLogFile(m_fPendingLogViewChg);
             // Must init time steppers before calling ResetLogViewTempTimeRange
             ResetLogViewTempTimeRange ( );
             m_fPendingLogViewChg = FALSE;
             m_fPendingLogCntrChg = FALSE;
        }

        if (m_fPendingFontChg || m_fPendingSizeChg) {

             //CalcZoomFactor();  

            if (m_fPendingFontChg) {
                if (NULL != hAttribDC ) {
                    m_pLegend->ChangeFont(hAttribDC);
                    m_pStatsBar->ChangeFont(hAttribDC);
                    m_pGraphDisp->ChangeFont(hAttribDC);
                    m_fPendingFontChg = FALSE;
                }
            }

            if ( NULL != hAttribDC ) {
                SizeComponents( hAttribDC );
                m_fPendingSizeChg = FALSE;
            }
        }
    
        m_pToolbar->SyncToolbar();
    }
}

void 
CSysmonControl::DrawBorder ( HDC hDC )
{
    if ( eBorderSingle == m_iBorderStyle ) {
        RECT rectClient;
        // Get dimensions of window
        GetClientRect (m_hWnd, &rectClient) ;

        if ( eAppear3D == m_iAppearance ) {
            DrawEdge(hDC, &rectClient, EDGE_RAISED, BF_RECT);
        } else {
            SelectBrush (hDC, GetStockObject (HOLLOW_BRUSH)) ;
            SelectPen (hDC, GetStockObject (BLACK_PEN)) ;
            Rectangle (hDC, rectClient.left, rectClient.top, rectClient.right, rectClient.bottom );
        }
    }
}

void CSysmonControl::Paint ( void )
{
    HDC            hDC ;
    PAINTSTRUCT    ps ;

    if ( DisplayMissedSampleMessage() ) {
        MessageBox(m_hWnd, ResourceString(IDS_SAMPLE_DATA_MISSING), ResourceString(IDS_APP_NAME),
                    MB_OK | MB_ICONINFORMATION);
    }

    hDC = BeginPaint (m_hWnd, &ps) ;

    ApplyChanges( hDC ) ;

    if ( m_fViewInitialized ) {

        m_pStatsBar->Draw(hDC, hDC, &ps.rcPaint);
        m_pGraphDisp->Draw(hDC, hDC, FALSE, FALSE, &ps.rcPaint);

        DrawBorder( hDC );

    }

    EndPaint (m_hWnd, &ps) ;
}

void 
CSysmonControl::OnDblClick(INT x, INT y)
{
    if ( REPORT_GRAPH != m_pObj->m_Graph.Options.iDisplayType ) {
        PCGraphItem pItem = m_pGraphDisp->GetItem ( x,y );      
        if ( NULL != pItem ) {
            SelectCounter( pItem );
            DblClickCounter ( pItem );
        }
    } else {
        assert ( FALSE );
    }
}

DWORD
CSysmonControl::ProcessCommandLine ( )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    LPCWSTR pszNext;
    LPTSTR  pszWmi = NULL;
    LPTSTR  pszSettings = NULL;
    LPWSTR* pszArgList = NULL;
    INT     iNumArgs;
    INT     iArgIndex;
    LPWSTR  pszNextArg = NULL;
    LPWSTR  pszThisArg = NULL;
    TCHAR   szFileName[MAX_PATH];
    TCHAR   szTemp[MAX_PATH];
    LPTSTR  pszToken = NULL;
    HRESULT hr = S_OK;

    pszWmi = ResourceString ( IDS_CMDARG_WMI );
    pszSettings = ResourceString ( IDS_CMDARG_SETTINGS );

    pszNext = GetCommandLineW();
    pszArgList = CommandLineToArgvW ( pszNext, &iNumArgs );

    if ( NULL != pszArgList ) {
 
        // This code assumes that UNICODE is defined.  That is, TCHAR is the 
        // same size as WCHAR.
        // Todo:  Define _T constants as L constants
        // Todo:  Filename, etc. as WCHAR
        assert ( sizeof(TCHAR) == sizeof (WCHAR) );

        for ( iArgIndex = 0; iArgIndex < iNumArgs; iArgIndex++ ) {
            pszNextArg = (LPWSTR)pszArgList[iArgIndex];
            pszThisArg = pszNextArg;

            while ( 0 != *pszThisArg ) {
                if ( *pszThisArg++ == _T('/') ) {  // argument found
                
                    lstrcpyn ( szTemp, pszThisArg, min(lstrlen(pszThisArg)+1, MAX_PATH ) );
                
                    pszToken = _tcstok ( szTemp, _T("/ =\"") );

                    if ( 0 == lstrcmpi ( pszToken, pszWmi ) ) {
                        // Ignore PDH errors.  The only possible error is that the default data source has
                        // already been set for this process.
                        PdhSetDefaultRealTimeDataSource ( DATA_SOURCE_WBEM );

                    } else if ( 0 == lstrcmpi ( pszToken, pszSettings ) ) {

                        // Strip the initial non-token characters for string comparison.
                        pszThisArg = _tcsspnp ( pszNextArg, _T("/ =\"") );
                        
                        if ( 0 == lstrcmpi ( pszThisArg, pszSettings ) ) {
                            // Get the next argument (the file name)
                            iArgIndex++;
                            pszNextArg = (LPWSTR)pszArgList[iArgIndex];
                            pszThisArg = pszNextArg;                                                
                        } else {
                            // File was created by Windows 2000 perfmon5.exe, 
                            // so file name is part of the arg.
                            ZeroMemory ( szFileName, sizeof ( szFileName ) );
                            pszThisArg += lstrlen ( pszSettings );
                            lstrcpyn ( szFileName, pszThisArg, min(lstrlen(pszThisArg)+1, MAX_PATH ) );
                            pszThisArg = _tcstok ( szFileName, _T("=\"") );
                        }

                        hr = LoadFromFile( pszThisArg, TRUE );

                        if ( SMON_STATUS_NO_SYSMON_OBJECT != hr ) {
                            if ( SUCCEEDED ( hr ) ) {
                                m_bSettingsLoaded = TRUE;  
                            } //  else LoadFromFile displays messages for other errors 
                        } else {
                            // SMON_STATUS_NO_SYSMON_OBJECT == hr 
                            MessageBox(
                                m_hWnd, 
                                ResourceString(IDS_NOSYSMONOBJECT_ERR ), 
                                ResourceString(IDS_APP_NAME),
                                MB_OK | MB_ICONERROR);
                        }
                    }
                }
            }
        }
    }

    if ( NULL != pszArgList ) {
        GlobalFree ( pszArgList );
    }

    return dwStatus;
}

HRESULT
CSysmonControl::LoadFromFile ( LPTSTR  pszFileName, BOOL bAllData )
{
    HRESULT         hr = S_OK;
    TCHAR           szLocalName [MAX_PATH+1];
    LPTSTR          pFileNameStart;
    HANDLE          hFindFile;
    WIN32_FIND_DATA FindFileInfo;
    INT             iNameOffset;

    lstrcpyn ( szLocalName, pszFileName, MAX_PATH );
    pFileNameStart = ExtractFileName (szLocalName) ;
    iNameOffset = (INT)(pFileNameStart - szLocalName);

    // convert short filename to long NTFS filename if necessary
    hFindFile = FindFirstFile ( szLocalName, &FindFileInfo) ;
    if (hFindFile && hFindFile != INVALID_HANDLE_VALUE) {
        if ( ConfirmSampleDataOverwrite ( ) ) {
            DWORD dwMsgStatus = ERROR_SUCCESS;
            HANDLE hOpenFile;
            INT iCharCount;

            // append the file name back to the path name

            iCharCount = lstrlen (FindFileInfo.cFileName)+1;
            iCharCount = min (iCharCount, ( MAX_PATH - iNameOffset ));
            
            lstrcpyn (&szLocalName[iNameOffset], FindFileInfo.cFileName, iCharCount) ;

            FindClose (hFindFile) ;
            // Open the file
            hOpenFile = CreateFile (
                            szLocalName, 
                            GENERIC_READ,
                            0,                  // Not shared
                            NULL,               // Security attributes
                            OPEN_EXISTING,     
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

            if ( hOpenFile && hOpenFile != INVALID_HANDLE_VALUE ) {
                DWORD dwFileSize;
                DWORD dwFileSizeHigh;
                DWORD dwFileSizeRead;
                LPTSTR pszData;
            
                // Read the file contents into a memory buffer.
                dwFileSize = GetFileSize ( hOpenFile, &dwFileSizeHigh );

                assert ( 0 == dwFileSizeHigh );

                pszData = new TCHAR[(dwFileSize + sizeof(TCHAR))/sizeof(TCHAR)];
                if ( NULL != pszData ) {
                    if ( ReadFile ( hOpenFile, pszData, dwFileSize, &dwFileSizeRead, NULL ) ) {

                        // Paste all settings from the memory buffer.
                        hr = PasteFromBuffer ( pszData, bAllData );
                        if ( E_OUTOFMEMORY == hr ) {
                            dwMsgStatus = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    } else {
                        dwMsgStatus = GetLastError();
                        hr = HRESULT_FROM_WIN32(dwMsgStatus);
                    }
            
                    delete pszData;
                } else {
                    dwMsgStatus = ERROR_NOT_ENOUGH_MEMORY;
                    hr = E_OUTOFMEMORY;
                }

                CloseHandle ( hOpenFile );
            } else {
                // Return file system error
                dwMsgStatus = GetLastError();
                hr = HRESULT_FROM_WIN32(dwMsgStatus);
            }

            if ( ERROR_SUCCESS != dwMsgStatus ) {
                TCHAR* pszMessage = NULL;
                TCHAR szSystemMessage[MAX_PATH+1];

                pszMessage = new TCHAR [lstrlen(szLocalName) + 2*MAX_PATH + 1];

                if ( NULL != pszMessage ) {
                    _stprintf ( pszMessage, ResourceString(IDS_READFILE_ERR), szLocalName );

                    FormatSystemMessage ( dwMsgStatus, szSystemMessage, MAX_PATH*2 );

                    lstrcat ( pszMessage, szSystemMessage );

                    MessageBox(Window(), pszMessage, ResourceString(IDS_APP_NAME), 
                        MB_OK | MB_ICONSTOP);

                    delete pszMessage;
                }                    
            }
        }
    }
    return hr;
}


void 
CSysmonControl::OnDropFile ( WPARAM wParam )
{
    TCHAR           szFileName [MAX_PATH+1];
    INT             iFileCount = 0;
    HRESULT         hr = S_OK;

    USES_CONVERSION

    iFileCount = DragQueryFile ((HDROP) wParam, 0xffffffff, NULL, 0) ;
    if ( iFileCount > 0 ) {

        // we only open the first file for now
        DragQueryFile((HDROP) wParam, 0, szFileName, MAX_PATH+1) ;

        hr = LoadFromFile ( szFileName, FALSE );
        
        if ( SMON_STATUS_NO_SYSMON_OBJECT == hr ) {
            MessageBox(
                m_hWnd, 
                ResourceString(IDS_NOSYSMONOBJECT_ERR ), 
                ResourceString(IDS_APP_NAME),
                MB_OK | MB_ICONERROR);
        } //  else LoadFromFile displays messages for other errors 
    }

    DragFinish ((HDROP) wParam) ;
}

void 
CSysmonControl::DisplayContextMenu(short x, short y)
{
    HMENU   hMenu;
    HMENU   hMenuPopup;

    RECT    clntRect;
    int     iPosx=0;
    int     iPosy=0;
    int     iLocalx;
    int     iLocaly;

    GetWindowRect(m_hWnd,&clntRect);
    if (x==0){
        iPosx = ((clntRect.right - clntRect.left)/2) ;
    }else{
        iPosx = x - clntRect.left;
    }
    if (y==0){
        iPosy = ((clntRect.bottom - clntRect.top)/2) ;
    }else{
        iPosy = y - clntRect.top;
    }

    iLocalx = clntRect.left + iPosx ;
    iLocaly = clntRect.top  + iPosy ;

    if ( ConfirmSampleDataOverwrite () ) {
        if ( !IsReadOnly() ) {
            UINT    uEnable;
            // Get the menu for the pop-up menu from the resource file.
            hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDM_CONTEXT));
            if (!hMenu)
            return;

            // enable/disable SaveData option depending on data source
            uEnable = (IsLogSource() ? MF_ENABLED : MF_GRAYED);
            uEnable |= MF_BYCOMMAND;
            EnableMenuItem (hMenu, IDM_SAVEDATA, uEnable);

            // Get the first submenu in it for TrackPopupMenu. 
            hMenuPopup = GetSubMenu(hMenu, 0);

            // Draw and track the "floating" pop-up menu. 
            TrackPopupMenu(hMenuPopup, TPM_RIGHTBUTTON,
                        iLocalx, iLocaly, 0, m_hWnd, NULL);

            // Destroy the menu.
            DestroyMenu(hMenu);
        }
    }
}


HRESULT CSysmonControl::DisplayProperties ( DISPID dispID )
{
    HRESULT hr;
    CAUUID  caGUID;
    OCPFIPARAMS params;

    USES_CONVERSION

    // Give container a chance to show properties
    if (NULL!=m_pObj->m_pIOleControlSite) {
        hr=m_pObj->m_pIOleControlSite->ShowPropertyFrame();

        if (NOERROR == hr)
            return hr;
    }

    //Put up our property pages.

    ZeroMemory ( &params, sizeof ( OCPFIPARAMS ) );

    hr = m_pObj->m_pImpISpecifyPP->GetPages(&caGUID);

    if (FAILED(hr))
        return hr;

    params.cbStructSize = sizeof ( OCPFIPARAMS );
    params.hWndOwner = m_hWnd;
    params.x = 10;
    params.y = 10;
    params.lpszCaption = T2W(ResourceString(IDS_PROPFRM_TITLE));
    params.cObjects = 1;
    params.lplpUnk = (IUnknown **)&m_pObj,
    params.cPages = caGUID.cElems;
    params.lpPages = caGUID.pElems;
    params.lcid = m_lcidCurrent;
    params.dispidInitialProperty = dispID;

    hr = OleCreatePropertyFrameIndirect ( &params );

    //Free the GUIDs
    CoTaskMemFree((void *)caGUID.pElems);

    // Make sure correct window has the focus
    AssignFocus();

    return hr;
}


HRESULT
CSysmonControl::AddCounter(
    LPTSTR pszPath, 
    PCGraphItem *pGItem)
/*++

Routine Description:

    AddCounter returns a pointer to the created counter item, or
    to the first created counter item if multiple created for a wildcard
    path.   
    EnumExpandedPath calls the AddCallback function for each new counter.
    AddCallback passes the counter path on to the AddSingleCounter method.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HRESULT hr;
    ENUM_ADD_COUNTER_CALLBACK_INFO CallbackInfo;
    CallbackInfo.pCtrl = this;
    CallbackInfo.pFirstItem = NULL;
    
    *pGItem = NULL;

    // TodoLogFiles:  Handle multiple files
    hr = EnumExpandedPath(GetDataSourceHandle(), pszPath, AddCounterCallback, &CallbackInfo); 

    *pGItem = CallbackInfo.pFirstItem;

    return hr;
    
}


HRESULT
CSysmonControl::AddCounters (
    VOID
    )
/*++

Routine Description:

    AddCounters invokes the counter browser to select new counters.
    The browser calls the AddCallback function for each new counter.
    AddCallback passes the counter path on to the AddCounter method.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ENUM_ADD_COUNTER_CALLBACK_INFO CallbackInfo;
    CallbackInfo.pCtrl = this;
    CallbackInfo.pFirstItem = NULL;
    HRESULT hr;

    // Browse counters (calling AddCallback for each selected counter)
    // Todo:  Handle multiple files
    hr = BrowseCounters(
            GetDataSourceHandle(), 
            PERF_DETAIL_WIZARD, 
            m_hWnd, 
            AddCounterCallback, 
            &CallbackInfo,
            m_pObj->m_Graph.Options.bMonitorDuplicateInstances);

    // Make sure correct window has the focus
    AssignFocus();

    return hr;
}

HRESULT
CSysmonControl::SaveAs (
    VOID
    )
/*++

Routine Description:

    SaveAs writes the current configuration to an HTML file.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HRESULT         hr = S_OK;
    INT             iReturn = IDCANCEL;
    INT             i;
    OPENFILENAME    ofn;
    TCHAR           szFileName[MAX_PATH+1];
    TCHAR           szExt[MAX_PATH+1];
    TCHAR           szFileFilter[MAX_PATH+1];
    TCHAR           szDefExtension[MAX_PATH+1];

    // Initial directory is the current directory

    szFileName[0] = TEXT('\0');
    ZeroMemory(szFileFilter, sizeof ( szFileFilter ) );
    ZeroMemory(&ofn, sizeof(ofn));
    lstrcpy (szFileFilter,(LPTSTR) ResourceString (IDS_HTML_FILE));
    lstrcpy (szDefExtension,(LPTSTR) ResourceString (IDS_DEF_EXT));

    for( i = 0; szFileFilter[i]; i++ ){
       if( szFileFilter[i] == TEXT('|') ){
          szFileFilter[i] = 0;
       }
    }

    for( i = 0; szDefExtension[i]; i++ ){
       if( szDefExtension[i] == TEXT('|') ){
          szDefExtension[i] = 0;
       }
    }

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = Window();
    ofn.hInstance = NULL ;       // Ignored if no template argument
    ofn.lpstrFilter =  szFileFilter; 
    ofn.lpstrDefExt =  szDefExtension;
    ofn.nFilterIndex = 1; // nFilterIndex is 1-based
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.nMaxFileTitle = 0;
    ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    
    iReturn = GetSaveFileName (&ofn);
    // Differentiate between *.htm and *.tsv
    _tsplitpath(szFileName,NULL,NULL,NULL,szExt);
    if ( IDOK == iReturn ) {
        // Create a file.
        HANDLE hFile;
        DWORD   dwMsgStatus = ERROR_SUCCESS;
        
        hFile =  CreateFile (
                    szFileName, 
                    GENERIC_READ | GENERIC_WRITE,
                    0,              // Not shared
                    NULL,           // Security attributes
                    CREATE_NEW,     // Query the user if file already exists.
                    FILE_ATTRIBUTE_NORMAL,
                    NULL );

        if ( INVALID_HANDLE_VALUE == hFile ) {
            DWORD dwCreateError = GetLastError();
            
            if ( ERROR_SUCCESS != dwCreateError ) {
                // Confirm file overwrite.
                INT iOverwrite = IDNO;
                TCHAR* pszMessage = NULL;

                pszMessage = new TCHAR [lstrlen(szFileName) + MAX_PATH + 1];

                if ( NULL != pszMessage ) {
                    _stprintf ( pszMessage, ResourceString(IDS_HTML_FILE_OVERWRITE), szFileName );

                    iOverwrite = MessageBox(
                                        Window(), 
                                        pszMessage, 
                                        ResourceString(IDS_APP_NAME),
                                        MB_YESNO );

                    delete pszMessage;

                    if ( IDYES == iOverwrite ) {
                        hFile = CreateFile (
                                    szFileName, 
                                    GENERIC_READ | GENERIC_WRITE,
                                    0,              // Not shared
                                    NULL,           // Security attributes
                                    CREATE_ALWAYS,  // Overwrite any existing file.
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL );

                    }
                }
            } 
        }
        
        if ( INVALID_HANDLE_VALUE != hFile ) {
            LPTSTR  pszTemp = NULL;
            WCHAR   szByteOrderMark[2];
            BOOL    bStatus;
            CWaitCursor cursorWait;
            
            // Save the current configuration to the file.
            if( (!_tcscmp(szExt,ResourceString(IDS_HTM_EXTENSION)))
                || (!_tcscmp(szExt,ResourceString(IDS_HTML_EXTENSION))) ) {
                
                // Html file

                szByteOrderMark[0] = 0xFEFF;
                szByteOrderMark[1] = 0;
                bStatus = FileWrite ( hFile, szByteOrderMark, sizeof(WCHAR) );

                if ( bStatus ) {
                    pszTemp = ResourceString ( IDS_HTML_FILE_HEADER1 );
                    bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(TCHAR) );
                }

                if ( bStatus ) {
                    pszTemp = ResourceString ( IDS_HTML_FILE_HEADER2 );
                    bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(TCHAR) );
                }

                if ( bStatus ) {
                    DWORD dwByteCount;
                    pszTemp = NULL;
                    hr = CopyToBuffer ( pszTemp, dwByteCount );
                    
                    if ( SUCCEEDED ( hr ) ) {
                        assert ( NULL != pszTemp );
                        assert ( 0 != dwByteCount );
                        bStatus = FileWrite ( hFile, pszTemp, dwByteCount );
                        delete pszTemp;
                    } else {
                        bStatus = FALSE;
                        SetLastError ( ERROR_OUTOFMEMORY );
                    }
                }

                if ( bStatus ) {
                    pszTemp = ResourceString ( IDS_HTML_FILE_FOOTER );
                    bStatus = FileWrite ( hFile, pszTemp, lstrlen (pszTemp) * sizeof(TCHAR) );
                }

                if ( !bStatus ) {
                    dwMsgStatus = GetLastError();                
                }

                
            } else if (!_tcscmp(szExt,ResourceString(IDS_TSV_EXTENSION))){

                // Tsv file
                bStatus = WriteFileReportHeader(hFile);
                
                if  (bStatus){
                    bStatus = m_pReport->WriteFileReport(hFile);
                }

                if (!bStatus){
                    dwMsgStatus = GetLastError();
                }
            }            

            bStatus = CloseHandle ( hFile );
        } else {
            dwMsgStatus = GetLastError();        
        }
        
        if ( ERROR_SUCCESS != dwMsgStatus ) {
            TCHAR* pszMessage = NULL;
            TCHAR szSystemMessage[MAX_PATH+1];

            pszMessage = new TCHAR [lstrlen(szFileName) + 2*MAX_PATH + 1];

            if ( NULL != pszMessage ) {
                _stprintf ( pszMessage, ResourceString(IDS_SAVEAS_ERR), szFileName );

                FormatSystemMessage ( dwMsgStatus, szSystemMessage, MAX_PATH );

                lstrcat ( pszMessage, szSystemMessage );

                MessageBox(Window(), pszMessage, ResourceString(IDS_APP_NAME), MB_OK | MB_ICONSTOP);
                    
                delete pszMessage;
            }
        }

    } // else ignore if they canceled out

    // Make sure correct window has the focus
    AssignFocus();

    return hr;
}

HRESULT
CSysmonControl::SaveData (
    VOID
    )
/*++

Routine Description:

    SaveData writes the data from the display to a log file for 
    later input as a data source.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HRESULT         hr = S_OK;
    INT             iReturn = IDCANCEL;
    INT             i;
    OPENFILENAME    ofn;
    TCHAR           szFileName[MAX_PATH+1];
    TCHAR           szExt[MAX_PATH+1];
    TCHAR           szFileFilter[MAX_PATH+1];
    TCHAR           szDefExtension[MAX_PATH+1];
    TCHAR           szDialogCaption[MAX_PATH+1];
    DWORD           dwStatus;
    LONG            lOrigFilterValue;

    // Initial directory is the current directory

    szFileName[0] = TEXT('\0');
    ZeroMemory(szFileFilter, sizeof ( szFileFilter ) );
    ZeroMemory(&ofn, sizeof(ofn));
    lstrcpy (szFileFilter,(LPTSTR) ResourceString (IDS_LOG_FILE));
    lstrcpy (szDefExtension,(LPTSTR) ResourceString (IDS_LOG_FILE_EXTENSION));
    lstrcpy (szDialogCaption, (LPTSTR) ResourceString (IDS_SAVE_DATA_CAPTION));

    for( i = 0; szFileFilter[i]; i++ ){
       if( szFileFilter[i] == TEXT('|') ){
          szFileFilter[i] = 0;
       }
    }

    for( i = 0; szDefExtension[i]; i++ ){
       if( szDefExtension[i] == TEXT('|') ){
          szDefExtension[i] = 0;
       }
    }

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = Window();
    ofn.hInstance = GetModuleHandle((LPCTSTR)TEXT("sysmon.ocx")) ;       // Ignored if no template argument
    ofn.lpstrFilter =  szFileFilter; 
    ofn.lpstrDefExt =  szDefExtension;
    ofn.nFilterIndex = 1; // nFilterIndex is 1-based
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.nMaxFileTitle = 0;
    ofn.Flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY | 
                OFN_OVERWRITEPROMPT | OFN_ENABLETEMPLATE | OFN_ENABLEHOOK;
    ofn.lpstrTitle = szDialogCaption;
    ofn.lCustData = (DWORD_PTR)this;
    ofn.lpfnHook = (LPOFNHOOKPROC) SaveDataDlgHookProc ;
    ofn.lpTemplateName = MAKEINTRESOURCE(IDD_SAVEDATA_DLG) ;

    lOrigFilterValue = GetSaveDataFilter ();
    
    iReturn = GetSaveFileName (&ofn);
    // Differentiate between *.htm and *.tsv
    _tsplitpath(szFileName,NULL,NULL,NULL,szExt);
    if ( IDOK == iReturn ) {
        DWORD   dwOutputLogType = PDH_LOG_TYPE_BINARY;
        DWORD   dwFilterCount;  // copy all records within the timerange
        PDH_TIME_INFO   TimeInfo;

        // get log type from file name
        if (ofn.nFileExtension > 0) {
            if (ofn.lpstrFile[ofn.nFileExtension] != 0) {
                if (lstrcmpi (&ofn.lpstrFile[ofn.nFileExtension-1], ResourceString (IDS_CSV_EXTENSION)) == 0) {
                    dwOutputLogType = PDH_LOG_TYPE_CSV;
                } else if (lstrcmpi (&ofn.lpstrFile[ofn.nFileExtension-1], ResourceString (IDS_TSV_EXTENSION)) == 0) { 
                    dwOutputLogType = PDH_LOG_TYPE_TSV;
                } // else use binary log format as default
            } // else use binary log format as default
        } // else use binary log format as default

        // get timerange for this log
        TimeInfo.StartTime = m_DataSourceInfo.llStartDisp;
        TimeInfo.EndTime = m_DataSourceInfo.llStopDisp;

        dwFilterCount = GetSaveDataFilter();

        //
        // Double check the filter count is not 0
        //
        if (dwFilterCount == 0) {
            dwFilterCount = 1;
        }

        // now relog the data
        dwStatus = RelogLogData (
            ofn.lpstrFile,
            dwOutputLogType,
            TimeInfo,
            dwFilterCount);

    } else {
        // they canceled out so restore filter value
        SetSaveDataFilter (lOrigFilterValue);
    }

    // Make sure correct window has the focus
    AssignFocus();

    return hr;
}

DWORD
CSysmonControl::RelogLogData (
    LPCTSTR szOutputFile,
    DWORD   dwOutputLogType,
    PDH_TIME_INFO   pdhTimeInfo,
    DWORD   dwFilterCount
)
{
    DWORD           dwNumOutputCounters = 0;
    DWORD           dwRecCount          = 0;
    DWORD           dwFiltered;
    LONG            Status              = ERROR_SUCCESS;
    PDH_STATUS      PdhStatus;
    PDH_RAW_COUNTER RawValue;
    HQUERY          hQuery              = NULL;
    HLOG            hOutLog             = NULL;
    HCOUNTER        hCounter            = NULL;
    HCOUNTER        hLastGoodCounter    = NULL;
    DWORD           dwType;
    DWORD           dwOpenMode;
    HLOG            hDataSource;

    hDataSource         = GetDataSourceHandle();
    Status = PdhStatus = PdhOpenQueryH(hDataSource, 0L, &hQuery);
    if (Status == ERROR_SUCCESS) {
        LPTSTR  szCounterPath;
        TCHAR   szLocalCounterPathBuffer[MAX_PATH*4];
        TCHAR   szParent[MAX_PATH];
        TCHAR   szInstance[MAX_PATH];
        DWORD   dwBufferSize;
        TCHAR   szDebugMsg[1024];

        PDH_COUNTER_PATH_ELEMENTS LocalCounterPath;

        PCMachineNode   pMachine;
        PCObjectNode    pObject;
        PCInstanceNode  pInstance;
        PCCounterNode   pCounter;
        BOOL            bStatus = TRUE;

        szParent[0] = _T('\0');
        szInstance[0] = _T('\0');
        
        for (pMachine = CounterTree()->FirstMachine();
             pMachine && TRUE == bStatus;
             pMachine = pMachine->Next()) {

            LocalCounterPath.szMachineName = (LPTSTR)pMachine->Name();
            for (pObject = pMachine->FirstObject();
                 pObject && TRUE == bStatus;
                 pObject = pObject->Next()) {

                LocalCounterPath.szObjectName = (LPTSTR)pObject->Name();
                    
                // Write the first line of instance (parent) names.
                for (pInstance = pObject->FirstInstance();
                     pInstance && TRUE == bStatus;
                     pInstance = pInstance->Next()) {
                    
                    // If instance has no parent, then the parent name is
                    // null, so a tab is written.
                    //
                    pInstance->GetParentName(szParent);
                    if (szParent[0] == 0) {
                        LocalCounterPath.szParentInstance = NULL;
                    } else {
                        LocalCounterPath.szParentInstance = szParent;
                    }

                    pInstance->GetInstanceName(szInstance);
                    if (szInstance[0] == 0) {
                        LocalCounterPath.szInstanceName = NULL;
                    } else {
                        LocalCounterPath.szInstanceName = szInstance;
                    }
                    // BUGBUG: unless this is defined else
                    LocalCounterPath.dwInstanceIndex = 0;
     
                    for (pCounter = pObject->FirstCounter();
                         pCounter && TRUE == bStatus;
                         pCounter = pCounter->Next()) {

                        LocalCounterPath.szCounterName = (LPTSTR)pCounter->Name();

                        // then build one from the components
                        szCounterPath = szLocalCounterPathBuffer;
                        dwBufferSize = sizeof (szLocalCounterPathBuffer) / sizeof (TCHAR);
                        memset (szLocalCounterPathBuffer, 0, dwBufferSize * sizeof (TCHAR));
                        PdhStatus = PdhMakeCounterPathW(& LocalCounterPath,
                                                        szCounterPath,
                                                        & dwBufferSize,
                                                        0);
                        if (PdhStatus == ERROR_SUCCESS) {
                            PdhStatus = PdhAddCounter (hQuery, szCounterPath, 0L, &hCounter);
                            if (PdhStatus != ERROR_SUCCESS) {
                                if (dwDbgPrintLevel == DBG_SHOW_STATUS_PRINTS) {
                                    _stprintf (szDebugMsg, (LPCTSTR)TEXT("\nUnable to add \"%s\", error: 0x%8.8x (%d)"), szCounterPath, PdhStatus, PdhStatus);
                                    OutputDebugString (szDebugMsg);
                                }
                            } else {
                                hLastGoodCounter = hCounter;
                                dwNumOutputCounters++;
                                if (dwDbgPrintLevel == DBG_SHOW_STATUS_PRINTS) {
                                    _stprintf (szDebugMsg, (LPCTSTR)TEXT("\nAdded \"%s\", error: 0x%8.8x (%d)"), szCounterPath, PdhStatus, PdhStatus);
                                    OutputDebugString (szDebugMsg);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    if ((Status == ERROR_SUCCESS) && (dwNumOutputCounters > 0)) {
        dwOpenMode = PDH_LOG_WRITE_ACCESS | PDH_LOG_CREATE_ALWAYS;

        PdhStatus = PdhOpenLog(szOutputFile,
                               dwOpenMode,
                               & dwOutputLogType,
                               hQuery,
                               0L,
                               NULL,
                               & hOutLog);

        if (PdhStatus != ERROR_SUCCESS) {
            Status = PdhStatus;
        } else {
            // set query range
            PdhStatus = PdhSetQueryTimeRange (hQuery, &pdhTimeInfo);
            // copy log data to output log
            PdhStatus = PdhUpdateLog (hOutLog, NULL);
            while (PdhStatus == ERROR_SUCCESS) {
                dwRecCount++;
                dwFiltered = 1; 
                while ((dwFiltered < dwFilterCount) && (PdhStatus == ERROR_SUCCESS)) {
                    PdhStatus = PdhCollectQueryData(hQuery);
                    if (PdhStatus == ERROR_SUCCESS) {
                        PdhStatus = PdhGetRawCounterValue  (
                            hLastGoodCounter,
                            &dwType,
                            &RawValue);
                        if (PdhStatus == ERROR_SUCCESS) {
                            // check for bogus timestamps as an inidcation we ran off the end of the file
                            if ((*(LONGLONG *)&RawValue.TimeStamp == 0) ||
                                (*(LONGLONG *)&RawValue.TimeStamp >= pdhTimeInfo.EndTime)){
                                PdhStatus = PDH_END_OF_LOG_FILE;
                            }
                        }
                    }
                    dwFiltered++;
                }
                if (PdhStatus == ERROR_SUCCESS) {
                    PdhStatus = PdhUpdateLog (hOutLog, NULL);
                }
            }

            if (   (PdhStatus == PDH_END_OF_LOG_FILE)
                || (PdhStatus == PDH_NO_MORE_DATA)) {
                PdhStatus = ERROR_SUCCESS;
            }

            // update log catalog while we're at it
            if (dwOutputLogType == PDH_LOG_TYPE_BINARY) { 
                PdhStatus = PdhUpdateLogFileCatalog (hOutLog);
                if (PdhStatus != ERROR_SUCCESS) {
                    Status = PdhStatus;
                }
            }

            PdhStatus = PdhCloseLog(hOutLog, 0L);
            if (PdhStatus != ERROR_SUCCESS) {
                Status = PdhStatus;
            } else {
                hOutLog = NULL;
            }
        } 
    }

    if (hQuery != NULL) {
        PdhStatus = PdhCloseQuery(hQuery);
        if (PdhStatus != ERROR_SUCCESS) {
            Status = PdhStatus;
        } else {
            hQuery = NULL;
            hCounter = NULL;
        }
    }

    return Status;
}

BOOL 
CSysmonControl::WriteFileReportHeader(HANDLE hFile){

    BOOL        bStatus = TRUE;
    DWORD       dwStatus = ERROR_SUCCESS;
    SYSTEMTIME  SysTime;
    DWORD       dwSize  = MAX_COMPUTERNAME_LENGTH + 1 ;
    TCHAR       szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    TCHAR       szHeader[6 * MAX_PATH];
    TCHAR       szDateTime[MAX_PATH+1];
    LPWSTR      szDataSource = NULL;
    TCHAR       szTime[MAX_PATH+1];
    TCHAR       szDate[MAX_PATH+1];
    TCHAR       szValue[MAX_PATH+1];
    DWORD       dwValueId = IDS_DEFAULT;
    WCHAR       szByteOrderMark[2];
    ULONG       ulLogListBufLen = 0;

    // Computer name 
    if (!SUCCEEDED(GetComputerName(szComputerName,&dwSize))){
        szComputerName[0] = _T('\0');
    }

    // Current date and time 
    GetLocalTime(&SysTime);

    GetTimeFormat (m_lcidCurrent, 0, &SysTime, NULL, szTime, MAX_TIME_CHARS) ;
    GetDateFormat (m_lcidCurrent, DATE_SHORTDATE, &SysTime, NULL, szDate, MAX_DATE_CHARS) ;
    
    _stprintf(
        szDateTime,
        ResourceString( IDS_REPORT_DATE_TIME ),
        szDate,
        szTime );

    // Report value type

    switch ( m_pObj->m_Graph.Options.iReportValueType ) {
        case sysmonCurrentValue:
            dwValueId = IDS_LAST;
            break;
        case sysmonAverage:
            dwValueId = IDS_AVERAGE;
            break;
        case sysmonMinimum:
            dwValueId = IDS_MINIMUM;
            break;
        case sysmonMaximum:
            dwValueId = IDS_MAXIMUM;
            break;
        default:
            dwValueId = IDS_DEFAULT;
    }

    _stprintf(
        szValue,
        ResourceString ( IDS_REPORT_VALUE_TYPE ),
        ResourceString ( dwValueId ) );

    // Data source

    if ( sysmonCurrentActivity == m_pObj->m_Graph.Options.iDataSourceType ) {
        szDataSource = new WCHAR [MAX_PATH];
        if ( NULL != szDataSource ) {
            lstrcpy(szDataSource,ResourceString(IDS_REPORT_REAL_TIME));
        }
    } else if ( sysmonLogFiles == m_pObj->m_Graph.Options.iDataSourceType ) {
        dwStatus = BuildLogFileList ( 
                    NULL,
                    TRUE,
                    &ulLogListBufLen );
        szDataSource =  (LPWSTR) malloc(ulLogListBufLen * sizeof(WCHAR));
        if ( NULL != szDataSource ) {
            dwStatus = BuildLogFileList ( 
                        szDataSource,
                        TRUE,
                        &ulLogListBufLen );
        } else {
            dwStatus = ERROR_OUTOFMEMORY;
        }
    } else if ( sysmonSqlLog == m_pObj->m_Graph.Options.iDataSourceType ) {
        dwStatus = FormatSqlDataSourceName ( 
                    m_DataSourceInfo.szSqlDsnName,
                    m_DataSourceInfo.szSqlLogSetName,
                    NULL,
                    &ulLogListBufLen );

        if ( ERROR_SUCCESS == dwStatus ) {
            szDataSource = (LPWSTR) malloc(ulLogListBufLen * sizeof(WCHAR));
            if (szDataSource == NULL) {
                dwStatus = ERROR_OUTOFMEMORY;
            } else {
                dwStatus = FormatSqlDataSourceName ( 
                            m_DataSourceInfo.szSqlDsnName,
                            m_DataSourceInfo.szSqlLogSetName,
                            szDataSource,
                            &ulLogListBufLen );
            }
        }
    }
    
    // Header
    
    _stprintf(
        szHeader, 
        ResourceString(IDS_REPORT_HEADER),
        szComputerName,
        szDateTime,
        szValue,
        szDataSource );

    if ( NULL != szDataSource ) {
        free ( szDataSource );
    }

    if ( sysmonCurrentActivity == m_pObj->m_Graph.Options.iDataSourceType ) {
        TCHAR       szInterval[MAX_PATH+1];

        // Add sample interval for realtime data source.
        _stprintf(
            szInterval,
            ResourceString(IDS_REPORT_INTERVAL),
            m_pObj->m_Graph.Options.fUpdateInterval );

        lstrcat(szHeader,szInterval);

    } else if ( sysmonLogFiles == m_pObj->m_Graph.Options.iDataSourceType 
            || sysmonSqlLog == m_pObj->m_Graph.Options.iDataSourceType ) 
    {
        TCHAR       szStartStop[MAX_PATH+1];

        // Add start and stop string for log files or Sql logs.
        FormatDateTime(m_DataSourceInfo.llStartDisp,szDate,szTime);

        _stprintf(
            szStartStop,
            TEXT("%s%s %s\n"),
            ResourceString(IDS_REPORT_LOG_START),
            szDate,
            szTime );

        FormatDateTime(m_DataSourceInfo.llStopDisp,szDate,szTime);
        lstrcat(szStartStop,ResourceString(IDS_REPORT_LOG_STOP));
        
        FormatDateTime(m_DataSourceInfo.llStopDisp,szDate,szTime);
        lstrcat(szStartStop,szDate);
        lstrcat(szStartStop,SpaceStr);
        lstrcat(szStartStop,szTime);
        lstrcat(szStartStop,LineEndStr);

        lstrcat(szHeader,szStartStop);
    }

    szByteOrderMark[0] = 0xFEFF;
    szByteOrderMark[1] = 0;
    bStatus = FileWrite ( hFile, szByteOrderMark, sizeof(WCHAR) );
    bStatus = FileWrite ( hFile, szHeader, lstrlen (szHeader) * sizeof(TCHAR) );

    return bStatus;
}

BOOL CSysmonControl::InitView (HWND hWndParent)
/*
   Effect:  Create the graph window. This window is a child of 
            hWndMain and is a container for the graph data,
            graph label, graph legend, and graph status windows.

   Note:    We don't worry about the size here, as this window
            will be resized whenever the main window is resized.

   Note:    This method initializes the control for rendering. 
*/
{
    PCGraphItem pItem;
    WNDCLASS    wc ;

    // Protect against multiple initializations
    if (m_fViewInitialized)
       return TRUE;

    BEGIN_CRITICAL_SECTION

    // Register the window class once
    if (pstrRegisteredClasses[SYSMONCTRL_WNDCLASS] == NULL) {
       
        wc.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
        wc.lpfnWndProc   = (WNDPROC) SysmonCtrlWndProc ;
        wc.hInstance     = g_hInstance ;
        wc.cbClsExtra    = 0 ;
        wc.cbWndExtra    = sizeof (PSYSMONCTRL) ;
        wc.hIcon         = NULL ;
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
        wc.hbrBackground = NULL ;
        wc.lpszMenuName  = NULL ;
        wc.lpszClassName = szSysmonCtrlWndClass ;

        if (RegisterClass (&wc)) {
            pstrRegisteredClasses[SYSMONCTRL_WNDCLASS] = szSysmonCtrlWndClass;
        }

   }

   END_CRITICAL_SECTION

   if (pstrRegisteredClasses[SYSMONCTRL_WNDCLASS] == NULL)
        return FALSE;

   // Create our control window
   m_hWnd = CreateWindow (szSysmonCtrlWndClass,    // window class
                         NULL,                     // caption
                         WS_CHILD | WS_VISIBLE,    // style for window
                         0, 0,                     // initial position
                         m_pObj->m_RectExt.right,  // width
                         m_pObj->m_RectExt.bottom, // height
                         hWndParent,               // parent
                         NULL,                     // menu
                         g_hInstance,              // program instance
                         (LPVOID)this) ;          // user-supplied data

    if (m_hWnd == NULL) {
    //    DWORD err = GetLastError();
        return FALSE;
    }

    DragAcceptFiles (m_hWnd, TRUE) ;

    // Subcomponents are allocated in AllocateSubcomponents

    // Init the legend

    if ( !m_pLegend 
        || !m_pGraphDisp
        || !m_pStatsBar
        || !m_pSnapBar
        || !m_pToolbar
        || !m_pReport ) 
    {
        return FALSE;
    }

    if (!m_pLegend->Init(this, m_hWnd))
        return FALSE;

    // Init the graph display
    if (!m_pGraphDisp->Init(this, &m_pObj->m_Graph))
        return FALSE;

    // Init the statistics bar
    if (!m_pStatsBar->Init(this, m_hWnd))
        return FALSE;

    // Init the snapshot bar
    if (!m_pSnapBar->Init(this, m_hWnd))
        return FALSE;

    if (!m_pToolbar->Init(this, m_hWnd))
        return FALSE;

    // Init the report view
    if (!m_pReport->Init(this, m_hWnd))
        return FALSE;
    
    m_fViewInitialized = TRUE;
    // If counters are present
    if ((pItem = FirstCounter()) != NULL) {
        // Add counters to the legend and report view
        while (pItem != NULL) {
            m_pLegend->AddItem(pItem);
            m_pReport->AddItem(pItem);
            pItem = pItem->Next();
        }
        if ( NULL != m_pSelectedItem ) {
            SelectCounter(m_pSelectedItem);
        } else {
            SelectCounter(FirstCounter());
        }
        if ( !m_bLogFileSource ) {
            // Pass new time span to statistics bar.  This must
            // be done after initializing the stats bar.
            m_pStatsBar->SetTimeSpan (
                            m_pObj->m_Graph.Options.fUpdateInterval
                            * m_pObj->m_Graph.Options.iDisplayFilter
                            * m_pHistCtrl->nMaxSamples );
        }
    }

    // Processing the command line can add counters from the property bag.  
    // Add the counters after the counter addition and selection code above so that counters
    // do not get added twice.

    ProcessCommandLine ( );

    return TRUE;                                              
}


BOOL CSysmonControl::Init (HWND hWndParent)
/*
   Effect:        Create the graph window. This window is a child of 
                  hWndMain and is a container for the graph data,
                  graph label, graph legend, and graph status windows.

   Note:          We don't worry about the size here, as this window
                  will be resized whenever the main window is resized.

*/
{
    PCGraphItem  pItem;
    BOOL bResult = TRUE;

    // Protect against multiple initializations
    if (!m_fInitialized) {

        bResult = InitView( hWndParent );

        if ( !m_bSampleDataLoaded ) {
        
            if ( bResult ) {
                m_fInitialized = TRUE;

                // When loaded from property bag or stream, the log file name is 
                // already set.  If realtime query, the Pdh query might
                // not have been opened.
                if ( sysmonCurrentActivity == m_pObj->m_Graph.Options.iDataSourceType ) {
                    put_DataSourceType ( sysmonCurrentActivity );
                }
                // Load the accelerator table
                m_hAccel = LoadAccelerators(g_hInstance, MAKEINTRESOURCE(ID_SMONACCEL));

                // If counters are present
                if ((pItem = FirstCounter()) != NULL) {
            
                    if ( ERROR_SUCCESS != ActivateQuery() ) {
                        m_fInitialized = FALSE;
                        return FALSE;
                    }
                }
            }
        }
    }

    //sync the toolbar last
    if ( bResult ) {
        m_pToolbar->SyncToolbar();
    }

    return bResult;                                              
}


HRESULT CSysmonControl::LoadFromStream(LPSTREAM pIStream)
{
    typedef struct _DATA_LIST_ELEM
    {
        GRAPHITEM_DATA3     itemData;
        LPWSTR              szCounterPath;
        struct _DATA_LIST_ELEM*    pNext;
    } DATA_LIST_ELEM, *PDATA_LIST_ELEM;
    HRESULT         hr = S_OK;
    ULONG           bc;
    GRAPH_OPTIONS   *pOptions = &m_pObj->m_Graph.Options;
    RECT            RectExt;
    SMONCTRL_VERSION_DATA   VersionData;
    LPTSTR          szLogFilePath = NULL;
    INT32           iLocalDataSourceType = (INT32)sysmonNullDataSource;
    GRAPHCTRL_DATA3 CtrlData3;
    ENUM_ADD_COUNTER_CALLBACK_INFO CallbackInfo;
    PDATA_LIST_ELEM pFirstElem = NULL;
    PDATA_LIST_ELEM pLastElem = NULL;
    PDATA_LIST_ELEM pNewElem = NULL;
    LPWSTR          pszCounterPath = NULL;
    LPTSTR          szLocaleBuf = NULL;
    DWORD           dwLocaleBufSize = 0;
    LPTSTR          pszPath = NULL;

    USES_CONVERSION

    if (g_dwScriptPolicy == URLPOLICY_DISALLOW) {
        return E_ACCESSDENIED;
    }
    if ( !m_bSettingsLoaded ) {
        // Read in parameters
        hr = pIStream->Read(&VersionData, sizeof(VersionData), &bc);
        if (FAILED(hr))
            return hr;

        if (bc != sizeof(VersionData))
            return E_FAIL;

        // The code below assumes that Sysmon version is 3.5.
        assert ( 3 == SMONCTRL_MAJ_VERSION );
        assert ( 6 == SMONCTRL_MIN_VERSION );

        // Read version 3 streams only.  
        if ( VersionData.iMajor < SMONCTRL_MAJ_VERSION )
            return E_FAIL;

        // Update the current loaded version number in order
        // to warn the user appropriately when saving to stream.
        m_LoadedVersion.iMajor = VersionData.iMajor;
        m_LoadedVersion.iMinor = VersionData.iMinor;

        assert( 256 == sizeof(CtrlData3) );
        
        ZeroMemory ( &CtrlData3, sizeof ( CtrlData3 ) );

        hr = pIStream->Read(&CtrlData3, sizeof(CtrlData3), &bc);
        if (FAILED(hr))
            return hr;
        
        if (bc != sizeof(CtrlData3))
            return E_FAIL;

        // Setup extent info
        SetRect(&RectExt, 0, 0, CtrlData3.iWidth, CtrlData3.iHeight);
        m_pObj->RectConvertMappings(&RectExt, TRUE);    // Convert from HIMETRIC
        m_pObj->m_RectExt = RectExt;
        SetCurrentClientRect( &RectExt );

        // Load options settings in graph structure
        pOptions->iVertMax          = CtrlData3.iScaleMax;
        pOptions->iVertMin          = CtrlData3.iScaleMin;
        pOptions->bLegendChecked    = CtrlData3.bLegend;
        pOptions->bToolbarChecked   = CtrlData3.bToolbar;
        pOptions->bLabelsChecked    = CtrlData3.bLabels;
        pOptions->bHorzGridChecked  = CtrlData3.bHorzGrid;
        pOptions->bVertGridChecked  = CtrlData3.bVertGrid;
        pOptions->bValueBarChecked  = CtrlData3.bValueBar;
        pOptions->bManualUpdate     = CtrlData3.bManualUpdate;
        pOptions->bHighlight        = CtrlData3.bHighlight;     // New for 3.1,  default = 0
        pOptions->bReadOnly         = CtrlData3.bReadOnly;      // New for 3.1+, default = 0
        pOptions->bAmbientFont      = CtrlData3.bAmbientFont;   // New for 3.3+, new default = 1, but 0 for old files.
        // MonitorDuplicateInstances is new for 3.3, default = 1
        pOptions->bMonitorDuplicateInstances = CtrlData3.bMonitorDuplicateInstances; 
        pOptions->fUpdateInterval   = CtrlData3.fUpdateInterval;
        pOptions->iDisplayType      = CtrlData3.iDisplayType;
        pOptions->clrBackCtl        = CtrlData3.clrBackCtl;
        pOptions->clrFore           = CtrlData3.clrFore;    
        pOptions->clrBackPlot       = CtrlData3.clrBackPlot;
        pOptions->iAppearance       = CtrlData3.iAppearance;
        pOptions->iBorderStyle      = CtrlData3.iBorderStyle;
        pOptions->iReportValueType  = CtrlData3.iReportValueType;   // New for 3.1+, default = 0
        pOptions->iDisplayFilter    = CtrlData3.iDisplayFilter;     // New for 3.4, default = 1, 0 is invalid
        iLocalDataSourceType        = CtrlData3.iDataSourceType;    // New for 3.4, default = 1, 0 is invalid
                                                                    // Pre-3.4, set based on presence of log file name
                                                                    // Set pOptions->iDataSourceType below
        
        if ( 0 == pOptions->iDisplayFilter ) {
            // New for 3.4
            assert ( ( SMONCTRL_MIN_VERSION - 2 ) > VersionData.iMinor );
            pOptions->iDisplayFilter = 1;
        }

        if ( ( SMONCTRL_MIN_VERSION - 6 ) < VersionData.iMinor ) {
            // Grid and TimeBar saved to file as of version 3.1.
            pOptions->clrGrid           = CtrlData3.clrGrid;
            pOptions->clrTimeBar        = CtrlData3.clrTimeBar;
        } else {
            assert ( 0 == VersionData.iMinor );
            pOptions->clrGrid = RGB(128,128,128);   // Medium gray
            pOptions->clrTimeBar = RGB(255,0,0);    // Red
        }
    
        if ( (SMONCTRL_MIN_VERSION - 3) > VersionData.iMinor  ) {
            // Saved to file as of version 3.3
            pOptions->bMonitorDuplicateInstances = 1; 
        }

        // Load font info if not using ambient font
        if ( !pOptions->bAmbientFont ) {
            hr = m_OleFont.LoadFromStream(pIStream);
            if (FAILED(hr))
                return hr;
        }
    
        // Read titles and log file name
        if ( ( SMONCTRL_MIN_VERSION - 5 ) < VersionData.iMinor ) {
            // As of Version 3.2, title and log file name strings stored as Wide characters
        
            // Log file name
            hr = WideStringFromStream(pIStream, &szLogFilePath, CtrlData3.nFileNameLen);
            if (FAILED(hr))
                return hr;

            // Graph title
            hr = WideStringFromStream(pIStream, &pOptions->pszGraphTitle, CtrlData3.nGraphTitleLen);
            if (FAILED(hr))
                return hr;

            // Y axis label
            hr = WideStringFromStream(pIStream, &pOptions->pszYaxisTitle, CtrlData3.nYaxisTitleLen);
            if (FAILED(hr))
                return hr;
        } else {
        
            // Log file name
            hr = StringFromStream(pIStream, &szLogFilePath, CtrlData3.nFileNameLen);
            if (FAILED(hr))
                return hr;
        
            // Graph title
            hr = StringFromStream(pIStream, &pOptions->pszGraphTitle, CtrlData3.nGraphTitleLen);
            if (FAILED(hr))
                return hr;
        
            // Y axis label
            hr = StringFromStream(pIStream, &pOptions->pszYaxisTitle, CtrlData3.nYaxisTitleLen);
            if (FAILED(hr))
                return hr;
        }
                
               
        // Read display range
        m_DataSourceInfo.llStartDisp = CtrlData3.llStartDisp;
        m_DataSourceInfo.llStopDisp = CtrlData3.llStopDisp;

        // Must put actual data source type after loading display range, before adding counters.
        // Always set data source to null data source before adding data source names.
        hr = put_DataSourceType ( sysmonNullDataSource );

        if ( SUCCEEDED ( hr ) && NULL != szLogFilePath ) {
            assert ( 0 == NumLogFiles() );
            if ( L'\0' != szLogFilePath[0] ) {
                if ( ( SMONCTRL_MIN_VERSION - 1 ) > VersionData.iMinor ) {
                    // 3.4 writes a single log file.
                    hr = AddSingleLogFile ( szLogFilePath );
                } else {
                    // 3.5+ writes a multi_sz
                    hr = LoadLogFilesFromMultiSz ( szLogFilePath );
                }
            }
        }

        if ( NULL != szLogFilePath ) {
            delete szLogFilePath;
        }

        // If version < 3.4, set data source type based on presence of log files.
        if ( ( SMONCTRL_MIN_VERSION - 2 ) > VersionData.iMinor ) {
            // DataSourceType is new for 3.4
            if ( 0 == NumLogFiles() ) {
                iLocalDataSourceType = sysmonCurrentActivity;
            } else {
                iLocalDataSourceType = sysmonLogFiles;
            }
        }

        // Set scale max and min
        m_pObj->m_Graph.Scale.SetMaxValue(pOptions->iVertMax);
        m_pObj->m_Graph.Scale.SetMinValue(pOptions->iVertMin);

        // Convert non-null OLE colors to real colors
        if (pOptions->clrFore != NULL_COLOR)
            OleTranslateColor(pOptions->clrFore, NULL, &m_clrFgnd);
    
        if (pOptions->clrBackPlot != NULL_COLOR)
            OleTranslateColor(pOptions->clrBackPlot, NULL, &m_clrBackPlot);

        // NT 5 Beta 1 BackCtlColor can be NULL.
        if (pOptions->clrBackCtl != NULL_COLOR) 
            OleTranslateColor(pOptions->clrBackCtl, NULL, &m_clrBackCtl);
 
        OleTranslateColor(pOptions->clrGrid, NULL, &m_clrGrid);

        OleTranslateColor(pOptions->clrTimeBar, NULL, &m_clrTimeBar);

        // Handle other ambient properties

        if ( NULL_APPEARANCE != pOptions->iAppearance )
            put_Appearance( pOptions->iAppearance, FALSE );

        if ( NULL_BORDERSTYLE != pOptions->iBorderStyle )
            put_BorderStyle( pOptions->iBorderStyle, FALSE );

        // Read legend data
        hr = m_pLegend->LoadFromStream(pIStream);
        if (FAILED(hr))
            return hr;
                               
        //Load the counters
        hr = S_OK;

        // Load the counters into temporary storage, so that they can be added after the 
        // SQL name and future items are loaded 

        while (TRUE) {
        
            pNewElem = new ( DATA_LIST_ELEM );

            if ( NULL != pNewElem ) {
                
                ZeroMemory ( pNewElem, sizeof ( DATA_LIST_ELEM ) );

                // Add to end of list
                pNewElem->pNext = NULL;

                if ( NULL == pFirstElem ) {
                    pFirstElem = pNewElem;
                    pLastElem = pFirstElem;
                } else if ( NULL == pLastElem ) {
                    pLastElem = pNewElem;
                } else {
                    pLastElem->pNext = pNewElem;
                    pLastElem = pNewElem;
                }
            
                // Read in parameters
                hr = pIStream->Read(&pNewElem->itemData, sizeof(GRAPHITEM_DATA3), &bc);
                if ( SUCCEEDED ( hr ) ) {
                    if (bc == sizeof(GRAPHITEM_DATA3)) {

                        // Stop on null item (indicated by no path name)
                        if (pNewElem->itemData.m_nPathLength == 0) {
                            break;
                        }
                    } else {
                        hr = E_FAIL;
                    }
                }
            } else {
                hr = E_OUTOFMEMORY;
            }
        
            if ( SUCCEEDED ( hr ) ) {

                if ( ( SMONCTRL_MIN_VERSION - 5 ) < VersionData.iMinor ) {
                    // As of Version 3.2, title and log file name strings stored as Wide characters
                    // Read in path name
                    hr = WideStringFromStream(pIStream, &pszCounterPath, pNewElem->itemData.m_nPathLength);
                } else {
                    // Read in path name
                    hr = StringFromStream(pIStream, &pszCounterPath, pNewElem->itemData.m_nPathLength);
                }
            }
        
            if ( SUCCEEDED ( hr ) ) {
                pNewElem->szCounterPath = pszCounterPath;
                pszCounterPath = NULL;
            }

        }

        if ( NULL != pszCounterPath ) {
            delete pszCounterPath;
            pszCounterPath = NULL;
        }

        if ( FAILED ( hr ) ) {
            while ( NULL != pFirstElem ) {
                pNewElem = pFirstElem->pNext;
                if ( NULL != pFirstElem->szCounterPath ) {
                    delete pFirstElem->szCounterPath;
                }
            
                delete pFirstElem;
                pFirstElem = pNewElem;
            }
            return hr;
        }
        
        // Load SQL names from the stream
        hr = WideStringFromStream(pIStream, &m_DataSourceInfo.szSqlDsnName, CtrlData3.iSqlDsnLen);
        if ( FAILED ( hr ) ) 
            return hr;

        hr = WideStringFromStream(pIStream, &m_DataSourceInfo.szSqlLogSetName, CtrlData3.iSqlLogSetNameLen);
        if (FAILED(hr))
            return hr;

        // Set the data source
        hr = put_DataSourceType ( iLocalDataSourceType );

        if (FAILED(hr)) {

            if ( SMON_STATUS_LOG_FILE_SIZE_LIMIT == hr ) {
                // TodoLogFiles:  Check log file type.  Only perfmon and circular
                // binary logs are still limited to 1 GB.
                // TodoLogFiles:  Current query is already closed,
                // so what can be done here?
            } else {
                DWORD dwStatus;
                LPWSTR       szLogFileList = NULL;
                ULONG        ulLogListBufLen= 0;

                if ( sysmonLogFiles == iLocalDataSourceType ) {
                    dwStatus = BuildLogFileList ( 
                                NULL,
                                TRUE,
                                &ulLogListBufLen );
                    szLogFileList =  (LPWSTR) malloc(ulLogListBufLen * sizeof(WCHAR));
                    if ( NULL != szLogFileList ) {
                        dwStatus = BuildLogFileList ( 
                                    szLogFileList,
                                    TRUE,
                                    &ulLogListBufLen );
                    }
                }

                dwStatus = DisplayDataSourceError (
                                m_hWnd,
                                (DWORD)hr,
                                iLocalDataSourceType,
                                szLogFileList,
                                m_DataSourceInfo.szSqlDsnName,
                                m_DataSourceInfo.szSqlLogSetName );

                if ( NULL != szLogFileList ) {
                    delete szLogFileList;
                }
            }                
        }      
        
       
        m_bLogFileSource = ( sysmonCurrentActivity != m_pObj->m_Graph.Options.iDataSourceType ); 

        hr = S_OK;

        // Load the counters from the temporary data storage.
        m_bLoadingCounters = TRUE;

        for ( pNewElem = pFirstElem; NULL != pNewElem; pNewElem = pNewElem->pNext ) {

            DWORD  dwBufSize;
            LPTSTR pNewBuf;
            PDH_STATUS pdhStatus;

            CallbackInfo.pCtrl = this;
            CallbackInfo.pFirstItem = NULL;

            // Stop on null item (indicated by no path name)
            if ( 0 == pNewElem->itemData.m_nPathLength ) {
                break;
            }

            // Set up properties so AddCounter can use them
            m_clrCounter = pNewElem->itemData.m_rgbColor;
            m_iColorIndex = ColorToIndex (pNewElem->itemData.m_rgbColor);
            m_iWidthIndex = WidthToIndex (pNewElem->itemData.m_iWidth);
            m_iStyleIndex = StyleToIndex (pNewElem->itemData.m_iStyle);
            m_iScaleFactor = pNewElem->itemData.m_iScaleFactor;

            pszPath = pNewElem->szCounterPath;
            //
            // Initialize the locale path buffer
            //
            if (dwLocaleBufSize == 0) {
                dwLocaleBufSize = (MAX_PATH + 1) * sizeof(TCHAR);

                szLocaleBuf = (LPTSTR) malloc(dwLocaleBufSize);
                if (szLocaleBuf == NULL) {
                    dwLocaleBufSize = 0;
                }
            }

            if (szLocaleBuf != NULL) {
                //
                // Translate counter name from English to Localization
                //
                dwBufSize = dwLocaleBufSize;

                pdhStatus = PdhTranslateLocaleCounter(
                                pNewElem->szCounterPath,
                                szLocaleBuf,
                                &dwBufSize);

                if (pdhStatus == PDH_MORE_DATA) {
                    pNewBuf = (LPTSTR) realloc(szLocaleBuf, dwBufSize);
                    if (pNewBuf != NULL) {
                        szLocaleBuf = pNewBuf;
                        dwLocaleBufSize = dwBufSize;

                        pdhStatus = PdhTranslateLocaleCounter(
                                        pNewElem->szCounterPath,
                                        szLocaleBuf,
                                        &dwBufSize);
                    }
                }

                if (pdhStatus == ERROR_SUCCESS) {
                    pszPath = szLocaleBuf;
                }
            }

            // Add new counter to control
            EnumExpandedPath (GetDataSourceHandle(), 
                              pszPath, 
                              AddCounterCallback, 
                              &CallbackInfo ); 
        }
        
        if (szLocaleBuf != NULL) {
            free(szLocaleBuf);
        }

        m_bLoadingCounters = FALSE;

        while ( NULL != pFirstElem ) {
            pNewElem = pFirstElem->pNext;
            if ( NULL != pFirstElem->szCounterPath ) {
                delete pFirstElem->szCounterPath;
            }
            delete pFirstElem;
            pFirstElem = pNewElem;
        }

        if ( SMONCTRL_MAJ_VERSION == VersionData.iMajor 
                && SMONCTRL_MIN_VERSION == VersionData.iMinor ) {
            m_pObj->m_fDirty=FALSE;
        } else {
            m_pObj->m_fDirty=TRUE;
        }

        if ( SMONCTRL_MIN_VERSION == VersionData.iMinor ) {
            // New for 3.6:  Save visuals to the stream
            // These must be loaded after the counters are loaded.
            m_iColorIndex = CtrlData3.iColorIndex;
            m_iWidthIndex = CtrlData3.iWidthIndex;
            m_iStyleIndex = CtrlData3.iStyleIndex;
        }

    } // Settings not loaded yet.    

    return hr;
}

HRESULT 
CSysmonControl::SaveToStream(LPSTREAM pIStream)
{
    HRESULT         hr = NOERROR;
    DWORD           dwStatus = ERROR_SUCCESS;
    GRAPH_OPTIONS   *pOptions = &m_pObj->m_Graph.Options;
    RECT            RectExt;
    SMONCTRL_VERSION_DATA   VersionData;
    LPWSTR          pszWideGraphTitle;
    LPWSTR          pszWideYaxisTitle;
    PCMachineNode   pMachine;
    PCObjectNode    pObject;
    PCInstanceNode  pInstance;
    PCGraphItem     pItem;
    PCCounterNode   pCounter;
    ULONG           ulLogFileListLen = 0;
    LPWSTR          szLogFileList = NULL;
    GRAPHCTRL_DATA3 CtrlData3;

    USES_CONVERSION
    assert( 256 == sizeof(CtrlData3) );

    ZeroMemory( &CtrlData3, 256 );

    //Store extent data in HIMETRIC format
    RectExt = m_pObj->m_RectExt;
    m_pObj->RectConvertMappings(&RectExt, FALSE); 
    CtrlData3.iWidth = RectExt.right - RectExt.left;
    CtrlData3.iHeight = RectExt.bottom - RectExt.top;

    // Store options settings in   structure
    CtrlData3.iScaleMax         = pOptions->iVertMax; 
    CtrlData3.iScaleMin         = pOptions->iVertMin; 
    CtrlData3.bLegend           = pOptions->bLegendChecked; 
    CtrlData3.bToolbar          = pOptions->bToolbarChecked; 
    CtrlData3.bLabels           = pOptions->bLabelsChecked; 
    CtrlData3.bHorzGrid         = pOptions->bHorzGridChecked; 
    CtrlData3.bVertGrid         = pOptions->bVertGridChecked; 
    CtrlData3.bValueBar         = pOptions->bValueBarChecked; 
    CtrlData3.bManualUpdate     = pOptions->bManualUpdate; 
    CtrlData3.bHighlight        = pOptions->bHighlight; 
    CtrlData3.bReadOnly         = pOptions->bReadOnly; 
    CtrlData3.bMonitorDuplicateInstances = pOptions->bMonitorDuplicateInstances; 
    CtrlData3.bAmbientFont      = pOptions->bAmbientFont; 
    CtrlData3.fUpdateInterval   = pOptions->fUpdateInterval; 
    CtrlData3.iDisplayType      = pOptions->iDisplayType; 
    CtrlData3.iReportValueType  = pOptions->iReportValueType; 
    CtrlData3.clrBackCtl        = pOptions->clrBackCtl;
    CtrlData3.clrFore           = pOptions->clrFore;
    CtrlData3.clrBackPlot       = pOptions->clrBackPlot;
    CtrlData3.iAppearance       = pOptions->iAppearance;
    CtrlData3.iBorderStyle      = pOptions->iBorderStyle;
    CtrlData3.clrGrid           = pOptions->clrGrid;
    CtrlData3.clrTimeBar        = pOptions->clrTimeBar;
    CtrlData3.iDisplayFilter    = pOptions->iDisplayFilter; 
    CtrlData3.iDataSourceType   = pOptions->iDataSourceType; 

    // Store the visuals in pOptions if they become visible 
    // via the programming interface.
    CtrlData3.iColorIndex       = m_iColorIndex;
    CtrlData3.iWidthIndex       = m_iWidthIndex;
    CtrlData3.iStyleIndex       = m_iStyleIndex;

    // NT 5 Beta 1 BackColorCtl can be NULL.
    if ( NULL_COLOR == pOptions->clrBackCtl ) 
        CtrlData3.clrBackCtl    = m_clrBackCtl;

    // Save number of samples to keep
    CtrlData3.nSamples = m_pHistCtrl->nMaxSamples;

    // Store Wide string lengths
    pszWideGraphTitle = T2W(pOptions->pszGraphTitle);
    CtrlData3.nGraphTitleLen = (pszWideGraphTitle == NULL) ? 
                                0 : lstrlen(pszWideGraphTitle);

    pszWideYaxisTitle = T2W(pOptions->pszYaxisTitle);
    CtrlData3.nYaxisTitleLen = (pszWideYaxisTitle == NULL) ? 
                                0 : lstrlen(pszWideYaxisTitle);
    
    BuildLogFileList ( NULL, FALSE, &ulLogFileListLen );
    CtrlData3.nFileNameLen = (INT32) ulLogFileListLen;

    CtrlData3.iSqlDsnLen = 0;
    if ( NULL != m_DataSourceInfo.szSqlDsnName ) {
        CtrlData3.iSqlDsnLen = lstrlen ( m_DataSourceInfo.szSqlDsnName );
    }

    CtrlData3.iSqlLogSetNameLen = 0;
    if ( NULL != m_DataSourceInfo.szSqlLogSetName ) {
        CtrlData3.iSqlLogSetNameLen = lstrlen ( m_DataSourceInfo.szSqlLogSetName );
    }

    // Store other file info
    CtrlData3.llStartDisp = m_DataSourceInfo.llStartDisp;
    CtrlData3.llStopDisp = m_DataSourceInfo.llStopDisp;

    // Write version info
    VersionData.iMajor = SMONCTRL_MAJ_VERSION;
    VersionData.iMinor = SMONCTRL_MIN_VERSION;

    hr = pIStream->Write(&VersionData, sizeof(VersionData), NULL);
    if (FAILED(hr))
        return hr;

    // Write control data
    hr = pIStream->Write(&CtrlData3, sizeof(CtrlData3), NULL);
    if (FAILED(hr))
       return hr;

    // Write font info if not using ambient font
    if ( !pOptions->bAmbientFont ) {
        hr = m_OleFont.SaveToStream(pIStream, TRUE);
        if (FAILED(hr))
            return hr;
    }

    // Write log file name
    if (CtrlData3.nFileNameLen != 0) {

        szLogFileList =  (LPWSTR) malloc(ulLogFileListLen * sizeof(WCHAR));
        if ( NULL != szLogFileList ) {
            dwStatus = BuildLogFileList ( 
                        szLogFileList,
                        FALSE,
                        &ulLogFileListLen );
            if ( ERROR_SUCCESS != dwStatus ) {
                hr = E_FAIL;
            }
        } else {
            hr = E_OUTOFMEMORY;
        }

        if ( SUCCEEDED ( hr ) ) {
            hr = pIStream->Write(szLogFileList, CtrlData3.nFileNameLen*sizeof(WCHAR), NULL);
        }
        if ( NULL != szLogFileList ) {
            delete szLogFileList;
            szLogFileList = NULL;
        }
        if (FAILED(hr))
            return hr;
    }

    // Write titles
    if (CtrlData3.nGraphTitleLen != 0) {
        hr = pIStream->Write(pszWideGraphTitle, CtrlData3.nGraphTitleLen*sizeof(WCHAR), NULL);
        if (FAILED(hr))
            return hr;
    }

    if (CtrlData3.nYaxisTitleLen != 0) {
        hr = pIStream->Write(pszWideYaxisTitle, CtrlData3.nYaxisTitleLen*sizeof(WCHAR), NULL);
        if (FAILED(hr))
            return hr;
    }

    // Write legend data
    hr = m_pLegend->SaveToStream(pIStream);
    if (FAILED(hr))
        return hr;
    
    // Save all counter info
    // Explicit counters first, followed by "All Instance" groups
    for ( pMachine = CounterTree()->FirstMachine();
          pMachine;
          pMachine = pMachine->Next()) {

      for ( pObject = pMachine->FirstObject();
            pObject;
            pObject = pObject->Next()) {

            // Clear generated pointer for all object's counters
            for ( pCounter = pObject->FirstCounter();
                  pCounter;
                  pCounter = pCounter->Next()) {
                     pCounter->m_pFirstGenerated = NULL;
                 }

            for ( pInstance = pObject->FirstInstance();
                  pInstance;
                  pInstance = pInstance->Next()) {

                for ( pItem = pInstance->FirstItem();
                      pItem;
                      pItem = pItem->m_pNextItem) {
                    
                    // If item is the first generated one for this counter
                    // then save it as the wild card model for this counter
                    if (pItem->m_fGenerated) {
                        if (pItem->Counter()->m_pFirstGenerated == NULL)
                            pItem->Counter()->m_pFirstGenerated = pItem;
                    }
                    else {
                        // else save it explictly
                        hr = pItem->SaveToStream(pIStream, FALSE, VersionData.iMajor, VersionData.iMinor);
                        if (FAILED(hr))
                            return hr;
                    }
                }
            }

            // Now go through counters again and store a wildcard path
            // for any that have genererated counters
            for (pCounter = pObject->FirstCounter();
                 pCounter;
                 pCounter = pCounter->Next()) {
                if (pCounter->m_pFirstGenerated) {
                    hr = pCounter->m_pFirstGenerated->SaveToStream(pIStream, TRUE, VersionData.iMajor, VersionData.iMinor);
                    if (FAILED(hr))
                        return hr;
                }
            }
        }
    }

    // Write null item to mark end of counter items
    hr = CGraphItem::NullItemToStream(pIStream, VersionData.iMajor, VersionData.iMinor);

    // Write Sql data source names
    if (CtrlData3.iSqlDsnLen != 0) {
        hr = pIStream->Write(m_DataSourceInfo.szSqlDsnName, CtrlData3.iSqlDsnLen*sizeof(WCHAR), NULL);
    }
    if (CtrlData3.iSqlLogSetNameLen != 0) {
        hr = pIStream->Write(m_DataSourceInfo.szSqlLogSetName, CtrlData3.iSqlLogSetNameLen*sizeof(WCHAR), NULL);
    }
    return hr;
}

HRESULT 
CSysmonControl::LoadLogFilesFromPropertyBag (
    IPropertyBag*   pIPropBag,
    IErrorLog*      pIErrorLog )
{
    HRESULT     hr = S_OK;
    HRESULT     hrErr = S_OK;
    INT         iLogFileCount = 0;
    INT         iIndex;
    INT         iBufSize = 0;
    INT         iPrevBufSize  = 0;
    LPTSTR      pszLogFilePath = NULL;
    INT         iLogFilePathBufSize = 0;
    WCHAR       szLogFilePropName[32];
    eDataSourceTypeConstant ePrevDataSourceType;
    DWORD       dwErrorPathListLen;
    LPCWSTR     szErrorPathList = NULL;
    LPWSTR      szMessage = NULL;

    get_DataSourceType ( ePrevDataSourceType );

    ClearErrorPathList();

    hr = StringFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszLogFileName, NULL, iBufSize );
    if ( SUCCEEDED(hr) && 
         iBufSize > 0 ) {
        
        pszLogFilePath = new TCHAR[iBufSize + 1];
        
        if ( NULL != pszLogFilePath ) {
            hr = StringFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszLogFileName, pszLogFilePath, iBufSize );
        } else {
            hr = E_OUTOFMEMORY;
        }
        
        if ( SUCCEEDED ( hr ) ) {
            // Always set the log source to null data source before modifying the log file list.
            // TodoLogFiles:  This can leave the user with state different than before, in the
            // case of log file load failure.
    
            hr = put_DataSourceType ( sysmonNullDataSource );
            if ( SUCCEEDED ( hr ) ) {
                assert ( 0 == NumLogFiles() );
                hr = AddSingleLogFile ( pszLogFilePath );
            }
        }

        if ( FAILED ( hr ) && NULL != pszLogFilePath ) {
            hrErr = hr;
            AddToErrorPathList ( pszLogFilePath );
        }

        if ( NULL != pszLogFilePath ) {
            delete pszLogFilePath;
            pszLogFilePath = NULL;
        }
    } else {
        hr = IntegerFromPropertyBag (pIPropBag, pIErrorLog, CGlobalString::m_cszLogFileCount, iLogFileCount );
        if ( SUCCEEDED( hr ) && 0 < iLogFileCount ) {
            assert ( 0 == NumLogFiles() );
            for ( iIndex = 1; iIndex <= iLogFileCount; iIndex++ ) {
                // Todo: log file list error message, as for counters
                // If one of the log files fails to load, continue loading others.
                hr = NOERROR;
                swprintf ( szLogFilePropName, CGlobalString::m_cszLogNameFormat, CGlobalString::m_cszLogFileName, iIndex );
                iPrevBufSize = iBufSize;
                hr = StringFromPropertyBag (
                        pIPropBag,
                        pIErrorLog,
                        szLogFilePropName,
                        pszLogFilePath,
                        iBufSize );
                if ( iBufSize > iPrevBufSize ) {
                    if ( NULL == pszLogFilePath || (iBufSize > iLogFilePathBufSize) ) {
                        if ( NULL != pszLogFilePath ) {
                            delete pszLogFilePath;
                            pszLogFilePath = 0;
                        }
                        pszLogFilePath = new WCHAR[iBufSize];
                        if ( NULL != pszLogFilePath ) {
                            iLogFilePathBufSize = iBufSize;
                        }
                    }
                    if ( NULL != pszLogFilePath ) {
                        hr = StringFromPropertyBag (
                                pIPropBag,
                                pIErrorLog,
                                szLogFilePropName,
                                pszLogFilePath,
                                iBufSize );
                    } else {
                        hr = E_OUTOFMEMORY;
                    }
                }

                if ( SUCCEEDED(hr) 
                      && MAX_PATH >= lstrlen(pszLogFilePath) ) {
                    hr = put_DataSourceType ( sysmonNullDataSource );
                    if ( SUCCEEDED ( hr ) ) {
                        hr = AddSingleLogFile ( pszLogFilePath );
                    }
                }

                if ( FAILED ( hr ) 
                    && SMON_STATUS_DUPL_LOG_FILE_PATH != hr ) 
                {
                    if ( S_OK == hrErr ) {
                        hrErr = hr;
                    }
                    AddToErrorPathList ( pszLogFilePath );
                }
            }
        }
    }

    if ( NULL != pszLogFilePath ) {
        delete pszLogFilePath;
        pszLogFilePath = NULL;
    }
    
    if ( SMON_STATUS_DUPL_LOG_FILE_PATH != hr ) {
        szErrorPathList = GetErrorPathList ( &dwErrorPathListLen );
        if ( NULL != szErrorPathList ) {

            // Report error, but continue.
            szMessage = new WCHAR [dwErrorPathListLen + MAX_PATH];
    
            if ( NULL != szMessage ) {
                _stprintf ( szMessage, ResourceString(IDS_ADD_LOG_FILE_ERR), szErrorPathList );    
                MessageBox (
                    m_hWnd, 
                    szMessage, 
                    ResourceString(IDS_APP_NAME), 
                    MB_OK | MB_ICONEXCLAMATION );

                delete szMessage;
            }
        }
    }
    ClearErrorPathList();

    return hrErr;
}
    
HRESULT 
CSysmonControl::LoadCountersFromPropertyBag (
    IPropertyBag*   pIPropBag,
    IErrorLog*      pIErrorLog,
    BOOL            bLoadData )
{
    HRESULT     hr = S_OK;
    HRESULT     hrErr = S_OK;
    INT         iCounterCount = 0;
    INT         iSampleCount = 0;
    INT         intValue;
    INT         iIndex;
    INT         iBufSize = 0;
    INT         iPrevBufSize  = 0;
    LPTSTR      pszCounterPath = NULL;
    INT         iCounterPathBufSize = 0;
    TCHAR       szSelected[MAX_PATH+1];
    TCHAR       szPathPropName[32];
    LPTSTR      szEnglishBuf = NULL;
    DWORD       dwEnglishBufSize = 0;
    LPTSTR      pszPath = NULL;
    DWORD       dwBufSize;
    LPTSTR      pNewBuf;
    PDH_STATUS  pdhStatus;
    PCGraphItem pItem = NULL;
    
    lstrcpy ( szSelected, L"" );
    
    hr = IntegerFromPropertyBag (pIPropBag, pIErrorLog, CGlobalString::m_cszCounterCount, iCounterCount );
    if ( SUCCEEDED( hr ) && 0 < iCounterCount ) {
        iBufSize = MAX_PATH+1;
        hr = StringFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszSelected, szSelected, iBufSize );
        if( SUCCEEDED( hr ) ){
            //
            // Initialize the locale path buffer
            //
            if (dwEnglishBufSize == 0) {
                dwEnglishBufSize = (MAX_PATH + 1) * sizeof(TCHAR);
                szEnglishBuf = (LPTSTR) malloc(dwEnglishBufSize);
                if (szEnglishBuf == NULL) {
                    dwEnglishBufSize = 0;
                }
            }

            if (szEnglishBuf != NULL) {
                //
                // Translate counter name from Localization into English
                //
                dwBufSize = dwEnglishBufSize;

                pdhStatus = PdhTranslate009Counter(
                                szSelected,
                                szEnglishBuf,
                                &dwBufSize);

                if (pdhStatus == PDH_MORE_DATA) {
                    pNewBuf = (LPTSTR)realloc(szEnglishBuf, dwBufSize);
                    if (pNewBuf != NULL) {
                        szEnglishBuf = pNewBuf;
                        dwEnglishBufSize = dwBufSize;

                        pdhStatus = PdhTranslate009Counter(
                                        szSelected,
                                        szEnglishBuf,
                                        &dwBufSize);
                    }
                }

                if (pdhStatus == ERROR_SUCCESS && dwBufSize < sizeof(szSelected) ) {
                    lstrcpy(szSelected, szEnglishBuf);
                }
            }
        }
    }


    if ( bLoadData ) {
        hr = IntegerFromPropertyBag (pIPropBag, pIErrorLog, CGlobalString::m_cszSampleCount, iSampleCount );        
        if ( SUCCEEDED(hr) && ( 0 < iSampleCount ) ) {
            intValue = 0;
            hr = IntegerFromPropertyBag (pIPropBag, pIErrorLog, CGlobalString::m_cszSampleIndex, intValue ); 
    
            if ( SUCCEEDED(hr) && intValue > 0 && intValue <= iSampleCount ) {
                INT iStepNum;
                hr = IntegerFromPropertyBag (
                        pIPropBag, 
                        pIErrorLog, 
                        CGlobalString::m_cszStepNumber, iStepNum ); 

                if ( SUCCEEDED(hr) ) {
                    // If data has been passed, freeze the view.
                    // These values are set only if all three values are present in the property bag.
                    put_ManualUpdate( TRUE );
                    // MaxSamples hardcoded for NT5
                    m_pHistCtrl->nSamples = iSampleCount;
                    m_pHistCtrl->iCurrent = intValue;
                    m_pObj->m_Graph.TimeStepper.StepTo(iStepNum);
                    m_bSampleDataLoaded = TRUE;
                }
            }
        }
    } else {
        iSampleCount = 0;
    }

    iBufSize = 0;
    ClearErrorPathList();
    
    for ( iIndex = 1; iIndex <= iCounterCount; iIndex++ ) {
    
        // If one of the counters fails to load, continue loading others.

        hr = NOERROR;
        _stprintf ( szPathPropName, TEXT("%s%05d.Path"), CGlobalString::m_cszCounter, iIndex );
       
        iPrevBufSize = iBufSize;
        hr = StringFromPropertyBag (
                pIPropBag,
                pIErrorLog,
                szPathPropName,
                pszCounterPath,
                iBufSize );


        if ( iBufSize > iPrevBufSize ) {
            if ( NULL == pszCounterPath || (iBufSize > iCounterPathBufSize) ) {
                if ( NULL != pszCounterPath ) {
                    delete pszCounterPath;
                    iCounterPathBufSize = 0;
                }
                pszCounterPath = new TCHAR[iBufSize];
                if ( NULL != pszCounterPath ) {
                    iCounterPathBufSize = iBufSize;
                }
            }
            if ( NULL != pszCounterPath ) {
                hr = StringFromPropertyBag (
                        pIPropBag,
                        pIErrorLog,
                        szPathPropName,
                        pszCounterPath,
                        iBufSize );
            } else {
                hr = E_OUTOFMEMORY;
            }
        }
    
        pszPath = pszCounterPath;

        if ( SUCCEEDED(hr) 
              && MAX_PATH >= lstrlen(pszCounterPath) ) {
            
            //
            // Translate English counter name into localized counter name
            //

            if (dwEnglishBufSize == 0) {
                dwEnglishBufSize = (MAX_PATH + 1) * sizeof(TCHAR);

                szEnglishBuf = (LPTSTR) malloc(dwEnglishBufSize);
                if (szEnglishBuf == NULL) {
                    dwEnglishBufSize = 0;
                }
            }

            if (szEnglishBuf != NULL) {
                //
                // Translate counter name from English to Localization
                //
                dwBufSize = dwEnglishBufSize;
 
                pdhStatus = PdhTranslateLocaleCounter(
                               pszCounterPath,
                                szEnglishBuf,
                                &dwBufSize);
 
                if (pdhStatus == PDH_MORE_DATA) {
                    pNewBuf = (LPTSTR) realloc(szEnglishBuf, dwBufSize);
                    if (pNewBuf != NULL) {
                        szEnglishBuf = pNewBuf;
                        dwEnglishBufSize = dwBufSize;
 
                        pdhStatus = PdhTranslateLocaleCounter(
                                        pszCounterPath,
                                        szEnglishBuf,
                                        &dwBufSize);
                    }
                }
 
                if (pdhStatus == ERROR_SUCCESS) {   
                    pszPath = szEnglishBuf;
                }
            }
 
            hr = AddCounter ( pszPath, &pItem );
            
            // Return status of the first failed counter.
            if ( FAILED ( hr ) && SMON_STATUS_DUPL_COUNTER_PATH != hr ) {
                if ( S_OK == hrErr ) {
                    hrErr = hr;
                }
            }
        } else {
            hr = E_FAIL;
            if ( S_OK == hrErr ) {
                hrErr = E_FAIL;
            }
        }


        if ( SUCCEEDED(hr) ) {
            assert ( NULL != pItem );
            if ( 0 == lstrcmpi ( pszPath, szSelected ) ) {
                SelectCounter( pItem );
            }
            if ( SUCCEEDED(hr) ) {
                assert ( NULL != pItem );
                // Only pass sample count if all sample properties exist
                // in the property bag.
                hr = pItem->LoadFromPropertyBag ( 
                                pIPropBag, 
                                pIErrorLog, 
                                iIndex,
                                SMONCTRL_MAJ_VERSION,
                                SMONCTRL_MIN_VERSION,
                                m_bSampleDataLoaded ? iSampleCount : 0 ); 
                                                           
            }
        } else {
            if ( SMON_STATUS_DUPL_COUNTER_PATH != hr ) {
                AddToErrorPathList ( pszPath );
            }
        }
    }

    if (szEnglishBuf != NULL) {
        free(szEnglishBuf);
    }
    
    if ( NULL != pszCounterPath ) {
        delete pszCounterPath;
    }

    
    if ( SMON_STATUS_DUPL_COUNTER_PATH != hr ) {
        DWORD dwCounterListLen;
        LPCWSTR szCounterList = NULL;
    
        szCounterList = GetErrorPathList ( &dwCounterListLen );
        if ( NULL != szCounterList ) {

            TCHAR* pszMessage = NULL;
            // Report error, but continue.
            pszMessage = new WCHAR [dwCounterListLen + MAX_PATH];
        
            if ( NULL != pszMessage ) {
                _stprintf ( pszMessage, ResourceString(IDS_ADD_COUNTER_ERR), szCounterList );    
                MessageBox (
                    m_hWnd, 
                    pszMessage, 
                    ResourceString(IDS_APP_NAME), 
                    MB_OK | MB_ICONEXCLAMATION);

                delete pszMessage;
            }
            ClearErrorPathList();
        }
    }

    return hrErr;
}


HRESULT 
CSysmonControl::LoadFromPropertyBag (
    IPropertyBag* pIPropBag,
    IErrorLog* pIErrorLog )
{
    HRESULT     hr = S_OK;
    GRAPH_OPTIONS   *pOptions = &m_pObj->m_Graph.Options;
    ISystemMonitor  *pObj = m_pObj->m_pImpISystemMonitor;
    INT         iExtentX;
    INT         iExtentY;
    INT         intValue;
    BOOL        bValue;
    FLOAT       fValue;
    OLE_COLOR   clrValue;
    INT         iBufSize;
    SMONCTRL_VERSION_DATA VersionData;
    INT         nLogType = SMON_CTRL_LOG;

    if (g_dwScriptPolicy == URLPOLICY_DISALLOW) {
        return E_ACCESSDENIED;
    }

    // Version info

    VersionData.dwVersion = 0;
    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszVersion, (INT&)VersionData.dwVersion );
    
    assert ( SMONCTRL_MAJ_VERSION >= VersionData.iMajor );

    m_LoadedVersion.dwVersion = VersionData.dwVersion;

    hr = IntegerFromPropertyBag (pIPropBag, pIErrorLog, CGlobalString::m_cszLogType, nLogType);
    if(SUCCEEDED(hr) && (nLogType == SLQ_TRACE_LOG)) {
        // This is a WMI/WDM event trace log files, bail out immediately.
        //
        MessageBox(m_hWnd,
                   ResourceString(IDS_TRACE_LOG_ERR_MSG),
                   ResourceString(IDS_APP_NAME),
                   MB_OK);
        return NOERROR;
    }

    // When loading properties, continue even if errors. On error, the value will 
    // remain default value.
    // Extent data
    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszExtentX, iExtentX );

    if ( SUCCEEDED( hr ) ){
        hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszExtentY, iExtentY );
        if ( SUCCEEDED( hr ) ) {
            RECT RectExt;

            SetRect(&RectExt, 0, 0, iExtentX, iExtentY);
            m_pObj->RectConvertMappings(&RectExt, TRUE);    // Convert from HIMETRIC
            m_pObj->m_RectExt = RectExt;
        }
    }

    // Options settings.  Where possible, options are added through the vtable
    // interface, for validation.    

    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszDisplayType, intValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_DisplayType ( (eDisplayTypeConstant)intValue );
    }

    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszReportValueType, intValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_ReportValueType ( (eReportValueTypeConstant)intValue );
    }

    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszMaximumScale, intValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_MaximumScale ( intValue );
    }

    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszMinimumScale, intValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_MinimumScale ( intValue );
    }

    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszAppearance, intValue );
    if ( SUCCEEDED(hr) ) {
        if ( NULL_COLOR == intValue ) {
            pOptions->iAppearance = intValue;
        } else {
            hr = pObj->put_Appearance ( intValue );
        }
    }

    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszBorderStyle, intValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_BorderStyle ( intValue );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszShowLegend, bValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_ShowLegend ( (SHORT)bValue );
    }
                
    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszShowToolBar, bValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_ShowToolbar ( (SHORT)bValue );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszShowValueBar, bValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_ShowValueBar ( (SHORT)bValue );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszShowScaleLabels, bValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_ShowScaleLabels ( (SHORT)bValue );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszShowHorizontalGrid, bValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_ShowHorizontalGrid ( (SHORT)bValue );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszShowVerticalGrid, bValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_ShowVerticalGrid ( (SHORT)bValue );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszHighLight, bValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_Highlight ( (SHORT)bValue );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszManualUpdate, bValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_ManualUpdate ( (SHORT)bValue );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszReadOnly, bValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_ReadOnly ( (SHORT)bValue );
    }

    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszMonitorDuplicateInstance, bValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_MonitorDuplicateInstances ( (SHORT)bValue );
    }

    hr = FloatFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszUpdateInterval, fValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_UpdateInterval ( fValue );
    }
    
    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszDisplayFilter, intValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_DisplayFilter ( intValue );
    }

    hr = OleColorFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszBackColorCtl, clrValue );
    if ( SUCCEEDED(hr) ) {
        if ( NULL_COLOR == clrValue ) {
            pOptions->clrBackCtl = clrValue;
        } else {
            hr = pObj->put_BackColorCtl ( clrValue );
        }
    }

    hr = OleColorFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszBackColor, clrValue );
    if ( SUCCEEDED(hr) ) {
        if ( NULL_COLOR == clrValue ) {
            pOptions->clrBackPlot = clrValue;
        } else {
            hr = pObj->put_BackColor ( clrValue );
        }
    }
    
    hr = OleColorFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszForeColor, clrValue );
    if ( SUCCEEDED(hr) ) {
        if ( NULL_COLOR == clrValue ) {
            pOptions->clrFore = clrValue;
        } else {
            hr = pObj->put_ForeColor ( clrValue );
        }
    }
    
    hr = OleColorFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszGridColor, clrValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_GridColor ( clrValue );
    }

    hr = OleColorFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszTimeBarColor, clrValue );
    if ( SUCCEEDED(hr) ) {
        hr = pObj->put_TimeBarColor ( clrValue );
    }

    // Titles
    
    hr = StringFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszGraphTitle, NULL, iBufSize );
    if ( SUCCEEDED(hr) && 
        iBufSize > 0 ) {
        pOptions->pszGraphTitle = new TCHAR[iBufSize];
        if ( NULL != pOptions->pszGraphTitle ) {
            hr = StringFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszGraphTitle, pOptions->pszGraphTitle, iBufSize );
        }
    }

    hr = StringFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszYAxisLabel, NULL, iBufSize );
    if ( SUCCEEDED(hr) && 
         iBufSize > 0 ) {
        pOptions->pszYaxisTitle = new TCHAR[iBufSize];
        if ( NULL != pOptions->pszYaxisTitle ) {
            hr = StringFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszYAxisLabel, pOptions->pszYaxisTitle, iBufSize );
        }
    }

    // SQL DSN and logset info
    // 
    hr = StringFromPropertyBag(
            pIPropBag, pIErrorLog, CGlobalString::m_cszSqlDsnName, NULL, iBufSize);
    if (SUCCEEDED(hr) &&  iBufSize > 0) {
        if (m_DataSourceInfo.szSqlDsnName) {
            delete(m_DataSourceInfo.szSqlDsnName);
            m_DataSourceInfo.szSqlDsnName = NULL;
        }
        m_DataSourceInfo.szSqlDsnName = new TCHAR[iBufSize + 1];
        if (m_DataSourceInfo.szSqlDsnName) {
            hr = StringFromPropertyBag(pIPropBag,
                                       pIErrorLog,
                                       CGlobalString::m_cszSqlDsnName,
                                       m_DataSourceInfo.szSqlDsnName,
                                       iBufSize);
        }
        if (SUCCEEDED(hr)) {
            hr = StringFromPropertyBag(
                    pIPropBag, pIErrorLog, CGlobalString::m_cszSqlLogSetName, NULL, iBufSize);
            if (SUCCEEDED(hr) &&  iBufSize > 0) {
                if (m_DataSourceInfo.szSqlLogSetName) {
                    delete(m_DataSourceInfo.szSqlLogSetName);
                    m_DataSourceInfo.szSqlLogSetName = NULL;
                }
                m_DataSourceInfo.szSqlLogSetName = new TCHAR[iBufSize + 1];
                if (m_DataSourceInfo.szSqlLogSetName) {
                    hr = StringFromPropertyBag(pIPropBag,
                                               pIErrorLog,
                                               CGlobalString::m_cszSqlLogSetName,
                                               m_DataSourceInfo.szSqlLogSetName,
                                               iBufSize);
                }
            }
        }
        if (SUCCEEDED(hr)) {
            hr = LLTimeFromPropertyBag(pIPropBag,
                                       pIErrorLog,
                                       CGlobalString::m_cszLogViewStart,
                                       m_DataSourceInfo.llStartDisp);
        }
        if (SUCCEEDED(hr)) {
            hr = LLTimeFromPropertyBag(pIPropBag,
                                       pIErrorLog,
                                       CGlobalString::m_cszLogViewStop,
                                       m_DataSourceInfo.llStopDisp);
        }
    }

    // Log file info

    hr = LoadLogFilesFromPropertyBag ( pIPropBag, pIErrorLog );

    // Must put log file name after display range, before adding counters.

    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszDataSourceType, intValue );
    if (FAILED (hr)) {
        // If DataSourceType flag is missing, set data source type based on 
        // presence of log files.
        if (NumLogFiles() > 0) {
            intValue = sysmonLogFiles;
        }
        else if ( m_DataSourceInfo.szSqlDsnName && m_DataSourceInfo.szSqlLogSetName ) {
            if ( m_DataSourceInfo.szSqlDsnName[0] != _T('\0') && m_DataSourceInfo.szSqlLogSetName[0] != _T('\0')) {
                intValue = sysmonSqlLog;
            }
        }
        else {
            intValue = sysmonCurrentActivity;
        }
    }

    // Load log view start and stop times if the data source is not realtime.
    if ( sysmonSqlLog == intValue || sysmonLogFiles == intValue ) {
        hr = LLTimeFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszLogViewStart, m_DataSourceInfo.llStartDisp );
        hr = LLTimeFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszLogViewStop, m_DataSourceInfo.llStopDisp );
    }

    hr = pObj->put_DataSourceType ( (eDataSourceTypeConstant)intValue );

    if( FAILED(hr) ) {

        if ( SMON_STATUS_LOG_FILE_SIZE_LIMIT == hr ) {
            // TodoLogFiles:  Check log file type.  Only perfmon and circular
            // binary logs are still limited to 1 GB.
            // TodoLogFiles:  Current query is already closed,
            // so what can be done here?
        } else {
            DWORD dwStatus;
            LPWSTR       szLogFileList = NULL;
            ULONG        ulLogListBufLen= 0;

            if ( sysmonLogFiles == intValue ) {
                dwStatus = BuildLogFileList ( 
                            NULL,
                            TRUE,
                            &ulLogListBufLen );
                szLogFileList =  (LPWSTR) malloc(ulLogListBufLen * sizeof(WCHAR));
                if ( NULL != szLogFileList ) {
                    dwStatus = BuildLogFileList ( 
                                szLogFileList,
                                TRUE,
                                &ulLogListBufLen );
                }
            }
            dwStatus = DisplayDataSourceError (
                            m_hWnd,
                            (DWORD)hr,
                            intValue,
                            szLogFileList,
                            m_DataSourceInfo.szSqlDsnName,
                            m_DataSourceInfo.szSqlLogSetName );

            if ( NULL != szLogFileList ) {
                delete szLogFileList;
                szLogFileList = NULL;
            }
        }
    } 

    // Font info
    hr = BOOLFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszAmbientFont, bValue );
    if (SUCCEEDED(hr)) {
        pOptions->bAmbientFont = bValue;
    }

    // Load property bag values if they exist, overriding any specified aspect of ambient font.
    hr = m_OleFont.LoadFromPropertyBag ( pIPropBag, pIErrorLog );

    // Legend
    hr = m_pLegend->LoadFromPropertyBag ( pIPropBag, pIErrorLog );

    // Counters
        
    m_bLoadingCounters = TRUE;

    hr = LoadCountersFromPropertyBag ( pIPropBag, pIErrorLog, TRUE );

    m_bLoadingCounters = FALSE;

    // Load the Visuals after loading all counters.

    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszNextCounterColor, intValue );
    if ( SUCCEEDED(hr) && ( intValue < NumStandardColorIndices() ) ) {
        m_iColorIndex = intValue;
    }

    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszNextCounterWidth, intValue );
    if ( SUCCEEDED(hr) && ( intValue < NumWidthIndices() ) ) {
        m_iWidthIndex = intValue;
    }

    hr = IntegerFromPropertyBag ( pIPropBag, pIErrorLog, CGlobalString::m_cszNextCounterLineStyle, intValue );
    if ( SUCCEEDED(hr) && ( intValue < NumStyleIndices() ) ) {
        m_iStyleIndex = intValue;
    }

    return NOERROR;
}


HRESULT 
CSysmonControl::SaveToPropertyBag (
    IPropertyBag* pIPropBag,
    BOOL fSaveAllProps )
{
    HRESULT         hr = NOERROR;
    GRAPH_OPTIONS   *pOptions = &m_pObj->m_Graph.Options;
    PCMachineNode   pMachine;
    PCObjectNode    pObject;
    PCInstanceNode  pInstance;
    PCGraphItem     pItem;
    PCLogFileItem   pLogFile = NULL;
    INT             iCounterIndex = 0;
    INT             iLogFileIndex = 0;
    RECT            RectExt;
    SMONCTRL_VERSION_DATA VersionData;
    WCHAR           szLogFileName[16];
    LPTSTR          szEnglishBuf = NULL;
    DWORD           dwEnglishBufSize = 0;
    LPTSTR          pszPath = NULL;
    PDH_STATUS      pdhStatus;

    // Version info
    VersionData.iMajor = SMONCTRL_MAJ_VERSION;
    VersionData.iMinor = SMONCTRL_MIN_VERSION;
    
    hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszVersion, VersionData.dwVersion );

    // Extent data in HIMETRIC format
    if ( SUCCEEDED( hr ) ){
        RectExt = m_pObj->m_RectExt;
        m_pObj->RectConvertMappings(&RectExt, FALSE); 
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszExtentX, RectExt.right - RectExt.left );

        if ( SUCCEEDED( hr ) ){
            hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszExtentY, RectExt.bottom - RectExt.top );
        }
    }

    // Options settings

    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszDisplayType, pOptions->iDisplayType );
    }

    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszReportValueType, pOptions->iReportValueType );
    }

    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszMaximumScale, pOptions->iVertMax );
    }

    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszMinimumScale, pOptions->iVertMin );
    }

    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszShowLegend, pOptions->bLegendChecked );
    }
                
    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszShowToolBar, pOptions->bToolbarChecked );
    }

    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszShowScaleLabels, pOptions->bLabelsChecked );
    }

    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszShowHorizontalGrid, pOptions->bHorzGridChecked );
    }
    
    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszShowVerticalGrid, pOptions->bVertGridChecked );
    }

    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszShowValueBar, pOptions->bValueBarChecked );
    }

    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszManualUpdate, pOptions->bManualUpdate );
    }

    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszHighLight, pOptions->bHighlight );
    }

    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszReadOnly, pOptions->bReadOnly );
    }
    
    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszMonitorDuplicateInstance, pOptions->bMonitorDuplicateInstances );
    }
    
    if ( SUCCEEDED( hr ) ){
        hr = FloatToPropertyBag ( pIPropBag, CGlobalString::m_cszUpdateInterval, pOptions->fUpdateInterval );
    }
    
    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszDisplayFilter, pOptions->iDisplayFilter );
    }

    if ( SUCCEEDED( hr ) ){
        hr = OleColorToPropertyBag ( pIPropBag, CGlobalString::m_cszBackColorCtl, pOptions->clrBackCtl );
    }

    if ( SUCCEEDED( hr ) ){
        hr = OleColorToPropertyBag ( pIPropBag, CGlobalString::m_cszForeColor, pOptions->clrFore );
    }

    if ( SUCCEEDED( hr ) ){
        hr = OleColorToPropertyBag ( pIPropBag, CGlobalString::m_cszBackColor, pOptions->clrBackPlot );
    }

    if ( SUCCEEDED( hr ) ){
        hr = OleColorToPropertyBag ( pIPropBag, CGlobalString::m_cszGridColor, pOptions->clrGrid );
    }
        
    if ( SUCCEEDED( hr ) ){
        hr = OleColorToPropertyBag ( pIPropBag, CGlobalString::m_cszTimeBarColor, pOptions->clrTimeBar );
    }

    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszAppearance, pOptions->iAppearance );
    }

    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszBorderStyle, pOptions->iBorderStyle );
    }

    // Visuals are stored directly in the control.  Move to pOptions if made part
    // of the programming interface.
    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszNextCounterColor, m_iColorIndex );
    }

    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszNextCounterWidth, m_iWidthIndex );
    }

    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszNextCounterLineStyle, m_iStyleIndex );
    }

    // Titles
    
    if ( SUCCEEDED( hr ) ){
        hr = StringToPropertyBag ( pIPropBag, CGlobalString::m_cszGraphTitle, pOptions->pszGraphTitle );
    }

    if ( SUCCEEDED( hr ) ){
        hr = StringToPropertyBag ( pIPropBag, CGlobalString::m_cszYAxisLabel, pOptions->pszYaxisTitle );
    }

    // Data source info

    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszDataSourceType, pOptions->iDataSourceType );
    }

    if ( SUCCEEDED( hr ) && 
        ( sysmonLogFiles == pOptions->iDataSourceType 
            || sysmonSqlLog == pOptions->iDataSourceType ) ) 
    {
        hr = LLTimeToPropertyBag ( pIPropBag, CGlobalString::m_cszLogViewStart, m_DataSourceInfo.llStartDisp );

        if ( SUCCEEDED( hr ) ){
            hr = LLTimeToPropertyBag ( pIPropBag, CGlobalString::m_cszLogViewStop, m_DataSourceInfo.llStopDisp );
        }
    }

    // SQL data source

    if (SUCCEEDED(hr)) {
        hr = StringToPropertyBag(pIPropBag,
                                 CGlobalString::m_cszSqlDsnName,
                                 m_DataSourceInfo.szSqlDsnName);
    }

    if (SUCCEEDED(hr)) {
        hr = StringToPropertyBag(pIPropBag,
                                 CGlobalString::m_cszSqlLogSetName,
                                 m_DataSourceInfo.szSqlLogSetName);
    }

    // Log files

    if ( SUCCEEDED( hr ) ){
        iLogFileIndex = 0;
        for ( 
            pLogFile = FirstLogFile(); 
            NULL != pLogFile;
            pLogFile = pLogFile->Next() ) 
        {
            swprintf ( szLogFileName, CGlobalString::m_cszLogNameFormat, CGlobalString::m_cszLogFileName, ++iLogFileIndex );
            hr = StringToPropertyBag ( pIPropBag, szLogFileName, pLogFile->GetPath() );
        }
        if ( SUCCEEDED( hr ) ){
            hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszLogFileCount, iLogFileIndex );
        }
    }

    // Font info

    if ( SUCCEEDED( hr ) ){
        hr = BOOLToPropertyBag ( pIPropBag, CGlobalString::m_cszAmbientFont, pOptions->bAmbientFont );

        if ( FAILED( hr ) || !pOptions->bAmbientFont ){
            hr = m_OleFont.SaveToPropertyBag ( pIPropBag, TRUE, fSaveAllProps );
        }
    }

    // Legend

    if ( SUCCEEDED( hr ) ){
        hr = m_pLegend->SaveToPropertyBag ( pIPropBag, TRUE, fSaveAllProps );
    }

    // Save counter count and sample data

    LockCounterData();

    if ( SUCCEEDED( hr ) ){
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszCounterCount, CounterTree()->NumCounters() );
    }

    if ( SUCCEEDED(hr) ) {
        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszMaximumSamples, m_pHistCtrl->nMaxSamples );
    }

    if ( SUCCEEDED(hr) ) {
        INT iSampleCount;

        if ( !m_fUserMode ) {
            iSampleCount = 0;
#if !_LOG_INCLUDE_DATA
        } else if ( m_bLogFileSource ) {
            iSampleCount = 0;
#endif 
        } else {
            iSampleCount = m_pHistCtrl->nSamples;
        }  

        hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszSampleCount, iSampleCount );

        if ( SUCCEEDED(hr) && ( 0 < iSampleCount )) {
#if _LOG_INCLUDE_DATA
            INT iTemp;
            iTemp = ( 0 < m_pHistCtrl->iCurrent ?  m_pHistCtrl->iCurrent : 1 );
            hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszSampleIndex, iTemp );            
            if ( SUCCEEDED(hr) ) {
                iTemp = ( 0 < m_pObj->m_Graph.TimeStepper.StepNum() ?  m_pObj->m_Graph.TimeStepper.StepNum() : 1 );
                hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszStepNumber, iTemp );
            }
#else
            hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszSampleIndex, m_pHistCtrl->iCurrent );            
            if ( SUCCEEDED(hr) ) {
                hr = IntegerToPropertyBag ( pIPropBag, CGlobalString::m_cszStepNumber, m_pObj->m_Graph.TimeStepper.StepNum() );
            }
#endif 
        }
    }

    for ( pMachine = CounterTree()->FirstMachine();
          pMachine;
          pMachine = pMachine->Next()) {

      for ( pObject = pMachine->FirstObject();
            pObject;
            pObject = pObject->Next()) {

            for ( pInstance = pObject->FirstInstance();
                  pInstance;
                  pInstance = pInstance->Next()) {

                for ( pItem = pInstance->FirstItem();
                      pItem;
                      pItem = pItem->m_pNextItem) {

                    // Save all counters explicitly, even if wildcard
                    iCounterIndex++;
                    hr = pItem->SaveToPropertyBag (
                                    pIPropBag, 
                                    iCounterIndex,
                                    m_fUserMode,
                                    SMONCTRL_MAJ_VERSION, 
                                    SMONCTRL_MIN_VERSION);
                    if (FAILED(hr))
                        return hr;

                }
            }
        }
    }
    
    assert ( iCounterIndex == CounterTree()->NumCounters() );

    // Selection
    if ( NULL != m_pSelectedItem ) {
        VARIANT vValue;
        DWORD   dwBufSize;
        LPTSTR  pNewBuf;

        VariantInit( &vValue );
        vValue.vt = VT_BSTR;
        // get this counter path
        hr = m_pSelectedItem->get_Path( &vValue.bstrVal );
        
        if( SUCCEEDED(hr) ){

            pszPath = vValue.bstrVal;

            //
            // Initialize the locale path buffer
            //
            if (dwEnglishBufSize == 0) {
                dwEnglishBufSize = (MAX_PATH + 1) * sizeof(TCHAR);
                szEnglishBuf = (LPTSTR) malloc(dwEnglishBufSize);
                if (szEnglishBuf == NULL) {
                    dwEnglishBufSize = 0;
                }
            }

            if (szEnglishBuf != NULL) {
                //
                // Translate counter name from Localization into English
                //
                dwBufSize = dwEnglishBufSize;

                pdhStatus = PdhTranslate009Counter(
                                vValue.bstrVal,
                                szEnglishBuf,
                                &dwBufSize);

                if (pdhStatus == PDH_MORE_DATA) {
                    pNewBuf = (LPTSTR)realloc(szEnglishBuf, dwBufSize);

                    if (pNewBuf != NULL) {
                        szEnglishBuf = pNewBuf;
                        dwEnglishBufSize = dwBufSize;
    
                        pdhStatus = PdhTranslate009Counter(
                                            vValue.bstrVal,
                                            szEnglishBuf,
                                            &dwBufSize);
                    }
                }

                if (pdhStatus == ERROR_SUCCESS) {
                    pszPath = szEnglishBuf;
                }
            }

            if( SUCCEEDED(hr) ) {
                VariantClear( &vValue );
                vValue.bstrVal = SysAllocString( pszPath );
                if( vValue.bstrVal != NULL ){
                    vValue.vt = VT_BSTR;
                }
            }else{
                //translation failed, write current value
                hr = ERROR_SUCCESS;
            }
        }

        
        if ( SUCCEEDED ( hr ) ) {
            hr = pIPropBag->Write(CGlobalString::m_cszSelected, &vValue );    
            VariantClear ( &vValue );
        }
    }

    if (szEnglishBuf != NULL) {
        free(szEnglishBuf);
    }

    UnlockCounterData();
    return hr;
}

DWORD 
CSysmonControl::InitializeQuery (
    void )
{
    DWORD dwStat = ERROR_SUCCESS;
    PCGraphItem pItem;

    // Query must be opened before this method is called.
    if ( NULL != m_hQuery ) {
        m_pHistCtrl->nMaxSamples = MAX_GRAPH_SAMPLES;
        m_pHistCtrl->iCurrent = 0;
        m_pHistCtrl->nSamples = 0;
        m_pHistCtrl->nBacklog = 0;
        m_pObj->m_Graph.TimeStepper.Reset();
        m_pObj->m_Graph.LogViewStartStepper.Reset();
        m_pObj->m_Graph.LogViewStopStepper.Reset();
        m_pHistCtrl->bLogSource = m_bLogFileSource;
    
    } else { 
        dwStat = PDH_INVALID_HANDLE;
    }

    if ( ERROR_SUCCESS == dwStat ) {
        // Add counters to the query, to initialize scale factors
        if ((pItem = FirstCounter()) != NULL) {
            while (pItem != NULL) {
                pItem->AddToQuery(m_hQuery);
                pItem = pItem->Next();
            }
        }
    }

    return dwStat;
}

DWORD 
CSysmonControl::ActivateQuery (
    void )
{
    DWORD dwStat = ERROR_SUCCESS;
    DWORD   dwThreadID;

    // if real-time source
    if (!IsLogSource() 
        && m_fInitialized
        && IsUserMode() ) {

        if ( NULL == m_CollectInfo.hEvent ) {
            // Create a collection event
            if ((m_CollectInfo.hEvent = CreateEvent(NULL, FALSE, 0, NULL)) == NULL) {
                dwStat = GetLastError();
            } else 
            // Create the collection thread
            if ( ( m_CollectInfo.hThread 
                    = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)CollectProc, this, 0, &dwThreadID)) == NULL) {
                dwStat = GetLastError();
            }
            if ( ERROR_SUCCESS == dwStat ) {
                SetThreadPriority ( m_CollectInfo.hThread, THREAD_PRIORITY_TIME_CRITICAL );
            }
        }
        if ( ERROR_SUCCESS == dwStat ) {
            // Start the data collection
            if ( FirstCounter() != NULL) {
                SetIntervalTimer();
            }
        }
    }

    if ( ERROR_SUCCESS != dwStat ) {
        // If failure, close query to clean up then exit
        CloseQuery();
    }

    return dwStat;
}
void 
CSysmonControl::CloseQuery (
    void )
{
    PCGraphItem pItem;

    // Terminate the collection thread
    if ( NULL != m_CollectInfo.hThread ) {
        m_CollectInfo.iMode = COLLECT_QUIT;
        SetEvent(m_CollectInfo.hEvent);

        WaitForSingleObject(m_CollectInfo.hThread, INFINITE);
        CloseHandle(m_CollectInfo.hThread);
        m_CollectInfo.hThread = NULL;
    }

    // Release the collection event
    if ( NULL != m_CollectInfo.hEvent ) {
        CloseHandle(m_CollectInfo.hEvent);
        m_CollectInfo.hEvent = NULL;
    }

    LockCounterData();

    // Remove counters from the query
    pItem = FirstCounter();
    while ( NULL != pItem ) {
        pItem->RemoveFromQuery();
        pItem = pItem->Next();
    }

    UnlockCounterData();

    // Delete the query
    if ( NULL != m_hQuery ) {
        PdhCloseQuery ( m_hQuery );
        if (   (m_DataSourceInfo.hDataSource != H_REALTIME_DATASOURCE)
                && (m_DataSourceInfo.hDataSource != H_WBEM_DATASOURCE)) {
            PdhCloseLog(m_DataSourceInfo.hDataSource, 0);
            m_DataSourceInfo.hDataSource = H_REALTIME_DATASOURCE;
        }
        m_hQuery = NULL;
    }
}


 void CSysmonControl::SizeComponents ( HDC hDC )
/*
   Effect:        Move and show the various components of the graph to
                  fill the size (xWidth x yHeight). Take into account
                  whether the user wants to show the legend or status
                  bars. Also take into account if we have room for these
                  items.

   Internals:     If the user doesn't want the status or legend windows,
                  they aren't shown. Also, if the user wanted the status
                  window but not the legend window, the status window is
                  not shown.

                  We may disregard the user's desire for the legend or
                  status bar if there is not room. In particular, a legend
                  window has a minimum width (LegendMinWidth ()) and a
                  minimum height (LegendMinHeight ()). These values are
                  fixed for a given session of perfmon. It also has a 
                  preferred height, which takes into consideration the 
                  size of the graph window and the number of items in
                  the legend. This value is returned by LegendHeight().
      
                  We don't show the legend if its minimum height would
                  take up more than half the graph height.

                  If we feel we don't have room for the legend, we don't
                  show the status window either.

   See Also:      LegendMinWidth, LegendMinHeight, LegendHeight, 
                  ValuebarHeight.

   Called By:     OnSize, any other function that may remove or add one
                  of the graph components.
*/
{
   RECT rectClient;
   RECT rectComponent;
   RECT rectToolbar;
   INT  xWidth;
   INT  yHeight;

   INT  yGraphHeight = 0;
   INT  ySnapHeight = 0;
   INT  yStatsHeight = 0;
   INT  yLegendHeight = 0;
   INT  yToolbarHeight = 0;

#define CTRL_BORDER 10

    // If not inited, there's noting to size
    if (!m_fViewInitialized)
        return;

    // Get dimensions of window
    //  GetClientRect (m_hWnd, &rectClient) ;

    // *** - Use extent.  It is the 'natural' size of the control.
    // This draws the control correctly when zoom = 100%
    // It also makes print size correct at all zoom levels.
    
    
    SetCurrentClientRect ( GetNewClientRect() );
    
    rectClient = *GetCurrentClientRect();

    switch (m_pObj->m_Graph.Options.iDisplayType) {

    case REPORT_GRAPH:

        // Toolbar 
        // Toolbar not available through IViewObect, so leave it out.
        if (m_pObj->m_Graph.Options.bToolbarChecked
            && m_fViewInitialized ) {
            rectToolbar = rectClient;            
            // Determine height of toolbar after sizing it, to handle Wrap.
            m_pToolbar->SizeComponents(&rectToolbar);
            yToolbarHeight = m_pToolbar->Height(); 
        } else {
            memset (&rectToolbar, 0, sizeof(RECT));
            yToolbarHeight = 0;
        }

        if (yToolbarHeight > 0) {
            rectClient.top += yToolbarHeight;
            rectToolbar.bottom = rectToolbar.top + yToolbarHeight;
        }

        // Give report the entire client area except for toolbar
        m_pReport->SizeComponents(&rectClient);

        // Hide the other view components
        SetRect(&rectClient,0,0,0,0);
        m_pGraphDisp->SizeComponents(hDC, &rectClient);
        m_pSnapBar->SizeComponents(&rectClient);
        m_pStatsBar->SizeComponents(&rectClient);
        m_pLegend->SizeComponents(&rectClient);
        break;

    case LINE_GRAPH:
    case BAR_GRAPH:
    
        // Subtract border area
        rectComponent = rectClient;
        InflateRect(&rectComponent, -CTRL_BORDER, -CTRL_BORDER);

        xWidth = rectComponent.right - rectComponent.left ;
        yHeight = rectComponent.bottom - rectComponent.top ;

        // if the window has no area, forget it
        if (xWidth == 0 || yHeight == 0)
            return ;

        // Reserve top fourth of window for graph
        yGraphHeight = yHeight / 4;
        yHeight -= yGraphHeight;

        // Allocate space to each enabled component
        // Toolbar 
        if (m_pObj->m_Graph.Options.bToolbarChecked
            && m_fViewInitialized ) {
            rectToolbar = rectComponent;            
            m_pToolbar->SizeComponents(&rectToolbar);
            yToolbarHeight = m_pToolbar->Height();
        } else {
            memset (&rectToolbar, 0, sizeof(RECT));
            yToolbarHeight = 0;
        }

        if (yToolbarHeight > 0) {
            yHeight -= yToolbarHeight;
            rectToolbar.bottom = rectToolbar.top + yToolbarHeight;
            rectComponent.top += yToolbarHeight;
        }

        // Legend (Start with minimum size)
        if (m_pObj->m_Graph.Options.bLegendChecked) {
            yLegendHeight = m_pLegend->MinHeight(yHeight - CTRL_BORDER);
            if (yLegendHeight > 0)          
                yHeight -= yLegendHeight + CTRL_BORDER;
        }

        // Statistics bar
        if (m_pObj->m_Graph.Options.bValueBarChecked) {
            yStatsHeight = m_pStatsBar->Height(yHeight - CTRL_BORDER, xWidth);
            if (yStatsHeight > 0)
                yHeight -= yStatsHeight + CTRL_BORDER;
        }

        // Snap bar 
        // only if tool bar is not displayed
        if ((m_pObj->m_Graph.Options.bManualUpdate) && 
            (!m_pObj->m_Graph.Options.bToolbarChecked)) {
            ySnapHeight = m_pSnapBar->Height(yHeight - CTRL_BORDER);
            if (ySnapHeight > 0)
                yHeight -= ySnapHeight + CTRL_BORDER;
        }

        // If legend is visible give it a chance to use remaining space
        // Rest goes to graph
        if (yLegendHeight != 0) {
            yHeight += yLegendHeight;
            yLegendHeight = m_pLegend->Height(yHeight);
            yGraphHeight += yHeight - yLegendHeight;
            }
        else
            yGraphHeight += yHeight;

        // Assign rectangle to each component
        // Toolbar assigned earlier, to handle wrap.
        
        // Graph display
        rectComponent.bottom = rectComponent.top + yGraphHeight;
        m_pGraphDisp->SizeComponents(hDC, &rectComponent);
        rectComponent.top += yGraphHeight + CTRL_BORDER;

        // Snap bar
        rectComponent.bottom = rectComponent.top + ySnapHeight;
        m_pSnapBar->SizeComponents(&rectComponent);
        if (ySnapHeight != 0)
            rectComponent.top += ySnapHeight + CTRL_BORDER;

        // Statistics bar 
        rectComponent.bottom = rectComponent.top + yStatsHeight;
        m_pStatsBar->SizeComponents(&rectComponent);
        if (yStatsHeight != 0)
            rectComponent.top += yStatsHeight + CTRL_BORDER;

        // Legend window
        rectComponent.bottom = rectComponent.top + yLegendHeight;
        m_pLegend->SizeComponents(&rectComponent);
        rectComponent.top += yLegendHeight;

        // Force redraw of window
        // Optimize:  SizeComponents only called within Paint or Render,
        // so remove this extra window invalidation.        
        WindowInvalidate(m_hWnd);

        // Hide report window
        SetRect(&rectClient,0,0,0,0);
        m_pReport->SizeComponents(&rectComponent);

        break;
    }  
}

void CSysmonControl::put_Highlight(BOOL bState)
{
    // If no change, just return
    if ( m_pObj->m_Graph.Options.bHighlight == bState )
        return;

    m_pObj->m_Graph.Options.bHighlight = bState;

    // if no selected item, state doesn't matter
    if (m_pSelectedItem == NULL)
        return;

    // Update graph display's highlighted item 
    if ( m_pObj->m_Graph.Options.bHighlight )
        m_pGraphDisp->HiliteItem(m_pSelectedItem);
    else
        m_pGraphDisp->HiliteItem(NULL);

    // Cause redraw
    UpdateGraph(UPDGRPH_PLOT);
}


void 
CSysmonControl::put_ManualUpdate(BOOL bManual)
{
    m_pObj->m_Graph.Options.bManualUpdate = bManual;

    if ( m_bSampleDataLoaded ) {
        UpdateCounterValues(FALSE);
    } else {    
        SetIntervalTimer();
        UpdateGraph(UPDGRPH_LAYOUT);
    }
}

VOID CSysmonControl::AssignFocus (
    VOID
    )
{
    if (m_pObj->m_Graph.Options.iDisplayType == REPORT_GRAPH)
        SetFocus(m_pReport->Window());
    else
        SetFocus(m_pLegend->Window());
}


HRESULT CSysmonControl::TranslateAccelerators( LPMSG pMsg )
{
    INT iStat;

    if (m_hWnd == NULL || m_hAccel == NULL)
        return S_FALSE;

    // If this is a cursor key down event, process it here, or the container may grab it first 
    // I need to be sure that it reaches the legend listbox 
    if (pMsg->message == WM_KEYDOWN && 
        ( pMsg->wParam == VK_UP || pMsg->wParam == VK_DOWN || 
          pMsg->wParam == VK_HOME || pMsg->wParam == VK_END ) ) {
        ::TranslateMessage(pMsg);
        ::DispatchMessage(pMsg);
        return S_OK;
    }

    iStat = ::TranslateAccelerator(m_hWnd, m_hAccel, pMsg);
    return iStat ? S_OK : S_FALSE;
}
        
//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//

BOOL 
CSysmonControl::DisplayHelp ( HWND hwndSelf )
{
    const INT ciBufCharCount = 2*MAX_PATH + 1;
    TCHAR pszHelpFilePath[ciBufCharCount];
    UINT nLen;
    INT iCharCount;

    if ( NULL != hwndSelf ) {
        nLen = ::GetWindowsDirectory(pszHelpFilePath, ciBufCharCount );
        if ( nLen == 0 ) {
            // Report error.
        }
        iCharCount = (ciBufCharCount - nLen);
        iCharCount = min ( iCharCount, lstrlen(L"\\help\\sysmon.chm") + 1 );

        lstrcpyn(&pszHelpFilePath[nLen], L"\\help\\sysmon.chm", iCharCount );

        HtmlHelp ( hwndSelf, pszHelpFilePath, HH_DISPLAY_TOPIC, 0 );
    }    
    return TRUE;
}

LRESULT APIENTRY SysmonCtrlWndProc (HWND hWnd,
                               UINT uiMsg,
                               WPARAM wParam,
                               LPARAM lParam)
{
    RECT        rect;
    PSYSMONCTRL pCtrl = (PSYSMONCTRL)GetWindowLongPtr(hWnd ,0);
    INT         iUpdate;

    switch (uiMsg) {

        case WM_NOTIFY:
            {
                NMHDR           *pnmHdr;
                NMTTDISPINFO    *pnmInfo;
                LONG_PTR        lStrId;
                pnmHdr = (NMHDR *)lParam;

                switch (pnmHdr->code) {
                    case TTN_NEEDTEXT:
                        pnmInfo = (NMTTDISPINFO *)lParam;
                        // cast ID as a string for this arg
                        lStrId = (LONG_PTR)(wParam - IDM_TOOLBAR);
                        lStrId += IDS_TB_BASE;
                        pnmInfo->lpszText = (LPTSTR)lStrId;
                        pnmInfo->hinst = g_hInstance;
                        break;
                    default:
                        return DefWindowProc (hWnd, uiMsg, wParam, lParam);
                }
            }
            break;

        case WM_CREATE:
            pCtrl = (PSYSMONCTRL)((CREATESTRUCT*)lParam)->lpCreateParams;
            SetWindowLongPtr(hWnd,0,(INT_PTR)pCtrl);
            break;

        case WM_DESTROY:
            pCtrl->m_hWnd = NULL;
            break;

        case WM_CONTEXTMENU:     
        case WM_LBUTTONDOWN:
        case WM_LBUTTONDBLCLK:

            //We become UI Active with mouse action
            if (!pCtrl->m_fUIDead) { 
                 pCtrl->m_pObj->UIActivate();

                pCtrl->AssignFocus();

                if (uiMsg == WM_CONTEXTMENU) {
                    if (LOWORD(lParam)!= 0xffff || HIWORD(lParam) != 0xffff){
                        pCtrl->DisplayContextMenu(LOWORD(lParam), HIWORD(lParam));
                    }else{
                        pCtrl->DisplayContextMenu(0,0);
                    }
                } else if (uiMsg == WM_LBUTTONDBLCLK) {
                    pCtrl->OnDblClick(LOWORD(lParam), HIWORD(lParam));
                }
            }
            break;

        case WM_COMMAND:

            if (pCtrl->m_fUIDead)
                break;

            switch (LOWORD(wParam)) {

                case IDM_TB_PROPERTIES:
                    pCtrl->DisplayProperties();
                    break;

                case IDM_PROPERTIES:
                    pCtrl->DisplayProperties ( DISPID_VALUE );
                    break;

                case IDM_TB_ADD:
                case IDM_ADDCOUNTERS:
                    pCtrl->AddCounters();
                    break;

                case IDM_TB_DELETE:
                case IDM_DELETE:
                    {
                        CWaitCursor cursorWait;
                        if (pCtrl->m_pObj->m_Graph.Options.iDisplayType == REPORT_GRAPH) {
                            pCtrl->m_pReport->DeleteSelection();
                        } else {
                            if ( pCtrl->DeleteCounter ( pCtrl->m_pSelectedItem, TRUE ) ) {
                                pCtrl->UpdateGraph(UPDGRPH_DELCNTR);
                            }
                        }
                    }
                    break;

                case IDM_TB_REALTIME:
                    if ( sysmonCurrentActivity != pCtrl->m_pObj->m_Graph.Options.iDataSourceType ) {
                        CWaitCursor cursorWait;
                        pCtrl->put_DataSourceType ( sysmonCurrentActivity );
                        pCtrl->Clear();
                    } else {
                        // Nothing changed, so resync the toolbar to 
                        // handle state of realtime button.
                        pCtrl->m_pToolbar->SyncToolbar();
                    }
                    break;
                case IDM_TB_LOGFILE:
                    {
                        pCtrl->DisplayProperties( DISPID_SYSMON_DATASOURCETYPE );
                        // Resync the toolbar in case the log file is invalid.
                        pCtrl->m_pToolbar->SyncToolbar();
                    }
                    break;

                case IDM_SAVEAS:
                    pCtrl->SaveAs();
                    break;

                case IDM_SAVEDATA:
                    pCtrl->SaveData();
                    break;

                case IDC_SNAPBTN:
                case IDM_TB_UPDATE:
                case IDM_UPDATE:
                    {
                        CWaitCursor cursorWait;
                        pCtrl->UpdateCounterValues(TRUE);
                    }
                    break;

                case IDM_TB_CLEAR:
                    {
                        CWaitCursor cursorWait;
                        pCtrl->Clear();
                    }
                    break;

                case IDM_TB_FREEZE:
                    // Confirm the data overwrite before changing the state of the freeze button.
                    if ( pCtrl->ConfirmSampleDataOverwrite() ) {
                        pCtrl->put_ManualUpdate ( !pCtrl->m_pObj->m_Graph.Options.bManualUpdate );
                    } else {
                        // Nothing changed, so resync the toolbar to 
                        // handle state of the freeze button.
                        pCtrl->m_pToolbar->SyncToolbar();
                    }
                    break;

                case IDM_TB_HIGHLIGHT:
                case IDM_HIGHLITE:
                    pCtrl->put_Highlight(!pCtrl->m_pObj->m_Graph.Options.bHighlight );
                    break;

                case ID_HATCHWINDOW:
                    if (HIWORD(wParam) == HWN_RESIZEREQUESTED)
                        pCtrl->m_pObj->m_pIOleIPSite->OnPosRectChange((LPRECT)lParam);
                    break;

                case IDM_TB_CHART:
                    if (pCtrl->m_pObj->m_Graph.Options.iDisplayType != sysmonLineGraph) {
                        CWaitCursor cursorWait;
                        if (pCtrl->m_pObj->m_Graph.Options.iDisplayType == REPORT_GRAPH)
                            iUpdate = UPDGRPH_VIEW;
                        else
                            iUpdate = UPDGRPH_PLOT;
                        pCtrl->m_pObj->m_Graph.Options.iDisplayType = LINE_GRAPH;
                        InvalidateRect(pCtrl->m_hWnd, NULL, TRUE);
                        pCtrl->UpdateGraph(iUpdate);
                    }
                    break;
                
                case IDM_TB_HISTOGRAM:
                    if (pCtrl->m_pObj->m_Graph.Options.iDisplayType != sysmonHistogram) {
                        CWaitCursor cursorWait;
                        if (pCtrl->m_pObj->m_Graph.Options.iDisplayType == REPORT_GRAPH)
                            iUpdate = UPDGRPH_VIEW;
                        else
                            iUpdate = UPDGRPH_PLOT;
                        pCtrl->m_pObj->m_Graph.Options.iDisplayType = BAR_GRAPH;
                        InvalidateRect(pCtrl->m_hWnd, NULL, TRUE);
                        pCtrl->UpdateGraph(iUpdate);
                    }
                    break;
                
                case IDM_TB_REPORT:
                    if (pCtrl->m_pObj->m_Graph.Options.iDisplayType != sysmonReport) {
                        CWaitCursor cursorWait;
                        pCtrl->m_pObj->m_Graph.Options.iDisplayType = REPORT_GRAPH;
                        InvalidateRect(pCtrl->m_hWnd, NULL, TRUE);
                        pCtrl->UpdateGraph(UPDGRPH_VIEW);
                    }
                    break;
                
                case IDM_TB_PASTE:
                    {
                        HRESULT hr = S_OK;
                        {
                            CWaitCursor cursorWait;
                            hr = pCtrl->Paste();
                        }
                        if ( SMON_STATUS_NO_SYSMON_OBJECT == hr ) {
                            MessageBox(
                                pCtrl->m_hWnd, 
                                ResourceString(IDS_NOSYSMONOBJECT_ERR ), 
                                ResourceString(IDS_APP_NAME),
                                MB_OK | MB_ICONERROR);
                        }
                    }
                    break;

                case IDM_TB_COPY:
                    {
                        CWaitCursor cursorWait;
                        pCtrl->Copy();
                    }
                    break;

                case IDM_TB_NEW:
                    {
                        CWaitCursor cursorWait;
                        pCtrl->Reset();
                    }
                    break;

                case IDM_TB_HELP:
                {
                    return pCtrl->DisplayHelp ( hWnd );
                }      

                default:
                    return DefWindowProc (hWnd, uiMsg, wParam, lParam);
            }
            break;
        
        case WM_DROPFILES:
            {
                CWaitCursor cursorWait;
                pCtrl->OnDropFile (wParam) ;
            }
            return (0) ;

        case WM_ERASEBKGND:
            GetClientRect(hWnd, &rect);
            Fill((HDC)wParam, pCtrl->clrBackCtl(), &rect);
            return TRUE; 

        case WM_SYSCOLORCHANGE:
            pCtrl->UpdateNonAmbientSysColors();

        case WM_PAINT:
            pCtrl->Paint();
            break ;

        case WM_SIZE:
            if (pCtrl != NULL) {
                // Avoid extra cases of (SetDirty()) if size has not changed.
                if ( !EqualRect ( pCtrl->GetCurrentClientRect(), pCtrl->GetNewClientRect() ) ) {
                    pCtrl->UpdateGraph(UPDGRPH_LAYOUT);
                }
            }
            break ;

        case WM_TIMER:
            pCtrl->UpdateCounterValues(FALSE);
            break;
    
        case WM_SETFOCUS:
            pCtrl->AssignFocus();
            break;

        case WM_GRAPH_UPDATE:
            pCtrl->UpdateGraphData();
            break;
        
        case WM_HELP:
            {
                return pCtrl->DisplayHelp ( hWnd );
            }      

        default:
            return  DefWindowProc (hWnd, uiMsg, wParam, lParam) ;
    }

    return (0);
}


HWND CSysmonControl::Window( VOID )
{
    return m_hWnd;
}


void CSysmonControl::UpdateGraph( INT nUpdateType )
{
    RECT  rectStats;
    RECT  rectGraph;
    PRECT prectUpdate = NULL;
    RECT rectClient;

    // Based on type of change either force redraw or resize components
    switch (nUpdateType) {

    case UPDGRPH_ADDCNTR:
    case UPDGRPH_DELCNTR:
        if ( m_bLogFileSource )
            m_fPendingLogCntrChg = TRUE;

        m_fPendingSizeChg = TRUE;
        break;

    case UPDGRPH_FONT:
        m_fPendingFontChg = TRUE;
        break;

    case UPDGRPH_LOGVIEW:
        m_fPendingLogViewChg = TRUE;
        if (m_hWnd && m_pStatsBar ) {
            m_pStatsBar->GetUpdateRect(&rectStats);
            prectUpdate = &rectStats;
        }
        // Fall into plot area case

    case UPDGRPH_PLOT:

        if ( REPORT_GRAPH != m_pObj->m_Graph.Options.iDisplayType ) {
            if (m_hWnd && m_pGraphDisp) {
                m_pGraphDisp->GetPlotRect(&rectGraph);
                if ( NULL == prectUpdate ) {
                    prectUpdate = &rectGraph;
                } else {
                    ::UnionRect( prectUpdate, &rectStats, &rectGraph);
                }
            }
        } else {
            GetClientRect (m_hWnd, &rectClient);
            prectUpdate = &rectClient;
        }
        break;
            
    case UPDGRPH_COLOR:
        //update the toolbar color
        m_pToolbar->SetBackgroundColor ( clrBackCtl() );
        m_fPendingSizeChg = TRUE;
        break;

    case UPDGRPH_LAYOUT:
    case UPDGRPH_VIEW:
        m_fPendingSizeChg = TRUE;
        break;
    }

    // Set change pending flag to enable ApplyChanges
    m_fPendingUpdate = TRUE;

    // If we're ready to do updates
    if (m_fViewInitialized) {

        // Invalidate window to force redraw
        InvalidateRect(m_hWnd, prectUpdate, TRUE);

        // Notify container of change
        m_pObj->SendAdvise(OBJECTCODE_DATACHANGED);
    }
}

    
void CSysmonControl::UpdateGraphData( VOID )
{
    HDC hDC = NULL;
    PGRAPHDATA  pGraph = &m_pObj->m_Graph;

    if (m_fViewInitialized) {

        UpdateAppPerfTimeData (TD_UPDATE_TIME, TD_BEGIN);

        hDC = GetDC(m_hWnd);

        // Update statistics if active
        // Statistics are updated before the graph display in case the
        // graph display selects a clipping region.  
        if (pGraph->Options.bValueBarChecked &&m_pSelectedItem != NULL) {
            // The stats bar doesn't always use the hDC, so passing NULL
            // hDC is okay.
            m_pStatsBar->Update(hDC, m_pSelectedItem);
        }

        if ( NULL != hDC ) {

            // Update graph display
            m_pGraphDisp->Update(hDC);

            m_pReport->Update();

            ReleaseDC(m_hWnd, hDC);
        }

        UpdateAppPerfTimeData (TD_UPDATE_TIME, TD_END);
    }   
}


void CSysmonControl::Render( 
    HDC hDC, 
    HDC hAttribDC,
    BOOL fMetafile, 
    BOOL fEntire, 
    LPRECT pRect )
{
    HDC hLocalAttribDC = NULL;
    
    // If not inited, return.
    if ( m_fViewInitialized ) {

        if ( NULL == hAttribDC ) {
            hLocalAttribDC = GetDC(m_hWnd);
        } else {
            hLocalAttribDC = hAttribDC;
        }

        // Make sure layout is up to date.

        ApplyChanges( hLocalAttribDC );

        if ( NULL != hDC && NULL != hLocalAttribDC ) {

            if ( REPORT_GRAPH == m_pObj->m_Graph.Options.iDisplayType ) {
                m_pReport->Render( hDC, hLocalAttribDC, fMetafile, fEntire, pRect );
            } else {

                // Fill with background color
                SetBkColor(hDC, clrBackCtl());
                ClearRect(hDC, pRect);

                m_pStatsBar->Draw(hDC, hLocalAttribDC, pRect);
                m_pGraphDisp->Draw(hDC, hLocalAttribDC, fMetafile, fEntire, pRect );
                m_pLegend->Render(hDC, hLocalAttribDC, fMetafile, fEntire, pRect);
            }
    
            if ( eBorderSingle == m_iBorderStyle ) {
                if ( eAppear3D == m_iAppearance ) {
                    DrawEdge(hDC, pRect, EDGE_RAISED, BF_RECT);
                } else {
                    SelectBrush (hDC, GetStockObject (HOLLOW_BRUSH)) ;
                    SelectPen (hDC, GetStockObject (BLACK_PEN)) ;
                    Rectangle (hDC, pRect->left, pRect->top, pRect->right, pRect->bottom );
                }
            }
        }
        if ( NULL != hLocalAttribDC && hAttribDC != hLocalAttribDC ) {
            ReleaseDC ( m_hWnd, hLocalAttribDC );
        }
    }
}



void CSysmonControl::SetIntervalTimer()
{
    HDC         hDC = NULL;
    PGRAPHDATA  pGraph = &m_pObj->m_Graph;

    // if not initialized or counter source is a log file, nothing to do
    if (!m_fInitialized || IsLogSource() || !IsUserMode() )
        return;

    // Update statistics bar
    m_pStatsBar->SetTimeSpan(
                    m_pObj->m_Graph.Options.fUpdateInterval 
                    * m_pObj->m_Graph.Options.iDisplayFilter
                    * m_pHistCtrl->nMaxSamples );

    hDC = GetDC(m_hWnd);
    if ( NULL != hDC ) {
        m_pStatsBar->Update(hDC, m_pSelectedItem);
        ReleaseDC(m_hWnd,hDC);
    }

    // If conditions right for sampling, start new time interval.
    // Otherwise, suspend the collection.
    if (!pGraph->Options.bManualUpdate 
        && pGraph->Options.fUpdateInterval >= 0.001 // ??
        && pGraph->CounterTree.NumCounters() != 0
        && IsUserMode() ) {

        m_CollectInfo.dwInterval= (DWORD)(pGraph->Options.fUpdateInterval * 1000);
        m_CollectInfo.dwSampleTime = GetTickCount();
        m_CollectInfo.iMode = COLLECT_ACTIVE;
    }
    else {
        m_CollectInfo.iMode = COLLECT_SUSPEND;
    }

    assert ( NULL != m_CollectInfo.hEvent );
        
    // Signal the collection thread
    SetEvent(m_CollectInfo.hEvent);

    // If no counters, reset sample time to start 
    if (pGraph->CounterTree.NumCounters() == 0) {
        m_pHistCtrl->iCurrent = 0;
        m_pHistCtrl->nSamples = 0;
        pGraph->TimeStepper.Reset();
    }

}

HRESULT CSysmonControl::AddSingleCounter(LPTSTR pszPath, PCGraphItem *pGItem)
{
    PCGraphItem pGraphItem;
    PGRAPHDATA pGraph = &m_pObj->m_Graph;
    HRESULT hr;
    BOOL bAddSuccessful = FALSE;

    *pGItem = NULL;

    // Create graph item
    pGraphItem = new CGraphItem(this); 
    if (pGraphItem == NULL)
        return E_OUTOFMEMORY;

    LockCounterData();

    // Add it to the counter tree
    hr = pGraph->CounterTree.AddCounterItem(
            pszPath, 
            pGraphItem, 
            pGraph->Options.bMonitorDuplicateInstances);

    if (SUCCEEDED(hr)) {

        // AddRef once for ourself
        pGraphItem->AddRef();

        // Set default attributes
        pGraphItem->put_Color(IndexToStandardColor(m_iColorIndex));
        pGraphItem->put_Width(IndexToWidth(m_iWidthIndex));
        pGraphItem->put_LineStyle(IndexToStyle(m_iStyleIndex));
        pGraphItem->put_ScaleFactor(m_iScaleFactor);

        // Increment and reset for next counter
        IncrementVisuals();
        m_iScaleFactor = INT_MAX;

        // Add item to graph's query

        if ( NULL != m_hQuery ) {
            hr = pGraphItem->AddToQuery(m_hQuery);
        } else {
            // Todo:  Change AddToQuery to return bad status,
            // Todo:  Display error message
            hr = E_FAIL;
        }

        if (SUCCEEDED(hr)) {
            bAddSuccessful = TRUE;
            
            // If control is initialized
            if (m_fViewInitialized) {

                // Add item to chart legend
                m_pLegend->AddItem(pGraphItem);
                m_pReport->AddItem(pGraphItem);
            }
        }
        else {
            // remove the item from the tree 
            pGraphItem->Instance()->RemoveItem(pGraphItem);
        }

        // If OK, Addref the returned interface
        if (SUCCEEDED(hr)) {
            pGraphItem->AddRef();
            *pGItem = pGraphItem;
        } // else released by RemoveItem above.

        // Update messages seem to be combined, so histogram sometimes updates instead of
        // repainting each entire bar.  This forces total repaint.
        if ( m_pGraphDisp) {
            m_pGraphDisp->SetBarConfigChanged();
        }

    } else {
        // AddCounterItem failed
        delete pGraphItem;
    }

    UnlockCounterData();

    // Send events outside of locks.
    if ( bAddSuccessful ) {
        // If first counter
        if (pGraph->CounterTree.NumCounters() == 1) {

            // Make it the selected counter and send event.
            SelectCounter(pGraphItem);

            // Start data collection
            if ( ERROR_SUCCESS != ActivateQuery() ) {
                hr = E_FAIL;
            }
        }

        // Redraw the graph
        UpdateGraph(UPDGRPH_ADDCNTR);

        m_pObj->SendEvent(eEventOnCounterAdded, pGraph->CounterTree.NumCounters());
    }
    return hr;
}


PCCounterTree 
CSysmonControl::CounterTree(
    VOID
    )
{
    return &(m_pObj->m_Graph.CounterTree);
}                                 


PCGraphItem 
CSysmonControl::FirstCounter(
    VOID
    )
{
    return m_pObj->m_Graph.CounterTree.FirstCounter();
}


PCGraphItem 
CSysmonControl::LastCounter(
    VOID
    )
{
    PCGraphItem pItem;
    PCGraphItem pItemNext;

    if (FirstCounter() == NULL)
        return NULL;

    // Locate last graph item
    pItem = FirstCounter();
    while ((pItemNext = pItem->Next()) != NULL)
        pItem = pItemNext;

    return pItem;
}

BOOL
CSysmonControl::IsLogSource(
    VOID
    )
{
    return m_pHistCtrl->bLogSource; 
}

BOOL
CSysmonControl::IsReadOnly(
    VOID
    )
{
    BOOL bReturn = TRUE;

    if (m_fInitialized ) {
        bReturn = m_pObj->m_Graph.Options.bReadOnly;
    }
    return bReturn; 
}

eReportValueTypeConstant
CSysmonControl::ReportValueType(
    VOID
    )
{    
    return ( (eReportValueTypeConstant) m_pObj->m_Graph.Options.iReportValueType );
}

INT CSysmonControl::CounterIndex(PCGraphItem pItem)
{
    PCGraphItem pItemLoc;
    INT iIndex;

    // Traverse linked list until item matched  
    pItemLoc = FirstCounter();
    iIndex = 1;
    while (pItemLoc != pItem && pItemLoc != NULL) {
        pItemLoc = pItemLoc->Next();
        iIndex++;
    }

    return (pItemLoc == NULL) ? -1 : iIndex;
} 


HRESULT CSysmonControl::DeleteCounter(PCGraphItem pItem, BOOL bPropagateUp)
{
    PGRAPHDATA  pGraph = &m_pObj->m_Graph;

    if (pItem == NULL)
        return E_INVALIDARG;

    // Send event
    m_pObj->SendEvent(eEventOnCounterDeleted, CounterIndex(pItem));

    LockCounterData();

    // If this is the selected counter, change selection to NULL
    if (pItem == m_pSelectedItem)
        m_pSelectedItem = NULL;

    if (m_fViewInitialized) {
        // Remove from legend and report
        m_pLegend->DeleteItem(pItem);
        m_pReport->DeleteItem(pItem);

        // Remove from query
        pItem->RemoveFromQuery();
    }

    // Proagate deletion up the tree if requested
    if (bPropagateUp) {
        pItem->Instance()->RemoveItem(pItem);
    }

    // If last counter, stop interval timer
    if (pGraph->CounterTree.NumCounters() == 0)
        SetIntervalTimer();

    // Update messages seem to be combined, so histogram sometimes updates instead of
    // repainting each entire bar.  This forces total repaint.
    if ( m_pGraphDisp) {
        m_pGraphDisp->SetBarConfigChanged();
    }

    UnlockCounterData();

    if ( m_fViewInitialized ) {
        UpdateGraph(UPDGRPH_DELCNTR);
    }

    return NOERROR;
}


void CSysmonControl::SelectCounter(PCGraphItem pItem)
{
    HDC hDC = NULL;
    INT iIndex;

    // Selection in the graph view is maintained independently
    // of the selection in the report view.
    if ( REPORT_GRAPH != m_pObj->m_Graph.Options.iDisplayType ) {
        // Save as current item
        m_pSelectedItem = pItem;

        if (m_fViewInitialized) {
            // Inform Legend
            m_pLegend->SelectItem(pItem);

            // Highlight selected item in graph display
            if (m_pObj->m_Graph.Options.bHighlight) {
                m_pGraphDisp->HiliteItem(pItem);
                UpdateGraph(UPDGRPH_PLOT);
            }

            // Update statistics bar
            if ( m_fViewInitialized )
                hDC = GetDC(m_hWnd);
            
            m_pStatsBar->Update(hDC, pItem);
            
            if ( NULL != hDC )
                ReleaseDC(m_hWnd,hDC);
        }
    }

    // Send event
    iIndex = (pItem == NULL) ? 0 : CounterIndex(pItem);
    m_pObj->SendEvent(eEventOnCounterSelected, iIndex);
}

HRESULT 
CSysmonControl::PasteFromBuffer( LPTSTR pszData, BOOL bAllData )
{
    HRESULT hr = NOERROR;
    CImpIPropertyBag IPropBag;

    hr = IPropBag.LoadData( pszData );

    if ( SUCCEEDED ( hr ) ) {
        INT   nLogType = SMON_CTRL_LOG;

        //get the log type from the  pPropBag and compare it with service(cookie) type
        //Determine log type from property bag. Default to -1  SMON_CTRL_LOG
                          
        hr = IntegerFromPropertyBag (
            &IPropBag,      
            NULL,
            ResourceString(IDS_HTML_LOG_TYPE),
            nLogType);

        if(nLogType == SLQ_TRACE_LOG){
            MessageBox(
                    m_hWnd,
                    ResourceString(IDS_TRACE_LOG_ERR_MSG),
                    ResourceString(IDS_APP_NAME),
                    MB_OK
                                );
        } else {
            if ( bAllData ) {            
                hr = LoadFromPropertyBag( &IPropBag, NULL );
            } else {
                // Do not load sample data for Paste or Drop File.
                hr = LoadCountersFromPropertyBag (&IPropBag, NULL, FALSE );
            }
        }
    }

    return hr;
}

HRESULT CSysmonControl::Paste()
{
    HRESULT hResReturn = NOERROR;
    HANDLE  hMemClipboard;

    // get the clipboard
    if (OpenClipboard (Window())) {
        // read the CF_TEXT or CF_UNICODE data from the clipboard to the local buffer
        hMemClipboard = GetClipboardData (
#if UNICODE
                    CF_UNICODETEXT);     // UNICODE text in the clipboard
#else
                    CF_TEXT);            // ANSI text in the clipboard
#endif
        if (hMemClipboard != NULL) {
            
            LPTSTR pszData;

            if ( ConfirmSampleDataOverwrite ( ) ) {
                pszData = (LPTSTR)GlobalLock (hMemClipboard);// (LPTSTR)hMemClipboard;

                if ( NULL != pszData ) {
                    hResReturn = PasteFromBuffer ( pszData, FALSE );
                    GlobalUnlock ( hMemClipboard );
                }
            }
        }
        // release the clipboard
        CloseClipboard();
    } else {
        // unable to open the clipboard
        hResReturn = HRESULT_FROM_WIN32(GetLastError());
    }

    return hResReturn;
}

HRESULT
CSysmonControl::CopyToBuffer ( LPTSTR& rpszData, DWORD& rdwBufferSize )
{
    HRESULT hr = S_OK;
    LPTSTR  pszHeader = NULL;
    LPTSTR  pszFooter = NULL;
    CImpIPropertyBag    IPropBag;

    assert ( NULL == rpszData );
    rdwBufferSize = 0;

    if (NULL!=m_pObj->m_pImpIPersistPropertyBag) {
        hr = m_pObj->m_pImpIPersistPropertyBag->Save (&IPropBag, FALSE, TRUE );
    }
   
    if ( SUCCEEDED ( hr ) ) {
        DWORD   dwBufferLength;
        LPTSTR  pszConfig;

        pszHeader = ResourceString ( IDS_HTML_OBJECT_HEADER );
        pszFooter = ResourceString ( IDS_HTML_OBJECT_FOOTER );
        pszConfig = IPropBag.GetData();

        // Buffer length includes 1 for NULL terminator.
        dwBufferLength = lstrlen ( pszHeader ) + lstrlen ( pszFooter ) + lstrlen ( pszConfig ) + 1;

        rpszData = new TCHAR[dwBufferLength];

        if ( NULL == rpszData ) {
            hr = E_OUTOFMEMORY; 
        } else {

            rdwBufferSize = dwBufferLength * sizeof(TCHAR);

            rpszData[0] = _T('\0');

            lstrcpy ( rpszData, pszHeader );
            lstrcat ( rpszData, pszConfig );
            lstrcat ( rpszData, pszFooter );
        }
    }

    return hr;
}

HRESULT CSysmonControl::Copy()
{
    HGLOBAL hBuffer = NULL;
    HRESULT hResReturn = NOERROR;
    LPTSTR  pszBuffer = NULL;
    DWORD   dwBufferSize;
    HANDLE  hMemClipboard;

    hResReturn = CopyToBuffer( pszBuffer, dwBufferSize);

    if ( SUCCEEDED ( hResReturn ) ) {
        LPTSTR  pszGlobalBuffer = NULL;
        
        hBuffer = GlobalAlloc ((GMEM_MOVEABLE | GMEM_DDESHARE), dwBufferSize);
        pszGlobalBuffer = (LPTSTR)GlobalLock (hBuffer);
        if ( NULL == pszGlobalBuffer ) {
            // allocation or lock failed so bail out
            GlobalFree (hBuffer);
            hResReturn = E_OUTOFMEMORY;
        }
        if ( SUCCEEDED ( hResReturn ) ) {
            lstrcpy ( pszGlobalBuffer, pszBuffer );
        }
        delete pszBuffer;
        GlobalUnlock (hBuffer);
    }

    if ( NULL != hBuffer ) {
        // then there's something to copy so...
        // get the clipboard
        if (OpenClipboard (m_hWnd)) {
            // copy the counter list to the clipboard
            if (EmptyClipboard()) {
                hMemClipboard = SetClipboardData (
#if UNICODE
                    CF_UNICODETEXT,     // UNICODE text in the clipboard
#else
                    CF_TEXT,            // ANSI text in the clipboard
#endif
                    hBuffer);
                if (hMemClipboard == NULL) {
                    //free memory since it didn't make it to the clipboard
                    GlobalFree (hBuffer);
                    // unable to set data in the clipboard
                    hResReturn = HRESULT_FROM_WIN32(GetLastError());
                }

            } else {
                //free memory since it didn't make it to the clipboard
                GlobalFree (hBuffer);
                // unable to empty the clipboard
                hResReturn = HRESULT_FROM_WIN32(GetLastError());
            }

            // release the clipboard
            CloseClipboard();
        } else {
            //free memory since it didn't make it to the clipboard
            GlobalFree (hBuffer);
            // unable to open the clipboard
            hResReturn = HRESULT_FROM_WIN32(GetLastError());
        }
    } 

    return hResReturn;
}

HRESULT CSysmonControl::Reset()
{
    PCGraphItem pItem; 
 
    // Request each counter from the control, to compute 
    // required buffer size

    while ((pItem = FirstCounter())!= NULL) {
        // delete this counter 
        DeleteCounter (pItem, TRUE);
    }

    m_iColorIndex = 0;
    m_iWidthIndex = 0;
    m_iStyleIndex = 0;

    return NOERROR;
}

void CSysmonControl::DblClickCounter(PCGraphItem pItem)
{
    INT iIndex;

    // Send event
    iIndex = (pItem == NULL) ? 0 : CounterIndex(pItem);
    m_pObj->SendEvent(eEventOnDblClick, iIndex);

}

BOOL 
CSysmonControl::ConfirmSampleDataOverwrite ( )
{
    BOOL bOverwrite = TRUE;

    if ( m_bSampleDataLoaded ) {
        // Confirm overwrite of view-only data.
        INT iOverwrite = IDNO;
        assert ( FALSE == m_fInitialized );

        iOverwrite = MessageBox(
                            Window(), 
                            ResourceString(IDS_SAMPLE_DATA_OVERWRITE), 
                            ResourceString(IDS_APP_NAME),
                            MB_YESNO );

        if ( IDYES == iOverwrite ) {
            m_bSampleDataLoaded = FALSE;
            bOverwrite = Init ( g_hWndFoster );
            UpdateGraph(UPDGRPH_LAYOUT);        // If toolbar enabled, must resize
                                                // Also clears the graph
        } else {
            bOverwrite = FALSE;
        }
    }    
    return bOverwrite;
}

void 
CSysmonControl::Clear ( void )
{
    if ( ConfirmSampleDataOverwrite() ) {
        PCGraphItem  pItem;

        m_pHistCtrl->nMaxSamples = MAX_GRAPH_SAMPLES;
        m_pHistCtrl->iCurrent = 0;
        m_pHistCtrl->nSamples = 0;
        m_pHistCtrl->nBacklog = 0;
        m_pObj->m_Graph.TimeStepper.Reset();

        m_pStatsBar->Clear();

        // Reset history for all counters
        for (pItem = FirstCounter(); pItem != NULL; pItem = pItem->Next()) {
                pItem->ClearHistory();
        }

        // Repaint the graph and value bar
        UpdateGraph(UPDGRPH_VIEW);
    }
}

PDH_STATUS 
CSysmonControl::UpdateCounterValues ( BOOL fValidSample )
{
    PDH_STATUS  stat = ERROR_SUCCESS;
    PCGraphItem  pItem;
    PGRAPHDATA  pGraph = &m_pObj->m_Graph;

    // If no query or no counters assign, nothing to do
    if ( NULL == m_hQuery
            || pGraph->CounterTree.NumCounters() == 0
            || !IsUserMode() ) {
        stat = ERROR_SUCCESS;
    } else {
        if ( ConfirmSampleDataOverwrite () ) {
            // If valid sample, collect the data
            if (fValidSample) {
                UpdateAppPerfTimeData (TD_P_QUERY_TIME, TD_BEGIN);
                stat = PdhCollectQueryData(m_hQuery);
                UpdateAppPerfTimeData (TD_P_QUERY_TIME, TD_END);
            }

            if ( ERROR_SUCCESS == stat ) { 

                UpdateAppPerfTimeData (TD_S_QUERY_TIME, TD_BEGIN);
    
                LockCounterData();

                // Update history control and all counter history arrays
                m_pHistCtrl->iCurrent++;

                if (m_pHistCtrl->iCurrent == m_pHistCtrl->nMaxSamples)
                    m_pHistCtrl->iCurrent = 0;

                if (m_pHistCtrl->nSamples < m_pHistCtrl->nMaxSamples)
                    m_pHistCtrl->nSamples++;
      
                // Update history for all counters
                for (pItem = FirstCounter(); pItem != NULL; pItem = pItem->Next()) {
                        pItem->UpdateHistory(fValidSample);
                }

                // If we're initialized and have at least two samples
                if (m_fInitialized && m_pHistCtrl->nSamples >= 2) {

                    // If no backlogged updates, post an update message
                    if (m_pHistCtrl->nBacklog == 0) {
                        PostMessage(m_hWnd, WM_GRAPH_UPDATE, 0, 0);
                    }

                    m_pHistCtrl->nBacklog++;
                }

                UnlockCounterData();

                // If event sync present, send notification outside of lock.
                m_pObj->SendEvent(eEventOnSampleCollected, 0);
    
                UpdateAppPerfTimeData (TD_S_QUERY_TIME, TD_END);
            }
        }
    }
    return ERROR_SUCCESS;
}

void CSysmonControl::Activate( VOID )
{
    if (!m_fUIDead) { 
        m_pObj->UIActivate();
    }
}

void CSysmonControl::put_Appearance(INT iAppearance, BOOL fAmbient)
{
    INT iLocalAppearance;

    if (fAmbient && m_pObj->m_Graph.Options.iAppearance != NULL_APPEARANCE)
        return;
    
    if (!fAmbient) {
        m_pObj->m_Graph.Options.iAppearance = iAppearance;
    }

    // Any non-zero value translates to 3D.  In ambient case, the high bits are sometimes set.

    if ( iAppearance ) {
        iLocalAppearance = eAppear3D;
    } else {
        iLocalAppearance = eAppearFlat;
    }

    m_iAppearance = iLocalAppearance;
    UpdateGraph(UPDGRPH_COLOR);
}

void CSysmonControl::put_BorderStyle(INT iBorderStyle, BOOL fAmbient)
{
    if (fAmbient && m_pObj->m_Graph.Options.iBorderStyle != NULL_BORDERSTYLE)
        return;
    
    if (!fAmbient) {
        m_pObj->m_Graph.Options.iBorderStyle = iBorderStyle;
    }

    m_iBorderStyle = iBorderStyle;
    
    UpdateGraph(UPDGRPH_COLOR);
}

void CSysmonControl::put_BackCtlColor(OLE_COLOR Color)
{
    m_pObj->m_Graph.Options.clrBackCtl = Color;

    OleTranslateColor(Color, NULL, &m_clrBackCtl);  
    UpdateGraph(UPDGRPH_COLOR);
}


void CSysmonControl::put_FgndColor (
    OLE_COLOR Color, 
    BOOL fAmbient
    )
{
    if (fAmbient && m_pObj->m_Graph.Options.clrFore != NULL_COLOR)
        return;
    
    if (!fAmbient)
         m_pObj->m_Graph.Options.clrFore = Color;

    OleTranslateColor(Color, NULL, &m_clrFgnd);  
    UpdateGraph(UPDGRPH_COLOR);
}

void CSysmonControl::put_BackPlotColor (
    OLE_COLOR Color, 
    BOOL fAmbient
    )
{
    if (fAmbient && m_pObj->m_Graph.Options.clrBackPlot != NULL_COLOR)
        return;
    
    if (!fAmbient)
         m_pObj->m_Graph.Options.clrBackPlot = Color;

    OleTranslateColor(Color, NULL, &m_clrBackPlot); 
    UpdateGraph(UPDGRPH_PLOT);
}

void CSysmonControl::put_GridColor (
    OLE_COLOR Color
    )
{
    // Options color is the OLE_COLOR.
    // Color in control is translated from OLE_COLOR.
    m_pObj->m_Graph.Options.clrGrid = Color;

    OleTranslateColor(Color, NULL, &m_clrGrid); 
    UpdateGraph(UPDGRPH_PLOT);
}

void CSysmonControl::put_TimeBarColor (
    OLE_COLOR Color
    )
{
    // Options color is the OLE_COLOR.
    // Color in control is translated from OLE_COLOR.
    m_pObj->m_Graph.Options.clrTimeBar = Color;

    OleTranslateColor(Color, NULL, &m_clrTimeBar); 
    UpdateGraph(UPDGRPH_PLOT);
}

HRESULT CSysmonControl::put_Font (
    LPFONT pIFont,
    BOOL fAmbient
    )
{
    HRESULT hr = NOERROR;
    if ( NULL == pIFont ) {
        hr = E_INVALIDARG;
    } else {
        if ( fAmbient && FALSE == m_pObj->m_Graph.Options.bAmbientFont ) {
            hr =  NOERROR;
        } else {
            if (!fAmbient) {
                m_pObj->m_Graph.Options.bAmbientFont = FALSE;
            }
            hr =  m_OleFont.SetIFont(pIFont);
        }
    }

    return hr;
}


void CSysmonControl::FontChanged(
    void
    )
{
    m_pReport->ChangeFont();
    UpdateGraph(UPDGRPH_FONT);
}

void 
CSysmonControl::SetMissedSample ( void ) 
{ 
    if ( !m_bLoadingCounters ) {
        m_bMissedSample = TRUE; 
    }
};

DWORD WINAPI
CollectProc (
    IN  PSYSMONCTRL pCtrl
    )
{

    DWORD       dwElapsedTime;
    DWORD       dwTimeout = INFINITE;
    COLLECT_PROC_INFO   *pCollectInfo = &pCtrl->m_CollectInfo;

    while (TRUE) {

        // Wait for event or next sample period
        WaitForSingleObject(pCollectInfo->hEvent, dwTimeout);

        // If quit request, exit loop
        if (pCollectInfo->iMode == COLLECT_QUIT)
            break;

        // If suspended, wait for an event
        if (pCollectInfo->iMode == COLLECT_SUSPEND) {
            dwTimeout = INFINITE;
            continue;
        }

        // Take a sample
        pCtrl->UpdateCounterValues(TRUE);

        // Get elapsed time from last sample time
        dwElapsedTime = GetTickCount() - pCollectInfo->dwSampleTime;
        if (dwElapsedTime > 100000)
            dwElapsedTime = 0;

        // Have we missed any sample times? 
        while (dwElapsedTime > pCollectInfo->dwInterval) {

            // By how much?
            dwElapsedTime -= pCollectInfo->dwInterval;

            // If less than 1/2 an interval, take the sample now
            // otherwise record a missed one
            if (dwElapsedTime < pCollectInfo->dwInterval/2) {
                pCtrl->UpdateCounterValues(TRUE);
            } else {
                pCtrl->SetMissedSample();
                pCtrl->UpdateCounterValues(FALSE);
            }

            // Advance to next sample time 
            pCollectInfo->dwSampleTime += pCollectInfo->dwInterval;
        }

        // Set timeout to wait until next sample time 
        dwTimeout = pCollectInfo->dwInterval - dwElapsedTime;
        pCollectInfo->dwSampleTime += pCollectInfo->dwInterval;
    }

    return 0;
}

HRESULT
CSysmonControl::InitLogFileIntervals ( void )
{
    HRESULT hr = S_OK;
    PDH_STATUS  pdhstat;
    DWORD   nLogEntries = 0;
    DWORD   nBufSize;
    PDH_TIME_INFO   TimeInfo;

    if ( m_bLogFileSource ) {

        // Get time and sample count info
        nBufSize = sizeof(TimeInfo);
        pdhstat = PdhGetDataSourceTimeRangeH(GetDataSourceHandle(),
                                             & nLogEntries,
                                             & TimeInfo,
                                             & nBufSize );
        if ( ERROR_SUCCESS != pdhstat ) {
            if ( ERROR_NOT_ENOUGH_MEMORY == pdhstat ) {
                pdhstat = SMON_STATUS_LOG_FILE_SIZE_LIMIT;
            }
            hr = (HRESULT)pdhstat;
        } else if ( 2 > TimeInfo.SampleCount ) {
            hr = (HRESULT)SMON_STATUS_TOO_FEW_SAMPLES;
            m_DataSourceInfo.llInterval = 1;
        } else {
            // Setup time range info
            m_DataSourceInfo.llBeginTime = TimeInfo.StartTime;
            m_DataSourceInfo.llEndTime = TimeInfo.EndTime;

            // The start or stop time might no longer be valid, so check for
            // relationship between the them as well as for start/begin, stop/end.
            if ( (m_DataSourceInfo.llStartDisp < m_DataSourceInfo.llBeginTime)
                    || (m_DataSourceInfo.llStartDisp > m_DataSourceInfo.llEndTime) )
                m_DataSourceInfo.llStartDisp = m_DataSourceInfo.llBeginTime;

            if ( (m_DataSourceInfo.llStopDisp > m_DataSourceInfo.llEndTime)
                    || (m_DataSourceInfo.llStopDisp < m_DataSourceInfo.llStartDisp) )
                m_DataSourceInfo.llStopDisp = m_DataSourceInfo.llEndTime;

            m_DataSourceInfo.nSamples = TimeInfo.SampleCount;

            m_DataSourceInfo.llInterval = (m_DataSourceInfo.llEndTime - m_DataSourceInfo.llBeginTime + m_DataSourceInfo.nSamples/2) / (m_DataSourceInfo.nSamples - 1);

            UpdateGraph(UPDGRPH_LOGVIEW);
        }
    } else {
        assert ( FALSE );
        hr = E_FAIL;
    }
    return hr;
}

HRESULT 
CSysmonControl::AddSingleLogFile(
    LPCTSTR         pszPath, 
    CLogFileItem**  ppLogFile )
{
    HRESULT         hr = NOERROR;
    CLogFileItem*   pLogFile = NULL;
    CLogFileItem*   pLocalLogFileItem = NULL;

    if ( NULL != pszPath ) {

        if ( NULL != ppLogFile ) {
            *ppLogFile = NULL;
        }

        // Check to ensure that current data source is NOT log files.
        if ( sysmonLogFiles == m_pObj->m_Graph.Options.iDataSourceType ) {
            hr = SMON_STATUS_LOG_FILE_DATA_SOURCE;
        } else {
            // Check for duplicate log file name.
            pLogFile = FirstLogFile();
            while ( NULL != pLogFile ) {
                if ( 0 == lstrcmpi ( pszPath, pLogFile->GetPath() ) ) {
                    hr = SMON_STATUS_DUPL_LOG_FILE_PATH;
                    break;
                }
                pLogFile = pLogFile->Next();
            }

            if (SUCCEEDED(hr)) {
                // Create log file item
                pLocalLogFileItem = new CLogFileItem ( this ); 
                if ( NULL == pLocalLogFileItem ) {  
                    hr = E_OUTOFMEMORY;
                } else {
                    hr = pLocalLogFileItem->Initialize ( pszPath, &m_DataSourceInfo.pFirstLogFile );
                }
                // TodoLogFiles: ??? Test log file type?  Or leave that up to the "SetDataSource" time?
                // TodoLogFiles: Add log file type to the data source info structure

                // TodoLogFiles:  If allow the user to add files while data source set to log files,
                // then check that condition here.  If log file data source, then resample with
                // new log file.

                // If OK, Addref the returned interface
                if (SUCCEEDED(hr)) {
                    // AddRef once for ourselves
                    pLocalLogFileItem->AddRef();
                    m_DataSourceInfo.lLogFileCount++;
                    if ( NULL != ppLogFile ) {
                        // AddRef the returned interface
                        pLocalLogFileItem->AddRef();
                        *ppLogFile = pLocalLogFileItem;   
                    }
                }
                else {
                    if (pLocalLogFileItem != NULL) {
                        delete pLocalLogFileItem;
                        pLocalLogFileItem = NULL;
                    }
                }
            }
        }
    } else {
        hr = E_INVALIDARG; 
    }
    return hr;
}

HRESULT 
CSysmonControl::RemoveSingleLogFile (
    CLogFileItem*  pLogFile )
{
    HRESULT         hr = ERROR_SUCCESS;
    CLogFileItem*   pNext;
    CLogFileItem*   pPrevious;
    
    // Check to ensure that current data source is NOT log files.
    if ( sysmonLogFiles == m_pObj->m_Graph.Options.iDataSourceType ) {
        hr = SMON_STATUS_LOG_FILE_DATA_SOURCE;
    } else {
        pNext = FirstLogFile();

        if ( pNext == pLogFile ) {
            m_DataSourceInfo.pFirstLogFile = pNext->Next();
        } else {
            do {
                pPrevious = pNext;
                pNext = pNext->Next();
                if ( pNext == pLogFile ) {
                    break;
                }
            } while ( NULL != pNext );

            if ( NULL != pNext ) {
                pPrevious->SetNext ( pNext->Next() );
            } else {
                // Something is wrong with the list.
                assert ( FALSE );
                hr = E_FAIL;
            }
        }
    
        m_DataSourceInfo.lLogFileCount--;

        pLogFile->Release();
    }
    return hr;
}
    
HRESULT 
CSysmonControl::ProcessDataSourceType ( 
    LPCTSTR szDataSourceName,
    INT iDataSourceType )
{
    HRESULT     hr = NOERROR;
    HQUERY      hTestQuery = NULL;
    PDH_STATUS  pdhStatus = ERROR_SUCCESS;
    HLOG        hTestLog   = H_REALTIME_DATASOURCE;

    if ( sysmonNullDataSource != iDataSourceType ) {
        // Open the new query

        if (iDataSourceType == sysmonLogFiles ||
            iDataSourceType == sysmonSqlLog) {
            pdhStatus = PdhBindInputDataSource(& hTestLog, szDataSourceName);
        }
        else if (iDataSourceType == sysmonCurrentActivity) {
            m_DataSourceInfo.hDataSource = H_REALTIME_DATASOURCE;
        }
        else {
            pdhStatus = PDH_INVALID_HANDLE;
        }
        if (pdhStatus == ERROR_SUCCESS) {
            pdhStatus = PdhOpenQueryH (hTestLog, 1, & hTestQuery );
        }
    }

    if ( ERROR_SUCCESS != pdhStatus ) {
        if ( ERROR_NOT_ENOUGH_MEMORY == pdhStatus ) {
            hr = (HRESULT)SMON_STATUS_LOG_FILE_SIZE_LIMIT;        
        } else {
            hr = (HRESULT)pdhStatus;
        }
    } else {
        // Close the current query
        CloseQuery();

        // At this point, the previous query no longer exists.  
        // If any problems with the new query, close it and
        // reset the data source to realtime.

        // Set the data source type
        // The previous log file name is deleted in CloseQuery()

        // For sysmonNullDataSource, the current query is closed, 
        // and the query handle is set to NULL.
    
        m_pObj->m_Graph.Options.iDataSourceType = iDataSourceType;
    
        // TodoLogFiles:  Eliminate use of m_bLogFileSource,
        // using m_pObj->m_Graph.Options.iDataSourceType instead.
        m_bLogFileSource = (   sysmonLogFiles == iDataSourceType
                            || sysmonSqlLog   == iDataSourceType); 

        m_hQuery                     = hTestQuery;
        m_DataSourceInfo.hDataSource = hTestLog;

        if ( m_bLogFileSource ) {
            hr = InitLogFileIntervals();
        }

        if ( SUCCEEDED ( hr ) && sysmonNullDataSource != iDataSourceType ) {
            // Initialize the new query.  For log files, this can be done after 
            // InitLogFileIntervals because the methods operate on different fields.
            if ( ERROR_SUCCESS != InitializeQuery() ) {
                hr =  E_FAIL;
            } else {
                if ( m_fInitialized ) {
                    if ( ERROR_SUCCESS != ActivateQuery() ) 
                        hr = E_FAIL;              
                }
            }

            if ( SUCCEEDED ( hr ) && !m_bLogFileSource ) {
                // If note log file data source, pass new time span to statistics bar.
                m_pStatsBar->SetTimeSpan (
                                m_pObj->m_Graph.Options.fUpdateInterval 
                                * m_pObj->m_Graph.Options.iDisplayFilter
                                * m_pHistCtrl->nMaxSamples);
            }
        }
    }

    if ( FAILED ( hr ) ) {

        if ( sysmonLogFiles == iDataSourceType
            || sysmonSqlLog   == iDataSourceType ) 
        {
            // If failed with log file query, retry with realtime query.
            assert ( m_bLogFileSource );
            // Status returned is for the original query, not the realtime query.
            // TodoLogFiles:  Need to activate query?
            put_DataSourceType ( sysmonCurrentActivity );
        } else {
            // This leaves the control in an odd state with no active query.
            // TodoLogFiles:  At least message to user
            CloseQuery();
            put_DataSourceType ( sysmonNullDataSource );
        }
    }
    return hr;
}

HRESULT 
CSysmonControl::get_DataSourceType ( 
    eDataSourceTypeConstant& reDataSourceType )
{
    HRESULT         hr = NOERROR;

    reDataSourceType = (eDataSourceTypeConstant)m_pObj->m_Graph.Options.iDataSourceType;

    return hr;
}

HRESULT 
CSysmonControl::put_DataSourceType ( 
    INT iDataSourceType )
{
    HRESULT hr             = NOERROR;
    DWORD   dwStatus = ERROR_SUCCESS;
    LPTSTR  szDataSourceName = NULL;

    // TodoLogFiles:  Implement multi-file.
    // TodoLogFiles:  Use single data source name?
    //
    if (sysmonLogFiles == iDataSourceType) {
        CLogFileItem * pLogFile        = FirstLogFile();
        ULONG          ulListLen = 0;
        
        if (pLogFile == NULL) {
            hr = E_INVALIDARG;
        }
        else {
            dwStatus = BuildLogFileList ( 
                        NULL,
                        FALSE,
                        &ulListLen );
            szDataSourceName =  (LPWSTR) malloc(ulListLen * sizeof(WCHAR));
            if ( NULL != szDataSourceName ) {
                dwStatus = BuildLogFileList ( 
                            szDataSourceName,
                            FALSE,
                            &ulListLen );
            } else {
                hr = E_OUTOFMEMORY;
            }
            
        }
    }
    else if (sysmonSqlLog == iDataSourceType) {
        if ( m_DataSourceInfo.szSqlDsnName && m_DataSourceInfo.szSqlLogSetName ) {
            if ( m_DataSourceInfo.szSqlDsnName[0] != _T('\0') && m_DataSourceInfo.szSqlLogSetName[0] != _T('\0')) {

                ULONG ulLogFileNameLen = 0;

                DWORD dwStatus = FormatSqlDataSourceName ( 
                                    m_DataSourceInfo.szSqlDsnName,
                                    m_DataSourceInfo.szSqlLogSetName,
                                    NULL,
                                    &ulLogFileNameLen );

                if ( ERROR_SUCCESS == dwStatus ) {
                    szDataSourceName = (LPWSTR) malloc(ulLogFileNameLen * sizeof(WCHAR));
                    if (szDataSourceName == NULL) {
                        hr = E_OUTOFMEMORY;
                    } else {
                        dwStatus = FormatSqlDataSourceName ( 
                                    m_DataSourceInfo.szSqlDsnName,
                                    m_DataSourceInfo.szSqlLogSetName,
                                    szDataSourceName,
                                    &ulLogFileNameLen );
                    }
                }
            }
        }
        else {
            hr = E_INVALIDARG;
        }
    }

    if (SUCCEEDED(hr)) {
        hr = ProcessDataSourceType((LPCTSTR) szDataSourceName, iDataSourceType);
    }
    if (szDataSourceName) {
        free(szDataSourceName);
    }

    return hr;
}

void 
CSysmonControl::IncrementVisuals (
    void
    )
{
    // Increment the visual indices in color, width, style order
    if (++m_iColorIndex >= NumStandardColorIndices()) {
        m_iColorIndex = 0;

        if (++m_iWidthIndex >= NumWidthIndices()) {
            m_iWidthIndex = 0;

            if (++m_iStyleIndex < NumStyleIndices()) {
                m_iStyleIndex = 0;
            }
        }
    }
}


void
CSysmonControl::SampleLogFile (
    BOOL bViewChange
    )
{
    typedef struct {
        PCGraphItem pItem;
        double  dMin;
        double  dMax;
        double  dAvg;
        INT     nAvgCnt;
        PDH_RAW_COUNTER rawValue[1];
    } LogWorkBuf, *PLogWorkBuf;

    INT nCounters;
    INT nLogSamples;
    INT nDispSamples;
    INT iNonDisp;

    PCGraphItem pItem;

    #define LLTIME_TICS_PER_SECOND (10000000)

    // Todo:  If query is null, call put_LogFileName to create it?
    // Todo:  Error message if m_hQuery is (still) null.
    if ( NULL != m_hQuery ) {
    
        // Determine number of counters to update
        nCounters = 0;

        // If log view change, we have to update all counters
        if (bViewChange) {
            for (pItem = FirstCounter(); pItem; pItem = pItem->Next()) {
                pItem->m_bUpdateLog = TRUE;
                nCounters++;
            }
        }
        // otherwise, just any new counters
        else {
            for (pItem = FirstCounter(); pItem; pItem = pItem->Next()) {
                if (pItem->m_bUpdateLog)
                    nCounters++;
            }
        }

        // If none, nothing to do
        if ( nCounters > 0) {

            // Number of log samples in displayed interval
            // Add 1 extra at the beginning.  PdhSetQueryTimeRange returns one sample
            // before the specified start time, if it exists.
            // Add extra 1 because ?
            if (m_DataSourceInfo.nSamples > 1) {
                assert ( 0 != m_DataSourceInfo.llInterval );
                nLogSamples = (INT)((m_DataSourceInfo.llStopDisp - m_DataSourceInfo.llStartDisp) / m_DataSourceInfo.llInterval) + 2;
            } else {
                nLogSamples = m_DataSourceInfo.nSamples;
            }

            // Number of display samples
            nDispSamples = min(nLogSamples, m_pHistCtrl->nMaxSamples);

            // Setup history control
            m_pHistCtrl->nSamples = nDispSamples;
            m_pHistCtrl->iCurrent = 0;
            m_pHistCtrl->nBacklog = 0;

            if ( nDispSamples > 1 ) {
                INT         nCompSamples;
                INT         iSampleDiff;
                INT         nPasses;
                INT         iComp;
                INT         iCtr;
                INT         iDisp;

                PLogWorkBuf pWorkBuffers;
                PLogWorkBuf pWorkBuf;
                INT         nWorkBufSize;
    
                PDH_TIME_INFO   TimeInfo;
                PDH_STATISTICS  Statistics;
                DWORD           dwCtrType;
                PDH_STATUS      stat;

                // Number of log samples to compress to one display values
                // Add an extra 1 for rate counters becuase it takes 2 raw sample to get one formatted value.
                // The first sample of each buffer is ignored for non-rate counters.
                nCompSamples = (nLogSamples / nDispSamples) + 1;

                // Length of one work buffer
                // Note that LogWorkBuf includes the first raw value so there are really nCompSamples + 1 
                // (an extra 1 is needed because some intervals will be one sample longer to make it
                // come out even at the end (e.g. 10 samples div into 3 intervals = (3, 4, 3))
                nWorkBufSize = sizeof(LogWorkBuf) + nCompSamples * sizeof(PDH_RAW_COUNTER);

                // Allocate work buffers of nCompSamples samples for each counter
                pWorkBuffers = (PLogWorkBuf)malloc( nCounters * nWorkBufSize);
                if (pWorkBuffers == NULL)
                    return;

                // Place selected counter item pointers in work buffers
                // and init statistics
                pWorkBuf = pWorkBuffers;
                for (pItem = FirstCounter(); pItem; pItem = pItem->Next()) {

                    if (pItem->m_bUpdateLog) {
                        pWorkBuf->pItem = pItem;
                        pWorkBuf->dMin = (double)10e8;
                        pWorkBuf->dMax = (double)-10e8;
                        pWorkBuf->dAvg = 0.0;
                        pWorkBuf->nAvgCnt = 0;
                        pWorkBuf = (PLogWorkBuf)((CHAR*)pWorkBuf + nWorkBufSize);
                    }
                }

                // Set time range for pdh
                TimeInfo.StartTime = m_DataSourceInfo.llStartDisp;
                TimeInfo.EndTime = m_DataSourceInfo.llStopDisp;
                PdhSetQueryTimeRange(m_hQuery, &TimeInfo);

                iSampleDiff = nLogSamples;

                for (iDisp = 0; iDisp<nDispSamples; iDisp++) {
        
                    // Do the differential calc to see if it's time for an extra sample
                    if ((iSampleDiff -= nDispSamples) <= 0) {
                        iSampleDiff += nLogSamples;
                        nPasses = nCompSamples;
                    }
                    else {
                        nPasses = nCompSamples + 1;
                    }

                    // Fill the work buffers with a set of samples
                    // Set bad status for sample zero first time through.
                    // Sample zero is only used for rate counters.
                    // Other passes will reuse last sample of previous pass.

                    iComp = 0;

                    if ( 0 == iDisp ) {
                        // Special handling for the first sample.
                        // Set bad status for each 
                        pWorkBuf = pWorkBuffers;
                        for (iCtr=0; iCtr < nCounters; iCtr++) {
                            pWorkBuf->rawValue[0].CStatus = PDH_CSTATUS_INVALID_DATA;
                            pWorkBuf = (PLogWorkBuf)((CHAR*)pWorkBuf + nWorkBufSize);
                        }
                        // If iDisp == 0, Query the data and check the timestamp for the first raw data value.
                        // If that timestamp is before the official Start time, store it in buffer 0 
                        // Otherwise, put that data in buffer 1 and skip the first sample collection of the
                        // regular loop below.

                        stat = PdhCollectQueryData(m_hQuery);
                        if (stat == 0) {

                            PDH_RAW_COUNTER rawSingleValue;
                            // Get a raw sample for each counter.  Check the timestamp of the first counter to 
                            // determine which buffer to use.
                            pWorkBuf = pWorkBuffers;
                            iCtr = 0;

                            PdhGetRawCounterValue(pWorkBuf->pItem->Handle(), &dwCtrType, &rawSingleValue);
                    
                            // Increment the buffer index to 1 if the time stamp is after Start time.
                            // Otherwise, write the data to buffer 0, which is only used to process rate counters.
                            if ( *((LONGLONG*)&rawSingleValue.TimeStamp) >= m_DataSourceInfo.llStartDisp ) {
                                iComp = 1;
                            }


                            pWorkBuf->rawValue[iComp] = rawSingleValue;
                
                            // Increment to the next counter, and continue normal processing for the first sample,
                            // using iComp buffer index.
                            iCtr++;
                            pWorkBuf = (PLogWorkBuf)((CHAR*)pWorkBuf + nWorkBufSize);
                            for ( ; iCtr < nCounters; iCtr++) {
                                PdhGetRawCounterValue(pWorkBuf->pItem->Handle(), &dwCtrType, &pWorkBuf->rawValue[iComp]);

                                pWorkBuf = (PLogWorkBuf)((CHAR*)pWorkBuf + nWorkBufSize);
                            }
                        } // else bad status already set in 0 buffer for each counter.        
                    }        

                    // Only rate counter values use work buffer 0
                    // Buffer 0 is set to value from previous sample, except when iDisp 0, in which case it might have
                    // been filled in the (if 0 == iDisp) clause above.

                    // Skip past any special handling for the first iDisp pass above.  If buffer 1 is not filled by that 
                    // special handling, then iComp is set to 1.
                    iComp++;

                    for ( ; iComp < nPasses; iComp++) {
                        stat = PdhCollectQueryData(m_hQuery);
                        if (stat == 0) {
                            // Get a raw sample for each counter
                            pWorkBuf = pWorkBuffers;

                            for (iCtr = 0; iCtr < nCounters; iCtr++) {
                                PdhGetRawCounterValue(pWorkBuf->pItem->Handle(), &dwCtrType, &pWorkBuf->rawValue[iComp]);
                                pWorkBuf = (PLogWorkBuf)((CHAR*)pWorkBuf + nWorkBufSize);
                            }
                        }
                        else {
                            // Set bad status for each 
                            pWorkBuf = pWorkBuffers;
                            for (iCtr=0; iCtr < nCounters; iCtr++) {
                                pWorkBuf->rawValue[iComp].CStatus = PDH_CSTATUS_INVALID_DATA;
                                pWorkBuf = (PLogWorkBuf)((CHAR*)pWorkBuf + nWorkBufSize);
                            }
                        }
                    }

                    // generate one display sample by averaging each compression buffer
                    pWorkBuf = pWorkBuffers;
                    for (iCtr=0; iCtr < nCounters; iCtr++) {
                        INT iPassesThisCounter;
                        INT iWorkBufIndex;

                        if ( pWorkBuf->pItem->IsRateCounter() ) {
                            iPassesThisCounter = nPasses;
                            iWorkBufIndex = 0;
                        } else {
                            // Non-rate counters do not use the first sample buffer.
                            iPassesThisCounter = nPasses - 1;
                            iWorkBufIndex = 1;
                        }

                        stat = PdhComputeCounterStatistics (pWorkBuf->pItem->Handle(), PDH_FMT_DOUBLE | PDH_FMT_NOCAP100,
                                            0, iPassesThisCounter, &pWorkBuf->rawValue[iWorkBufIndex], &Statistics );

                        if (stat == 0 && Statistics.mean.CStatus == PDH_CSTATUS_VALID_DATA) {
                            LONGLONG llTruncatedTimeStamp;
                            LONGLONG llTmpTimeStamp;
                            pWorkBuf->pItem->SetLogEntry(iDisp, Statistics.min.doubleValue,
                                                          Statistics.max.doubleValue,
                                                          Statistics.mean.doubleValue);
                
                            // Use the final sample timestamp.  It is valid for both rates and numbers.

                            llTmpTimeStamp = MAKELONGLONG(
                                pWorkBuf->rawValue[nPasses - 1].TimeStamp.dwLowDateTime,
                                pWorkBuf->rawValue[nPasses - 1].TimeStamp.dwHighDateTime);
                            TruncateLLTime(llTmpTimeStamp, & llTruncatedTimeStamp);
                            pWorkBuf->pItem->SetLogEntryTimeStamp ( iDisp, *((FILETIME*)&llTruncatedTimeStamp) );

                            if (Statistics.max.doubleValue > pWorkBuf->dMax)
                                pWorkBuf->dMax = Statistics.max.doubleValue;

                            if (Statistics.min.doubleValue < pWorkBuf->dMin)
                                pWorkBuf->dMin = Statistics.min.doubleValue;

                            pWorkBuf->dAvg += Statistics.mean.doubleValue;
                            pWorkBuf->nAvgCnt++;
                        }
                        else {
                            pWorkBuf->pItem->SetLogEntry(iDisp, -1.0, -1.0, -1.0);
                        }

                        pWorkBuf = (PLogWorkBuf)((CHAR*)pWorkBuf + nWorkBufSize);
                    }

                    // If a rate counter, move last sample to first sample 
                    // for next compress interval
                    pWorkBuf = pWorkBuffers;
                    for (iCtr=0; iCtr < nCounters; iCtr++) {
                        if ( pWorkBuf->pItem->IsRateCounter() ) {
                            pWorkBuf->rawValue[0] = pWorkBuf->rawValue[nPasses-1];
                        }
                        pWorkBuf = (PLogWorkBuf)((CHAR*)pWorkBuf + nWorkBufSize);
                    }
                }

                // Set the log statistics for empty samples.
                for (iNonDisp = nDispSamples; iNonDisp<m_pHistCtrl->nMaxSamples; iNonDisp++) {
                    pWorkBuf = pWorkBuffers;
                    for (iCtr=0; iCtr < nCounters; iCtr++) {
                        pWorkBuf->pItem->SetLogEntry(iNonDisp, -1.0, -1.0, -1.0);
                        pWorkBuf = (PLogWorkBuf)((CHAR*)pWorkBuf + nWorkBufSize);
                    }
                }

                // Store the final statistics and clear the update flags
                pWorkBuf = pWorkBuffers;
                for (iCtr=0; iCtr < nCounters; iCtr++) {

                    pWorkBuf->pItem->m_bUpdateLog = FALSE;

                    if (pWorkBuf->nAvgCnt)
                        pWorkBuf->dAvg /= pWorkBuf->nAvgCnt;
                    pWorkBuf->pItem->SetLogStats(pWorkBuf->dMin, pWorkBuf->dMax, pWorkBuf->dAvg);

                    pWorkBuf = (PLogWorkBuf)((CHAR*)pWorkBuf + nWorkBufSize);
                }
    
                // Free the work buffers
                free(pWorkBuffers);
            } else {
                // No data to display. Clear the history buffers by setting all status to Invalid.
                for (pItem = FirstCounter(); pItem; pItem = pItem->Next()) {
                    for (iNonDisp = 0; iNonDisp < m_pHistCtrl->nMaxSamples; iNonDisp++) {
                        pItem->SetLogEntry(iNonDisp, -1.0, -1.0, -1.0);
                    }
                }
            }
            // Update statistics bar
            m_pStatsBar->SetTimeSpan((double)(m_DataSourceInfo.llStopDisp - m_DataSourceInfo.llStartDisp) / LLTIME_TICS_PER_SECOND);
            m_pStatsBar->Update(NULL, m_pSelectedItem);
        }
    }
}

void
CSysmonControl::CalcZoomFactor ( void )
{
    RECT rectPos;
    RECT rectExtent;

    double dHeightPos;
    double dHeightExtent;
    // Calculate zoom factor based on height.
    // The Zoom calculation is prcPos (set by container) divided by the extent.
    // See technical note 40 - TN040.
    rectExtent = m_pObj->m_RectExt;
    GetClientRect ( m_hWnd, &rectPos );

    dHeightPos = rectPos.bottom - rectPos.top;
    dHeightExtent = rectExtent.bottom - rectExtent.top;
    m_dZoomFactor = ( dHeightPos ) / ( dHeightExtent );
}

BOOL
CSysmonControl::DisplayMissedSampleMessage ( void )
{
    BOOL bDisplay = FALSE;

    bDisplay = m_bMissedSample ;

    if ( bDisplay ) {
        // Missed at least one sample in this session.
        // Display the message only once per session.
        if ( m_bDisplayedMissedSampleMessage ) {
            bDisplay = FALSE;
        } else {
            m_bDisplayedMissedSampleMessage = TRUE;
        }
    }
    return bDisplay;
}

void
CSysmonControl::ResetLogViewTempTimeRange ()

/*++

Routine Description:

    Reset the log view temporary time range steppers to the ends of the visible 
    part of the log file. 

Arguments:


Return Value:


--*/

{
    assert ( IsLogSource() );

    if ( IsLogSource() ) {
        INT iNewStopStepNum = 0;
        m_pObj->m_Graph.LogViewStartStepper.Reset();
        m_pObj->m_Graph.LogViewStopStepper.Reset();

        if ( FirstCounter() ) {
            GetNewLogViewStepNum( m_DataSourceInfo.llStopDisp, iNewStopStepNum );
            m_pObj->m_Graph.LogViewStopStepper.StepTo( iNewStopStepNum );
        }
    }   
}

void
CSysmonControl::FindNextValidStepNum (
    BOOL        bDecrease,
    PCGraphItem pItem,
    LONGLONG    llNewTime,
    INT&        riNewStepNum,
    DWORD&      rdwStatus )
{
    DWORD       dwPdhStatus = ERROR_SUCCESS;
    DWORD       dwLocalStatus = ERROR_SUCCESS;
    LONGLONG    llNextTimeStamp = 0;
    INT         iLocalStepNum;
    INT         iTempLocalStepNum;

    assert ( NULL != pItem );

    if ( NULL != pItem ) {

        iLocalStepNum = riNewStepNum;
        iTempLocalStepNum = iLocalStepNum;
        dwLocalStatus = rdwStatus;

        if ( bDecrease ) {
            // Start by decreasing steps to find first valid step.
            while ( ( ERROR_SUCCESS == dwPdhStatus ) 
                    && ( ERROR_SUCCESS != dwLocalStatus )
                    && ( iLocalStepNum > 0 ) ) {
                iTempLocalStepNum = iLocalStepNum;
                iTempLocalStepNum--;
                dwPdhStatus = pItem->GetLogEntryTimeStamp( iTempLocalStepNum, llNextTimeStamp, &dwLocalStatus );
                iLocalStepNum = iTempLocalStepNum;
            }
            // Subtract 1 from nSamples because stepper is 0-based, 
            while ( ( ERROR_SUCCESS == dwPdhStatus ) 
                    && ( ERROR_SUCCESS != dwLocalStatus )
                    && ( iLocalStepNum < m_pHistCtrl->nSamples - 1 ) ) {
                iTempLocalStepNum++;
                dwPdhStatus = pItem->GetLogEntryTimeStamp( iTempLocalStepNum, llNextTimeStamp, &dwLocalStatus );
                iLocalStepNum = iTempLocalStepNum;
            }
    
        } else {
            // Start by increasing steps to find first valid step.

            // Subtract 1 from nSamples because stepper is 0-based, 
            while ( ( ERROR_SUCCESS == dwPdhStatus ) 
                    && ( ERROR_SUCCESS != dwLocalStatus )
                    && ( iLocalStepNum < m_pHistCtrl->nSamples - 1 ) ) {
                iTempLocalStepNum++;
                dwPdhStatus = pItem->GetLogEntryTimeStamp( iTempLocalStepNum, llNextTimeStamp, &dwLocalStatus );
                iLocalStepNum = iTempLocalStepNum;
            }
    
            while ( ( ERROR_SUCCESS == dwPdhStatus ) 
                    && ( ERROR_SUCCESS != dwLocalStatus )
                    && ( iLocalStepNum > 0 ) ) {
                iTempLocalStepNum = iLocalStepNum;
                iTempLocalStepNum--;
                dwPdhStatus = pItem->GetLogEntryTimeStamp( iTempLocalStepNum, llNextTimeStamp, &dwLocalStatus );
                iLocalStepNum = iTempLocalStepNum;
            }
        }
        if ( ERROR_SUCCESS == dwLocalStatus ) {
            riNewStepNum = iLocalStepNum;
            llNewTime = llNextTimeStamp;
            rdwStatus = dwLocalStatus;
        }
    }
    return;
}

void
CSysmonControl::GetNewLogViewStepNum (
    LONGLONG llNewTime,
    INT& riNewStepNum )

/*++

Routine Description:

    Given the new time and original stepnum, find the stepnum that matches
    the new time.

Arguments:

    llNewTime       New time stamp to match
    riNewStepNum    (IN) Current step num
                    (OUT) Step num that matches the new time stamp.

Return Value:


--*/

{
    PCGraphItem pItem = NULL;
    LONGLONG    llNextTimeStamp = 0;
    PDH_STATUS  dwPdhStatus = ERROR_SUCCESS;
    DWORD       dwStatus = ERROR_SUCCESS;
    INT         iLocalStepNum = 0;

    assert ( IsLogSource() );

    iLocalStepNum = riNewStepNum;

    // Check only the first counter for log file time stamp data.
    pItem = FirstCounter();

    if ( NULL != pItem ) {
        dwPdhStatus = pItem->GetLogEntryTimeStamp( iLocalStepNum, llNextTimeStamp, &dwStatus );

        // If the stepper is positioned on a sample with bad status,
        // move n steps in either direction to find a valid sample to start with.
        if ( ( ERROR_SUCCESS == dwPdhStatus ) && ( ERROR_SUCCESS != dwStatus ) ) {
            FindNextValidStepNum ( FALSE, pItem, llNextTimeStamp, iLocalStepNum, dwStatus );
        }

        if ( ERROR_SUCCESS == dwStatus ) {
            if ( ( llNewTime < llNextTimeStamp ) || ( MAX_TIME_VALUE == llNextTimeStamp ) ) {
                while ( iLocalStepNum > 0 ) {
                    iLocalStepNum--;
                    pItem->GetLogEntryTimeStamp( iLocalStepNum, llNextTimeStamp, &dwStatus );
                    if ( ERROR_SUCCESS == dwStatus ) {
                        if ( llNewTime == llNextTimeStamp ) {
                            break;
                        } else if ( llNewTime > llNextTimeStamp ) {
                            iLocalStepNum++;
                            break;
                        }
                    }
                }
            } else if ( llNewTime > llNextTimeStamp ) {
                // Subtract 1 from nSamples because stepper is 0-based, 
                while ( iLocalStepNum < m_pHistCtrl->nSamples - 1 ) {
                    iLocalStepNum++; 
                    pItem->GetLogEntryTimeStamp( iLocalStepNum, llNextTimeStamp, &dwStatus );
                    if ( ERROR_SUCCESS == dwStatus ) {
                        if ( llNewTime <= llNextTimeStamp ) {
                            break;
                        }                 
                    }
                }
            }
            riNewStepNum = iLocalStepNum;
        } // else if NO valid samples, leave the start/stop time stepper where it is.
    } // Non-null FirstCounter()

    return;
}

void
CSysmonControl::SetLogViewTempTimeRange (
    LONGLONG llStart,
    LONGLONG llStop
    )

/*++

Routine Description:

    Set the log view temporary time range. This routine provides the Source
    property page a way to give range to the control, so that the control
    can draw temporary timeline guides on the line graph.


Arguments:

    llStart     Temporary log view start time (FILETIME format)
    llEnd       Temporary log view end time (FILETIME format)

Return Value:


--*/

{
    assert ( llStart <= llStop );
    
    if ( IsLogSource() ) {
        INT         iNewStepNum;

        // No time range to modify if no counters selected.
        if ( NULL != FirstCounter() ) {
        
            // Start/Stop time range bars are turned off if llStart and llStop are set
            // to MIN and MAX values, so no need to update steppers.
            if ( MIN_TIME_VALUE != llStart ) {

                // Search through sample values to find the appropriate step for the start bar.
                if ( llStart != m_pObj->m_Graph.LogViewTempStart ) {

                    // Start with current position.
                    iNewStepNum = m_pObj->m_Graph.LogViewStartStepper.StepNum();

                    GetNewLogViewStepNum ( llStart, iNewStepNum );

                    if ( iNewStepNum != m_pObj->m_Graph.LogViewStartStepper.StepNum() ) {
                        m_pObj->m_Graph.LogViewStartStepper.StepTo ( iNewStepNum );
                    }
                }
            }
            if ( MAX_TIME_VALUE != llStop ) {

                // Search through sample values to find the appropriate step for the stop bar.
                if ( llStop != m_pObj->m_Graph.LogViewTempStop ) {

                    // Start with current position.
                    iNewStepNum = m_pObj->m_Graph.LogViewStopStepper.StepNum();

                    GetNewLogViewStepNum ( llStop, iNewStepNum );

                    if ( iNewStepNum != m_pObj->m_Graph.LogViewStopStepper.StepNum() ) {
                        m_pObj->m_Graph.LogViewStopStepper.StepTo ( iNewStepNum );
                    }                
                }
            }
        }
    }

    if ( ( m_pObj->m_Graph.LogViewTempStart != llStart )
        || ( m_pObj->m_Graph.LogViewTempStop != llStop ) ) {
    
        m_pObj->m_Graph.LogViewTempStart = llStart;
        m_pObj->m_Graph.LogViewTempStop = llStop;

        if ( sysmonLineGraph == m_pObj->m_Graph.Options.iDisplayType ) {
            // Cause redraw
            UpdateGraph(UPDGRPH_PLOT);
        }
    }
}

PRECT
CSysmonControl::GetNewClientRect ( void )
{
    return &m_pObj->m_RectExt;
}

PRECT
CSysmonControl::GetCurrentClientRect ( void )
{
    return &m_rectCurrentClient;
}

void
CSysmonControl::SetCurrentClientRect ( PRECT prectNew )
{
    m_rectCurrentClient = *prectNew;
}

void
CSysmonControl::UpdateNonAmbientSysColors ( void )
{
    HRESULT hr;
    COLORREF newColor;
    PGRAPH_OPTIONS pOptions = &m_pObj->m_Graph.Options;

    hr = OleTranslateColor(pOptions->clrBackCtl, NULL, &newColor);
    if ( SUCCEEDED( hr ) ) {
        m_clrBackCtl = newColor;
    }

    if (pOptions->clrBackPlot != NULL_COLOR) {
        hr = OleTranslateColor(pOptions->clrBackPlot, NULL, &newColor);
        if ( SUCCEEDED( hr ) ) {
            m_clrBackPlot = newColor;
        }
    }

    if (pOptions->clrFore != NULL_COLOR) {
        hr = OleTranslateColor(pOptions->clrFore, NULL, &newColor);
        if ( SUCCEEDED( hr ) ) {
            m_clrFgnd = newColor;
        }
    }

    hr = OleTranslateColor(pOptions->clrGrid, NULL, &newColor);
    if ( SUCCEEDED( hr ) ) {
        m_clrGrid = newColor;
    }

    hr = OleTranslateColor(pOptions->clrTimeBar, NULL, &newColor);
    if ( SUCCEEDED( hr ) ) {
        m_clrTimeBar = newColor;
    }
}

LPCTSTR 
CSysmonControl::GetDataSourceName ( void )
{
    LPTSTR  szReturn = NULL;
    CLogFileItem* pLogFile = NULL;

    if ( sysmonLogFiles == m_pObj->m_Graph.Options.iDataSourceType ) {

        pLogFile = FirstLogFile();
    
        if ( NULL != pLogFile ) {
            szReturn = const_cast<LPTSTR>((LPCTSTR)pLogFile->GetPath());
        }
    }
    // TodoLogFiles:  Use  the m_DataSourceInfo.szDataSourceName field?  When multi-file?
    return szReturn;
}


HRESULT 
CSysmonControl::GetSelectedCounter ( CGraphItem** ppItem )
{
    HRESULT hr = E_POINTER;

    if ( NULL != ppItem ) {
        *ppItem = m_pSelectedItem;
        hr = NOERROR;
    }

    return hr;
}

DWORD
CSysmonControl::BuildLogFileList ( 
    LPWSTR  szLogFileList,
    BOOL    bIsCommaDelimiter,
    ULONG*  pulBufLen )
{
    DWORD           dwStatus = ERROR_SUCCESS;
    ULONG           ulListLen;
    CLogFileItem*   pLogFile = FirstLogFile();
    LPCWSTR         szThisLogFile = NULL;
    LPWSTR          szLogFileCurrent = NULL;

    const WCHAR     cwComma = L',';

    if ( NULL != pulBufLen ) {
        ulListLen = 0;
        while (pLogFile != NULL) {
            szThisLogFile= pLogFile->GetPath();
            ulListLen += (lstrlen(szThisLogFile) + 1);
            pLogFile = pLogFile->Next();
        }
        ulListLen ++; // for the single final NULL character.
    
        if ( ulListLen <= *pulBufLen ) {
            if ( NULL != szLogFileList ) {
                ZeroMemory(szLogFileList, (ulListLen * sizeof(WCHAR)));
                pLogFile = FirstLogFile();
                szLogFileCurrent = (LPTSTR) szLogFileList;
                while (pLogFile != NULL) {
                    szThisLogFile      = pLogFile->GetPath();
                    lstrcpy(szLogFileCurrent, szThisLogFile);
                    szLogFileCurrent  += lstrlen(szThisLogFile);
                    *szLogFileCurrent = L'\0';
                    pLogFile     = pLogFile->Next();
                    if ( bIsCommaDelimiter && NULL != pLogFile ) {
                        // If comma delimited, replace the NULL char with a comma
                        *szLogFileCurrent = cwComma;
                    }
                    szLogFileCurrent ++;
                }
                if ( !bIsCommaDelimiter ) {
                    *szLogFileCurrent = L'\0';
                }
            }
        } else if ( NULL != szLogFileList ) {
            dwStatus = ERROR_MORE_DATA;
        }    
        *pulBufLen = ulListLen;
    } else {
        dwStatus = ERROR_INVALID_PARAMETER;
        assert ( FALSE );
    }

    return dwStatus;
}

HRESULT   
CSysmonControl::LoadLogFilesFromMultiSz (
    LPCWSTR  szLogFileList )
{
    HRESULT hr = NOERROR;
    LPWSTR  szNext = NULL;

    szNext = const_cast<LPWSTR>(szLogFileList);

    while ( NULL != szNext ) {
        hr = AddSingleLogFile ( szNext );
        if ( FAILED ( hr ) ) {
            break;
        }
        szNext += lstrlen (szNext) + 1;
    }

    return hr;
}


void
CSysmonControl::ClearErrorPathList ( void )
{
    if ( NULL != m_szErrorPathList ) {
        delete m_szErrorPathList;
    }    
    m_szErrorPathList = NULL;
    m_dwErrorPathListLen = 0;
    m_dwErrorPathBufLen = 0;
}

LPCWSTR
CSysmonControl::GetErrorPathList ( DWORD* pdwListLen )
{
    if ( NULL != pdwListLen ) {
        *pdwListLen = m_dwErrorPathListLen;
    }
    return m_szErrorPathList;
}

DWORD
CSysmonControl::AddToErrorPathList ( LPCWSTR  szPath )
{
    DWORD   dwStatus = ERROR_SUCCESS;
    DWORD   dwPathLen = 0;
    LPWSTR  szNewBuffer = NULL;
    LPWSTR  szNextCounter = NULL;


    const LPCWSTR   cszNewLine = L"\n";
    const DWORD     cdwAddLen = 2048;

    if ( NULL != szPath ) {
        dwPathLen = lstrlen ( szPath );

        if ( cdwAddLen > dwPathLen ) { 

            if ( m_dwErrorPathBufLen < m_dwErrorPathListLen + dwPathLen + 1 ) {
                m_dwErrorPathBufLen += cdwAddLen;

                szNewBuffer = new WCHAR[m_dwErrorPathBufLen];

                if ( NULL != szNewBuffer ) {
                    if ( NULL != m_szErrorPathList ) {
                        memcpy ( szNewBuffer, m_szErrorPathList, m_dwErrorPathListLen * sizeof(WCHAR) );
                        delete m_szErrorPathList;
                    }
                    m_szErrorPathList = szNewBuffer;
                } else {
                    dwStatus = ERROR_OUTOFMEMORY;
                }
            } 

            if ( ERROR_SUCCESS == dwStatus ) {
                // Point to ending null character.
                szNextCounter = m_szErrorPathList;
                if ( 0 < m_dwErrorPathListLen ) {
                    szNextCounter += m_dwErrorPathListLen - 1;
                }
                if ( 0 == m_dwErrorPathListLen ) {
                    //Increment first counter length for the ending null character.
                    m_dwErrorPathListLen++;
                } else { 
                    memcpy ( szNextCounter, cszNewLine, sizeof(cszNewLine) );
                    szNextCounter++;
                    m_dwErrorPathListLen++;          // Increment 1 for the comma
                }
                lstrcpy ( szNextCounter, szPath );
                m_dwErrorPathListLen += dwPathLen; 
            }
        } else { 
            dwStatus = ERROR_INVALID_PARAMETER;
        }
    } else { 
        dwStatus = ERROR_INVALID_PARAMETER;
    }

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\statbar.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    statbar.h

Abstract:

    <abstract>

--*/

#ifndef _STATBAR_H_
#define _STATBAR_H_

#define SZ_HRTIME_FORMAT    TEXT("%1d%s%02d%s%02d")
#define SZ_MINTIME_FORMAT   TEXT("%1d%s%02d")
#define SZ_DAYTIME_FORMAT   TEXT("%1dD %1d%s%02d")

#define E_MEDIUM_VALUE      999999.999
#define E_LARGE_VALUE       9999999999.0
#define E_TOO_LARGE_VALUE   1.0E+20

#define SZ_VALUE_TOO_HIGH       TEXT("+ + + +")
#define SZ_VALUE_TOO_LOW        TEXT("- - - -")

#define LABEL_MARGIN 12
#define VALUE_MARGIN 4
#define RECT_BORDER 1
#define LINE_SPACING (2 * RECT_BORDER + 4)

#define STAT_LAST   0
#define STAT_AVG    1
#define STAT_MIN    2
#define STAT_MAX    3
#define STAT_TIME   4
#define STAT_ITEM_CNT   5

// Structure for one item
typedef struct _STAT_ITEM {
   INT      xPos ;
   INT      yPos ;
   INT      xLabelWidth;
   double   dNewValue;
   double   dValue ;
   INT      iInitialized ;
   DWORD    dwCounterType;
   } STAT_ITEM, *PSTAT_ITEM ;

class CSysmonControl;
class CGraphItem;

class CStatsBar
{
    private:

        enum eStatFormat {
            eMinimumWidth = 10,
            eSmallPrecision = 3,
            eMediumPrecision = 0,
            eLargePrecision = 4,
            eIntegerPrecision = 0
        };
        
        void DrawValues (HDC hDC, BOOL bForce);

        CSysmonControl  *m_pCtrl;   
        STAT_ITEM       m_StatItem[STAT_ITEM_CNT];
        RECT            m_Rect;
        INT             m_iFontHeight;
        INT             m_iValueWidth;
        PCGraphItem     m_pGraphItemToInit;     
   
    
    public:

        CStatsBar (void);
        ~CStatsBar (void);

        BOOL Init (CSysmonControl *pCtrl, HWND hWnd);
        void SizeComponents(LPRECT pRect);
        void SetTimeSpan(double dSeconds);
        INT  Height (INT iMaxHeight, INT iMaxWidth);
        void ChangeFont(HDC hDC);

        void Draw (HDC hDC, HDC hAttribDC, PRECT prcUpdate);
        void Update(HDC hDC, CGraphItem* pGraphItem);
        void Clear( void );
        void GetUpdateRect( PRECT pRect ) { *pRect = m_Rect; } 
};

typedef CStatsBar *PSTATSBAR;

#endif // _STATBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\srcprop.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    srcprop.h

Abstract:

    Data Source Property Page

--*/

#ifndef _SRCPROP_H_
#define _SRCPROP_H_

#include <sqlext.h>
#include "timerng.h"
#include "smonprop.h"

// Dialog Controls
#define IDD_SRC_PROPP_DLG       400
#define IDC_SRC_REALTIME        401
#define IDC_SRC_LOGFILE         402
#define IDC_SRC_SQL             403     // IDH value is out of sync, should still work
#define IDC_SRC_GROUP           405
#define IDC_TIME_GROUP          406
#define IDC_TIMERANGE           407
#define IDC_TIMESELECTBTN       408
#define IDC_STATIC_TOTAL        410
#define IDC_STATIC_SELECTED     411

#define IDC_LIST_LOGFILENAME    412
#define IDC_ADDFILE             413
#define IDC_REMOVEFILE          414

#define IDC_DSN_COMBO           416
#define IDC_LOGSET_COMBO        417
#define IDC_STATIC_DSN          418
#define IDC_STATIC_LOGSET       419

#define REALTIME_SRC       1
#define LOGFILE_SRC        2

typedef struct _LogItemInfo {
    struct _LogItemInfo*   pNextInfo;   // For "Deleted" list
    ILogFileItem*       pItem;
    LPTSTR      pszPath;
} LogItemInfo, *PLogItemInfo;

// Data source property page class
class CSourcePropPage : public CSysmonPropPage
{
    public:
        
                CSourcePropPage(void);
        virtual ~CSourcePropPage(void);

        virtual BOOL Init( void );

    protected:

        virtual BOOL    GetProperties(void);   //Read current properties
        virtual BOOL    SetProperties(void);   //Set new properties
        virtual BOOL    InitControls(void);
        virtual void    DeinitControls(void);       // Deinitialize dialog controls
        virtual void    DialogItemChange(WORD wId, WORD wMsg); // Handle item change
        virtual HRESULT EditPropertyImpl( DISPID dispID);   // Set focus control      

    private:

        enum eConstants {
            ePdhLogTypeRetiredBinary = 3
        };
        
                DWORD   OpenLogFile(void); // Open log file and get time range
                void    SetTimeRangeCtrlState ( BOOL bValidLogFile, BOOL bValidLogFileRange );  
                BOOL    AddItemToFileListBox ( PLogItemInfo pInfo );
                BOOL    RemoveItemFromFileListBox ( void );
                void    OnLogFileChange ( void );
                void    OnSqlDataChange ( void );
                void    InitSqlDsnList(void);
                void    InitSqlLogSetList(void);
                void    SetSourceControlStates(void);
                void    LogFilesAreValid ( PLogItemInfo pNewInfo, BOOL& rbNewIsValid, BOOL& rbExistingIsValid );

                DWORD   BuildLogFileList (
                            HWND    hwndDlg,
                            LPWSTR  szLogFileList,
                            ULONG*  pulBufLen );

        PCTimeRange m_pTimeRange;

        // Properties
        DataSourceTypeConstants m_eDataSourceType;
        BOOL        m_bInitialTimeRangePending;
        LONGLONG    m_llStart;
        LONGLONG    m_llStop;
        LONGLONG    m_llBegin;
        LONGLONG    m_llEnd;
        HLOG        m_hDataSource;
        DWORD       m_dwMaxHorizListExtent;
        TCHAR       m_szSqlDsnName[SQL_MAX_DSN_LENGTH + 1];       
        TCHAR       m_szSqlLogSetName[MAX_PATH];    // Todo:  MAX_PATH correct limit?
        PLogItemInfo    m_pInfoDeleted;


        // Property change flags
        BOOL    m_bLogFileChg;
        BOOL    m_bSqlDsnChg;
        BOOL    m_bSqlLogSetChg;
        BOOL    m_bRangeChg;
        BOOL    m_bDataSourceChg;
};
typedef CSourcePropPage *PCSourcePropPage;

// {0CF32AA1-7571-11d0-93C4-00AA00A3DDEA}
DEFINE_GUID(CLSID_SourcePropPage,
        0xcf32aa1, 0x7571, 0x11d0, 0x93, 0xc4, 0x0, 0xaa, 0x0, 0xa3, 0xdd, 0xea);

#endif //_SRCPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\controls\smonctrl\statbar.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    statbar.cpp

Abstract:

    Implementation of the value bar class.

--*/

#include <stdio.h>
#include "polyline.h"
#include "statbar.h"

#define MAX_STAT_LABEL_LEN 32
static TCHAR    aszItemLabel[STAT_ITEM_CNT][MAX_STAT_LABEL_LEN];

static BOOLEAN  fInitDone = FALSE;

CStatsBar::CStatsBar(void)
:   m_pCtrl ( NULL ),
    m_iFontHeight ( 0 ),
    m_iValueWidth ( 0 ),
    m_pGraphItemToInit ( NULL )
{
    memset (&m_Rect, 0, sizeof(m_Rect));
}

CStatsBar::~CStatsBar(void)
{
}

BOOL CStatsBar::Init (PSYSMONCTRL pCtrl, HWND /* hWnd */ )
{
    INT         i;

    // save pointer to primary object
    m_pCtrl = pCtrl;

    // First time through, load the item labels
    if (!fInitDone) {
        fInitDone = TRUE;

        for (i=0; i<STAT_ITEM_CNT; i++) {
            LoadString(g_hInstance, (IDS_STAT_BASE + i), aszItemLabel[i], MAX_STAT_LABEL_LEN);
        }
    }

    // Initialze the stat values
    Clear();

    return TRUE;
}

        
void CStatsBar::SizeComponents(LPRECT pRect)
{
    // Just save the rectangle
    m_Rect = *pRect;
}

void CStatsBar::SetTimeSpan(double dSeconds)
{
    m_StatItem[STAT_TIME].dNewValue = dSeconds;
}

    
void CStatsBar::Update(HDC hDC, PCGraphItem pGraphItem)
{
    double dMin, dMax, dAvg, dVal;
    PSTAT_ITEM  pItem;
    INT     i;
    HRESULT hr;
    PDH_STATUS  stat;
    LONG    lCtrStat;

    // if no space assigned, return
    if (m_Rect.top == m_Rect.bottom) {
        m_pGraphItemToInit = pGraphItem;
        m_StatItem[0].iInitialized = 0;
        return;
    }

    if (pGraphItem == NULL) {
        pItem = &m_StatItem[0];
        for (i=0; i<STAT_ITEM_CNT-1; i++, pItem++) {
            pItem->dNewValue = 0.0;
            pItem->iInitialized = 0;
        }
    } else {

        stat = pGraphItem->GetValue(&dVal, &lCtrStat);
        if (stat == 0 && IsSuccessSeverity(lCtrStat))
            m_StatItem[STAT_LAST].dNewValue = dVal;
        else
            m_StatItem[STAT_LAST].dNewValue = 0.0;
            
        hr = pGraphItem->GetStatistics(&dMax, &dMin, &dAvg, &lCtrStat);
        if (SUCCEEDED(hr) && IsSuccessSeverity(lCtrStat)) {
            m_StatItem[STAT_MIN].dNewValue = dMin;
            m_StatItem[STAT_MAX].dNewValue = dMax;
            m_StatItem[STAT_AVG].dNewValue = dAvg;
        } else {
            m_StatItem[STAT_MIN].dNewValue = 0.0;
            m_StatItem[STAT_MAX].dNewValue = 0.0;
            m_StatItem[STAT_AVG].dNewValue = 0.0;
        }
        m_StatItem[0].dwCounterType = pGraphItem->m_CounterInfo.dwType;
        m_StatItem[0].iInitialized = 1;
    }

    // hDC is null if updating only values.
    if (hDC != NULL) {
        SetBkColor(hDC, m_pCtrl->clrBackCtl());
        SetTextColor(hDC, m_pCtrl->clrFgnd());
        DrawValues(hDC,FALSE);
    }
}       

void CStatsBar::Clear( void )
{
    PSTAT_ITEM  pItem;
    INT     i;

    pItem = &m_StatItem[0];
    f